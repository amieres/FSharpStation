[{"name":"","content":"READ ME!\n\nJust put all your code in here (all your F# code, that is).\n\n- Organize your code in snippets group them by theme, keep them all in one place, all your projects big and small\n- Use snippet dependencies to assemble your solution\n- Create one big code infrastructure that can be reused and refined over and over.\n- Code, try, test, compile, run your code\n- Intellisense (for now):\n    - Tooltips (F2)\n    - Error highlighting\n    - Auto completion\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n\n\n- Evaluate F# does not return the last value calculated, only what is printed to the output\n\n- Ctrl-Space for autocomplete\n- F2         for tooltips\n- Parse F# is sometimes necessary","predecessors":[],"id":{"$":0,"Item":"bc0d0abf-9c94-48bb-b46e-92e5d539b172"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"PENDING:\n- When compiling FSharpStation:\nWebSharper warning: Failed to load return type 'FSSGlobal.FSAutoComplete+CommandResponse+Kind, FSAutoCompleteDll' \nto verify encoding to JSON. at FSSGlobal.FSAutoComplete.sendMessageRpc\n- Allow plugable Add in commands\n- Separate parsing and compilation errors from output and other message windows like javascript, and F# and others\n- Use properties to enable/disable actions like Compile WS, Run WS, Evaluate F#\n- Click on Error Message jumps to location\n- Highlight snippets with errors\n- Do not parse/highlight non F# code\n- Add global search \n- back/forward button (using # preferrably)\n- Flush FsiExe MailBoxProcessor if 5 messages are waiting / or add a button for flushing\n- Transfer server code to FSharpStation\n- Keep count/ increase pending Http requests to avoid blocking the server\n- Intellisense\n    - Jump to definition\n    - Function Helps\n    - Parameters\n- ERRORS:   \n    - Bootstrap bleeds into WS Result\n    - Add Code hides children\n    - TypeError: Cannot read property 'appendChild' of undefine\n    - Fix Communications issue (kind of fixed there is a discrepancy between 60 seconds timeout and 100 seconds timeout resulting in 40 dead seconds)\n    - Incomplete Parse when typing fast\n\n- Give it an icon that says F# Station\n\n- Have non indenting nested elements just for folder organization    \n    - it could be a flag in the name/code\n    - it could be an external attribute, like MIME type/subtype \n    - it could be related to the other type of content considered for the future\n        - Allow non text entries: like images, documents, links(text?) and other resources, maybe using 64 encoding\n        - Allow other modes for some entries: MarkDown, html, etc. \n        - That way different type of content could be integrated into code with different techniques for merging: css, html, javascript, c#, MarkDown and others\n        - Also it could be used as input for some code (although not too clear on how to do this, it may require serving the data as a web file)\n            - To store it in server it would make sense to split the snippets as entry in a DB so the server would not need to read a whole file\n              just to serve a snippet\n            - Some snippet could be generated from others: for instance as js from F#, the snippet maintains the dependence and could also maintain the ages\n              and know when a snippet needs to be regenerated.\n- Create website load/upload/invoke/precompiled code\n- The editor could have dual mode: server DB and local file\n    - For a website definition it would need to track read/write access to snippets\n\n- Eliminate fixit2 hack hardcoded namespace dependency\n\n- Implement Tab(s) & Application deployment including configurable editor(s)\n- Block non local use of Evaluate F# (unless logged in and with permission)\n- add HTTPS\n- add # routing to get to specific snippets\n- Give it a web site look\n\nSOLVED:\n- FsTranslator loads from scratch every time, change it so it stays in memory as an agent\n- FsTranslator accumulates assemblies in memory - separate into an executable so it can be cleaned up\n- Speed up snippet list interaction: used ResetableMemoize\n- Speed up code construction for reparse\n- Intellisense\n    - Autocompletion\n    - Code tips\n    - Make tooltips pop-up not Alert\n    - Error highlight\n- Reissue FSharpStation awaitRequestFor\n- Create splitter template: grid template with splitters included\n- Change the title so that it says F# Station\n- Implement command start: webserver + editor\n- Think how to mix WebSharper and no WebSharper code without duplicating: they can be shared and use #define WEBSHARPER to add [< JavaScript >]\n- Get rid of undefined message when running JS and maybe show possible result value\n- Get rid of no output warning when Evaluating FS and say Done!\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n- Capture Asynchronous exceptions\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.\n- ERRORS:    \n    - Jump to top of document when fast editing. Fixed it with some clever counters but it feels as if there should be a better way maybe using Event and FRP\n","predecessors":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true,"level":0,"properties":{}},{"name":"FSSGlobal","content":"#nowarn \"1182\"\n#nowarn \"40\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\FSharp.Core.dll\"\n#if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSSGlobal   =\n#else\nnamespace FSSGlobal\n#endif\n","predecessors":[],"id":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"expanded":true,"level":0,"properties":{}},{"name":"F# Code","content":"// Code to be evaluated using FSI: `Evaluate F#`","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"id":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"expanded":true,"level":0,"properties":{}},{"name":"open WebSharper","content":"#if WEBSHARPER\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Main.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Web.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Sitelets.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Client\ntype on   = WebSharper.UI.Next.Html.on\ntype attr = WebSharper.UI.Next.Html.attr\n#endif","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true,"level":0,"properties":{}},{"name":"Useful","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Useful =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"expanded":true,"level":0,"properties":{}},{"name":"Result, Wrap","content":"open System\n#nowarn \"1178\"\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\n    let defaultWith f =\n        function\n        | Some x -> x\n        | None   -> f()\n\n    let call v = \n        function\n        | None   -> None\n        | Some f -> f v |> Some\n\n    let iterF v = \n        function\n        | None   -> ()\n        | Some f -> f v\n\n    let iterFO vO fO = \n        match vO, fO with\n        | Some v, Some f -> f v\n        | _     , _      -> ()\n\n    let apply vO fO =\n        match vO, fO with\n        | Some v, Some f -> f v |> Some\n        | _     , _      -> None\n\n    let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\n      \n\n//#nowarn \"25\"\ntype ErrMsg = \n    abstract member ErrMsg   : string\n    abstract member IsWarning: bool\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ExceptionThrown(exn:Exception) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" exn\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrOptionIsNone() =\n    interface ErrMsg with\n        member this.ErrMsg   : string = \"Option is None\"\n        member this.IsWarning: bool   = false\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype ErrSimple(msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Result<'TSuccess> = Result of 'TSuccess option * ErrMsg list     \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Result =\n    let inline succeed             x       = Result (Some x           , [  ]             )\n    let inline succeedWithMsg      x  m    = Result (Some x           , [m ]             )\n    let inline succeedWithMsgs     x  ms   = Result (Some x           ,  ms              )\n    let inline fail                   m    = Result (None             , [m ]             )\n    let inline failWithMsgs           ms   = Result (None             ,  ms              )\n    let inline map       f (Result(o, ms)) = Result (o |> Option.map f,  ms              )\n    let inline mapMsg    f (Result(o, ms)) =        (o                ,  ms |> List.map f)\n    let inline mapMsgs   f (Result(o, ms)) =        (o                ,  ms |>          f)\n    let inline getOption   (Result(o, _ )) =         o                   \n    let inline getMsgs     (Result(_, ms)) =                             ms\n    let inline mergeMsgs              ms r = Result (r |> mapMsgs   ((@) ms) )\n    let inline combine     (Result(_, ms)) = mergeMsgs ms\n    let inline bind      f (Result(o, ms)) = \n        match o with\n        | Some x   -> match f x with Result(o2, ms2) -> Result(o2, ms @ ms2)\n        | None     -> Result(None, ms)\n    let inline apply (Result(fO, fMs))  (Result(o , ms)) = \n        match fO, o with\n        | Some f, Some x -> Result(f x |> Some, fMs @ ms)\n        | _              -> Result(None       , fMs @ ms)\n\n\n    let (|Success|Failure|) =\n        function \n        | Result(Some x, ms) -> Success (x, ms) \n        | Result(None  , ms) -> Failure     ms  \n\n    let x = function\n              | Success (x, ms) -> \"yes\"\n              | Failure     ms  -> \"No\"\n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n    let failException e = ExceptionThrown(e) :> ErrMsg\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n    let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind (tryCall r) w\n        member inline this.Using      (disposable, restOfCExpr) = using disposable restOfCExpr\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f()\n        member inline this.Combine    (a, b)                    = combine a b\n//        member this.Run        (f)                       = f\n//        member this.While(guard, body) =\n//            if not (guard()) \n//            then this.Zero() \n//            else this.Bind( body(), fun () -> \n//                this.While(guard, body))  \n//        member this.For(sequence:seq<_>, body) =\n//            this.Using(sequence.GetEnumerator(),fun enum -> \n//                this.While(enum.MoveNext, \n//                    this.Delay(fun () -> body enum.Current)))\n\n    let result = ropBuilder()\n//    let inline flow_ () = new ropBuilder ()\n\n    let fromChoice context c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n\n    let toOption (Result(o, _)) = o\n\n    let tryProtection() : Result<unit> = succeed ()\n\n    let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \n    let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \n            \n    let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let getMessages   (ms: ErrMsg list) = ms |> List.map (fun m -> m.ErrMsg) |> String.concat \"\\n\"\n    let countMessages (ms: ErrMsg list) =\n        if ms = [] then \"\" else\n        let errors   = ms |> List.filter(fun m -> m.IsWarning |> not)\n        let warnings = ms |> List.filter(fun m -> m.IsWarning       )\n        match errors.Length, warnings.Length with\n        | 0, 0 -> sprintf \"%s\"\n        | 1, 0 -> sprintf \"%s\"\n        | 0, 1 -> sprintf \"%s\"\n        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n        | e, 0 -> sprintf \"%d errors\\n%s\" e\n        | 0, w -> sprintf \"%d warnings\\n%s\" w\n        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n        <| getMessages ms\n \nopen Result\n\ntype Wrap<'T> =\n| WResult of Result<'T>\n| WAsync  of Async<'T>\n| WAsyncR of Async<Result<'T>>\n| WSimple of 'T\n| WOption of 'T option\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Wrap =\n    let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\n\n    let wb2arb ms = \n        function\n        | WAsync       ab  -> async { let!   b = ab\n                                      return succeedWithMsgs b                   ms }\n        | WAsyncR     arb  -> async { let!   rb = arb                               \n                                      return rb |> mergeMsgs                     ms }\n        | WResult      rb  -> async { return rb |> mergeMsgs                     ms }\n        | WSimple       b                                                           \n        | WOption (Some b) -> async { return succeedWithMsgs b                   ms }\n        | WOption None     -> async { return failWithMsgs      (errOptionIsNone::ms)}\n\n    let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \n        try f a \n        with e -> failException e |> fail |> WResult\n\n    let bind (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\n        match wa with\n        | WSimple         a       \n        | WOption(Some    a)       \n        | WResult(Success(a, [])) -> tryCall f a\n        | WOption None            -> None            |> WOption\n        | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \n        | WResult(Success(a, ms)) -> tryCall f a\n                                     |> function\n                                     | WSimple         b              \n                                     | WOption(Some    b     ) -> succeedWithMsgs b  ms             |> WResult \n                                     | WOption None            -> failWithMsgs (errOptionIsNone::ms)|> WResult\n                                     | WResult(Success(b, [])) -> succeedWithMsgs b  ms             |> WResult \n                                     | WResult(Success(b, m2)) -> succeedWithMsgs b (ms @ m2)       |> WResult \n                                     | WResult(Failure    m2)  -> failWithMsgs      (ms @ m2)       |> WResult \n                                     | WAsync  ab              -> async { let!  b = ab\n                                                                          return succeedWithMsgs b ms\n                                                                  } |> WAsyncR\n                                     | WAsyncR arb             -> async { let! rb = arb\n                                                                          return mergeMsgs ms rb\n                                                                  } |> WAsyncR\n        | WAsync         aa       -> async {\n                                         let! a  = aa\n                                         return! tryCall f a |> wb2arb []\n                                     } |> WAsyncR\n        | WAsyncR       ara       -> async {\n                                         let! ar  = ara\n                                         let  arb = match ar with\n                                                    | Success(a, ms) -> tryCall f a |> wb2arb ms\n                                                    | Failure    ms  -> async { return failWithMsgs ms }\n                                         return! arb\n                                     } |> WAsyncR\n    let Return = WSimple \n    let map  (f: 'a -> 'b  ) = bind (f >> Return)     \n\n    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n        let wb = tryCall f a\n        match wb with\n        | WSimple _\n        | WOption _               -> wb |> wb2arb []\n        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n        | WAsync  ab              -> async { let!   b = ab\n                                             return succeed b }\n        | WAsyncR arb              -> arb\n\n    let addMsgs errOptionIsNone ms wb =\n        if ms = [] then wb else\n        match wb with\n        | WSimple          v       \n        | WOption (Some    v)      -> WResult (succeedWithMsgs                        v ms)\n        | WOption (None     )      -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n        | WAsync           va      -> async {\n                                        let! v = va\n                                        return succeedWithMsgs v ms\n                                      } |> WAsyncR\n        | WAsyncR          vra     -> async {\n                                        let! vr = vra\n                                        return vr                    |> Result.mergeMsgs ms\n                                      } |> WAsyncR\n\n    let combine errOptionIsNone wa wb =\n        match wa with\n        | WSimple          _\n        | WOption (Some    _)\n        | WResult (Result (_, []))\n        | WAsync           _       -> wb\n        | WAsyncR          _       -> wb\n        | WOption (None     )      -> wb |> addMsgs errOptionIsNone [errOptionIsNone]\n        | WResult (Result(_, ms))  -> wb |> addMsgs errOptionIsNone ms\n\n    type Builder() =\n//        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \n        member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \n        member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \n        member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WResult |> bind restOfCExpr \n        member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WOption |> bind restOfCExpr \n        member inline this.Zero         ()  = WSimple ()\n        member inline this.Return       (x) = WSimple x\n        member inline this.ReturnFrom   (w) = w\n//        member inline this.ReturnFrom   (w) = WAsync  w\n//        member inline this.ReturnFrom   (w) = WResult w\n//        member inline this.ReturnFrom   (w) = WOption w        \n        member inline this.Delay        (f) = f()\n        member        this.Combine   (a, b) = combine errOptionIsNone a b\n        member        this.Using (resource, body: 'a -> Wrap<'b>) =\n            async.Using(resource, wrapper2Async body) |> WAsyncR\n                    \n    let wrapper = Builder()\n\n    let getResult callback (wb: Wrap<'T>) =\n        match wb with\n        | WSimple      s  -> s               |> succeed                                      |> callback\n        | WOption(Some s) -> s               |> succeed                                      |> callback\n        | WOption None    -> errOptionIsNone |> fail                                         |> callback\n        | WResult      rb -> rb                                                              |> callback\n        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v         |> callback), \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n\n    let inline getAsyncR (wb: Wrap<'T>) =\n        match wb with\n        | WAsync      va  -> async {\n                               let! v = va\n                               return      succeed                           v}\n        | WSimple     v   -> async.Return (succeed                           v)\n        | WOption     v   -> async.Return (Result.fromOption errOptionIsNone v)\n        | WResult     v   -> async.Return                                    v\n        | WAsyncR     vra -> vra\n        \n    let inline getAsyncWithDefault f (wb: Wrap<'T>) = \n        async {\n            let!   vR = getAsyncR wb\n            return vR |> Result.withError f\n        }\n\n    let inline getAsync w =\n        match w with\n        | WAsync      va  ->              va\n        | WSimple     v   -> async.Return v\n        | WOption     vo  -> async {\n                                return\n                                    match vo with \n                                    | Some v         -> v\n                                    | None           -> raise (exn(getMessages [errOptionIsNone]))\n                             }\n        | WResult     vr  -> async {\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n        | WAsyncR     vra -> async {\n                                let! vr = vra\n                                return\n                                    match vr with \n                                    | Success (v, _) -> v\n                                    | Failure ms     -> raise (exn(getMessages ms))\n                             }\n//    let call wb = wb |> getR Rop.notifyMessages\n    let start (printMsg: string->unit) (w: Wrap<unit>) =\n        w\n        |> getAsyncR\n        |> fun asy -> Async.StartWithContinuations\n                        (asy \n                       , Result.mapMsgs Result.getMessages\n                         >> function\n                            | Some _, msgs -> msgs\n                            | None  , msgs -> printfn \"Failed!\" ; msgs\n                         >> sprintf \"%s\" >> printMsg\n                       ,    sprintf \"%A\" >> printMsg\n                       ,    sprintf \"%A\" >> printMsg)\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR (w: Wrap<_>) =\n        w\n        |> getAsyncR\n        |> Async.RunSynchronously\n    let runSynchronouslyO count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyR\n        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n    let runSynchronouslyS count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyO count\n        |> function\n           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n           \n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\ntype Wrap<'T> with\n    static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},"expanded":true,"level":0,"properties":{}},{"name":"extract, now, Async","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},"expanded":true,"level":0,"properties":{}},{"name":"REGEX","content":"#if WEBSHARPER\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n#endif\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},"expanded":true,"level":0,"properties":{}},{"name":"memoize","content":"#if WEBSHARPER\n[< Inline >]\n#endif\nlet memoize f = \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x -> \n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n             \ntype ResetableMemoize(f) =             \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    member this.ClearCache() = cache.Clear()\n    #if WEBSHARPER\n    [< Inline >]\n    #endif\n    member this.Call x =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n    ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},"expanded":true,"level":0,"properties":{}},{"name":"separateDirectives","content":"type PreproDirective =\n| PrepoR      of string\n| PrepoDefine of string\n| PrepoLoad   of string\n| PrepoLine   of string //* int\n| PrepoNoWarn of string\n| PrepoI      of string\n| PrepoIf     of string\n| PrepoElse   \n| PrepoEndIf\n| PrepoLight  of bool\n| PrepoOther  of string\n| NoPrepo\n\nlet separatePrepros removePrepoLine (code:string[]) =\n    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n    let  comment = ((+)\"//\") \n    let  preL    = if removePrepoLine then comment else id \n    let  prepro (line:string) = match true with \n                                | true when line.StartsWith(\"#define\") -> (comment line, line |> define |> PrepoDefine)\n                                | true when line.StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                                | true when line.StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                | true when line.StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                                | true when line.StartsWith(\"# \"     ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#line\"  ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                                | true when line.StartsWith(\"#if\"    ) -> (        line, line           |> PrepoIf    )\n                                | true when line.StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                                | true when line.StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                                | true when line.StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                                | true when line.StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                                | _                                    -> (        line,                   NoPrepo    ) \n    code |> Array.map prepro\n    \nlet separateDirectives (fsNass:(string * PreproDirective) seq) =\n    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n    code, assembs, defines, prepoIs, nowarns\n\n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},"expanded":true,"level":0,"properties":{}},{"name":"Save File","content":"open System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\nlet inline saveFile (file:string) (content: string) =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        backupFile file\n        File.WriteAllText(file, content)\n    } \n","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},"expanded":true,"level":0,"properties":{}},{"name":"type ActionBar","content":"open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"id":{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},"expanded":true,"level":0,"properties":{}},{"name":"UsefulDotNet","content":"module UsefulDotNet =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"expanded":false,"level":0,"properties":{}},{"name":"Regex, Regexs","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    if input = null then None else\n    try \n        let m = Regex.Match(input, pattern)\n        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n        else None\n    with e -> None\n\nlet (|Regexs|) pattern input =\n    if input = null then [| |] else\n    try \n        let ms = Regex.Matches(input, pattern)\n        [| for m in ms do yield m.Value |] \n    with e -> [| |]\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},"expanded":true,"level":0,"properties":{}},{"name":"fSharpError2TranspilerError","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\nopen Microsoft.FSharp.Compiler\nopen Useful\n\ntype FSharpErrors =\n    | WarningFSharp                 of string\n    | ErrFSharp                     of string\nwith interface ErrMsg with\n        member this.ErrMsg    = sprintf \"%A\"this\n        member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\n\nlet getIndentFile input =\n    match input with\n    | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\n    | _                                                 -> 0         , input\n   \nlet fSharpError2TranspilerError (error : FSharpErrorInfo) =\n    let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \n    sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \n       file \n       error.StartLineAlternate (error.StartColumn - indent) \n       error.EndLineAlternate   (error.EndColumn   - indent) \n       error.Subcategory error.ErrorNumber error.Message\n    |> (if   error.Severity = FSharpErrorSeverity.Error  \n        then ErrFSharp     \n        else WarningFSharp\n       )\n    :> ErrMsg\n    \n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},"expanded":true,"level":0,"properties":{}},{"name":"ResourceAgent","content":"open Useful\n\ntype ResourceAgent<'T, 'C when 'C : equality>(restartAfter:int, ctor: 'C option ->'T, ?cleanup, ?isAlive, ?configuration: 'C) =\n    let mutable configuration = configuration\n    let mutable resource = ctor configuration\n    let respawn() =\n        cleanup |> Option.iter (fun clean -> clean resource) \n        resource <- ctor configuration\n    let agent    = \n        MailboxProcessor.Start(fun inbox ->\n            async {\n               while true do\n                 try\n                     for i in 1 .. restartAfter do\n                         let! config, work = inbox.Receive()\n                         isAlive |> Option.iter (fun alive -> if not (alive resource) then respawn())\n                         if config <> configuration then\n                            configuration <- config\n                            respawn()\n                         do!  work resource\n                     respawn()\n                 with _ -> respawn() \n            }\n        )\n    do agent.Error.AddHandler <| Handler (fun _ _ -> respawn())\n    member x.Process (work:'T -> Wrap<'a>, ?config) =\n        agent.PostAndAsyncReply\n            (fun reply ->\n                 (config, fun resource ->\n                          async {\n                               let! res = work resource |> Wrap.getAsyncR\n                               reply.Reply res\n                          } \n                 )\n            )\n    interface System.IDisposable with\n        member this.Dispose () =\n            try cleanup |> Option.iter (fun clean -> clean resource) with _ -> ()\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},"expanded":true,"level":0,"properties":{}},{"name":"TempFileName","content":"type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member this.Name = fn\n    interface System.IDisposable with\n        member this.Dispose() = if System.IO.File.Exists fn then System.IO.File.Delete fn\n        \n        ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},"expanded":true,"level":0,"properties":{}},{"name":"runProcess","content":"open System.Diagnostics\nopen System.Text\nopen Useful\n\nlet runProcess p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let proc        = new Process()\n    proc.StartInfo <- procStart\n    proc.Start() \n\ntype ShellExError =\n    | ShellExitCode              of int\n    | ShellOutput                of string\n    | ShellErrors                of string\n    | ShellFailWithMessage       of string\n    | ShellFinishedWithNoMessage \n    | ShellDidNotStart \n    | ShellCrashed               of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | ShellFailWithMessage msg   -> msg  \n            | ShellFinishedWithNoMessage -> \"warning - No output\"\n            | ShellOutput          msg   -> msg\n            | ShellCrashed         msg   -> \"Crashed \" + msg\n            | msg                        -> sprintf \"%A\" msg\n        member this.IsWarning =\n            match this with \n            | ShellFinishedWithNoMessage\n            | ShellOutput _              -> true\n            | _                          -> false \n\n\ntype ShellEx(startInfo: ProcessStartInfo) =\n    let proc                              = new Process()\n    let bufferOutput                      = new StringBuilder()\n    let bufferError                       = new StringBuilder()\n    let consume (sb: StringBuilder)       = \n        let v = sb.ToString()\n        sb.Clear() |> ignore\n        v\n    do  startInfo.RedirectStandardInput  <- true\n        startInfo.RedirectStandardOutput <- true\n        startInfo.RedirectStandardError  <- true\n        startInfo.UseShellExecute        <- false\n        proc.StartInfo                   <- startInfo\n        proc.EnableRaisingEvents         <- true\n        proc.OutputDataReceived.AddHandler(DataReceivedEventHandler(fun sender args -> try bufferOutput.Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n        proc.ErrorDataReceived .AddHandler(DataReceivedEventHandler(fun sender args -> try bufferError .Append(args.Data + \"\\n\") |> ignore with _ -> () ))\n//        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n    new (program, args) =             \n        let startInfo                         = new ProcessStartInfo()\n        do  startInfo.FileName               <- program\n            startInfo.Arguments              <- args\n        new ShellEx(startInfo)\n    member this.Start() = \n        let r = proc.Start() \n        proc.BeginOutputReadLine()\n        proc.BeginErrorReadLine ()\n        r\n    member this.StartAndWait() =\n        let started = this.Start()\n        proc.WaitForExit()\n        let    output  = (consume bufferOutput).Trim()\n        let    error   = (consume bufferError ).Trim()\n        (output, error, if proc.HasExited then proc.ExitCode else -99999)\n    member this.StartAndWaitR() =\n        let out, errs, exit = this.StartAndWait()\n        if exit <> 0\n        then Result.failWithMsgs\n                [ if out  <> \"\"              then yield ErrSimple (\"stdout: \" + out           , true ) :> ErrMsg\n                  if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg\n                  if errs  = \"\" || exit <> 1 then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                ]\n        else Result.succeedWithMsgs out \n                [ if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg ]\n    member this.Send(txt: string)   = proc.StandardInput.WriteLine txt\n    member this.Output  ()          = consume bufferOutput\n    member this.Error   ()          = consume bufferError\n    member this.Response(out:string, err:string)  = \n        match out.Trim(), err.Trim() with\n//        | \"\"  , \"\"  -> None\n        | good, \"\"  -> Some( Result.succeed        good                             )\n        | \"\"  , bad -> Some( Result.fail                <| ShellFailWithMessage bad )\n        | good, bad -> Some( Result.succeedWithMsg good <| ShellFailWithMessage bad )\n    member this.Response()          = this.Response(this.Output(), this.Error())\n    member this.SendAndWait(send, wait, ?onError) =\n        let eventWait = \n            if defaultArg onError false then proc.ErrorDataReceived else proc.OutputDataReceived\n            |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.succeed v else None) with _ -> None)\n        let eventAll = Event.merge eventWait  (Event.map (fun _ -> Result.fail <| ShellCrashed startInfo.FileName) proc.Exited)\n        Wrap.wrapper {\n            do! Result.tryProtection()\n            async { \n                do!    Async.Sleep 20 \n                this.Send send        } |> Async.Start\n            let!   waitedR = Async.AwaitEvent eventAll\n            let!   waited  = waitedR\n            do!    Async.Sleep 200\n            let!   res =\n                   if defaultArg onError false then \n                       this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                   else this.Response()\n                   |> Option.defaultWith (fun () -> Result.succeedWithMsg \"\" ShellFinishedWithNoMessage)\n            return res\n        }\n    member this.HasExited = try proc.HasExited with _ -> true\n    interface System.IDisposable with\n        member this.Dispose () =\n            try proc.Kill   () with _ -> ()\n            try proc.Close  () with _ -> ()\n            try proc.Dispose() with _ -> ()\n\n\nlet runProcess2 p ops =\n    let procStart   = ProcessStartInfo(p, ops)\n    let shell       = new ShellEx(procStart)\n    shell.StartAndWaitR() \n\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},"expanded":true,"level":0,"properties":{}},{"name":"copyIfMust","content":"open System.IO\n\nlet copyIfNotExistsToFile from dest =\n    let fit = FileInfo dest\n    if not fit.Exists then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToFile from dest =\n    let fit = FileInfo dest\n    let must = \n        match fit.Exists with \n        | false -> true\n        | true  ->\n            let fif = FileInfo dest\n            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n    if must then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToDir from destDir =\n    let dest = Path.Combine(destDir, Path.GetFileName(from))\n    copyIfMustToFile from dest\n    ","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},"expanded":true,"level":0,"properties":{}},{"name":"Path.Combine","content":"let inline (+/+) a b = System.IO.Path.Combine(a, b)","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[],"id":{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},"expanded":true,"level":0,"properties":{}},{"name":"CompOptions","content":"module CompOptionsModule = // needs to be in a module so (?) operator does not collide with websharper\n    \n    type CompOptionClass = \n        | OpFSharp\n        | OpWebSharper\n        | OpInternal\n    \n    type CompOption = \n        {\n            name   : string\n            unique : bool\n            opClass: CompOptionClass  \n            prefix : string\n        }\n    with\n        static member (/=) (op: CompOption, v: CompOptionValue) = op,           v\n        static member (/=) (op: CompOption, v                 ) = op, OpVText   v\n        static member (/=) (op: CompOption, v                 ) = op, OpVTextOF v\n    \n    and CompOptionValue =\n        | OpVText   of                string\n        | OpVTextOF of (CompOptions -> string)\n    with \n        member this.Value ops = \n            match this with\n            | OpVText   v  -> v\n            | OpVTextOF fo -> fo ops\n    \n    and CompOptions = CompOptions of (CompOption * CompOptionValue) []\n    with\n        member this.Pairs             =  this |> function CompOptions ops ->  ops\n        member this.Exists   f        =  this.Pairs |> Array.exists f \n        member this.Find     name     =  this.Pairs |> Array.find (fun (opT, opV) -> name = opT.name)\n        member this.FindV    name     = (this.Find name |> snd).Value this\n        member this.Contains co       =  this.Exists (fun (opT, opV) -> co   = opT                           )\n        member this.Contains v        =  this.Exists (fun (opT, opV) -> v    = opT.prefix + (opV.Value this) )\n        member this.Get      f        =  this.Pairs |> Array.filter f |> Array.map (fun (opT, opV) ->        opT.prefix + (opV.Value this) )\n        static member FSharpOptions   = fun ({opClass=cls}, _) -> cls = OpFSharp\n        static member WSharperOptions = fun ({opClass=cls}, _) -> cls = OpFSharp || cls = OpWebSharper\n        static member (?) (ops: CompOptions, name: string) = ops.FindV name\n        static member (+) (os1: CompOptions, a2: (CompOption * CompOptionValue) seq) = \n            match os1 with \n            | CompOptions a1 -> \n                a1\n                |> Array.filter (fun (opT, _) -> (not opT.unique) || (a2 |> Seq.exists (fst >> (=) opT) |> not) )\n                |> Seq.append <| a2\n                |> Seq.toArray\n                |> CompOptions\n        static member (+) (ops: CompOptions, o:   CompOption * CompOptionValue      ) = ops + [| o |]\n        static member (+) (os1: CompOptions, os2: CompOptions                       ) = match os2 with | CompOptions a2 -> os1 + a2\n    \n    let (?) (ops:CompOptions) name = ops.FindV name\n    \n    let opSnippet     = { name = \"Snippet\"     ; unique = true  ; opClass = OpInternal   ; prefix = \"++snippet:\"   }\n    let opDirectory   = { name = \"Directory\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++directory:\" }\n    let opName        = { name = \"Name\"        ; unique = true  ; opClass = OpInternal   ; prefix = \"++name:\"      }\n    let opExtension   = { name = \"Extension\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++extension:\" }\n    let opFileName    = { name = \"Filename\"    ; unique = true  ; opClass = OpInternal   ; prefix = \"++filename:\"  }\n    let opConfig      = { name = \"Config\"      ; unique = true  ; opClass = OpInternal   ; prefix = \"++config:\"    }\n    let opGenInternal = { name = \"GenInternal\" ; unique = false ; opClass = OpInternal   ; prefix = \"++\"           }\n    let opWebSharper  = { name = \"WebSharper\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++websharper:\"}\n        \n    let opIOption     = { name = \"IOption\"     ; unique = false ; opClass = OpFSharp     ; prefix = \"-I:\"          }\n    let opReference   = { name = \"Reference\"   ; unique = false ; opClass = OpFSharp     ; prefix = \"-r:\"          }\n    let opSource      = { name = \"Source\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"\"             }\n    let opTarget      = { name = \"Target\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"--target:\"    }\n    let opOutput      = { name = \"Output\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"-o:\"          }\n    let opDebug       = { name = \"Debug\"       ; unique = true  ; opClass = OpFSharp     ; prefix = \"--debug:\"     }\n    let opDefine      = { name = \"Define\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"--define:\"    }\n    let opGenFSharp1  = { name = \"GenFSharp1\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"-\"            }\n    let opGenFSharp2  = { name = \"GenFSharp2\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"--\"           }\n    \n    let opWebSite     = { name = \"Website\"     ; unique = true  ; opClass = OpWebSharper ; prefix = \"--wsoutput:\"  }\n    let opGenWSharper = { name = \"GenWSharper\" ; unique = false ; opClass = OpWebSharper ; prefix = \"--\"           }\n    \n    let dllOptions     = CompOptions [| opTarget      /= \"library\"                                                                     |]  \n    let exeOptions     = CompOptions [| opTarget      /= \"exe\"     ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    let winExeOptions  = CompOptions [| opTarget      /= \"winexe\"  ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    \n    let genericOptions = \n      CompOptions\n        [|\n           opSnippet     /= \"Test\"\n           opName        /= fun os -> (os?Snippet : string).Split('/') |> Array.last\n           opDirectory   /= fun os -> \"Compiled\" +/+ os?Name\n           opExtension   /= fun os -> match os?Target with | \"library\" -> \"dll\" | _ -> \"exe\"\n           opFileName    /= fun os -> os?Directory +/+ os?Name + \".fs\"\n           opSource      /= fun os -> os?Filename\n           opOutput      /= fun os -> System.IO.Path.ChangeExtension(os?Source, os?Extension)\n           opConfig      /= fun os -> os?Output + \".config\"\n           opWebSharper  /= fun os -> if (os:CompOptions).Exists (fun (opT, opV) -> opT.opClass = OpWebSharper) then \"1\" else \"0\"\n        |]\n        \n    let siteOptions =\n      CompOptions\n        [|\n           opGenWSharper /= \"ws:Site\"\n           opWebSite     /= fun os -> os?Directory +/+ \"website\"\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let wsProjectOptions =\n      CompOptions\n        [|\n           opGenWSharper /= fun os -> sprintf \"project:%s\"  os?Name\n        |] \n     \n    let debugOptions = \n      CompOptions\n        [|\n           opGenFSharp1  /= \"g\"\n           opDebug       /= \"full\"\n           opDefine      /= \"DEBUG\"\n           opDefine      /= \"TRACE\"\n           opGenFSharp2  /= \"optimize-\"\n           opGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions =\n      CompOptions\n        [|\n           //@\"--noframework\"\n           opGenFSharp2  /= \"warn:3\"\n           opGenFSharp2  /= \"warnaserror:76\"\n           opGenFSharp2  /= \"vserrors\"\n           opGenFSharp2  /= \"utf8output\"\n           opGenFSharp2  /= \"fullpaths\"\n           opGenFSharp2  /= \"flaterrors\"\n           opGenFSharp2  /= \"subsystemversion:6.00\"\n           opGenFSharp2  /= \"highentropyva+\"\n           opGenInternal /= \"removelinedirectives\"\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions\n        + dllOptions\n        + otherOptions\n        + opSnippet     /= snp\n        \n    let compileOptionsDllDebug (snp:string) = compileOptionsDll snp + debugOptions        \n    let compileOptionsExeDebug    snp = compileOptionsDllDebug snp + exeOptions   \n    let compileOptionsWinExeDebug snp = compileOptionsDllDebug snp + winExeOptions\n        \n    let prepOptions (options:CompOptions) (code : string [], assembs : string [], defines : string [], prepoIs : string [], nowarns : string []) =\n        let  code2 =\n           [\n              yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n              yield! code \n           ] |> String.concat \"\\n\"\n        let  fileName = options?Filename\n        do   System.IO.File.WriteAllText(fileName, code2)\n        let  options2 = \n             options  + [|\n                           yield! prepoIs |> Array.map ((/=) opIOption  ) \n                           yield! assembs |> Array.map ((/=) opReference)\n                           yield! defines |> Array.map ((/=) opDefine   )\n                           if options.Contains \"++staticlinkall\" then \n                               yield! assembs |> Array.map (System.IO.Path.GetFileNameWithoutExtension >> ((+) \"staticlink:\") >> ((/=) opGenFSharp2 ))         \n                        |]\n        if options.Contains \"++copyassemblies\" then \n            assembs |> Array.iter (fun f -> System.IO.Path.GetDirectoryName(fileName) |> copyIfMustToDir f)      \n        if options2.Contains \"++showoptions\"    then printfn \"%s\" (options2.Get (fun _ -> true) |> String.concat \"\\n\")               \n        options2\n    \n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"}],"id":{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},"expanded":true,"level":0,"properties":{}},{"name":"RemotingDll","content":"#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n\n#define WEBSHARPER\n#define FSS_SERVER\n\nopen System\nopen System.Net\nopen System.Text\nopen System.IO\nopen WebSharper\n//open WebSharper.Remoting\n//open WebSharper.JavaScript\n\n#if FSS_SERVER\nlet sendRequestRpcEP     = \"RemotingDll:FSSGlobal.UsefulDotNet.sendRequest:-426626804\"\nlet awaitRequestForRpcEP = \"RemotingDll:FSSGlobal.UsefulDotNet.awaitRequestFor:-439983525\"\nlet replyToRpcEP         = \"RemotingDll:FSSGlobal.UsefulDotNet.replyTo:-1092841374\"\n#else\nlet sendRequestRpcEP     = \"Remote:CIPHERPrototype.Messaging.sendRequest:1096816393\"\nlet awaitRequestForRpcEP = \"Remote:CIPHERPrototype.Messaging.awaitRequestFor:278590570\"\nlet replyToRpcEP         = \"Remote:CIPHERPrototype.Messaging.replyTo:-1092841374\"\n#endif\n\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule Messaging =\n    type AddressId = AddressId of string\n    \n    type Request = {\n        toId              : AddressId\n        fromId            : AddressId\n        content           : string\n        mutable messageId : Guid option\n    }\n    \n    type MBMessage =\n    | Listener of AddressId * (Request->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Request  of Request   * (string ->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Reply    of Guid      *  string\n    \n    type POMessage =\n    | POIdentification\n    | POEcho   of string\n    | POListeners\n    | POPendingRequests\n    | POPendingReplys\n    \n    type POResponse =\n    | POString  of string\n    | POStrings of string[]\n\nopen Messaging\n\nlet extract n (s:string) = s.Substring(0, min n s.Length)\nlet now() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\ntype PostOffice() =\n    let mutable listeners = [| |]\n    let mutable requests  = [| |]\n    let mutable sent      = [| |]\n    let agent = MailboxProcessor.Start(fun mail ->\n        async {\n            while true do\n                let! mbMsg = mail.Receive()\n                match mbMsg with\n                | Listener                    (listener, lfs, lfe, lfc)  ->\n                    requests\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (request , rfs, rfe, rfc)) -> \n                        if request.toId <> listener then None else\n                        requests <- Array.append requests .[0..i-1]  requests .[i+1..requests .Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then \n                                    listeners <- \n                                        listeners \n                                        |> Array.filter(fun (lnr, lfs, exn, cen) -> \n                                            if lnr = listener then\n                                                //exn <| DivideByZeroException ()\n                                                //exn <| TimeoutException ()\n                                                lfs <| {\n                                                            toId      = AddressId \"\"\n                                                            fromId    = AddressId \"\"\n                                                            content   = \"{\\\"$\\\":0}\"\n                                                            messageId = None\n                                                        }\n                                                false\n                                            else true) \n                                        |> Array.append [| listener, lfs, lfe, lfc |]); v)\n                | Request                     (request , rfs, rfe, rfc)  ->\n                    listeners\n                    |> Array.indexed\n                    |> Array.tryPick (fun (i, (listener, lfs, lfe, lfc)) -> \n                        if request.toId <> listener then None else \n                        listeners <- Array.append listeners.[0..i-1] listeners.[i+1..listeners.Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then requests  <- requests  |> Array.append [| request , rfs, rfe, rfc |]); v)\n                | Reply                       (reply   , response)  ->\n                    sent\n                    |> Array.indexed\n                    |> Array.pick (fun (i, (request , rfs)) -> \n                        if request.messageId.Value <> reply then None else\n                        sent      <- Array.append sent     .[0..i-1] sent     .[i+1..sent     .Length - 1]\n                        rfs response\n                        Some ())\n                    None\n                |> Option.iter (fun (lfs, request, rfs) -> \n                    request.messageId <- Some <| Guid.NewGuid()\n                    sent <- sent |> Array.append [| request, rfs |]\n                    lfs request\n                )\n        }\n    )\n    with\n        member this.AwaitRequest    listener  fs fe fc = agent.Post <| Listener (listener, fs, fe, fc)\n        member this.SendRequest     request   fs fe fc = \n            printfn \"%s Request: %A %A %A\" (now()) request.toId request.fromId (extract 80 request.content)\n            agent.Post <| Request  (request , fs, fe, fc)\n        member this.ReplyTo         request   response = \n            printfn \"%s Reply:   %s\"       (now()) (extract 100 response)\n            agent.Post <| Reply    (request , response  )\n        member this.Listeners       ()                 = listeners |> Array.map (function | AddressId id, _, _, _ -> id)\n        member this.Requests        ()                 = requests  |> Array.map (sprintf \"%A\")\n        member this.Sent            ()                 = sent      |> Array.map (sprintf \"%A\")\n\nlet postOffice = PostOffice()\n\n[< Rpc >]\nlet awaitRequestFor (listener:AddressId) =\n    let startAsync (fs, fe, fc) = postOffice.AwaitRequest listener fs fe fc\n    Async.FromContinuations startAsync\n\n[< Rpc >]\nlet replyTo    (reply:Guid) response =\n    async {\n        postOffice.ReplyTo reply response\n    }\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\n[< Rpc >]\nlet sendRequest  toId fromId content =\n    if toId = AddressId \"WebServer:PostOffice\" then\n        async {\n            let msg = Json.Deserialize<POMessage> content\n            return\n                match msg with\n                | POIdentification  -> POString     \"WebServer:PostOffice\"\n                | POEcho        txt -> POString     txt\n                | POListeners       -> POStrings <| postOffice.Listeners()\n                | POPendingRequests -> POStrings <| postOffice.Requests ()\n                | POPendingReplys   -> POStrings <| postOffice.Sent     ()\n                |> Json.Serialize \n        }\n    else\n    let startAsync (fs, fe, fc) = postOffice.SendRequest   \n                                    { toId      = toId   \n                                      fromId    = fromId \n                                      content   = content \n                                      messageId = None }\n                                    fs fe fc\n    Async.FromContinuations startAsync\n\nlet RpcCall (url:string) method (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        req.Headers.Add(\"x-websharper-rpc\", method            )\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //printfn \"RpcCallResponse %s\" (extract 100 msg)\n        let json   = JsonValue.Parse msg\n        return       json.[\"$DATA\"]\n    }\n\nlet serializeAddressId aId =\n    match aId with\n    | AddressId v -> sprintf \"\"\"{\"$\":0,\"$0\":\"%s\"}\"\"\" v\n\nlet sendRequestRpc (toId: AddressId) (fromId: AddressId) (content: string): Async<string> =\n    async {\n        let! msg =\n            [| serializeAddressId toId ; serializeAddressId fromId ; Json.Serialize content |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint sendRequestRpcEP\n        return msg.AsString()\n    }\n\nlet awaitRequestForRpc (listener:AddressId) =\n    async {\n        let! msg =\n            [| serializeAddressId listener |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint awaitRequestForRpcEP\n        let  v = msg.[\"$V\"]\n        let req    =\n            {\n                toId      = AddressId <| v?toId  .[\"$V\"].[\"$0\"].AsString()\n                fromId    = AddressId <| v?fromId.[\"$V\"].[\"$0\"].AsString()\n                content   = v?content                          .AsString()\n                messageId = Some <| v?messageId  .[\"$V\"].[\"$0\"].AsGuid  ()\n            }\n        return req\n    }\n\nlet replyToRpc (reply:Guid) response =\n    async {\n        let! msg =\n            [| sprintf \"\\\"%s\\\"\" <| reply.ToString() ; Json.Serialize response |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint replyToRpcEP\n        return ()\n    }\n","parent":{"$":0,"Item":"376fdef6-dfcf-40c5-bd14-97c3b246bb30"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"82ab58ca-79e8-47f9-8917-f444d3320751"},"expanded":true,"level":0,"properties":{}},{"name":"FsEvaluator","content":"module FsEvaluator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"expanded":false,"level":0,"properties":{}},{"name":"evalFsiExe","content":"open Useful\n\nmodule Evaluator =\n    open System.Diagnostics\n    open UsefulDotNet\n    \n    type FsiExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"fsiAnyCPU.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = \"xXxY\" + \"yYyhH\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Eval txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                shell.Send txt \n                shell.Send \";;\"\n                let! res = shell.SendAndWait(endToken + \";;\", endToken, true)\n                return res\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()\n    \n    let fsiExe = lazy new ResourceAgent<_, string> (20, (fun config -> new FsiExe([\"--nologo\" ; \"--quiet\" ; defaultArg config \"\"] )), (fun fsi -> (fsi :> System.IDisposable).Dispose()), (fun fsi -> fsi.IsAlive), \"\")\n\n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let evalFsiExe (code:string) =\n        Wrap.wrapper {\n            let config = extractConfig (code.Split '\\n')\n            let! resR = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  do! Result.tryProtection()\n                  let! res = fsi.Eval code \n                  return res\n                }\n            , config)\n            let! res = resR\n            return res\n        }\n\n#define WEBSHARPER\nopen WebSharper\n\n[< Rpc >]\nlet evaluateAS source =\n    async {\n        let!    res  = Evaluator.evalFsiExe source |> Wrap.getAsyncR \n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet evaluateAR source =\n    async {\n        let!   vO, msgs = evaluateAS source\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"}],"id":{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationShared","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule FsStationShared =\n","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"expanded":false,"level":0,"properties":{}},{"name":"MessagingClient","content":"#define FSS_SERVER\n\n#if FSS_SERVER\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.UsefulDotNet.Messaging\n#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n#else\n\n//#r \"remote.dll\"\nopen CIPHERPrototype.Messaging\n#endif\nopen WebSharper\nopen Useful\n//open UsefulFewJS\n//open UsefulFewJS.Messaging\n\n#if WEBSHARPER\n[< Inline \"true\" >]\n#endif          \nlet inJavaScript = false\n\nlet selectF fj fn =\n    match inJavaScript with\n    | true  -> fj\n    | false -> fn\n    \n#if WEBSHARPER\nlet AsyncStart asy     = Async.StartWithContinuations(asy, id, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))    \n[< Inline \"\" >]\nlet awaitRequestForRpc = awaitRequestForRpc\n[< Inline \"\" >]\nlet sendRequestRpc     = sendRequestRpc\n[< Inline \"\" >]\nlet replyToRpc         = replyToRpc\n#else\nlet AsyncStart asy = Async.Start asy\n#endif          \n\nlet  AddressId = AddressId\n\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestForRpc\nlet sendRequestF     = selectF sendRequest         sendRequestRpc\nlet replyToF         = selectF replyTo                 replyToRpc\nlet AsyncStartF      = selectF AsyncStart             Async.Start\n\ntype MessagingClient(clientId, ?timeout, ?endPoint:string) =\n    let wsEndPoint = endPoint    |> Option.defaultValue \"##FSHARPSTATION_ENDPOINT##\"\n    let tout       = timeout     |> Option.defaultValue 100_000\n    let fromId     = AddressId clientId\n    do WebSharper.Remoting.EndPoint <- wsEndPoint \n    let awaitMessage respond =\n        async {\n            while true do\n                printfn \"%s awaitRequest %s\" (nowStamp()) clientId\n                let! msgA  = Async.StartChild(awaitRequestForF fromId, tout)\n                try\n                    let! msg   = msgA\n                    let! resp  = respond clientId msg.content\n                    do!          replyToF msg.messageId.Value resp\n                with \n                | :? System.TimeoutException -> ()\n                | e                          -> printfn \"%A\" e\n        } \n        |> AsyncStartF\n    let sendMessage  toId msg = sendRequestF toId fromId msg\n    let poMsg checkResponse msg =\n        async {\n            let! resp = sendMessage (AddressId \"WebServer:PostOffice\") (Json.Serialize<POMessage> msg)\n            return checkResponse (Json.Deserialize<POResponse> resp)\n        }\n    let poString resp =\n                match resp with\n                | POString  v  -> v\n                | POStrings vs -> sprintf \"%A\" vs\n    let poStrings resp =\n                match resp with\n                | POString  v  -> [| sprintf \"unexpected response: %s\" v |]\n                | POStrings vs -> vs\n  with \n    member this.AwaitMessage respond  = awaitMessage (fun clientId request -> async { return respond clientId request })\n    member this.AwaitMessage respondA = awaitMessage respondA\n    member this.SendMessage toId msg  = sendMessage toId msg\n    member this.POMessage        msg  = poMsg id        msg\n    member this.POListeners      ()   = poMsg poStrings POListeners\n    member this.EndPoint              = wsEndPoint\n    member this.ClientId              = clientId\n    static member EndPoint_           = \"##FSHARPSTATION_ENDPOINT##\"\n    ","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"}],"id":{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},"expanded":true,"level":0,"properties":{}},{"name":"CodeSnippet","content":"open Useful\n\nlet inline swap f a b = f b a\n      \nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\ntype CodeSnippetId = CodeSnippetId of System.Guid   \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n     member this.Text  = match this with CodeSnippetId guid -> guid.ToString()\n\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n    level        : int\n    properties   : Map<string, string>\n} with\n    member this.Name = snippetName this.name this.content\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> this.id.Text + \" \" + c + \".fsx\")\n//    member this.ContentIndented addLinePrepos =\n//        let indent        = this.level * 2\n//        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n//        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |] \n//        this.content.Split('\\n') \n//        |> addLinePs\n//        |> separatePrepros (not addLinePrepos)\n//        |> indentF\n//      , indent\n\n// tail recursion does not optimize\nlet rec preds fetcher outs (ins : CodeSnippetId list) : CodeSnippetId list =\n    match ins with\n    | []         -> outs\n    | hd :: rest -> List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                    |> preds fetcher (if outs |> Seq.contains hd then outs else hd::outs)\n\nlet predsL fetcher (ins : CodeSnippetId list) : CodeSnippetId list =\n    let mutable ins  = ins \n    let mutable outs = []\n    while not ins.IsEmpty do\n        match ins with\n        | []         -> ()\n        | hd :: rest -> if outs |> Seq.contains hd then\n                            ins  <- rest\n                        else\n                            ins  <- List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            outs <- hd::outs\n    outs\n\ntype CodeSnippet with\n    member this.UniquePredecessors (fetcher: CodeSnippetId -> CodeSnippet option) = predsL fetcher [ this.id ]        \n    static member TryFindByKey  snps key = snps |> Seq.tryFind (fun snp        -> snp.id = key)\n    member this.SeparateCode addLinePrepos =\n        let indent        = this.level * 2\n        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |]\n        let code, assembs, defines, prepIs, nowarns  =\n            this.content.Split('\\n') \n            |> addLinePs\n            |> separatePrepros (not addLinePrepos)\n            |> indentF\n            |> separateDirectives\n        [| this.NameSanitized, code.Length, indent |] , code, assembs, defines, prepIs, nowarns\n    static member AddSeps (lines1:(string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[])\n                          (lines2:(string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[]) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n    static member ReducedCode  addLinePrepos (snippets: CodeSnippet seq) =\n        snippets\n        |> Seq.map(fun snp -> snp.SeparateCode addLinePrepos)\n        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||] ] else snps\n        |> Seq.reduce CodeSnippet.AddSeps\n        |> fun (lines, code, assembs, defines, prepIs, nowarns) ->\n           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns)\n    static member FinishCode addLinePrepos (lines:(string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[]) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (name, len, ind) -> (name, (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    static member CodeAndStarts   addLinePrepos (snippets:CodeSnippet seq) =\n        CodeSnippet.ReducedCode   addLinePrepos snippets\n        |> CodeSnippet.FinishCode addLinePrepos\n    static member CodeFsx         addLinePrepos snps = CodeSnippet.CodeAndStarts addLinePrepos snps |> fst\n//    static member CodeMerged  addLinePrepos (snippets: CodeSnippet seq) =\n//        let bySnippet = \n//            snippets\n//            |> Seq.map(fun snp -> \n//                let code, indent = snp.ContentIndented addLinePrepos\n//                snp, indent, code\n//            )\n//        (bySnippet, bySnippet |> Seq.collect (function _, _, code -> code))\n//    static member CodeParts addLinePrepos snippets =\n//        let bySnippet, merged                        = CodeSnippet.CodeMerged addLinePrepos snippets\n//        let code, assembs, defines, prepIs, nowarns  = separateDirectives merged\n//        let config = defines |> Seq.distinct |> Seq.sort |> Seq.map ((+)\"-d:\")             |> String.concat \" \"\n//        [   if config <> \"\" then yield \"////\" + config\n//            yield! prepIs  |> Seq.distinct             |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n//            yield! assembs |> Seq.distinct             |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n//            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n//            yield! nowarns |> Seq.distinct             |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n//        ], code, bySnippet\n//    static member CodeFsx0 addLinePrepos (cur, snippets) =\n//        let part1, part2, bySnippet = CodeSnippet.CodeParts addLinePrepos (Array.append snippets [| cur |])\n//        [ yield! part1 ; yield! part2 ] |> String.concat \"\\n\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"b59aa3c7-13d9-4f78-98ea-307182bf4bd4"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true,"level":0,"properties":{}},{"name":"FSMessage,FSResponse","content":"type FSMessage =\n    | GetIdentification\n    | GenericMessage        of string\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetPredsById   of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippetPreds       of string []\n    | GetSnippet            of string []\n    | GetSnippetJSCode      of string []\n    | GetWholeFile\n    | RunSnippetUrlJSById   of CodeSnippetId * string\n    | RunSnippetUrlJS       of string []     * string\n\ntype FSSeverity =\n    | FSError\n    | FSWarning\n    | FSInfor\n\ntype FSResponse =\n    | IdResponse        of string\n    | StringResponse    of string option\n    | SnippetResponse   of CodeSnippet option\n    | SnippetsResponse  of CodeSnippet []\n    | StringResponseR   of string option * (string * FSSeverity)[]\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient","content":"\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | msg                        -> false\n\ntype FsStationClient(clientId, ?fsStationId:string, ?timeout, ?endPoint) =\n    let fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let msgClient  = MessagingClient(clientId, ?timeout= timeout, ?endPoint= endPoint)\n    let toId       = AddressId fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toList)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse  response =\n        match response with\n        | StringResponse (Some code)    -> Result.succeed code\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =\n        match response with\n        | SnippetsResponse snps         -> Result.succeed snps\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse response =\n        match response with\n        | SnippetResponse  snp          -> Result.succeed snp\n        | _                             -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        Wrap.wrapper {\n            let!   response = msgClient.SendMessage toId (msg |> Json.Serialize)\n            let!   resp     = checkResponse (Json.Deserialize<FSResponse> response)\n            return resp\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg toId2  msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg toId   msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg toId  (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg toId  (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg toId  (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg toId  (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg toId  (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg toId   GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg toId  (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg toId  (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"},{"$":0,"Item":"f6ebdffc-049c-4493-8de8-e32072419479"}],"id":{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient Save Extension","content":"//open CIPHERPrototype.Messaging\nopen Useful\nopen System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") ; printfn \"Deleted %s.bak\" file with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\ntype FsStationClient with\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file, printMsg) =\n        Wrap.wrapper {\n            printMsg <| sprintf \"%s\" msgBefore\n            let! content = contentW\n            let fullName = Path.Combine(path, file)\n            backupFile fullName\n            File.WriteAllText(fullName, content)\n            printMsg <| sprintf \"Saved %s.\" fullName\n        } |> Wrap.runSynchronouslyS false |> printMsg\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file) = this.Save(contentW, msgBefore, path, file, printfn \"%s\")\n    member this.SaveSnippetJS  path snippet = this.Save(this.RequestJSCode snippet, sprintf \"Compiling %s to JavaScript\" snippet, path, (snippet.Split '/' |> Seq.last) + \".js\" )\n    member this.SaveSnippetFsx path snippet = this.Save(this.RequestCode   snippet, sprintf \"Saving %s to F#\"            snippet, path, (snippet.Split '/' |> Seq.last) + \".fsx\")\n    member this.SaveWholeFile  path name    = this.Save(this.RequestWholeFile()   , sprintf \"Saving to %s.fsjson\"        name   , path, name + \".fsjson\"                        )\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},"expanded":true,"level":0,"properties":{}},{"name":"FsStationClient Compile Extension","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FsStationClient with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [ yield! msgs |> Array.map fSharpError2TranspilerError\n                                if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              ]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"15cf771f-22b1-4796-8e34-6c16f35d6506"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"ab5ab0ca-eb45-4851-affe-4690bb75d055"}],"id":{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},"expanded":true,"level":0,"properties":{}},{"name":"WebSite","content":"#define WEBSHARPER\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\n\ntype EndPoint = EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page( Html.html [ Html.body [ Html.h1 [ Html.text \"Hello Dolly\" ] ]])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},"expanded":true,"level":0,"properties":{}},{"name":"SelfHostedServer","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n\n    [<EntryPoint>]\n    let Main args =\n        let rootDirectory, url =\n            match args with\n            | [| rootDirectory; url |] -> rootDirectory, url\n            | [| url                |] -> \"..\"         , url\n            | [|                    |] -> \"..\"         , \"http://localhost:9001/\"\n            | _ -> eprintfn \"Usage: WebServer ROOT_DIRECTORY URL\"; exit 1\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                                   , Sitelet             = Some site\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                |> ignore\n                let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n                let maxA = ref 0\n                let maxB = ref 0\n                listener.SetRequestProcessingLimits(1000, 1000)\n                listener.GetRequestProcessingLimits(maxA, maxB)\n                printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n                )\n        stdout.WriteLine(\"Serving {0}\", url)\n        stdin.ReadLine() |> ignore\n        0\n","parent":{"$":0,"Item":"63eca270-405a-4789-941a-e298bbd265bd"},"predecessors":[{"$":0,"Item":"47912c89-9605-41df-9425-7facea3d6b50"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"2071bfaf-8f65-47a7-98e6-7ec138e9f905"},"expanded":true,"level":0,"properties":{}},{"name":"FsTranslator","content":"module FsTranslator =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"expanded":false,"level":0,"properties":{}},{"name":"FsTranslator","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.dll\"\n#r @\"..\\packages\\Zafir.Compiler\\lib\\net45\\WebSharper.Compiler.FSharp.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Pdb.dll\"\n#r @\"..\\packages\\Mono.Cecil\\lib\\net40\\Mono.Cecil.Mdb.dll\"\n//#r @\"System.Reflection.Metadata.dll\"\n\nmodule Translator =\n    open Useful\n    open UsefulDotNet\n    open System\n    open System.IO\n    open System.Reflection\n    \n    module Re = WebSharper.Core.Resources\n    module P  = WebSharper.PathConventions\n    open WebSharper.Compiler\n    open WebSharper.Compiler.FrontEnd\n    open WebSharper.Core\n    open WebSharper.Core.Resources\n    open WebSharper.Compile.CommandTools\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open Microsoft.FSharp.Compiler\n    \n    type WebSharperError = AST.SourcePos option * CompilationError\n    type TranslatorError =\n        | MustProvideAssemblyOutputPath\n        | MustProvideProjectPath\n        | ErrWebSharper                 of string\n        | NothingToTranslateToJavaScript\n        | OutputAssemblyNotFound        of string\n    with interface ErrMsg with\n            member this.ErrMsg =\n                if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\n                sprintf \"%A\"this\n            member this.IsWarning = false\n    \n    let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\n        fun                              (posO, error)   ->\n            posO \n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\n            |> Option.defaultValue \"\"\n            |>  sprintf \"%s%s\" <| error.ToString()\n            |> ErrWebSharper\n            :> ErrMsg\n    \n    let CompileToJsW: WsConfig -> Wrap<string> =\n        fun           config   -> Wrap.wrapper {\n            do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\n            do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\n            let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\n            let  fsErrors            = errors |> Array.map fSharpError2TranspilerError |> List.ofArray\n            do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\n            do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\n            do   System.IO.File.Delete config.AssemblyFile\n            let  paths               = [   for r in config.References -> \n                                               Path.GetFullPath r\n                                           yield Path.GetFullPath config.AssemblyFile\n                                       ]        \n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\n            let  loader              = Loader.Create aR (printfn \"%s\")\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\n            let  refMeta             =\n                 System.Threading.Tasks.Task.Run(fun () ->\n                     let refErrors = ref false\n                     let metas = refs |> List.choose (fun r -> \n                         try ReadFromAssembly FullMetadata r\n                         with e ->\n                             eprintfn \"WebSharper error %s\" e.Message\n                             refErrors := true\n                             None\n                     )\n                     if !refErrors then None\n                     elif List.isEmpty metas then Some WebSharper.Core.Metadata.Info.Empty \n                     else\n                         try\n                             Some { \n                                 WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\n                                     Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\n                             }\n                         with e ->\n                             eprintfn \"WebSharper error Error merging WebSharper metadata: %s\" e.Message\n                             None\n                 )\n            let  referencedAsmNames     = paths\n                                          |> Seq.map (fun i -> \n                                              let n = Path.GetFileNameWithoutExtension(i)\n                                              n, i\n                                          ) |> Map.ofSeq\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\n                    //printfn \"assemblyResolveHandler %s\" e.Name\n                    let assemblyName    = AssemblyName(e.Name).Name\n                    match Map.tryFind assemblyName referencedAsmNames with\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\n                    | Some p                                   -> Assembly.LoadFrom(p)\n                    | _                                        -> null\n                )\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\n                                        .Compile(refMeta, config.CompilerArgs, \".\", config.ProjectFile) \n            let  wsErrors    = comp.Errors |> List.map webSharperError2TranspilerError\n            do! if wsErrors.IsEmpty then Result.succeed () else\n                Result.failWithMsgs wsErrors\n            let  assem       = loader.LoadRaw assemblyBytes None\n            let! js          = ModifyAssembly (Some comp) \n                                              (refMeta.Result |> Option.defaultValue WebSharper.Core.Metadata.Info.Empty) \n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \n                                              config.SourceMap config.AnalyzeClosures assem\n                               |> Result.fromOption NothingToTranslateToJavaScript\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\n            use  stringW     = new System.IO.StringWriter()\n            use  writer      = new System.Web.UI.HtmlTextWriter(stringW)\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\n            let ctx : Resources.Context =\n                {\n                    DebuggingEnabled        = true\n                    DefaultToHttp           = false\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\n\n                    GetAssemblyRendering    = fun name ->\n                        //printfn \"GetAssemblyRendering %s\" name\n                        if name = thisProject || name = config.ProjectFile\n                        then WebSharper.Core.Resources.Rendering.Skip else\n                        name\n                        |> P.AssemblyId.Create\n                        |> pu.JavaScriptPath \n                        |> Re.RenderLink\n                    GetWebResourceRendering = fun ty resource ->\n                        //printfn \"GetWebResourceRendering %A\" ty\n                        let id = P.AssemblyId.Create(ty)\n                        let kind =\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\n                                then P.ResourceKind.Script\n                                else P.ResourceKind.Content\n                        P.EmbeddedResource.Create(kind, id, resource)\n                        |> pu.EmbeddedPath\n                        |> Re.RenderLink\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\n                }            \n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\n            //js.RenderDependencies(ctx, writer)\n            let  includes = stringW.ToString()\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\n                            |> String.concat \", \"\n            let  f        = js.[1..js.Length - 7] |> if List.isEmpty comp.Warnings then id else sprintf \"\\/*\\n%A\\n*\\/ %s\" comp.Warnings\n            return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\n        }\n    \n    let compileMainW: string[] -> Wrap<string> =\n      fun             argv     ->\n        let wsArgs    = ref WsConfig.Empty\n        let refs      = ResizeArray()\n        let resources = ResizeArray()\n        let fscArgs   = ResizeArray()\n        let cArgv     =\n            [|\n                let isRNext = ref false\n                for a in argv do\n                    match a with\n                    | \"-r\" ->\n                        isRNext := true\n                    | _ ->\n                        if !isRNext then\n                            isRNext := false   \n                            yield \"-r:\" + a\n                        else\n                            yield a\n            |]\n        for a in cArgv do\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\n            try\n                match a with\n                | \"--wig\"                          -> setProjectType WIG\n                | \"--bundle\"                       -> setProjectType Bundle\n                | \"--html\"                         -> setProjectType Html\n                | \"--site\"                         -> setProjectType Website\n                | StartsWith \"--ws:\" wsProjectType ->\n                    match wsProjectType.ToLower() with\n                    | \"site\" \n                    | \"web\" \n                    | \"website\" \n                    | \"export\"                     -> setProjectType Website\n                    | \"extension\"                  \n                    | \"interfacegenerator\"         -> setProjectType WIG\n                    | \"bundle\"                     -> setProjectType Bundle\n                    | \"html\"                       -> setProjectType Html\n                    | \"ignore\"                     -> ()\n                    | \"library\"                    -> ()\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\n                | \"--debug\"                      \n                | \"--debug+\"                     \n                | \"--debug:full\"                 \n                | \"-g\"                           \n                | \"-g+\"                          \n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\n                | StartsWith \"-o:\"               o \n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\n                | StartsWith \"-r:\"               r             \n                | StartsWith \"--reference:\"      r -> refs.Add      r                                   ; fscArgs.Add a\n                | StartsWith \"--resource:\"       r -> resources.Add r                                   ; fscArgs.Add a\n                | _                                ->                                                     fscArgs.Add a  \n            with e ->\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\n        fscArgs.Add \"--define:FSHARP41\"\n        wsArgs := \n            { !wsArgs with \n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\n                Resources    = resources.ToArray()\n                CompilerArgs = fscArgs  .ToArray() \n            }\n        CompileToJsW !wsArgs\n\n    let Process args =  \n        compileMainW args \n        |> Wrap.runSynchronouslyR\n        |> fun (Result(jsO, msgs)) -> \n               jsO |> Option.iter (printfn \"%s\")\n               if not msgs.IsEmpty then Result.getMessages msgs |> eprintfn \"%O\"\n               match jsO with\n               | Some js -> 0\n               | None    -> 1\n               \n    let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\n\n    [< EntryPoint >]\n    let Main args =\n        Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\n        let mutable cycle = true\n        if args = [| \"++loop\" |] \n        then while cycle do\n               let line = Console.ReadLine()\n               if line = null ||  line = \"++end\" then cycle <- false else\n               let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\n               if Process argsL = 0 then \"success\" else \"fail\"\n               |> printfn \"//%s\"\n               eprintfn \"%s\" endToken\n             0\n        else Process args \n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"},{"$":0,"Item":"9becc68c-9cc2-4f29-82df-e510d10226db"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}],"id":{"$":0,"Item":"cfe0b3ef-9176-4f30-853c-27177faef6b0"},"expanded":true,"level":0,"properties":{}},{"name":"TranslatorCaller","content":"module TranslatorCaller =\n    open Useful\n    open UsefulDotNet\n    open CompOptionsModule\n    open System\n    open System.IO\n    open System.Diagnostics\n    \n    type TranslatorExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"Compiled\\FsTranslator\\FsTranslator.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = sprintf \"//---------------%s-----------------\" \"EOF\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Translate txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                let! res1 = shell.SendAndWait(txt, endToken, true)\n                let! res2 = if res1.EndsWith \"//success\" then Result.succeed res1 else Result.fail (ErrSimple (\"Translator Failed\", false))\n                return res2\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()    \n\n    let translator = lazy new ResourceAgent<_, string> (20, (fun config -> new TranslatorExe([\"++loop\"; defaultArg config \"\"] )), (fun exe -> (exe :> System.IDisposable).Dispose()), (fun exe -> exe.IsAlive), \"\")\n    \n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let getJSW (minified:bool) (options0 : (CompOption * CompOptionValue) seq) (fsCode:string) =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  code           = fsCode.Split '\\n'\n            let  defines0       = (extractConfig code).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros false code |> separateDirectives\n            let  defines        = Array.append defines0 defines1\n            let  codeBase       = Path.GetFullPath \"bin\"\n            let  name           = \"Temp_\" + Path.GetFileNameWithoutExtension(Path.GetRandomFileName())\n            let  options1       = compileOptionsDll name\n                                  + opDirectory   /= Path.GetDirectoryName(codeBase)\n                                  + opGenWSharper /= \"project:FSharpStation\"\n                                 // + opIOption   /= @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\"\n                                  + options0\n            let  options2       = prepOptions options1 (fs, assembs, defines, prepIs, nowarns)\n            use  toErase        = new TempFileName(options2?Source)\n            let  ops            = options2.Get CompOptions.WSharperOptions\n                                  |> Seq.append [ \"IGNORED\" ]\n                                  |> Seq.map (sprintf \"%A\")\n                                  |> String.concat \" \"\n            let! jsR            = translator.Value.Process (fun tra -> tra.Translate ops)\n            let! js             = jsR\n            return js\n        }\n\n\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"},{"$":0,"Item":"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"},{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"f930dc48-39e8-453c-8c77-18a2cd73637a"}],"id":{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},"expanded":true,"level":0,"properties":{}},{"name":"Test FsTranslator.exe","content":"open Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let    snippet = \"FSSGlobal/WebSharper Code/WebSharper Snippets1/Test mouse\"//\"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    //let    snippet = \"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    let!   code    = FsStationShared.FsStationClient(\"Test FsTranslator.exe\").RequestCode snippet\n    let!   js      = TranslatorCaller.getJSW false [ (* opGenInternal /= \"showoptions\" *) ] code\n    return js\n} \n|> Wrap.runSynchronouslyS false\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"ef053bdf-997b-49c8-a401-1611a568bd8a"}],"id":{"$":0,"Item":"f587e7a5-825a-4c95-ac79-a53f43ed52c8"},"expanded":true,"level":0,"properties":{}},{"name":"translateAR","content":"open Useful\nopen WebSharper\n\n[< Rpc >]\nlet translateAS source minified = \n    async {\n        let!    res  = TranslatorCaller.getJSW minified [] source |> Wrap.getAsyncR\n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet translateAR source minified = \n    async {\n        let!   vO, msgs = translateAS source minified\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toList)\n    }\n    ","parent":{"$":0,"Item":"6568955e-6aa8-4f8f-b93f-b7e97622c677"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}],"id":{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},"expanded":true,"level":0,"properties":{}},{"name":"SlowlyChangingDimensions","content":"//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n#r @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Houston\\CIPHERTool\\FSharp.Data.SqlClient\\FSharp.Data.SqlClient.dll\"\n\nmodule SlowlyChangingDimensions =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"}],"id":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"expanded":false,"level":0,"properties":{}},{"name":"Fields","content":"type TargetField =\n     | CURR_ASSIGNED_VEND\n     | ORIG_ASSIGNED_VEND\n     | ORIG_INV_NUM\n     | POST_DTE_KEY\n     | RECEIVABLE_CURR_BILLING_TO_DTE\n     | RECEIVABLE_CURR_DELINQ_DTE\n     | RECEIVABLE_CURR_DUE_DTE\n     | RECEIVABLE_CURR_ISSUE_DTE\n     | RECEIVABLE_CURR_TO_DTE\n     | RECEIVABLE_KEY\n     | RECEIVABLE_ORIG_BILLING_TO_DTE\n     | RECEIVABLE_ORIG_DELINQ_DTE\n     | RECEIVABLE_ORIG_DUE_DTE\n     | RECEIVABLE_ORIG_ISSUE_DTE\n     | RECEIVABLE_ORIG_TO_DTE\n     | TRANS_DTE_KEY\n     | VERS_BEG_DTE  \n     | VERS_END_DTE \n     | CURR_VERS_FLAG\n     | ITEM_KEY\n     | INCDT_KEY\n     | CUST_KEY\n     | CARRIER_KEY\n     | CARRIER_PROCEDURE_KEY\n     | COLL_PERSON_KEY\n     | EMP_KEY\n     | FIN_TRANS_TYPE_KEY\n     | DTE_KEY\n     | COH_ORG_KEY\n     | SYS_LOAD_KEY       \n     | ORIG_CUST_KEY      \n     | COLL_VEND_CONTR_KEY\n     | GL_COMBO_KEY \n     | GL_ACCT_ID\n     | FUND_ID\n     | FUND_CNTR_ID\n     | FUNC_AREA_ID\n     | ROW_CHG_RSN\n     | Nil\n\ntype FinTransViewField =\n     | INTRA_DAY_ORDER\n     | DEPT_LONG_NAME\n     | CONTR_ID\n     | CUST_PAR_ID\n     | CUST_PAR_NAME\n     | ADJ_FLAG\n     | ALLOC_TRANS_FLAG\n     | BILLED_FLAG\n     | BLK_NUM\n     | BOOT_SERIAL_NUM\n     | BUS_AREA_ID\n     | BUS_CONT_PERSON_NAME\n     | CARRIER_FIN_CLASS\n     | CARRIER_FIN_GRP\n     | CARRIER_GRP\n     | CARRIER_NAME\n     | CARRIER_PROCEDURE_BILL_CODE\n     | CARRIER_PROCEDURE_CODE\n     | CARRIER_PROCEDURE_DESCR\n     | CARRIER_PROCEDURE_SRC\n     | CARRIER_PROCEDURE_TYPE\n     | CARRIER_SRC\n     | COH_EMP_NUM\n     | COLL_PERSON_ID\n     | COLL_PERSON_NAME\n     | COLL_PERSON_TYPE\n     | CONFI_CUST_FLAG\n     | CUST_ADDR_LINE_1\n     | CUST_ADDR_LINE_2\n     | CUST_ADDR_LINE_3\n     | CUST_APT_LOT\n     | CUST_CITY\n     | CUST_CNTY\n     | CUST_CTRY\n     | CUST_EMAIL_ADDR\n     | CUST_FAX_NUM\n     | CUST_GIS_CITY\n     | CUST_GIS_LOCATR_NAME\n     | CUST_GIS_MATCH_SCORE\n     | CUST_GIS_PREFIX\n     | CUST_GIS_ST_NAME\n     | CUST_GIS_ST_NUM\n     | CUST_GIS_ST_PRETYPE\n     | CUST_GIS_ST_TYPE\n     | CUST_GIS_SUFF\n     | CUST_GIS_X\n     | CUST_GIS_Y\n     | CUST_GIS_ZIP\n     | CUST_ID\n     | CUST_IN_CITY_FLAG\n     | CUST_IS_VEND_FLAG\n     | CUST_NAME\n     | CUST_PAR_KEY\n     | CUST_PHN_NUM_1\n     | CUST_PHN_NUM_2\n     | CUST_PHN_NUM_3\n     | CUST_PREFIX\n     | CUST_SERV_LVL\n     | CUST_ST\n     | CUST_STATE\n     | CUST_ST_DIR\n     | CUST_ST_NAME\n     | CUST_ST_NUM\n     | CUST_ST_PRETYPE\n     | CUST_ST_TYPE\n     | CUST_SUFF\n     | CUST_TYPE\n     | CUST_ZIP_CODE\n     | CUST_ZIP_PLUS_4\n     | DEC_CUST_FLAG\n     | DERIVED_TRANS_FLAG\n     | DET_TRANS_CODE\n     | DET_TRANS_DESCR\n     | DIGITECH_ID\n     | DIGITECH_TRANS_TYPE\n     | DIGITECH_TRANS_TYPE_DET\n     | DIV_LONG_NAME\n     | DL_ISSUE_STATE\n     | DL_NUM\n     | DTE\n     | EMP_NAME\n     | EMP_TYPE\n     | FED_TAX_ID\n     | FIRE_ALM_AGING_RST_FLAG\n     | FIRE_ORIG_ISSUE_DTE\n     | FUNC_AREA_ID\n     | FUND_CNTR_ID\n     | FUND_ID\n     | GL_ACCT_ID\n     | HCTO_AD_VAL_ID\n     | INCDT_ADDR_LINE_1\n     | INCDT_ADDR_LINE_2\n     | INCDT_ADDR_LINE_3\n     | INCDT_APT_LOT\n     | INCDT_CAT\n     | INCDT_CITY\n     | INCDT_CNTY\n     | INCDT_CTRY\n     | INCDT_DESCR\n     | INCDT_DTE\n     | INCDT_GIS_CITY\n     | INCDT_GIS_LOCATR_NAME\n     | INCDT_GIS_MATCH_SCORE\n     | INCDT_GIS_PREFIX\n     | INCDT_GIS_ST_NAME\n     | INCDT_GIS_ST_NUM\n     | INCDT_GIS_ST_PRETYPE\n     | INCDT_GIS_ST_TYPE\n     | INCDT_GIS_SUFF\n     | INCDT_GIS_X\n     | INCDT_GIS_Y\n     | INCDT_GIS_ZIP\n     | INCDT_IN_CITY_FLAG\n     | INCDT_PREFIX\n     | INCDT_SEQ_NUM\n     | INCDT_SERV_LVL\n     | INCDT_ST\n     | INCDT_STATE\n     | INCDT_ST_DIR\n     | INCDT_ST_NAME\n     | INCDT_ST_NUM\n     | INCDT_ST_PRETYPE\n     | INCDT_ST_TYPE\n     | INCDT_SUFF\n     | INCDT_TIME\n     | INCDT_TYPE\n     | INCDT_ZIP_CODE\n     | INCDT_ZIP_PLUS_4\n     | INTRA_FUND_TRANS_AMT\n     | INTRA_FUND_TRANS_FLAG\n     | INT_EXT_EMP_FLAG\n     | INV_NUM\n     | ITEM_ADDR_LINE_1\n     | ITEM_ADDR_LINE_2\n     | ITEM_ADDR_LINE_3\n     | ITEM_APT_LOT\n     | ITEM_CITY\n     | ITEM_CNTY\n     | ITEM_CTRY\n     | ITEM_DESCR\n     | ITEM_EXMPT_FLAG\n     | ITEM_GIS_CITY\n     | ITEM_GIS_LOCATR_NAME\n     | ITEM_GIS_MATCH_SCORE\n     | ITEM_GIS_PREFIX\n     | ITEM_GIS_ST_NAME\n     | ITEM_GIS_ST_NUM\n     | ITEM_GIS_ST_PRETYPE\n     | ITEM_GIS_ST_TYPE\n     | ITEM_GIS_SUFF\n     | ITEM_GIS_X\n     | ITEM_GIS_Y\n     | ITEM_GIS_ZIP\n     | ITEM_IN_CITY_FLAG\n     | ITEM_PREFIX\n     | ITEM_SERV_LVL\n     | ITEM_ST\n     | ITEM_STAT\n     | ITEM_STATE\n     | ITEM_STAT_CHG_DTE\n     | ITEM_ST_DIR\n     | ITEM_ST_NAME\n     | ITEM_ST_NUM\n     | ITEM_ST_PRETYPE\n     | ITEM_ST_TYPE\n     | ITEM_SUFF\n     | ITEM_TYPE\n     | ITEM_ZIP_CODE\n     | ITEM_ZIP_PLUS_4\n     | JV_CUST_FLAG\n     | LOAD_DTE\n     | LOAD_TIME\n     | MAN_TRANS_FLAG\n     | MEDICAID_PAYER_CODE\n     | MEDICARE_PAYER_CODE\n     | MSTR_TRANS_TYPE\n     | NAICS_DET_CODE\n     | NAICS_DET_NAME\n     | NAICS_DIV_CODE\n     | NAICS_DIV_NAME\n     | NAICS_INDY_CODE\n     | NAICS_INDY_GRP_CODE\n     | NAICS_INDY_GRP_NAME\n     | NAICS_INDY_NAME\n     | NAICS_MAJ_GRP_CODE\n     | NAICS_MAJ_GRP_NAME\n     | ORIG_BILL_NAME\n     | PAY_METH\n     | PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\n     | PMAM_ADJMT_TO\n     | PMAM_ADJMT_TYPE\n     | PMAM_ID\n     | POST_DTE\n     | PRKG_METER_NUM\n     | PRKG_METER_VIO_FLAG\n     | RECEIVABLE_1ST_PAY_DTE\n     | RECEIVABLE_EVER_TRANS_FLAG\n     | RECEIVABLE_FNL_PAY_DTE\n     | RECEIVABLE_LITIGATION_DTE\n     | RECEIVABLE_MSTR_STAT\n     | RECEIVABLE_MSTR_STAT_CHG_DTE\n     | RECEIVABLE_SETTLEMENT_DTE\n     | RECEIVABLE_STAT\n     | RECEIVABLE_STAT_CHG_DTE\n     | RECEIVABLE_VERS_BILLING_TO_DTE\n     | RECEIVABLE_VERS_DELINQ_DTE\n     | RECEIVABLE_VERS_DUE_DTE\n     | RECEIVABLE_VERS_ISSUE_DTE\n     | RECEIVABLE_VERS_TO_DTE\n     | REINSTATEMENT_DTE\n     | RM_EMP_MSTR_KEY\n     | RM_LOAD_DTE\n     | RM_LOAD_TIME\n     | RSN_INCDT_NOT_BILLED\n     | SAP_BUS_ID\n     | SIC_CODE\n     | SIC_DIV_CODE\n     | SIC_DIV_NAME\n     | SIC_INDY_GRP_CODE\n     | SIC_INDY_GRP_NAME\n     | SIC_MAJ_GRP_CODE\n     | SIC_MAJ_GRP_NAME\n     | SIC_NAME\n     | SMARTCM_IS_ADJMT\n     | SMARTCM_IS_FEE\n     | SMARTCM_IS_PAY\n     | SMARTCM_OTHER_CRITERIA\n     | SMART_CM_ID\n     | SRC_CARRIER_KEY\n     | SRC_CARRIER_PROCEDURE_KEY\n     | SRC_SYS\n     | SRC_SYS_ID\n     | SRC_SYS_MOD_DTE\n     | SRC_SYS_TRANS_ID\n     | STATE_CORP_CHTR_ID\n     | STATE_SALES_TAX_ID\n     | T2_ID\n     | T2_TRANS_MISC_ITEM_CODE\n     | T2_TRANS_MISC_ITEM_DESCR\n     | T2_TRANS_ORIG_OBJ_TYPE_ID\n     | T2_TRANS_PARSED_DESCR\n     | T2_TRANS_RSN\n     | T2_TRANS_SCENARIO\n     | T2_TRANS_TYPE_CODE\n     | T2_TRANS_TYPE_DESCR\n     | TOWING_CMPNY\n     | TRANS_AMT\n     | TRANS_CNT\n     | UNK_CUST_AT_BILL_FLAG\n     | VERS_ASSIGNED_VEND\n     | VIO_CODE\n     | EMS_INCDT   \n     | DISPATCH_NUM\n     | FLAG_DIM_INCDT_EMS_DET\n     | DEST_LOC\n     | EMS_INCDT_CAT\n     | ORIGIN_LOC\n     | TXP_SERV_LVL\n     | TXP_TYPE\n     | VEH\n     | FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET\n     | ALLOWABLE_NO_CHRG_INCDTS\n     | ALM_MNT_CMPNY\n     | ALM_TYPE\n     | PERMIT_EXP_DTE\n     | PERMIT_ISSUE_DTE\n     | PERMIT_NAME\n     | PERMIT_NUM\n     | REG_HOLDER_FLAG\n     | SUSPD_PERMIT_DTE\n     | SUSPD_PERMIT_RSN\n     | TYPE_OF_ALM_SITE\n     | FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET\n     | ALM_INSTL_CMPNY\n     | ALM_INSTL_DTE\n     | ALM_REG_KEY\n     | APPLICTN_RECV_DTE\n     | CURR_FIRE_ALM_PERMIT_FLAG\n     | EXCL_TYPE\n     | FIRE_ALM_PERMIT_ACTV_FLAG\n     | FIRE_ALM_PERMIT_NUM\n     | FIRE_ALM_PURPOSE\n     | FLAG_DIM_ITEM_LICENSED_VEH_DET\n     | LICENSE_PLATE_EXP_MTH\n     | LICENSE_PLATE_EXP_YR\n     | LICENSE_PLATE_NUM\n     | LICENSE_PLATE_TYPE\n     | OWNER_IS_CUST_FLAG\n     | SRC_SYS_VEH_ID\n     | VEH_COLOR\n     | VEH_ID_NUM\n     | VEH_MAKE\n     | VEH_MODEL\n     | VEH_MODEL_YR\n     | VEH_OWNER_ID\n     | VEH_OWNER_NAME\n     | VEH_TYPE\n     | FLAG_DIM_ITEM_PT_DET\n     | PT_AGE\n     | PT_GNDR\n     | FLAG_DIM_ITEM_TAXABLE_PROP_DET\n     | APPRAISAL_DISTR_ACCT_NUM\n     | CAN\n     | CC_JURIS_CODE\n     | CC_JURIS_DESCR\n     | CITY_RFPD_JURIS_CODE\n     | CITY_RFPD_JURIS_DESCR\n     | CONFI_ACCT_FLAG\n     | MUNIC_UTIL_DISTR_CODE\n     | MUNIC_UTIL_DISTR_DESCR\n     | NUM_OF_ACRES\n     | OWNERSHIP_EFF_DTE\n     | PROP_CLASS_CODE\n     | PROP_CLASS_DESCR\n     | REND_PENALTY_JURIS_CODE\n     | REND_PENALTY_JURIS_DESCR\n     | SCHOOL_JURIS_CODE\n     | SCHOOL_JURIS_DESCR\n     | SUBSTANTIAL_ERR_PENALTY\n     | TAX_DEFERRAL_END_DTE\n     | TAX_DEFERRAL_START_DTE\n     | TAX_ROLL_CODE\n     | TAX_ROLL_DESCR\n     | TAXABLE_PROP_LGL_DESCR_1\n     | TAXABLE_PROP_LGL_DESCR_2\n     | TAXABLE_PROP_LGL_DESCR_3\n     | TAXABLE_PROP_LGL_DESCR_4\n     | TAXABLE_PROP_LGL_DESCR_5\n     | TAXABLE_PROP_ROLL_TYPE\n     | FLAG_DIM_ITEM_WTR_ACCT_DET\n     | CURR_WTR_ACCT_FLAG\n     | DELINQ_DTE\n     | LAST_CUST_CONN_DTE\n     | LAST_CUST_CUTOFF_DTE\n     | LAST_CUST_DISCONN_DTE\n     | LAST_METER_INSPECT_DTE\n     | OWNER_RENTER\n     | SEN_CITIZEN_FLAG\n     | VAC_FLAG\n     | WTR_ACCT_NUM_OF_UNITS\n     | WTR_ACCT_ORIG_USE_TYPE\n     | WTR_ACCT_PROP_USE_TYPE\n     | WTR_METER_NUM\n     | FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n     | ``A#3307_ATTY_FEE_DTE``\n     | ``A#3308_ATTY_FEE_DTE``\n     | ``A#3348_ATTY_FEE_DTE``\n     | AD_VAL_ACCT_LVL_ID\n     | AD_VAL_DISABLED_FLAG\n     | AD_VAL_EFF_DTE_OF_OWNERSHIP\n     | AD_VAL_HOMESTEAD_FLAG\n     | AD_VAL_OVER_66_FLAG\n     | AD_VAL_TAX_DEFERRAL_END_DTE\n     | AD_VAL_TAX_DEFERRAL_START_DTE\n     | AD_VAL_VET_FLAG\n     | COLL_LAWSUIT_NUM\n     | COLL_LGL_COND\n     | HCAD_ACCT_STAT\n     | QTRLY_PAY_FLAG\n     | FLAG_DIM_RECEIVABLE_BOOT_TOW_DET\n     | RECEIVABLE_HAS_LTR_FLAG\n     | RECEIVABLE_HAS_NOTE_FLAG\n     | RECEIVABLE_HAS_PEND_LTR_FLAG\n     | RESOLVE_DESCR\n     | RESOLVE_DTE\n     | RESOLVE_RSN\n     | RESOLVED_BY\n     | FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET\n     | ACTV_CARRIER\n     | ACTV_CARRIER_FIN_CLASS\n     | ACTV_CARRIER_FIN_GRP\n     | BILLING_HOLD_FLAG\n     | SIG_FLAG\n     | FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET\n     | VOID_CODE\n     | VOID_DESCR\n     | WORK_STAT\n     | FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET\n     | ESC_CAND_FLAG\n     | ON_ADMIN_HOLD_FLAG\n     | UNDER_APPEAL_FLAG\n     | VOID_FLAG\n     | WRITE_OFF_FLAG\n     | Nil_\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},"expanded":true,"level":0,"properties":{}},{"name":"FieldDecls","content":"let fieldDecl = [|\n    (\"3307_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3308_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3348_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"ACCT_GRP_DESCR\", \"varchar(30)\", 0)\n    (\"ACCT_GRP_ID\", \"varchar(4)\", 0)\n    (\"ACTV_CARRIER\", \"varchar(120)\", 0)\n    (\"ACTV_CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"ACTV_CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"AD_VAL_ACCT_LVL_ID\", \"varchar(4)\", 1)\n    (\"AD_VAL_DISABLED_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\", \"datetime\", 0)\n    (\"AD_VAL_HOMESTEAD_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_OVER_66_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"AD_VAL_VET_FLAG\", \"varchar(1)\", 0)\n    (\"ADDR_ID\", \"varchar(10)\", 0)\n    (\"ADJ_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOC_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOWABLE_NO_CHRG_INCDTS\", \"int\", 0)\n    (\"ALM_INSTL_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_INSTL_DTE\", \"datetime\", 0)\n    (\"ALM_MNT_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_REG_KEY\", \"varchar(20)\", 0)\n    (\"ALM_TYPE\", \"varchar(2)\", 0)\n    (\"ALT_PAYEE_NUM\", \"varchar(10)\", 0)\n    (\"AM_PM\", \"varchar(2)\", 0)\n    (\"APPLICTN_RECV_DTE\", \"datetime\", 0)\n    (\"APPRAISAL_DISTR_ACCT_NUM\", \"varchar(16)\", 0)\n    (\"AUTH_GRP_ID\", \"varchar(10)\", 0)\n    (\"BAL_SHT_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"BAL_UPD_IND\", \"varchar(1)\", 0)\n    (\"BILLED_FLAG\", \"varchar(1)\", 0)\n    (\"BILLING_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"BLANK_BUD_PER_ALLOWED\", \"varchar(1)\", 0)\n    (\"BLK_NUM\", \"varchar(8)\", 0)\n    (\"BOOT_SERIAL_NUM\", \"varchar(32)\", 0)\n    (\"BUS_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"BUS_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"BUS_AREA_ID\", \"varchar(4)\", 0)\n    (\"BUS_AREA_KEY\", \"int\", 0)\n    (\"BUS_CONT_PERSON_NAME\", \"varchar(40)\", 0)\n    (\"CAL_DAY_OF_MTH_NUM\", \"int\", 0)\n    (\"CAL_MTH\", \"varchar(15)\", 0)\n    (\"CAL_MTH_NUM\", \"int\", 0)\n    (\"CAL_PER\", \"varchar(20)\", 1)\n    (\"CAL_QTR\", \"varchar(15)\", 1)\n    (\"CAL_QTR_NUM\", \"int\", 0)\n    (\"CAL_WK_ENDING_SAT\", \"varchar(15)\", 0)\n    (\"CAL_YR\", \"int\", 0)\n    (\"CAN\", \"varchar(16)\", 1)\n    (\"CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_KEY\", \"int\", 0)\n    (\"CARRIER_NAME\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_BILL_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_DESCR\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_KEY\", \"int\", 0)\n    (\"CARRIER_PROCEDURE_SRC\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_TYPE\", \"varchar(40)\", 0)\n    (\"CARRIER_SRC\", \"varchar(120)\", 0)\n    (\"CC_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CC_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CENTRAL_POSTING_BLK\", \"varchar(1)\", 0)\n    (\"CENTRALLY_IMPOSED_PURCH_BLK\", \"varchar(1)\", 0)\n    (\"CHGED_BY\", \"varchar(12)\", 0)\n    (\"CHGED_ON\", \"datetime\", 0)\n    (\"CHGED_ON_DTE\", \"datetime\", 0)\n    (\"CHRT_OF_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"CHRT_OF_ACCT_ID\", \"varchar(4)\", 0)\n    (\"CHRT_OF_ACCT_NAME\", \"varchar(50)\", 0)\n    (\"CITY\", \"varchar(40)\", 0)\n    (\"CITY_BUS_DAY\", \"varchar(40)\", 1)\n    (\"CITY_HOL_FLAG\", \"varchar(1)\", 0)\n    (\"CITY_RFPD_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CITY_RFPD_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CMPNY_CODE_ID\", \"varchar(4)\", 0)\n    (\"CMPNY_CODE_NAME\", \"varchar(25)\", 0)\n    (\"COH\", \"varchar(20)\", 1)\n    (\"COH_EMP_NUM\", \"varchar(8)\", 0)\n    (\"COH_ORG_KEY\", \"int\", 0)\n    (\"COLL_BID_NUM\", \"varchar(10)\", 0)\n    (\"COLL_LAWSUIT_NUM\", \"varchar(7)\", 0)\n    (\"COLL_LGL_COND\", \"varchar(100)\", 0)\n    (\"COLL_PERSON_ID\", \"varchar(20)\", 0)\n    (\"COLL_PERSON_KEY\", \"int\", 0)\n    (\"COLL_PERSON_NAME\", \"varchar(120)\", 0)\n    (\"COLL_PERSON_TYPE\", \"varchar(40)\", 0)\n    (\"COLL_VEND_CONTR_KEY\", \"int\", 0)\n    (\"CONFI_ACCT_FLAG\", \"varchar(2)\", 1)\n    (\"CONFI_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"CONTR_DESCR\", \"varchar(1000)\", 1)\n    (\"CONTR_ID\", \"varchar(10)\", 0)\n    (\"CONTR_KEY\", \"int\", 0)\n    (\"CONTR_LIFE_PRIOD\", \"int\", 0)\n    (\"CONTR_PER_KEY\", \"int\", 0)\n    (\"CONTR_REV_STREAM\", \"varchar(50)\", 1)\n    (\"CONTR_YR\", \"varchar(15)\", 0)\n    (\"CONTR_YR_PER\", \"varchar(15)\", 0)\n    (\"CR_INFO_ID\", \"varchar(11)\", 0)\n    (\"CREATE_DTE\", \"datetime\", 0)\n    (\"CREATED_BY\", \"varchar(12)\", 0)\n    (\"CTRL_AREA_DESCR\", \"varchar(20)\", 0)\n    (\"CTRL_AREA_ID\", \"varchar(4)\", 0)\n    (\"CTRY_ID\", \"varchar(3)\", 0)\n    (\"CTRY_NAME\", \"varchar(15)\", 0)\n    (\"CURR_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_VERS_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_WTR_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_CITY\", \"varchar(40)\", 1)\n    (\"CUST_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_CTRY\", \"varchar(32)\", 1)\n    (\"CUST_EMAIL_ADDR\", \"varchar(100)\", 0)\n    (\"CUST_FAX_NUM\", \"varchar(15)\", 0)\n    (\"CUST_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"CUST_GIS_LAT\", \"varchar(38)\", 1)\n    (\"CUST_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_GIS_LONG\", \"varchar(38)\", 1)\n    (\"CUST_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"CUST_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"CUST_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"CUST_GIS_X\", \"varchar(21)\", 1)\n    (\"CUST_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_ID\", \"varchar(120)\", 0)\n    (\"CUST_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_IS_VEND_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_KEY\", \"int\", 0)\n    (\"CUST_NAME\", \"varchar(120)\", 0)\n    (\"CUST_PAR_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_PAR_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CTRY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_GIS_MATCH_SCORE\", \"varchar(3)\", 1)\n    (\"CUST_PAR_GIS_PREFIX\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_GIS_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_GIS_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_GIS_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_GIS_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_X\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_PAR_ID\", \"varchar(40)\", 0)\n    (\"CUST_PAR_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_PAR_KEY\", \"int\", 0)\n    (\"CUST_PAR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_PAR_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_PAR_ST\", \"varchar(100)\", 0)\n    (\"CUST_PAR_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_PAR_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_STATE\", \"varchar(25)\", 0)\n    (\"CUST_PAR_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"CUST_PAR_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"CUST_PHN_NUM_1\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_2\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_3\", \"varchar(20)\", 1)\n    (\"CUST_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_ST\", \"varchar(100)\", 0)\n    (\"CUST_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_STATE\", \"varchar(25)\", 0)\n    (\"CUST_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_TYPE\", \"varchar(13)\", 1)\n    (\"CUST_ZIP_CODE\", \"varchar(32)\", 1)\n    (\"CUST_ZIP_PLUS_4\", \"varchar(13)\", 1)\n    (\"DAY_OF_WK\", \"varchar(9)\", 0)\n    (\"DAY_OF_WK_NUM\", \"int\", 0)\n    (\"DEC_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DEL_FLAG\", \"varchar(1)\", 0)\n    (\"DELINQ_DTE\", \"datetime\", 0)\n    (\"DELIV_POLICY_FLAG\", \"varchar(1)\", 0)\n    (\"DEPT_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DEPT_NAME\", \"varchar(30)\", 1)\n    (\"DERIVED_NODE_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_PAR_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"DEST_LOC\", \"varchar(120)\", 0)\n    (\"DET_TRANS_CODE\", \"varchar(20)\", 0)\n    (\"DET_TRANS_DESCR\", \"varchar(50)\", 0)\n    (\"DIGITECH_ID\", \"varchar(20)\", 1)\n    (\"DIGITECH_TRANS_TYPE\", \"varchar(40)\", 1)\n    (\"DIGITECH_TRANS_TYPE_DET\", \"varchar(120)\", 1)\n    (\"DISASTER_FLAG\", \"varchar(1)\", 0)\n    (\"DISPATCH_NUM\", \"varchar(40)\", 0)\n    (\"DISTR\", \"varchar(40)\", 0)\n    (\"DIV_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DIV_NAME\", \"varchar(30)\", 1)\n    (\"DL_ISSUE_STATE\", \"varchar(20)\", 0)\n    (\"DL_NUM\", \"varchar(20)\", 0)\n    (\"DST_EX_MIN_FLAG\", \"varchar(1)\", 0)\n    (\"DTE\", \"date\", 0)\n    (\"DTE_FISC_PER_KEY\", \"int\", 0)\n    (\"DTE_KEY\", \"int\", 0)\n    (\"EMP_KEY\", \"int\", 0)\n    (\"EMP_NAME\", \"varchar(120)\", 0)\n    (\"EMP_TYPE\", \"varchar(40)\", 0)\n    (\"EMS_INCDT\", \"varchar(40)\", 0)\n    (\"EMS_INCDT_CAT\", \"varchar(120)\", 0)\n    (\"ENTRY_DTE\", \"datetime\", 0)\n    (\"ESC_CAND_FLAG\", \"varchar(1)\", 0)\n    (\"ETL_PROC_USED\", \"varchar(50)\", 0)\n    (\"EXCH_RATE_LOCAL\", \"numeric\", 0)\n    (\"EXCL_TYPE\", \"varchar(50)\", 0)\n    (\"EXP_DTE\", \"datetime\", 0)\n    (\"EXTRACT_DTE_TIME\", \"datetime\", 0)\n    (\"EXTRACT_PROC_USED\", \"varchar(50)\", 0)\n    (\"FAX\", \"varchar(40)\", 0)\n    (\"FED_FISC_PER\", \"varchar(15)\", 0)\n    (\"FED_FISC_PER_NUM\", \"int\", 0)\n    (\"FED_FISC_QTR\", \"varchar(15)\", 1)\n    (\"FED_FISC_QTR_NUM\", \"int\", 0)\n    (\"FED_FISC_YR\", \"varchar(15)\", 1)\n    (\"FED_TAX_ID\", \"varchar(40)\", 0)\n    (\"FG_FIN_TRANS_KEY\", \"int\", 0)\n    (\"FIN_MGMT_AREA\", \"varchar(4)\", 0)\n    (\"FIN_MGMT_AREA_DESCR\", \"varchar(25)\", 0)\n    (\"FIN_TRANS_TYPE_KEY\", \"int\", 0)\n    (\"FIRE_ALM_AGING_RST_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_NUM\", \"varchar(20)\", 0)\n    (\"FIRE_ALM_PURPOSE\", \"varchar(50)\", 0)\n    (\"FIRE_ORIG_ISSUE_DTE\", \"datetime\", 0)\n    (\"FISC_PER\", \"varchar(15)\", 0)\n    (\"FISC_PER_ANNUAL_SORT_ORD\", \"int\", 0)\n    (\"FISC_PER_NUM\", \"int\", 0)\n    (\"FISC_QTR\", \"varchar(15)\", 0)\n    (\"FISC_QTR_NUM\", \"int\", 0)\n    (\"FISC_YR\", \"int\", 0)\n    (\"FISC_YR_VARIANT\", \"varchar(2)\", 0)\n    (\"FM_AUTH_GRP\", \"varchar(10)\", 0)\n    (\"FM_FINUSE\", \"varchar(16)\", 0)\n    (\"FM_SPONSER\", \"varchar(10)\", 0)\n    (\"FUNC_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"FUNC_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUNC_AREA_ID\", \"varchar(16)\", 0)\n    (\"FUNC_AREA_KEY\", \"int\", 0)\n    (\"FUNC_THAT_WILL_BE_BLKED\", \"varchar(2)\", 1)\n    (\"FUND_BUD_PROF\", \"varchar(6)\", 0)\n    (\"FUND_CNTR_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_CNTR_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUND_CNTR_ID\", \"varchar(16)\", 0)\n    (\"FUND_CNTR_KEY\", \"int\", 0)\n    (\"FUND_CNTR_NAME\", \"varchar(20)\", 0)\n    (\"FUND_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_ID\", \"varchar(10)\", 0)\n    (\"FUND_KEY\", \"int\", 0)\n    (\"FUND_NAME\", \"varchar(20)\", 0)\n    (\"FUND_SUBSTR1\", \"varchar(10)\", 0)\n    (\"FUND_SUBSTR2\", \"varchar(10)\", 0)\n    (\"FUND_TYPE_DESCR\", \"varchar(35)\", 0)\n    (\"FUND_TYPE_ID\", \"varchar(6)\", 0)\n    (\"GL_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"GL_ACCT_GRP\", \"varchar(4)\", 0)\n    (\"GL_ACCT_ID\", \"varchar(30)\", 0)\n    (\"GL_ACCT_KEY\", \"int\", 0)\n    (\"GL_ACCT_MSTR_DESCR\", \"varchar(64)\", 0)\n    (\"GL_COMBO_KEY\", \"int\", 0)\n    (\"GRP_ACCT_NUM\", \"varchar(10)\", 0)\n    (\"HCAD_ACCT_STAT\", \"varchar(100)\", 0)\n    (\"HCTO_AD_VAL_ID\", \"varchar(22)\", 1)\n    (\"HCTO_DET_TRANS_DESCR\", \"varchar(50)\", 1)\n    (\"HCTO_FISC_PER\", \"varchar(15)\", 0)\n    (\"HCTO_FISC_PER_NUM\", \"int\", 0)\n    (\"HCTO_FISC_QTR\", \"varchar(15)\", 1)\n    (\"HCTO_FISC_QTR_NUM\", \"int\", 0)\n    (\"HCTO_FISC_YR\", \"varchar(15)\", 1)\n    (\"HH\", \"varchar(2)\", 0)\n    (\"HIER_ID\", \"varchar(30)\", 0)\n    (\"HOL_DESCR\", \"varchar(40)\", 1)\n    (\"HOUSE_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"INCDT_APT_LOT\", \"varchar(20)\", 0)\n    (\"INCDT_CAT\", \"varchar(40)\", 0)\n    (\"INCDT_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_CNTY\", \"varchar(20)\", 0)\n    (\"INCDT_CTRY\", \"varchar(20)\", 0)\n    (\"INCDT_DESCR\", \"varchar(40)\", 0)\n    (\"INCDT_DTE\", \"datetime\", 0)\n    (\"INCDT_GIS_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"INCDT_GIS_LAT\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"INCDT_GIS_LONG\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"INCDT_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"INCDT_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_X\", \"varchar(21)\", 1)\n    (\"INCDT_GIS_Y\", \"varchar(17)\", 0)\n    (\"INCDT_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"INCDT_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"INCDT_KEY\", \"int\", 0)\n    (\"INCDT_PREFIX\", \"varchar(2)\", 0)\n    (\"INCDT_SEQ_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_SERV_LVL\", \"varchar(120)\", 0)\n    (\"INCDT_ST\", \"varchar(100)\", 0)\n    (\"INCDT_ST_DIR\", \"varchar(4)\", 0)\n    (\"INCDT_ST_NAME\", \"varchar(35)\", 0)\n    (\"INCDT_ST_NUM\", \"varchar(7)\", 0)\n    (\"INCDT_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"INCDT_ST_TYPE\", \"varchar(4)\", 0)\n    (\"INCDT_STATE\", \"varchar(25)\", 0)\n    (\"INCDT_SUFF\", \"varchar(2)\", 0)\n    (\"INCDT_TIME\", \"varchar(8)\", 0)\n    (\"INCDT_TYPE\", \"varchar(40)\", 0)\n    (\"INCDT_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"INCDT_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"INDY_DESCR\", \"varchar(20)\", 0)\n    (\"INDY_ID\", \"varchar(4)\", 0)\n    (\"INT_EXT_EMP_FLAG\", \"varchar(1)\", 0)\n    (\"INTER_CMPNY_TERM02_NAME\", \"varchar(28)\", 0)\n    (\"INTRA_FUND_TRANS_AMT\", \"money\", 1)\n    (\"INTRA_FUND_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"INV_NUM\", \"varchar(40)\", 0)\n    (\"INVALID INPUT\", \"nvarchar(100)\", 1)\n    (\"INVALID INPUT ERROR DESCRIPTION\", \"nvarchar(1000)\", 1)\n    (\"ITEM_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"ITEM_APT_LOT\", \"varchar(20)\", 0)\n    (\"ITEM_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_CNTY\", \"varchar(20)\", 0)\n    (\"ITEM_CTRY\", \"varchar(20)\", 0)\n    (\"ITEM_DESCR\", \"varchar(255)\", 1)\n    (\"ITEM_EXMPT_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_GIS_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"ITEM_GIS_LAT\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"ITEM_GIS_LONG\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"ITEM_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"ITEM_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_X\", \"varchar(21)\", 1)\n    (\"ITEM_GIS_Y\", \"varchar(17)\", 0)\n    (\"ITEM_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"ITEM_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_KEY\", \"int\", 0)\n    (\"ITEM_PREFIX\", \"varchar(2)\", 0)\n    (\"ITEM_SERV_LVL\", \"varchar(40)\", 0)\n    (\"ITEM_ST\", \"varchar(100)\", 0)\n    (\"ITEM_ST_DIR\", \"varchar(4)\", 0)\n    (\"ITEM_ST_NAME\", \"varchar(35)\", 0)\n    (\"ITEM_ST_NUM\", \"varchar(13)\", 1)\n    (\"ITEM_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"ITEM_ST_TYPE\", \"varchar(4)\", 0)\n    (\"ITEM_STAT\", \"varchar(40)\", 0)\n    (\"ITEM_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"ITEM_STATE\", \"varchar(25)\", 0)\n    (\"ITEM_SUFF\", \"varchar(2)\", 0)\n    (\"ITEM_TYPE\", \"varchar(40)\", 0)\n    (\"ITEM_ZIP_CODE\", \"varchar(13)\", 1)\n    (\"ITEM_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"JV_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"LANG_ID\", \"varchar(1)\", 0)\n    (\"LAST_CUST_CONN_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_CUTOFF_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_DISCONN_DTE\", \"datetime\", 0)\n    (\"LAST_METER_INSPECT_DTE\", \"datetime\", 0)\n    (\"LICENSE_PLATE_EXP_MTH\", \"varchar(3)\", 0)\n    (\"LICENSE_PLATE_EXP_YR\", \"varchar(4)\", 0)\n    (\"LICENSE_PLATE_NUM\", \"varchar(10)\", 0)\n    (\"LICENSE_PLATE_TYPE\", \"varchar(20)\", 0)\n    (\"LOAD_DTE\", \"datetime\", 0)\n    (\"LOAD_DTE_TIME\", \"datetime\", 0)\n    (\"LOAD_TIME\", \"varchar(8)\", 0)\n    (\"LOGICAL_SYS\", \"varchar(10)\", 0)\n    (\"MAN_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"MEDICAID_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MEDICARE_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MIN\", \"varchar(5)\", 0)\n    (\"MSTR_REC_CNTRL_DEL_BLK\", \"varchar(1)\", 0)\n    (\"MSTR_SUBDIV_ID\", \"varchar(10)\", 0)\n    (\"MSTR_TRANS_TYPE\", \"varchar(20)\", 0)\n    (\"MUNIC_UTIL_DISTR_CODE\", \"varchar(13)\", 1)\n    (\"MUNIC_UTIL_DISTR_DESCR\", \"varchar(50)\", 0)\n    (\"NAICS_DET_CODE\", \"varchar(6)\", 0)\n    (\"NAICS_DET_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_DIV_CODE\", \"varchar(2)\", 0)\n    (\"NAICS_DIV_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_CODE\", \"varchar(5)\", 0)\n    (\"NAICS_INDY_GRP_CODE\", \"varchar(4)\", 0)\n    (\"NAICS_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_MAJ_GRP_CODE\", \"varchar(3)\", 0)\n    (\"NAICS_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NODE_FLAG\", \"varchar(1)\", 0)\n    (\"NUM_OF_ACRES\", \"varchar(13)\", 1)\n    (\"ON_ADMIN_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"ONE_TIME_ACCT_DESCR\", \"varchar(5)\", 0)\n    (\"ORIG_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"ORIG_BILL_NAME\", \"varchar(120)\", 1)\n    (\"ORIG_CUST_KEY\", \"int\", 0)\n    (\"ORIG_INV_NUM\", \"varchar(40)\", 0)\n    (\"ORIGIN_LOC\", \"varchar(120)\", 0)\n    (\"OWNER_IS_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"OWNER_RENTER\", \"varchar(1)\", 0)\n    (\"OWNERSHIP_EFF_DTE\", \"datetime\", 0)\n    (\"PAY_BLK\", \"varchar(1)\", 0)\n    (\"PAY_METH\", \"varchar(15)\", 0)\n    (\"PAYROLL_PER\", \"int\", 0)\n    (\"PER_END_DTE\", \"date\", 1)\n    (\"PERMIT_EXP_DTE\", \"datetime\", 0)\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"varchar(1)\", 0)\n    (\"PERMIT_ISSUE_DTE\", \"datetime\", 0)\n    (\"PERMIT_NAME\", \"varchar(120)\", 0)\n    (\"PERMIT_NUM\", \"int\", 0)\n    (\"PERSON_IN_CHRG\", \"varchar(20)\", 0)\n    (\"PERSON_IN_CHRG_ID\", \"varchar(8)\", 0)\n    (\"PHN\", \"varchar(30)\", 0)\n    (\"PL_STMNT_ACCT_TYPE\", \"varchar(2)\", 0)\n    (\"PLANT_ID\", \"varchar(4)\", 0)\n    (\"PLANT_NAME\", \"varchar(30)\", 0)\n    (\"PMAM_ADJMT_TO\", \"varchar(20)\", 1)\n    (\"PMAM_ADJMT_TYPE\", \"varchar(50)\", 1)\n    (\"PMAM_ID\", \"varchar(20)\", 0)\n    (\"POST_DTE_KEY\", \"int\", 1)\n    (\"PRKG_METER_NUM\", \"varchar(8)\", 0)\n    (\"PRKG_METER_VIO_FLAG\", \"varchar(1)\", 0)\n    (\"PROP_CLASS_CODE\", \"varchar(13)\", 1)\n    (\"PROP_CLASS_DESCR\", \"varchar(50)\", 0)\n    (\"PT_AGE\", \"varchar(3)\", 0)\n    (\"PT_GNDR\", \"varchar(10)\", 0)\n    (\"QTRLY_PAY_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_1ST_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_EVER_TRANS_FLAG\", \"varchar(1)\", 1)\n    (\"RECEIVABLE_FNL_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_HAS_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_NOTE_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_KEY\", \"int\", 0)\n    (\"RECEIVABLE_LITIGATION_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_MSTR_STAT\", \"varchar(40)\", 1)\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DELINQ_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_ISSUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_SETTLEMENT_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_STAT\", \"varchar(40)\", 0)\n    (\"RECEIVABLE_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_TO_DTE\", \"datetime\", 0)\n    (\"REG_HOLDER_FLAG\", \"varchar(1)\", 0)\n    (\"REGION_ID\", \"varchar(3)\", 0)\n    (\"REGION_NAME\", \"varchar(20)\", 0)\n    (\"REINSTATEMENT_DTE\", \"datetime\", 1)\n    (\"RELE_REAL_COVER_ELIG\", \"varchar(1)\", 0)\n    (\"REND_PENALTY_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"REND_PENALTY_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"RESOLVE_DESCR\", \"varchar(128)\", 0)\n    (\"RESOLVE_DTE\", \"datetime\", 1)\n    (\"RESOLVE_RSN\", \"varchar(40)\", 1)\n    (\"RESOLVED_BY\", \"varchar(120)\", 0)\n    (\"REVERSAL_DTE\", \"datetime\", 0)\n    (\"RM_EMP_MSTR_KEY\", \"varchar(16)\", 1)\n    (\"RM_LOAD_DTE\", \"datetime\", 0)\n    (\"RM_LOAD_TIME\", \"varchar(8)\", 0)\n    (\"ROW_CHG_RSN\", \"varchar(100)\", 1)\n    (\"RSN_INCDT_NOT_BILLED\", \"varchar(40)\", 0)\n    (\"SAP_BUS_ID\", \"varchar(20)\", 0)\n    (\"SCHOOL_JURIS_CODE\", \"varchar(22)\", 1)\n    (\"SCHOOL_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"SCND_TEL_NUM\", \"varchar(16)\", 0)\n    (\"SEN_CITIZEN_FLAG\", \"varchar(1)\", 0)\n    (\"SIC_CODE\", \"varchar(8)\", 0)\n    (\"SIC_DIV_CODE\", \"varchar(20)\", 0)\n    (\"SIC_DIV_NAME\", \"varchar(40)\", 0)\n    (\"SIC_INDY_GRP_CODE\", \"varchar(3)\", 0)\n    (\"SIC_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_MAJ_GRP_CODE\", \"varchar(2)\", 0)\n    (\"SIC_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_NAME\", \"varchar(40)\", 0)\n    (\"SIG_FLAG\", \"varchar(1)\", 0)\n    (\"SMART_CM_ID\", \"varchar(20)\", 0)\n    (\"SMARTCM_IS_ADJMT\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_FEE\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_PAY\", \"varchar(1)\", 1)\n    (\"SMARTCM_OTHER_CRITERIA\", \"varchar(50)\", 1)\n    (\"SRC_CARRIER_KEY\", \"varchar(40)\", 0)\n    (\"SRC_CARRIER_PROCEDURE_KEY\", \"varchar(40)\", 0)\n    (\"SRC_SYS\", \"varchar(40)\", 0)\n    (\"SRC_SYS_ID\", \"varchar(120)\", 0)\n    (\"SRC_SYS_MOD_DTE\", \"datetime\", 1)\n    (\"SRC_SYS_TRANS_ID\", \"varchar(40)\", 1)\n    (\"SRC_SYS_VEH_ID\", \"varchar(32)\", 1)\n    (\"ST\", \"varchar(60)\", 0)\n    (\"STATE_CORP_CHTR_ID\", \"varchar(20)\", 0)\n    (\"STATE_FISC_PER\", \"varchar(15)\", 0)\n    (\"STATE_FISC_PER_NUM\", \"int\", 0)\n    (\"STATE_FISC_QTR\", \"varchar(15)\", 1)\n    (\"STATE_FISC_QTR_NUM\", \"int\", 0)\n    (\"STATE_FISC_YR\", \"varchar(15)\", 1)\n    (\"STATE_SALES_TAX_ID\", \"varchar(20)\", 0)\n    (\"SUBSTANTIAL_ERR_PENALTY\", \"varchar(1)\", 0)\n    (\"SUSPD_PERMIT_DTE\", \"datetime\", 0)\n    (\"SUSPD_PERMIT_RSN\", \"varchar(50)\", 0)\n    (\"SYS_LOAD_KEY\", \"int\", 0)\n    (\"T2_ID\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\", \"varchar(10)\", 0)\n    (\"T2_TRANS_PARSED_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_RSN\", \"varchar(50)\", 0)\n    (\"T2_TRANS_SCENARIO\", \"varchar(50)\", 0)\n    (\"T2_TRANS_TYPE_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_TYPE_DESCR\", \"varchar(50)\", 0)\n    (\"TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"TAX_NUM_1\", \"varchar(16)\", 0)\n    (\"TAX_NUM_2\", \"varchar(11)\", 0)\n    (\"TAX_ROLL_CODE\", \"varchar(13)\", 1)\n    (\"TAX_ROLL_DESCR\", \"varchar(50)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_1\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_2\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_3\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_4\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_5\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_ROLL_TYPE\", \"varchar(50)\", 0)\n    (\"TIME_KEY\", \"int\", 0)\n    (\"TOWING_CMPNY\", \"varchar(40)\", 0)\n    (\"TRADING_PRN_ID\", \"varchar(6)\", 0)\n    (\"TRADING_PRN_NAME\", \"varchar(30)\", 0)\n    (\"TRANS_AMT\", \"money\", 1)\n    (\"TRANS_CNT\", \"int\", 1)\n    (\"TRANS_DTE_KEY\", \"int\", 0)\n    (\"TXP_SERV_LVL\", \"varchar(120)\", 0)\n    (\"TXP_TYPE\", \"varchar(40)\", 0)\n    (\"TYPE_OF_ALM_SITE\", \"varchar(1)\", 0)\n    (\"UNDER_APPEAL_FLAG\", \"varchar(1)\", 0)\n    (\"UNIQ_VEND_NAME\", \"varchar(120)\", 1)\n    (\"UNK_CUST_AT_BILL_FLAG\", \"varchar(1)\", 1)\n    (\"VAC_FLAG\", \"varchar(1)\", 0)\n    (\"VALID_FROM_DTE\", \"datetime\", 0)\n    (\"VALID_TO_DTE\", \"datetime\", 0)\n    (\"VEH\", \"varchar(40)\", 0)\n    (\"VEH_COLOR\", \"varchar(40)\", 0)\n    (\"VEH_ID_NUM\", \"varchar(24)\", 0)\n    (\"VEH_MAKE\", \"varchar(40)\", 0)\n    (\"VEH_MODEL\", \"varchar(40)\", 0)\n    (\"VEH_MODEL_YR\", \"varchar(4)\", 0)\n    (\"VEH_OWNER_ID\", \"varchar(32)\", 0)\n    (\"VEH_OWNER_NAME\", \"varchar(120)\", 0)\n    (\"VEH_TYPE\", \"varchar(40)\", 0)\n    (\"VEND_BILLER_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_COLLR_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_CUST_ID\", \"varchar(10)\", 0)\n    (\"VEND_CUST_NAME\", \"varchar(40)\", 0)\n    (\"VEND_FULL_NAME\", \"varchar(120)\", 0)\n    (\"VEND_GRP_KEY\", \"varchar(10)\", 0)\n    (\"VEND_ID\", \"varchar(10)\", 0)\n    (\"VEND_KEY\", \"int\", 0)\n    (\"VEND_NAME\", \"varchar(40)\", 0)\n    (\"VEND_NAME_01\", \"varchar(40)\", 0)\n    (\"VEND_NAME_02\", \"varchar(40)\", 0)\n    (\"VEND_NAME_03\", \"varchar(40)\", 0)\n    (\"VEND_NAME_04\", \"varchar(40)\", 0)\n    (\"VERS_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"VERS_BEG_DTE\", \"datetime\", 0)\n    (\"VERS_END_DTE\", \"datetime\", 0)\n    (\"VIO_CODE\", \"varchar(20)\", 0)\n    (\"VOID_CODE\", \"varchar(10)\", 0)\n    (\"VOID_DESCR\", \"varchar(50)\", 0)\n    (\"VOID_FLAG\", \"varchar(1)\", 0)\n    (\"WK_IN_CAL_YR\", \"int\", 0)\n    (\"WKND_FLAG\", \"varchar(1)\", 0)\n    (\"WORK_STAT\", \"varchar(50)\", 0)\n    (\"WRITE_OFF_FLAG\", \"varchar(1)\", 0)\n    (\"WTR_ACCT_NUM_OF_UNITS\", \"int\", 0)\n    (\"WTR_ACCT_ORIG_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_ACCT_PROP_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_METER_NUM\", \"varchar(50)\", 0)\n    (\"ZIP\", \"varchar(10)\", 0) |]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},"expanded":true,"level":0,"properties":{}},{"name":"FieldDefaults","content":"let fieldDefault = [|\n    (\"LOAD_DTE\"                            , \"GETDATE()\"   )\n    (\"LOAD_TIME\"                           , \"CONVERT(VARCHAR(8),GETDATE(),108)\")\n    (\"VERS_ASSIGNED_VEND\"                  , \"'CoH'\")\n    (\"MEDICARE_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"MEDICAID_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_GRP\"                     , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_CLASS\"                   , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_GRP\"                         , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_NAME\"                        , \"'(SYS) UNKNOWN'\")\n    (\"SRC_CARRIER_CODE\"                    , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_CODE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_DESCR\"             , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_TYPE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_BILL_CODE\"         , \"'(SYS) UNKNOWN'\")\n    (\"VEH\"                                 , \"'(SYS) UNKNOWN'\")\n    (\"EMS_INCDT_CAT\"                       , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_GRP\"                , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_CLASS\"              , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER\"                        , \"'(SYS) UNKNOWN'\")\n    (\"NAICS_DET_CODE\"                      , \"'*'\")\n    (\"NAICS_DIV_CODE\"                      , \"'*'\")\n    (\"SIC_MAJ_GRP_CODE\"                    , \"'*'\")\n    (\"DEC_CUST_FLAG\"                       , \"'*'\")\n    (\"CUST_PREFIX\"                         , \"'*'\")\n    (\"CUST_SUFF\"                           , \"'*'\")\n    (\"CUST_GIS_PREFIX\"                     , \"'*'\")\n    (\"CUST_GIS_SUFF\"                       , \"'*'\")\n    (\"ALLOC_TRANS_FLAG\"                    , \"'*'\")\n    (\"SMARTCM_OTHER_CRITERIA\"              , \"'*'\")\n    (\"SMARTCM_IS_FEE\"                      , \"'*'\")\n    (\"SMARTCM_IS_ADJMT\"                    , \"'*'\")\n    (\"SMARTCM_IS_PAY\"                      , \"'*'\")\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"'*'\")\n    (\"PRKG_METER_VIO_FLAG\"                 , \"'*'\")\n    (\"INCDT_PREFIX\"                        , \"'*'\")\n    (\"INCDT_SUFF\"                          , \"'*'\")\n    (\"INCDT_IN_CITY_FLAG\"                  , \"'*'\")\n    (\"INCDT_GIS_PREFIX\"                    , \"'*'\")\n    (\"INCDT_GIS_SUFF\"                      , \"'*'\")\n    (\"ITEM_EXMPT_FLAG\"                     , \"'*'\")\n    (\"ITEM_PREFIX\"                         , \"'*'\")\n    (\"ITEM_SUFF\"                           , \"'*'\")\n    (\"ITEM_GIS_PREFIX\"                     , \"'*'\")\n    (\"ITEM_GIS_SUFF\"                       , \"'*'\")\n    (\"FIRE_ALM_AGING_RST_FLAG\"             , \"'*'\")\n    (\"AD_VAL_VET_FLAG\"                     , \"'*'\")\n    (\"AD_VAL_DISABLED_FLAG\"                , \"'*'\")\n    (\"AD_VAL_OVER_66_FLAG\"                 , \"'*'\")\n    (\"AD_VAL_HOMESTEAD_FLAG\"               , \"'*'\")\n    (\"QTRLY_PAY_FLAG\"                      , \"'*'\")\n    (\"SRC_CARRIER_KEY\"                     , \"'***'\")\n    (\"SRC_CARRIER_PROCEDURE_KEY\"           , \"'***'\")\n    (\"COLL_PERSON_ID\"                      , \"'***'\")\n    (\"T2_ID\"                               , \"'***'\")\n    (\"PMAM_ID\"                             , \"'***'\")\n    (\"SMART_CM_ID\"                         , \"'***'\")\n    (\"HCTO_AD_VAL_ID\"                      , \"'***'\")\n    (\"COLL_PERSON_COH_EMP_NUM\"             , \"'***'\")\n    (\"CUST_EMAIL_ADDR\"                     , \"'***'\")\n    (\"CUST_PHN_NUM_1\"                      , \"'***'\")\n    (\"CUST_FAX_NUM\"                        , \"'***'\")\n    (\"FED_TAX_ID\"                          , \"'***'\")\n    (\"BUS_CONT_PERSON_NAME\"                , \"'***'\")\n    (\"STATE_CORP_CHTR_ID\"                  , \"'***'\")\n    (\"STATE_SALES_TAX_ID\"                  , \"'***'\")\n    (\"SAP_BUS_ID\"                          , \"'***'\")\n    (\"NAICS_INDY_CODE\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_CODE\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_CODE\"                  , \"'***'\")\n    (\"SIC_INDY_GRP_CODE\"                   , \"'***'\")\n    (\"SIC_DIV_CODE\"                        , \"'***'\")\n    (\"DL_ISSUE_STATE\"                      , \"'***'\")\n    (\"DL_NUM\"                              , \"'***'\")\n    (\"CUST_ADDR_LINE_1\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_2\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_3\"                    , \"'***'\")\n    (\"CUST_ST_NUM\"                         , \"'***'\")\n    (\"CUST_ST_PRETYPE\"                     , \"'***'\")\n    (\"CUST_ST_NAME\"                        , \"'***'\")\n    (\"CUST_ST_TYPE\"                        , \"'***'\")\n    (\"CUST_SERV_LVL\"                       , \"'***'\")\n    (\"CUST_CITY\"                           , \"'***'\")\n    (\"CUST_STATE\"                          , \"'***'\")\n    (\"CUST_CTRY\"                           , \"'***'\")\n    (\"CUST_ST_DIR\"                         , \"'***'\")\n    (\"CUST_ST\"                             , \"'***'\")\n    (\"CUST_CNTY\"                           , \"'***'\")\n    (\"CUST_APT_LOT\"                        , \"'***'\")\n    (\"CUST_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"CUST_GIS_ST_NUM\"                     , \"'***'\")\n    (\"CUST_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"CUST_GIS_ST_NAME\"                    , \"'***'\")\n    (\"CUST_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"CUST_GIS_CITY\"                       , \"'***'\")\n    (\"CUST_GIS_ZIP\"                        , \"'***'\")\n    (\"CUST_GIS_X\"                          , \"'***'\")\n    (\"CUST_GIS_Y\"                          , \"'***'\")\n    (\"CUST_ZIP_CODE\"                       , \"'***'\")\n    (\"CUST_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"CUST_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"SIC_CODE\"                            , \"'***'\")\n    (\"NAICS_DET_NAME\"                      , \"'***'\")\n    (\"NAICS_INDY_NAME\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_NAME\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_NAME\"                  , \"'***'\")\n    (\"NAICS_DIV_NAME\"                      , \"'***'\")\n    (\"SIC_NAME\"                            , \"'***'\")\n    (\"SIC_INDY_GRP_NAME\"                   , \"'***'\")\n    (\"SIC_MAJ_GRP_NAME\"                    , \"'***'\")\n    (\"SIC_DIV_NAME\"                        , \"'***'\")\n    (\"CUST_PHN_NUM_2\"                      , \"'***'\")\n    (\"CUST_PHN_NUM_3\"                      , \"'***'\")\n    (\"CUST_PAR_ID\"                         , \"'***'\")\n    (\"CUST_PAR_NAME\"                       , \"'***'\")\n    (\"COH_EMP_NUM\"                         , \"'***'\")\n    (\"RM_LOAD_TIME\"                        , \"'***'\")\n    (\"RM_EMP_MSTR_KEY\"                     , \"'***'\")\n    (\"PAY_METH\"                            , \"'***'\")\n    (\"DET_TRANS_CODE\"                      , \"'***'\")\n    (\"T2_TRANS_TYPE_CODE\"                  , \"'***'\")\n    (\"T2_TRANS_TYPE_DESCR\"                 , \"'***'\")\n    (\"T2_TRANS_RSN\"                        , \"'***'\")\n    (\"T2_TRANS_PARSED_DESCR\"               , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_CODE\"             , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_DESCR\"            , \"'***'\")\n    (\"T2_TRANS_SCENARIO\"                   , \"'***'\")\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\"           , \"'***'\")\n    (\"PMAM_ADJMT_TO\"                       , \"'***'\")\n    (\"PMAM_ADJMT_TYPE\"                     , \"'***'\")\n    (\"DIGITECH_TRANS_TYPE_DET\"             , \"'***'\")\n    (\"RSN_INCDT_NOT_BILLED\"                , \"'***'\")\n    (\"VIO_CODE\"                            , \"'***'\")\n    (\"TOWING_CMPNY\"                        , \"'***'\")\n    (\"BOOT_SERIAL_NUM\"                     , \"'***'\")\n    (\"PRKG_METER_NUM\"                      , \"'***'\")\n    (\"INCDT_SEQ_NUM\"                       , \"'***'\")\n    (\"INCDT_ADDR_LINE_1\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_2\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_3\"                   , \"'***'\")\n    (\"INCDT_ST_NUM\"                        , \"'***'\")\n    (\"INCDT_ST_PRETYPE\"                    , \"'***'\")\n    (\"INCDT_ST_NAME\"                       , \"'***'\")\n    (\"INCDT_ST_TYPE\"                       , \"'***'\")\n    (\"INCDT_SERV_LVL\"                      , \"'***'\")\n    (\"INCDT_CITY\"                          , \"'***'\")\n    (\"INCDT_STATE\"                         , \"'***'\")\n    (\"INCDT_CTRY\"                          , \"'***'\")\n    (\"INCDT_ST_DIR\"                        , \"'***'\")\n    (\"INCDT_ST\"                            , \"'***'\")\n    (\"INCDT_CNTY\"                          , \"'***'\")\n    (\"INCDT_APT_LOT\"                       , \"'***'\")\n    (\"INCDT_GIS_MATCH_SCORE\"               , \"'***'\")\n    (\"INCDT_GIS_ST_NUM\"                    , \"'***'\")\n    (\"INCDT_GIS_ST_PRETYPE\"                , \"'***'\")\n    (\"INCDT_GIS_ST_NAME\"                   , \"'***'\")\n    (\"INCDT_GIS_ST_TYPE\"                   , \"'***'\")\n    (\"INCDT_GIS_CITY\"                      , \"'***'\")\n    (\"INCDT_GIS_ZIP\"                       , \"'***'\")\n    (\"INCDT_GIS_X\"                         , \"'***'\")\n    (\"INCDT_GIS_Y\"                         , \"'***'\")\n    (\"INCDT_ZIP_CODE\"                      , \"'***'\")\n    (\"INCDT_ZIP_PLUS_4\"                    , \"'***'\")\n    (\"INCDT_GIS_LOCATR_NAME\"               , \"'***'\")\n    (\"BLK_NUM\"                             , \"'***'\")\n    (\"TXP_ID\"                              , \"'***'\")\n    (\"TXP_SERV_LVL\"                        , \"'***'\")\n    (\"TXP_TYPE\"                            , \"'***'\")\n    (\"ORIGIN_LOC\"                          , \"'***'\")\n    (\"DEST_LOC\"                            , \"'***'\")\n    (\"ITEM_STAT\"                           , \"'***'\")\n    (\"ITEM_ADDR_LINE_1\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_2\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_3\"                    , \"'***'\")\n    (\"ITEM_ST_NUM\"                         , \"'***'\")\n    (\"ITEM_ST_PRETYPE\"                     , \"'***'\")\n    (\"ITEM_ST_NAME\"                        , \"'***'\")\n    (\"ITEM_ST_TYPE\"                        , \"'***'\")\n    (\"ITEM_SERV_LVL\"                       , \"'***'\")\n    (\"ITEM_CITY\"                           , \"'***'\")\n    (\"ITEM_STATE\"                          , \"'***'\")\n    (\"ITEM_CTRY\"                           , \"'***'\")\n    (\"ITEM_ST_DIR\"                         , \"'***'\")\n    (\"ITEM_ST\"                             , \"'***'\")\n    (\"ITEM_CNTY\"                           , \"'***'\")\n    (\"ITEM_APT_LOT\"                        , \"'***'\")\n    (\"ITEM_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"ITEM_GIS_ST_NUM\"                     , \"'***'\")\n    (\"ITEM_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"ITEM_GIS_ST_NAME\"                    , \"'***'\")\n    (\"ITEM_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"ITEM_GIS_CITY\"                       , \"'***'\")\n    (\"ITEM_GIS_ZIP\"                        , \"'***'\")\n    (\"ITEM_GIS_X\"                          , \"'***'\")\n    (\"ITEM_GIS_Y\"                          , \"'***'\")\n    (\"ITEM_ZIP_CODE\"                       , \"'***'\")\n    (\"ITEM_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"ITEM_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"HCAD_ACCT_STAT\"                      , \"'***'\")\n    (\"AD_VAL_ACCT_LVL_ID\"                  , \"'***'\")\n    (\"COLL_LGL_COND\"                       , \"'***'\")\n    (\"COLL_LAWSUIT_NUM\"                    , \"'***'\")\n    (\"GL_ACCT_ID\"                          , \"'0000247130'\")\n    (\"INCDT_TIME\"                          , \"'00:00:00'\")\n    (\"FUND_ID\"                             , \"'1000'\")\n    (\"EMS_INCDT\"                           , \"'***'\")\n    (\"DISPATCH_NUM\"                        , \"'100073'\")\n    (\"FUND_CNTR_ID\"                        , \"'1200030003'\")\n    (\"CONTR_ID\"                            , \"'4600012363'\")\n    (\"PT_AGE\"                              , \"'***'\")\n    (\"BUS_AREA_ID\"                         , \"'6400'\")\n    (\"RECEIVABLE_STAT\"                     , \"'ACTIVE'\")\n    (\"DET_TRANS_DESCR\"                     , \"'Base Amount Billed'\")\n    (\"MSTR_TRANS_TYPE\"                     , \"'Billed'\")\n    (\"CUST_NAME\"                           , \"'***'\")\n    (\"ORIG_BILL_NAME\"                      , \"'***'\")\n    (\"COLL_PERSON_TYPE\"                    , \"'COH Contractor'\")\n    (\"EMP_NAME\"                            , \"'***'\")\n    (\"ITEM_TYPE\"                           , \"'***'\")\n    (\"ITEM_DESCR\"                          , \"'***'\")\n    (\"INCDT_TYPE\"                          , \"'***'\")\n    (\"INCDT_CAT\"                           , \"'***'\")\n    (\"DIV_LONG_NAME\"                       , \"'***'\")\n    (\"INCDT_DESCR\"                         , \"'***'\")\n    (\"EMP_TYPE\"                            , \"'Employee'\")\n    (\"FUNC_AREA_ID\"                        , \"'GEGO-00-00000000'\")\n    (\"DEPT_LONG_NAME\"                      , \"'***'\")\n    (\"CUST_TYPE\"                           , \"'Individual'\")\n    (\"PT_GNDR\"                             , \"'***'\")\n    (\"COLL_PERSON_NAME\"                    , \"'Employee'\")\n    (\"DIGITECH_ID\"                         , \"'***'\")\n    (\"CARRIER_SRC\"                         , \"'***'\")\n    (\"CARRIER_PROCEDURE_SRC\"               , \"'***'\")\n    (\"CUST_IS_VEND_FLAG\"                   , \"'N'\")\n    (\"JV_CUST_FLAG\"                        , \"'N'\")\n    (\"MAN_TRANS_FLAG\"                      , \"'N'\")\n    (\"DERIVED_TRANS_FLAG\"                  , \"'N'\")\n    (\"INTRA_FUND_TRANS_FLAG\"               , \"'N'\")\n    (\"ADJ_FLAG\"                            , \"'N'\")\n    (\"UNK_CUST_AT_BILL_FLAG\"               , \"'N'\")\n    (\"BILLING_HOLD_FLAG\"                   , \"'N'\")\n    (\"SIG_FLAG\"                            , \"'N'\")\n    (\"RECEIVABLE_MSTR_STAT\"                , \"'Open'\")\n    (\"DIGITECH_TRANS_TYPE\"                 , \"'PROCS'\")\n    (\"INT_EXT_EMP_FLAG\"                    , \"'Y'\")\n    (\"CONFI_CUST_FLAG\"                     , \"'Y'\")\n    (\"CUST_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"BILLED_FLAG\"                         , \"'Y'\")\n    (\"ITEM_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"RECEIVABLE_EVER_TRANS_FLAG\"          , \"'Y'\")\n    (\"CUST_PAR_KEY\"                        , \"1\")\n    (\"TRANS_CNT\"                           , \"1\")\n    (\"SRC_SYS_MOD_DTE\"                     , \"'1900-01-01'\")\n    (\"RM_LOAD_DTE\"                         , \"'1900-01-01'\")\n    (\"ITEM_STAT_CHG_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_STAT_CHG_DTE\"             , \"'1900-01-01'\")\n    (\"FIRE_ORIG_ISSUE_DTE\"                 , \"'1900-01-01'\")\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\"        , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\"       , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\"         , \"'1900-01-01'\")\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\"         , \"'1900-01-01'\")\n    (\"3348_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3308_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3307_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DELINQ_DTE\"          , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DUE_DTE\"             , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_TO_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\"      , \"'1900-01-01'\")\n    (\"INCDT_DTE\"                           , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_ISSUE_DTE\"           , \"'1900-01-01'\")\n    (\"INTRA_FUND_TRANS_AMT\"                , \"NULL\"        )\n    (\"RECEIVABLE_1ST_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_FNL_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_LITIGATION_DTE\"           , \"'1900-01-01'\")\n    (\"RECEIVABLE_SETTLEMENT_DTE\"           , \"'1900-01-01'\")\n    (\"REINSTATEMENT_DTE\"                   , \"'1900-01-01'\")\n    (\"SRC_SYS_TRANS_ID\"                    , \"'***'\"       )\n\n    (\"ALLOWABLE_NO_CHRG_INCDTS\"            , \"0\"           )\n    (\"ALM_INSTL_CMPNY\"                     , \"'***'\"       )\n    (\"ALM_INSTL_DTE\"                       , \"'1900-01-01'\")\n    (\"ALM_MNT_CMPNY\"                       , \"'***'\"       )\n    (\"ALM_REG_KEY\"                         , \"'***'\"       )\n    (\"ALM_TYPE\"                            , \"'*'\"         )\n    (\"APPLICTN_RECV_DTE\"                   , \"'1900-01-01'\")\n    (\"APPRAISAL_DISTR_ACCT_NUM\"            , \"'***'\"       )\n    (\"CC_JURIS_DESCR\"                      , \"'***'\"       )\n    (\"CITY_RFPD_JURIS_DESCR\"               , \"'***'\"       )\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\"           , \"'*'\"         )\n    (\"CURR_WTR_ACCT_FLAG\"                  , \"'*'\"         )\n    (\"CUST_ID\"                             , \"'***'\"       )\n    (\"DELINQ_DTE\"                          , \"'1900-01-01'\")\n    (\"DTE\"                                 , \"'1900-01-01'\")\n    (\"ESC_CAND_FLAG\"                       , \"'*'\"         )\n    (\"EXCL_TYPE\"                           , \"'***'\"       )\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\"           , \"'*'\"         )\n    (\"FIRE_ALM_PERMIT_NUM\"                 , \"'***'\"       )\n    (\"FIRE_ALM_PURPOSE\"                    , \"'***'\"       )\n    (\"INV_NUM\"                             , \"'***'\"       )\n    (\"LAST_CUST_CONN_DTE\"                  , \"'1900-01-01'\")\n    (\"LAST_CUST_CUTOFF_DTE\"                , \"'1900-01-01'\")\n    (\"LAST_CUST_DISCONN_DTE\"               , \"'1900-01-01'\")\n    (\"LAST_METER_INSPECT_DTE\"              , \"'1900-01-01'\")\n    (\"LICENSE_PLATE_EXP_MTH\"               , \"'***'\"       )\n    (\"LICENSE_PLATE_EXP_YR\"                , \"'***'\"       )\n    (\"LICENSE_PLATE_NUM\"                   , \"'***'\"       )\n    (\"LICENSE_PLATE_TYPE\"                  , \"'***'\"       )\n    (\"MUNIC_UTIL_DISTR_DESCR\"              , \"'***'\"       )\n    (\"ON_ADMIN_HOLD_FLAG\"                  , \"'*'\"         )\n    (\"OWNERSHIP_EFF_DTE\"                   , \"'1900-01-01'\")\n    (\"OWNER_IS_CUST_FLAG\"                  , \"'*'\"         )\n    (\"OWNER_RENTER\"                        , \"'*'\"         )\n    (\"PERMIT_EXP_DTE\"                      , \"'1900-01-01'\")\n    (\"PERMIT_ISSUE_DTE\"                    , \"'1900-01-01'\")\n    (\"PERMIT_NAME\"                         , \"'***'\"       )\n    (\"PERMIT_NUM\"                          , \"0\"           )\n    (\"PROP_CLASS_DESCR\"                    , \"'***'\"       )\n    (\"RECEIVABLE_HAS_LTR_FLAG\"             , \"'*'\"         )\n    (\"RECEIVABLE_HAS_NOTE_FLAG\"            , \"'*'\"         )\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\"        , \"'*'\"         )\n    (\"REG_HOLDER_FLAG\"                     , \"'*'\"         )\n    (\"REND_PENALTY_JURIS_DESCR\"            , \"'***'\"       )\n    (\"RESOLVED_BY\"                         , \"'***'\"       )\n    (\"RESOLVE_DESCR\"                       , \"'***'\"       )\n    (\"SCHOOL_JURIS_DESCR\"                  , \"'***'\"       )\n    (\"SEN_CITIZEN_FLAG\"                    , \"'*'\"         )\n    (\"SRC_SYS\"                             , \"'***'\"       )\n    (\"SRC_SYS_ID\"                          , \"'***'\"       )\n    (\"SUBSTANTIAL_ERR_PENALTY\"             , \"'*'\"         )\n    (\"SUSPD_PERMIT_DTE\"                    , \"'1900-01-01'\")\n    (\"SUSPD_PERMIT_RSN\"                    , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_1\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_2\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_3\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_4\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_5\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_ROLL_TYPE\"              , \"'***'\"       )\n    (\"TAX_DEFERRAL_END_DTE\"                , \"'1900-01-01'\")\n    (\"TAX_DEFERRAL_START_DTE\"              , \"'1900-01-01'\")\n    (\"TAX_ROLL_DESCR\"                      , \"'***'\"       )\n    (\"TYPE_OF_ALM_SITE\"                    , \"'*'\"         )\n    (\"UNDER_APPEAL_FLAG\"                   , \"'*'\"         )\n    (\"VAC_FLAG\"                            , \"'*'\"         )\n    (\"VEH_COLOR\"                           , \"'***'\"       )\n    (\"VEH_ID_NUM\"                          , \"'***'\"       )\n    (\"VEH_MAKE\"                            , \"'***'\"       )\n    (\"VEH_MODEL\"                           , \"'***'\"       )\n    (\"VEH_MODEL_YR\"                        , \"'***'\"       )\n    (\"VEH_OWNER_ID\"                        , \"'***'\"       )\n    (\"VEH_OWNER_NAME\"                      , \"'***'\"       )\n    (\"VEH_TYPE\"                            , \"'***'\"       )\n    (\"VOID_CODE\"                           , \"'***'\"       )\n    (\"VOID_DESCR\"                          , \"'***'\"       )\n    (\"VOID_FLAG\"                           , \"'*'\"         )\n    (\"WORK_STAT\"                           , \"'***'\"       )\n    (\"WRITE_OFF_FLAG\"                      , \"'*'\"         )\n    (\"WTR_ACCT_NUM_OF_UNITS\"               , \"0\"           )\n    (\"WTR_ACCT_ORIG_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_ACCT_PROP_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_METER_NUM\"                       , \"'***'\"       )\n\n|]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"},"expanded":true,"level":0,"properties":{}},{"name":"SlowlyChangingDimensions","content":"#define SLOWLY_CHANGING_DIMENSIONS \nopen System.Text.RegularExpressions\nopen Microsoft.FSharp.Reflection\n\nlet padName: int -> string -> string =\n         fun len    name   -> name.PadRight len\n\nlet pad4 = padName 40\nlet pad2 = padName 20\n\nlet defaultValue v opt = match opt with\n                         | Some x -> x\n                         | None   -> v\n\nlet aNumeral (s : string) = if s.StartsWith \"A#\" then s.[2..] else s\n\nlet toString (x:'a) = \n    match FSharpValue.GetUnionFields(x, typeof<'a>) with\n    | case, _ -> case.Name\n    |> aNumeral\n\nlet fromString<'a> (s:string) =\n    match FSharpType.GetUnionCases typeof<'a> |> Array.filter (fun case -> case.Name = s) with\n    |[|case|] -> Some(FSharpValue.MakeUnion(case,[||]) :?> 'a)\n    |_ -> None\n\ntype sqlObjectType = | PROCEDURE | VIEW | TRIGGER\nwith\n     member this.Name      = toString this\n     member this.Condition = match    this with\n                             | PROCEDURE -> \"IN ( N'P', N'PC' )\"\n                             | VIEW      -> \"=    N'V' \"\n                             | TRIGGER   -> \"=    N'TR'\"\n\nlet sqlDropCreate: sqlObjectType -> string -> string =\n               fun sqlType          name   -> sprintf \"\"\"\nIF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'%s') AND type %s)\n    DROP %s %s;\nGO\n-- Machine-generated-code, DO NOT MODIFY HERE\n-- %s 'HPL', '2017-03-01'\nCREATE %s %s\n\"\"\"                                                name         sqlType.Condition \n                                                   sqlType.Name name \n                                                   name \n                                                   sqlType.Name name\n\n\nlet regexIdentifier = Regex @\"^[\\p{L}_][\\p{L}\\p{N}@$#_]{0,127}$|^\\[.+\\]$\"\n                                                \nlet isIdentifier: string -> bool =\n              fun txt    -> regexIdentifier.IsMatch txt\n\nlet nameS fName = \n    if isIdentifier fName \n    then fName \n    else sprintf \"[%s]\" fName\n\ntype TargetField\nwith\n     member this.Name = toString this\n\ntype FinTransViewField\nwith\n     member this.Name = toString this\n\ntype Field =\n    | SurrogateKey   of TargetField\n    | BusinessKey    of FinTransViewField\n    | SourceDate     of FinTransViewField\n    | IntraDayOrder  of  FinTransViewField\n    | SCD2BeginDate  of TargetField\n    | SCD2EndDate    of TargetField\n    | SCD2Current    of TargetField\n    | ChangeReason   of TargetField\n    | SCD2           of FinTransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD0 without accompanying SCD1 or 2\nwith member this.Name0 = \n        match this with\n        | SurrogateKey   tfield\n        | SCD2BeginDate  tfield\n        | SCD2EndDate    tfield\n        | ChangeReason   tfield\n        | SCD2Current    tfield        -> tfield.Name\n        | BusinessKey    sfield\n        | SourceDate     sfield\n        | IntraDayOrder  sfield\n        | SCD2          (sfield, _, _) \n        | SCD1          (sfield, _   ) \n        | SCD0           sfield        -> sfield.Name\n     member this.Name = this.Name0 |> nameS\n\nlet strOption: string -> string option =\n           fun txt    -> match txt.Trim() with\n                         | \"\" -> None\n                         | f  -> Some f\n\nlet tfldOption: TargetField -> TargetField option =\n            fun fld         -> match fld with | Nil  -> None | _ -> Some fld\n\nlet sfldOption: FinTransViewField -> FinTransViewField option =\n            fun fld         -> match fld with | Nil_ -> None | _ -> Some fld\n\nlet SurrogateKey  name           : Field =  name                   |> SurrogateKey \nlet BusinessKey   name           : Field =  name                   |> BusinessKey  \nlet SourceDate    name           : Field =  name                   |> SourceDate   \nlet IntraDayOrder name           : Field =  name                   |> IntraDayOrder   \nlet SCD2BeginDate name           : Field =  name                   |> SCD2BeginDate\nlet SCD2EndDate   name           : Field =  name                   |> SCD2EndDate  \nlet SCD2Current   name           : Field =  name                   |> SCD2Current  \nlet ChangeReason  name           : Field =  name                   |> ChangeReason  \nlet SCD0          name           : Field =  name                   |> SCD0         \nlet SCD1          name      scd0 : Field = (name, tfldOption scd0) |> SCD1         \nlet SCD2          name scd1 scd0 : Field = (name, tfldOption scd1                   \n                                                , tfldOption scd0) |> SCD2\n    \nlet fieldNames      :  Field -> string list =\n                   fun f     -> match f with \n                                | SCD2         (_, Some scd1, Some scd0) -> [ f.Name ; scd1.Name ; scd0.Name ]\n                                | SCD2         (_, _        , Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | SCD1         (_,            Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | _                                      -> [ f.Name                         ]\n\nlet fieldSource     :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _\n                                | SCD2BeginDate _\n                                | SCD2EndDate   _\n                                | ChangeReason  _\n                                | SCD2Current   _            -> []\n                                | _                          -> [ f.Name ]\n\nlet fieldTarget    :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  tfield\n                                | SCD2BeginDate tfield\n                                | SCD2EndDate   tfield\n                                | ChangeReason  tfield\n                                | SCD2Current   tfield                   -> [ tfield.Name            ]\n                                | SCD2         (_, Some scd1, Some scd0) -> [ scd1  .Name ; scd0.Name]\n                                | SCD2         (_, _        , Some scd0) -> [               scd0.Name]\n                                | SCD1         (_,            Some scd0) -> [               scd0.Name]\n                                | _                                      -> []\n\nlet fieldAlias      :  Field -> string =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> \"SurrogateKey_ \"\n                                | BusinessKey   _ -> \"BusinessKey_  \"\n                                | SourceDate    _ -> \"SourceDate_   \"\n                                | IntraDayOrder _ -> \"IntraDayOrder_\"\n                                | SCD2BeginDate _ -> \"SourceDate_   \"\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> \"\" \n                                | _               -> f.Name\nlet fieldAliasValue :  Field -> string -> string = \n                   fun f        v      -> sprintf \"%s = %s\" (pad4 (fieldAlias f)) v\n\nlet fieldSelectTable:  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f f.Name ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SCD2BeginDate _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> [] \n                                | _               -> [ f.Name ]\n\nlet fieldSelectSource: (string -> string) -> Field -> string list =\n                   fun transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f \"NULL\"  ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ -> [ fieldAliasValue f f.Name ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldSelectTogether1: (string -> string) -> Field -> string list =\n                   fun    transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAlias f |> transform ]\n                                | BusinessKey   _ -> [ fieldAlias f              ]\n                                | SourceDate    _ -> [ fieldAlias f              ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _ \n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldInsert     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f\n\nlet fieldValues     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (sprintf \"S.%s\")\n\nlet fieldUpdate     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | BusinessKey   _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (fun n -> sprintf \"T.%s = S.%s\" (pad4 n) n)\n\nlet fieldSCD2Equal   : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _ -> [ sprintf \"S.%s = P.%s\" ( pad4 f.Name) f.Name ]\n                                | _      -> []\n                                \nlet fieldSCD2        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _             -> [ sprintf \"S.%s\" f.Name ]\n                                | _                  -> []\n\nlet fieldSCD0        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD1(_,    Some scd0) \n                                | SCD2(_, _, Some scd0) -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 scd0.Name) f.Name ]\n                                | SCD0 _                -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\nlet fieldSCD1        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2(_, Some scd1, _) -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 scd1.Name) f.Name ]\n                                | SCD1 _                -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\ntype SQLTableView = {\n    db       : string option\n    schema   : string option\n    sqlObject: string\n    where    : string option\n    parms    : string option\n}\nwith member this.Reference   : string =\n                               match this.db, this.schema with\n                               | None   , None    -> sprintf \"%s\"\n                               | Some db, None    -> sprintf \"%s..%s\"   (nameS db)\n                               | Some db, Some sc -> sprintf \"%s.%s.%s\" (nameS db) (nameS sc)\n                               | None   , Some sc -> sprintf \"%s.%s\"               (nameS sc)\n                               <| nameS this.sqlObject\n     member this.Call        : string =\n                               match this.parms with\n                               | None    -> sprintf \"%s\"\n                               | Some ps -> fun r -> sprintf \"%s(%s)\" r ps\n                               <| this.Reference\n     member this.FromWhere   : string =\n                               match this.where with\n                               | None    -> sprintf \"%s\"\n                               | Some wh -> fun c -> sprintf \"%s WHERE %s \" c wh\n                               <| this.Call\n\n     static member New: string -> string ->  string  -> string -> string -> SQLTableView =\n                    fun db        schema     sobject    where     parms  -> {\n                                                                                db        = strOption db\n                                                                                schema    = strOption schema\n                                                                                sqlObject = sobject.Trim()\n                                                                                where     = strOption where \n                                                                                parms     = strOption parms\n                                                                            }\n\nlet indent : string  -> string =\n         fun content -> content.Split[| '\\n' |] |> String.concat \"\\n    \"\n\nlet indent2: string  -> string =\n         fun content -> \"    \" + (indent content)\n\ntype SQLWith = { \n    name   : string \n    content: string \n}\nwith override this.ToString()  = sprintf \"%s as (\\n%s\\n)\" this.name this.content\n     static member New: string -> string  -> SQLWith =\n                    fun name      content -> { name = name.Trim() ; content = indent2 content }\n\nlet sqlSelectP: string -> string -> string seq -> string =\n    fun         select    from      fields     -> \n        fields \n        |> String.concat \"\\n     , \"\n        |> sprintf \"%s %s\\n  FROM %s\" select <| from\n\nlet sqlSelect : string -> string seq -> string = sqlSelectP \"SELECT\"\nlet sqlSelectD: string -> string seq -> string = sqlSelectP \"SELECT Distinct\"\n\nlet sqlProcedure: string -> string  -> string  -> string=\n              fun name      parms      content -> \n                  sqlDropCreate PROCEDURE name\n                  |> sprintf \"%s %s\\n as \\n %s \\nGO\" <| parms <| content\n\nlet bSurrogateKey  = function | SurrogateKey  _ -> true | _ -> false\nlet bBusinessKey   = function | BusinessKey   _ -> true | _ -> false\nlet bSourceDate    = function | SourceDate    _ -> true | _ -> false\nlet bIntraDayOrder = function | IntraDayOrder _ -> true | _ -> false\nlet bSCD2BeginDate = function | SCD2BeginDate _ -> true | _ -> false\nlet bSCD2EndDate   = function | SCD2EndDate   _ -> true | _ -> false\nlet bChangeReason  = function | ChangeReason  _ -> true | _ -> false\nlet bSCD2Current   = function | SCD2Current   _ -> true | _ -> false\nlet bSCD2          = function | SCD2          _ -> true | _ -> false\n\ntype Dimension ( tableBase : SQLTableView\n               , source    : SQLTableView\n               , fields    : Field  seq\n               , snowflakes: string seq\n               , extra     : Printf.StringFormat<_>) =              \n     let isSnowflaked   = snowflakes |> Seq.isEmpty |> not\n     let countF filter  = fields |> Seq.filter filter |> Seq.length\n     let cSurrogateKey  = countF bSurrogateKey \n     let cBusinessKey   = countF bBusinessKey  \n     let cSourceDate    = countF bSourceDate   \n     let cIntraDayOrder = countF bIntraDayOrder\n     let cSCD2BeginDate = countF bSCD2BeginDate\n     let cSCD2EndDate   = countF bSCD2EndDate  \n     let cChangeReason  = countF bChangeReason  \n     let cSCD2Current   = countF bSCD2Current  \n     let cSCD2          = countF bSCD2\n     let table          = if isSnowflaked then { tableBase with sqlObject = \"SV_\" + tableBase.sqlObject } else tableBase\n     let duplicates     = fields |> Seq.collect fieldNames |> Seq.countBy (fun n -> n.Trim().ToUpper()) |> Seq.choose (fun (n, i) -> if i > 1 then sprintf \"Field %s appears more than once\" n |> Some else None) |> Seq.toList\n     let errors         = [\n                             if              cSurrogateKey  = 0 then yield \"A SurrogateKey  must be specified\"\n                             if              cBusinessKey   = 0 then yield \"A BusinessKey   must be specified\"\n                             if cSCD2 > 0 && cSourceDate    = 0 then yield \"A SourceDate    must be specified\"\n                             if cSCD2 > 0 && cIntraDayOrder = 0 then yield \"A IntraDayOrder must be specified\"\n                             if cSCD2 > 0 && cSCD2BeginDate = 0 then yield \"A SCD2BeginDate must be specified\"\n                             if cSCD2 > 0 && cSCD2EndDate   = 0 then yield \"A SCD2EndDate   must be specified\"\n                             if              cSurrogateKey  > 1 then yield \"Only 1 SurrogateKey  can be specified\"\n                             if              cBusinessKey   > 1 then yield \"Only 1 BusinessKey   can be specified\"\n                             if              cSourceDate    > 1 then yield \"Only 1 SourceDate    can be specified\"\n                             if              cIntraDayOrder > 1 then yield \"Only 1 IntraDayOrder can be specified\"\n                             if              cSCD2BeginDate > 1 then yield \"Only 1 SCD2BeginDate can be specified\"\n                             if              cSCD2EndDate   > 1 then yield \"Only 1 SCD2EndDate   can be specified\"\n                             if              cSCD2Current   > 1 then yield \"Only 1 SCD2Current   can be specified\"\n                             if              cChangeReason  > 1 then yield \"Only 1 ChangeReason  can be specified\"\n                             if cSCD2 = 0 && cSourceDate    = 1 then yield \"No SCD2 fields, SourceDate    cannot be specified\"\n                             if cSCD2 = 0 && cIntraDayOrder = 1 then yield \"No SCD2 fields, IntraDayOrder cannot be specified\"\n                             if cSCD2 = 0 && cSCD2BeginDate = 1 then yield \"No SCD2 fields, SCD2BeginDate cannot be specified\"\n                             if cSCD2 = 0 && cSCD2EndDate   = 1 then yield \"No SCD2 fields, SCD2EndDate   cannot be specified\"\n                             if cSCD2 = 0 && cSCD2Current   = 1 then yield \"No SCD2 fields, SCD2Current   cannot be specified\"\n                          ] @ duplicates\n     do if not errors.IsEmpty then failwith (errors |> String.concat \"\\n\")\n     let find  : (Field -> bool) -> string =\n             fun  ft             -> fields |> Seq.find ft |> fun f -> f.Name\n     let surrogateKey   = find bSurrogateKey\n     let businessKey    = find bBusinessKey\n     let sourceDateO    = if cSourceDate    = 1 then find bSourceDate    |> Some else None\n     let intraDayOrderO = if cIntraDayOrder = 1 then find bIntraDayOrder |> Some else None\n     let sCD2BeginDateO = if cSCD2BeginDate = 1 then find bSCD2BeginDate |> Some else None\n     let sCD2EndDateO   = if cSCD2EndDate   = 1 then find bSCD2EndDate   |> Some else None\n     let sCD2CurrentO   = if cSCD2Current   = 1 then find bSCD2Current   |> Some else None\n     let changeReasonO  = if cChangeReason  = 1 then find bChangeReason  |> Some else None \n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\n     let lastOfDay    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY %s, %s ORDER BY %s ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n businessKey (sourceDateO |> Option.defaultValue \"\") (intraDayOrderO |> Option.defaultValue \"\")\n     let together1    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY BusinessKey_, SourceDate_ ORDER BY SurrogateKey_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n \nwith\n     new(table, source, fields            ) = Dimension(table, source, fields, []        , \"%s\")\n     new(table, source, fields, snowflakes) = Dimension(table, source, fields, snowflakes, \"%s\")\n     member this.TableReference     = table    .Reference\n     member this.TableBase          = tableBase\n     member this.Fields: (Field -> string list) -> string seq =\n                     fun chooser                  -> fields |> Seq.sort |> Seq.collect chooser\n     member this.AllFields          = this.Fields <| fieldNames\n     member this.FinTransViewFields = this.Fields <| fieldSource\n     member this.TargetFields       = this.Fields <| fieldTarget\n     member this.Existing           = this.Fields <| fieldSelectTable\n     member this.Source             = this.Fields <| fieldSelectSource    (if cSCD2 > 0 then lastOfDay else id)\n     member this.Together1          = this.Fields <| fieldSelectTogether1 (if cSCD2 > 0 then together1 else id)\n     member this.Together2          = [\n                                        sprintf \"NRec_  = ROW_NUMBER() OVER (PARTITION BY BusinessKey_ ORDER BY %s)\" <| if cSCD2 > 0 then \"SourceDate_, ISNULL(SurrogateKey_, 2147483647)\" else \"ISNULL(SurrogateKey_, 2147483647)\"\n                                        \"*\"\n                                      ]\n     member this.NewRec             = if cSCD2 > 0 then \n                                          this.Fields fieldSCD2Equal\n                                          |> String.concat \"\\n                 AND \"  \n                                          |> sprintf \"NewRec_ = IIF (%s, 0, 1)\"\n                                       else          \"NewRec_ = IIF (P.BusinessKey_ is NULL                  , 1, 0) \"\n     member this.Ordered            = [\n                                        yield                    \"S.SurrogateKey_ \"\n                                        yield                    \"S.BusinessKey_  \"\n                                        yield                    \"S.NRec_         \"\n                                        yield                    this.NewRec      \n                                        if cSCD2 > 0 then yield  \"S.SourceDate_   \"\n                                        yield!                   this.Fields fieldSCD2\n                                        yield!                   this.Fields fieldSCD1\n                                        yield!                   this.Fields fieldSCD0\n                                      ]\n     member this.SCD2Records        = [\n                                        \"SCD2Record_ = SUM(NewRec_    ) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\"\n                                        \"NextDate_   = MAX(SourceDate_) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\"\n                                        \"LastRec_    = MAX(NRec_      ) OVER (PARTITION BY BusinessKey_)\"\n                                        \"*\"\n                                      ]\n     member this.VersBeg            = [\n                                        sCD2BeginDateO.Value |> pad4 |> sprintf \"%s = MIN(SourceDate_) OVER (PARTITION BY BusinessKey_, SCD2Record_)\"\n                                        sCD2EndDateO  .Value |> pad4 |> sprintf \"%s = DATEADD(d, -1, MAX(IIF(NRec_ = LastRec_, '9999-12-31', NextDate_)) OVER (PARTITION BY BusinessKey_, SCD2Record_))\"\n                                        \"*\"\n                                      ]\n     member this.RKeys              = [\n                                        if sCD2CurrentO.IsSome then \n                                           yield sCD2CurrentO.Value  |> pad4 |> sprintf \"%s = IIF(%s = '9999-12-30', 'Y', 'N')\"                       <| sCD2EndDateO.Value\n                                        yield    surrogateKey        |> pad4 |> sprintf \"%s = MAX(SurrogateKey_) OVER (PARTITION BY BusinessKey_ %s)\" <| if sCD2BeginDateO.IsSome  then  \", \" + sCD2BeginDateO.Value else \"\"\n                                        yield    businessKey         |> pad4 |> sprintf \"%s = BusinessKey_\"\n                                        if changeReasonO.IsSome then\n                                           yield changeReasonO.Value |> pad4 |> sprintf \"%s = '---'\"\n                                        yield    \"*\"\n                                      ]\n     member this.fromTogether2      = \"    Together2 S\n LEFT JOIN Together2 P ON P.BusinessKey_ = S.BusinessKey_\n                      AND P.NRec_        = S.NRec_ - 1\"\n     member this.Withs              =\n         [\n             yield    SQLWith.New \"Existing     \" <| sqlSelect  table .FromWhere              this.Existing \n             yield    SQLWith.New \"Source       \" <| sqlSelectD source.FromWhere              this.Source   \n             yield    SQLWith.New \"Together0    \" <| \"SELECT *  FROM Existing UNION ALL SELECT * FROM Source\"\n             yield    SQLWith.New \"Together1    \" <| sqlSelectD \"Together0\"                   this.Together1\n             yield    SQLWith.New \"Together2    \" <| sqlSelect  \"Together1          \"         this.Together2\n             yield    SQLWith.New \"Ordered      \" <| sqlSelect  this.fromTogether2            this.Ordered     \n             if cSCD2 > 0 then                                  \n                yield SQLWith.New \"SCD2Records  \" <| sqlSelect  \"Ordered            \"         this.SCD2Records \n                yield SQLWith.New \"VersBeg      \" <| sqlSelect  \"SCD2Records        \"         this.VersBeg     \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"VersBeg            \"         this.RKeys     \n             else                                               \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"Ordered            \"         this.RKeys     \n         ]\n     member this.LastWith           = this.Withs |> Seq.last\n     member this.SelectIntoTemp     = if isSnowflaked then sprintf \"    , NewSurrogateKey_ = NEXT VALUE FOR Seq_%s\\n\" this.TableBase.sqlObject else \"\"\n                                      |> sprintf \"SELECT * \\n%s   INTO #TEMP\\n  FROM %s \\n WHERE NewRec_ = 1\" <| this.LastWith.name                                       \n     member this.Insert             = this.Fields fieldInsert\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   INSERT(%s %s)\" (if isSnowflaked then sprintf \"%s\\n,\" surrogateKey  else \"\")\n                                      |> indent  |> indent\n     member this.Values             = this.Fields fieldValues\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   VALUES(%s %s)\\n\" (if isSnowflaked then \"NewSurrogateKey_\\n,\" else \"\")\n                                      |> indent  |> indent\n     member this.Update             = this.Fields fieldUpdate\n                                      |> String.concat \"\\n, \"\n                                      |> indent |> indent\n     member this.WhenNotMatched     = sprintf \"WHEN NOT MATCHED BY TARGET THEN\\n%s\\n%s\" \n                                      <| this.Insert            <| this.Values\n     member this.WhenMatched        = (fun f -> if f <> \"\" then sprintf \"WHEN MATCHED THEN\\nUPDATE SET %s\" f else f)\n                                      <| this.Update\n     member this.Merge              = sprintf \"MERGE %s AS T\\nUSING #TEMP AS S\\nON (T.%s = S.%s)\\n%s\\n%s;\" \n                                      <| this.TableReference \n                                      <| surrogateKey        <| surrogateKey\n                                      <| this.WhenNotMatched\n                                      <| this.WhenMatched\n     member this.Query              = this.Withs\n                                      |> List.map (fun w -> w.ToString())\n                                      |> String.concat \", \"\n                                      |> sprintf \"WITH %s\"\n                                      |> sprintf \"%s \\n%s; \\n%s\" <| this.SelectIntoTemp <| this.Merge\n     member this.Procedure          = this.Query\n                                      |> sprintf \"BEGIN\\n  EXEC GENERIC.Log @SOURCE, '%s', 'Started Merge', '';\\n  %s\\n END\\n\" procedureName\n                                      |> sqlProcedure procedureName \"@SOURCE VARCHAR(30), @CURRENT_DTE DATE = NULL\" \n     member this.ProcedureName      = procedureName\n     member this.SurrogateKey       = surrogateKey\n     member this.BusinessKey        = businessKey\n     member this.SourceDateO        = sourceDateO\n     member this.SCD2BeginDateO     = sCD2BeginDateO\n     member this.SCD2EndDateO       = sCD2EndDateO  \n     member this.TableName          = table.sqlObject\n     member this.Verification       = sCD2BeginDateO \n                                      |> Option.map (fun b ->\n                                            let e = sCD2EndDateO.Value\n                                            sprintf \" AND (D.%s BETWEEN X.%s AND X.%s  OR D.%s BETWEEN X.%s AND X.%s ) \" b b e  e b e\n                                         )\n                                      |> defaultValue \"\"\n                                      |> sprintf \"SELECT * \\n  FROM %s D \\n WHERE EXISTS(SELECT * \\n         FROM %s X \\n      WHERE X.%s <> D.%s AND X.%s = D.%s %s) \\n ORDER BY %s %s\" \n                                            table.Reference table.Reference\n                                            surrogateKey    surrogateKey    \n                                            businessKey     businessKey\n                                      <| businessKey <| \"\"\n     member this.Snowflakes         = snowflakes\n                                      \n                                    \ntype FactField = \n    | Fact   of FinTransViewField\n    | OField of TargetField * value: string\n\nlet OField: TargetField -> string -> FactField = \n        fun fld            value  -> (fld, value.Trim()) |> OField\n\n[< NoComparison >]\ntype DimRef =\n    | DimRef of Dimension * SurrogateKey: TargetField option * BusinesKey: FinTransViewField option\nwith\n     member this.Dim                = match this with                                      DimRef (dim, _   , _) -> dim\n     member this.FactSurrogateKey   = match this with | DimRef (dim, Some key, _) -> key.Name | DimRef (dim, None, _) -> dim.SurrogateKey\n     member this.FactBusinessKey    = match this with | DimRef (dim, _, Some key) -> key.Name | DimRef (dim, _, None) -> dim.BusinessKey\n     member this.FinTransViewFields = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! bKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.FinTransViewFields ]\n     member this.TargetFields       = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! sKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.TargetFields       ]\n     static member New dim                             = DimRef(dim, None             , None            )\n     static member New(dim, surrogateKey             ) = DimRef(dim, Some surrogateKey, None            )\n     static member New(dim, surrogateKey, businessKey) = DimRef(dim, Some surrogateKey, Some businessKey)\nlet dimension: Dimension -> TargetField -> FinTransViewField -> DimRef = \n           fun dim          surroK         businK      -> DimRef (dim, tfldOption surroK, sfldOption businK)\n\ntype FactTable( table  : SQLTableView\n              , source : SQLTableView\n              , dims   : DimRef    seq\n              , fields : FactField seq\n              , extra  : Printf.StringFormat<_>) =\n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\nwith \n     member this.TableName      = table.sqlObject\n     member this.ProcedureName  = procedureName\n     member this.SourceFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(_, f) -> f\n                                             )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.FinTransViewFields))\n                                  |> Seq.distinct\n     member this.TargetFields   = fields \n                                  |> Seq.collect (function \n                                                  | Fact f       -> []\n                                                  | OField(f, _) -> [ f.Name ]\n                                                 )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.TargetFields))\n                                  |> Seq.distinct\n     member this.Keys           = dims |> Seq.mapi(fun i dim -> sprintf \"D%d.%s\" i dim.Dim.SurrogateKey)\n     member this.Joins          = dims \n                                  |> Seq.mapi(fun i dim -> \n                                                    dim.Dim.SourceDateO\n                                                    |> Option.map (fun v -> sprintf \" AND S.%s BETWEEN D%d.%s AND D%d.%s\" v i dim.Dim.SCD2BeginDateO.Value i dim.Dim.SCD2EndDateO.Value)\n                                                    |> defaultValue \"\"\n                                                    |> sprintf \"%s D%d ON D%d.%s = S.%s %s\" (pad2 dim.Dim.TableBase.Reference) i i (pad2 dim.Dim.BusinessKey) (pad2 dim.FactBusinessKey)\n                                             )\n                                  |> Seq.toList                                                                 \n     member this.From           = sprintf \"%s S\" source.FromWhere\n                                  :: this.Joins\n                                  |> String.concat \"\\n LEFT JOIN \"\n     member this.Query          = fields \n                                  |> Seq.map (function \n                                              | Fact   f     -> sprintf \"S.%s\"    f.Name\n                                              | OField(f, v) -> sprintf \"%s = %s\" (pad2 f.Name) v\n                                             )\n                                  |> Seq.append this.Keys \n                                  |> sqlSelect this.From\n     member this.InsertFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(f, _) -> f.Name\n                                             )\n                                  |> Seq.append (dims |> Seq.map (fun dim -> dim.FactSurrogateKey))\n                                  |> String.concat \"\\n     , \"\n     member this.Insert         = sprintf \"INSERT INTO %s\\n      (%s)\\n%s\" table.Reference this.InsertFields this.Query\n                                  |> sprintf extra\n     member this.Procedure      = sqlProcedure procedureName \"@SOURCE VARCHAR(30), @FROM DATE = NULL, @TO DATE = NULL\" this.Insert\n\nlet print: string -> unit =\n       fun txt    -> printf \"\\n\\n%s\\n\\n\" txt\n\nlet FinTransViewFields: FactTable -> Dimension seq -> string seq =\n    fun                 fTable       dims          -> \n        fTable.SourceFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.FinTransViewFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\nlet targetFields: FactTable -> Dimension seq -> string seq =\n    fun           fTable       dims          -> \n        fTable.TargetFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.TargetFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\n\nlet getDecl: string -> (string * bool) option =\n         fun fname  -> fieldDecl\n                       |> Seq.choose (fun (name, typeDecl, nullable) -> if name = fname.ToUpper() then (typeDecl, nullable = 1) |> Some else None)\n                       |> Seq.tryHead\n\nlet getDefault: string -> string option =\n            fun fname  -> fieldDefault\n                          |> Array.tryPick (fun (name, value) -> if name = fname.ToUpper() then Some value else None)\n\nlet convert fName v =\n    getDecl fName \n    |> Option.map (fun (fType, nullable) -> fType.Trim())\n    |> Option.map (fun typeName -> sprintf \"CONVERT(%s, %s)\"  typeName v) \n    |> Option.defaultValue v\n\nlet applyDefault fName v =\n    getDecl fName \n    |> Option.bind (fun (fType, nullable) ->\n           if nullable then None\n           else getDefault fName\n           |> Option.map (sprintf \"ISNULL(%s, %s)\" v)\n    )\n    |> Option.defaultValue v\n\nlet equalField fName v =\n    fName\n    |> nameS\n    |> pad4 \n    |> sprintf \"%s = %s\"  <| v\n\ntype FinTransViewField\nwith \n    \n    member this.Convert      v = convert      this.Name v\n    member this.applyDefault v = applyDefault this.Name v\n    member this.equal        v = equalField   this.Name v\n    member this.DefaultO       = getDefault   this.Name\n\nlet cast: FinTransViewField -> string -> string =\n      fun field                value  ->\n          value\n          |> field.Convert\n          |> field.applyDefault \n          |> field.equal\n\ntype QueryField(target: FinTransViewField, value: string) =\n    let name = target.Name\nwith\n    member this.Entry = cast target value\n    member this.Name  = name\n\nlet vwField: FinTransViewField -> string -> QueryField = \n         fun fld                  value  -> QueryField(fld, value.Trim())\n\n\nlet inline getUnionNames typ =\n    Microsoft.FSharp.Reflection.FSharpType.GetUnionCases typ\n    |> Seq.map (fun e -> e.Name |> aNumeral)\n    |> Seq.filter ((<>)\"Nil_\")\n    |> Seq.sort\n    |> Seq.toArray\n\nlet finTransViewFieldNames = getUnionNames typeof<FinTransViewField>\nlet targetFieldNames   = getUnionNames typeof<TargetField>\n\nlet missingFields: QueryField seq -> string[] =\n    fun            fields         -> \n        finTransViewFieldNames\n        |> Array.filter (fun e -> fields |> Seq.exists (fun f -> f.Name = e) |> not)\n\nlet allFields() = missingFields (seq[])\n                  |> Seq.sort\n                  |> String.concat \"\\n        , \"\n\nlet setDefault: string -> string =\n            fun field  -> getDefault    field \n                          |> Option.defaultValue \"(NULL)\" \n                          |> convert    field\n                          |> equalField field\n\ntype FactView(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n    let fieldsCached = fields |> Seq.toArray\n    let getFieldValue fName =\n        fieldsCached \n        |> Array.tryFind      (fun q -> q.Name    = fName)\n        |> Option.map         (fun q -> q.Entry          )\n        |> Option.defaultWith (fun _ -> setDefault  fName)\nwith\n     member this.Name     = name.schema\n     member this.ViewName = name.Call\n     member this.Query    = \n         finTransViewFieldNames \n         |> Array.map  getFieldValue\n         |> String.concat \"\\n        , \"\n         |> sprintf \"SELECT %s\\n FROM %s;\\n\" <| source.FromWhere\n         |> sprintf \"%s\\n as %s; \\nGO\" (sqlDropCreate VIEW this.ViewName)\n\nlet missingDefaults() =\n    finTransViewFieldNames \n    |> Seq.map    (fun n -> n, getDecl n, getDefault n)\n    |> Seq.filter (fun (n, typeO, defO) -> \n         match typeO, defO with\n         | None               , _\n         | Some (_    , false), None -> true\n         | _                         -> false\n    )\n    |> Seq.map     (fun (n, typO, _) ->\n        (n, typO, \n            match typO with\n            | Some(\"int\"       , _) -> \"0\"\n            | Some(\"varchar(1)\", _)\n            | Some(\"varchar(2)\", _) -> \"'*'\"\n            | Some(\"date\"      , _) \n            | Some(\"datetime\"  , _) -> \"'1900-01-01'\"\n            | _                     -> \"'***'\"\n        )\n    )\n\nlet missingDecls () =\n    fieldDecl\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    \n\nlet inline str4 s = s |> sprintf \"%A\" |> pad4 \nlet inline str2 s = s |> sprintf \"%A\" |> pad2 \n\nlet mutable AllDimensions: Dimension  list = []\nlet mutable AllFactViews : FactView   list = []\nlet mutable AllFactTables: FactTable  list = []\n\ntype Dimension\nwith \n     static member New( tableBase : SQLTableView\n                      , source    : SQLTableView\n                      , fields    : Field  seq\n                      , snowflakes: string seq\n                      , extra     : Printf.StringFormat<_>) =\n          let dim = Dimension(tableBase, source, fields, snowflakes, extra)\n          AllDimensions <- List.append AllDimensions [ dim ]\n          dim\n     static member New(table, source, fields            ) = Dimension.New(table, source, fields, []        , \"%s\")\n     static member New(table, source, fields, snowflakes) = Dimension.New(table, source, fields, snowflakes, \"%s\")\n\ntype FactTable\nwith \n     static member New( table  : SQLTableView\n                      , source : SQLTableView\n                      , dims   : DimRef    seq\n                      , fields : FactField seq\n                      , extra  : Printf.StringFormat<_>) =\n          let ft = FactTable(table, source, dims, fields, extra)\n          AllFactTables <- List.append AllFactTables [ ft ]\n          ft\n\ntype FactView\nwith \n     static member New(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n          let fv = FactView(name, source, fields)\n          AllFactViews <- List.append AllFactViews [ fv ]\n          fv\n\n(*          \n(*keep*)#load \"BetterFSI.fsx\"  // <<<==== Execute first in F# Interactive\nDo __SOURCE_FILE__ __LINE__ //\nDo __SOURCE_FILE__ __LINE__ //  missingDecls()    |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (fun (n, _, d) -> printfn \"(%s, %s)\" (str4 n) (str2 d))\nDo __SOURCE_FILE__ __LINE__ //  finTransViewFieldNames |> Seq.filter (fun a -> a.StartsWith \"A#\" ) |>\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"}],"id":{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},"expanded":true,"level":0,"properties":{}},{"name":"-------- READ ME --------","content":"\n\nTo update and regenerate views and procedures:\n\n- Make the required changes to the Views and dimension definitions below \n  and/or the Fields, FieldDecls and Defaults above\n- When ready to send to SQL Server, \n  click on \"Copy Views and Procedures\" at the end of this group\n- WHILE \"Copy Views and Procedures\" IS HIGHLIGHTED, select the view(s) and/or dimensions(s) \n  that need to be updated by clicking on the small box to the right. \n- Click on the \"Evaluate FS\" button\n- After a while a menu will pop up\n- Click on the buttons to copy the new definition to the Clipboard\n- Paste into SSMS and execute\n\nSnowFlaked dimensions.\nTo also update the snowflaked dimensions superviews make sure to check the box for \"SQLFetchFields & SnowFlakeViews\"\nA connection to the SQL Server is required for this option to work.\nThe connection string can be found in line 6.\n\nIf more changes are necessary close the pop up menu and repeat the steps above.\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"38aa569a-caf7-4c97-81c7-12ab6a9faec4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"module Views =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"expanded":true,"level":0,"properties":{}},{"name":"View EMS_MSB","content":"let EMS_MSBView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS_STEP0_V2\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'EMS_MSB'                                                           \"\n                vwField SRC_SYS_ID                          \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(TAG_STATUS='Closed', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'6400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'EMS_MSB'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'EMS_MSB'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Fire Department'                                           \"\n                vwField DIV_LONG_NAME                       \"'Emergency Medical Services'                                        \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'EMS_MSB-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'EMS_MSB Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'EMS_MSB generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'4600012363'                                                        \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n                vwField CUST_NAME                           \"Name                                                                \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'EMS_MSB '                                                          \"\n                vwField COH_EMP_NUM                         \"'EMS_MSB-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Turnover'\n\t\t\t\t                                             else                            'Turnover'   end                      \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Turnover'   end          \"\n                vwField DET_TRANS_CODE                      \"'EMS_MSB-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"Account_No                                                          \"\n                vwField INCDT_DESCR                         \"'Emergency Transport'                                               \"\n                vwField INCDT_TYPE                          \"'EMS Transport'                                                     \"\n                vwField INCDT_CAT                           \"'EMS Transport'                                                     \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM INCDT EMS DET\n                vwField EMS_INCDT                           \"Account_No                                                          \"\n                vwField DISPATCH_NUM                        \"Account_No                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'EMS_MSB Patient'                                                   \"\n// DIM ITEM PT DET\n                vwField PT_GNDR                             \"PT_GNDR                                                             \"\n                vwField PT_AGE                              \"PT_AGE                                                              \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"Tag                                                                 \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'Y'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(DATEADD(year,1,Issue_Date) > Turnover_Date, Turnover_Date, DATEADD(year,1,Issue_Date))\"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_Date                                                       \"   \n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"Turnover_Date                                                       \"   \n                vwField VERS_ASSIGNED_VEND                  \"'0000130521'                                                        \"   \n                vwField RECEIVABLE_MSTR_STAT                \"TAG_STATUS                                                          \"      \n                vwField ITEM_DESCR                          \"'EMS Patient'                                                       \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                    \"                               \n        ]\n)\n             \n(* \nopen SlowlyChangingDimensions\nprint EMS_MSBView.Query       \n*)\n\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},"expanded":true,"level":0,"properties":{}},{"name":"View HCTO","content":"let HCTOView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HCTO'                                                          \"\n                vwField SRC_SYS_ID                          \"'HCTO-' + SRC_SYS_ID                                            \"\n                                                                                                                     \n                vwField BUS_AREA_ID                         \"'9000'                                                          \"\n// DIM_CARRIER                                                                                                                  \n                vwField CARRIER_SRC                         \"'HCTO'                                                          \"\n// DIM_CARRIER PROCEDURE                                                                                                       \n                vwField CARRIER_PROCEDURE_SRC               \"'HCTO'                                                          \"\n// DIM_COH_ORG                                                                                                                  \n                vwField DEPT_LONG_NAME                      \"'Legal Department'                                              \"\n                vwField DIV_LONG_NAME                       \"'Treasury'                                                      \"\n// DIM_COLL_PERSON                                                                                                              \n                vwField COLL_PERSON_ID                      \"'HCTO-111'                                                      \"\n                vwField COLL_PERSON_NAME                    \"'Harris County Employee'                                        \"\n                vwField DIGITECH_ID                         \"'HCTO generic'                                                  \"\n                vwField HCTO_AD_VAL_ID                      \"'Harris County Employee'                                        \"\n                vwField COLL_PERSON_TYPE                    \"'COH Contractor'                                                \"\n                \n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***-000001'                                                    \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HCTO-'+ CAN                                                    \"\n                vwField CONFI_CUST_FLAG                     \"'N'                                                             \"\n                vwField CUST_NAME                           \"NAMELINE1                                                       \"\n                vwField CUST_IS_VEND_FLAG                   \"'N'                                                             \"\n                vwField JV_CUST_FLAG                        \"'N'                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"NAMELINE2                                                       \"\n                vwField CUST_ADDR_LINE_2                    \"NAMELINE3                                                       \"\n                vwField CUST_ADDR_LINE_3                    \"NAMELINE4                                                       \"\n                vwField CUST_IN_CITY_FLAG                   \"IIF(CITY='HOUSTON','Y','N')                                     \"\n                vwField CUST_CITY                           \"CITY                                                            \"\n                vwField CUST_STATE                          \"STATE                                                           \"\n                vwField CUST_CTRY                           \"COUNTRY                                                         \"\n                vwField CUST_ZIP_CODE                       \"SUBSTRING(ZIPCODE,1,5)                                          \"\n                vwField CUST_ZIP_PLUS_4                     \"SUBSTRING(ZIPCODE,1,13)                                         \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"TRANS_DTE                                                       \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'COH Contractor'                                                \"\n                vwField EMP_NAME                            \"'Harris County Employee'                                        \"\n                vwField COH_EMP_NUM                         \"'HCTO-111'                                                      \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"MSTR_TRANS_TYPE                                             \"\n                vwField DET_TRANS_DESCR                     \"DET_TRANS_DESCR                                                 \"\n                vwField DET_TRANS_CODE                      \"'HCTO-' + MSTR_TRANS_TYPE                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"SRC_SYS_ID                                                      \"\n                vwField INCDT_DESCR                         \"'Property ownership'                                            \"\n                vwField INCDT_TYPE                          \"'Property ownership'                                            \"\n                vwField INCDT_CAT                           \"'Property ownership'                                            \"\n                vwField INCDT_DTE                           \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4),YEAR))              \"\n                vwField INCDT_ADDR_LINE_1                   \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                         \"\n                vwField INCDT_ST_NUM                        \"PNUMBER                                                         \"\n                vwField INCDT_ST_NAME                       \"PSTRNAME                                                        \"\n                vwField INCDT_IN_CITY_FLAG                  \"'Y'                                                             \"\n                vwField INCDT_STATE                         \"'Texas'                                                         \"\n                vwField INCDT_CTRY                          \"'USA'                                                           \"\n                vwField INCDT_ZIP_CODE                      \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'Ad Valorem Property'                                           \"\n                vwField ITEM_ADDR_LINE_1                    \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                           \" \n                vwField ITEM_ST_NUM                         \"CONVERT(VARCHAR(13),PNUMBER)                                    \"\n                vwField ITEM_ST_NAME                        \"PSTRNAME                                                        \"\n                vwField ITEM_IN_CITY_FLAG                   \"'Y'                                                             \"\n                vwField ITEM_STATE                          \"'Texas'                                                         \"\n                vwField ITEM_DESCR                          \"'Property ownership'                                            \"\n                vwField ITEM_ZIP_CODE                       \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM ITEM DET\n                vwField FLAG_DIM_ITEM_TAXABLE_PROP_DET      \"1                                                               \"\n                vwField TAXABLE_PROP_ROLL_TYPE              \"'Roll Type'                                          \"            \n                vwField NUM_OF_ACRES                        \"LEGACRES                                                        \"\n                vwField PROP_CLASS_CODE                     \"PROPCLASS                         \" \n                vwField CITY_RFPD_JURIS_CODE                \"'61'        \" \n                vwField CONFI_ACCT_FLAG                     \"'N' \" \n                vwField TAX_DEFERRAL_START_DTE              \"TAXDEFSTRT                                                      \"\n                vwField TAX_DEFERRAL_END_DTE                \"TAXDEFEND                                                     \" \n                vwField OWNERSHIP_EFF_DTE                   \"CONVERT(DATETIME,'1900-01-01 00:00:00.000') \" \n                vwField APPRAISAL_DISTR_ACCT_NUM            \"SUBSTRING(CAN,1,16) \" \n                vwField TAXABLE_PROP_LGL_DESCR_1            \"LEGAL1                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_2            \"LEGAL2                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_3            \"LEGAL3                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_4            \"LEGAL4                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_5            \"LEGAL5                                                          \"\n                vwField TAX_ROLL_CODE                       \"ROLL                                                            \"\n                vwField PROP_CLASS_DESCR                    \"Property_Description                                            \"\n                vwField CITY_RFPD_JURIS_DESCR               \"'HOUSTON, CITY OF'                                             \"\n                vwField TAX_ROLL_DESCR                      \"'Roll Type'                                         \"\n                vwField CAN                                 \"SUBSTRING(CAN,1,16) \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG      \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE      \"DELINQ_DTE                                                          \"\n                vwField RECEIVABLE_VERS_DUE_DTE         \"DUEDATE                                                             \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE       \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField RECEIVABLE_VERS_TO_DTE          \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField VERS_ASSIGNED_VEND              \"'0000113973'                                                        \"\n                vwField ORIG_BILL_NAME                  \"NAMELINE1                                                           \"\n                vwField UNK_CUST_AT_BILL_FLAG           \"'N'                                                                 \"\n// Dim_Receivable_Det DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n                vwField FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET \"1\"\n                vwField AD_VAL_VET_FLAG                  \"VETERAN                                                            \"\n                vwField AD_VAL_DISABLED_FLAG             \"DISABLED                                                           \"\n                vwField AD_VAL_OVER_66_FLAG              \"OVER65                                                             \"\n                vwField AD_VAL_HOMESTEAD_FLAG            \"HOMESTEAD                                                          \"\n                vwField HCAD_ACCT_STAT                   \"CAN                                                                \"\n                vwField AD_VAL_TAX_DEFERRAL_START_DTE    \"TAXDEFSTRT                                                        \"\n                vwField AD_VAL_TAX_DEFERRAL_END_DTE      \"TAXDEFEND                                                         \"\n                vwField ``A#3348_ATTY_FEE_DTE``          \"DATE_3348                                                         \"\n                vwField ``A#3308_ATTY_FEE_DTE``          \"DATE_3308                                                         \"\n//              vwField ``A#3307_ATTY_FEE_DTE``          \"DATE_3307                                                         \"\n//Dim Business Area\n                vwField BUS_AREA_ID                   \"'9000'                                                               \"\n\n// Dim Functional Area\n                vwField FUNC_AREA_ID                    \"'GEGO-00-00000000'                                                   \"\n// Dim Fund ID\n                vwField FUND_ID                         \"'1000'                                                               \"\n// Dim Fund Cntr ID\n                vwField FUND_CNTR_ID                    \"'1000'                                                               \"\n// Dim GL Acct  \n                vwField GL_ACCT_ID                      \"'0000428020'                                                         \"\n\n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"TRANS_AMT\t                                                       \"      \n                vwField SRC_SYS_TRANS_ID                    \"'HCTO'                                                            \"      \n              \n                vwField POST_DTE                            \"TRANS_DTE                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint HCTOView.Query \n*)","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},"expanded":true,"level":0,"properties":{}},{"name":"View HHD","content":"let HHDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HHD'                                                           \"\n                vwField SRC_SYS_ID                          \"'HHD-'+Document_Number                                          \"\n\n                vwField BUS_AREA_ID                         \"'3800'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HHD'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'HHD'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Health & Human Services'                                       \"\n                vwField DIV_LONG_NAME                       \"'Health & Human Services'                                       \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HHD-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'HHD Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'HHD generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HHD-'+ CONVERT(VARCHAR, CUSTOMER)                              \"\n                vwField CUST_NAME                           \"Name_1                                                          \"\n                vwField CUST_ADDR_LINE_1                    \"Street                                                          \"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_STATE                          \"Region                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(Postal_Code) = 0, '***', isnull(LEFT(Postal_Code, 5) ,'***'))           \"\n                vwField CUST_PHN_NUM_1                      \"IIF(LEN(Telephone_1) = 0,'***',Telephone_1)                     \"\n                vwField CUST_FAX_NUM                        \"IIF(LEN(Fax_Number) = 0,'***',Fax_Number)                     \"\n         \n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Value_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'HHD '                                                          \"\n                vwField COH_EMP_NUM                         \"'HHD-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc\t                                             \"\n                vwField DET_TRANS_CODE                      \"'HHD-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"'HHD-'+Document_Number                                          \"\n                vwField INCDT_DTE                           \"Value_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'HHD Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'HHD Transaction'                                                   \"    \n// DIM_RECEIVABLE\n//                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"Due_date                                                            \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_date                                                          \"\n//                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"Name_1                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Amount                                                            \"      \n                vwField POST_DTE                            \"Value_Date                                                        \"                               \n        ]\n)\n(* \nopen SlowlyChangingDimensions\nprint HHDView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},"expanded":true,"level":0,"properties":{}},{"name":"View HPL","content":"let HPLView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS_STEP0_v4\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HPL'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type2 \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(PIF='Y', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'3400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HPL'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'HPL'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Public Library'                                            \"\n                vwField DIV_LONG_NAME                       \"'Library Material Services'                                         \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HPL-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'HPL Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'HPL generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(CollectionState2 > 0, '4600014067' , '***')                     \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_EMAIL_ADDR                     \"EMAIL                                                               \"\n                vwField CUST_PHN_NUM_1                      \"PHONE                                                               \"\n                vwField CUST_NAME                           \"Name                                                                \"\n                vwField CUST_TYPE                           \"PROFILE                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"STREET                                                              \"\n                vwField CUST_ADDR_LINE_2                    \"APT_UNIT                                                            \"\n                vwField CUST_CITY                           \"CITY_STATE                                                          \"\n                vwField CUST_APT_LOT                        \"APT_UNIT                                                            \"\n                vwField CUST_ZIP_CODE                       \"LEFT(ZIP,5)                                                         \"\n                vwField CUST_ZIP_PLUS_4                     \"ZIP                                                                 \"\n// DIM_CUST_PAR                                                                                                                    \n                vwField CUST_PAR_ID                         \"IIF(LEN(CARE_OF) > 1, CUST_ID, '***')                               \"\n                vwField CUST_PAR_NAME                       \"IIF(LEN(CARE_OF) > 1, CARE_OF, '***')                               \"\n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date2                                                   \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'HPL '                                                              \"\n                vwField COH_EMP_NUM                         \"'HPL-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type2                                                   \"\n                vwField DET_TRANS_DESCR                     \" case Transaction_Type2 \n                                                              when 'Payment'          then 'Base, City Portion Paid'              \n                                                              when 'Paid'             then 'Base, City Portion Paid'              \n                                                              when 'Adjustment'       then 'Base Adjustment'                 \n                                                              when 'Billed'           then 'Base Amount Billed'                                                                 \n                                                              when 'Turnback'         then 'Base Amount Turnback'                                                                 \n                                                              when 'Turnover'         then 'Base Amount Turnover'                                                                 \n                                                              end                                                                \"\n                vwField DET_TRANS_CODE                      \"'HPL-' + Transaction_Type2                                          \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"'HPL Billed'                                                        \"\n                vwField INCDT_TYPE                          \"'Houston Public Library'                                            \"\n                vwField INCDT_CAT                           \"'Houston Public Library'                                            \"\n                vwField INCDT_DTE                           \"Date_Billed                                                         \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"ITEM_TYPE                                                           \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(CollectionState2 > 0, 'Y','N')                                  \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Date_Billed                                                         \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"IIF(CollectionState2 > 0, TurnoverDate, '1900-01-01')               \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(CollectionState2 > 0, '0000109958' , 'CoH')                     \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(PIF='Y','Close','Open')                                         \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"IIF(PIF='Y',Transaction_Date2, '1900-01-01')                        \"    \n                vwField ITEM_DESCR                          \"'HPL Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n                vwField RECEIVABLE_VERS_BILLING_TO_DTE      \"IIF(CollectionState2 > 0,TurnoverDate,'1900-01-01')                 \"   \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount2                                                 \"      \n                vwField POST_DTE                            \"Transaction_Date2                                                   \"                               \n        ]\n    )\n(*          \nopen SlowlyChangingDimensions\nprint HPLView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},"expanded":true,"level":0,"properties":{}},{"name":"View MCD","content":"let MCDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS2       \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS_STEP0_v2  \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'MCD'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n\n                vwField BUS_AREA_ID                         \"'1600'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'MCD'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'MCD'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Municipal Courts'                                                  \"\n                vwField DIV_LONG_NAME                       \"'Municipal Courts'                                                  \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'MCD-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'MCD Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'MCD generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(Vendor_ID LIKE 'INCOLL', '***', '0000100103')\" // this is needed to point to Linebarger when they have it\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_PHN_NUM_1                      \"ResPhone                                                            \"\n                vwField CUST_NAME                           \"DefLastName + ', ' + DefFirstName                                   \"\n                vwField DL_ISSUE_STATE                      \"DLState                                                             \"\n                vwField DL_NUM                              \"DLNbr                                                               \"\n                vwField CUST_ADDR_LINE_1                    \"BestAddLine1                                                        \"\n                vwField CUST_ADDR_LINE_2                    \"BestAddLine2                                                        \"\n                vwField CUST_CITY                           \"BestAddCity                                                         \"\n                vwField CUST_STATE                          \"BestAddState                                                        \"\n                vwField CUST_ZIP_CODE                       \"BestAddZip                                                          \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'MCD '                                                              \"\n                vwField COH_EMP_NUM                         \"'MCD-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"IIF(Transaction_Type = 'Non-Monetary','Adjustment',Transaction_Type) \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc                                                    \"\n                vwField DET_TRANS_CODE                      \"'MCD-' + Transaction_Type                                           \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"ViolationDesc                                                       \"\n                vwField VIO_CODE                            \"ViolationCode                                                       \"\n                vwField ADJ_FLAG                            \"ADJUDICATED_STATUS                                                  \"\n                vwField INCDT_TYPE                          \"'Municipal Courts'                                                  \"\n                vwField INCDT_CAT                           \"'Municipal Courts'                                                  \"\n                vwField INCDT_DTE                           \"ViolationDate                                                       \"\n                vwField INCDT_TIME                          \"ViolationTime                                                       \"\n                vwField INCDT_ADDR_LINE_1                   \"VioStreetName                                                       \"\n                vwField BLK_NUM                             \"VioStreetBlck                                                       \"\n// DIM_ITEM                                                                                                                      \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"ViolationStatus                                                     \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(Vendor_ID LIKE 'INCOLL', 'N','Y')                               \"\n       // too complex resolve in source  vwField RECEIVABLE_VERS_DELINQ_DTE          \"IIF(V.Vendor_ID LIKE 'INCOLL',NULL ,R.Turnover_DTE)                               \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(Turnover_DTE is null,DATEADD(day,60,Issue_DTE),Turnover_DTE) \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_DTE                                                           \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_DTE                                                        \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(Vendor_ID LIKE 'INCOLL','CoH' , '0000106846')                   \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(ViolationStatus='CLOSED','Close','Open')                        \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"STATUS_DATE                                                         \"    \n                vwField ITEM_DESCR                          \"'MCD Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"DefLastName + ', ' + DefFirstName                                   \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"STATUS_DATE                                                         \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint MCDView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},"expanded":true,"level":0,"properties":{}},{"name":"View PWE","content":"let PWEView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'PWE'                                                           \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                         \"\n\n                vwField BUS_AREA_ID                         \"'2000'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'PWE'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'PWE'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Public Works & Engineering'                                    \"\n                vwField DIV_LONG_NAME                       \"'Public Works & Engineering'                                    \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'PWE-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'PWE Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'PWE generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'PWE-'+ CONVERT(VARCHAR, ACCOUNTNUMBER)                         \"\n                vwField CUST_NAME                           \"CUSTDESC1                                                       \"\n                vwField CUST_ADDR_LINE_1                    \"CONVERT(VARCHAR(10), STNO) + ' ' + CONVERT(VARCHAR(max), STNAME)\"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(ZIP) = 0, '***', isnull(LEFT(ZIP, 5) ,'***'))           \"\n                vwField CUST_TYPE                           \"ACCTCLASSDESC                                                   \"\n\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'PWE '                                                          \"\n                vwField COH_EMP_NUM                         \"'PWE-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t when 'Paid'                then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Billed'   end          \"\n                vwField DET_TRANS_CODE                      \"'PWE-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                         \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'PWE Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'PWE Transaction'                                                   \"    \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"ISNULL(Due_Date, DATEADD(day, 21, CONVERT(DATETIME, Issue_Date)))   \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"CUSTDESC                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint PWEView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},"expanded":true,"level":0,"properties":{}},{"name":"module Dimensions =","content":"module Dimensions =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"expanded":true,"level":0,"properties":{}},{"name":"dimReceivable","content":"let dimReceivable = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_RECEIVABLE        \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_BOOT_TOW_DET\"\n                    \"DIM_RECEIVABLE_EMS_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_FIRE_ALM_CIT_DET\"\n                    \"DIM_RECEIVABLE_PRKG_CONTRA_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                     \n                    SourceDate     DTE\n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n                    \n                    SurrogateKey   RECEIVABLE_KEY                    \n                    SCD2BeginDate  VERS_BEG_DTE                       \n                    SCD2EndDate    VERS_END_DTE                       \n                    SCD2Current    CURR_VERS_FLAG           \n\n////////////                       SCD2                              SCD1                             SCD0        \n////////////                       ---------                         -------                          ------\n                    SCD2           RECEIVABLE_STAT                   Nil                              Nil\n                    SCD2           RECEIVABLE_STAT_CHG_DTE           Nil                              Nil\n                    SCD2           RECEIVABLE_VERS_ISSUE_DTE         RECEIVABLE_CURR_ISSUE_DTE        RECEIVABLE_ORIG_ISSUE_DTE            \n                    SCD2           RECEIVABLE_VERS_DUE_DTE           RECEIVABLE_CURR_DUE_DTE          RECEIVABLE_ORIG_DUE_DTE              \n                    SCD2           RECEIVABLE_VERS_DELINQ_DTE        RECEIVABLE_CURR_DELINQ_DTE       RECEIVABLE_ORIG_DELINQ_DTE           \n                    SCD2           RECEIVABLE_VERS_TO_DTE            RECEIVABLE_CURR_TO_DTE           RECEIVABLE_ORIG_TO_DTE               \n                    SCD2           RECEIVABLE_VERS_BILLING_TO_DTE    RECEIVABLE_CURR_BILLING_TO_DTE   RECEIVABLE_ORIG_BILLING_TO_DTE       \n                    SCD2           VERS_ASSIGNED_VEND                CURR_ASSIGNED_VEND               ORIG_ASSIGNED_VEND              \n                    SCD2           RECEIVABLE_MSTR_STAT              Nil                              Nil\n                    SCD2           RECEIVABLE_MSTR_STAT_CHG_DTE      Nil                              Nil\n\n////////////                       SCD1                              SCD0                    \n////////////                       ---------                         -------                        \n                    SCD1           INV_NUM                           ORIG_INV_NUM                   \n                    SCD1           RECEIVABLE_EVER_TRANS_FLAG        Nil\n                    SCD1           RECEIVABLE_LITIGATION_DTE         Nil\n                    SCD1           RECEIVABLE_FNL_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_1ST_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_SETTLEMENT_DTE         Nil\n                    SCD1           FIRE_ALM_AGING_RST_FLAG           Nil\n                    SCD1           REINSTATEMENT_DTE                 Nil\n                    SCD1           FIRE_ORIG_ISSUE_DTE               Nil\n                    SCD1           ITEM_DESCR                        Nil\n                    SCD1           ORIG_BILL_NAME                    Nil\n                    SCD1           UNK_CUST_AT_BILL_FLAG             Nil\n\n////////////                       SCD0                    \n////////////                       --------- \n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME              \n                    \n                    SCD1           FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET  Nil\n                    SCD1           ``A#3307_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3308_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3348_ATTY_FEE_DTE``                    Nil\n                    SCD1           AD_VAL_ACCT_LVL_ID                         Nil\n                    SCD1           AD_VAL_DISABLED_FLAG                       Nil\n                    SCD1           AD_VAL_EFF_DTE_OF_OWNERSHIP                Nil\n                    SCD1           AD_VAL_HOMESTEAD_FLAG                      Nil\n                    SCD1           AD_VAL_OVER_66_FLAG                        Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_END_DTE                Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_START_DTE              Nil\n                    SCD1           AD_VAL_VET_FLAG                            Nil\n                    SCD1           COLL_LAWSUIT_NUM                           Nil\n                    SCD1           COLL_LGL_COND                              Nil\n                    SCD1           HCAD_ACCT_STAT                             Nil\n                    SCD1           QTRLY_PAY_FLAG                             Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_BOOT_TOW_DET           Nil\n                    SCD1           RECEIVABLE_HAS_LTR_FLAG                    Nil\n                    SCD1           RECEIVABLE_HAS_NOTE_FLAG                   Nil\n                    SCD1           RECEIVABLE_HAS_PEND_LTR_FLAG               Nil\n                    SCD1           RESOLVE_DESCR                              Nil\n                    SCD1           RESOLVE_DTE                                Nil\n                    SCD1           RESOLVE_RSN                                Nil\n                    SCD1           RESOLVED_BY                                Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET     Nil\n                    SCD1           ACTV_CARRIER                               Nil\n                    SCD1           ACTV_CARRIER_FIN_CLASS                     Nil\n                    SCD1           ACTV_CARRIER_FIN_GRP                       Nil\n                    SCD1           BILLING_HOLD_FLAG                          Nil\n                    SCD1           SIG_FLAG                                   Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET       Nil\n                    SCD1           VOID_CODE                                  Nil\n                    SCD1           VOID_DESCR                                 Nil\n                    SCD1           WORK_STAT                                  Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET        Nil\n                    SCD1           ESC_CAND_FLAG                              Nil\n                    SCD1           ON_ADMIN_HOLD_FLAG                         Nil\n                    SCD1           UNDER_APPEAL_FLAG                          Nil\n                    SCD1           VOID_FLAG                                  Nil\n                    SCD1           WRITE_OFF_FLAG                             Nil\n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimReceivable.Procedure\nprint dimReceivable.Verification\n*)","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},"expanded":true,"level":0,"properties":{}},{"name":"dimItem","content":"let dimItem = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_ITEM              \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes = \n                 [\n                    \"DIM_ITEM_BURG_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_FIRE_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_LICENSED_VEH_DET\"\n                    \"DIM_ITEM_PT_DET\"\n                    \"DIM_ITEM_TAXABLE_PROP_DET\"\n                    \"DIM_ITEM_WTR_ACCT_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    ITEM_TYPE                     \n                    SourceDate     DTE                           \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   ITEM_KEY                        \n                    SCD2BeginDate  VERS_BEG_DTE                     \n                    SCD2EndDate    VERS_END_DTE                     \n                    SCD2Current    CURR_VERS_FLAG                \n                    SCD2           ITEM_STAT                        Nil                             Nil\n                    SCD2           ITEM_STAT_CHG_DTE                Nil                             Nil\n                    SCD1           ITEM_EXMPT_FLAG                  Nil\n                    SCD1           ITEM_ADDR_LINE_1                 Nil\n                    SCD1           ITEM_ADDR_LINE_2                 Nil\n                    SCD1           ITEM_ADDR_LINE_3                 Nil\n                    SCD1           ITEM_ST_NUM                      Nil\n                    SCD1           ITEM_PREFIX                      Nil\n                    SCD1           ITEM_ST_PRETYPE                  Nil\n                    SCD1           ITEM_ST_NAME                     Nil\n                    SCD1           ITEM_ST_TYPE                     Nil\n                    SCD1           ITEM_SUFF                        Nil\n                    SCD1           ITEM_SERV_LVL                    Nil\n                    SCD1           ITEM_IN_CITY_FLAG                Nil\n                    SCD1           ITEM_CITY                        Nil\n                    SCD1           ITEM_STATE                       Nil\n                    SCD1           ITEM_CTRY                        Nil\n                    SCD1           ITEM_ST_DIR                      Nil\n                    SCD1           ITEM_ST                          Nil\n                    SCD1           ITEM_CNTY                        Nil\n                    SCD1           ITEM_APT_LOT                     Nil\n                    SCD1           ITEM_GIS_MATCH_SCORE             Nil\n                    SCD1           ITEM_GIS_ST_NUM                  Nil\n                    SCD1           ITEM_GIS_PREFIX                  Nil\n                    SCD1           ITEM_GIS_ST_PRETYPE              Nil\n                    SCD1           ITEM_GIS_ST_NAME                 Nil\n                    SCD1           ITEM_GIS_ST_TYPE                 Nil\n                    SCD1           ITEM_GIS_SUFF                    Nil\n                    SCD1           ITEM_GIS_CITY                    Nil\n                    SCD1           ITEM_GIS_ZIP                     Nil\n                    SCD1           ITEM_GIS_X                       Nil\n                    SCD1           ITEM_GIS_Y                       Nil\n                    SCD1           ITEM_ZIP_CODE                    Nil\n                    SCD1           ITEM_ZIP_PLUS_4                  Nil\n                    SCD1           ITEM_GIS_LOCATR_NAME             Nil\n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME         \n                    \n                    SCD1           FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET  Nil\n                    SCD1           ALLOWABLE_NO_CHRG_INCDTS           Nil\n                    SCD1           ALM_MNT_CMPNY                      Nil\n                    SCD1           ALM_TYPE                           Nil\n                    SCD1           PERMIT_EXP_DTE                     Nil\n                    SCD1           PERMIT_ISSUE_DTE                   Nil\n                    SCD1           PERMIT_NAME                        Nil\n                    SCD1           PERMIT_NUM                         Nil\n                    SCD1           REG_HOLDER_FLAG                    Nil\n                    SCD1           SUSPD_PERMIT_DTE                   Nil\n                    SCD1           SUSPD_PERMIT_RSN                   Nil\n                    SCD1           TYPE_OF_ALM_SITE                   Nil\n                    SCD1           FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET  Nil\n                    SCD1           ALM_INSTL_CMPNY                    Nil\n                    SCD1           ALM_INSTL_DTE                      Nil\n                    SCD1           ALM_REG_KEY                        Nil\n                    SCD1           APPLICTN_RECV_DTE                  Nil\n                    SCD1           CURR_FIRE_ALM_PERMIT_FLAG          Nil\n                    SCD1           EXCL_TYPE                          Nil\n                    SCD1           FIRE_ALM_PERMIT_ACTV_FLAG          Nil\n                    SCD1           FIRE_ALM_PERMIT_NUM                Nil\n                    SCD1           FIRE_ALM_PURPOSE                   Nil\n                    SCD1           FLAG_DIM_ITEM_LICENSED_VEH_DET     Nil\n                    SCD1           LICENSE_PLATE_EXP_MTH              Nil\n                    SCD1           LICENSE_PLATE_EXP_YR               Nil\n                    SCD1           LICENSE_PLATE_NUM                  Nil\n                    SCD1           LICENSE_PLATE_TYPE                 Nil\n                    SCD1           OWNER_IS_CUST_FLAG                 Nil\n                    SCD1           SRC_SYS_VEH_ID                     Nil\n                    SCD1           VEH_COLOR                          Nil\n                    SCD1           VEH_ID_NUM                         Nil\n                    SCD1           VEH_MAKE                           Nil\n                    SCD1           VEH_MODEL                          Nil\n                    SCD1           VEH_MODEL_YR                       Nil\n                    SCD1           VEH_OWNER_ID                       Nil\n                    SCD1           VEH_OWNER_NAME                     Nil\n                    SCD1           VEH_TYPE                           Nil\n                    SCD1           FLAG_DIM_ITEM_PT_DET               Nil\n                    SCD1           PT_AGE                             Nil\n                    SCD1           PT_GNDR                            Nil\n                    SCD1           FLAG_DIM_ITEM_TAXABLE_PROP_DET     Nil\n                    SCD1           APPRAISAL_DISTR_ACCT_NUM           Nil\n                    SCD1           CAN                                Nil\n                    SCD1           CC_JURIS_CODE                      Nil\n                    SCD1           CC_JURIS_DESCR                     Nil\n                    SCD1           CITY_RFPD_JURIS_CODE               Nil\n                    SCD1           CITY_RFPD_JURIS_DESCR              Nil\n                    SCD1           CONFI_ACCT_FLAG                    Nil\n                    SCD1           MUNIC_UTIL_DISTR_CODE              Nil\n                    SCD1           MUNIC_UTIL_DISTR_DESCR             Nil\n                    SCD1           NUM_OF_ACRES                       Nil\n                    SCD1           OWNERSHIP_EFF_DTE                  Nil\n                    SCD1           PROP_CLASS_CODE                    Nil\n                    SCD1           PROP_CLASS_DESCR                   Nil\n                    SCD1           REND_PENALTY_JURIS_CODE            Nil\n                    SCD1           REND_PENALTY_JURIS_DESCR           Nil\n                    SCD1           SCHOOL_JURIS_CODE                  Nil\n                    SCD1           SCHOOL_JURIS_DESCR                 Nil\n                    SCD1           SUBSTANTIAL_ERR_PENALTY            Nil\n                    SCD1           TAX_DEFERRAL_END_DTE               Nil\n                    SCD1           TAX_DEFERRAL_START_DTE             Nil\n                    SCD1           TAX_ROLL_CODE                      Nil\n                    SCD1           TAX_ROLL_DESCR                     Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_1           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_2           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_3           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_4           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_5           Nil\n                    SCD1           TAXABLE_PROP_ROLL_TYPE             Nil\n                    SCD1           FLAG_DIM_ITEM_WTR_ACCT_DET         Nil\n                    SCD1           CURR_WTR_ACCT_FLAG                 Nil\n                    SCD1           DELINQ_DTE                         Nil\n                    SCD1           LAST_CUST_CONN_DTE                 Nil\n                    SCD1           LAST_CUST_CUTOFF_DTE               Nil\n                    SCD1           LAST_CUST_DISCONN_DTE              Nil\n                    SCD1           LAST_METER_INSPECT_DTE             Nil\n                    SCD1           OWNER_RENTER                       Nil\n                    SCD1           SEN_CITIZEN_FLAG                   Nil\n                    SCD1           VAC_FLAG                           Nil\n                    SCD1           WTR_ACCT_NUM_OF_UNITS              Nil\n                    SCD1           WTR_ACCT_ORIG_USE_TYPE             Nil\n                    SCD1           WTR_ACCT_PROP_USE_TYPE             Nil\n                    SCD1           WTR_METER_NUM                      Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimItem.Procedure\nprint dimItem.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},"expanded":true,"level":0,"properties":{}},{"name":"dimIncdt","content":"let dimIncdt = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_INCDT             \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_INCDT_EMS_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                          \n                    SourceDate     DTE                                 \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   INCDT_KEY                              \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           ADJ_FLAG                              Nil Nil\n                    SCD1           BILLED_FLAG                           Nil\n                    SCD1           RSN_INCDT_NOT_BILLED                  Nil\n                    SCD1           INV_NUM                               Nil\n                    SCD1           PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG  Nil\n                    SCD1           INCDT_DESCR                           Nil\n                    SCD1           VIO_CODE                              Nil\n                    SCD1           INCDT_TYPE                            Nil\n                    SCD1           INCDT_CAT                             Nil\n                    SCD1           TOWING_CMPNY                          Nil\n                    SCD1           BOOT_SERIAL_NUM                       Nil\n                    SCD1           PRKG_METER_VIO_FLAG                   Nil\n                    SCD1           PRKG_METER_NUM                        Nil\n                    SCD1           INCDT_SEQ_NUM                         Nil\n                    SCD1           INCDT_DTE                             Nil\n                    SCD1           INCDT_TIME                            Nil\n                    SCD1           INCDT_ADDR_LINE_1                     Nil\n                    SCD1           INCDT_ADDR_LINE_2                     Nil\n                    SCD1           INCDT_ADDR_LINE_3                     Nil\n                    SCD1           INCDT_ST_NUM                          Nil\n                    SCD1           INCDT_PREFIX                          Nil\n                    SCD1           INCDT_ST_PRETYPE                      Nil\n                    SCD1           INCDT_ST_NAME                         Nil\n                    SCD1           INCDT_ST_TYPE                         Nil\n                    SCD1           INCDT_SUFF                            Nil\n                    SCD1           INCDT_SERV_LVL                        Nil\n                    SCD1           INCDT_IN_CITY_FLAG                    Nil\n                    SCD1           INCDT_CITY                            Nil\n                    SCD1           INCDT_STATE                           Nil\n                    SCD1           INCDT_CTRY                            Nil\n                    SCD1           INCDT_ST_DIR                          Nil\n                    SCD1           INCDT_ST                              Nil\n                    SCD1           INCDT_CNTY                            Nil\n                    SCD1           INCDT_APT_LOT                         Nil\n                    SCD1           INCDT_GIS_MATCH_SCORE                 Nil\n                    SCD1           INCDT_GIS_ST_NUM                      Nil\n                    SCD1           INCDT_GIS_PREFIX                      Nil\n                    SCD1           INCDT_GIS_ST_PRETYPE                  Nil\n                    SCD1           INCDT_GIS_ST_NAME                     Nil\n                    SCD1           INCDT_GIS_ST_TYPE                     Nil\n                    SCD1           INCDT_GIS_SUFF                        Nil\n                    SCD1           INCDT_GIS_CITY                        Nil\n                    SCD1           INCDT_GIS_ZIP                         Nil\n                    SCD1           INCDT_GIS_X                           Nil\n                    SCD1           INCDT_GIS_Y                           Nil\n                    SCD1           INCDT_ZIP_CODE                        Nil\n                    SCD1           INCDT_ZIP_PLUS_4                      Nil\n                    SCD1           INCDT_GIS_LOCATR_NAME                 Nil\n                    SCD1           BLK_NUM                               Nil\n//                  SCD1           VEH                                   Nil\n//                  SCD1           EMS_INCDT                             Nil\n//                  SCD1           DISPATCH_NUM                          Nil\n//                  SCD1           EMS_INCDT_CAT                         Nil\n//                  SCD1           TXP_SERV_LVL                          Nil\n//                  SCD1           TXP_TYPE                              Nil\n//                  SCD1           ORIGIN_LOC                            Nil\n//                  SCD1           DEST_LOC                              Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n\n                    SCD1           FLAG_DIM_INCDT_EMS_DET                Nil\n                    SCD1           DEST_LOC                              Nil\n                    SCD1           DISPATCH_NUM                          Nil\n                    SCD1           EMS_INCDT                             Nil\n                    SCD1           EMS_INCDT_CAT                         Nil\n                    SCD1           ORIGIN_LOC                            Nil\n                    SCD1           TXP_SERV_LVL                          Nil\n                    SCD1           TXP_TYPE                              Nil\n                    SCD1           VEH                                   Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimIncdt.Procedure\nprint dimIncdt.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},"expanded":true,"level":0,"properties":{}},{"name":"dimCust","content":"let dimCust = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CUST              \" \"CUST_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    CUST_ID                                \n                    SourceDate     DTE                                       \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   CUST_KEY                               \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           JV_CUST_FLAG                          Nil Nil\n                    SCD2           DEC_CUST_FLAG                         Nil Nil\n                    SCD1           CONFI_CUST_FLAG                       Nil\n                    SCD1           CUST_EMAIL_ADDR                       Nil\n                    SCD1           CUST_PHN_NUM_1                        Nil\n                    SCD1           CUST_FAX_NUM                          Nil\n                    SCD1           CUST_NAME                             Nil\n                    SCD1           FED_TAX_ID                            Nil\n                    SCD1           CUST_TYPE                             Nil\n                    SCD1           BUS_CONT_PERSON_NAME                  Nil\n                    SCD1           STATE_CORP_CHTR_ID                    Nil\n                    SCD1           STATE_SALES_TAX_ID                    Nil\n                    SCD1           CUST_IS_VEND_FLAG                     Nil\n                    SCD1           SAP_BUS_ID                            Nil\n                    SCD1           NAICS_DET_CODE                        Nil\n                    SCD1           NAICS_INDY_CODE                       Nil\n                    SCD1           NAICS_INDY_GRP_CODE                   Nil\n                    SCD1           NAICS_MAJ_GRP_CODE                    Nil\n                    SCD1           NAICS_DIV_CODE                        Nil\n                    SCD1           SIC_INDY_GRP_CODE                     Nil\n                    SCD1           SIC_MAJ_GRP_CODE                      Nil\n                    SCD1           SIC_DIV_CODE                          Nil\n                    SCD1           DL_ISSUE_STATE                        Nil\n                    SCD1           DL_NUM                                Nil\n                    SCD1           CUST_ADDR_LINE_1                      Nil\n                    SCD1           CUST_ADDR_LINE_2                      Nil\n                    SCD1           CUST_ADDR_LINE_3                      Nil\n                    SCD1           CUST_ST_NUM                           Nil\n                    SCD1           CUST_PREFIX                           Nil\n                    SCD1           CUST_ST_PRETYPE                       Nil\n                    SCD1           CUST_ST_NAME                          Nil\n                    SCD1           CUST_ST_TYPE                          Nil\n                    SCD1           CUST_SUFF                             Nil\n                    SCD1           CUST_SERV_LVL                         Nil\n                    SCD1           CUST_IN_CITY_FLAG                     Nil\n                    SCD1           CUST_CITY                             Nil\n                    SCD1           CUST_STATE                            Nil\n                    SCD1           CUST_CTRY                             Nil\n                    SCD1           CUST_ST_DIR                           Nil\n                    SCD1           CUST_ST                               Nil\n                    SCD1           CUST_CNTY                             Nil\n                    SCD1           CUST_APT_LOT                          Nil\n                    SCD1           CUST_GIS_MATCH_SCORE                  Nil\n                    SCD1           CUST_GIS_ST_NUM                       Nil\n                    SCD1           CUST_GIS_PREFIX                       Nil\n                    SCD1           CUST_GIS_ST_PRETYPE                   Nil\n                    SCD1           CUST_GIS_ST_NAME                      Nil\n                    SCD1           CUST_GIS_ST_TYPE                      Nil\n                    SCD1           CUST_GIS_SUFF                         Nil\n                    SCD1           CUST_GIS_CITY                         Nil\n                    SCD1           CUST_GIS_ZIP                          Nil\n                    SCD1           CUST_GIS_X                            Nil\n                    SCD1           CUST_GIS_Y                            Nil\n                    SCD1           CUST_ZIP_CODE                         Nil\n                    SCD1           CUST_ZIP_PLUS_4                       Nil\n                    SCD1           CUST_GIS_LOCATR_NAME                  Nil\n                    SCD1           CUST_PAR_KEY                          Nil\n                    SCD1           SIC_CODE                              Nil\n                    SCD1           NAICS_DET_NAME                        Nil\n                    SCD1           NAICS_INDY_NAME                       Nil\n                    SCD1           NAICS_INDY_GRP_NAME                   Nil\n                    SCD1           NAICS_MAJ_GRP_NAME                    Nil\n                    SCD1           NAICS_DIV_NAME                        Nil\n                    SCD1           SIC_NAME                              Nil\n                    SCD1           SIC_INDY_GRP_NAME                     Nil\n                    SCD1           SIC_MAJ_GRP_NAME                      Nil\n                    SCD1           SIC_DIV_NAME                          Nil\n                    SCD1           CUST_PHN_NUM_2                        Nil\n                    SCD1           CUST_PHN_NUM_3                        Nil\n                    SCD1           SRC_SYS_MOD_DTE                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCust.Procedure\nprint dimCust.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},"expanded":true,"level":0,"properties":{}},{"name":"dimFinTransType","content":"let dimFinTransType = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_FIN_TRANS_TYPE    \" \"DET_TRANS_CODE LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    DET_TRANS_CODE                               \n                    SurrogateKey   FIN_TRANS_TYPE_KEY                  \n                    SCD1           PAY_METH                              Nil\n                    SCD1           MAN_TRANS_FLAG                        Nil\n                    SCD1           DERIVED_TRANS_FLAG                    Nil\n                    SCD1           MSTR_TRANS_TYPE                       Nil\n                    SCD1           SRC_SYS                               Nil\n                    SCD1           ALLOC_TRANS_FLAG                      Nil\n                    SCD1           DET_TRANS_DESCR                       Nil\n                    SCD1           T2_TRANS_TYPE_CODE                    Nil\n                    SCD1           T2_TRANS_TYPE_DESCR                   Nil\n                    SCD1           T2_TRANS_RSN                          Nil\n                    SCD1           T2_TRANS_PARSED_DESCR                 Nil\n                    SCD1           T2_TRANS_MISC_ITEM_CODE               Nil\n                    SCD1           T2_TRANS_MISC_ITEM_DESCR              Nil\n                    SCD1           T2_TRANS_SCENARIO                     Nil\n                    SCD1           INTRA_FUND_TRANS_FLAG                 Nil\n                    SCD1           T2_TRANS_ORIG_OBJ_TYPE_ID             Nil\n                    SCD1           SMARTCM_OTHER_CRITERIA                Nil\n                    SCD1           SMARTCM_IS_FEE                        Nil\n                    SCD1           SMARTCM_IS_ADJMT                      Nil\n                    SCD1           SMARTCM_IS_PAY                        Nil\n                    SCD1           PMAM_ADJMT_TO                         Nil\n                    SCD1           PMAM_ADJMT_TYPE                       Nil\n                    SCD1           DIGITECH_TRANS_TYPE                   Nil\n                    SCD1           DIGITECH_TRANS_TYPE_DET               Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimFinTransType.Procedure\nprint dimFinTransType.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},"expanded":true,"level":0,"properties":{}},{"name":"dims Carrier, Procedure, CollPerson, Emp, Dte,  CohOrg","content":"let dimCarrier = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_KEY                         \n                    SurrogateKey   CARRIER_KEY                            \n                    SCD1           MEDICARE_PAYER_CODE                   Nil\n                    SCD1           MEDICAID_PAYER_CODE                   Nil\n                    SCD1           CARRIER_FIN_GRP                       Nil\n                    SCD1           CARRIER_FIN_CLASS                     Nil\n                    SCD1           CARRIER_GRP                           Nil\n                    SCD1           CARRIER_NAME                          Nil\n                    SCD1           CARRIER_SRC                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimProcedure = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER_PROCEDURE \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_PROCEDURE_KEY                \n                    SurrogateKey   CARRIER_PROCEDURE_KEY                  \n                    SCD1           CARRIER_PROCEDURE_SRC                 Nil\n                    SCD1           CARRIER_PROCEDURE_CODE                Nil\n                    SCD1           CARRIER_PROCEDURE_DESCR               Nil\n                    SCD1           CARRIER_PROCEDURE_TYPE                Nil\n                    SCD1           CARRIER_PROCEDURE_BILL_CODE           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimCollPerson = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COLL_PERSON       \" \"COLL_PERSON_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    COLL_PERSON_ID                           \n                    SurrogateKey   COLL_PERSON_KEY                        \n                    SCD1           T2_ID                                 Nil\n                    SCD1           PMAM_ID                               Nil\n                    SCD1           SMART_CM_ID                           Nil\n                    SCD1           HCTO_AD_VAL_ID                        Nil\n                    SCD1           COLL_PERSON_TYPE                      Nil\n                    SCD1           COLL_PERSON_NAME                      Nil\n                    SCD1           COH_EMP_NUM                           Nil\n                    SCD1           INT_EXT_EMP_FLAG                      Nil\n                    SCD1           DIGITECH_ID                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimEmp = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_EMP               \" \"COH_EMP_NUM LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                              \" \"\"\n      , fields = [\n                    BusinessKey    COH_EMP_NUM                                  \n                    SurrogateKey   EMP_KEY                                \n                    SCD1           EMP_TYPE                              Nil\n                    SCD1           EMP_NAME                              Nil\n                    SCD1           RM_LOAD_DTE                           Nil\n                    SCD1           RM_LOAD_TIME                          Nil\n                    SCD1           RM_EMP_MSTR_KEY                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n\n\nlet dimDte = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_DTE               \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DTE                                         \n                    SurrogateKey   DTE_KEY                               \n                 ]\n    )\n\nlet dimCohOrg = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COH_ORG           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DEPT_LONG_NAME                       \n                    SurrogateKey   COH_ORG_KEY\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCarrier   .Procedure\nprint dimProcedure .Procedure\nprint dimCollPerson.Procedure\nprint dimEmp       .Procedure\nprint dimCohOrg    .Procedure\n\nprint dimCarrier   .Verification\nprint dimProcedure .Verification\nprint dimCollPerson.Verification\nprint dimEmp       .Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"id":{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},"expanded":true,"level":0,"properties":{}},{"name":"FactTable finTrans","content":"open Dimensions\nlet finTrans =\n    FactTable.New(\n               table  = SQLTableView.New \"         \" \"       \" \"FG_FIN_TRANS_INTER    \" \"\" \"\"\n             , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n             , dims   = [ //        dimension       SurrogateKey    BusinessKey (if different)\n                          dimension dimCust         Nil              Nil_\n                          dimension dimReceivable   Nil              Nil_\n                          dimension dimItem         Nil              Nil_\n                          dimension dimIncdt        Nil              Nil_\n                        //dimension dimCarrier      Nil              Nil_\n                        //dimension dimProcedure    Nil              Nil_\n                          dimension dimCollPerson   Nil              Nil_\n                          dimension dimEmp          Nil              Nil_\n                          dimension dimFinTransType Nil              Nil_\n                          dimension dimCohOrg       Nil              Nil_\n                          dimension dimDte          TRANS_DTE_KEY    Nil_\n                          dimension dimDte          POST_DTE_KEY     POST_DTE\n                        ]\n             , fields = [\n                          OField  SYS_LOAD_KEY          \"(SELECT MAX(SYS_LOAD_KEY) FROM DIM_SYS_LOAD WHERE SRC_SYS = @SOURCE)\"\n                          OField  ORIG_CUST_KEY         \"D0.CUST_KEY     \"\n                          OField  COLL_VEND_CONTR_KEY   \"CON.CONTR_KEY   \"\n                          OField  GL_COMBO_KEY          \"1\"\n                          Fact    TRANS_CNT            \n                          Fact    TRANS_AMT            \n                          Fact    INTRA_FUND_TRANS_AMT \n                          Fact    LOAD_DTE             \n                          Fact    LOAD_TIME            \n                          Fact    SRC_SYS_TRANS_ID     \n                        ]\n             , extra  = \"\"\"\nBEGIN\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started DELETE FG_FIN_TRANS_INTER', '';\n    DELETE S \n    FROM        FG_FIN_TRANS_INTER S \n    INNER JOIN  DIM_SYS_LOAD L ON L.SYS_LOAD_KEY = S.SYS_LOAD_KEY \n    INNER JOIN  DIM_DTE      D ON D.DTE_KEY      = S.TRANS_DTE_KEY\n    WHERE L.SRC_SYS = @SOURCE\n      AND D.DTE BETWEEN ISNULL(@FROM, '1000-01-01') AND ISNULL(@TO, '9999-12-31');\n    \n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started INSERT FG_FIN_TRANS_INTER', '';\n    %s\n LEFT JOIN  DIM_VEND             V ON V.VEND_ID               = S.VERS_ASSIGNED_VEND\n LEFT JOIN  DIM_CONTR          CON ON  CON.VEND_KEY           = V.VEND_KEY              AND S.DTE BETWEEN CON.VALID_FROM_DTE AND CON.VALID_TO_DTE\n                                  AND (CON.CONTR_REV_STREAM   = S.SRC_SYS                OR CON.CONTR_REV_STREAM   = '***'    ) \n\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'FINISHED!!! INSERT FG_FIN_TRANS_INTER', '';\nEND\n             \"\"\"\n             )\n\n(*\nopen SlowlyChangingDimensions\nprint finTrans       .Procedure\n*)\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"}],"id":{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},"expanded":true,"level":0,"properties":{}},{"name":"SQLFetchFields & SnowFlakeViews ","content":"#if SLOWLY_CHANGING_DIMENSIONS\n#define SQL_FETCH_FIELDS \nopen FSharp.Data\n\n[<Literal>]\nlet ConnectionString = @\"Data Source=ARStagingDB.HouTx.lcl;Initial Catalog=ARDatamart;UID=cipherbsc;PWD=123456\"\nlet columns = \n    lazy\n        use cmd = new SqlCommandProvider<\"\nWITH Columns as (\n    SELECT DISTINCT \n           ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT ColumnName, DataType, NULLABLE  \nFROM Columns WHERE NRec = 1\n\" , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute()\n\nlet defaults =\n    lazy\n        use cmd = new SqlCommandProvider<\"SELECT TOP 1 * FROM ARStaging.EMS_MSB.VW_FG_FIN_TRANS\" , ConnectionString, ResultType = ResultType.DataReader>(ConnectionString)\n        use rdr = cmd.Execute()\n        if rdr.Read() |> not then [||] else\n        [|\n            for i = 0 to rdr.FieldCount - 1 do\n                if rdr.IsDBNull i |> not then\n                    yield rdr.GetName i, rdr.GetValue i \n                                         |> sprintf \"%A\" \n                                         |> fun s -> if s.StartsWith \"\\\"\" \n                                                     then s.[1..s.Length-2] |> sprintf \"'%s'\" \n                                                     else s\n        |]\n\n\nlet writeFieldDecl () =\n    columns.Value\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDecl = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDecl.fsx\", txt)\n\nlet writeFieldDefault_Source () =\n    defaults.Value\n    |> Seq.sortBy snd\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDefault = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDefault source.fsx\", txt)\n\n[<Literal>]\nlet columnsQuery = \"\nWITH Columns as (\n    SELECT DISTINCT \n\t\t   TableName  = ISNULL(UPPER(TABLE_NAME), 'Nil')\n         , ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT DISTINCT \n       TableName\n     , ColumnName\n  FROM Columns\n WHERE CHARINDEX('|' + TableName + '|', @tables) > 0\nORDER BY 1, 2   \n   \"\n\ntype Dimension with\n    member this.allColumns() =\n        use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute(this.Snowflakes |> String.concat \"|\" |> sprintf \"|%s|%s|\" this.TableBase.sqlObject)\n    member this.superView() =\n        if this.Snowflakes |> Seq.isEmpty then \"\" else\n        let columns    = this.allColumns()\n        let first      = this.TableBase.sqlObject\n        let snowflakes = this.Snowflakes |> Seq.sort\n        let flags      = snowflakes |> Seq.map (sprintf \"        FLAG_%s = 0\")\n        let from  = \n            snowflakes\n            |> Seq.map (fun j -> sprintf \"LEFT JOIN %s ON %s.%s = %s.%s\" j j this.SurrogateKey first this.SurrogateKey)\n            |> String.concat \"\\n\"\n            |> sprintf \"  FROM %s \\n%s\" first\n        let fieldList f fields = fields |> Seq.map f |> String.concat \",\\n\"\n        let view =\n            columns\n            |> Seq.distinctBy (fun (tb, cl) -> cl)\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s.%s\" (nameS tb) (nameS cl))\n            |> sprintf \"%s,\\n%s\" (flags |> String.concat \",\\n\")\n            |> sprintf \"SELECT \\n%s\\n%s\" <| from\n            |> sprintf \"%sAS\\n%s;\\nGO\" (sqlDropCreate VIEW (sprintf \"GENERIC.%s\" this.TableName))\n        let fields table = columns |> Seq.filter (fst >> ((=) table))\n        let snowflakeCond table = \n            if table = first then \"\" else \n            sprintf \"IF (SELECT TOP 1 FLAG_%s FROM INSERTED) = 1 \\n\" table\n        let createTrigger command codes =\n            codes\n            |> String.concat \";\\n\"\n            |> sprintf \"  ON GENERIC.SV_%s\\nINSTEAD OF %s AS\\nBEGIN\\n%s\\nEND;\\nGO\" first command\n            |> sprintf \"%s\\n%s\" (sqlDropCreate TRIGGER (sprintf \"GENERIC.TR_%s_%s\" command first))\n        let insertTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s\" (nameS cl))\n            |> (fun flds -> \n                sprintf \"%s  INSERT INTO %s (%s)\\n  SELECT %s \\n  FROM inserted\"\n                  (snowflakeCond table) table flds flds      \n               )\n        let updateTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"    %s = inserted.%s\" (nameS cl) (nameS cl))\n            |> sprintf \"%s  UPDATE T SET\\n%s\\n  FROM %s T, inserted  \\n  WHERE T.%s = inserted.%s;\"\n                 (snowflakeCond table)\n                 <| table <| this.SurrogateKey <| this.SurrogateKey \n        let tables = Seq.append [first] snowflakes\n        let insert = tables |> Seq.map insertTable |> createTrigger \"INSERT\"\n        let update = tables |> Seq.map updateTable |> createTrigger \"UPDATE\"\n        view + insert + update\n\nlet snowflakeFields (dim: Dimension) =\n    if dim.Snowflakes |> Seq.isEmpty then \"\" else\n    use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n    let columns = \n        cmd.Execute(dim.Snowflakes |> Seq.sort |> String.concat \"|\" |> sprintf \"|%s|%s|\" dim.TableName)\n        |> Seq.distinctBy (fun (tb, cl) -> cl)\n\n    dim.Snowflakes\n    |> Seq.collect\n         (fun t ->\n            Seq.append\n                [ sprintf \"FLAG_%s\" t ]\n                (columns |> Seq.filter(fun (tb, fl) -> tb = t) |> Seq.map snd)\n         )\n    |> String.concat \"\\n\"\n\nlet snowflakeMissingFields (dim: Dimension) =\n    dim.allColumns()\n    |> Seq.filter(fun (tb, fn) -> \n        (finTransViewFieldNames |> Seq.contains fn |> not)\n     && (targetFieldNames       |> Seq.contains fn |> not)\n    )\n\nlet wrongFields (dim: Dimension) =\n    dim.AllFields\n    |> Seq.filter (fun n -> dim.allColumns() |> Seq.exists (fun (tb, cl) -> cl = n) |> not)\n\n#endif\n\n(*          \nopen SlowlyChangingDimensions\nprint <| dimItem      .superView()\nprint <| dimIncdt     .superView()\nprint <| dimReceivable.superView()\n\ndo writeFieldDecl()\ndo writeFieldDefault_Source()\n\nprint <| snowflakeFields dimIncdt      \nprint <| snowflakeFields dimItem       \nprint <| snowflakeFields dimReceivable \n\ndimReceivable.allColumns()            |> Seq.toList |> printfn \"%A\" \nsnowflakeMissingFields dimItem        |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimItem        |> Seq.iter     (printfn \"%A\")  \nwrongFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nwrongFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimCust        |> Seq.iter     (printfn \"%A\")\nwrongFields dimCarrier     |> Seq.iter     (printfn \"%A\")\nwrongFields dimProcedure   |> Seq.iter     (printfn \"%A\")\nwrongFields dimCollPerson  |> Seq.iter     (printfn \"%A\")\nwrongFields dimEmp         |> Seq.iter     (printfn \"%A\")\nwrongFields dimCohOrg      |> Seq.iter     (printfn \"%A\")\nwrongFields dimFinTransType|> Seq.iter     (printfn \"%A\")\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"id":{"$":0,"Item":"db8ed4d6-4bee-407f-958e-250016275444"},"expanded":true,"level":0,"properties":{}},{"name":"Copy Views and Procedures","content":"#if SLOWLY_CHANGING_DIMENSIONS\n\nlet bAllViews = \"Copy ALL views\", fun _ -> AllFactViews  |> Seq.map (fun st -> st.Query    ) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bAllDims  = \"Copy ALL dims\" , fun _ -> AllDimensions |> Seq.map (fun dm -> dm.Procedure) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bViews    = AllFactViews  |> Seq.map    (fun st -> st.ViewName      |> sprintf \"Copy %s\", (fun _ -> st.Query       |> Useful.sCopy )) |> Seq.toList\nlet bDims     = AllDimensions |> Seq.map    (fun dm -> dm.ProcedureName |> sprintf \"Copy %s\", (fun _ -> dm.Procedure   |> Useful.sCopy )) |> Seq.toList\nlet bfact     = AllFactTables |> Seq.map    (fun ft -> ft.ProcedureName |> sprintf \"Copy %s\", (fun _ -> ft.Procedure   |> Useful.sCopy )) |> Seq.toList\n#if SQL_FETCH_FIELDS\nlet bSuperVw  = AllDimensions |> Seq.filter (fun dm -> dm.Snowflakes |> Seq.isEmpty |> not) \n                              |> Seq.map    (fun dm -> dm.TableName  |> sprintf \"Copy %s SuperView\", (fun _ -> dm.superView() |> Useful.sCopy )) |> Seq.toList\n#endif                              \n\n[\n  if not bViews.IsEmpty then\n      yield ( \"===== For ARStaging Database ======\", fun _ -> \"---------------------\"  )\n  if bViews.Length > 1 then yield bAllViews\n  yield! bViews\n  if not AllDimensions.IsEmpty then\n      yield ( \"===== For ARDatamart Database =====\", fun _ -> \"---------------------\"  )\n  if bDims.Length  > 1 then yield bAllDims\n  yield! bDims\n  if not AllFactTables.IsEmpty then \n      yield ( \"------ Fact Tables -------\"         , fun _ -> \"---------------------\"  )\n      yield! bfact\n#if SQL_FETCH_FIELDS\n  if not bSuperVw.IsEmpty then\n      yield ( \"------ Super Views -------\"         , fun _ -> \"---------------------\"  )\n  yield! bSuperVw\n#endif                              \n]\n#else\n[]\n#endif\n|> (fun l -> if l.IsEmpty then [ \"=== Select in F# some Views and/or Dimensions ===\", fun _ -> \"Nothing selected\" ]  else l)\n|> Useful.ActionBar\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"}],"id":{"$":0,"Item":"daa2fd06-2419-40bf-a9af-7f9863420fa5"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoComplete","content":"module FSAutoComplete =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"expanded":false,"level":0,"properties":{}},{"name":"Utils","content":"#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net40\\FSharp.Data.DesignTime.dll\"\n\nopen System.IO\nopen System.Collections.Concurrent\nopen System.Diagnostics\nopen System\n//#nowarn \"1182\"\n#nowarn \"1178\"\n#nowarn \"52\"\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Utils =\n    \n    type Result<'a> =\n      | Success of 'a\n      | Failure of string\n    \n    type Pos =\n        { Line: int\n          Col: int }\n    \n    type Range =\n        { StartLine : int\n          StartColumn : int\n          EndLine : int\n          EndColumn: int}\n    \n    type Document =\n        { FullName : string\n          LineCount : int\n          GetText : unit -> string\n          GetLineText0 : int -> string\n          GetLineText1 : int -> string}\n    \n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"id":{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"},"expanded":true,"level":0,"properties":{}},{"name":"Utils2","content":"    [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\n    module Pos =\n        let make line column = { Line = line; Col = column }\n    \n    \n    type Serializer = obj -> string\n    type ProjectFilePath = string\n    type SourceFilePath = string\n    type LineStr = string\n    \n    let isAScript fileName =\n        let ext = Path.GetExtension fileName\n        [\".fsx\";\".fsscript\";\".sketchfs\"] |> List.exists ((=) ext)\n    \n    let runningOnMono =\n      try not << isNull <| Type.GetType \"Mono.Runtime\"\n      with _ -> false\n    \n    let normalizePath (file : string) =\n      if file.EndsWith \".fs\" || file.EndsWith \".fsi\" then\n          let p = Path.GetFullPath file\n          (p.Chars 0).ToString().ToLower() + p.Substring(1)\n      else file\n    \n    let inline combinePaths path1 (path2 : string) = Path.Combine(path1, path2.TrimStart [| '\\\\'; '/' |])\n    \n    let inline (</>) path1 path2 = combinePaths path1 path2\n    \n    let private sepChar = Path.DirectorySeparatorChar\n    \n    let normalizeDirSeparators (path: string) =\n      match sepChar with\n      | '\\\\' -> path.Replace('/', '\\\\')\n      | '/' -> path.Replace('\\\\', '/')\n      | _ -> path\n      \nopen Utils      \n    \n[<RequireQualifiedAccess>]\nmodule Option =\n\n  let inline attempt (f: unit -> 'T) = try Some <| f() with _ -> None\n\n  let getOrElse defaultValue option =\n    match option with\n    | None -> defaultValue\n    | Some x -> x\n\n  /// Gets the option if Some x, otherwise the supplied default value.\n  let inline orElseX v option =\n    match option with\n    | Some x -> Some x\n    | None -> v\n\n\n  let orElseFun other option =\n    match option with\n    | None -> other()\n    | Some x -> Some x\n\n  let getOrElseFun defaultValue option =\n    match option with\n    | None -> defaultValue()\n    | Some x -> x\n\n  let inline orTry f =\n    function\n    | Some x -> Some x\n    | None -> f()\n\n  /// Some(Some x) -> Some x | None -> None\n  let inline flatten x =\n    match x with\n    | Some x -> x\n    | None -> None\n\n\n[<RequireQualifiedAccess>]\nmodule Async =\n    /// Transforms an Async value using the specified function.\n    [<CompiledName(\"Map\")>]\n    let map (mapping : 'a -> 'b) (value : Async<'a>) : Async<'b> =\n        async {\n            // Get the input value.\n            let! x = value\n            // Apply the mapping function and return the result.\n            return mapping x\n        }\n\n    // Transforms an Async value using the specified Async function.\n    [<CompiledName(\"Bind\")>]\n    let bind (binding : 'a -> Async<'b>) (value : Async<'a>) : Async<'b> =\n        async {\n            // Get the input value.\n            let! x = value\n            // Apply the binding function and return the result.\n            return! binding x\n        }\n\n[<Sealed>]\ntype AsyncMaybeBuilder () =\n    [<DebuggerStepThrough>]\n    member __.Return value : Async<'T option> = Some value |> async.Return\n\n    [<DebuggerStepThrough>]\n    member __.ReturnFrom value : Async<'T option> = value\n\n    [<DebuggerStepThrough>]\n    member __.ReturnFrom (value: 'T option) : Async<'T option> = async.Return value\n\n    [<DebuggerStepThrough>]\n    member __.Zero () : Async<unit option> =\n        Some () |> async.Return\n\n    [<DebuggerStepThrough>]\n    member __.Delay (f : unit -> Async<'T option>) : Async<'T option> = f ()\n\n    [<DebuggerStepThrough>]\n    member __.Combine (r1, r2 : Async<'T option>) : Async<'T option> =\n        async {\n            let! r1' = r1\n            match r1' with\n            | None -> return None\n            | Some () -> return! r2\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Bind (value: Async<'T option>, f : 'T -> Async<'U option>) : Async<'U option> =\n        async {\n            let! value' = value\n            match value' with\n            | None -> return None\n            | Some result -> return! f result\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Bind (value: 'T option, f : 'T -> Async<'U option>) : Async<'U option> =\n        async {\n            match value with\n            | None -> return None\n            | Some result -> return! f result\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Using (resource : ('T :> IDisposable), body : _ -> Async<_ option>) : Async<_ option> =\n        try body resource\n        finally\n            if not << isNull <| resource then resource.Dispose ()\n\n    [<DebuggerStepThrough>]\n    member x.While (guard, body : Async<_ option>) : Async<_ option> =\n        if guard () then\n            x.Bind (body, (fun () -> x.While (guard, body)))\n        else\n            x.Zero ()\n\n    [<DebuggerStepThrough>]\n    member x.For (sequence : seq<_>, body : 'T -> Async<unit option>) : Async<_ option> =\n        x.Using (sequence.GetEnumerator (), fun enum ->\n            x.While (enum.MoveNext, x.Delay (fun () -> body enum.Current)))\n\n    [<DebuggerStepThrough>]\n    member inline __.TryWith (computation : Async<'T option>, catchHandler : exn -> Async<'T option>) : Async<'T option> =\n            async.TryWith (computation, catchHandler)\n\n    [<DebuggerStepThrough>]\n    member inline __.TryFinally (computation : Async<'T option>, compensation : unit -> unit) : Async<'T option> =\n            async.TryFinally (computation, compensation)\n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule AsyncMaybe =\n    let inline liftAsync (async : Async<'T>) : Async<_ option> =\n        async |> Async.map Some\n\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Array =\n    let inline private checkNonNull argName arg =\n        match box arg with\n        | null -> nullArg argName\n        | _ -> ()\n\n    /// Optimized arrays equality. ~100x faster than `array1 = array2` on strings.\n    /// ~2x faster for floats\n    /// ~0.8x slower for ints\n    let inline areEqual (xs: 'T []) (ys: 'T []) =\n        match xs, ys with\n        | null, null -> true\n        | [||], [||] -> true\n        | null, _ | _, null -> false\n        | _ when xs.Length <> ys.Length -> false\n        | _ ->\n            let mutable break' = false\n            let mutable i = 0\n            let mutable result = true\n            while i < xs.Length && not break' do\n                if xs.[i] <> ys.[i] then\n                    break' <- true\n                    result <- false\n                i <- i + 1\n            result\n\n\n    /// Fold over the array passing the index and element at that index to a folding function\n    let foldi (folder: 'State -> int -> 'T -> 'State) (state: 'State) (array: 'T []) =\n        checkNonNull \"array\" array\n        if array.Length = 0 then state else\n        let folder = OptimizedClosures.FSharpFunc<_,_,_,_>.Adapt folder\n        let mutable state:'State = state\n        let len = array.Length\n        for i = 0 to len - 1 do\n            state <- folder.Invoke (state, i, array.[i])\n        state\n\n    /// Returns all heads of a given array.\n    /// For [|1;2;3|] it returns [|[|1; 2; 3|]; [|1; 2|]; [|1|]|]\n    let heads (array: 'T []) =\n        checkNonNull \"array\" array\n        let res = Array.zeroCreate<'T[]> array.Length\n        for i = array.Length - 1 downto 0 do\n            res.[i] <- array.[0..i]\n        res\n\n    /// check if subArray is found in the wholeArray starting\n    /// at the provided index\n    let inline isSubArray (subArray: 'T []) (wholeArray:'T []) index =\n        if isNull subArray || isNull wholeArray then false\n        elif subArray.Length = 0 then true\n        elif subArray.Length > wholeArray.Length then false\n        elif subArray.Length = wholeArray.Length then areEqual subArray wholeArray else\n        let rec loop subidx idx =\n            if subidx = subArray.Length then true\n            elif subArray.[subidx] = wholeArray.[idx] then loop (subidx+1) (idx+1)\n            else false\n        loop 0 index\n\n    /// Returns true if one array has another as its subset from index 0.\n    let startsWith (prefix: _ []) (whole: _ []) =\n        isSubArray prefix whole 0\n\n    /// Returns true if one array has trailing elements equal to another's.\n    let endsWith (suffix: _ []) (whole: _ []) =\n        isSubArray suffix whole (whole.Length-suffix.Length)\n\n    /// Returns a new array with an element replaced with a given value.\n    let replace index value (array: _ []) =\n        checkNonNull \"array\" array\n        if index >= array.Length then raise (IndexOutOfRangeException \"index\")\n        let res = Array.copy array\n        res.[index] <- value\n        res\n\n    /// pass an array byref to reverse it in place\n    let revInPlace (array: 'T []) =\n        checkNonNull \"array\" array\n        if areEqual array [||] then () else\n        let arrlen, revlen = array.Length-1, array.Length/2 - 1\n        for idx in 0 .. revlen do\n            let t1 = array.[idx]\n            let t2 = array.[arrlen-idx]\n            array.[idx] <- t2\n            array.[arrlen-idx] <- t1\n\n\n\n\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule String =\n    let inline toCharArray (str:string) = str.ToCharArray()\n\n    let lowerCaseFirstChar (str: string) =\n        if String.IsNullOrEmpty str\n         || Char.IsLower(str, 0) then str else\n        let strArr = toCharArray str\n        match Array.tryHead strArr with\n        | None -> str\n        | Some c  ->\n            strArr.[0] <- Char.ToLower c\n            String (strArr)\n\n\n    let extractTrailingIndex (str: string) =\n        match str with\n        | null -> null, None\n        | _ ->\n            let charr = str.ToCharArray()\n            Array.revInPlace charr\n            let digits = Array.takeWhile Char.IsDigit charr\n            Array.revInPlace digits\n            String digits\n            |> function\n               | \"\" -> str, None\n               | index -> str.Substring (0, str.Length - index.Length), Some (int index)\n\n\n    let (|StartsWith|_|) pattern value =\n        if String.IsNullOrWhiteSpace value then\n            None\n        elif value.StartsWith pattern then\n            Some()\n        else None\n\n\n\ntype ConcurrentDictionary<'key, 'value> with\n    member x.TryFind key =\n        match x.TryGetValue key with\n        | true, value -> Some value\n        | _ -> None\n\n    member x.ToSeq() =\n        x |> Seq.map (fun (KeyValue(k, v)) -> k, v)\n\ntype Path with\n    static member GetFullPathSafe path =\n        try Path.GetFullPath path\n        with _ -> path\n\n    static member GetFileNameSafe path =\n        try Path.GetFileName path\n        with _ -> path\n\n\n\nlet inline debug msg = Printf.kprintf Debug.WriteLine msg\nlet inline fail msg = Printf.kprintf Debug.Fail msg\nlet asyncMaybe = AsyncMaybeBuilder()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"id":{"$":0,"Item":"ad03c7ec-8dd8-4ed9-8e69-cfb36e93ddd3"},"expanded":true,"level":0,"properties":{}},{"name":"Lexer","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype SymbolKind =\n    | Ident\n    | Operator\n    | GenericTypeParameter\n    | StaticallyResolvedTypeParameter\n    | ActivePattern\n    | Keyword\n    | Other\n\ntype LexerSymbol =\n    { Kind: SymbolKind\n      Line: int\n      LeftColumn: int\n      RightColumn: int\n      Text: string }\n\n[<RequireQualifiedAccess>]\ntype SymbolLookupKind =\n    | Fuzzy\n    | ByRightColumn\n    | ByLongIdent\n    | Simple\n\ntype private DraftToken =\n    { Kind: SymbolKind\n      Token: FSharpTokenInfo\n      RightColumn: int }\n    static member inline Create kind token =\n        { Kind = kind; Token = token; RightColumn = token.LeftColumn + token.FullMatchedLength - 1 }\n\nmodule Lexer =\n    /// Return all tokens of current line\n    let tokenizeLine (args: string[]) lineStr =\n        let defines =\n            args |> Seq.choose (fun s -> if s.StartsWith \"--define:\" then Some s.[9..] else None)\n                 |> Seq.toList\n        let sourceTokenizer = FSharpSourceTokenizer(defines, Some \"/tmp.fsx\")\n        let lineTokenizer = sourceTokenizer.CreateLineTokenizer lineStr\n        let rec loop lexState acc =\n            match lineTokenizer.ScanToken lexState with\n            | Some tok, state -> loop state (tok :: acc)\n            | _ -> List.rev acc\n        loop 0L []\n\n    let inline private isIdentifier t = t.CharClass = FSharpTokenCharKind.Identifier\n    let inline private isOperator t = t.ColorClass = FSharpTokenColorKind.Operator\n    let inline private isKeyword t = t.ColorClass = FSharpTokenColorKind.Keyword\n\n    let inline private (|GenericTypeParameterPrefix|StaticallyResolvedTypeParameterPrefix|ActivePattern|Other|) ((token: FSharpTokenInfo), (lineStr:string)) =\n        if token.Tag = FSharpTokenTag.QUOTE then GenericTypeParameterPrefix\n        elif token.Tag = FSharpTokenTag.INFIX_AT_HAT_OP then\n             // The lexer return INFIX_AT_HAT_OP token for both \"^\" and \"@\" symbols.\n             // We have to check the char itself to distinguish one from another.\n             if token.FullMatchedLength = 1 && lineStr.[token.LeftColumn] = '^' then\n                StaticallyResolvedTypeParameterPrefix\n             else Other\n        elif token.Tag = FSharpTokenTag.LPAREN then\n            if token.FullMatchedLength = 1 && lineStr.[token.LeftColumn+1] = '|' then\n               ActivePattern\n            else Other\n        else Other\n\n    // Operators: Filter out overlapped operators (>>= operator is tokenized as three distinct tokens: GREATER, GREATER, EQUALS.\n    // Each of them has FullMatchedLength = 3. So, we take the first GREATER and skip the other two).\n    //\n    // Generic type parameters: we convert QUOTE + IDENT tokens into single IDENT token, altering its LeftColumn\n    // and FullMathedLength (for \"'type\" which is tokenized as (QUOTE, left=2) + (IDENT, left=3, length=4)\n    // we'll get (IDENT, left=2, length=5).\n    //\n    // Statically resolved type parameters: we convert INFIX_AT_HAT_OP + IDENT tokens into single IDENT token, altering its LeftColumn\n    // and FullMathedLength (for \"^type\" which is tokenized as (INFIX_AT_HAT_OP, left=2) + (IDENT, left=3, length=4)\n    // we'll get (IDENT, left=2, length=5).\n    let private fixTokens lineStr (tokens : FSharpTokenInfo list) =\n        tokens\n        |> List.fold (fun (acc, lastToken) token ->\n            match lastToken with\n            | Some t when token.LeftColumn <= t.RightColumn ->\n                acc, lastToken\n            | Some ( {Kind = SymbolKind.ActivePattern} as lastToken) when token.Tag = FSharpTokenTag.BAR || token.Tag = FSharpTokenTag.IDENT || token.Tag = FSharpTokenTag.UNDERSCORE ->\n                let mergedToken =\n                    {lastToken.Token with Tag = FSharpTokenTag.IDENT\n                                                RightColumn = token.RightColumn\n                                                FullMatchedLength = lastToken.Token.FullMatchedLength + token.FullMatchedLength }\n\n                acc, Some { lastToken with Token = mergedToken; RightColumn = lastToken.RightColumn + token.FullMatchedLength }\n            | _ ->\n                match token, lineStr with\n                | GenericTypeParameterPrefix -> acc, Some (DraftToken.Create GenericTypeParameter token)\n                | StaticallyResolvedTypeParameterPrefix -> acc, Some (DraftToken.Create StaticallyResolvedTypeParameter token)\n                | ActivePattern -> acc, Some (DraftToken.Create ActivePattern token)\n                | Other ->\n                    let draftToken =\n                        match lastToken with\n                        | Some { Kind = GenericTypeParameter | StaticallyResolvedTypeParameter as kind } when isIdentifier token ->\n                              DraftToken.Create kind { token with LeftColumn = token.LeftColumn - 1\n                                                                  FullMatchedLength = token.FullMatchedLength + 1 }\n                        | Some ( { Kind = SymbolKind.ActivePattern } as ap) when token.Tag = FSharpTokenTag.RPAREN ->\n                              DraftToken.Create SymbolKind.Ident ap.Token\n                        | _ ->\n                            let kind =\n                                if isOperator token then Operator\n                                elif isIdentifier token then Ident\n                                elif isKeyword token then Keyword\n                                else Other\n                            DraftToken.Create kind token\n                    draftToken :: acc, Some draftToken\n            ) ([], None)\n        |> fst\n\n    // Returns symbol at a given position.\n    let private getSymbolFromTokens (tokens: FSharpTokenInfo list) line col (lineStr: string) lookupKind: LexerSymbol option =\n        let tokens = fixTokens lineStr tokens\n\n        // One or two tokens that in touch with the cursor (for \"let x|(g) = ()\" the tokens will be \"x\" and \"(\")\n        let tokensUnderCursor =\n            match lookupKind with\n            | SymbolLookupKind.Simple | SymbolLookupKind.Fuzzy ->\n                tokens |> List.filter (fun x -> x.Token.LeftColumn <= col && x.RightColumn + 1 >= col)\n            | SymbolLookupKind.ByRightColumn ->\n                tokens |> List.filter (fun x -> x.RightColumn = col)\n            | SymbolLookupKind.ByLongIdent ->\n                tokens |> List.filter (fun x -> x.Token.LeftColumn <= col)\n\n        //printfn \"Filtered tokens: %+A\" tokensUnderCursor\n        match lookupKind with\n        | SymbolLookupKind.ByLongIdent ->\n            // Try to find start column of the long identifiers\n            // Assume that tokens are ordered in an decreasing order of start columns\n            let rec tryFindStartColumn tokens =\n               match tokens with\n               | {Kind = Ident; Token = t1} :: {Kind = Operator; Token = t2} :: remainingTokens ->\n                    if t2.Tag = FSharpTokenTag.DOT then\n                        tryFindStartColumn remainingTokens\n                    else\n                        Some t1.LeftColumn\n               | {Kind = Ident; Token = t} :: _ ->\n                   Some t.LeftColumn\n               | _ :: _ | [] ->\n                   None\n            let decreasingTokens =\n                match tokensUnderCursor |> List.sortBy (fun token -> - token.Token.LeftColumn) with\n                // Skip the first dot if it is the start of the identifier\n                | {Kind = Operator; Token = t} :: remainingTokens when t.Tag = FSharpTokenTag.DOT ->\n                    remainingTokens\n                | newTokens -> newTokens\n\n            match decreasingTokens with\n            | [] -> None\n            | first :: _ ->\n                tryFindStartColumn decreasingTokens\n                |> Option.map (fun leftCol ->\n                    { Kind = Ident\n                      Line = line\n                      LeftColumn = leftCol\n                      RightColumn = first.RightColumn + 1\n                      Text = lineStr.[leftCol..first.RightColumn] })\n        | SymbolLookupKind.Fuzzy\n        | SymbolLookupKind.ByRightColumn ->\n            // Select IDENT token. If failed, select OPERATOR token.\n            tokensUnderCursor\n            |> List.tryFind (fun { DraftToken.Kind = k } ->\n                match k with\n                | Ident | GenericTypeParameter | StaticallyResolvedTypeParameter | Keyword -> true\n                | _ -> false)\n                /// Gets the option if Some x, otherwise try to get another value\n\n            |> Option.orTry (fun _ -> tokensUnderCursor |> List.tryFind (fun { DraftToken.Kind = k } -> k = Operator))\n            |> Option.map (fun token ->\n                { Kind = token.Kind\n                  Line = line\n                  LeftColumn = token.Token.LeftColumn\n                  RightColumn = token.RightColumn + 1\n                  Text = lineStr.Substring(token.Token.LeftColumn, token.Token.FullMatchedLength) })\n        | SymbolLookupKind.Simple ->\n            tokensUnderCursor\n            |> List.tryLast\n            |> Option.map (fun token ->\n                { Kind = token.Kind\n                  Line = line\n                  LeftColumn = token.Token.LeftColumn\n                  RightColumn = token.RightColumn + 1\n                  Text = lineStr.Substring(token.Token.LeftColumn, token.Token.FullMatchedLength) })\n\n    let getSymbol line col lineStr lookupKind (args: string[]) =\n        let tokens = tokenizeLine args lineStr\n        try\n            getSymbolFromTokens tokens line col lineStr lookupKind\n        with _ ->\n            //LoggingService.LogInfo (sprintf \"Getting lex symbols failed with %O\" e)\n            None","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"08e0d335-e0a3-48e0-af14-d57d98247feb"},"expanded":true,"level":0,"properties":{}},{"name":"Parser","content":"open System\nopen Microsoft.FSharp.Compiler\n\n// --------------------------------------------------------------------------------------\n// Simple implementation of LazyList\n// --------------------------------------------------------------------------------------\n\n#nowarn \"21\"\n\ntype private LazyList<'T> =\n  | Nil\n  | Cons of 'T * Lazy<LazyList<'T>>\n\nmodule private LazyList =\n  let ofSeq (s:seq<'T>) =\n    let en = s.GetEnumerator()\n    let rec take() =\n      if en.MoveNext() then\n        Cons(en.Current, lazy take())\n      else\n        en.Dispose()\n        Nil\n    take()\n\nmodule Parser =\n  open System\n\n  /// Add some useful methods for creating strings from sequences\n  type String with\n    static member OfSeq chars = chars |> Seq.toArray |> String\n    static member OfReversedSeq chars = chars |> Seq.toArray |> Array.rev |> String\n\n  /// Parser is implemented using lazy list (so that we can use seq<_>)\n  type Parser<'T> = private P of (LazyList<char> -> ('T * LazyList<char>) list)\n\n  // Basic functions needed by the computation builder\n\n  let result v = P (fun c -> [v, c])\n  let zero () = P (fun _ -> [])\n  \n  let bind (P p) f = P (fun inp ->\n    [ for (pr, inp') in p inp do\n        let (P pars) = f pr\n        yield! pars inp' ])\n  \n  let plus (P p) (P q) = P (fun inp ->\n    (p inp) @ (q inp) )\n\n  let (<|>) p1 p2 = plus p1 p2\n\n  type ParserBuilder() =\n    member __.Bind(v, f) = bind v f\n    member __.Zero() = zero()\n    member __.Return(v) = result(v)\n    member __.ReturnFrom(p) = p\n    member __.Combine(a, b) = plus a b\n    member __.Delay(f) = f()\n\n  let parser = new ParserBuilder()\n\n  // --------------------------------------------------------------------------------------\n  // Basic combinators for composing parsers\n\n  let item = P(function | LazyList.Nil -> [] | LazyList.Cons(c, r) -> [c,r.Value])\n\n  let sat p = parser {\n    let! v = item\n    if (p v) then return v }\n\n  let char x = sat ((=) x)\n  let digit = sat Char.IsDigit\n  let letter = sat Char.IsLetter\n  let whitespace = sat (Char.IsWhiteSpace)\n\n  let rec word = parser {\n    return []\n    return! parser {\n      let! x = letter\n      let! xs = word\n      return x::xs } }\n\n  let string (str:string) =\n    let chars = str.ToCharArray() |> List.ofSeq\n    let rec string' = function\n      | [] -> result []\n      | x::xs -> parser {\n          let! y = char x\n          let! ys = string' xs\n          return y::ys }\n    string' chars\n\n  let rec many p = parser {\n    return! parser {\n      let! it = p\n      let! res = many p\n      return it::res }\n    return [] }\n\n  let rec some p = parser {\n    let! first = p\n    let! rest = many p\n    return first::rest }\n\n  let rec map f p = parser {\n    let! v = p\n    return f v }\n\n  let optional p = parser {\n    return! parser { let! v = p in return Some v }\n    return None }\n\n  let apply (P p) (str:seq<char>) =\n    let res = str |> LazyList.ofSeq |> p\n    res |> List.map fst\n\n// --------------------------------------------------------------------------------------\n/// Parsing utilities for IntelliSense (e.g. parse identifier on the left-hand side\n/// of the current cursor location etc.)\nmodule Parsing =\n  open Parser\n\n  module Legacy =\n    let inline isFirstOpChar ch =\n        ch = '!' || ch = '%'|| ch = '&' || ch = '*'|| ch = '+'|| ch = '-'|| ch = '.'|| ch = '/'|| ch = '<'|| ch = '='|| ch = '>'|| ch = '@'|| ch = '^'|| ch = '|'|| ch = '~'\n  \n    let isOpChar ch = ch = '?' || isFirstOpChar ch\n\n    let parseBackSymOpFragment = parser {\n      // This is unfortunate, but otherwise cracking at $ in A.$B\n      // causes the backward parse to return a symbol fragment.\n      let! c  = sat (fun c -> c <> '.' && isOpChar c)\n      let! cs = many (sat isOpChar)\n      return String.OfReversedSeq (c::cs)\n      }\n\n    /// Parses F# short-identifier (i.e. not including '.'); also ignores active patterns\n    // let parseIdent =\n    //   parseActivePatternEnd <|> parseSymOpFragment <|> many fsharpIdentCharacter\n    //    |> map String.ofSeq\n    let fsharpIdentCharacter = sat PrettyNaming.IsIdentifierPartCharacter\n\n    let rawIdChar = sat (fun c -> c <> '\\n' && c <> '\\t' && c <> '\\r' && c <> '`')\n\n    /// Parse F# short-identifier and reverse the resulting string\n    let parseBackIdent =\n      parser {\n          let! x = optional (string \"``\")\n          let! res = many (if x.IsSome then rawIdChar else fsharpIdentCharacter) |> map String.OfReversedSeq\n          let! _ = optional (string \"``\")\n          return res }\n\n    /// Parse remainder of a long identifier before '.' (e.g. \"Name.space.\")\n    /// (designed to look backwards - reverses the results after parsing)\n    let rec parseBackLongIdentRest = parser {\n      return! parser {\n        let! _ = char '.'\n        let! ident = parseBackIdent\n        let! rest = parseBackLongIdentRest\n        return ident::rest }\n      return [] }\n\n    let parseBackLongIdent = parser {\n      return! parser {\n        let! ident = parseBackSymOpFragment <|> parseBackIdent\n        let! rest = parseBackLongIdentRest\n        return ident::rest |> List.rev }\n      return [] }\n\n    let parseBackTriggerThenLongIdent = parser {\n      let! _ = char '(' <|> char '<'\n      let! _  = many whitespace\n      return! parseBackLongIdent\n      }\n\n  /// Create sequence that reads the string backwards\n  let createBackStringReader (str:string) from = seq {\n    for i in (min from (str.Length - 1)) .. -1 .. 0 do yield str.[i] }\n\n  /// Create sequence that reads the string forwards\n  let createForwardStringReader (str:string) from = seq {\n    for i in (max 0 from) .. (str.Length - 1) do yield str.[i] }\n\n  /// Returns first result returned by the parser\n  let getFirst p s = apply p s |> List.head\n  let tryGetFirst p s = match apply p s with h::_ -> Some h | [] -> None\n\n  let inline private tryGetLexerSymbolIslands sym =\n      match sym.Text with \n      | \"\" -> None \n      | _ -> Some (sym.RightColumn, sym.Text.Split '.' |> Array.toList)\n\n  // Parsing - find the identifier around the current location\n  // (we look for full identifier in the backward direction, but only\n  // for a short identifier forward - this means that when you hover\n  // 'B' in 'A.B.C', you will get intellisense for 'A.B' module)\n  let findIdents col lineStr lookupType =\n      if lineStr = \"\" then None\n      else\n          Lexer.getSymbol 0 col lineStr lookupType [||]\n          |> Option.bind tryGetLexerSymbolIslands\n\n  let findLongIdents (col, lineStr) =\n    findIdents col lineStr SymbolLookupKind.Fuzzy\n\n  let findLongIdentsAndResidue (col, lineStr:string) =\n      let lineStr = lineStr.Substring(0, col)\n\n      match Lexer.getSymbol 0 col lineStr SymbolLookupKind.ByLongIdent [||] with\n      | Some sym ->\n          match sym.Text with\n          | \"\" -> [], \"\"\n          | text ->\n              let res = text.Split '.' |> List.ofArray |> List.rev\n              if lineStr.[col - 1] = '.' then res |> List.rev, \"\"\n              else\n                  match res with\n                  | head :: tail -> tail |> List.rev, head\n                  | [] -> [], \"\"\n      | _ -> [], \"\"\n\n  /// find the identifier prior to a '(' or ',' once the method tip trigger '(' shows\n  let findLongIdentsAtGetMethodsTrigger (col, lineStr) =\n    let lookBack = createBackStringReader lineStr col\n    let backIdentOpt = tryGetFirst Legacy.parseBackTriggerThenLongIdent lookBack\n    match backIdentOpt with\n    | None -> None\n    | Some backIdent ->\n\n    let identIsland =\n      match List.rev backIdent with\n      | last::prev -> (last::prev |> List.rev)\n      | [] -> []\n\n    match identIsland with\n    | [] | [ \"\" ] -> None\n    | _ -> Some identIsland","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"08e0d335-e0a3-48e0-af14-d57d98247feb"}],"id":{"$":0,"Item":"a6ffc34e-45f1-4732-a3e7-7de501ad478e"},"expanded":true,"level":0,"properties":{}},{"name":"KeywordList","content":"module internal KeywordList =\n    let private modifiers =\n        Map.ofList [\n            \"abstract\",  \"\"\"Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.\"\"\"\n            \"inline\",  \"\"\"Used to indicate a function that should be integrated directly into the caller's code.\"\"\"\n            \"mutable\",  \"\"\"Used to declare a variable, that is, a value that can be changed.\"\"\"\n            \"private\",  \"\"\"Restricts access to a member to code in the same type or module.\"\"\"\n            \"public\",  \"\"\"Allows access to a member from outside the type.\"\"\"\n        ]\n\n    let private keywordDescriptions =\n        Map.ofList [\n            \"abstract\",  \"\"\"Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.\"\"\"\n            \"and\",  \"\"\"Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.\"\"\"\n            \"as\",  \"\"\"Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.\"\"\"\n            \"assert\",  \"\"\"Used to verify code during debugging.\"\"\"\n            \"base\",  \"\"\"Used as the name of the base class object.\"\"\"\n            \"begin\",  \"\"\"In verbose syntax, indicates the start of a code block.\"\"\"\n            \"class\",  \"\"\"In verbose syntax, indicates the start of a class definition.\"\"\"\n            \"default\",  \"\"\"Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.\"\"\"\n            \"delegate\",  \"\"\"Used to declare a delegate.\"\"\"\n            \"do\",  \"\"\"Used in looping constructs or to execute imperative code.\"\"\"\n            \"done\",  \"\"\"In verbose syntax, indicates the end of a block of code in a looping expression.\"\"\"\n            \"downcast\",  \"\"\"Used to convert to a type that is lower in the inheritance chain.\"\"\"\n            \"downto\",  \"\"\"In a for expression, used when counting in reverse.\"\"\"\n            \"elif\",  \"\"\"Used in conditional branching. A short form of else if.\"\"\"\n            \"else\",  \"\"\"Used in conditional branching.\"\"\"\n            \"end\",  \"\"\"In type definitions and type extensions, indicates the end of a section of member definitions.\nIn verbose syntax, used to specify the end of a code block that starts with the begin keyword.\"\"\"\n            \"exception\",  \"\"\"Used to declare an exception type.\"\"\"\n            \"extern\",  \"\"\"Indicates that a declared program element is defined in another binary or assembly.\"\"\"\n            \"false\",  \"\"\"Used as a Boolean literal.\"\"\"\n            \"finally\",  \"\"\"Used together with try to introduce a block of code that executes regardless of whether an exception occurs.\"\"\"\n            \"for\",  \"\"\"Used in looping constructs.\"\"\"\n            \"fun\",  \"\"\"Used in lambda expressions, also known as anonymous functions.\"\"\"\n            \"function\",  \"\"\"Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.\"\"\"\n            \"global\",  \"\"\"Used to reference the top-level .NET namespace.\"\"\"\n            \"if\",  \"\"\"Used in conditional branching constructs.\"\"\"\n            \"in\",  \"\"\"Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.\"\"\"\n            \"inherit\",  \"\"\"Used to specify a base class or base interface.\"\"\"\n            \"inline\",  \"\"\"Used to indicate a function that should be integrated directly into the caller's code.\"\"\"\n            \"interface\",  \"\"\"Used to declare and implement interfaces.\"\"\"\n            \"internal\",  \"\"\"Used to specify that a member is visible inside an assembly but not outside it.\"\"\"\n            \"lazy\",  \"\"\"Used to specify a computation that is to be performed only when a result is needed.\"\"\"\n            \"let\",  \"\"\"Used to associate, or bind, a name to a value or function.\"\"\"\n            \"let!\",  \"\"\"Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.\"\"\"\n            \"match\",  \"\"\"Used to branch by comparing a value to a pattern.\"\"\"\n            \"member\",  \"\"\"Used to declare a property or method in an object type.\"\"\"\n            \"module\",  \"\"\"Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.\"\"\"\n            \"mutable\",  \"\"\"Used to declare a variable, that is, a value that can be changed.\"\"\"\n            \"namespace\",  \"\"\"Used to associate a name with a group of related types and modules, to logically separate it from other code.\"\"\"\n            \"new\",  \"\"\"Used to declare, define, or invoke a constructor that creates or that can create an object.\nAlso used in generic parameter constraints to indicate that a type must have a certain constructor.\"\"\"\n            \"not\",  \"\"\"Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.\"\"\"\n            \"null\",  \"\"\"Indicates the absence of an object.\nAlso used in generic parameter constraints.\"\"\"\n            \"of\",  \"\"\"Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.\"\"\"\n            \"open\",  \"\"\"Used to make the contents of a namespace or module available without qualification.\"\"\"\n            \"or\",  \"\"\"Used with Boolean conditions as a Boolean or operator. Equivalent to ||.\nAlso used in member constraints.\"\"\"\n            \"override\",  \"\"\"Used to implement a version of an abstract or virtual method that differs from the base version.\"\"\"\n            \"private\",  \"\"\"Restricts access to a member to code in the same type or module.\"\"\"\n            \"public\",  \"\"\"Allows access to a member from outside the type.\"\"\"\n            \"rec\",  \"\"\"Used to indicate that a function is recursive.\"\"\"\n            \"return\",  \"\"\"Used to indicate a value to provide as the result of a computation expression.\"\"\"\n            \"return!\",  \"\"\"Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.\"\"\"\n            \"select\",  \"\"\"Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.\"\"\"\n            \"static\",  \"\"\"Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.\"\"\"\n            \"struct\",  \"\"\"Used to declare a structure type.\nAlso used in generic parameter constraints.\nUsed for OCaml compatibility in module definitions.\"\"\"\n            \"then\",  \"\"\"Used in conditional expressions.\nAlso used to perform side effects after object construction.\"\"\"\n            \"to\",  \"\"\"Used in for loops to indicate a range.\"\"\"\n            \"true\",  \"\"\"Used as a Boolean literal.\"\"\"\n            \"try\",  \"\"\"Used to introduce a block of code that might generate an exception. Used together with with or finally.\"\"\"\n            \"type\",  \"\"\"Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.\"\"\"\n            \"upcast\",  \"\"\"Used to convert to a type that is higher in the inheritance chain.\"\"\"\n            \"use\",  \"\"\"Used instead of let for values that require Dispose to be called to free resources.\"\"\"\n            \"use!\",  \"\"\"Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.\"\"\"\n            \"val\",  \"\"\"Used in a signature to indicate a value, or in a type to declare a member, in limited situations.\"\"\"\n            \"void\",  \"\"\"Indicates the .NET void type. Used when interoperating with other .NET languages.\"\"\"\n            \"when\",  \"\"\"Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.\"\"\"\n            \"while\",  \"\"\"Introduces a looping construct.\"\"\"\n            \"with\",  \"\"\"Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.\"\"\"\n            \"yield\",  \"\"\"Used in a sequence expression to produce a value for a sequence.\"\"\"\n            \"yield!\",  \"\"\"Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.\"\"\"\n            \"->\", \"\"\"In function types, delimits arguments and return values.\nYields an expression (in sequence expressions); equivalent to the yield keyword.\nUsed in match expressions\"\"\"\n            \"<-\", \"Assigns a value to a variable.\"\n            \":>\", \"Converts a type to type that is higher in the hierarchy.\"\n            \":?>\", \"Converts a type to a type that is lower in the hierarchy.\"\n            \"<@\", \"Delimits a typed code quotation.\"\n            \"@>\", \"Delimits a typed code quotation.\"\n            \"<@@\", \"Delimits a untyped code quotation.\"\n            \"@@>\", \"Delimits a untyped code quotation.\"]\n\n    let tryGetKeywordDescription (keyword: string) =\n        keywordDescriptions |> Map.tryFind keyword\n        |> Option.orElseFun (fun _ -> modifiers |> Map.tryFind keyword)\n\n    let allKeywords : string list =\n        [ yield! modifiers |> Map.toSeq |> Seq.map fst\n          yield! keywordDescriptions |> Map.toSeq |> Seq.map fst ]","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"id":{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"},"expanded":true,"level":0,"properties":{}},{"name":"UntypedAstUtils","content":"open Microsoft.FSharp.Compiler.Ast\nopen System.Collections.Generic\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.Range\n\ntype Range.range with\n    member inline x.IsEmpty = x.StartColumn = x.EndColumn && x.StartLine = x.EndLine\n\ntype internal ShortIdent = string\ntype internal Idents = ShortIdent[]\n\nlet internal longIdentToArray (longIdent: LongIdent): Idents =\n    longIdent |> Seq.map string |> Seq.toArray\n\n    /// An recursive pattern that collect all sequential expressions to avoid StackOverflowException\nlet rec (|Sequentials|_|) = function\n    | SynExpr.Sequential(_, _, e, Sequentials es, _) ->\n        Some(e::es)\n    | SynExpr.Sequential(_, _, e1, e2, _) ->\n        Some [e1; e2]\n    | _ -> None\n\nlet (|ConstructorPats|) = function\n    | SynConstructorArgs.Pats ps -> ps\n    | SynConstructorArgs.NamePatPairs(xs, _) -> List.map snd xs\n\n/// Returns all Idents and LongIdents found in an untyped AST.\nlet internal getLongIdents (input: ParsedInput option) : IDictionary<Range.pos, Idents> =\n    let identsByEndPos = Dictionary<Range.pos, Idents>()\n\n    let addLongIdent (longIdent: LongIdent) =\n        let idents = longIdentToArray longIdent\n        for ident in longIdent do\n            identsByEndPos.[ident.idRange.End] <- idents\n\n    let addLongIdentWithDots (LongIdentWithDots (longIdent, lids) as value) =\n        match longIdentToArray longIdent with\n        | [||] -> ()\n        | [|_|] as idents -> identsByEndPos.[value.Range.End] <- idents\n        | idents ->\n            for dotRange in lids do\n                identsByEndPos.[Range.mkPos dotRange.EndLine (dotRange.EndColumn - 1)] <- idents\n            identsByEndPos.[value.Range.End] <- idents\n\n    let addIdent (ident: Ident) =\n        identsByEndPos.[ident.idRange.End] <- [|ident.idText|]\n\n    let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n        List.iter walkSynModuleOrNamespace moduleOrNamespaceList\n\n    and walkSynModuleOrNamespace (SynModuleOrNamespace(_, _, _, decls, _, attrs, _, _)) =\n        List.iter walkAttribute attrs\n        List.iter walkSynModuleDecl decls\n\n    and walkAttribute (attr: SynAttribute) =\n        addLongIdentWithDots attr.TypeName\n        walkExpr attr.ArgExpr\n\n    and walkTyparDecl (SynTyparDecl.TyparDecl (attrs, typar)) =\n        List.iter walkAttribute attrs\n        walkTypar typar\n\n    and walkTypeConstraint = function\n        | SynTypeConstraint.WhereTyparIsValueType (t, _)\n        | SynTypeConstraint.WhereTyparIsReferenceType (t, _)\n        | SynTypeConstraint.WhereTyparIsUnmanaged (t, _)\n        | SynTypeConstraint.WhereTyparSupportsNull (t, _)\n        | SynTypeConstraint.WhereTyparIsComparable (t, _)\n        | SynTypeConstraint.WhereTyparIsEquatable (t, _) -> walkTypar t\n        | SynTypeConstraint.WhereTyparDefaultsToType (t, ty, _)\n        | SynTypeConstraint.WhereTyparSubtypeOfType (t, ty, _) -> walkTypar t; walkType ty\n        | SynTypeConstraint.WhereTyparIsEnum (t, ts, _)\n        | SynTypeConstraint.WhereTyparIsDelegate (t, ts, _) -> walkTypar t; List.iter walkType ts\n        | SynTypeConstraint.WhereTyparSupportsMember (ts, sign, _) -> List.iter walkType ts; walkMemberSig sign\n\n    and walkPat = function\n        | SynPat.Tuple (pats, _)\n        | SynPat.ArrayOrList (_, pats, _)\n        | SynPat.Ands (pats, _) -> List.iter walkPat pats\n        | SynPat.Named (pat, ident, _, _, _) ->\n            walkPat pat\n            addIdent ident\n        | SynPat.Typed (pat, t, _) ->\n            walkPat pat\n            walkType t\n        | SynPat.Attrib (pat, attrs, _) ->\n            walkPat pat\n            List.iter walkAttribute attrs\n        | SynPat.Or (pat1, pat2, _) -> List.iter walkPat [pat1; pat2]\n        | SynPat.LongIdent (ident, _, typars, ConstructorPats pats, _, _) ->\n            addLongIdentWithDots ident\n            typars\n            |> Option.iter (fun (SynValTyparDecls (typars, _, constraints)) ->\n                 List.iter walkTyparDecl typars\n                 List.iter walkTypeConstraint constraints)\n            List.iter walkPat pats\n        | SynPat.Paren (pat, _) -> walkPat pat\n        | SynPat.IsInst (t, _) -> walkType t\n        | SynPat.QuoteExpr(e, _) -> walkExpr e\n        | _ -> ()\n\n    and walkTypar (Typar (_, _, _)) = ()\n\n    and walkBinding (SynBinding.Binding (_, _, _, _, attrs, _, _, pat, returnInfo, e, _, _)) =\n        List.iter walkAttribute attrs\n        walkPat pat\n        walkExpr e\n        returnInfo |> Option.iter (fun (SynBindingReturnInfo (t, _, _)) -> walkType t)\n\n    and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) = List.iter walkBinding bindings\n\n    and walkIndexerArg = function\n        | SynIndexerArg.One e -> walkExpr e\n        | SynIndexerArg.Two (e1, e2) -> List.iter walkExpr [e1; e2]\n\n    and walkType = function\n        | SynType.Array (_, t, _)\n        | SynType.HashConstraint (t, _)\n        | SynType.MeasurePower (t, _, _) -> walkType t\n        | SynType.Fun (t1, t2, _)\n        | SynType.MeasureDivide (t1, t2, _) -> walkType t1; walkType t2\n        | SynType.LongIdent ident -> addLongIdentWithDots ident\n        | SynType.App (ty, _, types, _, _, _, _) -> walkType ty; List.iter walkType types\n        | SynType.LongIdentApp (_, _, _, types, _, _, _) -> List.iter walkType types\n        | SynType.Tuple (ts, _) -> ts |> List.iter (fun (_, t) -> walkType t)\n        | SynType.WithGlobalConstraints (t, typeConstraints, _) ->\n            walkType t; List.iter walkTypeConstraint typeConstraints\n        | _ -> ()\n\n    and walkClause (Clause (pat, e1, e2, _, _)) =\n        walkPat pat\n        walkExpr e2\n        e1 |> Option.iter walkExpr\n\n    and walkSimplePats = function\n        | SynSimplePats.SimplePats (pats, _) -> List.iter walkSimplePat pats\n        | SynSimplePats.Typed (pats, ty, _) ->\n            walkSimplePats pats\n            walkType ty\n\n    and walkExpr = function\n        | SynExpr.Paren (e, _, _, _)\n        | SynExpr.Quote (_, _, e, _, _)\n        | SynExpr.Typed (e, _, _)\n        | SynExpr.InferredUpcast (e, _)\n        | SynExpr.InferredDowncast (e, _)\n        | SynExpr.AddressOf (_, e, _, _)\n        | SynExpr.DoBang (e, _)\n        | SynExpr.YieldOrReturn (_, e, _)\n        | SynExpr.ArrayOrListOfSeqExpr (_, e, _)\n        | SynExpr.CompExpr (_, _, e, _)\n        | SynExpr.Do (e, _)\n        | SynExpr.Assert (e, _)\n        | SynExpr.Lazy (e, _)\n        | SynExpr.YieldOrReturnFrom (_, e, _) -> walkExpr e\n        | SynExpr.Lambda (_, _, pats, e, _) ->\n            walkSimplePats pats\n            walkExpr e\n        | SynExpr.New (_, t, e, _)\n        | SynExpr.TypeTest (e, t, _)\n        | SynExpr.Upcast (e, t, _)\n        | SynExpr.Downcast (e, t, _) -> walkExpr e; walkType t\n        | SynExpr.Tuple (es, _, _)\n        | Sequentials es\n        | SynExpr.ArrayOrList (_, es, _) -> List.iter walkExpr es\n        | SynExpr.App (_, _, e1, e2, _)\n        | SynExpr.TryFinally (e1, e2, _, _, _)\n        | SynExpr.While (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.iter (fun ((ident, _), e, _) ->\n                        addLongIdentWithDots ident\n                        e |> Option.iter walkExpr)\n        | SynExpr.Ident ident -> addIdent ident\n        | SynExpr.ObjExpr(ty, argOpt, bindings, ifaces, _, _) ->\n            argOpt |> Option.iter (fun (e, ident) ->\n                walkExpr e\n                ident |> Option.iter addIdent)\n            walkType ty\n            List.iter walkBinding bindings\n            List.iter walkInterfaceImpl ifaces\n        | SynExpr.LongIdent (_, ident, _, _) -> addLongIdentWithDots ident\n        | SynExpr.For (_, ident, e1, _, e2, e3, _) ->\n            addIdent ident\n            List.iter walkExpr [e1; e2; e3]\n        | SynExpr.ForEach (_, _, _, pat, e1, e2, _) ->\n            walkPat pat\n            List.iter walkExpr [e1; e2]\n        | SynExpr.MatchLambda (_, _, synMatchClauseList, _, _) ->\n            List.iter walkClause synMatchClauseList\n        | SynExpr.Match (_, e, synMatchClauseList, _, _) ->\n            walkExpr e\n            List.iter walkClause synMatchClauseList\n        | SynExpr.TypeApp (e, _, tys, _, _, _, _) ->\n            List.iter walkType tys; walkExpr e\n        | SynExpr.LetOrUse (_, _, bindings, e, _) ->\n            List.iter walkBinding bindings; walkExpr e\n        | SynExpr.TryWith (e, _, clauses, _, _, _, _) ->\n            List.iter walkClause clauses;  walkExpr e\n        | SynExpr.IfThenElse (e1, e2, e3, _, _, _, _) ->\n            List.iter walkExpr [e1; e2]\n            e3 |> Option.iter walkExpr\n        | SynExpr.LongIdentSet (ident, e, _)\n        | SynExpr.DotGet (e, _, ident, _) ->\n            addLongIdentWithDots ident\n            walkExpr e\n        | SynExpr.DotSet (e1, idents, e2, _) ->\n            walkExpr e1\n            addLongIdentWithDots idents\n            walkExpr e2\n        | SynExpr.DotIndexedGet (e, args, _, _) ->\n            walkExpr e\n            List.iter walkIndexerArg args\n        | SynExpr.DotIndexedSet (e1, args, e2, _, _, _) ->\n            walkExpr e1\n            List.iter walkIndexerArg args\n            walkExpr e2\n        | SynExpr.NamedIndexedPropertySet (ident, e1, e2, _) ->\n            addLongIdentWithDots ident\n            List.iter walkExpr [e1; e2]\n        | SynExpr.DotNamedIndexedPropertySet (e1, ident, e2, e3, _) ->\n            addLongIdentWithDots ident\n            List.iter walkExpr [e1; e2; e3]\n        | SynExpr.JoinIn (e1, _, e2, _) -> List.iter walkExpr [e1; e2]\n        | SynExpr.LetOrUseBang (_, _, _, pat, e1, e2, _) ->\n            walkPat pat\n            List.iter walkExpr [e1; e2]\n        | SynExpr.TraitCall (ts, sign, e, _) ->\n            List.iter walkTypar ts\n            walkMemberSig sign\n            walkExpr e\n        | SynExpr.Const (SynConst.Measure(_, m), _) -> walkMeasure m\n        | _ -> ()\n\n    and walkMeasure = function\n        | SynMeasure.Product (m1, m2, _)\n        | SynMeasure.Divide (m1, m2, _) -> walkMeasure m1; walkMeasure m2\n        | SynMeasure.Named (longIdent, _) -> addLongIdent longIdent\n        | SynMeasure.Seq (ms, _) -> List.iter walkMeasure ms\n        | SynMeasure.Power (m, _, _) -> walkMeasure m\n        | SynMeasure.Var (ty, _) -> walkTypar ty\n        | SynMeasure.One\n        | SynMeasure.Anon _ -> ()\n\n    and walkSimplePat = function\n        | SynSimplePat.Attrib (pat, attrs, _) ->\n            walkSimplePat pat\n            List.iter walkAttribute attrs\n        | SynSimplePat.Typed(pat, t, _) ->\n            walkSimplePat pat\n            walkType t\n        | _ -> ()\n\n    and walkField (SynField.Field(attrs, _, _, t, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkType t\n\n    and walkValSig (SynValSig.ValSpfn(attrs, _, _, t, SynValInfo(argInfos, argInfo), _, _, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkType t\n        argInfo :: (argInfos |> List.concat)\n        |> List.map (fun (SynArgInfo(attrs, _, _)) -> attrs)\n        |> List.concat\n        |> List.iter walkAttribute\n\n    and walkMemberSig = function\n        | SynMemberSig.Inherit (t, _)\n        | SynMemberSig.Interface(t, _) -> walkType t\n        | SynMemberSig.Member(vs, _, _) -> walkValSig vs\n        | SynMemberSig.ValField(f, _) -> walkField f\n        | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (info, repr, memberSigs, _), _) ->\n            let isTypeExtensionOrAlias =\n                match repr with\n                | SynTypeDefnSigRepr.Simple(SynTypeDefnSimpleRepr.TypeAbbrev _, _)\n                | SynTypeDefnSigRepr.ObjectModel(SynTypeDefnKind.TyconAbbrev, _, _)\n                | SynTypeDefnSigRepr.ObjectModel(SynTypeDefnKind.TyconAugmentation, _, _) -> true\n                | _ -> false\n            walkComponentInfo isTypeExtensionOrAlias info\n            walkTypeDefnSigRepr repr\n            List.iter walkMemberSig memberSigs\n\n    and walkMember = function\n        | SynMemberDefn.AbstractSlot (valSig, _, _) -> walkValSig valSig\n        | SynMemberDefn.Member (binding, _) -> walkBinding binding\n        | SynMemberDefn.ImplicitCtor (_, attrs, pats, _, _) ->\n            List.iter walkAttribute attrs\n            List.iter walkSimplePat pats\n        | SynMemberDefn.ImplicitInherit (t, e, _, _) -> walkType t; walkExpr e\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> List.iter walkBinding bindings\n        | SynMemberDefn.Interface (t, members, _) ->\n            walkType t\n            members |> Option.iter (List.iter walkMember)\n        | SynMemberDefn.Inherit (t, _, _) -> walkType t\n        | SynMemberDefn.ValField (field, _) -> walkField field\n        | SynMemberDefn.NestedType (tdef, _, _) -> walkTypeDefn tdef\n        | SynMemberDefn.AutoProperty (attrs, _, _, t, _, _, _, _, e, _, _) ->\n            List.iter walkAttribute attrs\n            Option.iter walkType t\n            walkExpr e\n        | _ -> ()\n\n    and walkEnumCase (EnumCase(attrs, _, _, _, _)) = List.iter walkAttribute attrs\n\n    and walkUnionCaseType = function\n        | SynUnionCaseType.UnionCaseFields fields -> List.iter walkField fields\n        | SynUnionCaseType.UnionCaseFullType (t, _) -> walkType t\n\n    and walkUnionCase (SynUnionCase.UnionCase (attrs, _, t, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkUnionCaseType t\n\n    and walkTypeDefnSimple = function\n        | SynTypeDefnSimpleRepr.Enum (cases, _) -> List.iter walkEnumCase cases\n        | SynTypeDefnSimpleRepr.Union (_, cases, _) -> List.iter walkUnionCase cases\n        | SynTypeDefnSimpleRepr.Record (_, fields, _) -> List.iter walkField fields\n        | SynTypeDefnSimpleRepr.TypeAbbrev (_, t, _) -> walkType t\n        | _ -> ()\n\n    and walkComponentInfo isTypeExtensionOrAlias (ComponentInfo(attrs, typars, constraints, longIdent, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        List.iter walkTyparDecl typars\n        List.iter walkTypeConstraint constraints\n        if isTypeExtensionOrAlias then\n            addLongIdent longIdent\n\n    and walkTypeDefnRepr = function\n        | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.iter walkMember defns\n        | SynTypeDefnRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n        | SynTypeDefnRepr.Exception _ -> ()\n\n    and walkTypeDefnSigRepr = function\n        | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.iter walkMemberSig defns\n        | SynTypeDefnSigRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n        | SynTypeDefnSigRepr.Exception _ -> ()\n\n    and walkTypeDefn (TypeDefn (info, repr, members, _)) =\n        let isTypeExtensionOrAlias =\n            match repr with\n            | SynTypeDefnRepr.ObjectModel (SynTypeDefnKind.TyconAugmentation, _, _)\n            | SynTypeDefnRepr.ObjectModel (SynTypeDefnKind.TyconAbbrev, _, _)\n            | SynTypeDefnRepr.Simple (SynTypeDefnSimpleRepr.TypeAbbrev _, _) -> true\n            | _ -> false\n        walkComponentInfo isTypeExtensionOrAlias info\n        walkTypeDefnRepr repr\n        List.iter walkMember members\n\n    and walkSynModuleDecl (decl: SynModuleDecl) =\n        match decl with\n        | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace fragment\n        | SynModuleDecl.NestedModule (info, _, modules, _, _) ->\n            walkComponentInfo false info\n            List.iter walkSynModuleDecl modules\n        | SynModuleDecl.Let (_, bindings, _) -> List.iter walkBinding bindings\n        | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n        | SynModuleDecl.Types (types, _) -> List.iter walkTypeDefn types\n        | SynModuleDecl.Attributes (attrs, _) -> List.iter walkAttribute attrs\n        | _ -> ()\n\n    match input with\n    | Some (ParsedInput.ImplFile input) ->\n         walkImplFileInput input\n    | _ -> ()\n    //debug \"%A\" idents\n    identsByEndPos :> _\n\nlet getLongIdentAt ast pos =\n    let idents = getLongIdents (Some ast)\n    match idents.TryGetValue pos with\n    | true, idents -> Some idents\n    | _ -> None\n\n/// Returns ranges of all quotations found in an untyped AST\nlet getQuotationRanges ast =\n    let quotationRanges = ResizeArray()\n\n    let rec visitExpr = function\n        | SynExpr.LongIdentSet (_, expr, _)\n        | SynExpr.Typed (expr, _, _)\n        | SynExpr.Paren (expr, _, _, _)\n        | SynExpr.New (_, _, expr, _)\n        | SynExpr.ArrayOrListOfSeqExpr (_, expr, _)\n        | SynExpr.CompExpr (_, _, expr, _)\n        | SynExpr.ForEach (_, _, _, _, _, expr(*body*), _)\n        | SynExpr.YieldOrReturn (_, expr, _)\n        | SynExpr.YieldOrReturnFrom (_, expr, _)\n        | SynExpr.Do (expr, _)\n        | SynExpr.DoBang (expr, _)\n        | SynExpr.Downcast (expr, _, _)\n        | SynExpr.For (_, _, _, _, _, expr, _)\n        | SynExpr.Lazy (expr, _)\n        | SynExpr.Assert (expr, _)\n        | SynExpr.TypeApp (expr, _, _, _, _, _, _)\n        | SynExpr.DotSet (_, _, expr, _)\n        | SynExpr.DotIndexedSet (_, _, expr, _, _, _)\n        | SynExpr.NamedIndexedPropertySet (_, _, expr, _)\n        | SynExpr.DotNamedIndexedPropertySet (_, _, _, expr, _)\n        | SynExpr.TypeTest (expr, _, _)\n        | SynExpr.Upcast (expr, _, _)\n        | SynExpr.InferredUpcast (expr, _)\n        | SynExpr.InferredDowncast (expr, _)\n        | SynExpr.Lambda (_, _, _, expr, _)\n        | SynExpr.AddressOf (_, expr, _, _) ->\n            visitExpr expr\n        | SynExpr.App (_,_, expr1(*funcExpr*),expr2(*argExpr*), _)\n        | SynExpr.LetOrUseBang (_, _, _, _,expr1(*rhsExpr*),expr2(*body*), _)\n        | SynExpr.TryFinally (expr1, expr2, _, _, _)\n        | SynExpr.While (_, expr1, expr2, _) ->\n            visitExpr expr1; visitExpr expr2\n        | SynExpr.Tuple (exprs, _, _)\n        | SynExpr.ArrayOrList (_, exprs, _)\n        | Sequentials  exprs ->\n            List.iter visitExpr exprs\n        | SynExpr.TryWith (expr, _, clauses, _, _, _, _)\n        | SynExpr.Match (_, expr, clauses, _, _) ->\n            visitExpr expr; visitMatches clauses\n        | SynExpr.IfThenElse (cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n            visitExpr cond; visitExpr trueBranch\n            falseBranchOpt |> Option.iter visitExpr\n        | SynExpr.LetOrUse (_, _, bindings, body, _) -> visitBindindgs bindings; visitExpr body\n        | SynExpr.Quote (_, _isRaw, _quotedExpr, _, range) -> quotationRanges.Add range\n        | SynExpr.MatchLambda (_, _, clauses, _, _) -> visitMatches clauses\n        | SynExpr.ObjExpr (_, _, bindings, _, _ , _) -> visitBindindgs bindings\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.choose (fun (_, expr, _) -> expr) |> List.iter visitExpr\n        | _ -> ()\n\n    and visitBinding (Binding(_, _, _, _, _, _, _, _, _, body, _, _)) = visitExpr body\n    and visitBindindgs = List.iter visitBinding\n\n    and visitPattern = function\n        | SynPat.QuoteExpr (expr, _) -> visitExpr expr\n        | SynPat.Named (pat, _, _, _, _)\n        | SynPat.Paren (pat, _)\n        | SynPat.Typed (pat, _, _) -> visitPattern pat\n        | SynPat.Ands (pats, _)\n        | SynPat.Tuple (pats, _)\n        | SynPat.ArrayOrList (_, pats, _) -> List.iter visitPattern pats\n        | SynPat.Or (pat1, pat2, _) -> visitPattern pat1; visitPattern pat2\n        | SynPat.LongIdent (_, _, _, ctorArgs, _, _) ->\n            match ctorArgs with\n            | SynConstructorArgs.Pats pats -> List.iter visitPattern pats\n            | SynConstructorArgs.NamePatPairs(xs, _) ->\n                xs |> List.map snd |> List.iter visitPattern\n        | SynPat.Record(xs, _) -> xs |> List.map snd |> List.iter visitPattern\n        | _ -> ()\n\n    and visitMatch (SynMatchClause.Clause (pat, _, expr, _, _)) = visitPattern pat; visitExpr expr\n\n    and visitMatches = List.iter visitMatch\n\n    let visitMember = function\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> visitBindindgs bindings\n        | SynMemberDefn.Member (binding, _) -> visitBinding binding\n        | SynMemberDefn.AutoProperty (_, _, _, _, _, _, _, _, expr, _, _) -> visitExpr expr\n        | _ -> ()\n\n    let visitType ty =\n        let (SynTypeDefn.TypeDefn (_, repr, defns, _)) = ty\n        match repr with\n        | SynTypeDefnRepr.ObjectModel (_, objDefns, _) ->\n            for d in objDefns do visitMember d\n        | _ -> ()\n        for d in defns do visitMember d\n\n    let rec visitDeclarations decls =\n        decls |> List.iter\n           (function\n            | SynModuleDecl.Let (_, bindings, _) -> visitBindindgs bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> visitExpr expr\n            | SynModuleDecl.Types (types, _) -> List.iter visitType types\n            | SynModuleDecl.NestedModule (_, _, decls, _, _) -> visitDeclarations decls\n            | _ -> () )\n\n    let visitModulesAndNamespaces modulesOrNss =\n        modulesOrNss\n        |> Seq.iter (fun (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) -> visitDeclarations decls)\n    ast\n    |> Option.iter (function\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) -> visitModulesAndNamespaces modules\n        | _ -> ())\n    quotationRanges\n\n/// Returns all string literal ranges\nlet internal getStringLiterals ast : Range.range list =\n    let result = ResizeArray()\n\n    let visitType ty =\n        match ty with\n        | SynType.StaticConstant (SynConst.String(_, r), _) -> result.Add r\n        | _ -> ()\n\n    let rec visitExpr = function\n        | SynExpr.ArrayOrListOfSeqExpr (_, expr, _)\n        | SynExpr.CompExpr (_, _, expr, _)\n        | SynExpr.Lambda (_, _, _, expr, _)\n        | SynExpr.YieldOrReturn (_, expr, _)\n        | SynExpr.YieldOrReturnFrom (_, expr, _)\n        | SynExpr.New (_, _, expr, _)\n        | SynExpr.Assert (expr, _)\n        | SynExpr.Do (expr, _)\n        | SynExpr.Typed (expr, _, _)\n        | SynExpr.Paren (expr, _, _, _)\n        | SynExpr.DoBang (expr, _)\n        | SynExpr.Downcast (expr, _, _)\n        | SynExpr.For (_, _, _, _, _, expr, _)\n        | SynExpr.Lazy (expr, _)\n        | SynExpr.TypeTest(expr, _, _)\n        | SynExpr.Upcast(expr, _, _)\n        | SynExpr.InferredUpcast(expr, _)\n        | SynExpr.InferredDowncast(expr, _)\n        | SynExpr.LongIdentSet (_, expr, _)\n        | SynExpr.DotGet (expr, _, _, _)\n        | SynExpr.ForEach (_, _, _, _, _,expr(*body*), _) -> visitExpr expr\n        | SynExpr.App (_,_, expr1(*funcExpr*), expr2(*argExpr*), _)\n        | SynExpr.TryFinally (expr1, expr2, _, _, _)\n        | SynExpr.NamedIndexedPropertySet (_, expr1, expr2, _)\n        | SynExpr.DotNamedIndexedPropertySet (_, _, expr1, expr2, _)\n        | SynExpr.LetOrUseBang (_, _, _, _,expr1(*rhsExpr*), expr2(*body*), _)\n        | SynExpr.While (_, expr1, expr2, _) ->\n            visitExpr expr1; visitExpr expr2\n        | Sequentials exprs\n        | SynExpr.Tuple (exprs, _, _)\n        | SynExpr.ArrayOrList(_, exprs, _) -> List.iter visitExpr exprs\n        | SynExpr.Match (_, expr, clauses, _, _)\n        | SynExpr.TryWith(expr, _, clauses, _, _, _, _) ->\n            visitExpr expr; visitMatches clauses\n        | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n            visitExpr cond\n            visitExpr trueBranch\n            falseBranchOpt |> Option.iter visitExpr\n        | SynExpr.LetOrUse (_, _, bindings, body, _) ->\n            visitBindindgs bindings\n            visitExpr body\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.choose (fun (_, expr, _) -> expr) |> List.iter visitExpr\n        | SynExpr.MatchLambda (_, _, clauses, _, _) -> visitMatches clauses\n        | SynExpr.ObjExpr (_, _, bindings, _, _ , _) -> visitBindindgs bindings\n        | SynExpr.Const (SynConst.String (_, r), _) -> result.Add r\n        | SynExpr.TypeApp(_, _, tys, _, _, _, _) -> List.iter visitType tys\n        | _ -> ()\n\n    and visitBinding (Binding(_, _, _, _, _, _, _, _, _, body, _, _)) = visitExpr body\n    and visitBindindgs = List.iter visitBinding\n    and visitMatch (SynMatchClause.Clause (_, _, expr, _, _)) = visitExpr expr\n    and visitMatches = List.iter visitMatch\n\n    let visitMember = function\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> visitBindindgs bindings\n        | SynMemberDefn.Member (binding, _) -> visitBinding binding\n        | SynMemberDefn.AutoProperty (_, _, _, _, _, _, _, _, expr, _, _) -> visitExpr expr\n        | _ -> ()\n\n    let visitTypeDefn ty =\n        let (SynTypeDefn.TypeDefn (_, repr, memberDefns, _)) = ty\n        match repr with\n        | SynTypeDefnRepr.ObjectModel (_, defns, _) ->\n            for d in defns do visitMember d\n        | SynTypeDefnRepr.Simple(SynTypeDefnSimpleRepr.TypeAbbrev(_, SynType.App(_, _, tys, _,_ , _, _), _), _) ->\n            List.iter visitType tys\n        | _ -> ()\n        List.iter visitMember memberDefns\n\n    let rec visitDeclarations decls =\n        for declaration in decls do\n            match declaration with\n            | SynModuleDecl.Let (_, bindings, _) -> visitBindindgs bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> visitExpr expr\n            | SynModuleDecl.Types (types, _) -> for ty in types do visitTypeDefn ty\n            | SynModuleDecl.NestedModule (_, _, decls, _, _) -> visitDeclarations decls\n            | _ -> ()\n\n    let visitModulesAndNamespaces modulesOrNss =\n        Seq.iter (fun (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) -> visitDeclarations decls) modulesOrNss\n\n    ast\n    |> Option.iter (function\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) -> visitModulesAndNamespaces modules\n        | _ -> ())\n\n    List.ofSeq result\n\n/// Get path to containing module/namespace of a given position\nlet getModuleOrNamespacePath (pos: pos) (ast: ParsedInput) =\n    let idents =\n        match ast with\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) ->\n            let rec walkModuleOrNamespace idents (decls, moduleRange) =\n                decls\n                |> List.fold (fun acc ->\n                    function\n                    | SynModuleDecl.NestedModule (componentInfo, _, nestedModuleDecls, _, nestedModuleRange) ->\n                        if rangeContainsPos moduleRange pos then\n                            let (ComponentInfo(_,_,_,longIdent,_,_,_,_)) = componentInfo\n                            walkModuleOrNamespace (longIdent::acc) (nestedModuleDecls, nestedModuleRange)\n                        else acc\n                    | _ -> acc) idents\n\n            modules\n            |> List.fold (fun acc (SynModuleOrNamespace(longIdent, _, _, decls, _, _, _, moduleRange)) ->\n                    if rangeContainsPos moduleRange pos then\n                        walkModuleOrNamespace (longIdent::acc) (decls, moduleRange) @ acc\n                    else acc) []\n        | ParsedInput.SigFile(ParsedSigFileInput(_, _, _, _, modules)) ->\n            let rec walkModuleOrNamespaceSig idents (decls, moduleRange) =\n                decls\n                |> List.fold (fun acc ->\n                    function\n                    | SynModuleSigDecl.NestedModule (componentInfo, _, nestedModuleDecls, nestedModuleRange) ->\n                        if rangeContainsPos moduleRange pos then\n                            let (ComponentInfo(_,_,_,longIdent,_,_,_,_)) = componentInfo\n                            walkModuleOrNamespaceSig (longIdent::acc) (nestedModuleDecls, nestedModuleRange)\n                        else acc\n                    | _ -> acc) idents\n\n            modules\n            |> List.fold (fun acc (SynModuleOrNamespaceSig(longIdent, _, _, decls, _, _, _, moduleRange)) ->\n                    if rangeContainsPos moduleRange pos then\n                        walkModuleOrNamespaceSig (longIdent::acc) (decls, moduleRange) @ acc\n                    else acc) []\n    idents\n    |> List.rev\n    |> Seq.concat\n    |> Seq.map (fun ident -> ident.idText)\n    |> String.concat \".\"\n\n\nmodule HashDirectiveInfo =\n    open System.IO\n\n    type IncludeDirective =\n        | ResolvedDirectory of string\n\n    type LoadDirective =\n        | ExistingFile of string\n        | UnresolvableFile of string * previousIncludes : string array\n\n    [<NoComparison>]\n    type Directive =\n        | Include of IncludeDirective * range\n        | Load of LoadDirective * range\n\n    /// returns an array of LoadScriptResolutionEntries\n    /// based on #I and #load directives\n    let getIncludeAndLoadDirectives ast =\n        // the Load items are resolved using fallback resolution relying on previously parsed #I directives\n        // (this behaviour is undocumented in F# but it seems to be how it works).\n\n        // list of #I directives so far (populated while encountering those in order)\n        // TODO: replace by List.fold if possible\n        let includesSoFar = new System.Collections.Generic.List<_>()\n        let pushInclude = includesSoFar.Add\n\n        // those might need to be abstracted away from real filesystem operations\n        let fileExists = File.Exists\n        let directoryExists = Directory.Exists\n        let isPathRooted = Path.IsPathRooted\n        let getDirectoryOfFile = Path.GetFullPathSafe >> Path.GetDirectoryName\n        let getRootedDirectory = Path.GetFullPathSafe\n        let makeRootedDirectoryIfNecessary baseDirectory directory =\n            if not (isPathRooted directory) then\n                getRootedDirectory (baseDirectory </> directory)\n            else\n                directory\n\n        // separate function to reduce nesting one level\n        let parseDirectives modules file =\n            [|\n            let baseDirectory = getDirectoryOfFile file\n            for (SynModuleOrNamespace (_, _, _, declarations, _, _, _, _)) in modules do\n                for decl in declarations do\n                    match decl with\n                    | SynModuleDecl.HashDirective (ParsedHashDirective(\"I\",[directory],range),_) ->\n                        let directory = makeRootedDirectoryIfNecessary (getDirectoryOfFile file) directory\n\n                        if directoryExists directory then\n                            let includeDirective = ResolvedDirectory(directory)\n                            pushInclude includeDirective\n                            yield Include (includeDirective, range)\n\n                    | SynModuleDecl.HashDirective (ParsedHashDirective (\"load\",files,range),_) ->\n                        for f in files do\n                            if isPathRooted f && fileExists f then\n\n                                // this is absolute reference to an existing script, easiest case\n                                yield Load (ExistingFile f, range)\n\n                            else\n                                // I'm not sure if the order is correct, first checking relative to file containing the #load directive\n                                // then checking for undocumented resolution using previously parsed #I directives\n                                let fileRelativeToCurrentFile = baseDirectory </> f\n                                if fileExists fileRelativeToCurrentFile then\n                                    // this is existing file relative to current file\n                                    yield Load (ExistingFile fileRelativeToCurrentFile, range)\n\n                                else\n                                    // match file against first include which seemingly have it found\n                                    let maybeFile =\n                                        includesSoFar\n                                        |> Seq.tryPick (function\n                                            | (ResolvedDirectory d) ->\n                                                let filePath = d </> f\n                                                if fileExists filePath then Some filePath else None\n                                        )\n                                    match maybeFile with\n                                    | None -> () // can't load this file even using any of the #I directives...\n                                    | Some f ->\n                                        yield Load (ExistingFile f,range)\n                    | _ -> ()\n            |]\n\n        match ast with\n        | ParsedInput.ImplFile (ParsedImplFileInput(fn,_,_,_,_,modules,_)) -> parseDirectives modules fn\n        | _ -> [||]\n\n    /// returns the Some (complete file name of a resolved #load directive at position) or None\n    let getHashLoadDirectiveResolvedPathAtPosition (pos: pos) (ast: ParsedInput) : string option =\n        getIncludeAndLoadDirectives ast\n        |> Array.tryPick (\n            function\n            | Load (ExistingFile f,range)\n                // check the line is within the range\n                // (doesn't work when there are multiple files given to a single #load directive)\n                when rangeContainsPos range pos\n                    -> Some f\n            | _     -> None\n        )\n\n\n/// Set of visitor utilities, designed for the express purpose of fetching ranges\n/// from an untyped AST for the purposes of outlining.\nmodule Outlining =\n    [<RequireQualifiedAccess>]\n    module private Range =\n        /// Create a range starting at the end of r1 and finishing at the end of r2\n        let inline endToEnd (r1: range) (r2: range) = mkFileIndexRange r1.FileIndex r1.End   r2.End\n\n        /// Create a range beginning at the start of r1 and finishing at the end of r2\n        let inline startToEnd (r1: range) (r2: range) = mkFileIndexRange r1.FileIndex r1.Start r2.End\n\n        /// Create a new range from r by shifting the starting column by m\n        let inline modStart (r: range) (m:int) =\n            let modstart = mkPos r.StartLine (r.StartColumn+m)\n            mkFileIndexRange r.FileIndex modstart r.End\n\n        /// Produce a new range by adding modStart to the StartColumn of `r`\n        /// and subtracting modEnd from the EndColumn of `r`\n        let inline modBoth (r:range) modStart modEnd =\n            let rStart = Range.mkPos r.StartLine (r.StartColumn+modStart)\n            let rEnd   = Range.mkPos r.EndLine   (r.EndColumn - modEnd)\n            mkFileIndexRange r.FileIndex rStart rEnd\n\n    /// Scope indicates the way a range/snapshot should be collapsed. |Scope.Scope.Same| is for a scope inside\n    /// some kind of scope delimiter, e.g. `[| ... |]`, `[ ... ]`, `{ ... }`, etc.  |Scope.Below| is for expressions\n    /// following a binding or the right hand side of a pattern, e.g. `let x = ...`\n    type Collapse =\n        | Below = 0\n        | Same = 1\n\n    type Scope =\n        | Open = 0\n        | Namespace = 1\n        | Module = 2\n        | Type = 3\n        | Member = 4\n        | LetOrUse = 5\n        | Match = 6\n        /// MatchLambda = function | expr -> .... | expr ->...\n        | MatchLambda = 7\n        | CompExpr = 8\n        | IfThenElse = 9\n        | ThenInIfThenElse = 10\n        | ElseInIfThenElse = 11\n        | TryWith = 12\n        | TryInTryWith = 13\n        | WithInTryWith = 14\n        | TryFinally = 15\n        | TryInTryFinally = 16\n        | FinallyInTryFinally = 17\n        | ArrayOrList = 18\n        | ObjExpr = 19\n        | For = 20\n        | While = 21\n        | CompExprInternal = 22\n        | Quote = 23\n        | Record = 24\n        | Tuple = 25\n        | SpecialFunc = 26\n        | Do = 27\n        | Lambda = 28\n        | MatchClause = 29\n        | Attribute = 30\n        | Interface = 31\n        | HashDirective = 32\n        | LetOrUseBang = 33\n        | TypeExtension = 34\n        | YieldOrReturn = 35\n        | YieldOrReturnBang = 36\n        | UnionCase = 37\n        | EnumCase = 38\n        | RecordField = 39\n        | SimpleType = 40\n        | RecordDefn = 41\n        | UnionDefn = 42\n        | Comment = 43\n        | XmlDocComment = 44\n\n    [<NoComparison; Struct>]\n    type ScopeRange (scope:Scope, collapse:Collapse, r:range) =\n        member __.Scope = scope\n        member __.Collapse = collapse\n        member __.Range = r\n\n    // Only yield a range that spans 2 or more lines\n    let inline private rcheck scope collapse (r: range) =\n        seq { if r.StartLine <> r.EndLine then\n                yield ScopeRange (scope, collapse, r) }\n\n    let rec private parseExpr expression =\n        seq {\n            match expression with\n            | SynExpr.Upcast (e,_,_)\n            | SynExpr.Downcast (e,_,_)\n            | SynExpr.AddressOf(_,e,_,_)\n            | SynExpr.InferredDowncast (e,_)\n            | SynExpr.InferredUpcast (e,_)\n            | SynExpr.DotGet (e,_,_,_)\n            | SynExpr.Do (e,_)\n            | SynExpr.DotSet (e,_,_,_)\n            | SynExpr.New (_,_,e,_)\n            | SynExpr.Typed (e,_,_)\n            | SynExpr.DotIndexedGet (e,_,_,_)\n            | SynExpr.DotIndexedSet (e,_,_,_,_,_) -> yield! parseExpr e\n            | SynExpr.YieldOrReturn (_,e,r) ->\n                yield! rcheck Scope.YieldOrReturn Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.YieldOrReturnFrom (_,e,r) ->\n                yield! rcheck Scope.YieldOrReturnBang Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.DoBang (e,r) ->\n                yield! rcheck Scope.Do Collapse.Below <| Range.modStart r 3\n                yield! parseExpr e\n            | SynExpr.LetOrUseBang (_,_,_,pat,e1,e2,_) ->\n                // for `let!` or `use!` the pattern begins at the end of the keyword so that\n                // this scope can be used without adjustment if there is no `=` on the same line\n                // if there is an `=` the range will be adjusted during the tooltip creation\n                yield! rcheck Scope.LetOrUseBang Collapse.Below <| Range.endToEnd pat.Range e1.Range\n                yield! parseExpr e1\n                yield! parseExpr e2\n            | SynExpr.For (_,_,_,_,_,e,r)\n            | SynExpr.ForEach (_,_,_,_,_,e,r) ->\n                yield! rcheck Scope.For Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.LetOrUse (_,_,bindings, body,_) ->\n                yield! parseBindings bindings\n                yield! parseExpr body\n            | SynExpr.Match (seqPointAtBinding,_,clauses,_,r) ->\n                match seqPointAtBinding with\n                | SequencePointAtBinding pr ->\n                    yield! rcheck Scope.Match Collapse.Below <| Range.endToEnd pr r\n                | _ -> ()\n                yield! parseMatchClauses clauses\n            | SynExpr.MatchLambda (_,_,clauses,_,r) ->\n                yield! rcheck Scope.MatchLambda Collapse.Below <| Range.modStart r 8\n                yield! parseMatchClauses clauses\n            | SynExpr.App (atomicFlag,isInfix,funcExpr,argExpr,r) ->\n                // seq exprs, custom operators, etc\n                if ExprAtomicFlag.NonAtomic=atomicFlag && (not isInfix)\n                   && (function | SynExpr.Ident _ -> true | _ -> false) funcExpr\n                   // if the argExrp is a computation expression another match will handle the outlining\n                   // these cases must be removed to prevent creating unnecessary tags for the same scope\n                   && (function | SynExpr.CompExpr _ -> false | _ -> true) argExpr then\n                        yield! rcheck Scope.SpecialFunc Collapse.Below <| Range.endToEnd funcExpr.Range r\n                yield! parseExpr argExpr\n                yield! parseExpr funcExpr\n            | SynExpr.Sequential (_,_,e1,e2,_) ->\n                yield! parseExpr e1\n                yield! parseExpr e2\n            | SynExpr.ArrayOrListOfSeqExpr (isArray,e,r) ->\n                yield! rcheck  Scope.ArrayOrList Collapse.Same <| Range.modBoth r (if isArray then 2 else 1) (if isArray then 2 else 1)\n                yield! parseExpr e\n            | SynExpr.CompExpr (arrayOrList,_,e,r) ->\n                if arrayOrList then\n                    yield! parseExpr e\n                else  // exclude the opening { and closing } on the cexpr from collapsing\n                    yield! rcheck Scope.CompExpr Collapse.Same <| Range.modBoth r 1 1\n                yield! parseExpr e\n            | SynExpr.ObjExpr (_,_,bindings,_,newRange,wholeRange) ->\n                let r = mkFileIndexRange newRange.FileIndex newRange.End (Range.mkPos wholeRange.EndLine (wholeRange.EndColumn - 1))\n                yield! rcheck Scope.ObjExpr Collapse.Below r\n                yield! parseBindings bindings\n            | SynExpr.TryWith (e,_,matchClauses,tryRange,withRange,tryPoint,withPoint) ->\n                match tryPoint with\n                | SequencePointAtTry r ->\n                    yield! rcheck Scope.TryWith Collapse.Below <| Range.endToEnd r tryRange\n                | _ -> ()\n                match withPoint with\n                | SequencePointAtWith r ->\n                    yield! rcheck Scope.WithInTryWith Collapse.Below <| Range.endToEnd r withRange\n                | _ -> ()\n                yield! parseExpr e\n                yield! parseMatchClauses matchClauses\n            | SynExpr.TryFinally (tryExpr,finallyExpr,r,tryPoint,finallyPoint) ->\n                match tryPoint with\n                | SequencePointAtTry tryRange ->\n                    yield! rcheck Scope.TryFinally Collapse.Below <| Range.endToEnd tryRange r\n                | _ -> ()\n                match finallyPoint with\n                | SequencePointAtFinally finallyRange ->\n                    yield! rcheck  Scope.FinallyInTryFinally Collapse.Below <| Range.endToEnd finallyRange r\n                | _ -> ()\n                yield! parseExpr tryExpr\n                yield! parseExpr finallyExpr\n            | SynExpr.IfThenElse (e1,e2,e3,seqPointInfo,_,_,r) ->\n                // Outline the entire IfThenElse\n                yield! rcheck Scope.IfThenElse Collapse.Below r\n                // Outline the `then` scope\n                match seqPointInfo with\n                | SequencePointInfoForBinding.SequencePointAtBinding rt ->\n                    yield! rcheck  Scope.ThenInIfThenElse Collapse.Below <| Range.endToEnd rt e2.Range\n                | _ -> ()\n                yield! parseExpr e1\n                yield! parseExpr e2\n                match e3 with\n                | Some e ->\n                    match e with // prevent double collapsing on elifs\n                    | SynExpr.IfThenElse (_,_,_,_,_,_,_) ->\n                        yield! parseExpr e\n                    | _ ->\n                        yield! rcheck Scope.ElseInIfThenElse Collapse.Same e.Range\n                        yield! parseExpr e\n                | None -> ()\n            | SynExpr.While (_,_,e,r) ->\n                yield! rcheck Scope.While Collapse.Below  r\n                yield! parseExpr e\n            | SynExpr.Lambda (_,_,pats,e,r) ->\n                match pats with\n                | SynSimplePats.SimplePats (_,pr)\n                | SynSimplePats.Typed (_,_,pr) ->\n                    yield! rcheck Scope.Lambda Collapse.Below <| Range.endToEnd pr r\n                yield! parseExpr e\n            | SynExpr.Lazy (e,r) ->\n                yield! rcheck Scope.SpecialFunc Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.Quote (_,isRaw,e,_,r) ->\n                // subtract columns so the @@> or @> is not collapsed\n                yield! rcheck Scope.Quote Collapse.Same <| Range.modBoth r (if isRaw then 3 else 2) (if isRaw then 3 else 2)\n                yield! parseExpr e\n            | SynExpr.Tuple (es,_,r) ->\n                yield! rcheck Scope.Tuple Collapse.Same r\n                yield! Seq.collect parseExpr es\n            | SynExpr.Paren (e,_,_,_) ->\n                yield! parseExpr e\n            | SynExpr.Record (recCtor,recCopy,recordFields,r) ->\n                if recCtor.IsSome then\n                    let (_,ctorArgs,_,_,_) = recCtor.Value\n                    yield! parseExpr ctorArgs\n                if recCopy.IsSome then\n                    let (e,_) = recCopy.Value\n                    yield! parseExpr e\n                yield! recordFields |> (Seq.choose (fun (_,e,_) -> e) >> Seq.collect parseExpr)\n                // exclude the opening `{` and closing `}` of the record from collapsing\n                yield! rcheck Scope.Record Collapse.Same <| Range.modBoth r 1 1\n            | _ -> ()\n        }\n\n    and private parseMatchClause (SynMatchClause.Clause (synPat,_,e,_,_)) =\n        seq { yield! rcheck Scope.MatchClause Collapse.Same <| Range.startToEnd synPat.Range e.Range  // Collapse the scope after `->`\n              yield! parseExpr e }\n\n    and private parseMatchClauses = Seq.collect parseMatchClause\n\n    and private parseAttributes (attrs: SynAttributes) =\n        seq{\n            let attrListRange =\n                if List.isEmpty attrs then Seq.empty else\n                rcheck Scope.Attribute Collapse.Same  <| Range.startToEnd (attrs.[0].Range) (attrs.[attrs.Length-1].ArgExpr.Range)\n            match  attrs with\n            | [] -> ()\n            | [_] -> yield! attrListRange\n            | hd::tl ->\n                yield! attrListRange\n                yield! parseExpr hd.ArgExpr\n                // If there are more than 2 attributes only add tags to the 2nd and beyond, to avoid double collapsing on the first attribute\n                yield! tl |> Seq.collect (fun attr -> rcheck Scope.Attribute Collapse.Same <| Range.startToEnd attr.Range attr.ArgExpr.Range)\n                // visit the expressions inside each attribute\n                yield! attrs |> Seq.collect (fun attr -> parseExpr attr.ArgExpr)\n        }\n\n    and private parseBinding (Binding (_,kind,_,_,attrs,_,_,_,_,e,br,_) as b) =\n        seq {\n//            let r = Range.endToEnd b.RangeOfBindingSansRhs b.RangeOfBindingAndRhs\n            match kind with\n            | SynBindingKind.NormalBinding ->\n                yield! rcheck Scope.LetOrUse Collapse.Below <| Range.endToEnd b.RangeOfBindingSansRhs b.RangeOfBindingAndRhs\n            | SynBindingKind.DoBinding ->\n                yield! rcheck Scope.Do Collapse.Below <| Range.modStart br 2\n            | _ -> ()\n            yield! parseAttributes attrs\n            yield! parseExpr e\n        }\n\n    and private parseBindings = Seq.collect parseBinding\n\n    and private parseSynMemberDefn d =\n        seq {\n            match d with\n            | SynMemberDefn.Member (binding, r) ->\n                yield! rcheck Scope.Member Collapse.Below r\n                yield! parseBinding binding\n            | SynMemberDefn.LetBindings (bindings, _, _, _r) ->\n                //yield! rcheck Scope.LetOrUse Collapse.Below r\n                yield! parseBindings bindings\n            | SynMemberDefn.Interface (tp,iMembers,_) ->\n                yield! rcheck Scope.Interface Collapse.Below <| Range.endToEnd tp.Range d.Range\n                match iMembers with\n                | Some members -> yield! Seq.collect parseSynMemberDefn members\n                | None -> ()\n            | SynMemberDefn.NestedType (td, _, _) ->\n                yield! parseTypeDefn td\n            | SynMemberDefn.AbstractSlot (ValSpfn(_, _, _, synt, _, _, _, _, _, _, _), _, r) ->\n                yield! rcheck Scope.Member Collapse.Below <| Range.startToEnd synt.Range r\n            | SynMemberDefn.AutoProperty (_, _, _, _, (*memkind*)_, _, _, _, e, _, r) ->\n                yield! rcheck Scope.Member Collapse.Below r\n                yield! parseExpr e\n            | _ -> ()\n        }\n\n    (*  For Cases like\n        --------------\n            type JsonDocument =\n                private {   Json : string\n                            Path : string   }\n        Or\n             type JsonDocument =\n                internal |  Json of string\n                         |  Path of string\n    *)\n    and private parseSimpleRepr simple =\n        let _accessRange (opt:SynAccess option) =\n            match opt with\n            | None -> 0\n            | Some synacc ->\n                match synacc with\n                | SynAccess.Public -> 6\n                | SynAccess.Private -> 7\n                | SynAccess.Internal -> 8\n        seq {\n            match simple with\n            | SynTypeDefnSimpleRepr.Enum (cases,er) ->\n                yield! rcheck Scope.SimpleType Collapse.Below er\n                yield!\n                    cases\n                    |> Seq.collect (fun (SynEnumCase.EnumCase (attrs, _, _, _, cr)) ->\n                        seq { yield! rcheck Scope.EnumCase Collapse.Below cr\n                              yield! parseAttributes attrs })\n            | SynTypeDefnSimpleRepr.Record (_opt,fields,rr) ->\n                //yield! rcheck Scope.SimpleType Collapse.Same <| Range.modBoth rr (accessRange opt+1) 1\n                yield! rcheck Scope.RecordDefn Collapse.Same rr //<| Range.modBoth rr 1 1\n                yield! fields\n                    |> Seq.collect (fun (SynField.Field (attrs,_,_,_,_,_,_,fr)) ->\n                    seq{yield! rcheck Scope.RecordField Collapse.Below fr\n                        yield! parseAttributes attrs\n                    })\n            | SynTypeDefnSimpleRepr.Union (_opt,cases,ur) ->\n//                yield! rcheck Scope.SimpleType Collapse.Same <| Range.modStart ur (accessRange opt)\n                yield! rcheck Scope.UnionDefn Collapse.Same ur\n                yield! cases\n                    |> Seq.collect (fun (SynUnionCase.UnionCase (attrs,_,_,_,_,cr)) ->\n                    seq{yield! rcheck Scope.UnionCase Collapse.Below cr\n                        yield! parseAttributes attrs\n                    })\n            | _ -> ()\n        }\n\n    and private parseTypeDefn (TypeDefn (componentInfo, objectModel, members, range)) =\n        seq {\n            match objectModel with\n            | SynTypeDefnRepr.ObjectModel (defnKind, objMembers, _) ->\n                match defnKind with\n                | SynTypeDefnKind.TyconAugmentation ->\n                    yield! rcheck Scope.TypeExtension Collapse.Below <| Range.endToEnd componentInfo.Range range\n                | _ ->\n                    yield! rcheck Scope.Type Collapse.Below <| Range.endToEnd componentInfo.Range range\n                yield! Seq.collect parseSynMemberDefn objMembers\n                // visit the members of a type extension\n                yield! Seq.collect parseSynMemberDefn members\n            | SynTypeDefnRepr.Simple (simpleRepr,_r) ->\n                yield! rcheck Scope.Type Collapse.Below <| Range.endToEnd componentInfo.Range range\n                yield! parseSimpleRepr simpleRepr\n                yield! Seq.collect parseSynMemberDefn members\n            | SynTypeDefnRepr.Exception _ -> ()\n        }\n\n    let private getConsecutiveModuleDecls (predicate: SynModuleDecl -> range option) (scope:Scope) (decls: SynModuleDecls) =\n        let groupConsecutiveDecls input =\n            let rec loop (input: range list) (res: range list list) currentBulk =\n                match input, currentBulk with\n                | [], [] -> List.rev res\n                | [], _ -> List.rev (currentBulk::res)\n                | r :: rest, [] -> loop rest res [r]\n                | r :: rest, last :: _ when r.StartLine = last.EndLine + 1 ->\n                    loop rest res (r::currentBulk)\n                | r :: rest, _ -> loop rest (currentBulk::res) [r]\n            loop input [] []\n\n        let selectRanges (ranges: range list) =\n            match ranges with\n            | [] -> None\n            | [r] when r.StartLine = r.EndLine -> None\n            | [r] -> Some <| ScopeRange (scope, Collapse.Same, (Range.mkRange \"\" r.Start r.End))\n            | lastRange :: rest ->\n                let firstRange = Seq.last rest\n                Some <| ScopeRange (scope, Collapse.Same, (Range.mkRange \"\" firstRange.Start lastRange.End))\n\n        decls |> (List.choose predicate >> groupConsecutiveDecls >> List.choose selectRanges)\n\n\n    let collectOpens = getConsecutiveModuleDecls (function SynModuleDecl.Open (_, r) -> Some r | _ -> None) Scope.Open\n\n    let collectHashDirectives =\n         getConsecutiveModuleDecls(\n            function\n            | SynModuleDecl.HashDirective (ParsedHashDirective (directive, _, _),r) ->\n                let prefixLength = \"#\".Length + directive.Length + \" \".Length\n                Some (Range.mkRange \"\" (Range.mkPos r.StartLine prefixLength) r.End)\n            | _ -> None) Scope.HashDirective\n\n\n    let rec private parseDeclaration (decl: SynModuleDecl) =\n        seq {\n            match decl with\n            | SynModuleDecl.Let (_,bindings,_) ->\n                yield! parseBindings bindings\n            | SynModuleDecl.Types (types,_) ->\n                yield! Seq.collect parseTypeDefn types\n            // Fold the attributes above a module\n            | SynModuleDecl.NestedModule (SynComponentInfo.ComponentInfo (attrs,_,_,_,_,_,_,cmpRange),_, decls,_,_) ->\n                // Outline the full scope of the module\n                yield! rcheck Scope.Module Collapse.Below <| Range.endToEnd cmpRange decl.Range\n                // A module's component info stores the ranges of its attributes\n                yield! parseAttributes attrs\n                yield! collectOpens decls\n                yield! Seq.collect parseDeclaration decls\n            | SynModuleDecl.DoExpr (_,e,_) ->\n                yield! parseExpr e\n            | SynModuleDecl.Attributes (attrs,_) ->\n                yield! parseAttributes attrs\n            | _ -> ()\n        }\n\n    let private parseModuleOrNamespace moduleOrNs =\n        seq { let (SynModuleOrNamespace.SynModuleOrNamespace (_,_,_,decls,_,_,_,_)) = moduleOrNs\n              yield! collectHashDirectives decls\n              yield! collectOpens decls\n              yield! Seq.collect parseDeclaration decls }\n\n    type private LineNum = int\n    type private LineStr = string\n    type private CommentType = Regular | XmlDoc\n\n    [<NoComparison>]\n    type private CommentList =\n        { Lines: ResizeArray<LineNum * LineStr>\n          Type: CommentType }\n        static member New ty lineStr =\n            { Type = ty; Lines = ResizeArray [| lineStr |] }\n\n    let private (|Comment|_|) line =\n        match line with\n        | String.StartsWith \"///\" -> Some XmlDoc\n        | String.StartsWith \"//\" -> Some Regular\n        | _ -> None\n\n    let getCommentRanges (lines: string[]) =\n        let comments: CommentList list =\n            lines\n            |> Array.foldi (fun ((lastLineNum, currentComment: CommentList option, result) as state) lineNum lineStr ->\n                match lineStr.TrimStart(), currentComment with\n                | Comment commentType, Some comment ->\n                    if comment.Type = commentType && lineNum = lastLineNum + 1 then\n                        comment.Lines.Add (lineNum, lineStr)\n                        lineNum, currentComment, result\n                    else lineNum, Some (CommentList.New commentType (lineNum, lineStr)), comment :: result\n                | Comment commentType, None ->\n                    lineNum, Some (CommentList.New commentType (lineNum, lineStr)), result\n                | _, Some comment ->\n                    lineNum, None, comment :: result\n                | _ -> state)\n               (-1, None, [])\n            |> fun (_, lastComment, comments) ->\n                match lastComment with\n                | Some comment ->\n                    comment :: comments\n                | _ -> comments\n                |> List.rev\n\n        comments\n        |> List.filter (fun comment -> comment.Lines.Count > 1)\n        |> List.map (fun comment ->\n            let lines = comment.Lines\n            let startLine, startStr = lines.[0]\n            let endLine, endStr = lines.[lines.Count - 1]\n            let startCol = startStr.IndexOf '/'\n            let endCol = endStr.TrimEnd().Length\n\n            let scopeType =\n                match comment.Type with\n                | Regular -> Scope.Comment\n                | XmlDoc -> Scope.XmlDocComment\n            ScopeRange(\n                scopeType,\n                Collapse.Same,\n                Range.mkRange\n                    \"\"\n                    (Range.mkPos (startLine + 1) startCol)\n                    (Range.mkPos (endLine + 1) endCol)))\n\n    let getOutliningRanges sourceLines tree =\n        match tree with\n        | ParsedInput.ImplFile implFile ->\n            let (ParsedImplFileInput (_, _, _, _, _, modules, _)) = implFile\n            let astBasedRanges = Seq.collect parseModuleOrNamespace modules\n            let commentRanges = getCommentRanges sourceLines\n            Seq.append astBasedRanges commentRanges\n        | _ -> Seq.empty\n\nmodule Printf =\n    [<NoComparison>]\n    type PrintfFunction =\n        { FormatString: Range.range\n          Args: Range.range[] }\n\n    [<NoComparison>]\n    type private AppWithArg =\n        { Range: Range.range\n          Arg: Range.range }\n\n    let internal getAll (input: ParsedInput option) : PrintfFunction[] =\n        let result = ResizeArray()\n        let appStack: AppWithArg list ref = ref []\n\n        let addAppWithArg appWithArg =\n            match !appStack with\n            | lastApp :: _ when not (Range.rangeContainsRange lastApp.Range appWithArg.Range) ->\n                appStack := [appWithArg]\n            | _ -> appStack := appWithArg :: !appStack\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.iter walkSynModuleOrNamespace moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) =\n            List.iter walkSynModuleDecl decls\n\n        and walkTypeConstraint = function\n            | SynTypeConstraint.WhereTyparDefaultsToType (_, ty, _)\n            | SynTypeConstraint.WhereTyparSubtypeOfType (_, ty, _) -> walkType ty\n            | SynTypeConstraint.WhereTyparIsEnum (_, ts, _)\n            | SynTypeConstraint.WhereTyparIsDelegate (_, ts, _) -> List.iter walkType ts\n            | SynTypeConstraint.WhereTyparSupportsMember (_, sign, _) -> walkMemberSig sign\n            | _ -> ()\n\n        and walkBinding (SynBinding.Binding (_, _, _, _, _, _, _, _, returnInfo, e, _, _)) =\n            walkExpr e\n            returnInfo |> Option.iter (fun (SynBindingReturnInfo (t, _, _)) -> walkType t)\n\n        and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) = List.iter walkBinding bindings\n\n        and walkIndexerArg = function\n            | SynIndexerArg.One e -> walkExpr e\n            | SynIndexerArg.Two (e1, e2) -> List.iter walkExpr [e1; e2]\n\n        and walkType = function\n            | SynType.Array (_, t, _)\n            | SynType.HashConstraint (t, _)\n            | SynType.MeasurePower (t, _, _) -> walkType t\n            | SynType.Fun (t1, t2, _)\n            | SynType.MeasureDivide (t1, t2, _) -> walkType t1; walkType t2\n            | SynType.App (ty, _, types, _, _, _, _) -> walkType ty; List.iter walkType types\n            | SynType.LongIdentApp (_, _, _, types, _, _, _) -> List.iter walkType types\n            | SynType.Tuple (ts, _) -> ts |> List.iter (fun (_, t) -> walkType t)\n            | SynType.WithGlobalConstraints (t, typeConstraints, _) ->\n                walkType t; List.iter walkTypeConstraint typeConstraints\n            | _ -> ()\n\n        and walkClause (Clause (_, e1, e2, _, _)) =\n            walkExpr e2\n            e1 |> Option.iter walkExpr\n\n        and walkSimplePats = function\n            | SynSimplePats.SimplePats (pats, _) -> List.iter walkSimplePat pats\n            | SynSimplePats.Typed (pats, ty, _) ->\n                walkSimplePats pats\n                walkType ty\n\n        and walkExpr e =\n            match e with\n            | SynExpr.App (_, _, SynExpr.Ident _, SynExpr.Const (SynConst.String (_, stringRange), _), r) ->\n                match !appStack with\n                | (lastApp :: _) as apps when Range.rangeContainsRange lastApp.Range e.Range ->\n                    let intersectsWithFuncOrString (arg: Range.range) =\n                        Range.rangeContainsRange arg stringRange\n                        || arg = stringRange\n                        || Range.rangeContainsRange arg r\n                        || arg = r\n\n                    let rec loop acc (apps: AppWithArg list) =\n                        match acc, apps with\n                        | _, [] -> acc\n                        | [], h :: t ->\n                            if not (intersectsWithFuncOrString h.Arg) then\n                                loop [h] t\n                            else loop [] t\n                        | prev :: _, curr :: rest ->\n                            if Range.rangeContainsRange curr.Range prev.Range\n                               && not (intersectsWithFuncOrString curr.Arg) then\n                                loop (curr :: acc) rest\n                            else acc\n\n                    let args =\n                        apps\n                        |> loop []\n                        |> List.rev\n                        |> List.map (fun x -> x.Arg)\n                        |> List.toArray\n                    let res = { FormatString = stringRange\n                                Args = args }\n                    result.Add res\n                | _ -> ()\n                appStack := []\n            | SynExpr.App (_, _, SynExpr.App(_, true, SynExpr.Ident op, e1, _), e2, _) ->\n                let rec deconstruct = function\n                    | SynExpr.Paren (exp, _, _, _) -> deconstruct exp\n                    | SynExpr.Tuple (exps, _, _) ->\n                        exps |> List.iter (fun exp -> addAppWithArg { Range = e.Range; Arg = exp.Range})\n                        ()\n                    | _ -> ()\n\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                if op.idText = (PrettyNaming.CompileOpName \"||>\")\n                        || op.idText = (PrettyNaming.CompileOpName \"|||>\") then\n                    deconstruct e1\n                    walkExpr e2\n                else\n                    if op.idText = (PrettyNaming.CompileOpName \"|>\") then\n                        addAppWithArg { Range = e.Range; Arg = e1.Range }\n                    walkExpr e2\n                    walkExpr e1\n            | SynExpr.App (_, _, SynExpr.App(_, true, _, e1, _), e2, _) ->\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                addAppWithArg { Range = e.Range; Arg = e1.Range }\n                walkExpr e1\n                walkExpr e2\n            | SynExpr.App (_, _, e1, e2, _) ->\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                walkExpr e1\n                walkExpr e2\n            | _ ->\n                match e with\n                | SynExpr.Paren (e, _, _, _)\n                | SynExpr.Quote (_, _, e, _, _)\n                | SynExpr.Typed (e, _, _)\n                | SynExpr.InferredUpcast (e, _)\n                | SynExpr.InferredDowncast (e, _)\n                | SynExpr.AddressOf (_, e, _, _)\n                | SynExpr.DoBang (e, _)\n                | SynExpr.YieldOrReturn (_, e, _)\n                | SynExpr.ArrayOrListOfSeqExpr (_, e, _)\n                | SynExpr.CompExpr (_, _, e, _)\n                | SynExpr.Do (e, _)\n                | SynExpr.Assert (e, _)\n                | SynExpr.Lazy (e, _)\n                | SynExpr.YieldOrReturnFrom (_, e, _) -> walkExpr e\n                | SynExpr.Lambda (_, _, pats, e, _) ->\n                    walkSimplePats pats\n                    walkExpr e\n                | SynExpr.New (_, t, e, _)\n                | SynExpr.TypeTest (e, t, _)\n                | SynExpr.Upcast (e, t, _)\n                | SynExpr.Downcast (e, t, _) -> walkExpr e; walkType t\n                | SynExpr.Tuple (es, _, _)\n                | Sequentials es\n                | SynExpr.ArrayOrList (_, es, _) -> List.iter walkExpr es\n                | SynExpr.TryFinally (e1, e2, _, _, _)\n                | SynExpr.While (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.Record (_, _, fields, _) ->\n                    fields |> List.iter (fun (_, e, _) -> e |> Option.iter walkExpr)\n                | SynExpr.ObjExpr(ty, argOpt, bindings, ifaces, _, _) ->\n                    argOpt |> Option.iter (fun (e, _) -> walkExpr e)\n                    walkType ty\n                    List.iter walkBinding bindings\n                    List.iter walkInterfaceImpl ifaces\n                | SynExpr.For (_, _, e1, _, e2, e3, _) -> List.iter walkExpr [e1; e2; e3]\n                | SynExpr.ForEach (_, _, _, _, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.MatchLambda (_, _, synMatchClauseList, _, _) ->\n                    List.iter walkClause synMatchClauseList\n                | SynExpr.Match (_, e, synMatchClauseList, _, _) ->\n                    walkExpr e\n                    List.iter walkClause synMatchClauseList\n                | SynExpr.TypeApp (e, _, tys, _, _, _, _) ->\n                    List.iter walkType tys; walkExpr e\n                | SynExpr.LetOrUse (_, _, bindings, e, _) ->\n                    List.iter walkBinding bindings; walkExpr e\n                | SynExpr.TryWith (e, _, clauses, _, _, _, _) ->\n                    List.iter walkClause clauses;  walkExpr e\n                | SynExpr.IfThenElse (e1, e2, e3, _, _, _, _) ->\n                    List.iter walkExpr [e1; e2]\n                    e3 |> Option.iter walkExpr\n                | SynExpr.LongIdentSet (_, e, _)\n                | SynExpr.DotGet (e, _, _, _) -> walkExpr e\n                | SynExpr.DotSet (e1, _, e2, _) ->\n                    walkExpr e1\n                    walkExpr e2\n                | SynExpr.DotIndexedGet (e, args, _, _) ->\n                    walkExpr e\n                    List.iter walkIndexerArg args\n                | SynExpr.DotIndexedSet (e1, args, e2, _, _, _) ->\n                    walkExpr e1\n                    List.iter walkIndexerArg args\n                    walkExpr e2\n                | SynExpr.NamedIndexedPropertySet (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.DotNamedIndexedPropertySet (e1, _, e2, e3, _) -> List.iter walkExpr [e1; e2; e3]\n                | SynExpr.JoinIn (e1, _, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.LetOrUseBang (_, _, _, _, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.TraitCall (_, sign, e, _) ->\n                    walkMemberSig sign\n                    walkExpr e\n                | SynExpr.Const (SynConst.Measure(_, m), _) -> walkMeasure m\n                | _ -> ()\n\n        and walkMeasure = function\n            | SynMeasure.Product (m1, m2, _)\n            | SynMeasure.Divide (m1, m2, _) -> walkMeasure m1; walkMeasure m2\n            | SynMeasure.Seq (ms, _) -> List.iter walkMeasure ms\n            | SynMeasure.Power (m, _, _) -> walkMeasure m\n            | SynMeasure.One\n            | SynMeasure.Anon _\n            | SynMeasure.Named _\n            | SynMeasure.Var _ -> ()\n\n        and walkSimplePat = function\n            | SynSimplePat.Attrib (pat, _, _) -> walkSimplePat pat\n            | SynSimplePat.Typed(_, t, _) -> walkType t\n            | _ -> ()\n\n        and walkField (SynField.Field(_, _, _, t, _, _, _, _)) = walkType t\n\n        and walkMemberSig = function\n            | SynMemberSig.Inherit (t, _)\n            | SynMemberSig.Interface(t, _) -> walkType t\n            | SynMemberSig.ValField(f, _) -> walkField f\n            | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (_, repr, memberSigs, _), _) ->\n                walkTypeDefnSigRepr repr\n                List.iter walkMemberSig memberSigs\n            | SynMemberSig.Member _ -> ()\n\n        and walkMember = function\n            | SynMemberDefn.Member (binding, _) -> walkBinding binding\n            | SynMemberDefn.ImplicitCtor (_, _, pats, _, _) -> List.iter walkSimplePat pats\n            | SynMemberDefn.ImplicitInherit (t, e, _, _) -> walkType t; walkExpr e\n            | SynMemberDefn.LetBindings (bindings, _, _, _) -> List.iter walkBinding bindings\n            | SynMemberDefn.Interface (t, members, _) ->\n                walkType t\n                members |> Option.iter (List.iter walkMember)\n            | SynMemberDefn.Inherit (t, _, _) -> walkType t\n            | SynMemberDefn.ValField (field, _) -> walkField field\n            | SynMemberDefn.NestedType (tdef, _, _) -> walkTypeDefn tdef\n            | SynMemberDefn.AutoProperty (_, _, _, t, _, _, _, _, e, _, _) ->\n                Option.iter walkType t\n                walkExpr e\n            | _ -> ()\n\n        and walkTypeDefnRepr = function\n            | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.iter walkMember defns\n            | SynTypeDefnRepr.Simple _ -> ()\n            | SynTypeDefnRepr.Exception _ -> ()\n\n        and walkTypeDefnSigRepr = function\n            | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.iter walkMemberSig defns\n            | SynTypeDefnSigRepr.Simple _ -> ()\n            | SynTypeDefnSigRepr.Exception _ -> ()\n\n        and walkTypeDefn (TypeDefn (_, repr, members, _)) =\n            walkTypeDefnRepr repr\n            List.iter walkMember members\n\n        and walkSynModuleDecl (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace fragment\n            | SynModuleDecl.NestedModule (_, _, modules, _, _) ->\n                List.iter walkSynModuleDecl modules\n            | SynModuleDecl.Let (_, bindings, _) -> List.iter walkBinding bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n            | SynModuleDecl.Types (types, _) -> List.iter walkTypeDefn types\n            | _ -> ()\n\n        match input with\n        | Some (ParsedInput.ImplFile input) ->\n             walkImplFileInput input\n        | _ -> ()\n        //debug \"%A\" idents\n        result.ToArray()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"}],"id":{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"},"expanded":true,"level":0,"properties":{}},{"name":"TypedAstUtils","content":"open System\nopen System.Text.RegularExpressions\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open UntypedAstUtils\n\n[<NoComparison>]\ntype SymbolUse =\n    { SymbolUse: FSharpSymbolUse\n      IsUsed: bool\n      FullNames: Idents[] }\n\n[<AutoOpen>]\nmodule TypedAstUtils =\n    let isSymbolLocalForProject (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpParameter -> true\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember || not m.Accessibility.IsPublic\n        | :? FSharpEntity as m -> not m.Accessibility.IsPublic\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> not m.Accessibility.IsPublic\n        | :? FSharpField as m -> not m.Accessibility.IsPublic\n        | _ -> false\n\n    let isAttribute<'T> (attribute: FSharpAttribute) =\n        // CompiledName throws exception on DataContractAttribute generated by SQLProvider\n        match Option.attempt (fun _ -> attribute.AttributeType.CompiledName) with\n        | Some name when name = typeof<'T>.Name -> true\n        | _ -> false\n\n    let hasAttribute<'T> (attributes: seq<FSharpAttribute>) =\n        attributes |> Seq.exists isAttribute<'T>\n\n    let tryGetAttribute<'T> (attributes: seq<FSharpAttribute>) =\n        attributes |> Seq.tryFind isAttribute<'T>\n\n    let hasModuleSuffixAttribute (entity: FSharpEntity) =\n         entity.Attributes\n         |> tryGetAttribute<CompilationRepresentationAttribute>\n         |> Option.bind (fun a ->\n              Option.attempt (fun _ -> a.ConstructorArguments)\n              |> Option.bind (fun args -> args |> Seq.tryPick (fun (_, arg) ->\n                   let res =\n                       match arg with\n                       | :? int32 as arg when arg = int CompilationRepresentationFlags.ModuleSuffix ->\n                           Some()\n                       | :? CompilationRepresentationFlags as arg when arg = CompilationRepresentationFlags.ModuleSuffix ->\n                           Some()\n                       | _ ->\n                           None\n                   res)))\n         |> Option.isSome\n\n    let isOperator (name: string) =\n        name.StartsWith \"( \" && name.EndsWith \" )\" && name.Length > 4\n            && name.Substring (2, name.Length - 4)\n               |> String.forall (fun c -> c <> ' ' && not (Char.IsLetter c))\n\n    let private UnnamedUnionFieldRegex = Regex(\"^Item(\\d+)?$\", RegexOptions.Compiled)\n    let isUnnamedUnionCaseField (field: FSharpField) = UnnamedUnionFieldRegex.IsMatch(field.Name)\n\n[<AutoOpen>]\nmodule TypedAstExtensionHelpers =\n    type FSharpEntity with\n        member x.TryGetFullName() =\n            Option.attempt (fun _ -> x.TryFullName)\n            |> Option.flatten\n            |> Option.orTry (fun _ ->\n                Option.attempt (fun _ -> String.Join(\".\", x.AccessPath, x.DisplayName)))\n\n        member x.TryGetFullDisplayName() =\n            let fullName = x.TryGetFullName() |> Option.map (fun fullName -> fullName.Split '.')\n            let res =\n                match fullName with\n                | Some fullName ->\n                    match Option.attempt (fun _ -> x.DisplayName) with\n                    | Some shortDisplayName when not (shortDisplayName.Contains \".\") ->\n                        Some (fullName |> Array.replace (fullName.Length - 1) shortDisplayName)\n                    | _ -> Some fullName\n                | None -> None\n                |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n            //debug \"GetFullDisplayName: FullName = %A, Result = %A\" fullName res\n            res\n\n        member x.TryGetFullCompiledName() =\n            let fullName = x.TryGetFullName() |> Option.map (fun fullName -> fullName.Split '.')\n            let res =\n                match fullName with\n                | Some fullName ->\n                    match Option.attempt (fun _ -> x.CompiledName) with\n                    | Some shortCompiledName when not (shortCompiledName.Contains \".\") ->\n                        Some (fullName |> Array.replace (fullName.Length - 1) shortCompiledName)\n                    | _ -> Some fullName\n                | None -> None\n                |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n            //debug \"GetFullCompiledName: FullName = %A, Result = %A\" fullName res\n            res\n\n        member x.PublicNestedEntities =\n            x.NestedEntities |> Seq.filter (fun entity -> entity.Accessibility.IsPublic)\n\n        member x.TryGetMembersFunctionsAndValues =\n            Option.attempt (fun _ -> x.MembersFunctionsAndValues) |> Option.getOrElse ([||] :> _)\n\n    type FSharpMemberOrFunctionOrValue with\n        // FullType may raise exceptions (see https://github.com/fsharp/fsharp/issues/307).\n        member x.FullTypeSafe = Option.attempt (fun _ -> x.FullType)\n\n        member x.TryGetFullDisplayName() =\n            let fullName = Option.attempt (fun _ -> x.FullName.Split '.')\n            match fullName with\n            | Some fullName ->\n                match Option.attempt (fun _ -> x.DisplayName) with\n                | Some shortDisplayName when not (shortDisplayName.Contains \".\") ->\n                    Some (fullName |> Array.replace (fullName.Length - 1) shortDisplayName)\n                | _ -> Some fullName\n            | None -> None\n            |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n\n        member x.TryGetFullCompiledOperatorNameIdents() : Idents option =\n            // For operator ++ displayName is ( ++ ) compiledName is op_PlusPlus\n            if isOperator x.DisplayName && x.DisplayName <> x.CompiledName then\n                x.EnclosingEntity.TryGetFullName()\n                |> Option.map (fun enclosingEntityFullName ->\n                     Array.append (enclosingEntityFullName.Split '.') [| x.CompiledName |])\n            else None\n\n    type FSharpAssemblySignature with\n        member x.TryGetEntities() = try x.Entities :> _ seq with _ -> Seq.empty\n\n[<AutoOpen>]\nmodule TypedAstPatterns =\n    let (|AbbreviatedType|_|) (entity: FSharpEntity) =\n        if entity.IsFSharpAbbreviation then Some entity.AbbreviatedType\n        else None\n\n    let (|TypeWithDefinition|_|) (ty: FSharpType) =\n        if ty.HasTypeDefinition then Some ty.TypeDefinition\n        else None\n\n    let rec getEntityAbbreviatedType (entity: FSharpEntity) =\n        if entity.IsFSharpAbbreviation then\n            match entity.AbbreviatedType with\n            | TypeWithDefinition def -> getEntityAbbreviatedType def\n            | abbreviatedType -> entity, Some abbreviatedType\n        else entity, None\n\n    let rec getAbbreviatedType (fsharpType: FSharpType) =\n        if fsharpType.IsAbbreviation then\n            getAbbreviatedType fsharpType.AbbreviatedType\n        else fsharpType\n\n    let (|Attribute|_|) (entity: FSharpEntity) =\n        let isAttribute (entity: FSharpEntity) =\n            let getBaseType (entity: FSharpEntity) =\n                try\n                    match entity.BaseType with\n                    | Some (TypeWithDefinition def) -> Some def\n                    | _ -> None\n                with _ -> None\n\n            let rec isAttributeType (ty: FSharpEntity option) =\n                match ty with\n                | None -> false\n                | Some ty ->\n                    match ty.TryGetFullName() with\n                    | None -> false\n                    | Some fullName ->\n                        fullName = \"System.Attribute\" || isAttributeType (getBaseType ty)\n            isAttributeType (Some entity)\n        if isAttribute entity then Some() else None\n\n    let (|ValueType|_|) (e: FSharpEntity) =\n        if e.IsEnum || e.IsValueType || hasAttribute<MeasureAnnotatedAbbreviationAttribute> e.Attributes then Some()\n        else None\n\n    let (|Class|_|) (original: FSharpEntity, abbreviated: FSharpEntity, _) =\n        if abbreviated.IsClass\n           && (not abbreviated.IsStaticInstantiation || original.IsFSharpAbbreviation) then Some()\n        else None\n\n    let (|Record|_|) (e: FSharpEntity) = if e.IsFSharpRecord then Some() else None\n    let (|UnionType|_|) (e: FSharpEntity) = if e.IsFSharpUnion then Some() else None\n    let (|Delegate|_|) (e: FSharpEntity) = if e.IsDelegate then Some() else None\n    let (|FSharpException|_|) (e: FSharpEntity) = if e.IsFSharpExceptionDeclaration then Some() else None\n    let (|Interface|_|) (e: FSharpEntity) = if e.IsInterface then Some() else None\n    let (|AbstractClass|_|) (e: FSharpEntity) =\n        if hasAttribute<AbstractClassAttribute> e.Attributes then Some() else None\n\n    let (|FSharpType|_|) (e: FSharpEntity) =\n        if e.IsDelegate || e.IsFSharpExceptionDeclaration || e.IsFSharpRecord || e.IsFSharpUnion\n            || e.IsInterface || e.IsMeasure\n            || (e.IsFSharp && e.IsOpaque && not e.IsFSharpModule && not e.IsNamespace) then Some()\n        else None\n\n    let (|ProvidedType|_|) (e: FSharpEntity) =\n        if (e.IsProvided || e.IsProvidedAndErased || e.IsProvidedAndGenerated) && e.CompiledName = e.DisplayName then\n            Some()\n        else None\n\n    let (|ByRef|_|) (e: FSharpEntity) = if e.IsByRef then Some() else None\n    let (|Array|_|) (e: FSharpEntity) = if e.IsArrayType then Some() else None\n    let (|FSharpModule|_|) (entity: FSharpEntity) = if entity.IsFSharpModule then Some() else None\n\n    let (|Namespace|_|) (entity: FSharpEntity) = if entity.IsNamespace then Some() else None\n    let (|ProvidedAndErasedType|_|) (entity: FSharpEntity) = if entity.IsProvidedAndErased then Some() else None\n    let (|Enum|_|) (entity: FSharpEntity) = if entity.IsEnum then Some() else None\n\n    let (|Tuple|_|) (ty: FSharpType option) =\n        ty |> Option.bind (fun ty -> if ty.IsTupleType then Some() else None)\n\n    let (|RefCell|_|) (ty: FSharpType) =\n        match getAbbreviatedType ty with\n        | TypeWithDefinition def when\n            def.IsFSharpRecord && def.FullName = \"Microsoft.FSharp.Core.FSharpRef`1\" -> Some()\n        | _ -> None\n\n    let (|FunctionType|_|) (ty: FSharpType) =\n        if ty.IsFunctionType then Some()\n        else None\n\n    let (|Pattern|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpUnionCase\n        | :? FSharpActivePatternCase -> Some()\n        | _ -> None\n\n    /// Field (field, fieldAbbreviatedType)\n    let (|Field|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpField as field -> Some (field, getAbbreviatedType field.FieldType)\n        | _ -> None\n\n    let (|MutableVar|_|) (symbol: FSharpSymbol) =\n        let isMutable =\n            match symbol with\n            | :? FSharpField as field -> field.IsMutable && not field.IsLiteral\n            | :? FSharpMemberOrFunctionOrValue as func -> func.IsMutable\n            | _ -> false\n        if isMutable then Some() else None\n\n    /// Entity (originalEntity, abbreviatedEntity, abbreviatedType)\n    let (|FSharpEntity|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpEntity as entity ->\n            let abbreviatedEntity, abbreviatedType = getEntityAbbreviatedType entity\n            Some (entity, abbreviatedEntity, abbreviatedType)\n        | _ -> None\n\n    let (|Parameter|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpParameter -> Some()\n        | _ -> None\n\n    let (|UnionCase|_|) (e: FSharpSymbol) =\n        match e with\n        | :? FSharpUnionCase as uc -> Some uc\n        | _ -> None\n\n    let (|RecordField|_|) (e: FSharpSymbol) =\n        match e with\n        | :? FSharpField as field ->\n            if field.DeclaringEntity.IsFSharpRecord then Some field else None\n        | _ -> None\n\n    let (|ActivePatternCase|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpActivePatternCase as case -> Some case\n        | _ -> None\n\n    /// Func (memberFunctionOrValue, fullType)\n    let (|MemberFunctionOrValue|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpMemberOrFunctionOrValue as func -> Some func\n        | _ -> None\n\n    /// Constructor (enclosingEntity)\n    let (|Constructor|_|) (func: FSharpMemberOrFunctionOrValue) =\n        match func.CompiledName with\n        | \".ctor\" | \".cctor\" -> Some func.EnclosingEntity\n        | _ -> None\n\n    let (|Function|_|) excluded (func: FSharpMemberOrFunctionOrValue) =\n        match func.FullTypeSafe |> Option.map getAbbreviatedType with\n        | Some typ when typ.IsFunctionType\n                       && not func.IsPropertyGetterMethod\n                       && not func.IsPropertySetterMethod\n                       && not excluded\n                       && not (isOperator func.DisplayName) -> Some()\n        | _ -> None\n\n    let (|ExtensionMember|_|) (func: FSharpMemberOrFunctionOrValue) =\n        if func.IsExtensionMember then Some() else None\n\n    let (|Event|_|) (func: FSharpMemberOrFunctionOrValue) =\n        if func.IsEvent then Some () else None\n\nmodule UnusedDeclarations =\n    open System.Collections.Generic\n\n    let symbolUseComparer =\n        { new IEqualityComparer<FSharpSymbolUse> with\n              member __.Equals (x, y) = x.Symbol.IsEffectivelySameAs y.Symbol\n              member __.GetHashCode x = x.Symbol.GetHashCode() }\n\n    let getSingleDeclarations (symbolsUses: SymbolUse[]): FSharpSymbol[] =\n        let symbols = Dictionary<FSharpSymbolUse, int>(symbolUseComparer)\n\n        for symbolUse in symbolsUses do\n            match symbols.TryGetValue symbolUse.SymbolUse with\n            | true, count -> symbols.[symbolUse.SymbolUse] <- count + 1\n            | _ -> symbols.[symbolUse.SymbolUse] <- 1\n\n        symbols\n        |> Seq.choose (fun (KeyValue(symbolUse, count)) ->\n            match symbolUse.Symbol with\n            | UnionCase _ when isSymbolLocalForProject symbolUse.Symbol -> Some symbolUse.Symbol\n            // Determining that a record, DU or module is used anywhere requires\n            // inspecting all their enclosed entities (fields, cases and func / vals)\n            // for usefulness, which is too expensive to do. Hence we never gray them out.\n            | FSharpEntity ((Record | UnionType | Interface | FSharpModule), _, _ | Class) -> None\n            // FCS returns inconsistent results for override members; we're skipping these symbols.\n            | MemberFunctionOrValue func when func.IsOverrideOrExplicitInterfaceImplementation -> None\n            // Usage of DU case parameters does not give any meaningful feedback; we never gray them out.\n            | Parameter -> None\n            | _ when count = 1 && symbolUse.IsFromDefinition && isSymbolLocalForProject symbolUse.Symbol ->\n                    Some symbolUse.Symbol\n                | _ -> None)\n        |> Seq.toArray","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"}],"id":{"$":0,"Item":"34a27ec3-40ab-455a-a53f-48fde25fd73c"},"expanded":true,"level":0,"properties":{}},{"name":"AssemblyContentProvider","content":"open System\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n//type internal ShortIdent = string\n//type Idents = ShortIdent[]\ntype IsAutoOpen = bool\ntype ModuleKind = { IsAutoOpen: bool; HasModuleSuffix: bool }\n\ntype EntityKind =\n    | Attribute\n    | Type\n    | FunctionOrValue of isActivePattern:bool\n    | Module of ModuleKind\n    override x.ToString() = sprintf \"%A\" x\n\ntype RawEntity =\n    { /// Full entity name as it's seen in compiled code (raw FSharpEntity.FullName, FSharpValueOrFunction.FullName).\n      FullName: string\n      /// Entity name parts with removed module suffixes (Ns.M1Module.M2Module.M3.entity -> Ns.M1.M2.M3.entity)\n      /// and replaced compiled names with display names (FSharpEntity.DisplayName, FSharpValueOrFucntion.DisplayName).\n      /// Note: *all* parts are cleaned, not the last one.\n      CleanedIdents: Idents\n      Namespace: Idents option\n      IsPublic: bool\n      TopRequireQualifiedAccessParent: Idents option\n      AutoOpenParent: Idents option\n      Kind: EntityKind }\n    override x.ToString() = sprintf \"%A\" x\n\ntype AssemblyPath = string\ntype AssemblyContentType = Public | Full\n\ntype Parent =\n    { Namespace: Idents option\n      RequiresQualifiedAccess: Idents option\n      AutoOpen: Idents option\n      WithModuleSuffix: Idents option }\n    static member Empty =\n        { Namespace = None\n          RequiresQualifiedAccess = None\n          AutoOpen = None\n          WithModuleSuffix = None }\n    static member RewriteParentIdents (parentIdents: Idents option) (idents: Idents) =\n        match parentIdents with\n        | Some p when p.Length <= idents.Length ->\n            for i in 0..p.Length - 1 do\n                idents.[i] <- p.[i]\n        | _ -> ()\n        idents\n\n    member x.FixParentModuleSuffix (idents: Idents) =\n        Parent.RewriteParentIdents x.WithModuleSuffix idents\n\n    member __.FormatEntityFullName (entity: FSharpEntity) =\n        // remove number of arguments from generic types\n        // e.g. System.Collections.Generic.Dictionary`2 -> System.Collections.Generic.Dictionary\n        // and System.Data.Listeners`1.Func -> System.Data.Listeners.Func\n        let removeGenericParamsCount (idents: Idents) =\n            idents\n            |> Array.map (fun ident ->\n                if ident.Length > 0 && Char.IsDigit ident.[ident.Length - 1] then\n                    let lastBacktickIndex = ident.LastIndexOf '`'\n                    if lastBacktickIndex <> -1 then\n                        ident.Substring(0, lastBacktickIndex)\n                    else ident\n                else ident)\n\n        let removeModuleSuffix (idents: Idents) =\n            if entity.IsFSharpModule && idents.Length > 0 && hasModuleSuffixAttribute entity then\n                let lastIdent = idents.[idents.Length - 1]\n                if lastIdent.EndsWith \"Module\" then\n                    idents |> Array.replace (idents.Length - 1) (lastIdent.Substring(0, lastIdent.Length - 6))\n                else idents\n            else idents\n\n        entity.TryGetFullName()\n        |> Option.bind (fun fullName ->\n            entity.TryGetFullDisplayName()\n            |> Option.map (fun fullDisplayName ->\n                fullName,\n                fullDisplayName.Split '.'\n                |> removeGenericParamsCount\n                |> removeModuleSuffix))\n\nmodule AssemblyContentProvider =\n    open System.IO\n\n    type AssemblyContentCacheEntry =\n        { FileWriteTime: DateTime\n          ContentType: AssemblyContentType\n          Entities: RawEntity list }\n\n    [<NoComparison; NoEquality>]\n    type IAssemblyContentCache =\n        abstract TryGet: AssemblyPath -> AssemblyContentCacheEntry option\n        abstract Set: AssemblyPath -> AssemblyContentCacheEntry -> unit\n\n    let private createEntity ns (parent: Parent) (entity: FSharpEntity) =\n        parent.FormatEntityFullName entity\n        |> Option.map (fun (fullName, cleanIdents) ->\n            { FullName = fullName\n              CleanedIdents = cleanIdents\n              Namespace = ns\n              IsPublic = entity.Accessibility.IsPublic\n              TopRequireQualifiedAccessParent = parent.RequiresQualifiedAccess |> Option.map parent.FixParentModuleSuffix\n              AutoOpenParent = parent.AutoOpen |> Option.map parent.FixParentModuleSuffix\n              Kind =\n                match entity with\n                | TypedAstPatterns.Attribute -> EntityKind.Attribute\n                | FSharpModule ->\n                    EntityKind.Module\n                        { IsAutoOpen = hasAttribute<AutoOpenAttribute> entity.Attributes\n                          HasModuleSuffix = hasModuleSuffixAttribute entity }\n                | _ -> EntityKind.Type })\n\n    let private traverseMemberFunctionAndValues ns (parent: Parent) (membersFunctionsAndValues: seq<FSharpMemberOrFunctionOrValue>) =\n        membersFunctionsAndValues\n        |> Seq.collect (fun func ->\n            let processIdents fullName idents =\n                { FullName = fullName\n                  CleanedIdents = parent.FixParentModuleSuffix idents\n                  Namespace = ns\n                  IsPublic = func.Accessibility.IsPublic\n                  TopRequireQualifiedAccessParent =\n                        parent.RequiresQualifiedAccess |> Option.map parent.FixParentModuleSuffix\n                  AutoOpenParent = parent.AutoOpen |> Option.map parent.FixParentModuleSuffix\n                  Kind = EntityKind.FunctionOrValue func.IsActivePattern }\n\n            [ yield! func.TryGetFullDisplayName()\n                     |> Option.map (fun fullDisplayName -> processIdents func.FullName (fullDisplayName.Split '.'))\n                     |> Option.toList\n              (* for\n                 [<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\n                 module M =\n                     let (++) x y = ()\n                 open M\n                 let _ = 1 ++ 2\n\n                 we should return additional RawEntity { FullName = MModule.op_PlusPlus; CleanedIdents = [|\"M\"; \"op_PlusPlus\"|] ... }\n              *)\n              yield! func.TryGetFullCompiledOperatorNameIdents()\n                     |> Option.map (fun fullCompiledIdents ->\n                          processIdents (fullCompiledIdents |> String.concat \".\") fullCompiledIdents)\n                     |> Option.toList ])\n\n    let rec private traverseEntity contentType (parent: Parent) (entity: FSharpEntity) =\n\n        seq { if not entity.IsProvided then\n                match contentType, entity.Accessibility.IsPublic with\n                | Full, _ | Public, true ->\n                    let ns = entity.Namespace |> Option.map (fun x -> x.Split '.') |> Option.orElseX parent.Namespace\n                    let currentEntity = createEntity ns parent entity\n\n                    match currentEntity with\n                    | Some x -> yield x\n                    | None -> ()\n\n                    let currentParent =\n                        { RequiresQualifiedAccess =\n                            parent.RequiresQualifiedAccess\n                            |> Option.orElseX (\n                                if hasAttribute<RequireQualifiedAccessAttribute> entity.Attributes then\n                                    parent.FormatEntityFullName entity |> Option.map snd\n                                else None)\n                          AutoOpen =\n                            let isAutoOpen = entity.IsFSharpModule && hasAttribute<AutoOpenAttribute> entity.Attributes\n                            match isAutoOpen, parent.AutoOpen with\n                            // if parent is also AutoOpen, then keep the parent\n                            | true, Some parent -> Some parent\n                            // if parent is not AutoOpen, but current entity is, peek the latter as a new AutoOpen module\n                            | true, None -> parent.FormatEntityFullName entity |> Option.map snd\n                            // if current entity is not AutoOpen, we discard whatever parent was\n                            | false, _ -> None\n\n                          WithModuleSuffix =\n                            if entity.IsFSharpModule && hasModuleSuffixAttribute entity then\n                                currentEntity |> Option.map (fun e -> e.CleanedIdents)\n                            else parent.WithModuleSuffix\n                          Namespace = ns }\n\n                    if entity.IsFSharpModule then\n                        match entity.TryGetMembersFunctionsAndValues with\n                        | xs when xs.Count > 0 ->\n                            yield! traverseMemberFunctionAndValues ns currentParent xs\n                        | _ -> ()\n\n                    for e in (try entity.NestedEntities :> _ seq with _ -> Seq.empty) do\n                        yield! traverseEntity contentType currentParent e\n                | _ -> () }\n\n    let getAssemblySignatureContent contentType (signature: FSharpAssemblySignature) =\n            signature.TryGetEntities()\n            |> Seq.collect (traverseEntity contentType Parent.Empty)\n            |> Seq.distinct\n\n    let private getAssemblySignaturesContent contentType (assemblies: FSharpAssembly list) =\n        assemblies\n        |> Seq.collect (fun asm -> getAssemblySignatureContent contentType asm.Contents)\n        |> Seq.toList\n\n    let getAssemblyContent (withCache: ((IAssemblyContentCache -> _) -> _) option)\n                           contentType (fileName: string option) (assemblies: FSharpAssembly list) =\n        match assemblies |> List.filter (fun x -> not x.IsProviderGenerated), fileName with\n        | [], _ -> []\n        | assemblies, Some fileName ->\n            let fileWriteTime = FileInfo(fileName).LastWriteTime\n            match withCache with\n            | Some withCache ->\n                withCache <| fun cache ->\n                    match contentType, cache.TryGet fileName with\n                    | _, Some entry\n                    | Public, Some entry when entry.FileWriteTime = fileWriteTime -> entry.Entities\n                    | _ ->\n                        let entities = getAssemblySignaturesContent contentType assemblies\n                        cache.Set fileName { FileWriteTime = fileWriteTime; ContentType = contentType; Entities = entities }\n                        entities\n            | None -> getAssemblySignaturesContent contentType assemblies\n        | assemblies, None ->\n            getAssemblySignaturesContent contentType assemblies\n        |> List.filter (fun entity ->\n            match contentType, entity.IsPublic with\n            | Full, _ | Public, true -> true\n            | _ -> false)","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"34a27ec3-40ab-455a-a53f-48fde25fd73c"},{"$":0,"Item":"a6ffc34e-45f1-4732-a3e7-7de501ad478e"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"},"expanded":true,"level":0,"properties":{}},{"name":"Environment","content":"\nmodule Environment =\n  let private environVar v = Environment.GetEnvironmentVariable v\n\n  let private programFilesX86 =\n      let wow64 = environVar \"PROCESSOR_ARCHITEW6432\"\n      let globalArch = environVar \"PROCESSOR_ARCHITECTURE\"\n      match wow64, globalArch with\n      | \"AMD64\", \"AMD64\"\n      | null, \"AMD64\"\n      | \"x86\", \"AMD64\" -> environVar \"ProgramFiles(x86)\"\n      | _ -> environVar \"ProgramFiles\"\n      |> fun detected -> if detected = null then @\"C:\\Program Files (x86)\\\" else detected\n\n  // Below code slightly modified from FAKE MSBuildHelper.fs \"\n  \n  let private tryFindFile dirs file =\n      let files =\n          dirs\n          |> Seq.map (fun (path : string) ->\n              try\n                 let path =\n                    if path.StartsWith(\"\\\"\") && path.EndsWith(\"\\\"\")\n                    then path.Substring(1, path.Length - 2)\n                    else path\n                 let dir = new DirectoryInfo(path)\n                 if not dir.Exists then \"\"\n                 else\n                     let fi = new FileInfo(dir.FullName </> file)\n                     if fi.Exists then fi.FullName\n                     else \"\"\n              with\n              | _ -> \"\")\n          |> Seq.filter ((<>) \"\")\n          |> Seq.cache\n      if not (Seq.isEmpty files) then Some(Seq.head files) \n      else None\n\n  let private tryFindPath backupPaths tool =\n      let paths = Environment.GetEnvironmentVariable \"PATH\" + string Path.PathSeparator + backupPaths\n      let paths = paths.Split(Path.PathSeparator)\n      tryFindFile paths tool\n\n  let private findPath backupPaths tool =\n      match tryFindPath backupPaths tool with\n      | Some file -> file\n      | None -> tool\n\n  let msbuild =\n      if runningOnMono then \"xbuild\"\n      else\n        let MSBuildPath = \n            (programFilesX86 </> @\"\\MSBuild\\14.0\\Bin\") + \";\" +\n            (programFilesX86 </> @\"\\MSBuild\\12.0\\Bin\") + \";\" +\n            (programFilesX86 </> @\"\\MSBuild\\12.0\\Bin\\amd64\") + \";\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\;\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v4.0.30128\\;\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v3.5\\\"\n        let ev = Environment.GetEnvironmentVariable \"MSBuild\"\n        if not (String.IsNullOrEmpty ev) then ev\n        else findPath MSBuildPath \"MSBuild.exe\"\n//\"\n  let private fsharpInstallationPath =\n    [\"4.1\"; \"4.0\"; \"3.1\"; \"3.0\"]\n    |> List.map (fun v -> programFilesX86 </> @\"\\Microsoft SDKs\\F#\\\" </> v </> @\"\\Framework\\v4.0\")\n    |> List.tryFind Directory.Exists\n\n  let fsi =\n    if runningOnMono then \"fsharpi\"\n    else\n      Option.getOrElse \"\" fsharpInstallationPath </> \"fsi.exe\"\n\n  let fsc =\n    if Utils.runningOnMono then \"fsharpc\"\n    else\n      Option.getOrElse \"\" fsharpInstallationPath </> \"fsc.exe\"\n\n  let fsharpCoreOpt =\n    if Utils.runningOnMono then\n      let mscorlibDir = Path.GetDirectoryName typeof<obj>.Assembly.Location\n      if List.forall File.Exists (List.map (combinePaths mscorlibDir) [\"FSharp.Core.dll\"; \"FSharp.Core.optdata\"; \"FSharp.Core.sigdata\"]) then\n        Some (mscorlibDir </> \"FSharp.Core.dll\")\n      else\n        None\n    else\n      let referenceAssembliesPath =\n        programFilesX86 </> @\"Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\\"\n      let fsharpCoreVersions = [\"4.4.1.0\"; \"4.4.0.0\"; \"4.3.1.0\"; \"4.3.0.0\"]\n      tryFindFile (List.map (combinePaths referenceAssembliesPath) fsharpCoreVersions) \"FSharp.Core.dll\"\n\n  let referenceAssembliesPath = \n     programFilesX86 </> @\"Reference Assemblies\\Microsoft\\Framework\\.NETFramework\"\n  \n  let dotNetVersions () =\n    if Directory.Exists referenceAssembliesPath then\n      Directory.EnumerateDirectories referenceAssembliesPath\n      |> Seq.sort\n      |> Seq.toArray\n      |> Array.rev\n    else\n      Array.empty\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},"expanded":true,"level":0,"properties":{}},{"name":"CompilerServiceInterface","content":"open System\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open Utils\nopen System.Collections.Concurrent\n\ntype ParseAndCheckResults\n    (\n        parseResults: FSharpParseFileResults,\n        checkResults: FSharpCheckFileResults\n    ) =\n\n  member __.TryGetMethodOverrides (lines: LineStr[]) (pos: Pos) = async {\n    // Find the starting point, ideally right after the first '('\n    let lineCutoff = pos.Line - 6\n    let commas, line, col =\n      let rec prevPos (line,col) =\n        match line, col with\n        | 1, 1\n        | _ when line < lineCutoff -> 1, 1\n        | _, 1 ->\n           let prevLine = lines.[line - 2]\n           if prevLine.Length = 0 then prevPos(line-1, 1)\n           else line - 1, prevLine.Length\n        | _    -> line, col - 1\n\n      let rec loop commas depth (line, col) =\n        if (line,col) <= (1,1) then (0, line, col) else\n        let ch = lines.[line - 1].[col - 1]\n        let commas = if depth = 0 && ch = ',' then commas + 1 else commas\n        if (ch = '(' || ch = '{' || ch = '[') && depth > 0 then loop commas (depth - 1) (prevPos (line,col))\n        elif ch = ')' || ch = '}' || ch = ']' then loop commas (depth + 1) (prevPos (line,col))\n        elif ch = '(' || ch = '<' then commas, line, col\n        else loop commas depth (prevPos (line,col))\n      match loop 0 0 (prevPos(pos.Line, pos.Col)) with\n      | _, 1, 1 -> 0, pos.Line, pos.Col\n      | newPos -> newPos\n\n    let lineStr = lines.[line - 1]\n    match Parsing.findLongIdentsAtGetMethodsTrigger(col - 1, lineStr) with\n    | None -> return Failure \"Could not find ident at this location\"\n    | Some identIsland ->\n\n    let! meth = checkResults.GetMethodsAlternate(line, col, lineStr, Some identIsland)\n\n    return Success(meth, commas) }\n\n  member __.TryFindDeclaration (pos: Pos) (lineStr: LineStr) = async {\n    match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n    | None -> return Failure \"Could not find ident at this location\"\n    | Some(col, identIsland) ->\n\n      let! declarations = checkResults.GetDeclarationLocationAlternate(pos.Line, col, lineStr, identIsland, false)\n\n      match declarations with\n      | FSharpFindDeclResult.DeclNotFound _ -> return Failure \"Could not find declaration\"\n      | FSharpFindDeclResult.DeclFound range -> return Success range\n      //| FSharpFindDeclResult.ExternalDecl(assembly, externalSym) -> return Failure \"External declaration\" //TODO: Handle external declarations\n    }\n\n  member __.TryGetToolTip (pos: Pos) (lineStr: LineStr) = async {\n    match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n    | None -> return Failure \"Cannot find ident for tooltip\"\n    | Some(col,identIsland) ->\n\n      // TODO: Display other tooltip types, for example for strings or comments where appropriate\n      let! tip = checkResults.GetToolTipTextAlternate(pos.Line, col, lineStr, identIsland, FSharpTokenTag.Identifier)\n      return\n        match tip with\n        | FSharpToolTipText(elems) when elems |> List.forall ((=) FSharpToolTipElement.None) ->\n            match identIsland with\n            | [ident] ->\n               KeywordList.tryGetKeywordDescription ident\n               |> Option.map (fun desc -> FSharpToolTipText [FSharpToolTipElement.Single(ident, FSharpXmlDoc.Text desc)])\n               |> function\n               | Some tip -> Success tip\n               | None -> Failure \"No tooltip information\"\n            | _ -> Failure \"No tooltip information\"\n        | _ -> Success(tip)\n  }\n\n  member __.TryGetSymbolUse (pos: Pos) (lineStr: LineStr) =\n    async {\n        match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n        | None -> return (Failure \"No ident at this location\")\n        | Some(colu, identIsland) ->\n\n        let! symboluse = checkResults.GetSymbolUseAtLocation(pos.Line, colu, lineStr, identIsland)\n        match symboluse with\n        | None -> return (Failure \"No symbol information found\")\n        | Some symboluse ->\n\n        let! symboluses = checkResults.GetUsesOfSymbolInFile symboluse.Symbol\n        return Success (symboluse, symboluses) }\n\n  member __.TryGetF1Help (pos: Pos) (lineStr: LineStr) =\n    async {\n        match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n        | None -> return (Failure \"No ident at this location\")\n        | Some(colu, identIsland) ->\n\n        let! help = checkResults.GetF1KeywordAlternate(pos.Line, colu, lineStr, identIsland)\n        match help with\n        | None -> return (Failure \"No symbol information found\")\n        | Some hlp -> return Success hlp}\n\n  member __.TryGetCompletions (pos: Pos) (lineStr: LineStr) filter = async {\n    let longName, residue = Parsing.findLongIdentsAndResidue(pos.Col - 1, lineStr)\n    try\n      let! results = checkResults.GetDeclarationListInfo(Some parseResults, pos.Line, pos.Col, lineStr, longName, residue, (fun () -> []))\n\n      let decls =\n        match filter with\n        | Some \"StartsWith\" -> [| for d in results.Items do if d.Name.StartsWith(residue, StringComparison.InvariantCultureIgnoreCase) then yield d |]\n        | Some \"Contains\" -> [| for d in results.Items do if d.Name.IndexOf(residue, StringComparison.InvariantCultureIgnoreCase) >= 0 then yield d |]\n        | _ -> results.Items\n      return Some (decls, residue)\n    with :? TimeoutException -> return None\n  }\n\n  member __.GetAllEntities () =\n    async {\n      try\n        return\n          Some\n            [\n              yield! AssemblyContentProvider.getAssemblySignatureContent AssemblyContentType.Full checkResults.PartialAssemblySignature\n              let ctx = checkResults.ProjectContext\n              let assembliesByFileName =\n                ctx.GetReferencedAssemblies()\n                |> Seq.groupBy (fun asm -> asm.FileName)\n                |> Seq.map (fun (fileName, asms) -> fileName, List.ofSeq asms)\n                |> Seq.toList\n                |> List.rev // if mscorlib.dll is the first then FSC raises exception when we try to\n                            // get Content.Entities from it.\n\n              for fileName, signatures in assembliesByFileName do\n                let contentType = Public // it's always Public for now since we don't support InternalsVisibleTo attribute yet\n                yield! AssemblyContentProvider.getAssemblyContent (fun _ -> []) contentType fileName signatures\n\n            ]\n      with\n      | _ -> return None\n  }\n\n  member __.GetSemanticClassification = checkResults.GetSemanticClassification None\n  member __.GetAST = parseResults.ParseTree\n  member __.GetCheckResults = checkResults\n  member __.GetParseResults = parseResults\n  member __.FileName = parseResults.FileName\n\ntype private FileState =\n    | Checked\n    | NeedChecking\n    | BeingChecked\n    | Cancelled\n\ntype Version = int\n\ntype FSharpCompilerServiceChecker() =\n  let checker =\n    FSharpChecker.Create(\n      projectCacheSize = 200,\n      keepAllBackgroundResolutions = false,\n      keepAssemblyContents = true)\n\n  let files = ConcurrentDictionary<string, Version * FileState>()\n  do checker.BeforeBackgroundFileCheck.Add ignore\n\n  let isResultObsolete fileName =\n      match files.TryGetValue fileName with\n      | true, (_, Cancelled) -> true\n      | _ -> false\n\n  let fileChanged filePath version =\n    files.AddOrUpdate (filePath, (version, NeedChecking), (fun _ (oldVersion, oldState) ->\n        if version <> oldVersion then\n           (version,\n            match oldState with\n            | BeingChecked -> Cancelled\n            | Cancelled -> Cancelled\n            | NeedChecking -> NeedChecking\n            | Checked -> NeedChecking)\n        else oldVersion, oldState))\n    |> debug \"[LanguageService] %s changed: set status to %A\" filePath\n\n\n  let fixFileName path =\n    if (try Path.GetFullPath path |> ignore; true with _ -> false) then path\n    else\n        match Environment.OSVersion.Platform with\n        | PlatformID.Unix\n        | PlatformID.MacOSX -> Environment.GetEnvironmentVariable \"HOME\"\n        | _ -> Environment.ExpandEnvironmentVariables \"%HOMEDRIVE%%HOMEPATH%\"\n        </> Path.GetFileName path\n\n  let isFSharpCore (s : string) = s.EndsWith \"FSharp.Core.dll\"\n\n\n  let ensureCorrectFSharpCore (options: string[]) =\n    Environment.fsharpCoreOpt\n    |> Option.map (fun path ->\n                   let fsharpCoreRef = sprintf \"-r:%s\" path\n                   [| yield fsharpCoreRef\n                      yield! options |> Seq.filter (not << isFSharpCore) |])\n    |> Option.getOrElse options\n\n  let ensureCorrectVersions (options: string[]) =\n    if Utils.runningOnMono then options\n    else\n      let replace = \n        if Environment.dotNetVersions () |> Seq.isEmpty then id else\n        let version = Environment.dotNetVersions () |> Seq.head\n        let oldRef = Environment.referenceAssembliesPath </> \"v4.0\"\n        let newRef = Environment.referenceAssembliesPath </> version\n        fun (s : string) -> s.Replace(oldRef, newRef)\n\n      let fsharpCoreRef = options |> Seq.find isFSharpCore\n\n      let newOptions =\n        options\n        |> Seq.filter (not << isFSharpCore)\n        |> Seq.map    replace\n      [| yield fsharpCoreRef\n         yield! newOptions |]\n\n  let chooseByPrefix prefix (s: string) =\n    if s.StartsWith(prefix) then Some (s.Substring(prefix.Length))\n    else None\n\n  let getDependingProjects file (options : seq<string * FSharpProjectOptions>) =\n    let project = options |> Seq.tryFind (fun (k,_) -> k = file)\n    project |> Option.map (fun (name, option) ->\n      [\n        yield! options\n               |> Seq.map snd\n               |> Seq.filter (fun o -> o.ReferencedProjects |> Array.map (fun (k,v) -> v.ProjectFileName) |> Array.contains option.ProjectFileName )\n        yield option\n      ])\n\n  member __.GetProjectOptionsFromScript(file, source) = async {\n    let! rawOptions, _ = checker.GetProjectOptionsFromScript(file, source)\n    let opts =\n      rawOptions.OtherOptions\n      |> ensureCorrectFSharpCore\n      |> ensureCorrectVersions\n\n    return { rawOptions with OtherOptions = opts }\n  }\n\n  member __.CheckProjectsInBackgroundForFile (file,options : seq<string * FSharpProjectOptions>) =\n    defaultArg (getDependingProjects file options) []\n    |> List.iter (checker.CheckProjectInBackground)\n\n  member __.ParseProjectsForFile(file, options : seq<string * FSharpProjectOptions> ) =\n    let project = options |> Seq.tryFind (fun (k,_) -> k = file)\n    match project with\n    | None -> async {return Failure \"Project for current file not found\"}\n    | Some (name, option) ->\n      async {\n        let projs = defaultArg (getDependingProjects file options) []\n        let! results =\n          projs\n          |> Seq.map checker.ParseAndCheckProject\n          |> Async.Parallel\n        let! currentResult =  checker.ParseAndCheckProject option\n        let res = [| yield currentResult; yield! results |]\n        return Success res\n      }\n\n  member __.GetBackgroundCheckResultsForFileInProject =\n    checker.GetBackgroundCheckResultsForFileInProject\n\n  member __.FileChecked =\n    checker.FileChecked\n\n  member __.ParseAndCheckFileInProject(filePath, version, source, options) =\n    async {\n      debug \"[LanguageService] ParseAndCheckFileInProject - enter\"\n      fileChanged filePath version\n      let fixedFilePath = fixFileName filePath\n      let! res = Async.Catch (async {\n          try\n               // wait until the previous checking completed\n               while files.ContainsKey filePath &&\n                     (match files.TryGetValue filePath with\n                      | true, (v, Checked)\n                      | true, (v, NeedChecking) ->\n                         files.[filePath] <- (v, BeingChecked)\n                         true\n                      | _ -> false) do\n                   do! Async.Sleep 20\n\n               debug \"[LanguageService] Change state for %s to `BeingChecked`\" filePath\n               debug \"[LanguageService] Parse and typecheck source...\"\n               return! checker.ParseAndCheckFileInProject (fixedFilePath, version, source, options, null) //TODO: Add cancelation again\n          finally\n               match files.TryGetValue filePath with\n               | true, (v, BeingChecked)\n               | true, (v, Cancelled) -> files.[filePath] <- (v, Checked)\n               | _ -> ()\n      })\n\n      debug \"[LanguageService]: Check completed\"\n      // Construct new typed parse result if the task succeeded\n      return\n          match res with\n          | Choice1Of2 x -> Success x\n          | Choice2Of2 e -> Failure e.Message\n    }\n\n  member __.TryGetRecentCheckResultsForFile(file, options, ?source) =\n    checker.TryGetRecentCheckResultsForFile(file, options, ?source=source)\n    |> Option.map (fun (pr, cr, _) -> ParseAndCheckResults (pr, cr))\n\n\n\n\n  member __.GetUsesOfSymbol (file, options : (SourceFilePath * FSharpProjectOptions) seq, symbol) = async {\n    let projects = getDependingProjects file options\n    return!\n      match projects with\n      | None -> async {return [||]}\n      | Some projects -> async {\n        let! res =\n          projects\n          |> Seq.map (fun (opts) -> async {\n              let! res = checker.ParseAndCheckProject opts\n              return! res.GetUsesOfSymbol symbol\n            })\n          |> Async.Parallel\n        return res |> Array.collect id }\n  }\n\n  member __.GetDeclarations (fileName, source, options, version) = async {\n    let! parseResult =\n      match checker.TryGetRecentCheckResultsForFile(fileName, options,source), version with\n      | Some (pr, _, v), Some ver when v = ver ->  async {return pr}\n      | _, None -> checker.ParseFileInProject(fileName, source, options)\n      | _ ->\n        async {\n          let! chkd =\n            checker.FileParsed\n            |> Event.filter (fun (fn,_) -> fn = fileName)\n            |> Async.AwaitEvent\n\n          return!\n            match checker.TryGetRecentCheckResultsForFile(fileName,options,source) with\n            | None -> checker.ParseFileInProject(fileName, source, options)\n            | Some (pr,_,_) -> async {return pr}\n        }\n    return parseResult.GetNavigationItems().Declarations\n  }\n\n  member __.GetDeclarationsInProjects (options : seq<string * FSharpProjectOptions>) =\n      options\n      |> Seq.distinctBy(fun (_, v) -> v.ProjectFileName)\n      |> Seq.map (fun (_, opts) -> async {\n          let! _ = checker.ParseAndCheckProject opts\n          return!\n            options\n            |> Seq.filter (fun (_, projectOpts) -> projectOpts = opts)\n            |> Seq.map (fun (projectFile,_) -> async {\n                let! parseRes, _ = checker.GetBackgroundCheckResultsForFileInProject(projectFile, opts)\n                return (parseRes.GetNavigationItems().Declarations |> Array.map (fun decl -> decl, projectFile))\n              })\n            |> Async.Parallel\n         })\n      |> Async.Parallel\n      |> Async.map (Seq.collect (Seq.collect id) >> Seq.toArray)\n\n\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"ad03c7ec-8dd8-4ed9-8e69-cfb36e93ddd3"},{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"}],"id":{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"},"expanded":true,"level":0,"properties":{}},{"name":"FileSystem","content":"\nopen Microsoft.FSharp.Compiler.AbstractIL.Internal.Library\nopen System\n\ntype VolatileFile =\n  { Touched: DateTime\n    Lines: string [] }\n\nopen System.IO\n\ntype FileSystem (actualFs: IFileSystem, tryFindFile: SourceFilePath -> VolatileFile option) =\n    let normalize = normalizePath\n    let getFile = normalize >> tryFindFile\n\n    let getContent (filename: string) =\n        filename \n        |> getFile\n        |> Option.map (fun file ->\n             System.Text.Encoding.UTF8.GetBytes (String.Join (\"\\n\", file.Lines)))\n\n    interface IFileSystem with\n        member __.FileStreamReadShim fileName =\n            getContent fileName\n            |> Option.map (fun bytes -> new MemoryStream (bytes) :> Stream)\n            |> Option.getOrElseFun (fun _ -> actualFs.FileStreamReadShim fileName)\n\n        member __.ReadAllBytesShim fileName =\n            getContent fileName\n            |> Option.getOrElseFun (fun _ -> actualFs.ReadAllBytesShim fileName)\n\n        member __.GetLastWriteTimeShim fileName =\n            getFile fileName\n            |> Option.map (fun x -> x.Touched)\n            |> Option.getOrElseFun (fun _ -> actualFs.GetLastWriteTimeShim fileName)\n\n        member __.GetTempPathShim() = actualFs.GetTempPathShim()\n        member __.FileStreamCreateShim file = file |> normalize |> actualFs.FileStreamCreateShim\n        member __.FileStreamWriteExistingShim file = file |> normalize |> actualFs.FileStreamWriteExistingShim\n        member __.GetFullPathShim file = file |> normalize |> actualFs.GetFullPathShim\n        member __.IsInvalidPathShim file = file |> normalize |> actualFs.IsInvalidPathShim\n        member __.IsPathRootedShim file = file |> normalize |> actualFs.IsPathRootedShim\n        member __.SafeExists file = file |> normalize |> actualFs.SafeExists\n        member __.FileDelete file = file |> normalize |> actualFs.FileDelete\n        member __.AssemblyLoadFrom file = file |> normalize |> actualFs.AssemblyLoadFrom\n        member __.AssemblyLoad assemblyName = actualFs.AssemblyLoad assemblyName","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"},"expanded":true,"level":0,"properties":{}},{"name":"State","content":"open System\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen System.Collections.Concurrent\n\ntype DeclName = string\n\ntype State =\n  {\n    Files : ConcurrentDictionary<SourceFilePath, VolatileFile>\n    FileCheckOptions : ConcurrentDictionary<SourceFilePath, FSharpProjectOptions>\n    HelpText : ConcurrentDictionary<DeclName, FSharpToolTipText>\n    mutable ColorizationOutput: bool\n  }\n\n  static member Initial =\n    { Files = ConcurrentDictionary()\n      FileCheckOptions = ConcurrentDictionary()\n      HelpText = ConcurrentDictionary()\n      ColorizationOutput = false }\n\n  member x.GetCheckerOptions(file: SourceFilePath, lines: LineStr[]) : FSharpProjectOptions option =\n    let file = Utils.normalizePath file\n\n    x.FileCheckOptions.TryFind file\n    |> Option.map (fun opts ->\n        x.Files.[file] <- { Lines = lines; Touched = DateTime.Now }\n        x.FileCheckOptions.[file] <- opts\n        opts\n    )\n\n  member x.AddFileTextAndCheckerOptions(file: SourceFilePath, lines: LineStr[], opts) =\n    let file = Utils.normalizePath file\n    let fileState = { Lines = lines; Touched = DateTime.Now }\n    x.Files.[file] <- fileState\n    x.FileCheckOptions.[file] <- opts\n\n  static member private FileWithoutProjectOptions(file) =\n    let opts=\n        defaultArg (Environment.fsharpCoreOpt  |> Option.map (fun path -> [| yield sprintf \"-r:%s\" path; yield \"--noframework\" |] )) [|\"--noframework\"|]\n\n    { ProjectFileName = file + \".fsproj\"\n      ProjectFileNames = [|file|]\n      OtherOptions = opts // \"--noframework\"\n      ReferencedProjects = [| |]\n      IsIncompleteTypeCheckEnvironment = true\n      UseScriptResolutionRules = false\n      LoadTime = DateTime.Now\n      UnresolvedReferences = None\n      OriginalLoadReferences = []\n      ExtraProjectInfo = None  }\n\n  member x.TryGetFileCheckerOptionsWithLines(file: SourceFilePath) : Result<FSharpProjectOptions * LineStr[]> =\n    let file = Utils.normalizePath file\n    match x.Files.TryFind(file) with\n    | None -> Failure (sprintf \"File '%s' not parsed\" file)\n    | Some (volFile) ->\n\n      match x.FileCheckOptions.TryFind(file) with\n      | None -> Success (State.FileWithoutProjectOptions(file), volFile.Lines)\n      | Some opts -> Success (opts, volFile.Lines)\n\n  member x.TryGetFileCheckerOptionsWithSource(file: SourceFilePath) : Result<FSharpProjectOptions * string> =\n    let file = Utils.normalizePath file\n    match x.TryGetFileCheckerOptionsWithLines(file) with\n    | Failure x -> Failure x\n    | Success (opts, lines) -> Success (opts, String.concat \"\\n\" lines)\n\n  member x.TryGetFileCheckerOptionsWithLinesAndLineStr(file: SourceFilePath, pos : Pos) : Result<FSharpProjectOptions * LineStr[] * LineStr> =\n    let file = Utils.normalizePath file\n    match x.TryGetFileCheckerOptionsWithLines(file) with\n    | Failure x -> Failure x\n    | Success (opts, lines) ->\n      let ok = pos.Line <= lines.Length && pos.Line >= 1 &&\n               pos.Col <= lines.[pos.Line - 1].Length + 1 && pos.Col >= 1\n      if not ok then Failure \"Position is out of range\"\n      else Success (opts, lines, lines.[pos.Line - 1])","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"}],"id":{"$":0,"Item":"032c8d14-697f-45c9-a306-1e0e3f275d72"},"expanded":true,"level":0,"properties":{}},{"name":"TipFormatter","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Xml.dll\"\n// --------------------------------------------------------------------------------------\n// (c) Tomas Petricek, http://tomasp.net/blog\n// --------------------------------------------------------------------------------------\nmodule TipFormatter =\n \n open System\n open System.IO\n open System.Xml\n open System.Text.RegularExpressions\n open Microsoft.FSharp.Compiler.SourceCodeServices\n \n // TODO: Improve this parser. Is there any other XmlDoc parser available?\n type private XmlDocMember(doc: XmlDocument) =\n   let nl = System.Environment.NewLine\n   let readContent (node: XmlNode) =\n     match node with\n     | null -> null\n     | _ ->\n         // Many definitions contain references like <paramref name=\"keyName\" /> or <see cref=\"T:System.IO.IOException\">\n     // Replace them by the attribute content (keyName and System.IO.Exception in the samples above)\n         Regex.Replace(node.InnerXml,\"\"\"<\\w+ \\w+=\"(?:\\w:){0,1}(.+?)\" />\"\"\", \"$1\")\n   let readChildren name (doc: XmlDocument) =\n     doc.DocumentElement.GetElementsByTagName name\n     |> Seq.cast<XmlNode>\n     |> Seq.map (fun node -> node.Attributes.[0].InnerText.Replace(\"T:\",\"\"), readContent node)\n     |> Map.ofSeq\n   let summary = readContent doc.DocumentElement.ChildNodes.[0]\n   let pars = readChildren \"param\" doc\n   let exceptions = readChildren \"exception\" doc\n   override x.ToString() =\n     summary + nl + nl +\n     (pars |> Seq.map (fun kv -> kv.Key + \": \" + kv.Value) |> String.concat nl) +\n     (if exceptions.Count = 0 then \"\"\n      else nl + nl + \"Exceptions:\" + nl +\n           (exceptions |> Seq.map (fun kv -> \"\\t\" + kv.Key + \": \" + kv.Value) |> String.concat nl))\n \n let rec private readXmlDoc (reader: XmlReader) (acc: Map<string,XmlDocMember>) =\n   let acc' =\n     match reader.Read() with\n     | false -> None\n     | true when reader.Name = \"member\" && reader.NodeType = XmlNodeType.Element ->\n       try\n         let key = reader.GetAttribute(\"name\")\n         use subReader = reader.ReadSubtree()\n         let doc = XmlDocument()\n         doc.Load(subReader)\n         acc |> Map.add key (XmlDocMember doc) |> Some\n       with\n       | _ -> Some acc\n     | _ -> Some acc\n   match acc' with\n   | None -> acc\n   | Some acc' -> readXmlDoc reader acc'\n \n let private getXmlDoc =\n   let xmlDocCache = System.Collections.Concurrent.ConcurrentDictionary<string, Map<string, XmlDocMember>>()\n   fun dllFile ->\n     let xmlFile = Path.ChangeExtension(dllFile, \".xml\")\n     if xmlDocCache.ContainsKey xmlFile then\n       Some xmlDocCache.[xmlFile]\n     else\n       let rec exists filePath tryAgain =\n         match File.Exists filePath, tryAgain with\n         | true, _ -> Some filePath\n         | false, false -> None\n         | false, true ->\n           // In Linux, we need to check for upper case extension separately\n           let filePath = Path.ChangeExtension(filePath, Path.GetExtension(filePath).ToUpper())\n           exists filePath false\n \n       match exists xmlFile true with\n       | None -> None\n       | Some actualXmlFile ->\n         // Prevent other threads from tying to add the same doc simultaneously\n         xmlDocCache.AddOrUpdate(xmlFile, Map.empty, fun _ _ -> Map.empty) |> ignore\n         try\n           use reader = XmlReader.Create actualXmlFile\n           let xmlDoc = readXmlDoc reader Map.empty\n           xmlDocCache.AddOrUpdate(xmlFile, xmlDoc, fun _ _ -> xmlDoc) |> ignore\n           Some xmlDoc\n         with _ ->\n           None  // TODO: Remove the empty map from cache to try again in the next request?\n \n // --------------------------------------------------------------------------------------\n // Formatting of tool-tip information displayed in F# IntelliSense\n // --------------------------------------------------------------------------------------\n let private buildFormatComment cmt =\n     match cmt with\n     | FSharpXmlDoc.Text s -> s\n     | FSharpXmlDoc.XmlDocFileSignature(dllFile, memberName) ->\n        match getXmlDoc dllFile with\n        | Some doc when doc.ContainsKey memberName -> string doc.[memberName]\n        | _ -> \"\"\n     | _ -> \"\"\n \n let formatTip (FSharpToolTipText tips) : (string * string) list list =\n     tips\n     |> List.choose (function\n         | FSharpToolTipElement.Single (it, comment) -> Some [it, buildFormatComment comment]\n         | FSharpToolTipElement.Group items ->\n             Some (items |> List.map (fun (it, comment) ->  (it, buildFormatComment comment)))\n         | FSharpToolTipElement.CompositionError (error) -> Some [(\"<Note>\", error)]\n         | _ -> None)\n \n let extractSignature (FSharpToolTipText tips) =\n    let getSignature (str: string) =\n        let nlpos = str.IndexOfAny([|'\\r';'\\n'|])\n        let firstLine =\n            if nlpos > 0 then str.[0..nlpos-1]\n            else str\n\n        if firstLine.StartsWith(\"type \", StringComparison.Ordinal) then\n            let index = firstLine.LastIndexOf(\"=\", StringComparison.Ordinal)\n            if index > 0 then firstLine.[0..index-1]\n            else firstLine\n        else firstLine\n\n    let firstResult x =\n         match x with\n         | FSharpToolTipElement.Single (t, _) when not (String.IsNullOrWhiteSpace t) -> Some t\n         | FSharpToolTipElement.Group gs -> List.tryPick (fun (t, _) -> if not (String.IsNullOrWhiteSpace t) then Some t else None) gs\n         | _ -> None\n\n    tips\n    |> Seq.tryPick firstResult\n    |> Option.map getSignature\n    |> Option.getOrElse \"\"","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"de1ff71b-1245-4eef-816d-975da9252207"},"expanded":true,"level":0,"properties":{}},{"name":"UnopenedNamespacesResolver","content":"/// Original code from VisualFSharpPowerTools project: https://github.com/fsprojects/VisualFSharpPowerTools/blob/master/src/FSharp.Editing/Coloring/UnopenedNamespacesResolver.fs\n//namespace FsAutoComplete.UnopenedNamespacesResolver\n\n//open FsAutoComplete.UntypedAstUtils\n\ntype LongIdent = string\n\n\ntype Entity =\n    { FullRelativeName: LongIdent\n      Qualifier: LongIdent\n      Namespace: LongIdent option\n      Name: LongIdent }\n    override x.ToString() = sprintf \"%A\" x\n\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Entity =\n    let getRelativeNamespace (targetNs: Idents) (sourceNs: Idents) =\n        let rec loop index =\n            if index > targetNs.Length - 1 then sourceNs.[index..]\n            // target namespace is not a full parent of source namespace, keep the source ns as is\n            elif index > sourceNs.Length - 1 then sourceNs\n            elif targetNs.[index] = sourceNs.[index] then loop (index + 1)\n            else sourceNs.[index..]\n        if sourceNs.Length = 0 || targetNs.Length = 0 then sourceNs\n        else loop 0\n\n    let cutAutoOpenModules (autoOpenParent: Idents option) (candidateNs: Idents) =\n        let nsCount =\n            match autoOpenParent with\n            | Some parent when parent.Length > 0 ->\n                min (parent.Length - 1) candidateNs.Length\n            | _ -> candidateNs.Length\n        candidateNs.[0..nsCount - 1]\n\n    let tryCreate (targetNamespace: Idents option, targetScope: Idents, partiallyQualifiedName: Idents,\n                   requiresQualifiedAccessParent: Idents option, autoOpenParent: Idents option,\n                   candidateNamespace: Idents option, candidate: Idents) =\n        match candidate with\n        | [||] -> [||]\n        | _ ->\n            partiallyQualifiedName\n            |> Array.heads\n            |> Array.choose (fun parts ->\n                if not (candidate |> Array.endsWith parts) then None\n                else\n                  let identCount = parts.Length\n                  let fullOpenableNs, restIdents =\n                      let openableNsCount =\n                          match requiresQualifiedAccessParent with\n                          | Some parent -> min parent.Length candidate.Length\n                          | None -> candidate.Length\n                      candidate.[0..openableNsCount - 2], candidate.[openableNsCount - 1..]\n\n                  let openableNs = cutAutoOpenModules autoOpenParent fullOpenableNs\n\n                  let getRelativeNs ns =\n                      match targetNamespace, candidateNamespace with\n                      | Some targetNs, Some candidateNs when candidateNs = targetNs ->\n                          getRelativeNamespace targetScope ns\n                      | None, _ -> getRelativeNamespace targetScope ns\n                      | _ -> ns\n\n                  let relativeNs = getRelativeNs openableNs\n\n                  match relativeNs, restIdents with\n                  | [||], [||] -> None\n                  | [||], [|_|] -> None\n                  | _ ->\n                      let fullRelativeName = Array.append (getRelativeNs fullOpenableNs) restIdents\n                      let ns =\n                          match relativeNs with\n                          | [||] -> None\n                          | _ when identCount > 1 && relativeNs.Length >= identCount ->\n                              Some (relativeNs.[0..relativeNs.Length - identCount] |> String.concat \".\")\n                          | _ -> Some (relativeNs |> String.concat \".\")\n                      let qualifier =\n                          if fullRelativeName.Length > 1 && fullRelativeName.Length >= identCount then\n                              fullRelativeName.[0..fullRelativeName.Length - identCount]\n                          else fullRelativeName\n                      Some\n                          { FullRelativeName = String.concat \".\" fullRelativeName //.[0..fullRelativeName.Length - identCount - 1]\n                            Qualifier = String.concat \".\" qualifier\n                            Namespace = ns\n                            Name = match restIdents with [|_|] -> \"\" | _ -> String.concat \".\" restIdents })\n\ntype ScopeKind =\n    | Namespace\n    | TopModule\n    | NestedModule\n    | OpenDeclaration\n    | HashDirective\n    override x.ToString() = sprintf \"%A\" x\n\ntype InsertContext =\n    { ScopeKind: ScopeKind\n      Pos: Pos }\n\nmodule ParsedInput =\n    open Microsoft.FSharp.Compiler\n    open Microsoft.FSharp.Compiler.Ast\n\n    type private EndLine = int\n\n    let getEntityKind (input: ParsedInput) (p: Pos) : EntityKind option =\n        let pos = Range.mkPos p.Line p.Col\n\n        let (|ConstructorPats|) = function\n            | Pats ps -> ps\n            | NamePatPairs(xs, _) -> List.map snd xs\n\n        let isPosInRange range = Range.rangeContainsPos range pos\n\n        let ifPosInRange range f =\n            if isPosInRange range then f()\n            else None\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.tryPick (walkSynModuleOrNamespace true) moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace isTopLevel (SynModuleOrNamespace(_, _, isModule, decls, _, attrs, _, r)) =\n            if isModule && isTopLevel then None else List.tryPick walkAttribute attrs\n            |> Option.orElseX (ifPosInRange r (fun _ -> List.tryPick (walkSynModuleDecl isTopLevel) decls))\n\n        and walkAttribute (attr: SynAttribute) =\n            if isPosInRange attr.Range then Some EntityKind.Attribute else None\n            |> Option.orElseX (walkExprWithKind (Some EntityKind.Type) attr.ArgExpr)\n\n        and walkTypar (Typar (ident, _, _)) = ifPosInRange ident.idRange (fun _ -> Some EntityKind.Type)\n\n        and walkTyparDecl (SynTyparDecl.TyparDecl (attrs, typar)) =\n            List.tryPick walkAttribute attrs\n            |> Option.orElseX (walkTypar typar)\n\n        and walkTypeConstraint = function\n            | SynTypeConstraint.WhereTyparDefaultsToType (t1, t2, _) -> walkTypar t1 |> Option.orElseX (walkType t2)\n            | SynTypeConstraint.WhereTyparIsValueType(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsReferenceType(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsUnmanaged(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparSupportsNull (t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsComparable(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsEquatable(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparSubtypeOfType(t, ty, _) -> walkTypar t |> Option.orElseX (walkType ty)\n            | SynTypeConstraint.WhereTyparSupportsMember(ts, sign, _) ->\n                List.tryPick walkType ts |> Option.orElseX (walkMemberSig sign)\n            | SynTypeConstraint.WhereTyparIsEnum(t, ts, _) -> walkTypar t |> Option.orElseX (List.tryPick walkType ts)\n            | SynTypeConstraint.WhereTyparIsDelegate(t, ts, _) -> walkTypar t |> Option.orElseX (List.tryPick walkType ts)\n\n        and walkPatWithKind (kind: EntityKind option) = function\n            | SynPat.Ands (pats, _) -> List.tryPick walkPat pats\n            | SynPat.Named(SynPat.Wild nameRange as pat, _, _, _, _) ->\n                if isPosInRange nameRange then None\n                else walkPat pat\n            | SynPat.Typed(pat, t, _) -> walkPat pat |> Option.orElseX (walkType t)\n            | SynPat.Attrib(pat, attrs, _) -> walkPat pat |> Option.orElseX (List.tryPick walkAttribute attrs)\n            | SynPat.Or(pat1, pat2, _) -> List.tryPick walkPat [pat1; pat2]\n            | SynPat.LongIdent(_, _, typars, ConstructorPats pats, _, r) ->\n                ifPosInRange r (fun _ -> kind)\n                |> Option.orElseX (\n                    typars\n                    |> Option.bind (fun (SynValTyparDecls (typars, _, constraints)) ->\n                        List.tryPick walkTyparDecl typars\n                        |> Option.orElseX (List.tryPick walkTypeConstraint constraints)))\n                |> Option.orElseX (List.tryPick walkPat pats)\n            | SynPat.Tuple(pats, _) -> List.tryPick walkPat pats\n            | SynPat.Paren(pat, _) -> walkPat pat\n            | SynPat.ArrayOrList(_, pats, _) -> List.tryPick walkPat pats\n            | SynPat.IsInst(t, _) -> walkType t\n            | SynPat.QuoteExpr(e, _) -> walkExpr e\n            | _ -> None\n\n        and walkPat = walkPatWithKind None\n\n        and walkBinding (SynBinding.Binding(_, _, _, _, attrs, _, _, pat, returnInfo, e, _, _)) =\n            List.tryPick walkAttribute attrs\n            |> Option.orElseX (walkPat pat)\n            |> Option.orElseX (walkExpr e)\n            |> Option.orElseX (\n                match returnInfo with\n                | Some (SynBindingReturnInfo (t, _, _)) -> walkType t\n                | None -> None)\n\n        and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) =\n            List.tryPick walkBinding bindings\n\n        and walkIndexerArg = function\n            | SynIndexerArg.One e -> walkExpr e\n            | SynIndexerArg.Two(e1, e2) -> List.tryPick walkExpr [e1; e2]\n\n        and walkType = function\n            | SynType.LongIdent ident -> ifPosInRange ident.Range (fun _ -> Some EntityKind.Type)\n            | SynType.App(ty, _, types, _, _, _, _) ->\n                walkType ty |> Option.orElseX (List.tryPick walkType types)\n            | SynType.LongIdentApp(_, _, _, types, _, _, _) -> List.tryPick walkType types\n            | SynType.Tuple(ts, _) -> ts |> List.tryPick (fun (_, t) -> walkType t)\n            | SynType.Array(_, t, _) -> walkType t\n            | SynType.Fun(t1, t2, _) -> walkType t1 |> Option.orElseX (walkType t2)\n            | SynType.WithGlobalConstraints(t, _, _) -> walkType t\n            | SynType.HashConstraint(t, _) -> walkType t\n            | SynType.MeasureDivide(t1, t2, _) -> walkType t1 |> Option.orElseX (walkType t2)\n            | SynType.MeasurePower(t, _, _) -> walkType t\n            | _ -> None\n\n        and walkClause (Clause(pat, e1, e2, _, _)) =\n            walkPatWithKind (Some EntityKind.Type) pat\n            |> Option.orElseX (walkExpr e2)\n            |> Option.orElseX (Option.bind walkExpr e1)\n\n        and walkExprWithKind (parentKind: EntityKind option) = function\n            | SynExpr.LongIdent (_, LongIdentWithDots(_, dotRanges), _, r) ->\n                match dotRanges with\n                | [] when isPosInRange r -> parentKind |> Option.orElseX (Some (EntityKind.FunctionOrValue false))\n                | firstDotRange :: _  ->\n                    let firstPartRange =\n                        Range.mkRange \"\" r.Start (Range.mkPos firstDotRange.StartLine (firstDotRange.StartColumn - 1))\n                    if isPosInRange firstPartRange then\n                        parentKind |> Option.orElseX (Some (EntityKind.FunctionOrValue false))\n                    else None\n                | _ -> None\n            | SynExpr.Paren (e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Quote(_, _, e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Typed(e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Tuple(es, _, _) -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.ArrayOrList(_, es, _) -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.Record(_, _, fields, r) ->\n                ifPosInRange r (fun _ ->\n                    fields |> List.tryPick (fun (_, e, _) -> e |> Option.bind (walkExprWithKind parentKind)))\n            | SynExpr.New(_, t, e, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.ObjExpr(ty, _, bindings, ifaces, _, _) ->\n                walkType ty\n                |> Option.orElseX (List.tryPick walkBinding bindings)\n                |> Option.orElseX (List.tryPick walkInterfaceImpl ifaces)\n            | SynExpr.While(_, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.For(_, _, e1, _, e2, e3, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2; e3]\n            | SynExpr.ForEach(_, _, _, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.ArrayOrListOfSeqExpr(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.CompExpr(_, _, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.Lambda(_, _, _, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.MatchLambda(_, _, synMatchClauseList, _, _) ->\n                List.tryPick walkClause synMatchClauseList\n            | SynExpr.Match(_, e, synMatchClauseList, _, _) ->\n                walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkClause synMatchClauseList)\n            | SynExpr.Do(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.Assert(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.App(_, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.TypeApp(e, _, tys, _, _, _, _) ->\n                walkExprWithKind (Some EntityKind.Type) e |> Option.orElseX (List.tryPick walkType tys)\n            | SynExpr.LetOrUse(_, _, bindings, e, _) -> List.tryPick walkBinding bindings |> Option.orElseX (walkExprWithKind parentKind e)\n            | SynExpr.TryWith(e, _, clauses, _, _, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkClause clauses)\n            | SynExpr.TryFinally(e1, e2, _, _, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.Lazy(e, _) -> walkExprWithKind parentKind e\n            | Sequentials es -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.IfThenElse(e1, e2, e3, _, _, _, _) ->\n                List.tryPick (walkExprWithKind parentKind) [e1; e2] |> Option.orElseX (match e3 with None -> None | Some e -> walkExprWithKind parentKind e)\n            | SynExpr.Ident ident -> ifPosInRange ident.idRange (fun _ -> Some (EntityKind.FunctionOrValue false))\n            | SynExpr.LongIdentSet(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotGet(e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotSet(e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotIndexedGet(e, args, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkIndexerArg args)\n            | SynExpr.DotIndexedSet(e, args, _, _, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkIndexerArg args)\n            | SynExpr.NamedIndexedPropertySet(_, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.DotNamedIndexedPropertySet(e1, _, e2, e3, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2; e3]\n            | SynExpr.TypeTest(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.Upcast(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.Downcast(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.InferredUpcast(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.InferredDowncast(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.AddressOf(_, e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.JoinIn(e1, _, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.YieldOrReturn(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.YieldOrReturnFrom(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.LetOrUseBang(_, _, _, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.DoBang(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.TraitCall (ts, sign, e, _) ->\n                List.tryPick walkTypar ts\n                |> Option.orElseX (walkMemberSig sign)\n                |> Option.orElseX (walkExprWithKind parentKind e)\n            | _ -> None\n\n        and walkExpr = walkExprWithKind None\n\n        and walkSimplePat = function\n            | SynSimplePat.Attrib (pat, attrs, _) ->\n                walkSimplePat pat |> Option.orElseX (List.tryPick walkAttribute attrs)\n            | SynSimplePat.Typed(pat, t, _) -> walkSimplePat pat |> Option.orElseX (walkType t)\n            | _ -> None\n\n        and walkField (SynField.Field(attrs, _, _, t, _, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkType t)\n\n        and walkValSig (SynValSig.ValSpfn(attrs, _, _, t, _, _, _, _, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkType t)\n\n        and walkMemberSig = function\n            | SynMemberSig.Inherit (t, _) -> walkType t\n            | SynMemberSig.Member(vs, _, _) -> walkValSig vs\n            | SynMemberSig.Interface(t, _) -> walkType t\n            | SynMemberSig.ValField(f, _) -> walkField f\n            | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (info, repr, memberSigs, _), _) ->\n                walkComponentInfo false info\n                |> Option.orElseX (walkTypeDefnSigRepr repr)\n                |> Option.orElseX (List.tryPick walkMemberSig memberSigs)\n\n        and walkMember = function\n            | SynMemberDefn.AbstractSlot (valSig, _, _) -> walkValSig valSig\n            | SynMemberDefn.Member(binding, _) -> walkBinding binding\n            | SynMemberDefn.ImplicitCtor(_, attrs, pats, _, _) ->\n                List.tryPick walkAttribute attrs |> Option.orElseX (List.tryPick walkSimplePat pats)\n            | SynMemberDefn.ImplicitInherit(t, e, _, _) -> walkType t |> Option.orElseX (walkExpr e)\n            | SynMemberDefn.LetBindings(bindings, _, _, _) -> List.tryPick walkBinding bindings\n            | SynMemberDefn.Interface(t, members, _) ->\n                walkType t\n                |> Option.orElseX (members |> Option.bind (List.tryPick walkMember))\n            | SynMemberDefn.Inherit(t, _, _) -> walkType t\n            | SynMemberDefn.ValField(field, _) -> walkField field\n            | SynMemberDefn.NestedType(tdef, _, _) -> walkTypeDefn tdef\n            | SynMemberDefn.AutoProperty(attrs, _, _, t, _, _, _, _, e, _, _) ->\n                List.tryPick walkAttribute attrs\n                |> Option.orElseX (Option.bind walkType t)\n                |> Option.orElseX (walkExpr e)\n            | _ -> None\n\n        and walkEnumCase (EnumCase(attrs, _, _, _, _)) = List.tryPick walkAttribute attrs\n\n        and walkUnionCaseType = function\n            | SynUnionCaseType.UnionCaseFields fields -> List.tryPick walkField fields\n            | SynUnionCaseType.UnionCaseFullType(t, _) -> walkType t\n\n        and walkUnionCase (UnionCase(attrs, _, t, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkUnionCaseType t)\n\n        and walkTypeDefnSimple = function\n            | SynTypeDefnSimpleRepr.Enum (cases, _) -> List.tryPick walkEnumCase cases\n            | SynTypeDefnSimpleRepr.Union(_, cases, _) -> List.tryPick walkUnionCase cases\n            | SynTypeDefnSimpleRepr.Record(_, fields, _) -> List.tryPick walkField fields\n            | SynTypeDefnSimpleRepr.TypeAbbrev(_, t, _) -> walkType t\n            | _ -> None\n\n        and walkComponentInfo isModule (ComponentInfo(attrs, typars, constraints, _, _, _, _, r)) =\n            if isModule then None else ifPosInRange r (fun _ -> Some EntityKind.Type)\n            |> Option.orElseX (\n                List.tryPick walkAttribute attrs\n                |> Option.orElseX (List.tryPick walkTyparDecl typars)\n                |> Option.orElseX (List.tryPick walkTypeConstraint constraints))\n\n        and walkTypeDefnRepr = function\n            | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.tryPick walkMember defns\n            | SynTypeDefnRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n            | SynTypeDefnRepr.Exception(_) -> None\n\n        and walkTypeDefnSigRepr = function\n            | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.tryPick walkMemberSig defns\n            | SynTypeDefnSigRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n            | SynTypeDefnSigRepr.Exception(_) -> None\n\n        and walkTypeDefn (TypeDefn (info, repr, members, _)) =\n            walkComponentInfo false info\n            |> Option.orElseX (walkTypeDefnRepr repr)\n            |> Option.orElseX (List.tryPick walkMember members)\n\n        and walkSynModuleDecl isTopLevel (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace isTopLevel fragment\n            | SynModuleDecl.NestedModule(info, _, modules, _, range) ->\n                walkComponentInfo true info\n                |> Option.orElseX (ifPosInRange range (fun _ -> List.tryPick (walkSynModuleDecl false) modules))\n            | SynModuleDecl.Open _ -> None\n            | SynModuleDecl.Let (_, bindings, _) -> List.tryPick walkBinding bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n            | SynModuleDecl.Types (types, _) -> List.tryPick walkTypeDefn types\n            | _ -> None\n\n        let res =\n            match input with\n            | ParsedInput.SigFile _ -> None\n            | ParsedInput.ImplFile input -> walkImplFileInput input\n        //debug \"%A\" ast\n        res\n\n    type Col = int\n\n    type Scope =\n        { Idents: Idents\n          Kind: ScopeKind }\n\n    let tryFindInsertionContext (currentLine: int) (ast: ParsedInput) =\n        let result: (Scope * Pos) option ref = ref None\n        let ns: string[] option ref = ref None\n        let modules = ResizeArray<Idents * EndLine * Col>()\n\n        let inline longIdentToIdents ident = ident |> Seq.map (fun x -> string x) |> Seq.toArray\n\n        let addModule (longIdent: LongIdent) endLine col =\n            modules.Add(longIdent |> List.map string |> List.toArray, endLine, col)\n\n        let doRange kind (scope: LongIdent) line col =\n            if line <= currentLine then\n                match !result with\n                | None ->\n                    result := Some ({ Idents = longIdentToIdents scope; Kind = kind }, Pos.make line col)\n                | Some (oldScope, oldPos) ->\n                    match kind, oldScope.Kind with\n                    | (Namespace | NestedModule | TopModule), OpenDeclaration\n                    | _ when oldPos.Line <= line ->\n                        result :=\n                            Some ({ Idents =\n                                        match scope with\n                                        | [] -> oldScope.Idents\n                                        | _ -> longIdentToIdents scope\n                                    Kind = kind },\n                                  Pos.make line col)\n                    | _ -> ()\n\n        let getMinColumn (decls: SynModuleDecls) =\n            match decls with\n            | [] -> None\n            | firstDecl :: _ ->\n                match firstDecl with\n                | SynModuleDecl.NestedModule (_, _, _, _, r) -> Some r\n                | SynModuleDecl.Let (_, _, r) -> Some r\n                | SynModuleDecl.DoExpr (_, _, r) -> Some r\n                | SynModuleDecl.Types (_, r) -> Some r\n                | SynModuleDecl.Exception (_, r) -> Some r\n                | SynModuleDecl.Open (_, r) -> Some r\n                | SynModuleDecl.HashDirective (_, r) -> Some r\n                | _ -> None\n                |> Option.map (fun r -> r.StartColumn)\n\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.iter (walkSynModuleOrNamespace []) moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace (parent: LongIdent) (SynModuleOrNamespace(ident, _, isModule, decls, _, _, _, range)) =\n            if range.EndLine >= currentLine then\n                match isModule, parent, ident with\n                | false, _, _ -> ns := Some (longIdentToIdents ident)\n                // top level module with \"inlined\" namespace like Ns1.Ns2.TopModule\n                | true, [], _f :: _s :: _ ->\n                    let ident = longIdentToIdents ident\n                    ns := Some (ident.[0..ident.Length - 2])\n                | _ -> ()\n\n                let fullIdent = parent @ ident\n\n                let startLine =\n                    if isModule then range.StartLine\n                    else range.StartLine - 1\n\n                let scopeKind =\n                    match isModule, parent with\n                    | true, [] -> TopModule\n                    | true, _ -> NestedModule\n                    | _ -> Namespace\n\n                doRange scopeKind fullIdent startLine range.StartColumn\n                addModule fullIdent range.EndLine range.StartColumn\n                List.iter (walkSynModuleDecl fullIdent) decls\n\n        and walkSynModuleDecl (parent: LongIdent) (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace parent fragment\n            | SynModuleDecl.NestedModule(ComponentInfo(_, _, _, ident, _, _, _, _), _, decls, _, range) ->\n                let fullIdent = parent @ ident\n                addModule fullIdent range.EndLine range.StartColumn\n                if range.EndLine >= currentLine then\n                    let moduleBodyIdentation = getMinColumn decls |> Option.getOrElse (range.StartColumn + 4)\n                    doRange NestedModule fullIdent range.StartLine moduleBodyIdentation\n                    List.iter (walkSynModuleDecl fullIdent) decls\n            | SynModuleDecl.Open (_, range) -> doRange OpenDeclaration [] range.EndLine (range.StartColumn - 5)\n            | SynModuleDecl.HashDirective (_, range) -> doRange HashDirective [] range.EndLine range.StartColumn\n            | _ -> ()\n\n        match ast with\n        | ParsedInput.SigFile _ -> ()\n        | ParsedInput.ImplFile input -> walkImplFileInput input\n\n        let res =\n            !result\n            |> Option.map (fun (scope, pos) ->\n                let ns = !ns |> Option.map longIdentToIdents\n                scope, ns, { pos with Line = pos.Line + 1 } )\n\n        let modules =\n            modules\n            |> Seq.filter (fun (_, endLine, _) -> endLine < currentLine)\n            |> Seq.sortBy (fun (m, _, _) -> -m.Length)\n            |> Seq.toList\n\n        fun (partiallyQualifiedName: Idents) (requiresQualifiedAccessParent: Idents option, autoOpenParent: Idents option,\n                                              entityNamespace: Idents option, entity: Idents) ->\n            match res with\n            | None -> [||]\n            | Some (scope, ns, pos) ->\n                Entity.tryCreate(ns, scope.Idents, partiallyQualifiedName, requiresQualifiedAccessParent,\n                                 autoOpenParent, entityNamespace, entity)\n                |> Array.map (fun e ->\n                    e,\n                    match modules |> List.filter (fun (m, _, _) -> entity |> Array.startsWith m ) with\n                    | [] -> { ScopeKind = scope.Kind; Pos = pos }\n                    | (_, endLine, startCol) :: _ ->\n                        //printfn \"All modules: %A, Win module: %A\" modules m\n                        let scopeKind =\n                            match scope.Kind with\n                            | TopModule -> NestedModule\n                            | x -> x\n                        { ScopeKind = scopeKind; Pos = Pos.make (endLine + 1) startCol })","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"},{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"}],"id":{"$":0,"Item":"76c26c6f-cd19-43a5-bcfb-751329719f87"},"expanded":true,"level":0,"properties":{}},{"name":"CompletionUtils","content":"open System\n\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open FsAutoComplete.UnopenedNamespacesResolver\n//open FSharpLint.Application\nmodule internal CompletionUtils =\n  let getIcon (glyph : FSharpGlyph) =\n    match glyph with\n    | FSharpGlyph.Class -> (\"Class\", \"C\")\n    | FSharpGlyph.Constant -> (\"Constant\", \"Cn\")\n    | FSharpGlyph.Delegate -> (\"Delegate\", \"D\")\n    | FSharpGlyph.Enum -> (\"Enum\", \"E\")\n    | FSharpGlyph.EnumMember -> (\"Property\", \"P\")\n    | FSharpGlyph.Event -> (\"Event\", \"e\")\n    | FSharpGlyph.Exception -> (\"Exception\", \"X\")\n    | FSharpGlyph.Field -> (\"Field\", \"F\")\n    | FSharpGlyph.Interface -> (\"Interface\", \"I\")\n    | FSharpGlyph.Method -> (\"Method\", \"M\")\n    | FSharpGlyph.OverridenMethod -> (\"Method\", \"M\")\n    | FSharpGlyph.Module -> (\"Module\", \"N\")\n    | FSharpGlyph.NameSpace -> (\"Namespace\", \"N\")\n    | FSharpGlyph.Property -> (\"Property\", \"P\")\n    | FSharpGlyph.Struct -> (\"Struct\", \"S\")\n    | FSharpGlyph.Typedef -> (\"Class\", \"C\")\n    | FSharpGlyph.Type -> (\"Type\", \"T\")\n    | FSharpGlyph.Union -> (\"Type\", \"T\")\n    | FSharpGlyph.Variable -> (\"Variable\", \"V\")\n    | FSharpGlyph.ExtensionMethod -> (\"Extension Method\", \"M\")\n    | FSharpGlyph.Error -> (\"Error\", \"E\")\n\n\n  let getEnclosingEntityChar = function\n    | FSharpEnclosingEntityKind.Namespace -> \"N\"\n    | FSharpEnclosingEntityKind.Module -> \"M\"\n    | FSharpEnclosingEntityKind.Class -> \"C\"\n    | FSharpEnclosingEntityKind.Exception -> \"E\"\n    | FSharpEnclosingEntityKind.Interface -> \"I\"\n    | FSharpEnclosingEntityKind.Record -> \"R\"\n    | FSharpEnclosingEntityKind.Enum -> \"En\"\n    | FSharpEnclosingEntityKind.DU -> \"D\"\n\n(*module internal CompletionUtils =\n  let map =\n    [ 0x0000,  (\"Class\", \"C\")\n      0x0003,  (\"Enum\", \"E\")\n      0x00012, (\"Struct\", \"S\")\n      0x00018, (\"Struct\", \"S\") (* value type *)\n      0x0002,  (\"Delegate\", \"D\")\n      0x0008,  (\"Interface\", \"I\")\n      0x000e,  (\"Module\", \"N\") (* module *)\n      0x000f,  (\"Namespace\", \"N\")\n      0x000c,  (\"Method\", \"M\")\n      0x000d,  (\"Extension Method\", \"M\") (* method2 ? *)\n      0x00011, (\"Property\", \"P\")\n      0x0005,  (\"Event\", \"e\")\n      0x0007,  (\"Field\", \"F\") (* fieldblue ? *)\n      0x0020,  (\"Field\", \"Fy\") (* fieldyellow ? *)\n      0x0001,  (\"Function\", \"Fc\") (* const *)\n      0x0004,  (\"Property\", \"P\") (* enummember *)\n      0x0006,  (\"Exception\", \"X\") (* exception *)\n      0x0009,  (\"Text File Icon\", \"t\") (* TextLine *)\n      0x000a,  (\"Regular File\", \"R\") (* Script *)\n      0x000b,  (\"Script\", \"s\") (* Script2 *)\n      0x0010,  (\"Tip of the day\", \"t\") (* Formula *);\n      0x00013, (\"Class\", \"C\") (* Template *)\n      0x00014, (\"Class\", \"C\") (* Typedef *)\n      0x00015, (\"Type\", \"T\") (* Type *)\n      0x00016, (\"Type\", \"T\") (* Union *)\n      0x00017, (\"Field\", \"V\") (* Variable *)\n      0x00019, (\"Class\", \"C\") (* Intrinsic *)\n      0x0001f, (\"Other\", \"o\") (* error *)\n      0x00021, (\"Other\", \"o\") (* Misc1 *)\n      0x0022,  (\"Other\", \"o\") (* Misc2 *)\n      0x00023, (\"Other\", \"o\") (* Misc3 *) ] |> Map.ofSeq\n\n  let getIcon glyph =\n    match map.TryFind (glyph / 6), map.TryFind (glyph % 6) with\n    | Some(s), _ -> s // Is the second number good for anything?\n    | _, _ -> (\"\", \"\")\n\n  let getEnclosingEntityChar = function\n    | FSharpEnclosingEntityKind.Namespace -> \"N\"\n    | FSharpEnclosingEntityKind.Module -> \"M\"\n    | FSharpEnclosingEntityKind.Class -> \"C\"\n    | FSharpEnclosingEntityKind.Exception -> \"E\"\n    | FSharpEnclosingEntityKind.Interface -> \"I\"\n    | FSharpEnclosingEntityKind.Record -> \"R\"\n    | FSharpEnclosingEntityKind.Enum -> \"En\"\n    | FSharpEnclosingEntityKind.DU -> \"D\"\n\n*)","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"76c26c6f-cd19-43a5-bcfb-751329719f87"},{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"},{"$":0,"Item":"de1ff71b-1245-4eef-816d-975da9252207"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"95c3cd5f-4472-4a86-9f2e-0ce0d99196e8"},"expanded":true,"level":0,"properties":{}},{"name":"CommandResponse","content":"#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule CommandResponse =","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"id":{"$":0,"Item":"0ab13bad-870c-464e-9bb2-9735b826746a"},"expanded":true,"level":0,"properties":{}},{"name":"CommandResponseTypes","content":"open Utils\n\ntype Location =\n  {\n    File: string\n    Line: int\n    Column: int\n  }\ntype CompletionResponse =\n  {\n    Name: string\n    ReplacementText: string\n    Glyph: string\n    GlyphChar: string\n  }\n//type ProjectResponse =\n//  {\n//    Project: ProjectFilePath\n//    Files: List<SourceFilePath>\n//    Output: string\n//    References: List<ProjectFilePath>\n//    Logs: Map<string, string>\n//  }\ntype OverloadDescription =\n  {\n    Signature: string\n    Comment: string\n  }\ntype OverloadParameter =\n  {\n    Name : string\n    CanonicalTypeTextForSorting : string\n    Display : string\n    Description : string\n  }\ntype Overload =\n  {\n    Tip : OverloadDescription list list\n    TypeText : string\n    Parameters : OverloadParameter list\n    IsStaticArguments : bool\n  }\ntype MethodResponse =\n  {\n    Name : string\n    CurrentParameter : int\n    Overloads : Overload list\n  }\ntype SymbolUseRange =\n  {\n    FileName: string\n    StartLine: int\n    StartColumn: int\n    EndLine: int\n    EndColumn: int\n    IsFromDefinition: bool\n    IsFromAttribute : bool\n    IsFromComputationExpression : bool\n    IsFromDispatchSlotImplementation : bool\n    IsFromPattern : bool\n    IsFromType : bool\n  }\ntype SymbolUseResponse =\n  {\n    Name: string\n    Uses: SymbolUseRange list\n  }\ntype HelpTextResponse =\n  {\n    Name: string\n    Overloads: OverloadDescription list list\n  }\ntype CompilerLocationResponse =\n  {\n    Fsc: string\n    Fsi: string\n    MSBuild: string\n  }\ntype FSharpErrorInfo =\n  {\n    FileName: string\n    StartLine:int\n    EndLine:int\n    StartColumn:int\n    EndColumn:int\n   // Severity:FSharpErrorSeverity\n    Message:string\n    Subcategory:string\n  }\ntype ErrorResponse =\n  {\n    File: string\n    Errors: FSharpErrorInfo []\n  }\ntype Colorization =\n  {\n    Range: Range\n    Kind: string\n  }\ntype Declaration =\n  {\n    UniqueName: string\n    Name: string\n    Glyph: string\n    GlyphChar: string\n    IsTopLevel: bool\n    Range     : Utils.Range\n    BodyRange : Utils.Range\n    File : string\n    EnclosingEntity: string\n    IsAbstract: bool\n  }\ntype DeclarationResponse = {\n    Declaration : Declaration;\n    Nested : Declaration []\n}\ntype OpenNamespace = {\n  Namespace : string\n  Name : string\n  Type : string\n  Line : int\n  Column : int\n  MultipleNames : bool\n}\ntype QualifySymbol = {\n  Name : string\n  Qualifier : string\n}\ntype ResolveNamespaceResponse = {\n  Opens : OpenNamespace []\n  Qualifies: QualifySymbol []\n  Word : string\n}\ntype UnionCaseResponse = {\n  Text : string\n  Position : Pos\n}\ntype Kind = \n| KInfo             of string\n| KError            of string\n| KHelpText         of HelpTextResponse\n| KCompletion       of CompletionResponse  []\n| KSymbolUse        of SymbolUseResponse\n| KHelp             of string\n| KMethod           of MethodResponse\n| KErrors           of ErrorResponse\n| KColorizations    of Colorization list\n| KFindDecl         of Location\n| KDeclarations     of DeclarationResponse []\n| KToolTip          of OverloadDescription []\n| KTypeSig          of string\n| KCompilerLocation of CompilerLocationResponse\n| KNamespaces       of ResolveNamespaceResponse\n| KUnionCase        of UnionCaseResponse\n| KMultiple         of Kind                []\n\ntype ACMessage =\n| ACMIdentification\n| ACMEcho      of string\n| ACMToolTip   of string * int * int\n| ACMToolTip2  of string * int * int *  string\n| ACMComplete  of string * int * int\n| ACMComplete2 of string * int * int *  string\n| ACMParse     of string * string    * (string * (int * int * int)) []\n| ACMMustParse of string * string\n","parent":{"$":0,"Item":"0ab13bad-870c-464e-9bb2-9735b826746a"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"id":{"$":0,"Item":"4f394f9e-3597-40dc-b5e0-4c89808dd0ae"},"expanded":true,"level":0,"properties":{}},{"name":"PostCommandResponse","content":"type FSharpErrorInfo  with\n    static member OfFSharpError(e:Microsoft.FSharp.Compiler.FSharpErrorInfo) =\n      {\n        FileName = e.FileName\n        StartLine = e.StartLineAlternate\n        EndLine = e.EndLineAlternate\n        StartColumn = e.StartColumn + 1\n        EndColumn = e.EndColumn + 1\n       // Severity = e.Severity\n        Message = e.Message\n        Subcategory = e.Subcategory\n      }\n\ntype Declaration with\n    static member OfDeclarationItem(e:FSharpNavigationDeclarationItem, fn) =\n      let (glyph, glyphChar) = CompletionUtils.getIcon e.Glyph \n      {\n        UniqueName = e.UniqueName\n        Name = e.Name\n        Glyph = glyph\n        GlyphChar = glyphChar\n        IsTopLevel = e.IsSingleTopLevel\n        Range     = { \n                      Range.StartLine   = e.Range    .StartLine  \n                      Range.StartColumn = e.Range    .StartColumn\n                      Range.EndLine     = e.Range    .EndLine    \n                      Range.EndColumn   = e.Range    .EndColumn\n                    }\n        BodyRange = {\n                      Range.StartLine   = e.BodyRange.StartLine  \n                      Range.StartColumn = e.BodyRange.StartColumn\n                      Range.EndLine     = e.BodyRange.EndLine    \n                      Range.EndColumn   = e.BodyRange.EndColumn\n                    }\n        File = fn\n        EnclosingEntity = CompletionUtils.getEnclosingEntityChar e.EnclosingEntityKind\n        IsAbstract = e.IsAbstract\n       }\n \nlet info  (s: string) = KInfo  s\nlet error (s: string) = KError s\nlet helpText (name: string, tip: FSharpToolTipText) =\n  let data = TipFormatter.formatTip tip |> List.map(List.map(fun (n,m) -> {Signature = n; Comment = m} ))\n  KHelpText { HelpTextResponse.Name = name; Overloads = data }\n//let project (serialize : Serializer) (projectFileName, projectFiles, outFileOpt, references, logMap) =\n//  let projectData =\n//    { Project = projectFileName\n//      Files = projectFiles\n//      Output = match outFileOpt with Some x -> x | None -> \"null\"\n//      References = List.sortBy IO.Path.GetFileName references\n//      Logs = logMap }\n//  serialize { Kind = \"project\"; Data = projectData }\nlet completion (decls: FSharpDeclarationListItem[]) includeKeywords =\n    KCompletion [|        for d in decls do\n                             let code = Microsoft.FSharp.Compiler.SourceCodeServices.PrettyNaming.QuoteIdentifierIfNeeded d.Name\n                             let (glyph, glyphChar) = CompletionUtils.getIcon d.Glyph\n                             yield {CompletionResponse.Name = d.Name; ReplacementText = code; Glyph = glyph; GlyphChar = glyphChar }\n                          if includeKeywords then\n                            for k in KeywordList.allKeywords do\n                              yield {CompletionResponse.Name = k; ReplacementText = k; Glyph = \"Keyword\"; GlyphChar = \"K\"}\n                        |]\nlet symbolUse (symbol: FSharpSymbolUse, uses: FSharpSymbolUse[]) =\n  let su =\n    { Name = symbol.Symbol.DisplayName\n      Uses =\n        [ for su in uses do\n            yield { StartLine = su.RangeAlternate.StartLine\n                    StartColumn = su.RangeAlternate.StartColumn + 1\n                    EndLine = su.RangeAlternate.EndLine\n                    EndColumn = su.RangeAlternate.EndColumn + 1\n                    FileName = su.FileName\n                    IsFromDefinition = su.IsFromDefinition\n                    IsFromAttribute = su.IsFromAttribute\n                    IsFromComputationExpression = su.IsFromComputationExpression\n                    IsFromDispatchSlotImplementation = su.IsFromDispatchSlotImplementation\n                    IsFromPattern = su.IsFromPattern\n                    IsFromType = su.IsFromType } ] |> Seq.distinct |> Seq.toList }\n  KSymbolUse su\nlet help (data : string) =\n  KHelp data\nlet methods (meth: FSharpMethodGroup, commas: int) =\n    KMethod {              Name = meth.MethodName\n                           CurrentParameter = commas\n                           Overloads =\n                            [ for o in meth.Methods do\n                               let tip = TipFormatter.formatTip o.Description |> List.map(List.map(fun (n,m) -> {Signature = n; Comment = m} ))\n                               yield {\n                                 Tip = tip\n                                 TypeText = o.TypeText\n                                 Parameters =\n                                   [ for p in o.Parameters do\n                                      yield {\n                                        Name = p.ParameterName\n                                        CanonicalTypeTextForSorting = p.CanonicalTypeTextForSorting\n                                        Display = p.Display\n                                        Description = \"\"//p.Description\n                                      }\n                                 ]\n                                 IsStaticArguments = not o.HasParameters\n                               }\n                            ]\n              }\nlet errors (errors: Microsoft.FSharp.Compiler.FSharpErrorInfo[], file: string) =\n  KErrors            { File = file\n                       Errors = Array.map FSharpErrorInfo.OfFSharpError errors }\nlet colorizations (colorizations: (Range.range * SemanticClassificationType)[]) =\n  // let data = [ for r, k in colorizations do\n  //                yield { Range = r; Kind = Enum.GetName(typeof<SemanticClassificationType>, k) } ]\n  KColorizations []  //TODO: Fix colorization\nlet findDeclaration (range: Range.range) =\n  let data = { Line = range.StartLine; Column = range.StartColumn + 1; File = range.FileName }\n  KFindDecl data\nlet declarations (decls : (FSharpNavigationTopLevelDeclaration * string) []) =\n   let decls' =\n    decls |> Array.map (fun (d, fn) ->\n      { Declaration = Declaration.OfDeclarationItem (d.Declaration, fn);\n        Nested = d.Nested |> Array.map ( fun a -> Declaration.OfDeclarationItem(a,fn))\n      })\n   KDeclarations decls'\nlet toolTip (tip) =\n  let data = TipFormatter.formatTip tip |> Seq.collect(List.map(fun (n,m) -> {Signature = n; Comment = m} )) |> Seq.toArray\n  KToolTip data\nlet typeSig (tip) =\n  let data = TipFormatter.extractSignature tip\n  KTypeSig data\nlet compilerLocation fsc fsi msbuild =\n  let data = { Fsi = fsi; Fsc = fsc; MSBuild = msbuild }\n  KCompilerLocation data\n//let message (serialize : Serializer) (kind: string, data: 'a) =\n//  serialize { Kind = kind; Data = data }\n//let lint (serialize : Serializer) (warnings : LintWarning.Warning list) =\n//  let data = warnings |> List.toArray\n//  serialize { Kind = \"lint\"; Data = data }\nlet resolveNamespace (word: string, opens : (string * string * InsertContext * bool) list, qualfies : (string * string) list) =\n  let ops =\n    opens\n    |> List.map (fun (ns, name, ctx, multiple) ->\n      {\n        Namespace = ns\n        Name = name\n        Type = ctx.ScopeKind.ToString()\n        Line = ctx.Pos.Line\n        Column = ctx.Pos.Column\n        MultipleNames = multiple\n      })\n    |> List.toArray\n  let quals =\n    qualfies\n    |> List.map (fun (name, q) ->\n      {\n        Name = name\n        Qualifier = q\n      })\n    |> List.toArray\n  let data = {\n    Opens = ops\n    Qualifies = quals\n    Word = word\n  }\n  KNamespaces  data\nlet unionCase (text : string) position =\n  let data = {\n    Text = text\n    Position = position\n  }\n  KUnionCase data\n","parent":{"$":0,"Item":"0ab13bad-870c-464e-9bb2-9735b826746a"},"predecessors":[{"$":0,"Item":"95c3cd5f-4472-4a86-9f2e-0ce0d99196e8"}],"id":{"$":0,"Item":"7fd7c0b3-84f5-4874-b926-e467a27b29b3"},"expanded":true,"level":0,"properties":{}},{"name":"Extensions","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\n\n\ntype FSharpSymbol with\n    member this.IsPrivateToFile =\n        match this with\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember\n        | :? FSharpEntity as m -> m.Accessibility.IsPrivate\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> m.Accessibility.IsPrivate\n        | :? FSharpField as m -> m.Accessibility.IsPrivate\n        | _ -> false\n\n    member this.IsInternalToProject =\n        match this with\n        | :? FSharpParameter -> true\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember || not m.Accessibility.IsPublic\n        | :? FSharpEntity as m -> not m.Accessibility.IsPublic\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> not m.Accessibility.IsPublic\n        | :? FSharpField as m -> not m.Accessibility.IsPublic\n        | _ -> false","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"id":{"$":0,"Item":"58592fc9-77d6-4563-8ebd-95aed86d0c82"},"expanded":true,"level":0,"properties":{}},{"name":"Commands","content":"open System\nopen System.IO\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open FSharpLint.Application\n//open FsAutoComplete.UnopenedNamespacesResolver\n//open FsAutoComplete.UnionPatternMatchCaseGenerator\n\n\nmodule Response = CommandResponse\n\ntype Commands () =\n    let checker = FSharpCompilerServiceChecker()\n    let state = State.Initial\n//    let fsharpLintConfig = ConfigurationManager.ConfigurationManager()\n\n    member private __.SerializeResultAsync (successToString: 'a -> Async<Response.Kind>, ?failureToString: string -> Response.Kind) =\n        Async.bind <| function\n            // A failure is only info here, as this command is expected to be\n            // used 'on idle', and frequent errors are expected.\n            | Result.Failure e -> async.Return ( (defaultArg failureToString Response.info) e )\n            | Result.Success r -> successToString r\n\n    member private x.SerializeResult (successToString: 'a -> Response.Kind, ?failureToString: string -> Response.Kind) =\n        x.SerializeResultAsync ((fun x -> successToString x |> async.Return), ?failureToString = failureToString)\n\n    member __.TryGetRecentTypeCheckResultsForFile = checker.TryGetRecentCheckResultsForFile\n    member __.TryGetFileCheckerOptionsWithLinesAndLineStr = state.TryGetFileCheckerOptionsWithLinesAndLineStr\n    member __.TryGetFileCheckerOptionsWithLines = state.TryGetFileCheckerOptionsWithLines\n    member __.Files = state.Files\n\n    member __.Parse file lines version = async {\n        let colorizations = state.ColorizationOutput\n        let parse' fileName (text:string) options =\n            async {\n                let! result = checker.ParseAndCheckFileInProject(fileName, version, text, options)\n                return\n                    match result with\n                    | Failure e -> Response.error e\n                    | Success (parseResult, checkResults) ->\n                        match checkResults with\n                        | FSharpCheckFileAnswer.Aborted -> Response.info \"Parse aborted\"\n                        | FSharpCheckFileAnswer.Succeeded results ->\n                            let errors = Array.append results.Errors parseResult.Errors\n                            if colorizations then\n                                 [| Response.errors        (errors, fileName)\n                                    Response.colorizations (results.GetSemanticClassification None) |] |> Response.KMultiple\n                            else Response.errors        (errors, fileName)                       \n            }\n        let file = Path.GetFullPath file\n        let text = String.concat \"\\n\" lines\n\n        if Utils.isAScript file then\n            let! checkOptions0 = checker.GetProjectOptionsFromScript(file, text)\n            let config    =\n                let n = text.IndexOf(\"\\n\")\n                if  n > 5 && text.StartsWith \"////-d:\" then text.Substring(4, n - 4) else \"\"\n            let  defines  = if config <> \"\" then config.Split ' ' else [||]\n            let  checkOptions = { checkOptions0 with OtherOptions = Array.append checkOptions0.OtherOptions defines }\n            //printfn \"%A\" checkOptions\n            state.AddFileTextAndCheckerOptions(file, lines, checkOptions)\n            return! parse' file text checkOptions\n        else\n            let! checkOptions =\n                match state.GetCheckerOptions(file, lines) with\n                | Some c -> async.Return c\n                | None -> async {\n                    let! checkOptions = checker.GetProjectOptionsFromScript(file, text)\n                    state.AddFileTextAndCheckerOptions(file, lines, checkOptions)\n                    return checkOptions\n                }\n            return! parse' file text checkOptions\n    }\n\n    member __.ParseAndCheckProjectsInBackgroundForFile file = async {\n        do checker.CheckProjectsInBackgroundForFile (file, state.FileCheckOptions.ToSeq() )\n        return Response.errors ([||], \"\")\n    }\n\n    member __.ParseProjectsForFile file = async {\n        let! res = checker.ParseProjectsForFile(file, state.FileCheckOptions.ToSeq())\n        return\n            match res with\n            | Failure e -> Response.error e\n            | Success results ->\n                let errors = results |> Array.collect (fun r -> r.Errors)\n                Response.errors (errors, file)\n    }\n\n    // member __.FileChecked =\n    //     checker.FileChecked\n    //     |> Event.map (fun fn ->\n    //         let file = Path.GetFullPath fn\n    //         let res = state.FileCheckOptions |> Seq.tryFind (fun kv -> Path.GetFullPath kv.Key = file)\n    //         match res with\n    //         | None  -> async { return Response.info ( sprintf \"Project for file not found: %s\" file)  }\n    //         | Some kv ->\n    //             async {\n    //                 let result= checker.TryGetRecentCheckResultsForFile(fn, kv.Value)\n    //                 return\n    //                     match result with\n    //                     | None     -> Response.info   \"File not parsed\"                  \n    //                     | Some res -> Response.errors (res.GetCheckResults.Errors, file) \n    //             })\n\n//    member __.Project projectFileName verbose onChange = async {\n//        let projectFileName = Path.GetFullPath projectFileName\n//        let project = state.Projects.TryFind projectFileName\n//\n//        let project = project |> Option.getOrElseFun (fun _ ->\n//            let project = new Project(projectFileName, onChange)\n//            state.Projects.[projectFileName] <- project\n//            project)\n//\n//        let (|NetCoreProjectJson|NetCoreSdk|Net45|Unsupported|) file =\n//            //.NET Core Sdk preview3+ replace project.json with fsproj\n//            //Easy way to detect new fsproj is to check the msbuild version of .fsproj\n//            //  MSBuild version 15 (`ToolsVersion=\"15.0\"`) is the new project format\n//            //Post preview5 has (`Sdk=\"FSharp.NET.Sdk;Microsoft.NET.Sdk\"`), use that\n//            //  for checking .NET Core fsproj. NB: casing of FSharp may be inconsistent.\n//            //The `dotnet-compile-fsc.rsp` are created also in `preview3+`, so we can\n//            //  reuse the same behaviour of `preview2`\n//            let rec getProjectType (sr:StreamReader) limit =\n//                // only preview3-5 uses ToolsVersion='15.0'\n//                // post preview5 dropped this, check Sdk field\n//                let isNetCore (line:string) = line.Contains(\"=\\\"15.0\\\"\") || line.ToLower().Contains(\"sdk=\")\n//                if limit = 0 then\n//                    Unsupported // unsupported project type\n//                else\n//                    let line = sr.ReadLine()\n//                    if not <| line.Contains(\"ToolsVersion\") && not <| line.Contains(\"Sdk=\") then\n//                        getProjectType sr (limit-1)\n//                    else // both net45 and preview3-5 have 'ToolsVersion', > 5 has 'Sdk'\n//                        if isNetCore line then NetCoreSdk else Net45\n//            if not <| File.Exists(projectFileName) then Net45 // no such file is handled downstream\n//            elif Path.GetExtension file = \".json\" then NetCoreProjectJson // dotnet core preview 2 or earlier\n//            else\n//                use sr = File.OpenText(file)\n//                getProjectType sr 3\n//\n//\n//        return\n//            match project.Response with\n//            | Some response -> response\n//            | None ->\n//                let options =\n//                    match projectFileName with\n//                    | NetCoreProjectJson -> checker.TryGetProjectJsonProjectOptions projectFileName\n//                    | NetCoreSdk -> checker.TryGetCoreProjectOptions projectFileName\n//                    | Net45 -> checker.TryGetProjectOptions (projectFileName, verbose)\n//                    | Unsupported -> checker.TryGetProjectOptions (projectFileName, verbose)\n//\n//                match options with\n//                | Result.Failure error ->\n//                    project.Response <- None\n//                    Response.error error\n//                | Result.Success (opts, projectFiles, outFileOpt, references, logMap) ->\n//                    let projectFiles = projectFiles |> List.map (Path.GetFullPath >> Utils.normalizePath)\n//                    let response = Response.project (projectFileName, projectFiles, outFileOpt, references, logMap)\n//                    for file in projectFiles do\n//                        state.FileCheckOptions.[file] <- opts\n//                    project.Response <- Some response\n//                    response\n//    }\n//\n    member __.Declarations file version = async {\n        let file = Path.GetFullPath file\n        match state.TryGetFileCheckerOptionsWithSource file with\n        | Failure s -> return Response.error s\n        | Success (checkOptions, source) ->\n            let! decls = checker.GetDeclarations(file, source, checkOptions, version)\n            let decls = decls |> Array.map (fun a -> a,file)\n            return Response.declarations decls\n    }\n\n    member __.DeclarationsInProjects () = async {\n        let! decls = checker.GetDeclarationsInProjects <| state.FileCheckOptions.ToSeq()\n        return Response.declarations decls\n    }\n\n    member __.Helptext sym =\n        match state.HelpText.TryFind sym with\n        | None     -> Response.error    (sprintf \"No help text available for symbol '%s'\" sym) \n        | Some tip -> Response.helpText (sym, tip                                            )\n\n    member __.CompilerLocation () = [Response.compilerLocation Environment.fsc Environment.fsi Environment.msbuild]\n    member __.Colorization enabled = state.ColorizationOutput <- enabled\n    member __.Error msg = Response.error msg\n\n    member __.Completion (tyRes : ParseAndCheckResults) (pos: Pos) lineStr filter includeKeywords = async {\n        let! res = tyRes.TryGetCompletions pos lineStr filter\n        return match res with\n                | Some (decls, residue) ->\n                    let declName (d: FSharpDeclarationListItem) = d.Name\n\n                    // Send the first helptext without being requested.\n                    // This allows it to be displayed immediately in the editor.\n                    let firstMatchOpt =\n                      Array.sortBy declName decls\n                      |> Array.tryFind (fun d -> (declName d).StartsWith(residue, StringComparison.InvariantCultureIgnoreCase))\n                    let res = match firstMatchOpt with\n                                | None   -> Response.completion decls includeKeywords     \n                                | Some d -> [| Response.helpText (d.Name, d.DescriptionText)\n                                               Response.completion decls includeKeywords     |] |> Response.KMultiple\n\n                    for decl in decls do\n                        state.HelpText.[ declName decl ] <- decl.DescriptionText\n                    res\n                | None -> Response.error \"Timed out while fetching completions\"\n    }\n\n    member x.ToolTip (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetToolTip pos lineStr |> x.SerializeResult Response.toolTip\n\n    member x.Typesig (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetToolTip pos lineStr |> x.SerializeResult Response.typeSig\n\n    member x.SymbolUse (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetSymbolUse pos lineStr |> x.SerializeResult Response.symbolUse\n\n    member x.Help (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetF1Help pos lineStr |> x.SerializeResult Response.help\n\n    member x.SymbolUseProject (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        let fn = tyRes.FileName\n        tyRes.TryGetSymbolUse pos lineStr |> x.SerializeResultAsync (fun (sym, usages) ->\n            async {\n                let fsym = sym.Symbol\n                if fsym.IsPrivateToFile then\n                    return Response.symbolUse (sym, usages)\n                elif fsym.IsInternalToProject then\n                    let opts = state.FileCheckOptions.[tyRes.FileName]\n                    let! symbols = checker.GetUsesOfSymbol (fn, [tyRes.FileName, opts] , sym.Symbol)\n                    return Response.symbolUse (sym, symbols)\n                else\n                    let! symbols = checker.GetUsesOfSymbol (fn, state.FileCheckOptions.ToSeq(), sym.Symbol)\n                    return Response.symbolUse (sym, symbols)\n            })\n\n    member x.FindDeclarations (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryFindDeclaration pos lineStr |> x.SerializeResult (Response.findDeclaration, Response.error)\n\n    member x.Methods (tyRes : ParseAndCheckResults) (pos: Pos) (lines: LineStr[]) =\n        tyRes.TryGetMethodOverrides lines pos |> x.SerializeResult (Response.methods, Response.error)\n\n//    member __.Lint (file: SourceFilePath) = async {\n//        let file = Path.GetFullPath file\n//        let res =\n//            match state.TryGetFileCheckerOptionsWithSource file with\n//            | Failure s -> Response.error s\n//            | Success (options, source) ->\n//                let tyResOpt = checker.TryGetRecentCheckResultsForFile(file, options)\n//\n//                match tyResOpt with\n//                | None -> Response.info \"Cached typecheck results not yet available\"\n//                | Some tyRes ->\n//                    match tyRes.GetAST with\n//                    | None -> Response.info \"Something went wrong during parsing\"\n//                    | Some tree ->\n//                        fsharpLintConfig.LoadConfigurationForProject file\n//                        let opts = fsharpLintConfig.GetConfigurationForProject (file)\n//                        let res =\n//                            Lint.lintParsedSource\n//                                { Lint.OptionalLintParameters.Default with Configuration = Some opts}\n//                                { Ast = tree\n//                                  Source = source\n//                                  TypeCheckResults = Some tyRes.GetCheckResults\n//                                  FSharpVersion = Version() }\n//                        let res' =\n//                            match res with\n//                            | LintResult.Failure _        -> Response.info \"Something went wrong during parsing\"\n//                            | LintResult.Success warnings -> Response.lint warnings                              \n//\n//                        res'\n//        return res\n//    }\n\n(*    member __.GetNamespaceSuggestions (tyRes : ParseAndCheckResults) (pos: Pos) (line: LineStr) = async {\n        match tyRes.GetAST with\n        | None -> return Response.info \"Parsed Tree not avaliable\"    \n        | Some parsedTree ->\n        match Parsing.findLongIdents(pos.Col, line) with\n        | None -> return Response.info \"Ident not found\"              \n        | Some (_,idents) ->\n        match ParsedInput.getEntityKind parsedTree pos with\n        | None -> return Response.info \"EntityKind not found\"         \n        | Some entityKind ->\n\n        let symbol = Lexer.getSymbol pos.Line pos.Col line SymbolLookupKind.Fuzzy [||]\n        match symbol with\n        | None -> return Response.info \"Symbol at position not found\" \n        | Some sym ->\n\n        let! entitiesRes = tyRes.GetAllEntities ()\n        match entitiesRes with\n        | None -> return Response.info \"Something went wrong\"         \n        | Some entities ->\n            let isAttribute = entityKind = EntityKind.Attribute\n            let entities =\n                entities |> List.filter (fun e ->\n                    match entityKind, (e.Kind LookupType.Fuzzy) with\n                    | EntityKind.Attribute, EntityKind.Attribute\n                    | EntityKind.Type, (EntityKind.Type | EntityKind.Attribute)\n                    | EntityKind.FunctionOrValue _, _ -> true\n                    | EntityKind.Attribute, _\n                    | _, EntityKind.Module _\n                    | EntityKind.Module _, _\n                    | EntityKind.Type, _ -> false)\n\n            let entities =\n                entities\n                |> List.collect (fun e ->\n                      [ yield e.TopRequireQualifiedAccessParent, e.AutoOpenParent, e.Namespace, e.CleanedIdents\n                        if isAttribute then\n                            let lastIdent = e.CleanedIdents.[e.CleanedIdents.Length - 1]\n                            if (e.Kind LookupType.Fuzzy) = EntityKind.Attribute && lastIdent.EndsWith \"Attribute\" then\n                                yield\n                                    e.TopRequireQualifiedAccessParent,\n                                    e.AutoOpenParent,\n                                    e.Namespace,\n                                    e.CleanedIdents\n                                    |> Array.replace (e.CleanedIdents.Length - 1) (lastIdent.Substring(0, lastIdent.Length - 9)) ])\n            let createEntity = ParsedInput.tryFindInsertionContext pos.Line parsedTree (idents |> List.toArray)\n            let word = sym.Text\n            let candidates = entities |> Seq.collect createEntity |> Seq.toList\n\n            let openNamespace =\n                candidates\n                |> Seq.choose (fun (entity, ctx) -> entity.Namespace |> Option.map (fun ns -> ns, entity.Name, ctx))\n                |> Seq.groupBy (fun (ns, _, _) -> ns)\n                |> Seq.map (fun (ns, xs) ->\n                    ns,\n                    xs\n                    |> Seq.map (fun (_, name, ctx) -> name, ctx)\n                    |> Seq.distinctBy (fun (name, _) -> name)\n                    |> Seq.sortBy fst\n                    |> Seq.toArray)\n                |> Seq.collect (fun (ns, names) ->\n                    let multipleNames = names |> Array.length > 1\n                    names |> Seq.map (fun (name, ctx) -> ns, name, ctx, multipleNames))\n                |> Seq.toList\n\n            let qualifySymbolActions =\n                candidates\n                |> Seq.map (fun (entity, _) -> entity.FullRelativeName, entity.Qualifier)\n                |> Seq.distinct\n                |> Seq.sort\n                |> Seq.toList\n\n            return Response.resolveNamespace (word, openNamespace, qualifySymbolActions) \n    }*)\n\n//    member __.GetUnionPatternMatchCases (tyRes : ParseAndCheckResults) (pos: Pos) (lines: LineStr[]) (line: LineStr) = async {\n//        let codeGenService = CodeGenerationService(checker, state)\n//        let doc = {\n//            Document.LineCount = lines.Length\n//            FullName = tyRes.FileName\n//            GetText = fun _ -> lines |> String.concat \"\\n\"\n//            GetLineText0 = fun i -> lines.[i]\n//            GetLineText1 = fun i -> lines.[i - 1]\n//        }\n//\n//        let! res = tryFindUnionDefinitionFromPos codeGenService pos doc\n//        match res with\n//        | None -> return Response.info \"Union at position not found\" \n//        | Some (symbolRange, patMatchExpr, unionTypeDefinition, insertionPos) ->\n//\n//        if shouldGenerateUnionPatternMatchCases patMatchExpr unionTypeDefinition then\n//            let result = formatMatchExpr insertionPos \"$1\" patMatchExpr unionTypeDefinition\n//            let pos = {\n//                Col = insertionPos.InsertionPos.Column\n//                Line = insertionPos.InsertionPos.Line\n//            }\n//            return Response.unionCase result pos                    \n//        else\n//            return Response.info      \"Union at position not found\" \n//    }","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"ad03c7ec-8dd8-4ed9-8e69-cfb36e93ddd3"},{"$":0,"Item":"7fd7c0b3-84f5-4874-b926-e467a27b29b3"},{"$":0,"Item":"4f394f9e-3597-40dc-b5e0-4c89808dd0ae"},{"$":0,"Item":"58592fc9-77d6-4563-8ebd-95aed86d0c82"},{"$":0,"Item":"032c8d14-697f-45c9-a306-1e0e3f275d72"},{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"}],"id":{"$":0,"Item":"1002c4bd-6116-45e3-9982-e1b0b4b01ec8"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoCompleteDll","content":"open CommandResponse\nopen Useful\n\ntype FsAutoCompleteErr =\n    | ``Code has not been parsed, use Parse F#``\n    | ``This snippet has not been previosuly parsed, use Parse F#``\n    | ``Cached typecheck results not yet available``\n    | ``Error FileCheckerOptions`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = match this with | msg -> sprintf \"%A\" msg\n        member this.IsWarning = false    \n        \n/// this converts from Result to Rop.Result\nlet fromResult' f = \n    function \n    | Failure s  -> Result.fail <| f s\n    | Success v  -> Result.succeed v\n\ntype Responder() =\n    let commands = Commands()\n    let starts : Map<string, Map<string, int * int * int>> ref = ref Map.empty\n    \n    let getDelta fname snpIdO =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file = System.IO.Path.GetFullPath fname\n            match snpIdO with\n            | Some snpId -> let! fileMap          = (!starts) |> Map.tryFind file         |> Result.fromOption ``Code has not been parsed, use Parse F#``\n                            let! ind, first, last = fileMap   |> Map.tryFind snpIdO.Value |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n                            return file, first, ind\n            | None       -> return file, 0    , 0 \n        }\n    let mustParse fname snpId =\n        getDelta fname (Some snpId)\n        |> Wrap.map              (fun _ -> false)\n        |> Wrap.RunSynchronously \n        |> Result.withError      (fun _ -> true )\n\n    let getTyRes (getHint: ParseAndCheckResults->Pos->string->Async<Kind>) fname ln col (snpIdO:string option) =\n        Wrap.wrapper {\n            let! file, dln, dcol = getDelta fname snpIdO\n            let  pos             = Pos.make (ln + dln) (col + dcol)\n            let! prj , ls , l    = commands.TryGetFileCheckerOptionsWithLinesAndLineStr(file, pos) |>        fromResult' ``Error FileCheckerOptions``\n            let! tyRes           = commands.TryGetRecentTypeCheckResultsForFile        (file, prj) |> Result.fromOption  ``Cached typecheck results not yet available``\n            let! res             = getHint tyRes pos l \n            return res\n        } \n        |> Wrap.RunSynchronously\n        |> Result.withError (Result.getMessages >> CommandResponse.KError)\n\n    let getCompletion tyRes pos (l:string) = commands.Completion tyRes pos l (Some \"Contains\") false\n        \n    member this.Respond (msg:CommandResponse.ACMessage) =\n        match msg with\n        | ACMIdentification              -> KInfo \"FSAutoComplete\"\n        | ACMEcho   txt                  -> KInfo txt \n        | ACMMustParse(fname, snpId    ) -> mustParse fname snpId |> sprintf \"%b\" |> KInfo\n        | ACMParse    (fname, code, sts) ->\n            async {\n                let  file = System.IO.Path.GetFullPath (fname)\n                do   starts := !starts |> Map.add file (Map sts)\n                let! errors = commands.Parse file (code.Split '\\n' |> Array.filter (fun l -> l.StartsWith \"# 1 @\" |> not)) 0\n                let  fixedErrors =\n                    match errors with\n                    | KErrors ers -> \n                          KErrors { ers with \n                                      Errors = ers.Errors \n                                      |> Array.map (fun err ->\n                                          sts \n                                          |> Array.tryFind (fun (snpNm, (ind, first, last)) -> err.StartLine >= first && err.StartLine < last)\n                                          |> Option.map    (fun (snpNm, (ind, first, last)) -> \n                                              { err with FileName    = snpNm\n                                                         StartLine   = err.StartLine   - first\n                                                         EndLine     = err.EndLine     - first\n                                                         StartColumn = err.StartColumn - ind\n                                                         EndColumn   = err.EndColumn   - ind   }) \n                                          |> Option.defaultValue err)\n                                  } \n                    | _ -> errors\n                return fixedErrors\n            }\n            |> Async.RunSynchronously\n        | ACMToolTip (fname, ln, col)         -> getTyRes commands.ToolTip fname ln col None\n        | ACMToolTip2(fname, ln, col, snpId)  -> getTyRes commands.ToolTip fname ln col (Some snpId)\n        | ACMComplete (fname, ln, col)        -> getTyRes getCompletion    fname ln col None\n        | ACMComplete2(fname, ln, col, snpId) -> getTyRes getCompletion    fname ln col (Some snpId)\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"1002c4bd-6116-45e3-9982-e1b0b4b01ec8"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"54872ed7-1c82-422c-8869-1852b98102c9"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoComplete","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n\nopen WebSharper\nopen WebSharper.Remoting\nopen CommandResponse\nopen Useful\n\nlet msgClient = FsStationShared.MessagingClient(\"FSAutoComplete\")\n\nopen FsStationShared\n\n#if JUSTCHECKING\n#else\n[< EntryPoint >]\n#endif\nlet main args =\n    let responder = Responder()\n\n    let respond (fromId) msg = \n        printfn \"%s\" <| extract 100 (sprintf \"%A\" msg)\n        responder.Respond msg\n        |> fun r -> printfn \"%A\" r ; r\n\n    let respondMessage fromId (msg:string) : string =\n        respond fromId (Json.Deserialize<CommandResponse.ACMessage> msg) \n        |> Json.Serialize\n\n    msgClient.AwaitMessage respondMessage\n    stdout.WriteLine(\"Listening {0}\", msgClient.ClientId)\n    stdin.ReadLine() |> ignore    \n    0\n    ","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"54872ed7-1c82-422c-8869-1852b98102c9"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"7a655466-e218-4121-a7b6-f9c70a922e07"},{"$":0,"Item":"ad03c7ec-8dd8-4ed9-8e69-cfb36e93ddd3"},{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"}],"id":{"$":0,"Item":"971e9b81-6e5d-4f11-a604-f87504d7c950"},"expanded":true,"level":0,"properties":{}},{"name":"Program (not used)","content":"//#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen Microsoft.FSharp.Compiler\n\nmodule internal Main =\n  open System.Collections.Concurrent\n\n  let originalFs = AbstractIL.Internal.Library.Shim.FileSystem\n  let writeJson = sprintf \"%A\"\n  let commands = Commands writeJson\n  let fs = new FileSystem(originalFs, commands.Files.TryFind)\n  AbstractIL.Internal.Library.Shim.FileSystem <- fs\n  //let commandQueue = new BlockingCollection<Command>(10)\n\n  let main () : int =\n    let mutable quit = false\n\n    while not quit do\n      async {\n          match commandQueue.Take() with\n          | Parse (file, kind, lines) ->\n              let! res = commands.Parse file lines 0\n              //Hack for tests\n              let r = match kind with\n                      | Synchronous -> Response.info writeJson \"Synchronous parsing started\"\n                      | Normal -> Response.info writeJson \"Background parsing started\"\n              return r :: res\n\n          | Project (file, verbose) ->\n              return! commands.Project file verbose (fun fullPath -> commandQueue.Add(Project (fullPath, verbose)))\n          | Declarations file -> return! commands.Declarations file None\n          | HelpText sym -> return commands.Helptext sym\n          | PosCommand (cmd, file, lineStr, pos, _timeout, filter) ->\n              let file = Path.GetFullPath file\n              match commands.TryGetFileCheckerOptionsWithLines file with\n              | Failure s -> return [Response.error writeJson s]\n              | Success options ->\n                  let projectOptions, lines = options\n                  let ok = pos.Line <= lines.Length && pos.Line >= 1 &&\n                           pos.Col <= lineStr.Length + 1 && pos.Col >= 1\n                  if not ok then\n                      return [Response.error writeJson \"Position is out of range\"]\n                  else\n                    // TODO: Should sometimes pass options.Source in here to force a reparse\n                    //       for completions e.g. `(some typed expr).$`\n                    let tyResOpt = commands.TryGetRecentTypeCheckResultsForFile(file, projectOptions)\n                    match tyResOpt with\n                    | None -> return [ Response.info writeJson \"Cached typecheck results not yet available\"]\n                    | Some tyRes ->\n                        return!\n                            match cmd with\n                            | Completion -> commands.Completion tyRes pos lineStr filter false\n                            | ToolTip -> commands.ToolTip tyRes pos lineStr\n                            | TypeSig -> commands.Typesig tyRes pos lineStr\n                            | SymbolUse -> commands.SymbolUse tyRes pos lineStr\n                            | FindDeclaration -> commands.FindDeclarations tyRes pos lineStr\n                            | Methods -> commands.Methods tyRes pos lines\n                            | SymbolUseProject -> commands.SymbolUseProject tyRes pos lineStr\n\n          | CompilerLocation -> return commands.CompilerLocation()\n          | Colorization enabled -> commands.Colorization enabled; return []\n          | Lint filename -> return! commands.Lint filename\n          | Error msg -> return commands.Error msg\n          | Quit ->\n              quit <- true\n              return []\n      }\n      |> Async.Catch\n      |> Async.RunSynchronously\n      |> function\n         | Choice1Of2 res -> res |> List.iter Console.WriteLine\n         | Choice2Of2 exn ->\n            exn\n            |> sprintf \"Unexpected internal error. Please report at https://github.com/fsharp/FsAutoComplete/issues, attaching the exception information:\\n%O\"\n            |> Response.error writeJson\n            |> Console.WriteLine\n    0\n\n  [<EntryPoint>]\n  let entry args =\n    System.Threading.ThreadPool.SetMinThreads(8, 8) |> ignore\n    Console.InputEncoding <- Text.Encoding.UTF8\n    Console.OutputEncoding <- new Text.UTF8Encoding(false, false)\n    let extra = Options.p.Parse args\n    if extra.Count <> 0 then\n      printfn \"Unrecognised arguments: %s\" (String.concat \",\" extra)\n      1\n    else\n      try\n        async {\n          while true do\n            commandQueue.Add (CommandInput.parseCommand(Console.ReadLine()))\n        }\n        |> Async.Start\n\n        main()\n      finally\n        (!Debug.output).Close()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"1002c4bd-6116-45e3-9982-e1b0b4b01ec8"},{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"},{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"}],"id":{"$":0,"Item":"6653d6a0-75e7-4116-bce2-620df1f2c31a"},"expanded":true,"level":0,"properties":{}},{"name":"FSAutoCompleteClient","content":"open Useful\nopen FsStationShared\nopen CommandResponse\nopen WebSharper\nopen WebSharper.Remoting\n#if FSS_SERVER\n#r @\"Compiled\\FsAutoCompleteDll\\FsAutoCompleteDll.dll\"\n\nlet responder = FSSGlobal.FSAutoComplete.Responder()\n\n[< Rpc >]\nlet sendMessageRpc msg = async { return responder.Respond msg }\n\n[<WebSharper.JavaScript>]\nlet sendMessage  (msg:ACMessage) : Async<Kind> = \n    async {\n        let!   res = sendMessageRpc (msg |> box |> unbox)\n        return res                       |> box |> unbox\n    }\n#endif\n\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\ntype FSAutoCompleteClient(clientId, ?endPoint:string) =\n     #if FSS_SERVER\n     #else\n     let msgClient = MessagingClient(clientId, ?endPoint = endPoint)\n     let toId      = AddressId \"FSAutoComplete\"\n     let sendMessage (msg:ACMessage) =\n         Wrap.wrapper {\n             let! resp = msgClient.SendMessage toId (Json.Serialize msg)\n             let  acr  = resp |> Json.Deserialize<CommandResponse.Kind>\n             return acr\n         } |> Wrap.getAsyncWithDefault (Result.getMessages >> CommandResponse.KError)\n     #endif\n     let Async_map f aa = \n         async { \n             let! a = aa\n             return f a\n         }\n     let rec comp2Strings comp =\n         match comp with \n         | KCompletion cs -> cs |> Array.map (fun cs -> cs.Name, cs.ReplacementText, cs.Glyph, cs.GlyphChar)\n         | KHelpText   _  -> [||]\n         | KMultiple   ks -> ks |> Array.collect comp2Strings \n         | m              -> [| sprintf \"%A\" m, \"\", \"ErrorMsg\", \"E\" |] \n     let tip2String tip =\n         match tip with \n         | KToolTip ts -> ts |> Seq.collect (fun t -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let errors2String errs =\n         match errs with \n         | KErrors  es -> \n             es.Errors \n             |> Seq.map (fun er -> sprintf \"ErrFSharp \\\"F# %s.fsx (%d,%d) - (%d,%d) %s:%s\\\"\" \n                                      er.FileName er.StartLine er.StartColumn er.EndLine er.EndColumn er.Subcategory er.Message) \n             |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let info2Bool inf =\n         match inf with\n         | KInfo \"true\" -> true\n         | _            -> false\n        \n   with\n     member this.MustParse(fname,            sId) = sendMessage (ACMMustParse(fname,             sId)) |> Async_map info2Bool\n     member this.Parse    (fname, txt , sts     ) = sendMessage (ACMParse    (fname, txt , sts      )) |> Async_map errors2String\n     member this.Parse    (fname, txt           ) = sendMessage (ACMParse    (fname, txt , [||]     )) |> Async_map errors2String\n     member this.ToolTip  (fname, line, col     ) = sendMessage (ACMToolTip  (fname, line, col      )) |> Async_map tip2String\n     member this.ToolTip  (fname, line, col, sId) = sendMessage (ACMToolTip2 (fname, line, col , sId)) |> Async_map tip2String\n     member this.Complete (fname, line, col     ) = sendMessage (ACMComplete (fname, line, col      )) |> Async_map comp2Strings\n     member this.Complete (fname, line, col, sId) = sendMessage (ACMComplete2(fname, line, col , sId)) |> Async_map comp2Strings\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"4f394f9e-3597-40dc-b5e0-4c89808dd0ae"},{"$":0,"Item":"eb54ba64-3d11-4347-97c8-aeae9e3e3121"}],"id":{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},"expanded":true,"level":0,"properties":{}},{"name":"Snippets","content":"module Snippets =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false,"level":0,"properties":{}},{"name":"","content":"let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true,"level":0,"properties":{}},{"name":"Free Monad","content":"(**\nFree Monad - Interpreter pattern in F#\n================================\n\nAn analysis of the Free Monad - Interpreter pattern in F# from a definition\ncreated by erdeszt and based on: http://programmers.stackexchange.com/a/242803/145941\n\nThe DSL\n-------\n\nFirst we define a DSL for our actions. Each action points to the next action using the `'next` generic type, \nevery action has a `'next` that in turn could be a DSL, thus chaining them.\n*)\ntype DSL<'next> =\n    | Set of key: string * value: string *  'next\n    | Get of key: string *       (string -> 'next)\n(** \n* `Get` returns a string which is passed to a function. `id` function can be used to finish the chain.\n* `Set` doesn't return anything, so the `'next` portion is the next DSL element in the chain, or a constant like `()` to finish.\n\nNote that used this way `'next` can be anything. It does not have to be a DSL value, so there is no real implication of a chain of DSLs.\n\nThis is what 3 actions in the DSL may look like.\n*)\nlet ex1 = Set (\"name\", \"John\"\n             , Get (\"name\"\n                  , fun name -> Set (\"greeting\", sprintf \"Hello %s\" name, () )\n                   )\n              )\n(**\n`val ex1 : DSL<DSL<DSL<unit>>> =\n  Set (\"name\",\"John\",Get (\"name\",<fun:ex1@23-4>))`\n\nNotice how the resulting type `DSL<DSL<DSL<unit>>>` is nested and not generic. \nThis means a strongly type function cannot process all posible values.\n\nThe Free Monad\n--------------\n\nHere comes the Free Monad `ChainDSL` to the rescue.\n*)\n\ntype ChainDSL<'a> =\n    | Do     of DSL<ChainDSL<'a>>\n    | Return of 'a\n\n(**\nThe `Do` option creates a chain of `ChainDSL`s that ends with the `Return` option.\nThis chain ends up having a type equal to the last `DSL` in the chain.\nThis is almost like creating a `List` of `DSL`s (`List<DSL<'a>> or DSL<'a> list`), \nexcept that each `DSL` in the chain can be of a different type.\n\nLets look at the same value above with `ChainDSL`:\n*)\n\nlet exF1 = Do (Set (\"name\", \"John\"\n                  , Do (Get (\"name\"\n                           , fun name -> Do (Set (\"greeting\", sprintf \"Hello %s\" name, Return () )) \n                            )\n                       )\n                   )\n              )\n(**\n`val exF1 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:exF1@49-3>))))`\n\nCompare the resulting type with the prior case: `ChainDSL<unit>` vs `DSL<DSL<DSL<unit>>>`.\nNo matter how deep the chain is, the value will always be of type `ChainDSL<unit>` or `ChainDSL<string>`.\n\n\nBut creating the chain is much more complex than before.\nTo solve that, lets create two helper functions: get and set.\n*)\nlet get key       = Do (Get (key, fun value -> Return value))\nlet set key value = Do (Set (key,     value,   Return ()   ))    \n(**\n`val get : key:string -> ChainDSL<string>`\n\n`val set : key:string -> value:string -> ChainDSL<unit>`\n\nNotice `get` returns a `ChainDSL<string>` and `set` returns a `ChainDSL<unit>`.\nThey both return a `ChainDSL` chain with a single `DSL` action.\n\nWith these functions we can create Get & Set operations like this:\n*)\nlet setName     name = set \"name\"     name\nlet getName          = get \"name\"\nlet setGreeting name = set \"greeting\" (sprintf \"Hello %s\" name)\n(**\nbut they are not chained together like before.\n\nBinding it together\n-------------------\n\nTo chain them we will need to define a bind function for the ChainDSL.\nWe start with a map function for DSL, thus making DSL a functor:\n*)\nlet mapDSL: ('a -> 'b) -> DSL<'a> -> DSL<'b> = \n    fun     f             action  ->\n        match action with\n        | Get (key,        fNext) -> Get (key,        fNext >> f)\n        | Set (key, value,  next) -> Set (key, value,  next |> f)\n\n(**\nAll `mapDSL` does is apply the function `f` to the `'next` part of the `DSL`.\nIn other words go to the next node in the chain.\n\nNext we define the bind function for ChainDSL, finally making it a monad:\n*)\nlet bindChain: ('a -> ChainDSL<'b>) -> ChainDSL<'a> -> ChainDSL<'b> =\n    fun        fChain                  chainTo      ->\n        let rec appendTo chain =\n            match chain with\n            | Return a   -> fChain a\n            | Do     dsl -> Do (mapDSL appendTo dsl)\n        appendTo chainTo\n(** \n`bindChain` is similar and acts like the List.append function, it concatenates two chains of `ChainDSL`s. \nThe difference is that the chain to be appended `fChain` is passed within a function.\n`bindChain` navigates recursively down `chainTo` and replaces the last element with the result of `fChain`:\n\n* On the `Do` side `bindChain` calls `mapDSL` to apply the function to the next `ChainDSL` node.\n* On the `Return` side it replaces the 'Return a' for a call to the chain to be appended `fChain`.\n\nIn a sense `ChainDSL` is actually the opposite of a `List<DSL<'a>>`. In a List new elements are\ninserted at the head, here they are attached at the tail end.\n\nNow we can bind setName, getName & setResult from above like this: *)\n\nlet exF2 = setName \"John\" \n           |> bindChain (fun _    -> getName         )\n           |> bindChain (fun name -> setGreeting name)\n\n(** \n`val exF2 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nwhich is the same as this: *)\n\nlet exF3 = set \"name\" \"John\" \n           |> bindChain (fun _ -> get \"name\"                           )\n           |> bindChain (fun v -> set \"greeting\" (sprintf \"Hello %s\" v))\n(** \n`val exF3 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nand this: *)\nlet (>>=) v f = bindChain f v\n\nlet exF4 = set \"name\" \"John\" \n           >>= fun _    -> get \"name\" \n           >>= fun name -> set \"greeting\" (sprintf \"Hello %s\" name)\n(**\n`val exF4 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nUsing Computational Expressions\n-------------------------------\n\nNow lets try it with Computational Expressions.\nFirst we define a builder class.\n*)\n\ntype ChainDSLBuilder () =\n    member this.Return      v = Return v\n    member this.ReturnFrom mv = mv\n    member this.Zero       () = Return ()\n    member this.Bind   (v, f) = v >>= f\n\nlet chainDSL = ChainDSLBuilder ()\n\n(**\nAnd now we use the computational expression like this.\n*)\n\nlet exF5 = chainDSL {\n    do!         set \"name\"     \"John\"\n    let! name = get \"name\"\n    do!         set \"greeting\" (sprintf \"Hello %s\" name)\n}\n(**\n`val exF5 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nThe Interpreter(s)\n------------------\n  \nNow we are going to create an interpreter to execute the AST created.\n\nThis first version is very simple it does not store or retrieve any values, just prints out the commands.\n*)\n(*** define-output:interpreter1 ***)    \nlet rec interpreter1: ChainDSL<'a> -> 'a =\n    fun               chain        ->\n        match chain with\n        | Return v -> printfn \"return %A\" v\n                      v\n        | Do   dsl -> \n            match dsl with\n            | Get(key,        nextF) -> printfn \"Get %s\" key\n                                        nextF (sprintf \"<get.%s>\" key) \n            | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                        next                           \n            |> interpreter1\n\ninterpreter1 exF5\n(*** include-output:interpreter1 ***)\n(**\nThis next version actually stores and retrieves the values in a `Map` object, and when finished prints its content. \n*)\n(*** define-output:interpreter2 ***)    \nlet interpreter2 chain = \n    let rec interpreter2r: Map<string, string> -> ChainDSL<'a> -> 'a =\n        fun                dataStore              chain        ->\n            match chain with\n            | Return v -> printfn \"return %A\\n%A\" v dataStore\n                          v\n            | Do   dsl -> \n                match dsl with\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n\n    interpreter2r (Map.ofList []) chain\n\ninterpreter2 exF5\n(*** include-output:interpreter2 ***)\n\n(**\nA slightly longer example:\n*)\n\n(*** define-output:interpreter2b ***)    \n\nchainDSL {\n    do!           set \"first-name\" \"John\"\n    do!           set \"last-name\"  \"Smith\"\n    let! first  = get \"first-name\"\n    let! last   = get \"last-name\"\n    do!           set \"full-name\" (first + \" \"  + last)\n    let! full   = get \"full-name\"\n    return        sprintf \"Hello %s\" full\n}\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2b ***)\n(** Return value:*)\n(*** include-it:interpreter2b ***)\n(**\nTrying to replicate this last example without the computational expression \nrequires explicitly nesting some of the calls.\n\nIt would look like this:\n\n*)\n(*** define-output:interpreter2c ***)    \n\nset \"first-name\" \"John\" \n>>= fun _     -> set \"last-name\"  \"Smith\"            \n>>= fun _     -> get \"first-name\"                    \n>>= fun first -> get \"last-name\" \n                 >>= fun last -> set \"full-name\" (first + \" \"  + last)\n>>= fun _     -> get \"full-name\"\n>>= fun full  -> Return (sprintf \"Hello %s\" full)\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2c ***)\n(** Return value:*)\n(*** include-it:interpreter2c ***)\n\n(**\nTwo in one\n----------\n\nSo, do we really need two types, the Free Monad and the DSL?\n\nI do not think it is necessary, the free monad helps in binding the elements of the DSL. \nThe same can be achieved just by adding the `Return` option to the DSL.\n\nHere is the same implementation with just the DSL type:\n*)\n\nmodule DSL2 =\n    type DSL<'a> =\n        | Set of key: string * value: string *  DSL<'a>\n        | Get of key: string *       (string -> DSL<'a>)\n        | Return of 'a\n    \n    let set key value = Set (key, value,          Return ())\n    let get key       = Get (key,        fun v -> Return v )\n    \n    let bind: ('a -> DSL<'b>) -> DSL<'a> -> DSL<'b> =\n        fun   fChain             chainTo ->\n           let rec appendTo chain =\n               match chain with\n               | Set (k, v,  next) -> Set (k, v,  next |> appendTo)\n               | Get (k,    fNext) -> Get (k,    fNext >> appendTo)\n               | Return  v         -> fChain v\n           appendTo chainTo\n\n    let (>>=) v f = bind f v\n\n    let interpreter2 dsl =\n        let rec interpreter2r: Map<string, string> -> DSL<'a> -> 'a =\n            fun                dataStore              dslR    ->\n                match dslR with\n                | Return v               -> printfn \"return %A\\n%A\" v dataStore\n                                            v\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n        interpreter2r (Map.ofList []) dsl\n\n(**\nThere you have it the DSL definition, helper functions, the bind function and the interpreter.\nHere is the last example again.\n*)\n(*** define-output:dsl2 ***)    \n\n    set \"first-name\" \"John\" \n    >>= fun _     -> set \"last-name\"  \"Smith\"            \n    >>= fun _     -> get \"first-name\"                    \n    >>= fun first -> get \"last-name\" \n                     >>= fun last -> set \"full-name\" (first + \" \"  + last)\n    >>= fun _     -> get \"full-name\"\n    >>= fun full  -> Return (sprintf \"Hello %s\" full)\n    |> interpreter2\n(** Output:*)\n(*** include-output:dsl2 ***)\n(** Return value:*)\n(*** include-it:dsl2 ***)    \n(*** hide ***)\ninterpreter2 exF1\ninterpreter2 exF2\ninterpreter2 exF3\ninterpreter2 exF4\ninterpreter2 exF5\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},"expanded":true,"level":0,"properties":{}},{"name":"UNLOAD FSI","content":"#define UNLOAD_FSI\n\n#if WEBSHARPER\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\nopen WebSharper\n[< JavaScript >]\n#endif\nlet a = 9 + 8\n\n7 * 3\n|> printfn \"%A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true,"level":0,"properties":{}},{"name":"Substring, Regex","content":"let extract n (s:string) = s.Substring(0, min n s.Length)\nlet s = \"1234567890123456789012345678901234567890\"\nprintfn \"%s\" <| extract 100 s\n\nopen System\nprintfn \"%s\" <| System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nopen UsefulDotNet\n//Example:\nlet phone = \"(555) 555-5555\"\nmatch phone with\n| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n| _ -> printfn \"Not a phone number\"\n\nlet code = \"let a = \\\"123\\\" |> St\"\nmatch code with\n| Regex @\"([a-zA-Z_]\\w+)$\" [ txt ] -> printfn \"%s\" txt\n| _                                -> printfn \"<No match>\"\n\nlet line = \" hello how \\\"are you\\\" good \\\"and you\\\"\"\nmatch line with \n| Regexs \"(\\\".*?\\\"|\\S+)\" ms -> \n    ms \n    |> Seq.iter\n        (function | Regex \"(\\\"(.*?)\\\")\" [_ ; m] | m -> printfn \"%A\" m)\n//| Regex \"(\\\"([^\\\"]*)\\\"|\\S*)*\" r -> printfn \"%A\" r\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"7646acbc-2c28-4159-98b1-2365d19fc97c"}],"id":{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},"expanded":true,"level":0,"properties":{}},{"name":"Stack Overflow","content":"let rec recursive i = 1 + recursive i\nrecursive 1","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true,"level":0,"properties":{}},{"name":"Calculate primes","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\n#if INTERACTIVE\nlet main =\n#else\n[< EntryPoint ; STAThread >]\nlet main args =\n#endif\n    Application.EnableVisualStyles()\n    let form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    panel1.DockPadding.All <- 10\n    let spacing = 5\n    let button1 = new Button(Text = \"Start\")\n    let button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\n    let button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\n    let updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                         Value = 20m,\n                                                         Minimum = 0m,\n                                                         Maximum = 1000000m)\n    let label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                            Width = 300, Height = 2 * button1.Height)\n    let progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                      Width = 300)\n    panel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\n    form.Controls.Add(panel1)\n    button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n    button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n    button3.Click.Add(fun args -> Async.CancelDefaultToken())\n    form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n#if INTERACTIVE\n    form.ShowDialog() |> ignore\n#else\n    form |> Application.Run\n#endif\n    0\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true,"level":0,"properties":{}},{"name":"Form test and Messaging","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\n\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value   = 20m     ,\n                                                     Minimum = 0m      ,\n                                                     Maximum = 1000000m)\n\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1    \n   button2    \n   button3    \n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start\n\n//open CIPHERPrototype.Messaging\nopen Useful\nopen FsStationShared\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n#nowarn \"1125\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\nlet fsClient = FsStationClient(\"ButtonTest\")\n\nbutton1.Click.Add (fun args ->                                                      \n    Wrap.wrapper {\n        let! response = fsClient.GenericMessage \"Hello\"\n        label1.Text <- response\n    } |> Wrap.Start\n)\n\n//let requestCode (snpName:string) = \n//    async {\n//        let! response = sendRequestRpc toId fromId (snpName.Split '/' |> GetSnippetCode |> Json.Serialize)\n//        let resp =\n//            match response |> Json.Deserialize<FSResponse> with\n//            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n//            | StringResponse (Some code)    -> code\n//            | IdResponse     (AddressId id) -> id.ToString()\n//            | _                             -> sprintf \"<Incomplete response: %s>\" response\n//        return resp\n//    }    \n//\n//open Rop\n//Wrap.wrapper {\n//    let! code   = requestCode \"module FSharpStationMD   =/Evaluate F# Code/module Snippets =/Calculate primes\"\n//    let! result = processCode (compileCode \"TESTCODE\") code\n//    result |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> printfn \"%s\"\n//} |> Wrap.getAsyncR |> Async.Start\n\nlet respondMessage fromId (msg:string) : string =\n    label1.Text <- msg\n    match msg |> Json.Deserialize<FSMessage> with\n    | GenericMessage        txt  -> label1.Text <- txt\n                                    StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fromId \n    | _                          -> StringResponse <| (Some <| \"Message received: \" + msg)\n    |> Json.Serialize\n\nfsClient.MessagingClient.AwaitMessage respondMessage\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},"expanded":true,"level":0,"properties":{}},{"name":"JSON Serializer","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\n//open CIPHERPrototype.Messaging\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\n\ntype FSMessage =\n    | GetSnippetContentById of string //CodeSnippetId\n    | GetSnippetCodeById    of string //CodeSnippetId\n    | GetSnippetById        of string //CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of string //CodeSnippet option\n    | StringResponse    of string option\n    | IdResponse        of CIPHERPrototype.Messaging.AddressId\n\nGenericMessage \"Hello\" \n|> Json.ServerSideProvider.GetEncoder().Encode\n|> Json.ServerSideProvider.Pack\n|> printfn \"%A\"\n\ntype Response = {\n    ``$TYPES`` : string[]\n    ``$DATA``  : string\n}\n\n\"\"\"{\"$TYPES\":[],\"$DATA\":\"{\\\"$\\\":1,\\\"Item\\\":\\\"Message received: Hello\\\"}\"}\"\"\"\n|> Json.Deserialize<Response>\n|> (fun r -> r.``$DATA``)\n|> Json.Deserialize<FSResponse>\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"System.IO.File.Delete(@\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\EPFileX\\CodeEditor.fsx.bak\")","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let rand = System.Random()\nlet randomNumbers = seq { while true do yield rand.Next(100) }\nlet firstTenRandomNumbers =\n randomNumbers\n |> Seq.truncate 10\n |> Seq.toList\n \nprintfn \"%+A\" firstTenRandomNumbers  \n//printfn \"%t\" (fun w -> w.WriteLine 6)  \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},"expanded":true,"level":0,"properties":{}},{"name":"Failed to load argument type","content":"#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\n\n[< JavaScript >]\ntype AddressId = AddressId of string\n\n[< Rpc >]\nlet sendRequest  (toId:AddressId) =\n        async {\n            return \"HELLO\"\n        }\n\n[< JavaScript >]\nlet tried() =\n    let f = AddressId \"XXX\"\n    let v = sendRequest f\n    (f, v)\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},"expanded":true,"level":0,"properties":{}},{"name":"Rules Alea","content":"let accounts =\n  [|\n    \"30\", \"Net Income After M. I. & Taxes \"\n    \"35\", \"Income (Loss) before Taxes \"\n    \"36\", \"Income (Loss) before taxes and M.I. \"\n    \"37\", \"Income from Continuing Operations \"\n    \"38\", \"Operating Income/(Loss) \"\n    \"39\", \"Actual Gross Income \"\n    \"300\", \"Total Net Revenue \"\n    \"301\", \"Orders Available to Ship \"\n    \"310\", \"Total Projected Sales Orders \"\n    \"320\", \"Plus:Orders In Backlog \"\n    \"350\", \"Less:Proj. Ending Backlog \"\n    \"360\", \"Non Interco Revenue \"\n    \"370\", \"Interco Revenue \"\n    \"400\", \"Cost of Goods Sold-Actual \"\n    \"401\", \"Memo Only:Inventory Receipts \"\n    \"402\", \"Memo Only:Interco inventory \"\n    \"410\", \"Cost of Goods Sold \"\n    \"430\", \"Standard COGS-Non Interco \"\n    \"440\", \"Standard COGS-Interco \"\n    \"500\", \"Total Mfg./Distr. Variances \"\n    \"510\", \"Purchase Price/Freight/Reclass \"\n    \"520\", \"Material Usage \"\n    \"530\", \"Inventory Adjustment \"\n    \"540\", \"Labor Performance/Rate \"\n    \"580\", \"Overhead Variance \"\n    \"5800\", \"Overhead Spending \"\n    \"5810\", \"Bonus Accrual for Overhead \"\n    \"5820\", \"Less:Overhead Absorption \"\n    \"40\", \"Actual Gross Margin %   \"\n    \"41\", \"Plan Gross Margin %  \"\n    \"60\", \"Total Expenses \"\n    \"610\", \"Engineering \"\n    \"620\", \"Sales \"\n    \"630\", \"General & Administrative \"\n    \"640\", \"ESOP/401K Contributions \"\n    \"650\", \"Bonus Accrual \"\n    \"660\", \"Warranty Expense-Total \"\n    \"700\", \"Total Non-Operating Income/(Expense) \"\n    \"710\", \"Other Income \"\n    \"720\", \"JV Profit Allocation \"\n    \"730\", \"Other (Expense) \"\n    \"740\", \"Management Fees \"\n    \"750\", \"Interest (Expense)/Income \"\n    \"810\", \"Inventory Disposal Program \"\n    \"910\", \"Minority Interest \"\n    \"920\", \"Federal State Other Income Tax \"\n    \"31\", \"P.A.T. % \"\n    \"32\", \"PLAN INCOME AFTER TAXES & M.I. \"\n    \"33\", \"$ VARIANCE TO PLAN \"\n    \"Cash Flow Statement\", \"Cash Flow Statement \"\n    \"C1\", \"Projected Ending Loan Balance \"\n    \"C10\", \"Beginning Loan Balance \"\n    \"C20\", \"NET PROJECTED CASH + (-) \"\n    \"C201\", \"Other Items- \"\n    \"C202\", \"Other Income \"\n    \"C203\", \"JV Profit Allocation \"\n    \"C204\", \"Other Expense \"\n    \"C205\", \"Management Fees \"\n    \"C206\", \"Capital Additions & Investments \"\n    \"C207\", \"Interest (Expense)/Income \"\n    \"C208\", \"Note principal payments \"\n    \"C209\", \"Other State & Fed Taxes \"\n    \"C210\", \"Tax Distributions to Holdings \"\n    \"C211\", \"Tax Dist. to Other Shareholders \"\n    \"C212\", \"Non-Tax Distributions to Holdings \"\n    \"C213\", \"Non-Tax Dist. to Other Shareholders \"\n    \"C30\", \"Net Cash Flow from Operations \"\n    \"C31\", \"= Gross Cash Inflow(Outflow) \"\n    \"C310\", \"= Net Collections \"\n    \"C311\", \"Gross Collections \"\n    \"C312\", \"Less Core Credits \"\n    \"C321\", \"Payments \"\n    \"C322\", \"Materials \"\n    \"C323\", \"Less Warranty Recovery \"\n    \"C324\", \"Freight Payments \"\n    \"C325\", \"Direct Labor \"\n    \"C326\", \"Overhead Spending \"\n    \"C33\", \"Total Expenses \"\n    \"C331\", \"Engineering \"\n    \"C332\", \"Sales \"\n    \"C333\", \"General & Administrative \"\n    \"C334\", \"ESOP/401K Contributions \"\n    \"C335\", \"Bonus Payments \"\n    \"C336\", \"Gross Warranty Payments \"\n    \"C39\", \"Add back: Depreciation \"\n    \"C2\", \"PLAN Loan Balance \"\n    \"C3\", \"$ VARIANCE TO PLAN (under) \"\n    \"Return On Assets\", \"Return On Assets \"\n    \"R10\", \"Opinion ROA (annualized) \"\n    \"R11\", \"Year End ROA Plan \"\n    \"R5\", \"Year End Net Income Plan \"\n    \"R100\", \"Net Income Calculations \"\n    \"R3\", \"YTD Comparison to Plan \"\n    \"R1\", \"Total Net Income (opinion & YTD) \"\n    \"R110\", \"Last Month Projected Net Income YTD \"\n    \"R120\", \"This Month Opinion Net Income \"\n    \"R2\", \"Net Income YTD Plan \"\n    \"R4\", \"Annualized Projected - Actual, Opinion & Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Earnings\", \"Earnings \"\n    \"E1\", \"EBITDA Dollar Calculations \"\n    \"E2\", \"EBITDA YTD Opinion to Plan (worse) \"\n    \"E20\", \"Annualized Projected  \"\n    \"E21\", \"Total EBITDA Dollars (opinion & YTD) \"\n    \"E22\", \"Projected Last Month EBITDA YTD \"\n    \"E23\", \"This Month Opinion EBITDA Dollars \"\n    \"E231\", \"This Month-- Profit Before Tax and M.I. \"\n    \"E232\", \"This Month-- Interest \"\n    \"E233\", \"This Month-- Depreciation/Amortization \"\n    \"E24\", \"EBITDA Plan Remaining Year \"\n    \"E25\", \"Annual EBITDA Dollars -- FROM PLAN \"\n    \"E3\", \"EBITDA Month Opinion to Plan (worse) \"\n    \"E30\", \"Plan EBITDA Dollars This Month \"\n    \"E31\", \"This Month Opinion EBITDA Dollars \"\n    \"E40\", \"Opinion EBITDA/Assets (annualized) \"\n    \"E41\", \"Annual EBITDA/Month Assets Plan \"\n    \"E42\", \"Annual EBITDA/Annual Assets Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Shipments\", \" \"\n    \"S1\", \"Current Shipments \"\n  |]\n  \nlet rules = \n  [| \n    \"[Version:'Projection'] =IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))));\", \"##[Projection] FROM [FP,W5,W4,W3,W2,W1] RULE: IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))))\"\n    \"[Version:'Actual\\Projection']=B:IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection']);\", \"##[Actual\\Projection] FROM ['Actual'], ['Projection'] RULE: IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection'])\"\n    \"[Currency:'USD'] =B:[Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'));\", \"##[Currency] FROM LC RULE: [Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'))\"\n    \"[Period:'YTD']=[Period:'YTD_12'];\", \"##[YTD] FROM [YTD_12] RULE: [Period:'YTD_12']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'310'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Total Projected Sales Orders] FROM [Interco Revenue] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']=-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Interco Revenue]                     FROM [Interco Revenue]  RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'401']=[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\", \"##ELIM Memo [Only:Inventory Receipts] FROM [Interco Revenue] RULE: [Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'440'] =B:-1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Interco] FROM [Standard COGS-Interco] RULE: -1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'430'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Non Interco] FROM [Interco Revenue] AND [Standard COGS-Interco] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Account:'910', Version:'Plan']=#NA;\", \"##[Minority Interest] RULE: #NA\"\n    \"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\", \"##[Minority Interest] FROM [Income (Loss) before taxes and M.I.] RULE: -1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %')\"\n    \"[Account:'40'] =[Account:'39']/[Account:'300'];\", \"##[Actual Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39']/[Account:'300']\"\n    \"[Account:'41'] =[Account:'39',Version:'Plan']/[Account:'300',Version:'Plan'];\", \"##[Plan Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39',Version:'Plan']/[Account:'300',Version:'Plan']\"\n    \"[Account:'31'] =[Account:'30']/[Account:'360'];\", \"##[P.A.T. %] FROM [Net Income After M. I. & Taxes] / [Income (Loss) before taxes and M.I.] RULE: [Account:'30']/[Account:'360']\"\n    \"[Account:'32'] =[Account:'30',Version:'Plan'];\", \"##[PLAN INCOME AFTER TAXES & M.I.] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30',Version:'Plan']\"\n    \"[Account:'33'] =B:[Account:'30']-[Account:'32'];\", \"##[$ VARIANCE TO PLAN] FROM [Net Income After M. I. & Taxes] - [PLAN INCOME AFTER TAXES & M.I.] RULE: [Account:'30']-[Account:'32']\"\n    \"###[Account:'C326']=B:-1*([Account:'5800']-[Account:'5810'])\", \"##[Overhead Spending] FROM [Overhead Spending] - [Bonus Accrual for Overhead] RULE: -1*([Account:'5800']-[Account:'5810'])\"\n    \"[Account:'C331']=-1*([Account:'610']);\", \"##[Engineering] FROM [Engineering] RULE: -1*([Account:'610'])\"\n    \"[Account:'C332']=-1*([Account:'620']);\", \"##[Sales] FROM [Sales] RULE: -1*([Account:'620'])\"\n    \"[Account:'C333']=-1*([Account:'630']);\", \"##[General & Administrative] FROM [General & Administrative] RULE: -1*([Account:'630'])\"\n    \"[Account:'C334']=-1*[Account:'640'];\", \"##[ESOP/401K Contributions] FROM [ESOP/401K Contributions] RULE: -1*([Account:'640'])\"\n    \"[Account:'C205']=B:[Account:'740'];\", \"##[Management Fees] FROM [Management Fees] RULE: [Account:'740']\"\n    \"[Account:'C207']=[Account:'750'];\", \"##[Interest (Expense)/Income] FROM [Interest (Expense)/Income] RULE: [Account:'750']\"\n    \"[Account:'C3'] =[Account:'C1']-[Account:'C2'];\", \"##[$ VARIANCE TO PLAN (under)] FROM [Projected Ending Loan Balance] - [PLAN Loan Balance] RULE: [Account:'C1']-[Account:'C2']\"\n    \"[Account:'C2']=B:IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2']);\", \"##[PLAN Loan Balance] FROM [PLAN Loan Balance] RULE: IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2'])\"\n    \"[Account:'R110']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE));\", \"##BC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE))\"\n    \"[Account:'R110']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET);\", \"##CC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET)\"\n    \"[Account:'R120'] =[Account:'30'];\", \"##[This Month Opinion Net Income] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30']\"\n    \"[Account:'R2']=B:DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##BC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'R2']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET);\", \"##CC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET)\"\n    \"[Account:'R610']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE));\", \"##[Projected Last Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE))\"\n    \"[Account:'R7']=[Version:'Plan',Account:'R6'];\", \"##[Plan This Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: [Version:'Plan',Account:'R6']\"\n    \"[Account:'R9']=[Period:'Year', Version:'Plan', Account:'R6'];\", \"##[Year Ending Asset Plan] FROM [Total This Month Ending Assets Opinion] RULE: [Period:'Year', Version:'Plan', Account:'R6']\"\n    \"###[Account:'R3'] =[Account:'R1']-[Account:'R2']\", \"##[YTD Comparison to Plan] FROM [Total Net Income (opinion & YTD)] - [Net Income YTD Plan] RULE: [Account:'R1']-[Account:'R2']\"\n    \"[Account:R633] =[Account:401];\", \"##[Material Receipts] FROM [Memo Only:Inventory Receipts] RULE: [Account:401]\"\n    \"[Account:R634] =-1*[Account:520];\", \"##[Material Usage Variance] FROM [Material Usage] RULE: -1*[Account:520]\"\n    \"[Account:R635] =-1*[Account:C325];\", \"##[Labor] FROM [Direct Labor] RULE: -1*[Account:C325]\"\n    \"[Account:R637] =-1*[Account:5820];\", \"##[Overhead Absorbed] FROM [Less:Overhead Absorption] RULE: -1*[Account:5820]\"\n    \"[Account:R636] =-1*[Account:540];\", \"##[Labor Variance] FROM [Labor Performance/Rate] RULE: -1*[Account:540]\"\n    \"[Account:R638] =[Account:C323];\", \"##[Material Recovery from Warranty] FROM [Less Warranty Recovery] RULE: [Account:C323]\"\n    \"[Account:R639] =-1*[Account:'410'];\", \"##[COGS Out] FROM [Cost of Goods Sold] RULE: -1*[Account:'410']\"\n    \"[Account:R642] =-1*[Account:C206];\", \"##[Capital and Investments] FROM [Capital Additions & Investments] RULE: -1*[Account:C206]\"\n    \"[Account:R643] =-1*[Account:C39];\", \"##[Depreciation] FROM [Add back: Depreciation] RULE: -1*[Account:C39]\"\n    \"[Account:R652] =[Account:300];\", \"##[Shipments] FROM [Total Net Revenue] RULE: [Account:300]\"\n    \"[Account:R653] =[Account:C311];\", \"##[Gross Collections] FROM [Gross Collections] RULE: [Account:C311]\"\n    \"[Account:'R10']=[Account:'R4']/[Account:'R6'];\", \"##[Opinion ROA (annualized)] FROM [Annualized Projected - Actual, Opinion & Plan] / [Total This Month Ending Assets Opinion] RULE: [Account:'R4']/[Account:'R6']\"\n    \"[Account:'R11']=[Account:'R5']/[Account:'R9'];\", \"##[Year End ROA Plan] FROM [Year End Net Income Plan] / [Year Ending Asset Plan] RULE: [Account:'R5']/[Account:'R9']\"\n    \"[Account:'E22']=DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Projected Last Month EBITDA YTD] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E24']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[EBITDA Plan Remaining Year] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E25']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Annual EBITDA Dollars -- FROM PLAN] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E30']=[Version:'Plan',Account:'36'];\", \"##[Plan EBITDA Dollars This Month] FROM [Income (Loss) before taxes and M.I.] RULE: [Version:'Plan',Account:'36']\"\n    \"[Account:'E31']=[Account:'E23'];\", \"##[This Month Opinion EBITDA Dollars] FROM [This Month Opinion EBITDA Dollars] RULE: [Account:'E23']\"\n    \"[Account:'E231']=[Account:'36'];\", \"##[This Month-- Profit Before Tax and M.I.] FROM [Income (Loss) before taxes and M.I.] RULE: [Account:'36']\"\n    \"[Account:'E233']=[Account:'C39'];\", \"##[This Month-- Depreciation/Amortization] FROM [Add back: Depreciation] RULE: [Account:'C39']\"\n    \"[Account:'E232']=-1*[Account:'750'];\", \"##[This Month-- Interest] FROM [Interest (Expense)/Income] RULE: -1*[Account:'750']\"\n    \"[Account:'E40']=[Account:'E20']/[Account:'R6'];\", \"##[Opinion EBITDA/Assets (annualized)] FROM [Annualized Projected ] / [Total This Month Ending Assets Opinion] RULE: [Account:'E20']/[Account:'R6']\"\n    \"[Account:'E41']=[Account:'E25']/[Account:'R7'];\", \"##[Annual EBITDA/Month Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Plan This Month Ending Assets] RULE: [Account:'E25']/[Account:'R7']\"\n    \"[Account:'E42']=[Account:'E25']/[Account:'R9'];\", \"##[Annual EBITDA/Annual Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Year Ending Asset Plan] RULE: [Account:'E25']/[Account:'R9']\"\n  |]  \n  \n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet AccountP = @\"(\\[((.+?),)*\\s*Account\\s*:\\s*'?(.+?)'?(,(.+?))*\\])\"\nlet input    = @\"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\"\n\nlet splitRule r =\n    Regex.Match(r, @\"(.+?)=(.+)\")\n    |> (fun m -> m.Groups.[1].Value, m.Groups.[2].Value)\n\nlet replace input =\n    Regex.Matches(input, AccountP)\n    |> Seq.cast<Match>\n    |> Seq.map (fun m -> \n        let whole = m.Groups.[0]\n        let acct  = m.Groups.[4]\n        let pres  = m.Groups.[3].Captures |> Seq.cast<Capture>\n        let sufs  = m.Groups.[6].Captures |> Seq.cast<Capture>\n        accounts \n        |> Seq.tryFind (fst >> ((=) acct.Value)) \n        |> Option.map snd \n        |> Option.defaultValue (\"Not Found: \" + acct.Value) \n        |> (fun s -> \n            let txt  = \n                [ yield s.Trim()\n                  for pre in pres do yield pre.Value\n                  for suf in sufs do yield suf.Value \n                ] \n                |> String.concat \"~\" \n                |> sprintf \"{%s}\" \n            txt, whole.Index, whole.Length)\n       )\n    |> Seq.fold (fun (txt:string, i, out) (v, s, l) -> (txt.[s + l - i ..], s + l, out + txt.[0 .. s - i - 1] + v) ) (input, 0, \"\")\n    |> fun (res, _, out) -> out + res\n    \nrules\n|> Seq.iter (\n    fun (r, c) ->\n        let a, b = splitRule r\n        printfn \"%s\\t%s\\t%s\" (replace a) (replace b) c\n \n)","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpPlus","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\n\nopen FSharpPlus\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\"2\"; \"3\"; \"4\"; \"5\"|]\n|> printfn \"%A\"\n\nmap ((+) 9) (Some 3)\n// val it : int option = Some 12\n|> printfn \"%A\"\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList<string> = {Head = \"2\"; Tail = [\"3\"; \"4\"; \"5\"];}\n|> printfn \"%A\"\n\n[\"hello\";\" \";\"world\"] >>= (fun x -> Seq.toList x)\n// val x : char list = ['h'; 'e'; 'l'; 'l'; 'o'; ' '; 'w'; 'o'; 'r'; 'l'; 'd']\n|> printfn \"%A\"\n\n\nlet tryParseInt : string -> int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nSome \"20\" >>= tryParseInt >>= tryDivide 100\n// val y : int option = Some 5\n|> printfn \"%A\"\n\nlet parseAndDivide100By = tryParseInt >=> tryDivide 100\n\nparseAndDivide100By \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By \"0\"    // None\n|> printfn \"%A\"\n\nlet parseElement n = List.tryItem n >=> tryParseInt\nparseElement 2 [\"0\"; \"1\";\"2\"]\n|> printfn \"%A\"\n\nlet tryParseInt' x : Choice<int, string> = \n    match tryParse x with \n    | Some x -> Choice1Of2 x\n    | None   -> Choice2Of2 (\"Failed to parse \" + x)\n        \n\nlet tryDivide' x n = \n    if n = 0 then Choice2Of2 \"Can't divide by zero\"\n    else Choice1Of2 (x / n)\n    \nlet parseAndDivide100By' = tryParseInt' >=> tryDivide' 100\n\nparseAndDivide100By' \"20\"   // Some 5\n|> printfn \"%A\"\nparseAndDivide100By' \"zero\" // None\n|> printfn \"%A\"\nparseAndDivide100By' \"0\"    // None\n|> printfn \"%A\"\n\nSome (+) <*> Some 2 <*> Some 10     // val sumAllOptions : int option = Some 12\n|> printfn \"%A\"\n\n[(+)] <*> [10; 100] <*> [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n|> printfn \"%A\"\n\nopen FSharpPlus.Lens\n\n\n(\"hello\",\"world\")^. FSharpPlus.Lens._2\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset _2 42 (\"hello\",\"world\", 8)\n// val it : string * int = (\"hello\", 42)\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^.(_2 << _1)\n// val it : string = \"world\"\n|> printfn \"%A\"\n\nset (_2 << _1) 42 (\"hello\",(\"world\",\"!!!\"))             \n// val it : string * (int * string) = (\"hello\", (42, \"!!!\"))\n|> printfn \"%A\"\n\n\"hello\"^.to' length\n// val it : int = 5\n|> printfn \"%A\"\n\n(\"hello\",(\"world\",\"!!!\"))^. (_2 << _2 << to' length)\n// val it : int = 3\n|> printfn \"%A\"\n\n_1 .-> \"hello\" <| ((),\"world\")\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\n((), \"world\") |> _1 .-> \"hello\"\n// val it : string * string = (\"hello\", \"world\")\n|> printfn \"%A\"\n\nview _2 (10,20)\n// val it : int = 20\n|> printfn \"%A\"\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"3def8b16-6c90-40f4-a78e-b2b293df699a"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"System.IO.Path.GetRandomFileName()\n|> printfn \"%s\"","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},"expanded":true,"level":0,"properties":{}},{"name":"Check All F# Code 1","content":"#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"c8d8aeb9-a872-45dc-b240-b7846e076d1a"},{"$":0,"Item":"dfc80990-ada5-4f24-8192-85bfe3b115a5"},{"$":0,"Item":"f850ce38-14e5-47a4-81ed-df02d7979f8e"},{"$":0,"Item":"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"},{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"},{"$":0,"Item":"8ee6b535-3615-4066-8917-9125cf8a1f20"},{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},{"$":0,"Item":"5df15cf1-361e-4d57-a565-683ab0b72082"},{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},{"$":0,"Item":"46450fbf-b073-4a66-ab42-587be0afc45f"}],"id":{"$":0,"Item":"caa2898b-b46a-4e93-99ba-63cc8e5726d0"},"expanded":true,"level":0,"properties":{}},{"name":"Test FSharp.Compiler.Service","content":"let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \n#if HELLO\nlet checker = FSharpChecker.Create()\n#endif\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#define FSHARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#if FHSARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#else\n#r @\"FSharp.Compiler.Service.dll\"\n#endif\n\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\nlet checker = FSharpChecker.Create()\n\nlet file       = @\"Compiled\\Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 2\nlet lineStr    = inputLines.[line - 1]\nasync {\n    #if FSHARP40 \n    let! projOptions0    = checker.GetProjectOptionsFromScript(file, input)\n    #else\n    let! projOptions02, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"ERRORS: %A\" errors\n    #endif\n    let  projOptions     = { projOptions0 with OtherOptions = Array.append projOptions0.OtherOptions [| \"-d:HELLO\" |]}\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, \"////-d:HELLO\\nlet a = 1\", projOptions)\n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    printfn \":%s\" lineStr\n    printfn \"PROJECT: %A\" projOptions\n    //parseResults.PrintDump()\n    let res = checker.TryGetRecentCheckResultsForFile(file, projOptions)\n    printfn \"RES: %A\" res\n    match res with\n    | None  -> ()\n    | Some  (_, res,_) ->\n        let! tip2 = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n        printfn \"TIP2: %A\" tip2\n} |> Async.RunSynchronously","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"id":{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},"expanded":true,"level":0,"properties":{}},{"name":"Check All F# Code 2","content":"// separate check for FSAutoComplete because it uses a different version of Compiler.Services.dll than Compile\n#define JUSTCHECKING","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},{"$":0,"Item":"971e9b81-6e5d-4f11-a604-f87504d7c950"}],"id":{"$":0,"Item":"11e21cf6-f497-4f73-a287-a2d5ff5b0445"},"expanded":true,"level":0,"properties":{}},{"name":"Calculation Editor","content":"module CalcEditor =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"id":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Rules (typed)","content":"open System\n\ntype DimType =\n    | DtTime\n    | DtVersion\n    | DtCalc\n    | DtMeasure\n    | DtOther\n\ntype AttType =\n    | AtString\n    | AtNumber\n\ntype ElmType =\n    | EtString\n    | EtNumber\n\ntype ModId = ModId of Guid\ntype AttId = AttId of Guid\ntype ElmId = ElmId of Guid\ntype CubId = CubId of Guid\ntype DimId = DimId of Guid\ntype CalId = CalId of Guid\ntype ForId = ForId of Guid\n\ntype Attribute = {\n    attId                  : AttId\n    mutable attName        : string\n    mutable attType        : AttType\n    mutable attTableNum    : int\n}\n\ntype Element = {\n    elmId                  : ElmId\n    elmDim                 : DimId\n    mutable elmType        : ElmType\n    mutable elmName        : string\n    mutable elmDescription : string\n    mutable elmAttributes  : Map<AttId, string> \n    mutable elmParents     : ElmId     []\n} \nwith\n    static member New name = \n      {\n        elmId          = ElmId <| Guid.NewGuid()\n        elmDim         = DimId <| Guid.NewGuid()\n        elmType        = EtString\n        elmName        = name\n        elmDescription = name\n        elmAttributes  = Map []\n        elmParents     = [||]\n      }\n\ntype Dimension = {\n    dimId                  : DimId\n    mutable dimName        : string\n    mutable dimPrefix      : string\n    mutable dimType        : DimType\n    mutable defaultElm     : ElmId     option\n    mutable dimElements    : Element   []\n    mutable dimAttributes  : Attribute []\n}\n\ntype Cube = {\n    cubId                  : CubId\n    mutable cubName        : string\n    cubDims                : Set<DimId>     \n} with\n    static member New(name, dims) = \n      {\n        cubId   = CubId <| Guid.NewGuid()\n        cubName = name\n        cubDims = dims\n      }\n\ntype Operator = \n    | OpAdd      \n    | OpSubtract \n    | OpMultiply \n    | OpDivide   \n    | OpEQ    \n    | OpNE\n    | OpGT       \n    | OpGE       \n    | OpLT       \n    | OpLE       \n    | OpAnd      \n    | OpOr           \n\ntype Function = Function\n\ntype ElmReference =\n    | ElemFixed   of DimId * ElmId\n    | ElemDynamic of DimId * ExpressionText\n  with\n    member this.DimId =\n        match this with\n        | ElemFixed  (id, _)\n        | ElemDynamic(id, _) -> id\n        \nand  ExpressionText =\n    | ExtNA\n    | ExtStet\n    | ExtSlice      of Slice\n    | ExtString     of string\n    | ExtDimElement of DimId\n    | ExtDimName    of DimId\n    | ExtFunction   of Function * ExpressionAny []\n    | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n    | ExtSubSt      of ExpressionText   * ExpressionNumber * ExpressionNumber\n\nand  ExpressionNumber =\n    | ExnNA\n    | ExnStet\n    | ExnSlice      of Slice\n    | ExnNumber     of float\n    | ExnOperationN of Operator * ExpressionNumber * ExpressionNumber\n    | ExnOperationT of Operator * ExpressionText   * ExpressionText\n    | ExnOperationI of Operator * ExpressionAny    * ExpressionAny\n    | ExnFunction   of Function * ExpressionAny []\n    | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n    | ExnMax        of ExpressionNumber * ExpressionNumber\n    | ExnMin        of ExpressionNumber * ExpressionNumber\n    | ExnDeIsChild  of ExpressionText   * ExpressionText   * ExpressionText  \n    \nand ExpressionAny =    \n    | ExiNA\n    | ExiStet\n    | ExiSlice      of Slice\n    | ExNumeric     of ExpressionNumber\n    | ExText        of ExpressionText\n    | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n    \nand  Slice = {\n    sliDims     : Map<DimId, ElmReference>   \n    calculation : CalId option\n} with \n    static member ForAll = {\n             sliDims       = Map.empty\n             calculation   = None\n    }\n\n\ntype ForType = \n    | ForBase\n    | ForConsolidated\n    | ForAll\n\ntype Formula = {\n    forId                  : ForId\n    mutable forDestination : ElmReference list\n    mutable forDescription : string\n    mutable forExpression  : ExpressionAny\n    mutable forType        : ForType\n}\n\ntype Calculation = {\n    calId                  : CalId\n    mutable calName        : string\n    mutable calDescription : string\n    mutable format         : string\n    mutable isText         : bool\n    mutable isInput        : bool\n    mutable isBalance      : bool\n    mutable calDims        : Set<DimId>\n    mutable calFormulas    : Formula []\n    mutable cube           : CubId   option\n    properties             : System.Collections.Generic.Dictionary<string, string>\n} with\n    member this.Slice : Slice = \n         {\n             sliDims       = Map.empty\n             calculation   = Some this.calId\n         }\n    member this.Type = if this.isInput then \"INPUT\" else \"CALC\"\n\ntype Model = {\n    modId                   : ModId\n    mutable server          : string\n    mutable modDims         : Dimension   []\n    mutable modCubes        : Cube        []\n    mutable modCalculations : Calculation []\n}\n\nlet model = \n  {\n    modId           = ModId <| Guid.NewGuid()\n    server          = @\"local\\Budget\"\n    modDims         = [||]\n    modCubes        = [||]\n    modCalculations = [||]\n  }\n\n#nowarn \"86\"\n\ntype HelperTypeN = HelperTypeN with\n    static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n    static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n    static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n    static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n    static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice           a.Slice\n    static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n    \nlet inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n\ntype HelperTypeT = HelperTypeT with\n    static member (&&>)  (HelperTypeT, a :     string          ) : ExpressionText = ExtString          a \n    static member (&&>)  (HelperTypeT, a :     Dimension       ) : ExpressionText = ExtDimName         a.dimId \n    static member (&&>)  (HelperTypeT, a :     Slice           ) : ExpressionText = ExtSlice           a\n    static member (&&>)  (HelperTypeT, a :     Calculation     ) : ExpressionText = ExtSlice           a.Slice\n    static member (&&>)  (HelperTypeT, a :     ExpressionText  ) : ExpressionText =                    a\n\nlet inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n\ntype HelperTypeA = HelperTypeA with\n    static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n    static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n    static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n    static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice           a.Slice\n    static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n    static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n    static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n\nlet inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n\ntype Formula with\n    static member inline New(dest, exp, typ) =\n          {\n              forId          = ForId <| Guid.NewGuid()\n              forDestination = dest\n              forDescription = \"\"\n              forExpression  = toExpA exp\n              forType        = typ\n          }\n    member this.Conso = { this with forType = ForConsolidated }\n   //static member inline Base(formula      ) = Formula.New([]  , formula, ForBase        )        \n   //static member inline Base(formula, dest) = Formula.New(dest, formula, ForBase        )        \n   //static member inline Cons(formula      ) = Formula.New([]  , formula, ForConsolidated)  \n   //static member inline Cons(formula, dest) = Formula.New(dest, formula, ForConsolidated)  \n   //static member inline All (formula      ) = Formula.New([]  , formula, ForAll         )    \n   //static member inline All (formula, dest) = Formula.New(dest, formula, ForAll         )    \n\nlet Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n\ntype Calculation with\n    static member Input (name: string)  =\n        let c =\n          {\n            calId          = CalId <| Guid.NewGuid()\n            calName        = name.Replace(\"_\", \" \").Trim()\n            calDescription = \"\"\n            format         = \"#,##0.00\"\n            isText         = false\n            isInput        = true\n            isBalance      = false\n            calDims        = Set.empty\n            calFormulas    = [||]\n            cube           = None\n            properties     = System.Collections.Generic.Dictionary<string, string>()\n          }\n        model.modCalculations <- Array.append model.modCalculations [| c |]\n        c\n    static member Calc name  = \n        let c = Calculation.Input name\n        c.isInput <- false\n        c \n    member        this.Name name           = this.calName     <- name                                                                         ; this\n    member inline this.Add (formula      ) = this.calFormulas <- Array.append this.calFormulas [| formula                                  |] ; this \n    member inline this.Base(expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForBase        ) |] ; this \n    member inline this.Base(expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForBase        ) |] ; this \n    member inline this.Cons(expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForConsolidated) |] ; this \n    member inline this.Cons(expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForConsolidated) |] ; this \n    member inline this.All (expr         ) = this.calFormulas <- Array.append this.calFormulas [| Formula.New([]  , expr, ForAll         ) |] ; this \n    member inline this.All (expr   , dest) = this.calFormulas <- Array.append this.calFormulas [| Formula.New(dest, expr, ForAll         ) |] ; this \n    member inline this.For (es: ElmReference list) = { this.Slice with sliDims = Map_adds (List.map (fun (e:ElmReference) -> e.DimId, e) es) this.Slice.sliDims } \n    member        this.AddFormulas fs = Array.append this.calFormulas (fs |> Seq.toArray)\n\ntype Dimension with \n    static member New name =\n        let d =\n          {\n            dimId          = DimId <| Guid.NewGuid()\n            dimName        = name\n            dimPrefix      = \"\"\n            dimType        = DtOther\n            defaultElm     = None\n            dimElements    = [| Element.New \"Hello\" |]\n            dimAttributes  = [||]      \n          }\n        model.modDims <- Array.append model.modDims [| d |]\n        d\n    member inline this.Item (it) : ElmReference = \n        match toExpT it with \n        | ExtString s -> printfn \"%s\" s ;ElemFixed  (this.dimId, this.dimElements.[ 0 ].elmId) \n        | exp         -> ElemDynamic(this.dimId, exp                         )  \n    member inline this.__     it     = this.Item it\n    member inline this.M      it     = this.Item it\n    member inline this.E      it     = this.Item it\n    member inline this.I      it     = this.Item it\n    member        this.Prefix pr     = this.dimPrefix <- pr   ; this\n    member        this.Name   name   = this.dimName   <- name ; this\n        \n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[],"id":{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Interfase","content":"#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\nopen Useful\n\ntype ErrAlea(errn, msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\nmodule Alea =\n\n    let private g  = new MdsAut.GeneralClass()\n    let private s  = new MdsAut.ServersClass()\n    let private d  = new MdsAut.DimensionsClass()\n    let private c  = new MdsAut.TablesClass()\n    let private at = new MdsAut.AttributeTablesClass()\n    let private e  = new MdsAut.ElementsClass()\n    let private l  = new MdsAut.DataCellsClass()\n\n    let res = g.MdsInit(0)\n\n    let callR<'T> (v: obj) =\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then Result.fail (ErrAlea(errN, g.MdsError errN |> unbox<string>, false))\n        else v |> unbox<'T> |> Result.succeed\n\n    let (|*>) result f = Result.bind f result\n\n    type ServerOlap(address: string) =\n        member this.Address     = address\n        member this.connectR    = s.ServerConnectEx (address, \"Admin\", \"\") |> callR<bool>\n        member this.disconnectR = s.ServerDisconnect(address             ) |> callR<bool>\n\n    type DimOlap(dimname: string, server: ServerOlap) = \n        member this.server                                  = server\n        member this.withR<'T>                f              = f this.server.Address dimname |> callR<'T>\n        member this.DimensionImport          df ef del desc = this.withR<bool  >    <| fun servAd dimN -> d.DimensionImport        (servAd, dimN, df, ef, del, desc)\n        member this.editBeginR               clear desc     = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditBegin     (servAd, dimN, clear, desc |> Option.defaultValue dimN)\n        member this.addElementR              eType elem parent weight = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditAddElement(servAd, dimN, eType, elem, parent, weight, \"\")\n        member this.editCommitR              commit         = this.withR<bool  >    <| fun servAd dimN -> d.DimensionEditCommit    (servAd, dimN, commit) \n        member this.elementsCountR                          = this.withR<int   >    <| fun servAd dimN -> e.ElementsCount          (servAd, dimN) \n        member this.elementsNameR            i              = this.withR<string>    <| fun servAd dimN -> e.ElementsName           (servAd, dimN, i) \n        member this.Name                                    = dimname\n     \n    type ElemOlap(elemname: string, dim: DimOlap) =\n        member this.dimension                                = dim\n        member this.withR<'T>                f               = this.dimension.withR<'T>    <| fun servAd dimN    -> f servAd dimN elemname\n        member this.childrenCountR                           = this.withR<int   >    <| fun servAd dimN elemN -> e.ElementChildrenCount   (servAd, dimN, elemN) \n        member this.childrenNameR      i                     = this.withR<string>    <| fun servAd dimN elemN -> e.ElementChildrenName    (servAd, dimN, elemN, i)\n        member this.childrenR                                =     Result.result {\n                                                                       let! n     = this.childrenCountR \n                                                                       let! elems = seq[ for i in 1..n do\n                                                                                            yield this.childrenNameR     i\n                                                                                    ] |> Result.seqCheck\n                                                                       return elems |> Seq.map (fun e -> ElemOlap(e, this.dimension)) |> Seq.toArray\n                                                                   }\n    type DimOlap with\n        member this.elementsR                                =     Result.result {\n                                                                       let! n     = this.elementsCountR\n                                                                       let! names = seq[ for i in 1..n do\n                                                                                            yield this.elementsNameR     i\n                                                                                    ] |> Result.seqCheck\n                                                                       let  elems = names |> Seq.map (fun e -> ElemOlap(e, this))\n                                                                       return elems |> Seq.toArray\n                                                                   }\n        member this.inputsR                                 =      Result.result {\n                                                                       let! n     = this.elementsCountR \n                                                                       let! elems = seq[ for i in 1..n do\n                                                                                            yield\n                                                                                                Result.result {\n                                                                                                    let! elemN  = this.elementsNameR     i\n                                                                                                    let  eOlap  = ElemOlap(elemN, this)\n                                                                                                    let! childN = eOlap.childrenCountR\n                                                                                                    return \n                                                                                                        if childN = 0 \n                                                                                                        then Some eOlap\n                                                                                                        else None\n                                                                                                }\n                                                                                    ]\n                                                                                    |> Result.seqCheck\n                                                                       return elems |> Seq.choose id |> Seq.toArray\n                                                                   }\n\n    type AttTableOlap(table: int16, dim: DimOlap) =\n        member this.dimension                               = dim\n        member this.nS                                      = table\n        member this.withR<'T>          f                    = this.dimension.withR<'T>    <| fun servAd dimN    -> f servAd dimN this.nS\n        member this.deleteR                                 = this.withR<bool>            <| fun servAd dimN nS -> at.ATableDelete     (servAd, dimN, nS |> int)\n        member this.createBeginR    ()                      = this.withR<int >            <| fun servAd dimN nS -> at.ATableCreateBegin(servAd, dimN, nS - 1s  )\n        member this.fieldAddR       handle name desc nType len dec = at.ATableFieldAdd(int16 handle, name, desc, nType, len, dec) |> callR<bool>\n        member this.createCommitR   handle                  = at.ATableCreateCommit(int16 handle) |> callR<bool>\n\n    type AttFieldOlap(name: string, table: AttTableOlap) =\n        member this.attTable                                = table\n        member this.name                                    = name\n        member this.withR<'T>          f                    = this.attTable.withR<'T>     <| fun servAd dimN nS       -> f servAd dimN nS this.name\n        member this.getInfoDescR                            = this.withR<string>          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 2)\n        member this.getInfoAtypR                            = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 3)\n        member this.getInfoLengthR                          = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 4)\n        member this.getInfoDecimalR                         = this.withR<int16 >          <| fun servAd dimN nS field -> at.ATableFieldGetInfo(servAd, dimN, nS, field, 5)\n        member this.putValueR          v elem               = this.withR<bool  >          <| fun servAd dimN nS field -> at.ATableFieldPutValue(v, servAd, dimN, nS |> int, elem, field)\n\n    type CubeOlap(cube: string, server: ServerOlap) =\n        member this.server                                   = server\n        member this.withR<'T>              f                 = f this.server.Address cube |> callR<'T>\n        static member bulkTransferBeginR  lType              = l.BulkTransferBegin(lType)             |> callR<bool>\n        static member bulkTransferCommitR lType stop log     = l.BulkTransferCommit(lType, stop, log) |> callR<bool>\n        member this.create                (dims: string[])   = this.withR<int       >        <| fun servAd cubeN -> c.TablesAdd(servAd, cubeN, cubeN, dims.[0], dims.[1]\n                                                                                                                       , Array.tryItem  2 dims, Array.tryItem  3 dims, Array.tryItem  4 dims, Array.tryItem  5 dims\n                                                                                                                       , Array.tryItem  6 dims, Array.tryItem  7 dims, Array.tryItem  8 dims, Array.tryItem  9 dims\n                                                                                                                       , Array.tryItem 10 dims, Array.tryItem 11 dims, Array.tryItem 12 dims, Array.tryItem 13 dims\n                                                                                                                       , Array.tryItem 14 dims, Array.tryItem 15 dims, Array.tryItem 16 dims, Array.tryItem 17 dims\n                                                                                                                       , Array.tryItem 18 dims, Array.tryItem 19 dims)\n        member this.delete                 ()                = this.withR<int       >        <| fun servAd cubeN -> c.TableKill(servAd, cubeN)\n        member this.setMeasure             dim               = this.withR<int       >        <| fun servAd cubeN -> c.TableSetMeasureDimension(servAd, cubeN, dim)\n        member this.dimensionsCountR                         = this.withR<int       >        <| fun servAd cubeN -> c.TableDimensionsCount(servAd, cubeN)\n        member this.exists                                   = this.dimensionsCountR |> Result.map ((>) 0) |> Result.ifError false  \n        member this.dimensionsNameR        i                 = this.withR<string    >        <| fun servAd cubeN -> c.TableDimensionsName (servAd, cubeN, i)\n        member this.putValueExR            v elems           = this.withR<bool      >        <| fun servAd cubeN -> l.DataPutValueEx (servAd, cubeN, v, elems)\n        member this.dimensionsR                              =     Result.result {\n                                                                        let! n    = this.dimensionsCountR\n                                                                        let! dims = seq [\n                                                                                         for i in 1..n do \n                                                                                             yield (this.dimensionsNameR    i)\n                                                                                    ]\n                                                                                    |> Result.seqCheck\n                                                                        return dims |> Seq.map (fun dimN -> DimOlap(dimN, this.server)) |> Seq.toArray\n                                                                   } \n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"65a5556d-d78e-4afb-8736-cb9f71aaf19f"},"expanded":true,"level":0,"properties":{}},{"name":"Update Model","content":"#r \"..\\packages\\FSharpPlus\\lib\\net40\\FSharpPlus.dll\"\nopen FSharpPlus.Lens\n\ntype Model with\n    member this.ServerOlap         = Alea.ServerOlap this.server\n    member this.GetDimension dimId = this.modDims |> Seq.tryFind (fun d -> d.dimId = dimId)\n\ntype Cube with\n    member this.MeasureDim = \"M\" + this.cubName.[2..]\n    member this.Dims (model:Model)  = \n        model.modDims\n        |> Array.filter(fun d -> this.cubDims |> Set.exists ((=) d.dimId) )\n    member this.CreateAttTable dim =\n        Result.result {\n            let  att    = Alea.AttTableOlap(1s, dim)\n            let! handle = att.createBeginR()\n            let! res    = att.fieldAddR handle \"Type\"          \"Type\"   0s  10s 0s  \n            let! res    = att.fieldAddR handle \"Format_String\" \"Format\" 0s 254s 0s\n            let! res    = att.createCommitR handle \n            ()\n        }\n    member this.CreateMeasureDimension(model: Model) =\n        Result.result {\n            do!  Result.tryProtection()\n            use  temp1 = new UsefulDotNet.TempFileName()\n            model.modCalculations\n            |> Seq.filter (fun c -> c.cube = Some this.cubId)\n            |> Seq.map    (fun c -> sprintf \"%s    %s\" (if c.isText then \"S\" else \"N\" ) c.calName)\n            |> String.concat \"\\n\"\n            |> fun txt -> System.IO.File.WriteAllText(temp1.Name, txt)\n            use  temp2  = new UsefulDotNet.TempFileName()\n            let  dim    = Alea.DimOlap(this.MeasureDim, model.ServerOlap)\n            let! res    = dim.DimensionImport temp1.Name  temp2.Name  '\\t'  (\"Measure for \" + this.cubName)\n            let  att    = Alea.AttTableOlap(int16 1, dim)\n            let  res    = this.CreateAttTable dim\n            let  fldTyp = Alea.AttFieldOlap(\"Type\"         , att)\n            let  fldFmt = Alea.AttFieldOlap(\"Format_String\", att)\n            model.modCalculations\n            |> Seq.iter (fun c ->\n                fldTyp.putValueR c.Type   c.calName |> ignore\n                fldFmt.putValueR c.format c.calName |> ignore\n            )\n        }\n    member this.CreateCube (model: Model) =\n        Result.result {\n            do!  this.CreateMeasureDimension model\n            let  cube      = Alea.CubeOlap(this.cubName, model.ServerOlap)\n            let  dims      = this.Dims model\n            let  dimNames  = dims |> Array.map (fun d -> d.dimName.ToUpper())\n            let  dimsOlapR = cube.dimensionsR \n            let  exists = \n                dimsOlapR \n                |> Result.map (fun dimsOlap ->\n                    dimNames = (dimsOlap |> Array.map (fun dimOlap -> dimOlap.Name.ToUpper()))\n                )\n                |> Result.ifError false\n            if not exists then\n                cube.delete |> ignore\n                let! res = cube.create dimNames\n                let! res = cube.setMeasure this.MeasureDim\n                ()\n            ()\n        }\n    \n\ntype Model with\n    member this.DimCombinations() =\n        this.modCalculations\n        |> Seq.map (fun c -> c.calDims)\n        |> Seq.distinct \n\n    member this.AutoName dims =\n        this.modDims\n        |> Seq.filter (fun d -> dims |> Seq.exists ((=) d.dimId) ) \n        |> Seq.map    (fun d -> d.dimPrefix )\n        |> String.concat \"\"\n        |> ((+) \"Z\")\n        \n    member this.GetCube cubId = this.modCubes |> Seq.tryFind (fun cub -> cub.cubId   = cubId)\n    member this.GetCube dims  = this.modCubes |> Seq.tryFind (fun cub -> cub.cubDims = dims )\n    \n    member this.FixForDimensions() =\n        let dimIds = this.modDims |> Array.map (fun d -> d.dimId)\n        this.modCubes <-\n            this.modCubes\n            |> Array.map (fun cub ->\n                { cub with cubDims = cub.cubDims |> Set.filter (fun d -> Seq.exists ((=) d) dimIds) }\n            )\n        this.modCalculations <-\n            this.modCalculations\n            |> Array.map (fun cal ->\n                { cal with calDims = cal.calDims |> Set.filter (fun d -> Seq.exists ((=) d) dimIds) }\n            )\n            \n    member this.FixCalcsAndCubes() =\n        let calNoCube, calCube = this.modCalculations |> Array.partition (fun c -> c.cube |> Option.bind this.GetCube |> Option.isNone)\n        if not <| Seq.isEmpty calNoCube then\n            let newCubes =\n                calNoCube\n                |> Seq.map    (fun c -> c.calDims)\n                |> Seq.distinct\n                |> Seq.filter (fun ds -> this.GetCube ds |> Option.isNone)\n                |> Seq.map    (fun ds -> Cube.New(this.AutoName ds, ds) )\n                |> Seq.toArray\n            if not <| Seq.isEmpty newCubes then \n               this.modCubes <- Array.append this.modCubes newCubes\n            let calNews = \n                calNoCube \n                |> Seq.map (fun c -> { c with cube = this.GetCube c.calDims |> Option.map (fun cub -> cub.cubId) } ) \n                |> Seq.toArray\n                |> Array.append calCube\n            this.modCalculations <- calNews\n        let dimCombinations = this.modCalculations |> Seq.map (fun cal -> cal.calDims) |> Seq.distinct |> Seq.toArray\n        this.modCubes <- this.modCubes |> Array.filter (fun cub -> Array.exists ((=) cub.cubDims) dimCombinations)\n        \n    member this.UpdateModel() =\n        this.FixForDimensions()\n        this.FixCalcsAndCubes()\n        this.modCubes |> Seq.iter (fun cub -> cub.CreateCube this |> Result.mapMsgs Result.countMessages |> snd |> printfn \"%s\")\n    ","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"4137cad8-fd64-426e-98de-16a92a56388d"},{"$":0,"Item":"65a5556d-d78e-4afb-8736-cb9f71aaf19f"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"ffce841e-404b-42d5-945c-cb2e9f9a67e3"},"expanded":true,"level":0,"properties":{}},{"name":"Syntax","content":"module Syntax =    \n    type HelperAdd      = HelperAdd      with static member inline (?<-) (x            , HelperAdd     , y) = ExnOperationN (OpAdd     , toExpN    x      , toExpN    y)\n    type HelperSubtract = HelperSubtract with static member inline (?<-) (x            , HelperSubtract, y) = ExnOperationN (OpSubtract, toExpN    x      , toExpN    y)\n    type HelperMultiply = HelperMultiply with static member inline (?<-) (x            , HelperMultiply, y) = ExnOperationN (OpMultiply, toExpN    x      , toExpN    y)\n    type HelperDivide   = HelperDivide   with static member inline (?<-) (x            , HelperDivide  , y) = ExnOperationN (OpDivide  , toExpN    x      , toExpN    y)\n    type HelperEQ       = HelperEQ       with static member inline (?<-) (x            , HelperEQ      , y) = ExnOperationN (OpEQ      , toExpN    x      , toExpN    y)\n    type HelperNE       = HelperNE       with static member inline (?<-) (x            , HelperNE      , y) = ExnOperationN (OpNE      , toExpN    x      , toExpN    y)\n    type HelperGT       = HelperGT       with static member inline (?<-) (x            , HelperGT      , y) = ExnOperationN (OpGT      , toExpN    x      , toExpN    y)\n    type HelperGE       = HelperGE       with static member inline (?<-) (x            , HelperGE      , y) = ExnOperationN (OpGE      , toExpN    x      , toExpN    y)\n    type HelperLT       = HelperLT       with static member inline (?<-) (x            , HelperLT      , y) = ExnOperationN (OpLT      , toExpN    x      , toExpN    y)\n    type HelperLE       = HelperLE       with static member inline (?<-) (x            , HelperLE      , y) = ExnOperationN (OpLE      , toExpN    x      , toExpN    y)\n    type HelperEQx      = HelperEQx      with static member inline (?<-) (x            , HelperEQx     , y) = ExnOperationT (OpEQ      , toExpT    x      , toExpT    y)\n    type HelperNEx      = HelperNEx      with static member inline (?<-) (x            , HelperNEx     , y) = ExnOperationT (OpNE      , toExpT    x      , toExpT    y)\n    type HelperGTx      = HelperGTx      with static member inline (?<-) (x            , HelperGTx     , y) = ExnOperationT (OpGT      , toExpT    x      , toExpT    y)\n    type HelperGEx      = HelperGEx      with static member inline (?<-) (x            , HelperGEx     , y) = ExnOperationT (OpGE      , toExpT    x      , toExpT    y)\n    type HelperLTx      = HelperLTx      with static member inline (?<-) (x            , HelperLTx     , y) = ExnOperationT (OpLT      , toExpT    x      , toExpT    y)\n    type HelperLEx      = HelperLEx      with static member inline (?<-) (x            , HelperLEx     , y) = ExnOperationT (OpLE      , toExpT    x      , toExpT    y)\n    type HelperAnd      = HelperAnd      with static member inline (?<-) (x            , HelperAnd     , y) = ExnOperationN (OpAnd     , toExpN    x      , toExpN    y)\n    type HelperOr       = HelperOr       with static member inline (?<-) (x            , HelperOr      , y) = ExnOperationN (OpOr      , toExpN    x      , toExpN    y)\n    \n    let inline ( +   )  x y = x ? (HelperAdd     ) <- y\n    let inline ( -   )  x y = x ? (HelperSubtract) <- y\n    let inline ( *   )  x y = x ? (HelperMultiply) <- y\n    let inline ( /   )  x y = x ? (HelperDivide  ) <- y\n    let inline ( =   )  x y = x ? (HelperEQ      ) <- y\n    let inline ( <>  )  x y = x ? (HelperNE      ) <- y\n    let inline ( >   )  x y = x ? (HelperGT      ) <- y\n    let inline ( >=  )  x y = x ? (HelperGE      ) <- y\n    let inline ( <   )  x y = x ? (HelperLT      ) <- y\n    let inline ( <=  )  x y = x ? (HelperLE      ) <- y\n    let inline ( &&  )  x y = x ? (HelperAnd     ) <- y\n    let inline ( ||  )  x y = x ? (HelperOr      ) <- y\n     \n    let inline ( &=  ) x y = x ? (HelperEQx     ) <- y\n    let inline ( &<> ) x y = x ? (HelperNEx     ) <- y\n    let inline ( &>  ) x y = x ? (HelperGTx     ) <- y\n    let inline ( &>= ) x y = x ? (HelperGEx     ) <- y\n    let inline ( &<  ) x y = x ? (HelperLTx     ) <- y\n    let inline ( &<= ) x y = x ? (HelperLEx     ) <- y\n     \n    let inline ( ?   ) (d:Dimension) e = d.[ toExpT e ]\n    let inline ( !   ) (d:Dimension)   = ExtDimElement d.dimId\n    \n    \n    let inline IF          (cond, thenR , elseR) = ExnIf       (toExpN cond, toExpN thenR , toExpN elseR)\n    let inline MAX         (v1  , v2           ) = ExnMax      (toExpN v1  , toExpN v2                  )\n    let inline MIN         (v1  , v2           ) = ExnMin      (toExpN v1  , toExpN v2                  )\n    let inline DE_ISCHILD  (dim , parent, child) = ExnDeIsChild(toExpT dim , toExpT parent, toExpT child)\n    \n    let inline IFt  (cond, thenR, elseR) = ExtIf   (toExpN cond, toExpT thenR, toExpT elseR)\n    let inline SUBST(txt , from , len  ) = ExtSubSt(toExpT txt , toExpN from , toExpN len  )\n    \n    let ForAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n    }\n    \n    let inline toForm0 e = Formula.New([], toExpA e, ForBase)\n    let inline addFormula  (c:Calculation) f dest forT = c.Add({ f with forDestination = dest ; forType = forT })\n    let inline addFormulaE (c:Calculation) e           = addFormula c (toForm0 e)\n    \n    type HelperForm = HelperForm with\n        static member (?<-) (c:Calculation, HelperForm, f : Formula          ) = addFormula  c f \n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionNumber ) = addFormulaE c e \n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionText   ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : Slice            ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : Calculation      ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : bool             ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : int              ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : float            ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : string           ) = addFormulaE c e\n        static member (?<-) (c:Calculation, HelperForm, e : ExpressionAny    ) = addFormulaE c e \n        static member (?<-) (c:Calculation, HelperForm, l : ElmReference list) = fun dest forT f -> addFormula c f l forT\n    \n    let inline (<<|  )  (c:Calculation) e = (c?(HelperForm)<-e) [] ForBase\n    let inline (<<|* )  (c:Calculation) e = (c?(HelperForm)<-e) [] ForConsolidated\n    \n    type HelperForm2 = HelperForm2 with\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Formula          ) = add(f        )\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionNumber ) = add(toForm0 f) \n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionText   ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Slice            ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : Calculation      ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : bool             ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : int              ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : float            ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : string           ) = add(toForm0 f)\n        static member (?<-) (add :Formula -> Calculation, HelperForm2, f : ExpressionAny    ) = add(toForm0 f) \n    \n    let inline (<<<)  p e = p?(HelperForm2)<-e\n    \n    let Calc  = Calculation.Calc\n    let Input = Calculation.Input\n    let NA    = ExnNA\n    \n    ","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"4c64379b-83c7-4785-874d-99271ccf1859"}],"id":{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Calculations","content":"open Syntax\n\nlet DataType             = Dimension.New \"DataType\"\nlet Value                = DataType.[\"Value\"]\n \nlet Price                = Dimension    .New( \"Price\"      ).Prefix \"PR\"\nlet Brand                = Dimension    .New( \"Brand\"      ).Prefix \"BR\"\nlet Product              = Dimension    .New( \"Product\"    ).Prefix \"PD\"\nlet Season               = Dimension    .New( \"Season\"     ).Prefix \"SE\"\nlet CostCenter           = Dimension    .New( \"CostCenter\" ).Prefix \"CC\"\nlet Account              = Dimension    .New( \"Account\"    ).Prefix \"AC\"\n \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nlet Sales_by_Brand                           = Input(\"Sales_by_Brand                           \")\nlet FP_vs_MD_Perc                            = Input(\"FP_vs_MD_Perc                            \")\nlet Sales_by_Brand_Price                     =  Calc(\"Sales_by_Brand_Price                     \")\nlet Gross_Perc                               = Input(\"Gross_Perc                               \")\nlet Gross_Sales_by_Brand_Price               =  Calc(\"Gross_Sales_by_Brand_Price               \")\nlet Seasonal_Allocation                      = Input(\"Seasonal_Allocation                      \")\nlet Seasonal_Allocation_2                    =  Calc(\"Seasonal_Allocation_2                    \")\nlet Seasonal_Allocation_Outlet               = Input(\"Seasonal_Allocation_Outlet               \")\nlet Discount                                 = Input(\"Discount                                 \")\nlet Sales_by_Season                          =  Calc(\"Sales_by_Season                          \")\nlet Net_Sales_by_Season                      =  Calc(\"Net_Sales_by_Season                      \")\nlet Markup                                   =  Calc(\"Markup                                   \")\nlet Seasonal_Cost_Factor                     = Input(\"Seasonal_Cost_Factor                     \")\nlet COGS                                     =  Calc(\"COGS                                     \")\nlet Inventory_Beginning                      =  Calc(\"Inventory_Beginning                      \")\nlet Average_Price                            = Input(\"Average_Price                            \")\nlet Inventory_Beginning_Quantity             =  Calc(\"Inventory_Beginning_Quantity             \")\nlet Inventory_Transfer_IN                    =  Calc(\"Inventory_Transfer_IN                    \")\nlet Purchases                                =  Calc(\"Purchases                                \")\nlet Inventory_Transfer_OUT                   =  Calc(\"Inventory_Transfer_OUT                   \")\nlet Sell_Through                             = Input(\"Sell_Through                             \")\nlet Purchases_Timing_Perc                    = Input(\"Purchases_Timing_Perc                    \")\nlet Total_Stock                              =  Calc(\"Total_Stock                              \")\nlet Inventory_Ending                         =  Calc(\"Inventory_Ending                         \")\nlet VAT_Rate_Sales_Tax                       = Input(\"VAT_Rate_Sales_Tax                       \")\nlet Selling_Squared_meters                   = Input(\"Selling_Squared_meters                   \")\nlet Net_Squared_meters                       = Input(\"Net_Squared_meters                       \")\nlet Gross_Squared_Meters                     = Input(\"Gross_Squared_Meters                     \")\nlet CAPEX                                    = Input(\"CAPEX                                    \")\nlet CASHOUT                                  = Input(\"CASHOUT                                  \")\nlet Landed_Factor_Custom_Duties              = Input(\"Landed_Factor_Custom_Duties              \")\nlet Landed_Factor_Insurance                  = Input(\"Landed_Factor_Insurance                  \")\nlet Landed_Factor_Freight                    = Input(\"Landed_Factor_Freight                    \")\nlet Net_Sales_Stockist                       = Input(\"Net_Sales_Stockist                       \")\nlet Net_Sales_Inter_Company                  = Input(\"Net_Sales_Inter_Company                  \")\nlet PercNet_Sales_Full_Price                 =  Calc(\"PercNet_Sales_Full_Price                 \")\nlet PercNet_Sales_Markdown                   =  Calc(\"PercNet_Sales_Markdown                   \")\nlet PercNet_Sales_Stockist                   =  Calc(\"PercNet_Sales_Stockist                   \")\nlet PercNet_Sales_InterCompany               =  Calc(\"PercNet_Sales_InterCompany               \")\nlet Average_Sales_Price_Full_Price           = Input(\"Average_Sales_Price_Full_Price           \")\nlet Average_Sales_Price_Markdown             = Input(\"Average_Sales_Price_Markdown             \")\nlet Average_Sales_Price_Stockist             = Input(\"Average_Sales_Price_Stockist             \")\nlet Average_Sales_Price_Intercompany         = Input(\"Average_Sales_Price_Intercompany         \")\nlet Mark_Up_Boutique                         =  Calc(\"Mark_Up_Boutique                         \")\nlet Mark_Up_Outlet                           =  Calc(\"Mark_Up_Outlet                           \")\nlet Custom_Duties_Beginning_Inventory        = Input(\"Custom_Duties_Beginning_Inventory        \")\nlet Freight_Beginning_Inventory              = Input(\"Freight_Beginning_Inventory              \")\nlet Insurance_Beginning_Inventory            = Input(\"Insurance_Beginning_Inventory            \")\nlet Index_Perc                               = Input(\"Index_Perc                               \")\nlet Depreciation_IC_Initial_Provision        = Input(\"Depreciation_IC_Initial_Provision        \")\nlet Depreciation_IC_Final_Provision          = Input(\"Depreciation_IC_Final_Provision          \")\nlet Depreciation_TP_Initial_Provision        = Input(\"Depreciation_TP_Initial_Provision        \")\nlet Depreciation_TP_Final_Provision          = Input(\"Depreciation_TP_Final_Provision          \")\nlet Depreciation_IC_Initial_Provision_Factor =  Calc(\"Depreciation_IC_Initial_Provision_Factor \")\nlet Depreciation_IC_Final_Provision_Factor   =  Calc(\"Depreciation_IC_Final_Provision_Factor   \")\nlet Depreciation_TP_Initial_Provision_Factor =  Calc(\"Depreciation_TP_Initial_Provision_Factor \")\nlet Depreciation_TP_Final_Provision_Factor   =  Calc(\"Depreciation_TP_Final_Provision_Factor   \")\nlet Depreciation_Beginning                   =  Calc(\"Depreciation_Beginning                   \")\nlet Depreciation_Ending                      =  Calc(\"Depreciation_Ending                      \")\nlet Depreciation_Change                      =  Calc(\"Depreciation_Change                      \")\nlet AMOUNT                                   =  Calc(\"AMOUNT                                   \")\n\n(*\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nlet For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\nlet For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\nlet For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\nlet For_NoSeasonalThirdParty = For_NoSeasonal @ [ Brand?(\"06\") ]\n\nlet isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\nlet isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\nlet isFallWinterM1            = !Season &= \"07\"\nlet isSeasonCarryOver         = !Season &= \"19\"\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nSales_by_Brand_Price                    <-- Sales_by_Brand * FP_vs_MD_Perc                                                                                              \n\nFP_vs_MD_Perc                           //<-- ([ Price?Mark_Down ; Value ] := (1 - FP_vs_MD_Perc.For[ Price?Full_Price ] ))                                   \n                                        <== Sales_by_Brand_Price / Sales_by_Brand                                                                                       \n\nGross_Sales_by_Brand_Price              <-- Sales_by_Brand_Price / (1 - Gross_Perc)                                                                                     \n\nSeasonal_Allocation                     <-- (For_NoSeasonalThirdParty := 1)                                                                                                         \n                                        <-- 1 - Seasonal_Allocation.For[ Season?Seasons ]                                , For_SeasonCarryOver                          )\n\nSeasonal_Allocation_2                   <-- 1                                                                            , For_NoSeasonalThirdParty                     )\n                                        <-- 0.5                                                                          , For_FallWinterM1                             )\n                                        <-- 0.5                                                                          , For_SeasonCarryOver                          )\n                                        <-- 0                                                                                                                           )\n                                        <-- IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)                                                                             )\n\nSeasonal_Allocation_Outlet              <-- 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]                        , For_NoSeasonal                               )\n\nSales_by_Season                         <-- Sales_by_Brand_Price                                          \n                                               * IF( isOutlet                                           \n                                                   , Seasonal_Allocation_Outlet                                           \n                                                   , IF(!CostCenter &= \"RBUS19\"                                           \n                                                     || !CostCenter &= \"RBUS20\"                                           \n                                                     || !CostCenter &= \"RBUS42\"                                           \n                                                     || !CostCenter &= \"RBUS41\"                                          \n                                                       , Seasonal_Allocation_2                                          \n                                                       , Seasonal_Allocation                                          \n                                                   )                                           \n                                                )                                                                                                                          )\n\nDiscount                                <== 1 - Sales_by_Season / Net_Sales_by_Season                                                                                   )\n\nNet_Sales_by_Season                     <-- Sales_by_Season / (1 - Discount)                                                                                            )\n\nMarkup                                  <-- IF (isOutlet, 1.25, 2.5)                                                     , [ Value                                    ] )\n                                        <== Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor                                                                         )\n\nCOGS                                    <-- Net_Sales_by_Season / Markup * Seasonal_Cost_Factor                                                                         )\n                                             \nInventory_Beginning                     <-- IF( isOutlet                                           \n                                                 , NA                                          \n                                                 , COGS \n                                                   * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                      /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                      +  COGS.For[ CostCenter?Boutiques ] ) )                               ,   For_FallWinterM1                           )\n                                                                                                   \n                                        <-- IF (isOutlet, COGS, COGS / 0.47 * 0.55)                                                                                     )\n                                                                                        \nInventory_Beginning_Quantity            <-- Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor)                                                                )\nInventory_Transfer_IN                   <-- COGS                                                                         , [ CostCenter?ROUS08                        ] )\n                                        <-- IF( isOutlet, COGS / 0.35, NA)                                               ,   For_FallWinterM1                           )\n                                        <-- IF( isOutlet                                           \n                                                 , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                   * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                 , NA)                                                                                                                     )\nPurchases                               <-- COGS * Purchases_Timing_Perc / Sell_Through                                                                                 )\nInventory_Transfer_OUT                  <-- IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                                   )\nTotal_Stock                             <-- Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                            )\nInventory_Ending                        <-- Total_Stock - COGS                                                                                                          )\n\nMark_Up_Boutique                        <-- IF(isOutlet, NA    , Markup)                                                                                                )\nMark_Up_Outlet                          <-- IF(isOutlet, Markup, NA    )                                                                                                )\n\nDepreciation_IC_Initial_Provision_Factor<-- IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) )            )\nDepreciation_IC_Final_Provision_Factor  <-- IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) )            )\nDepreciation_TP_Initial_Provision_Factor<-- IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) )            )\nDepreciation_TP_Final_Provision_Factor  <-- IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) )            )\nDepreciation_Beginning                  <-- IF(isOutlet,              \n                                                   IF( isThirdParty              \n                                                     , Depreciation_TP_Initial_Provision_Factor              \n                                                     , Depreciation_IC_Initial_Provision_Factor)              \n                                                   * Inventory_Beginning              \n                                               , 0)                                                                                                                        )\nDepreciation_Ending                     <-- IF(isOutlet,              \n                                                   IF( isThirdParty              \n                                                     , Depreciation_TP_Final_Provision_Factor              \n                                                     , Depreciation_IC_Final_Provision_Factor)              \n                                                   * Inventory_Ending              \n                                               , 0)                                                                                                                        )\nDepreciation_Change                     <-- Depreciation_Beginning - Depreciation_Ending                                                                                )\n\nAMOUNT                                  <-- Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ]          , [ Account?(\"BDG.002.02.FPR\"); Product   ?ND ] )\n                                        <-- Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ]          , [ Account?(\"BDG.002.02.MKD\"); Product   ?ND ] )\n                                        <-- Purchases_Timing_Perc                                                       , [ Account?(\"BDG.005.04\"    ); Product   ?ND ] )\n                                        <-- Markup                                                                      , [ Account?(\"BDG.011.EC\"    ); CostCenter?ND ] )\n                                        <-- IF( isOutlet, NA,  Markup)                                                  , [ Account?(\"BDG.011.W\"     ); CostCenter?ND ] )\n  \nprintfn \"%A\" model\n*)","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"547d9db7-67cb-4879-9568-e16a617b81b9"}],"id":{"$":0,"Item":"9b967b5a-a186-416e-b2f0-c5dfdf581917"},"expanded":true,"level":0,"properties":{}},{"name":"Alea Formulas","content":"let For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\nlet For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\nlet For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\nlet For_NoSeasonalThirdParty =   Brand?(\"06\") :: For_NoSeasonal\n\nlet isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\nlet isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\nlet isFallWinterM1            = !Season &= \"07\"\nlet isSeasonCarryOver         = !Season &= \"19\"\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nSales_by_Brand_Price                    <<|                                    Sales_by_Brand * FP_vs_MD_Perc                  \n\nFP_vs_MD_Perc                           <<| [ Price?Mark_Down ; Value ]    <<< 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]                                 \n                                        <<|                                    Sales_by_Brand_Price / Sales_by_Brand                                                                           \n                  \n\nGross_Sales_by_Brand_Price              <<|                                    Sales_by_Brand_Price / (1 - Gross_Perc)                                                                                                       \n\nSeasonal_Allocation                     <<| For_NoSeasonalThirdParty       <<< 1                                                                                                         \n                                        <<| For_SeasonCarryOver            <<< 1 - Seasonal_Allocation.For[ Season?Seasons ]                                           \n\nSeasonal_Allocation_2                   <<| For_NoSeasonalThirdParty       <<< 1         \n                                        <<| For_FallWinterM1               <<< 0.5                              \n                                        <<| For_SeasonCarryOver            <<< 0.5                          \n                                        <<|                                    0                                                                                                                           \n                                        <<|                                    IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)                                                                                               \n\nSeasonal_Allocation_Outlet              <<| For_NoSeasonal                 <<< 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]                                                 \n\nSales_by_Season                         <<|                                    Sales_by_Brand_Price                                          \n                                                                                  * IF( isOutlet                                           \n                                                                                      , Seasonal_Allocation_Outlet                                           \n                                                                                      , IF(!CostCenter &= \"RBUS19\"                                           \n                                                                                        || !CostCenter &= \"RBUS20\"                                           \n                                                                                        || !CostCenter &= \"RBUS42\"                                           \n                                                                                        || !CostCenter &= \"RBUS41\"                                          \n                                                                                          , Seasonal_Allocation_2                                          \n                                                                                          , Seasonal_Allocation                                          \n                                                                                      )                                           \n                                                                                   )                                                                                                                          \n                                                  \nDiscount                                <<|*                                   1 - Sales_by_Season / Net_Sales_by_Season                                                                                   \n                                                  \nNet_Sales_by_Season                     <<|                                    Sales_by_Season / (1 - Discount)                                                                                            \n                                                  \nMarkup                                  <<| [ Value ]                      <<< IF (isOutlet, 1.25, 2.5)                                                     \n                                        <<|*                                   Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor                                                                         \n                                                  \nCOGS                                    <<|                                    Net_Sales_by_Season / Markup * Seasonal_Cost_Factor                                                                         \n                                                                                \nInventory_Beginning                     <<| For_FallWinterM1               <<< IF( isOutlet                                           \n                                                                                                    , NA                                          \n                                                                                                    , COGS \n                                                                                                      * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                                                                         /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                                                                         +  COGS.For[ CostCenter?Boutiques ] ) )                                                                                                                                                                             \n                                        <<|                                    IF (isOutlet, COGS, COGS / 0.47 * 0.55)                                                                                     \n                                                                                                                           \nInventory_Beginning_Quantity            <<|                                    Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor)                                                                \nInventory_Transfer_IN                   <<| [ CostCenter?ROUS08 ]          <<< COGS \n                                        <<| For_FallWinterM1               <<< IF( isOutlet, COGS / 0.35, NA)                           \n                                        <<|                                    IF( isOutlet                                           \n                                                                                    , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                                                      * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                                                    , NA)     \n                                                                                    \nPurchases                               <<|                                    COGS * Purchases_Timing_Perc / Sell_Through                                                                                 \nInventory_Transfer_OUT                  <<|                                    IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                                   \nTotal_Stock                             <<|                                    Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                            \nInventory_Ending                        <<|                                    Total_Stock - COGS                                                                                                          \n                                                  \nMark_Up_Boutique                        <<|                                    IF(isOutlet, NA    , Markup)                                                                                                \nMark_Up_Outlet                          <<|                                    IF(isOutlet, Markup, NA    )                                                                                                \n                                                  \nDepreciation_IC_Initial_Provision_Factor<<|                                    IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) )            \nDepreciation_IC_Final_Provision_Factor  <<|                                    IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) )            \nDepreciation_TP_Initial_Provision_Factor<<|                                    IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) )            \nDepreciation_TP_Final_Provision_Factor  <<|                                    IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) )            \nDepreciation_Beginning                  <<|                                    IF(isOutlet,              \n                                                                                      IF( isThirdParty              \n                                                                                        , Depreciation_TP_Initial_Provision_Factor              \n                                                                                        , Depreciation_IC_Initial_Provision_Factor)              \n                                                                                      * Inventory_Beginning              \n                                                                                  , 0)                                                                                                                     \nDepreciation_Ending                     <<|                                    IF(isOutlet,              \n                                                                                      IF( isThirdParty              \n                                                                                        , Depreciation_TP_Final_Provision_Factor              \n                                                                                        , Depreciation_IC_Final_Provision_Factor)              \n                                                                                      * Inventory_Ending              \n                                                                                  , 0)                                                                                                                     \nDepreciation_Change                     <<|                                    Depreciation_Beginning - Depreciation_Ending                                                                                \n\nAMOUNT                                  <<| [ Account?(\"BDG.002.02.FPR\") \n                                              Product   ?ND              ] <<< Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ] \n                                        <<| [ Account?(\"BDG.002.02.MKD\")\n                                              Product   ?ND              ] <<< Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ] \n                                        <<| [ Account?(\"BDG.005.04\"    )\n                                              Product   ?ND              ] <<< Purchases_Timing_Perc                                              \n                                        <<| [ Account?(\"BDG.011.EC\"    )\n                                              CostCenter?ND              ] <<< Markup                                                             \n                                        <<| [ Account?(\"BDG.011.W\"     )\n                                              CostCenter?ND              ] <<< IF( isOutlet, NA,  Markup)                                         \n  \nprintfn \"%A\" model\n","parent":{"$":0,"Item":"002fe5c4-6032-4259-a8dc-9afa8f5f7742"},"predecessors":[{"$":0,"Item":"9b967b5a-a186-416e-b2f0-c5dfdf581917"}],"id":{"$":0,"Item":"9904a292-3cee-45b2-9909-5f3894447112"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Code","content":"#define WEBSHARPER\n(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)\n","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":false,"level":0,"properties":{}},{"name":"HtmlNode","content":"\n[<JavaScript>]\nmodule HtmlNode      =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":false,"level":0,"properties":{}},{"name":"Val","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa     |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View\n\n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: IRef<_           >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSSGlobal.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n\n    [< Inline >]\n    let inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n    \n    let inline toDoc       v           = toView      (fixit v ) |> Doc.EmbedView\n    [< Inline >]\n    let inline bindIRef f  v           = bindIRef0 f (fixit v   |> toView)\n    let inline iter     f  v           = iterV     f (fixit v )\n    let inline bind     f  v           = bindV     f (fixit v )\n    let inline map      f  v           = mapV      f (fixit v )\n    let inline map2     f  v1 v2       = map2V     f (fixit v1) (fixit v2)\n    let inline map3     f  v1 v2 v3    = map3V     f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4     f  v1 v2 v3 v4 = map4V     f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n    let inline sink     f  v           = fixit v |> toView |> View.Sink f\n\n    let inline iter2    f  v1 v2       = map2      f v1 v2       |> iterV id\n    let inline iter3    f  v1 v2 v3    = map3      f v1 v2 v3    |> iterV id\n    let inline iter4    f  v1 v2 v3 v4 = map4      f v1 v2 v3 v4 |> iterV id\n\n    let inline mapAsync f  v           = View.MapAsync f (fixit v |> toView) \n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true,"level":0,"properties":{}},{"name":"HtmlNode","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | HtmlElementV   of Val<HtmlNode>\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText     vtext           -> Some <| Val.tagDoc WebSharper.UI.Next.Html.text vtext\n    | SomeDoc      doc             -> Some <| doc\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true,"level":0,"properties":{}},{"name":"HTML Elements & Attributes","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet inline ``xclass`` v  = \n    match Val.fixit v with\n    | Constant c  -> Attr.Class        c       \n    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true\n\nlet  findRootElement (e:Dom.Element) =\n    let root = e.GetRootNode()\n    if isUndefined root?body \n    then root.FirstChild :?> Dom.Element\n    else root?body  |> unbox<Dom.Element>\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true,"level":0,"properties":{}},{"name":"storeVar","content":"[< Inline >]\nlet inline storeVar<'T> storeName (var:IRef<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"id":{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},"expanded":true,"level":0,"properties":{}},{"name":"LoadFiles","content":"[< Inline \"CIPHERSpaceLoadFiles($files, $cb)\" >]\nlet LoadFiles (files: string []) (cb: unit -> unit) : unit = X<_>","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true,"level":0,"properties":{}},{"name":"Template","content":"[<JavaScript>]\nmodule Template      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false,"level":0,"properties":{}},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true,"level":0,"properties":{}},{"name":"Bootstrap","content":"type Bootstrap() =\n    member this.Render =\n        div [\n          script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript\"    ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n          link   [ href \"/EPFileX/css/main.css\"                                                ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n         ]\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},"expanded":true,"level":0,"properties":{}},{"name":"Button","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\"\n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ]\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true,"level":0,"properties":{}},{"name":"Input","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : IRef<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                            }\n  static member  New(v)   = Input.New(Var.Create v)\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Var              = this.var","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true,"level":0,"properties":{}},{"name":"Hoverable","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : IRef<bool>\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n    }\n  member inline this.Content    (c: HtmlNode seq) = \n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  c\n    |> div\n  member inline this.Content    (c:HtmlNode) = \n      c.AddChildren \n          [ classIf \"hovering\" this.hover\n            SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n            SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n          ] \n  static member  Demo  = Hoverable.New.Content(div [ style \"flex-flow: column;\" ])\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true,"level":0,"properties":{}},{"name":"Panel","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true,"level":0,"properties":{}},{"name":"TextArea","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : IRef<string>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                            }\n  static member  New(v)   = TextArea.New(Var.Create v)\n  member        this.Render    =    \n    Doc.InputArea\n        [ \n          _class              this._class\n          attr.id             this.id  \n          atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          atr \"title\"         this.title\n          atr \"style\"        \"height: 100%;  width: 100%; box-sizing: border-box; \"\n          _placeholder        this.placeholder \n        ]\n        this.var\n    |> someElt \n    |> Seq.singleton \n    //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n    |> div\n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Var              = this.var\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true,"level":0,"properties":{}},{"name":"codeMirrorIncludes","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n      \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n//      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"                 \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror","content":"type CodeMirrorPos = { line: int ; ch  : int }\nlet inline cmPos(l, c) = { line = l ; ch  = c }\n\ntype CodeMirrorEditor() =\n    let a = 1\n  with\n    [< Inline \"CodeMirror($elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , gutters      : ['CodeMirror-lint-markers']\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($elt)\" >]\n    static member SetupEditor elt                                     : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]      \n    member this.GetValue()                                            : string           = X<_>\n    [< Inline \"$this.setValue($v)\"            >]      \n    member this.SetValue(v:string)                                    : unit             = X<_>\n    [< Inline \"$this.setOption($o, $v)\"       >]      \n    member this.SetOption(o:string, v:obj)                            : unit             = X<_>\n    [< Inline \"$this.getCursor()\"             >]      \n    member this.GetCursor()                                           : CodeMirrorPos    = X<_>\n    [< Inline \"$this.getLine($l)\"             >]      \n    member this.GetLine(l:int)                                        : string           = X<_>\n    [< Inline \"$this.getDoc().markText({line:$fl, ch:$fc}, {line:$tl, ch:$tc}, {className: $className, title: $title})\" >]\n    member this.MarkText (fl:int, fc:int) (tl:int, tc:int) (className: string) (title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                        : unit             = X<_>\n    [< Inline \"$this.on($event, $f)\"          >]\n    member this.On(event: string, f:(CodeMirrorEditor * obj) -> unit) : unit             = X<_>\n    [< Inline \"$this.addKeyMap($keyMap)\"      >]\n    member this.AddKeyMap(keyMap: obj)                                : unit              = X<_>\n    [< Inline \"$this.getWrapperElement()\"     >]\n    member this.GetWrapperElement()                                   : Dom.Element       = X<_>\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : IRef<string>\n    onChange        : (unit             -> unit)\n    onRender        : (CodeMirrorEditor -> unit) option\n    mutable editorO : CodeMirrorEditor option\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        onRender = None\n        editorO  = None\n      }\n  static member  New(v)   = CodeMirror.New(Var.Create v)\n  member        this.Render    =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                  LoadFiles codeMirrorIncludes\n                    (fun () ->                       \n                       let editor = CodeMirrorEditor.SetupEditor el\n                       this.editorO <- Some editor\n                       this.onRender |> Option.iter (fun onrender -> onrender editor)\n                       let editorChanged = ref 0L\n                       let varChanged    = ref 0L\n                       editor.On(\"changes\", fun (cm, change) ->\n                           let v = editor.GetValue() \n                           if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                       )\n                       this.var.View |> View.Sink (fun _ ->\n                           if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                           elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                       )\n                    )\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\"           ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/hint/show-hint.css\"     ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/lint/lint.css\"          ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.OnRender f    = { this with onRender  = Some f         }\n  member inline this.Var           = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror Hints","content":"\ntype Hint = {\n    text        : string\n    displayText : string\n    className   : string\n}\n\ntype HintResponse  = {\n    list           : Hint []\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype HintFunc      = FuncWithArgs<CodeMirrorEditor * (HintResponse -> unit) * obj,  unit>\n\ntype HintOptions   = {\n    hint           : HintFunc\n    completeSingle : bool   \n    container      : Dom.Element\n}\n\n[< Inline \"($v.hint.async = 1, $ed.showHint($v))\"          >]\nlet showHint_ (ed:CodeMirrorEditor) v   : unit       = X<_>\nlet showHints (ed:CodeMirrorEditor) getHints completeSingle _ =\n    showHint_ ed\n        {  completeSingle = completeSingle\n           hint           = HintFunc getHints\n           container      = ed.GetWrapperElement() |> findRootElement\n        }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},"expanded":true,"level":0,"properties":{}},{"name":"CodeMirror Lint","content":"type LintResponse  = {\n    message        : string\n    severity       : string\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype LintFunc      = FuncWithArgs<string * (LintResponse[] -> unit) * obj * CodeMirrorEditor,  unit>\n\n[< Inline \"($ed.setOption('lint', { async: 1, getAnnotations: $f, container: $elm }))\"          >]\nlet setLint_(ed:CodeMirrorEditor) (f:LintFunc) (elm:Dom.Element)  : unit = X<_>\nlet setLint (ed:CodeMirrorEditor) getAnnotations       = \n    setLint_ ed (LintFunc getAnnotations) (ed.GetWrapperElement() |> findRootElement)\n\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},"expanded":true,"level":0,"properties":{}},{"name":"SplitterBar","content":"[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : IRef<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit   5.0\n            max      = Val.fixit  95.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging _ (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true,"level":0,"properties":{}},{"name":"Grid","content":"[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\n[< Inline \"new ResizeObserver($f).observe($el)\" >]\nlet resizeObserver (f: unit->unit) (el:Dom.Element) = X<_> \n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    width         : IRef<float>\n    height        : IRef<float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       width         = Var.Create 1000.0\n       height        = Var.Create  100.0\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: float)  col =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter f true\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter f false\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto              spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto              spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n          style1 \"grid-template-rows\"    <| this.style this.rows this.height\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setDimensions () =\n                    this.width.Value  <- el.GetBoundingClientRect().Width\n                    this.height.Value <- el.GetBoundingClientRect().Height\n                JS.SetTimeout setDimensions 60 |> ignore\n                resizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},"expanded":true,"level":0,"properties":{}},{"name":"TabStrip","content":"let reorderList (ts:'a list) drag drop =\n    if drop < drag then\n       ts.[0       ..drop - 1     ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop    ..drag - 1     ]\n     @ ts.[drag + 1..ts.Length - 1]\n    else\n       ts.[0..drag - 1            ]\n     @ ts.[drag + 1..drop         ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop + 1..ts.Length - 1]\n\nlet reorderArray (ts:'a []) drag drop =\n   (if drop < drag then\n      [|\n       ts.[0       ..drop - 1     ]\n       [|        ts.[drag]       |]\n       ts.[drop    ..drag - 1     ]\n       ts.[drag + 1..ts.Length - 1]\n      |]\n    else\n      [|\n       ts.[0..drag - 1            ]\n       ts.[drag + 1..drop         ]\n       [|        ts.[drag]       |]\n       ts.[drop + 1..ts.Length - 1]\n      |]\n   )|> Array.collect id \n\n\n[< NoComparison >]\ntype TabStrip =\n    { selected  : IRef<int>\n      tabs      : IRef<(System.Guid * (string * HtmlNode)) []>\n      top       : bool\n      horizontal: bool\n      id        : System.Guid\n    } \n\nlet draggedTab: (TabStrip * int) option ref = ref None\n\nlet uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n\nlet selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n\nlet setSelectedPanel group panelO = \n    selectedPanels.Value <- \n        match panelO with\n        | Some panel -> selectedPanels.Value.Add    (group, panel)\n        | None       -> selectedPanels.Value.Remove  group\n\nlet mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\nlet RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n\ntype TabStrip with\n    member this.moveTab from drag drop =\n        let ts = this.tabs.Value\n        let ft = from.tabs.Value\n        let newTabsT =\n            [|\n             ts.[0       ..drop - 1     ]\n             [|        ft.[drag]       |]\n             ts.[drop    ..ts.Length - 1]\n            |]\n            |> Array.collect id\n        let newTabsF =\n            [|\n             ft.[0       ..drag - 1     ]\n             ft.[drag + 1..ft.Length - 1]\n            |]\n            |> Array.collect id\n        from.tabs.Value     <- newTabsF\n        this.tabs.Value     <- newTabsT\n        this.selected.Value <- drop\n        if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n        RaiseTabMoved from this\n\n    member this.reorder drop =\n        match !draggedTab with\n        | None                                     -> ()\n        | Some(from, drag) when from.id <> this.id -> this.moveTab from drag drop\n        | Some(from, drag)                         ->\n        this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n        let sel = this.selected.Value\n        this.selected.Value <- if    sel = drag                then drop\n                               elif (sel < drag && sel < drop)\n                                 || (sel > drag && sel > drop) then sel \n                               elif  sel < drag                then sel + 1\n                               else                                 sel - 1\n                               \n    static member New(tabs)    =\n        { selected   = Var.Create 0\n          tabs       = tabs \n          top        = false \n          horizontal = true\n          id         = System.Guid.NewGuid() \n        } \n    static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n    member this.Top         = { this with top        = true  }\n    member this.Bottom      = { this with top        = false }\n    member this.Horizontal  = { this with horizontal = true  }\n    member this.Vertical    = { this with horizontal = false }\n    member this.Selected    = Val.map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs this.selected\n    member this.Render      =\n        let strip =\n            this.tabs\n            |> bindHElem (\n                fun tabs ->\n                    div [ yield ``class`` <| sprintf \"tab-strip %s %s\"\n                                                (if this.top        then \"top\"        else \"bottom\"  ) \n                                                (if this.horizontal then \"horizontal\" else \"vertical\")\n                          \n                          for i, (uid, (txt, _)) in  tabs |> Seq.indexed  do\n                              yield Hoverable.New.Content(\n                                    div [ htmlText txt\n                                          ``class`` <| Val.map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected\n                                          draggable \"true\"\n                                          SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                            )\n                                          SomeAttr <| on.drag    (fun _ _  ->                     draggedTab := Some(this, i))\n                                          SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                          SomeAttr <| on.click   (fun _ _  ->                       this.selected.Value <- i ) \n                                        ])\n                        ]\n            )\n        Val.sink (setSelectedPanel this.id) this.Selected  \n        let content = \n            this.tabs\n            |> bindHElem (fun tabs ->\n                div [\n                  yield  ``class`` \"tab-children\"\n                  yield  Id <| uid2s this.id\n                  yield!\n                      tabs\n                      |> Seq.map (fun (uid, (txt, sub)) -> \n                          sub.AddChildren(\n                            [ style <| Val.map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels\n                              Id    <| uid2s uid\n                            ]))\n                ] \n             )\n        div [ ``class`` \"tab-panel\"\n              (if     this.top then strip else HtmlEmpty)\n              div [ content ; ``class`` \"tab-content\" ]\n              (if not this.top then strip else HtmlEmpty)\n              SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                      )\n              SomeAttr <| on.drop    (fun e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n              css @\"\n\n.tab-panel {\n overflow : hidden ;\n display  : flex   ;\n flex-flow: column ;\n background: pink    ;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n\"]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},"expanded":true,"level":0,"properties":{}},{"name":"SplitterNode","content":"#nowarn \"1178\"\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | SHtmlNode of HtmlNode\n    | STabStrip of TabStrip\n    | Split     of SplitterNode * SplitterNode * (SplitterNode -> SplitterNode -> HtmlNode)\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | SHtmlNode node        -> node\n        | STabStrip strip       -> strip.Render  \n        | Split   (ch1, ch2, f) -> f ch1 ch2\n\nlet renderSplitter (per:float) ver ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    if ver then grid.ColVariable(per).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n           else grid.RowVariable(per).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterStructure with    \n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2     ) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter 50.0 vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| SHtmlNode child1), SplitterNode (Var.Create <| SHtmlNode child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| STabStrip child1), SplitterNode (Var.Create <| STabStrip child2), renderSplitter per  vertical)\n    static member New(ss1, ss2, f                    ) = Split(SplitterNode (Var.Create ss1                ), SplitterNode (Var.Create ss2                ), f                      )\n    static member New(strip                          ) = STabStrip strip\n    static member New(node                           ) = SHtmlNode node\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, STabStrip node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, SHtmlNode node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | SHtmlNode HtmlEmpty   -> true\n        | SHtmlNode _           -> false\n        | STabStrip strip       -> strip.tabs.Value.Length = 0\n        | Split   (ch1, ch2, f) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ch1, ch2, f) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                   elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                    else ch1.UnSplitEmpties()\n                                                         ch2.UnSplitEmpties()\n        | _                     -> ()  \n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"}],"id":{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"},"expanded":true,"level":0,"properties":{}},{"name":"MenuBar","content":"let inline menuEntry content   = li [ content ]\nlet inline private ref       content r = a  [ content ; hrefO r ] \nlet inline refText   txt     r = bindHElem (fun t -> if t = \"\" then HtmlEmpty else ref (htmlText t) r) txt\nlet inline entryTxt  txt     r = menuEntry (refText  txt  r)\n  \nlet inline entries    ch cl    =  ul ch |> addClass cl\nlet inline nav        ch       =  entries ch \"nav navbar-nav\"\nlet inline dropdown   ch       =  entries ch \"dropdown-menu\"\nlet navbar brand center right  =\n    div [ ``class``                     \"navbar navbar-default\"\n          div [ ``class``               \"container-fluid\"\n                div [ ``class``         \"navbar-header\"\n                      div [ ``class``   \"navbar-brand\"\n                            brand\n                          ]\n                    ]\n                div [ ``class``         \"navbar-collapse collapse\"\n                      center\n                      right |> addClass \"navbar-right\"\n                    ]\n              ]\n    ]\n    \n#nowarn \"1178\"    \n\ntype MenuEntry = {\n    text       : Val<string>\n    ref        : Val<string option>\n    active     : Val<bool>\n    disabled   : Val<bool>\n    subMenu    : Menu option\n    toolTip    : string option\n    divider    : bool\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        active    = Val.fixit  false \n        ref       = Val.Constant None\n        toolTip   = None\n        subMenu   = None\n        onClick   = None\n        divider   = false\n        disabled  = Val.fixit false\n    } \n    static member inline New(txt, ref) = { MenuEntry.New(txt) with ref      = Val.map Some ref }\n    member this.Render           = \n        entryTxt this.text this.ref |> addClassIf \"active\" this.active |> addClassIf \"disabled\" this.disabled\n        |> match this.subMenu with | None  -> id | Some m -> addChildren [ ``class`` \"dropdown\" ; m.Render ]\n        |> match this.onClick with | None  -> id | Some f -> addChildren [ SomeAttr  <| on.click <@ f @>   ; style \"cursor : pointer\" ]\n        |> match this.divider with | false -> id | true   -> addClass    \"divider\"\n    member inline this.Divider      = { this with divider  = true                           }\n    member inline this.OnClick  f   = { this with onClick  = Some f                         }\n    member inline this.Disabled dis = { this with disabled = Val.fixit dis                  }\n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New( es).DropDown } \n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New2(es).DropDown } \n    member        this.MenuNode     = MenuEntry this\nand MenuNode =\n    | MenuHtml  of HtmlNode\n    | MenuEntry of MenuEntry \n  with\n    member this.Render = match this with | MenuHtml h -> h | MenuEntry e -> e.Render\nand Menu = {\n    entries  : MenuNode seq\n    dropdown : bool\n} with\n    static member New es : Menu = { \n        entries = es\n        dropdown = false\n    }    \n    static member New2 es : Menu = Menu.New(es |> Seq.map MenuEntry) \n    member this.DropDown        = { this      with dropdown = true  }\n    member this.Render          =\n        (if this.dropdown then dropdown else nav) <|\n            seq [\n                for entry in this.entries -> \n                    entry.Render\n            ]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"id":{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"},"expanded":true,"level":0,"properties":{}},{"name":"Action","content":"type Action = {\n    text       : Val<string>\n    highlight  : Val<bool>\n    disabled   : Val<bool>\n    toolTip    : string option\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        highlight = Val.fixit  false \n        disabled  = Val.fixit  false\n        toolTip   = None\n        onClick   = None\n    } \n    member inline this.OnClick   f   = { this with onClick   = Some f        }\n    member inline this.OnClick2  f   = { this with onClick   = Some (f this) }\n    member inline this.Disabled  dis = { this with disabled  = Val.fixit dis }\n    member inline this.Highlight h   = { this with highlight = Val.fixit h   }\n    member        this.MenuEntry     = {\n        MenuEntry.text      = this.text\n        MenuEntry.active    = this.highlight \n        MenuEntry.disabled  = this.disabled\n        MenuEntry.toolTip   = this.toolTip\n        MenuEntry.onClick   = this.onClick\n        MenuEntry.ref       = Val.Constant None\n        MenuEntry.divider   = false\n        MenuEntry.subMenu   = None\n    }\n    member        this.Button       = {\n        Button.text      = this.text\n        Button.disabled  = this.disabled\n        Button.onClick   = this.onClick |> Option.defaultValue (fun _ _ -> ())\n//        Button.toolTip   = this.toolTip\n        Button._class    = Val.map (fun h -> if h then \"btn btn-primary\" else \"btn\") this.highlight \n        Button._type     = Val.fixit \"button\" \n        Button.style     = Val.fixit \"\"\n        Button.id        = \"\"\n      }\n\nlet Do  f p = (fun     _ _ -> f     p)\nlet Do2 f p = (fun act _ _ -> f act p)","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}],"id":{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},"expanded":true,"level":0,"properties":{}},{"name":"RunCode","content":"[<JavaScript>]\nmodule RunCode       =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false,"level":0,"properties":{}},{"name":"completeJS","content":"let completeJS js = \n  \"\"\"\n    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n                 \"\"\" + js","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool) =\n  let bClearNode    = defaultArg clearNode true\n  let createNode() =\n      let e = JS.Document.CreateElement \"div\"\n      e?style <- \"height: 100%; width: 100%;\"\n      e\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      match baseNode.ShadowRoot with\n      | null -> let p = createNode()\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild p |> ignore\n                let e = createNode()\n                p.AppendChild e |> ignore\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool) = RunNode(\"TestNode\", ?clearNode = clearNode)\n  member this.RunNode   = runNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true,"level":0,"properties":{}},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.ParentElement.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true,"level":0,"properties":{}},{"name":"RunDoc","content":"  member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true,"level":0,"properties":{}},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true,"level":0,"properties":{}},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        Useful.Wrap.wrapper {\n            freeMsgs.Value <- \"Compiling to JavaScript...\"\n            freeJS.Value   <- \"\"\n            let    code      = freeFS.Value\n            let!   jsR       = FsTranslator.translateAR code false\n            let!   js        = jsR\n            let    jsc       = completeJS js\n            freeJS.Value    <- jsc\n            sendMsg            \"Compiled!\"\n            runJS()\n        } |> Useful.Wrap.start sendMsg\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true,"level":0,"properties":{}},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true,"level":0,"properties":{}},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStation Code","content":"module FSharpStation =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"expanded":false,"level":0,"properties":{}},{"name":"CodeSnippet Extensions, Position","content":"open Template\nopen FsStationShared\nopen System.Collections.Generic\nopen Useful\n\n#if FSS_SERVER\nopen FsTranslator\nopen FsEvaluator\n#endif\n\n[< JavaScript >]\nmodule FsGlobal =\n    [< Inline >]\n    let inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\n    \n    //let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n    //let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n    let fsIds  = \"FSharpStation\" //+ (System.Guid.NewGuid() |> string)\n    \n    let tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n    \n    type CodeSnippet \n        with\n        static member PickIO       id   = codeSnippets.Value    |> tryPickI (fun (_, snp) -> snp.id = id)\n        static member FetchO       id   = codeSnippets.TryFindByKey id\n        static member FetchL       id   = CodeSnippet.FetchO id |> Option.toList\n        static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n        static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n        static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n        static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n        static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n        static member New(od, nm, pa, pred, co, cnt) =\n            let newS =\n                {\n                    name         = nm\n                    content      = cnt\n                    parent       = pa\n                    predecessors = pred\n                    id           = CodeSnippetId.New\n                    expanded     = true\n                    level        = 0\n                    properties   = Map.empty\n                }\n            match od, codeSnippets.Length with\n            | _, 0            -> codeSnippets.Append newS\n            | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n            | i, n when i < n -> codeSnippets.Value \n                                    |> Seq.toArray\n                                    |> Array.splitAt od\n                                    |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                    |> codeSnippets.Set \n            | _, _            -> codeSnippets.Append newS\n            newS\n        member this.Level =\n            let rec level out snp = \n                snp.parent\n                |> Option.bind CodeSnippet.FetchO\n                |> Option.map (level <| out + 1) \n                |> Option.defaultValue out\n            level 0 this\n        member this.PrepareSnippet   = { this with level   = this.Level\n                                                   content = this.content\n                                                                  .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , fsIds                  )\n                                                                  .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href) }\n        member this.Predecessors     () =\n            let preds = this.UniquePredecessors CodeSnippet.FetchO |> Seq.toArray\n            codeSnippets.Value\n            |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n            |> Seq.map    (fun snp -> snp.PrepareSnippet)\n            |> Seq.toArray\n        member this.GetCodeAndStarts addLinePrepos = this.Predecessors() |> CodeSnippet.CodeAndStarts addLinePrepos\n        member this.GetCodeFsx       addLinePrepos = this.GetCodeAndStarts addLinePrepos |> fst\n        member this.IsDescendantOf antId =\n            let rec isDescendantOf snp =\n                match snp.parent with\n                | None       -> false\n                | Some parId ->\n                if parId = antId then true else\n                CodeSnippet.FetchO parId\n                |> Option.map isDescendantOf\n                |> Option.defaultValue false\n            isDescendantOf this\n        static member FetchByPathO names      = \n            let tryFindByName      snps name  = snps |> Seq.filter (fun (snp:CodeSnippet) -> snp.Name = name) |> Seq.tryHead\n            let rec tryFindByPath  snps names = \n                let first = names |> Seq.tryHead |> Option.bind (tryFindByName snps)\n                if names |> Seq.length <= 1 then first else\n                first\n                |> Option.bind (fun f ->\n                    names \n                    |> Seq.tail\n                    |> tryFindByPath  (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent = Some f.id))\n                )\n            names \n            |> tryFindByPath (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent.IsNone))  \n    \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    \n    type ErrCompiler =\n        | JsCompilerMsg  of string * bool\n        | ``Snippet Missing``\n        | ``Could not open new browser, Popup blocker may be active``\n        interface ErrMsg with\n            member this.ErrMsg   : string = \n                match this with \n                | JsCompilerMsg(msg, err) -> sprintf \"%s\" msg\n                | _                       -> sprintf \"%A\" this\n            member this.IsWarning: bool   = \n                match this with \n                | JsCompilerMsg(msg, err) -> not err\n                | _                       -> false\n                \n    [< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\n    let saveAs (txt:string) (name:string) = ()\n    \n    type KeyMapAutoComplete = { \n        F2              : Template.CodeMirrorEditor -> unit \n        LeftDoubleClick : Template.CodeMirrorEditor -> unit\n        ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n    }\n    \nopen FsGlobal                ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},"expanded":true,"level":0,"properties":{}},{"name":"CIPHERPrototype Module","content":"#r @\"ZafirTranspiler.dll\"\n    \n[< JavaScript >]\ntype CIPHERPrototypeMsg(msg: string, warning: bool) =\n    interface ErrMsg with\n        member this.ErrMsg    = msg\n        member this.IsWarning = warning\n\n[< JavaScript >]\nlet translateAR fsCode minified = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.translate fsCode minified\n        let!   js     = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return js\n    } |> Wrap.getAsyncR\n\n[< JavaScript >]\nlet evaluateAR  fsCode = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.evaluate fsCode\n        let!   txt    = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return txt\n    } |> Wrap.getAsyncR\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStationClient","content":"[< JavaScript >]\nlet FSharpStationClient () =\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":false,"level":0,"properties":{}},{"name":"currentCodeSnippetId","content":"\nlet missingVar  = Var.Create \"\"\nlet missing find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> \"\") (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name   ) (fun s n -> { s with name    = n }) <| k\nlet curSnippetCodeOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content) (fun s n -> { s with content = n }) <| k\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"1787d1fe-db11-4716-b3f6-164048e8991b"},{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditorMain","content":"\n\nlet noSelection cur = CodeSnippet.FetchO cur = None\nlet noSelectionVal  = Val.map noSelection currentCodeSnippetId\n\nlet mutable lastCodeAndStarts : (CodeSnippetId * bool * ((string * int * int) [] * string [] * string [] * string [] * string [] * string [])) option = None\n\nlet getPredecessors curO =\n    curO\n    |> Option.map (fun (snp:CodeSnippet) -> snp.UniquePredecessors CodeSnippet.FetchO |> HashSet)\n    |> Option.defaultValue (System.Collections.Generic.HashSet())\n\nlet getPredecessorsM = Useful.ResetableMemoize(getPredecessors)\n\nlet codeFS         = Var.Create \"\"\nlet codeJS         = Var.Create \"\"\nlet codeMsgs       = Var.Create \"\"\nlet mutable parsed = false\nlet dirty          = Var.Create false \nlet setDirtyPart() = parsed            <- false\n                     dirty.Value       <- true       \nlet setDirty()     = lastCodeAndStarts <- None\n                     setDirtyPart               ()\nlet setDirtyPred() = setDirty                   ()\n                     getPredecessorsM.ClearCache()\n                     refreshView                ()\nlet setClean()     = getPredecessorsM.ClearCache()\n                     dirty.Value       <- false\n                     lastCodeAndStarts <- None\n                     \n\n//storeVarCodeEditor \"dirty\" dirty\nlet sendMsg msg =\n    if isUndefined msg then () else\n    codeMsgs.Value  <- \n        match codeMsgs.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.GetCodeFsx true )\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\n//let evalIFrameJS success failure js =\n//    createIFrame (fun frame ->\n//        try\n//             let window   = frame?contentWindow\n//             let eval   s = JS.Apply window \"eval\" [| s |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure\n//    )\n//    |> RunCode.RunNode().RunHtml\n//\n//let evalWindowUrlJS (url:string) success failure js =\n//    let window       = JS.Apply JS.Window \"open\" [| url |]\n//    match window with\n//    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n//    | _    ->\n//    800 \n//    |> JS.SetTimeout (fun () -> \n//        try\n//             let eval   s = JS.Apply window   \"eval\" [| s |]\n//             //printfn \"Evaluating...\"\n//             JS.Apply window   \"focus\" [|  |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure)\n//    |> ignore\n//\n//let runUrlJS url pos msgs js =\n//    sendMsg \"Running JavaScript...\"\n//    match pos with\n//    | NewBrowser -> evalWindowUrlJS url\n//    | _          -> evalIFrameJS\n//    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n//    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n//    <| js\n//\n//let processSnippet getCode msg processCode =\n//    CodeSnippet.FetchO currentCodeSnippetId.Value \n//    |> Option.iter (fun snp -> \n//        codeMsgs.Value <- msg\n//        codeJS.Value   <- \"\"\n//        let code = getCode snp\n//        codeFS.Value   <- code\n//        processCode       code\n//    )\n//\n//let compileSnippet fThen fFail = \n//    processSnippet (fun snp -> snp.GetCodeFsx true) \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n//\n//let compileRunP pos = compileSnippet (runJS pos)                                         sendMsg\n//let compileRun  ()  = compileRunP           position.Value\n//let justCompile ()  = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirtyPred()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirtyPred()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirtyPred()\n    )\n\nlet mutable draggedId   = CodeSnippetId.New\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true,"level":0,"properties":{}},{"name":"Compile","content":"let compileSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp       = snpO |> Result.fromOption ``Snippet Missing``\n        codeMsgs.Value  <- \"Compiling to JavaScript...\"\n        codeJS.Value    <- \"\"\n        let    code      = snp.GetCodeFsx true\n        codeFS.Value    <- code\n        let!   jsR       = translateAR code false\n        let!   js        = jsR\n        let    jsc       = RunCode.completeJS js\n        codeJS.Value    <- jsc\n        sendMsg            \"Compiled!\"\n        return jsc\n    }\n    \nlet newWindow url = \n    JS.Apply JS.Window \"open\"  [| url |]\n    |> function\n       | null   -> Result.fail    ``Could not open new browser, Popup blocker may be active``\n       | window -> Result.succeed window\n    \nlet eval  window js = JS.Apply window \"eval\"  [| js  |]\nlet focus window    = JS.Apply window \"focus\" [|     |] |> ignore\n\nlet evalWindowUrlJSW (url:string) js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n\nlet createIFrameA () =\n    Async.FromContinuations\n        (fun (cb, errF: exn -> unit, canF: System.OperationCanceledException -> unit) ->\n            try\n                createIFrame cb |> RunCode.RunNode().RunHtml     \n            with e -> errF e\n        )\n\nlet evalIFrameJSW js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   frame        = createIFrameA () \n        let    window       = frame?contentWindow\n        let    res : string = eval window js\n        return res\n    }\n\nlet compileRunUrlW url pos snpO =\n    Wrap.wrapper {\n        let! js  = compileSnippetW snpO\n        sendMsg \"Running JavaScript...\"\n        let! res = match pos with\n                   | NewBrowser -> evalWindowUrlJSW url js\n                   | _          -> evalIFrameJSW        js\n        sendMsg res\n        sendMsg \"Done!\"\n        return  res\n    }\n\nlet getSnpO () = CodeSnippet.FetchO currentCodeSnippetId.Value\n\nlet evaluateSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp       = snpO |> Result.fromOption ``Snippet Missing``\n        codeMsgs.Value  <- \"Evaluating F# code...\"\n        let    code      = snp.GetCodeFsx true\n        codeFS.Value    <- code\n        let! resR        = evaluateAR code\n        let! res         = resR\n        sendMsg res\n        sendMsg \"Done!\"\n        return  res\n    }\n\nlet compileRunW = compileRunUrlW (JS.Window.Location.Origin + \"/Main.html\") \n\nlet compileRunP pos = getSnpO() |> compileRunW pos  |> Wrap.map ignore |> Wrap.start sendMsg\nlet justCompile     = getSnpO   >> compileSnippetW  >> Wrap.map ignore >> Wrap.start sendMsg\nlet evaluateFS      = getSnpO   >> evaluateSnippetW >> Wrap.map ignore >> Wrap.start sendMsg\nlet compileRun  ()  = compileRunP position.Value\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"afaac2af-143d-4745-9447-7e8d3044950f"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},"expanded":true,"level":0,"properties":{}},{"name":"Messaging","content":"#if NOMESSAGING\n#else\n\nlet fsStationClient = FsStationClient(fsIds, fsIds, endPoint = JS.Window.Location.Href)\n\nlet transMsgs (msgs: ErrMsg list)  =  msgs |> Seq.map (fun e -> e.ErrMsg, if e.IsWarning then FSWarning else FSError) |> Seq.toArray\n\nlet result2response res = \n    match res with \n    | Result (a, b) -> StringResponseR (a, b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet respond fromId (msg:FSMessage) : Async<FSResponse> =\n    async {\n        match msg with\n        | GetWholeFile                     -> return  codeSnippets.Value            |> Seq.toArray |> Json.Serialize |> Some                                   |> StringResponse       \n        | GetSnippetContentById sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.content        )                             |> StringResponse       \n        | GetSnippetCodeById    sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse \n        | GetSnippetPredsById   sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippetById        sId        -> return  CodeSnippet.FetchO       sId                                                                             |> SnippetResponse \n        | GetSnippetContent     path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.content        )                             |> StringResponse\n        | GetSnippetCode        path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse\n        | GetSnippetJSCode      path       -> match   CodeSnippet.FetchByPathO path with\n                                              | Some snp -> let!    jsR = translateAR (snp.GetCodeFsx true) false\n                                                            return (jsR |> Result.map RunCode.completeJS |> Result.getOption, jsR |> Result.getMsgs |> transMsgs)      |> StringResponseR\n                                              | None     -> return (None, [| \"Snippet not found\" , FSError |] )                                                |> StringResponseR\n        | GetSnippetPreds       path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippet            path       -> return  CodeSnippet.FetchByPathO path                                                                            |> SnippetResponse \n        | GenericMessage        txt        -> return  (Some <| \"Message received: \" + txt)                                                                     |> StringResponse\n        | GetIdentification                -> return  fromId                                                                                                   |> IdResponse  \n        | RunSnippetUrlJSById  (sId , url) -> return! CodeSnippet.FetchO       sId  |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunSnippetUrlJS      (path, url) -> return! CodeSnippet.FetchByPathO path |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n    }     \n     \nlet respondMessage fromId txt =\n    async {\n        let  msg = Json.Deserialize txt \n        let! res = respond fromId msg\n        return Json.Serialize res\n    }\n\n1000 |> JS.SetTimeout (fun () -> fsStationClient.MessagingClient.AwaitMessage respondMessage) |> ignore\n\n#endif","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"}],"id":{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},"expanded":true,"level":0,"properties":{}},{"name":"List Code","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\n\nlet curPredecessors = Val.map getPredecessorsM.Call currentCodeSnippetO\n\nlet isIndirectPredecessor pre (predecessors: HashSet<CodeSnippetId>) = predecessors.Contains pre //predecessors |> Set.contains pre\n\n//let isIndirectPredecessorT (preId, curId) = getPredecessors curId |> Set.contains preId            // horrible performance\n//let isIndirectPredecessorM  preId  curId  = (Useful.memoize isIndirectPredecessorT) (preId, curId) // horrible performance\n\nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecessors CodeSnippet.FetchO |> HashSet) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirtyPred()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                    code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor    code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor  code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                              )\n                    SomeAttr <| on.drag    (fun _ _  ->                                              draggedId <- code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"-\"        else \"+\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (sprintf \"%dem\" <| code.Level)\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n\nlet listEntries snps =\n    div [ \n        yield style \"overflow: auto\"\n        yield! \n            snps\n            |> Seq.indexed\n            |> Seq.mapFold (fun expanded (i, snp) ->\n                if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n                    let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n                    let isExpanded  = isParent && snp.expanded\n                    (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n                else  (None, expanded)\n            )  (Set [])\n            |> fst\n            |> Seq.choose id\n    ]","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true,"level":0,"properties":{}},{"name":"Deserialize","content":"let inline ifUndef def v = if isUndefined v then def else v\nlet obj2CodeSnippetId o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> CodeSnippetId \n\nlet obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n    if isUndefined o then\n        None\n    else\n        Some <| obj2CodeSnippetId o\n\nlet obj2Map o =\n    if isUndefined o then\n        Map.empty\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n\nlet deserializeCodeSnipets v = \n    try\n        let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n        printfn \"%A\" <| Array.length objs\n        let snps =\n            objs\n            |> Array.choose (fun o ->\n                 if isUndefined o then None else\n                 {\n                    name         = o?name         |> ifUndef \"\"\n                    content      = o?content      |> ifUndef \"\"\n                    parent       = o?parent       |> obj2CodeSnippetIdO\n                    predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                    id           = o?id           |> obj2CodeSnippetId\n                    expanded     = o?expanded     |> ifUndef false\n                    level        = o?level        |> ifUndef 0\n                    properties   = o?properties   |> obj2Map\n                  } |> Some)\n        snps\n    with _ -> [||]","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},"expanded":true,"level":0,"properties":{}},{"name":"Add,Delete,Load,Save","content":"let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) -> CodeSnippet.New(i + 1, \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = findRootElement e\n      loadTextFile (root.QuerySelector(\"#\" + fileInputElementId))\n        (fun txt ->\n            try\n                txt\n                |> deserializeCodeSnipets\n                |> codeSnippets.Set\n                setClean()\n                refreshView()\n            with e -> JS.Alert <| e.ToString()\n        )\n\nlet downloadFile() =\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n                \nlet do_LoadFile (e:Dom.Element) _ =          \n    let root = findRootElement e\n    (root.QuerySelector(\"#\" + fileInputElementId))?click()\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"54304360-819a-498c-a091-e6ece880a35a"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true,"level":0,"properties":{}},{"name":"codeMirror","content":"let autoCompleteClient = FSAutoComplete.FSAutoCompleteClient(\"FSharpStation\", endPoint = JS.Window.Location.Href)\n\n#if FSS_SERVER\nlet parseFile = @\"FS_ParseFile.fsx\"\n#else\nlet parseFile = @\"..\\FS_ParseFile.fsx\"\n#endif\n\nlet setDirtyCond() =\n    match lastCodeAndStarts with\n    | Some (pId, _, red) when pId = currentCodeSnippetId.Value -> setDirtyPart()\n    | _                                                        -> setDirty    ()\n\nlet getCodeAndStartsFast msgF (snp:CodeSnippet) addLinePrepos =\n    let red0, cur = \n        match lastCodeAndStarts with\n        | Some (pId, alp, red) when pId = snp.id && alp = addLinePrepos -> msgF \"Reparsing...\"; red, snp.PrepareSnippet\n        | _ -> \n        msgF \"Parsing...\"\n        let preds = snp.Predecessors()\n        let red = CodeSnippet.ReducedCode addLinePrepos preds.[0..preds.Length - 2]\n        let cur = preds.[preds.Length - 1]\n        lastCodeAndStarts <- Some(cur.id, addLinePrepos, red)\n        red, cur\n    let red1 = CodeSnippet.ReducedCode addLinePrepos [| cur |]\n    CodeSnippet.AddSeps red0 red1\n    |> CodeSnippet.FinishCode addLinePrepos\n\nlet mutable parseRun = 1\n\nlet parseFSA silent =\n    async {\n        let msgF = if silent then ignore else fun txt -> codeMsgs.Value <- txt\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let runN = parseRun + 1\n        parseRun <- runN\n        let  code, starts = getCodeAndStartsFast msgF cur false\n        let! res          = autoCompleteClient.Parse(parseFile, code, starts)\n        parsed           <- true\n        if not silent && runN = parseRun then\n            sendMsg res\n            sendMsg \"Parsed!\"\n    }\n\nlet parseFS() = \n    async {\n        lastCodeAndStarts <- None\n        do! parseFSA false\n    } |> Async.Start \n\n\nlet mustParse (cur:CodeSnippet) =\n    async {\n        printfn \"parsed = %b\" parsed\n        if not parsed then return true \n        else\n            printfn \"going to call autoCompleteClient.MustParse %s\" cur.NameSanitized\n            let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n            printfn \"returned1 %b\" must\n            return must\n    }\n\nlet rec parseIfMustThen silent =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        printfn \"checking if mustParse %s\" cur.NameSanitized\n        let! must = mustParse cur\n        printfn \"returned2 %b\" must\n        if must then \n            printfn \"going to parse %s\" cur.NameSanitized\n            do! parseFSA silent\n            printfn \"recursive parseIfMustThen %s\" cur.NameSanitized\n            do! parseIfMustThen silent\n    }\n\nlet getStartWord (line:string) ch =\n    match line.Substring(0, ch) with\n    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet getEndWord (line:string) ch =\n    match line.Substring(ch) with\n    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet showToolTip (ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let  sub   = (getStartWord l pos.ch |> String.length)   \n        let  add0  = (getEndWord   l pos.ch |> String.length)    \n        let  add   = if sub = 0 && add0 = 0 then 2 else add0 \n        let! tip   = autoCompleteClient.ToolTip  (parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        sendMsg <| sprintf \"InfoFSharp \\\"%s %A - %A %s \\\"\" cur.NameSanitized (pos.line + 1, pos.ch - sub + 1) (pos.line + 1, pos.ch + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen true\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = getStartWord l pos.ch     \n        let! com    = autoCompleteClient.Complete(parseFile, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        cb { Template.list   = com \n                               |> Array.map (fun (dis, rep, cls, chr) -> \n                                    { text        = rep\n                                      displayText = chr + \"| \" + dis\n                                      className   = cls                              \n                                    })\n             Template.from   = { pos with ch = pos.ch - word.Length }\n             Template.``to`` = pos \n           }\n    } |> Async.Start\n    \nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        match codeMsgs.Value with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n            if file.StartsWith cur.id.Text || file = sanitize cur.name then\n                let ind = if int indent > 0 then int indent else 0\n                { Template.LintResponse.message  = msg\n                  Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n                  Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n                  Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n                } |> Some\n            else     None\n          )\n        |> cb\n    } |> Async.Start\n\nlet codeMirror = \n    Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId)\n        .OnChange(setDirtyCond)\n        .OnRender(fun ed ->\n          ed.AddKeyMap({  F2              = showToolTip            \n                          LeftDoubleClick = showToolTip\n                          ``Ctrl-Space``  = Template.showHints ed getHints false\n                       })\n          Template.setLint ed getAnnotations \n        )\n        .Style(\"height: 100%\")\n\ncodeMsgs\n|> Val.sink (fun msgs ->\n    async {\n        if not parsed then () else\n        match codeMirror.editorO  with\n        | None    -> () \n        | Some ed ->\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = autoCompleteClient.MustParse(parseFile, cur.NameSanitized)\n        if must       then () else\n        ed?performLint() |> ignore\n    } |> Async.Start      \n)\n//let mutable prior = \"\", \"\"\n//Val.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n//|> Val.sink (fun (msgs, curO) ->\n//    async {\n//        match codeMirror.editorO  with\n//        | None        -> () \n//        | Some editor ->\n//            match curO with \n//            | None -> () \n//            | Some cur ->\n//            curSnippetNameOf cur.id\n//            |> Val.iter (fun name ->\n//                printfn \"RemoveMarks: %s\" name\n//                if prior = (msgs, name) then () else\n//                prior   <- (msgs, name)\n//                editor.RemoveMarks()\n//                match msgs with\n//                | REGEX rex \"g\" m -> m\n//                | _               -> [||]\n//                |> Array.choose (fun v ->\n//                    match v with\n//                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n//                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n//                    | _ -> None\n//                )\n//                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n//                    printfn \"inside -%s-%s-\" file (sanitize name)\n//                    if file.StartsWith cur.id.Text || file = sanitize name then\n//                        100\n//                        |> JS.SetTimeout (fun () ->\n//                            editor.MarkText (fl - 1, fc - 1) (tl - 1, tc - 1) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n//                        |> ignore\n//    \n//                )\n//            )\n//    } |> Async.Start\n//)\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},"expanded":true,"level":0,"properties":{}},{"name":"styleEditor","content":"let styleEditor    =\n     \"\"\"\ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true,"level":0,"properties":{}},{"name":"Actions","content":"\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(do_LoadFile                )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick(Do downloadFile  ()        ).Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do addCode       ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do deleteCode    ()        ).Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do indentCodeIn  ()        ).Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do indentCodeOut ()        ).Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do getFSCode     ()        ).Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do evaluateFS    ()        ).Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do compileRunP   NewBrowser).Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do compileRunP   Below     ).Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do compileRun    ()        ).Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do parseFS       ()        ).Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do justCompile   ()        ).Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          span []       \n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; NewBrowser ] position |> someElt\n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditorGrid","content":"let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New(codeMsgs).Placeholder(\"Output:\"    ).Title(\"Messages\"                 ).Render\n     \"JavaScript\", Template.TextArea.New(codeJS  ).Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(codeFS  ).Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n    \n(*\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1)\n     .ColAuto(     0.0)\n     .ColVariable( 0.0).Min(0.0).Max(Val.map ((-) 92.0) spl1.GetValue).Before.Children([ style \"grid-row   : 1 / 5\" ])\n     .RowFixedPx( 34.0) \n     .RowAuto(     0.0)\n     .RowVariable(17.0)                                               .Before.Children([ style \"grid-column: 2 / 3\" ])\n     .RowFixedPx( 80.0)\n     .Padding(1.0)\n     .Content(\"sidebar\", \n         codeSnippets.View\n         |> View.SnapshotOn codeSnippets.Value refresh.View\n         |> bindHElem listEntries\n      )\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TabStrip  .New(Messages).Top                                                                        .Render)\n     .Content(\"footer\"  ,       \n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actCompileWS     .Button.Render\n              actRunWSIn       .Button.Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n     .Style(\"\"\" \n            grid-template-areas:\n                'header0 header   sidebar2'\n                'sidebar content1 sidebar2'\n                'sidebar content2 sidebar2'\n                'footer  footer   sidebar2';\n            color      : #333;\n            height     : 100%;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\")\n\n*)","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"e702bf50-ad01-45eb-8b7b-813cc9046bef"},{"$":0,"Item":"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"},{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"},{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true,"level":0,"properties":{}},{"name":"MainForm","content":"let snippetList = \n    codeSnippets.View\n       |> View.SnapshotOn codeSnippets.Value refresh.View\n       |> bindHElem listEntries\n       \nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                       .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\n\nlet title         = SHtmlNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\nlet messages      = STabStrip <| TabStrip.New(Messages).Top\nlet code          = SHtmlNode <| codeMirror.Render\nlet snippets      = SHtmlNode <| snippetList\nlet buttons       = SHtmlNode <| buttonsH\nlet menu          = SHtmlNode <| menuBar\n\nlet title_code    = SplitterStructure.New(       title        , code         , fixedHorSplitter1 34.0)\nlet code_buttons  = SplitterStructure.New(       title_code   , buttons      , fixedHorSplitter2 80.0)\nlet snippets_code = SplitterStructure.New(true , snippets     , code_buttons ,                   15.0)\nlet main_messages = SplitterStructure.New(false, snippets_code, messages     ,                   82.0)\nlet main_window   = SplitterStructure.New(       menu         , main_messages, fixedHorSplitter1 50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\n\nlet rootSplitter = SplitterNode.New(main_window)\n\ndiv [ style \"height: 100vh; width: 100% \"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n      script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n      script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n      link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n      link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n      css styleEditor                                                                                                               \n      style  \"\"\" \n            color      : #333;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\"\n    ]\n|> renderDoc\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"a48d72fc-5220-4dac-b3b3-98bad48b0561"}],"id":{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},"expanded":true,"level":0,"properties":{}},{"name":"CodeEditor (old not used)","content":"let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"}],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true,"level":0,"properties":{}},{"name":"Editor2","content":"// Version using ZafirTranspiler.dll & Remote.dll\n[< JavaScript >]\nlet Main = FSharpStationClient() |> Doc.Run JS.Document.Body\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"8fbd59ac-9417-4309-8d01-3ccd5d62452c"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"8d84a97a-8fbf-4ee6-81c3-cf70db4adfa4"},"expanded":true,"level":0,"properties":{}},{"name":"Site","content":"// Version using internal Rpc's\n#define FSS_SERVER\n//#define NOMESSAGING\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(\n        Title = \"F# Station\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] \n                  Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"/EPFileX/CIPHERSpaceLoadFiles.js\"           ] [] \n                ]\n      , Body  = [ Html.client <@  FSharpStationClient () @> ])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},"expanded":true,"level":0,"properties":{}},{"name":"FSharpStation","content":"#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\Zafir.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n//#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9010/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some site\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA : int ref = ref 0\n            let maxB : int ref = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"95a237c8-a9ff-40d1-bd72-bd298b20af8c"},{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"}],"id":{"$":0,"Item":"0dbfcc9d-8ea2-42a3-8f81-ce2bf7d0fad4"},"expanded":true,"level":0,"properties":{}},{"name":"compile & run FSharpStation","content":"#define FSS_SERVER\n\nopen System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n                     + opDirectory    /= \"Compiled/FSharpStation2\"\n                     + siteOptions\n                     + (opGenInternal /= \"showoptions\")\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"%s\"              res\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9020/\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"529e1429-a4ce-48be-a89f-f13fec19bef3"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Snippets1","content":"[< JavaScript >]\nmodule Snippets =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":false,"level":0,"properties":{}},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode(\"HEllo\").RunHtml//PlusFree\n   \n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nh3 [\n  inp.Render\n  htmlText inp.Var\n  htmlElement \"h2\" [ htmlText inp.Var ]\n  h1 [ htmlText inp.Var ]\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Code","content":"open FSAutoComplete\nopen Template\nopen Useful\n\nlet  file               = @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\Test.fsx\"\nlet  autoCompleteClient = FSAutoCompleteClient(\"Demo Code\")\n\ntype KeyMapAutoComplete = { \n    F2             : CodeMirrorEditor -> unit \n    ``Ctrl-Space`` : CodeMirrorEditor -> unit\n}\n\n[< Inline \"$editor.setOption('extraKeys', { 'F2': function(cm) { var pos = cm.getCursor(); $f(pos) } })\" >]\nlet addMiddleClick (f: CodeMirrorPos -> unit) (editor:CodeMirrorEditor) = ()\n\nlet showToolTip (ed:CodeMirrorEditor) =\n    printfn \"showToolTip\"\n    async {\n        let  pos = ed.GetCursor()\n        let! tip = autoCompleteClient.ToolTip(file, pos.line + 1, pos.ch + 1)\n        do   JS.Alert tip\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = match l.Substring(0, pos.ch) with\n                      | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                      | _                                      -> \"\"          \n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        let! com    = autoCompleteClient.Complete(file, pos.line + 1, pos.ch + 1)\n        cb { list   = com |> Array.map (fun (dis, rep, cls, chr) -> \n                            { text        = rep\n                              displayText = chr + \"| \" + dis\n                              className   = cls                              \n                            })\n             from   = { pos with ch = pos.ch - word.Length }\n             ``to`` = pos \n           }\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        match res with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n            { message  = msg\n              severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" else \"warning\")\n              from     = cmPos(fl - 1, fc - 1) \n              ``to``   = cmPos(tl - 1, tc - 1)\n            }\n          )\n        |> cb\n    } |> Async.Start\n\nlet code = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\")\n       .OnRender(fun ed -> \n          ed.SetOption(\"gutter\", [| \"CodeMirror-lint-markers\" |])\n          ed.AddKeyMap({ F2             = showToolTip \n                         ``Ctrl-Space`` = showHints   ed getHints false\n                       })\n          setLint ed getAnnotations \n       )\n\ndiv [ \n      code.Render\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.\nFix it now.\n              \"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      Template.Button.New(\"Parse\").OnClick(fun _ _ -> \n          code.editorO \n          |> Option.iter (fun ed -> autoCompleteClient.Parse(file, ed.GetValue()) |> Async.map ignore |> Async.Start)\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n      h1 [ htmlText code.Var ]            \n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"18d8153d-422c-42f6-8266-9a9d854bd6a1"},{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"a05dd36e-a15e-4394-8013-128e21e69574"},{"$":0,"Item":"08e9600a-804b-4aba-a262-85f22e0cc8de"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true,"level":0,"properties":{}},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     \n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Grid","content":"open Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nGrid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div [ htmlText \"Div22\" ; style \"background-color: lightgreen\" ])\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n    .Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"id":{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true,"level":0,"properties":{}},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true,"level":0,"properties":{}},{"name":"InputSelect","content":"module InputSelect = \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    let positionTxt v =\n        match v with\n        | Below      -> \"Below\"\n        | Right      -> \"Right\"\n        | Tab        -> \"In Tab\"\n        | NewBrowser -> \"New Browser\" \n    \n    let position = Var.Create Below \n    \n    let inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n        match s with\n        | \"Below\"        -> Below     \n        | \"Right\"        -> Right     \n        | \"In Tab\"       -> Tab       \n        | \"New Browser\"  -> NewBrowser\n        | _              -> prev\n        ) )\n    \n    div [\n      inp.Render\n      Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n    ]\n    |> RunCode.RunNode().RunHtml\n        ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true,"level":0,"properties":{}},{"name":"Regex Pattern matching","content":"module regex1 =\n    // from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\n    let str    = new String(\"Bob likes pineapples.\")\n    let regex  = new RegExp(@\"^\\w+\") // matches the first word\n    let newstr = str.Replace(regex,\"Alice\")\n    \n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None\n        \n    let duple a b = a, b\n    4 * 8\n    let txt = \"\"\"Compiling to JavaScript...\n    2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    //\"\n    let rex = rex1 + \"|\" + rex2\n    \n    //[ \"JavaScript RegExp:\"\n    //  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n    //  sprintf \"Active pattern: %A\" <|\n    //      match txt with\n    //      | REGEX rex m -> m\n    //      | _           -> \"<no match>\"\n    //]\n    //|> List.map  (fun t -> div [ htmlText t ] )\n    //|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n    //|> List.map  (htmlText >> List.singleton >> div )\n    //|> (duple (style \"text-align: left\") >> List.Cons) \n    //|> RunCode.RunNode().ShowHtmlResult\n    \n    let inp = Template.TextArea.New(txt)                            .Placeholder(\"Text\")\n    let rx  = Template.Input   .New(rex).Prefix(htmlText \"RegEx  :\").Placeholder(\"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\")  \n    let opt = Template.Input   .New(\"g\").Prefix(htmlText \"Options:\").Placeholder(\"Options: g i m u y\") \n    \n    h5 [\n      inp.Render\n      rx .Render\n      opt.Render\n      Val.map3 (fun inp rx opt ->\n              ul [\n                  match inp with\n                  | REGEX rx opt m -> yield! m |> Array.map (htmlText >> List.singleton >> li)\n                  | _              -> yield  htmlText \"<no match>\" \n              ]\n          ) inp.Var rx.Var opt.Var\n          |> bindHElem id\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //open System.Text.RegularExpressions\n    //\n    //let (|Regex|_|) pattern input =\n    //    let m = Regex.Match(input, pattern)\n    //    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    //    else None\n    //\n    ////Example:\n    //let phone = \"(555) 555-5555\"\n    //match phone with\n    //| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    //    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n    //| _ -> printfn \"Not a phone number\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true,"level":0,"properties":{}},{"name":"Regex Pattern matching2","content":"module regex2 =\n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None \n       \n    let txt = \"\"\"Compiling to JavaScript...\n    Compiling to JavaScript...\n    Compiled!\n    0 errors, 1 warnings\n    WarningFSharp\n      \"(6)47f7c0ba-35b0-466e-a759-4e4d9963e524 codeMirror (1,11) - (1,19) typecheck 1178: The struct, record or union type 'KeyMapF2' is not structurally comparable because the type 'obj' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type 'KeyMapF2' to clarify that the type is not comparable\"\n      2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    let rex = rex1 + \"|\" + rex2\n    \n    match txt with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n    |> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n    |> h5\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"218507eb-4a87-4c11-b5d9-53a2213dd36a"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"}],"id":{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},"expanded":true,"level":0,"properties":{}},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true,"level":0,"properties":{}},{"name":"Storage","content":"module Storage =\n    let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\n    let max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\n    let value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n    \n    let settingsStorage = JS.Window.LocalStorage\n    \n    settingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n    \n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n    \n    let styleT   p =\n      p |> sprintf \"\"\"\n    .SplitterArea {\n        display: grid;\n        grid-template-columns: %f%% auto;\n        grid-template-areas:   \"left right\";\n        background-color: #41414d;\n        color: #444;\n        height: 50px;\n        grid-gap: 9px;\n        padding : 9px;\n    }\n    \n    .SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n    .SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n    \n    .Splitter { \n        grid-column     :    2      ;\n        grid-row        :  1/2      ;\n        width           :    5px    ; \n        margin-left     : -7.5px    ; \n        border          :    0px    ; \n        padding         :    0px    ;\n        cursor          : col-resize;\n      \tbackground-color: #eef      ; \n    }   \"\"\"\n    \n    let splitter   = Template.SplitterBar\n                         .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                         .Min(Val.map float min.Var)\n                         .Max(Val.map float max.Var)\n                         \n    \n    let bar =\n        div [\n          ``class`` \"SplitterArea\"\n          div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n          div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n          styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n          splitter.Render\n        ]\n        \n    div [\n      bar\n      min  .Render\n      max  .Render\n      value.Render\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true,"level":0,"properties":{}},{"name":"Messaging Test","content":"//#r @\"remote.dll\"\n\n//open CIPHERPrototype.Messaging\nopen FsStationShared\nopen System\nopen Useful\n\nlet messageTypes = \n    [\n        GetSnippetContentById CodeSnippetId.New\n        GetSnippetCodeById    CodeSnippetId.New\n        GetSnippetPredsById   CodeSnippetId.New\n        GetSnippetById        CodeSnippetId.New\n        GetSnippetContent     [||]\n        GetSnippetPreds       [||]\n        GetSnippetCode        [||]\n        GetSnippetJSCode      [||]\n        GetSnippet            [||]\n        GenericMessage        \"\"\n        GetIdentification     \n        GetWholeFile\n    ]\n    \nlet messageTxt v =\n    match v with\n    | GetSnippetContentById _ -> \"GetSnippetContentById\"\n    | GetSnippetCodeById    _ -> \"GetSnippetCodeById   \"\n    | GetSnippetPredsById   _ -> \"GetSnippetCodeById   \"\n    | GetSnippetById        _ -> \"GetSnippetById       \"\n    | GetSnippetContent     _ -> \"GetSnippetContent    \"\n    | GetSnippetPreds       _ -> \"GetSnippetPreds      \"\n    | GetSnippetCode        _ -> \"GetSnippetCode       \"\n    | GetSnippetJSCode      _ -> \"GetSnippetJSCode     \" \n    | GetSnippet            _ -> \"GetSnippet           \"\n    | GenericMessage        _ -> \"GenericMessage       \"\n    | RunSnippetUrlJS       _ -> \"RunSnippetUrlJS      \"\n    | RunSnippetUrlJSById   _ -> \"RunSnippetUrlJSById  \"\n    | GetIdentification       -> \"GetIdentification    \"\n    | GetWholeFile            -> \"GetWholeFile         \"\n\nlet fsClient = FsStationClient(\"MessagingTest\")\n\nlet snpId       = Var.Create \"\" \nlet message     = Var.Create \"\"\nlet messageType = Var.Create GetIdentification\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet getListeners _ _ =\n    async {\n        let! ls          = fsClient.MessagingClient.POListeners()\n        do   if listeners.Value <> ls then listeners.Value <- ls\n    } |> Async.Start\n\nlet requestMessage msgT (content:string) : Async<string> =\n    let msg =\n        match msgT with\n        | GetSnippetContentById _ -> GetSnippetContentById  <| CodeSnippetId (Guid content)\n        | GetSnippetCodeById    _ -> GetSnippetCodeById     <| CodeSnippetId (Guid content)\n        | GetSnippetPredsById   _ -> GetSnippetPredsById    <| CodeSnippetId (Guid content)\n        | GetSnippetById        _ -> GetSnippetById         <| CodeSnippetId (Guid content)\n        | RunSnippetUrlJSById   _ -> RunSnippetUrlJSById    <|(CodeSnippetId (Guid content), \"http://localhost:9000\")\n        | RunSnippetUrlJS       _ -> RunSnippetUrlJS        <|(content.Split '/'           , \"http://localhost:9000\")\n        | GetSnippetContent     _ -> GetSnippetContent      <| content.Split '/'\n        | GetSnippetPreds       _ -> GetSnippetPreds        <| content.Split '/'\n        | GetSnippetCode        _ -> GetSnippetCode         <| content.Split '/'\n        | GetSnippetJSCode      _ -> GetSnippetJSCode       <| content.Split '/'\n        | GetSnippet            _ -> GetSnippet             <| content.Split '/'\n        | GenericMessage        _ -> GenericMessage         <| content\n        | GetIdentification       -> GetIdentification    \n        | GetWholeFile            -> GetWholeFile         \n    async {\n        let! response = fsClient.SendMessage(AddressId(listener.Value |> Option.defaultValue \"WebServer:PostOffice\"), msg) |> Wrap.getAsync\n        let resp =\n            match response with\n            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n            | SnippetsResponse     snps     -> snps |> Json.Serialize\n            | StringResponse (Some code)    -> code\n            | IdResponse      id            -> id\n            | _                             -> sprintf \"<Incomplete response: %A>\" response\n        return resp\n    }\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(snpId  ).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          message.Value <- \"Sending request...\"\n          let! code = requestMessage messageType.Value snpId.Value\n          message.Value <- code\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5597a227-c983-46fc-87e2-cbe241faa279"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},"expanded":true,"level":0,"properties":{}},{"name":"Json.Parse","content":"module JsonParse =\n    open Useful\n    open FsStationShared\n    //let provider = WebSharper.Json.Provider\n    let inp = Template.TextArea.New(\"[ { \\\"name\\\": \\\"Hello\\\" }, { \\\"name\\\": \\\"How are you?\\\" } ]\").Placeholder(\"Text\")\n    \n    let inline ifUndef def v = if isUndefined v then def else v\n    let obj2CodeSnippetId o = \n        if isUndefined o then\n            System.Guid(\"00000000-0000-0000-0000-000000000000\")\n        else\n            o?Item\n        |> CodeSnippetId \n    \n    let obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n        if isUndefined o then\n            None\n        else\n            Some <| obj2CodeSnippetId o\n    \n    let obj2Map o =\n        if isUndefined o then\n            Map.empty\n        else\n            JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n    \n    let deserializeCodeSnipets v = \n        try\n            let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n            printfn \"%A\" <| Array.length objs\n            let snps =\n                objs\n                |> Array.choose (fun o ->\n                     if isUndefined o then None else\n                     {\n                        name         = o?name         |> ifUndef \"\"\n                        content      = o?content      |> ifUndef \"\"\n                        parent       = o?parent       |> obj2CodeSnippetIdO\n                        predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                        id           = o?id           |> obj2CodeSnippetId\n                        expanded     = o?expanded     |> ifUndef false\n                        level        = o?level        |> ifUndef 0\n                        properties   = o?properties   |> obj2Map\n                      } |> Some)\n            snps\n        with _ -> [||]\n    \n    \n    \n    h5 [\n      inp.Render\n      bindHElem (deserializeCodeSnipets >> Array.map (sprintf \"%A\" >> htmlText >> Seq.singleton >> li) >> ul) inp.Var\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},{"$":0,"Item":"368caae7-6a67-4063-9af3-978c25b81ac2"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}],"id":{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},"expanded":true,"level":0,"properties":{}},{"name":"WebSharper Snippets2","content":"[< JavaScript >]\nmodule Snippets2 = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"id":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"expanded":false,"level":0,"properties":{}},{"name":"Tab Panel","content":"printfn \"strip\"\nopen Template\n#nowarn \"1178\"\n\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | HtmlNode of HtmlNode\n    | TabStrip of TabStrip\n    | Split    of bool * Var<float> * SplitterNode * SplitterNode\nwith    \n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create             child1), SplitterNode (Var.Create             child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| HtmlNode child1), SplitterNode (Var.Create <| HtmlNode child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| TabStrip child1), SplitterNode (Var.Create <| TabStrip child2))\n    static member New(strip                          ) = TabStrip strip\n    static member New(node                           ) = HtmlNode node\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | HtmlNode node                -> node\n        | TabStrip strip               -> strip.Render  \n        | Split   (ver, var, ch1, ch2) ->\n        let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                           .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n        if ver then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n               else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, TabStrip  node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, HtmlNode  node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | HtmlNode HtmlEmpty           -> true\n        | HtmlNode _                   -> false\n        | TabStrip strip               -> strip.tabs.Value.Length = 0\n        | Split   (ver, var, ch1, ch2) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ver, var, ch1, ch2) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                          elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                           else ch1.UnSplitEmpties()\n                                                                ch2.UnSplitEmpties()\n        | _                            -> ()  \n\nlet tabs1 = \n      [|\n        \"Hello\"   \n        \"How\"   \n        \"Are\"   \n        \"You\"   \n        \"Today?\"\n      |]\n\nlet tabs2 = \n      [|\n        \"Very\"   \n        \"Well\"  \n        \"Thank\" \n        \"You\"   \n      |]\n\nlet direction    = Var.Create true\nlet createdNodes = System.Collections.Generic.Dictionary<System.Guid, Dom.Element>()\n\nlet getU tabs =\n    [| for tab in tabs do \n           yield tab\n               , Template.TextArea.New(tab:string).Render\n    |]\n    \nlet getU2 tabs = tabs |> getU |> Array.map (fun def -> System.Guid.NewGuid(), def)    \n\nlet tabs1V = TabStrip.New(getU tabs1).Top   \nlet tabs2V = TabStrip.New(getU tabs2).Bottom\n\nlet rootSplitter = SplitterNode.New(SplitterStructure.New(true, tabs1V, tabs2V))\n\ndo  TabMoved <- Some (fun _ -> rootSplitter.UnSplitEmpties())\n\ndiv [ style \"height: 500px\"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      //direction\n      //|> Val.map3 (fun t1 t2 dir-> t1,t2,dir) tabs1V.tabs tabs2V.tabs\n      //|> bindHElem (fun (t1,t2,dir) ->\n      //    match t1.Length, t2.Length with\n      //    | _, 0 -> tabs1V.Render\n      //    | 0, _ -> tabs2V.Render\n      //    | _, _ -> Grid.New\n      //                   .Content(\"one\", tabs1V.Render.Style(\"height: 100%; width: 100% \")\n      //                   .Content(\"two\", tabs2V.Render.Style(\"height: 100%; width: 100% \") )\n      //              |> (fun grid -> if dir then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n      //                                     else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render)\n      //    |> (fun html -> html.Style(\"height: 100%; width: 100% \")\n      //)\n      Button.New(\"print\"  ).OnClick(fun _ _ -> printfn \"strip\"                                                                ).Render\n      Button.New(\"Split\"  ).OnClick(fun _ _ -> direction.Value <- not direction.Value\n                                               rootSplitter.SplitMe(false, direction.Value)                                   ).Render\n      Button.New(\"New\"    ).OnClick(fun _ _ -> tabs1V.tabs.Value <- Array.append tabs1V.tabs.Value <| getU2 [| \"New1\" |] \n                                               tabs2V.tabs.Value <- Array.append tabs2V.tabs.Value <| getU2 [| \"New2\" |]      ).Render\n      //Button.New(\"UnSplit\").OnClick(fun _ _ -> rootSplitter.UnSplitEmpties()                                                  ).Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n\n//    css \"\n//:host {\n//  all: initial;\n//  display: block;\n//  contain: content; /* Boom. CSS containment FTW. */\n//}\"\n","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"cddabd38-7ecb-4692-99bd-13ca70e4232f"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}],"id":{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},"expanded":true,"level":0,"properties":{}},{"name":"Grid Bug","content":"\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"},"expanded":true,"level":0,"properties":{}},{"name":"Demo Action","content":"printfn \"Menu00\"\nopen Template\n\nlet actionClick act () = Val.iter (fun txt -> JS.Alert <| txt + \" Clicked!\") act.text\n\nlet actLoadFile       = Action.New(\"Load...\"                    ).OnClick2(Do2 actionClick () ) \nlet actSaveFile       = Action.New(\"Save as...\"                 ).OnClick2(Do2 actionClick () ).Highlight(true)\nlet actAddSnippet     = Action.New(\"Add Snippet\"                ).OnClick2(Do2 actionClick () )\nlet actDeleteSnippet  = Action.New(\"Delete Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actIndentSnippet  = Action.New(\"Indent Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actOutdentSnippet = Action.New(\"Outdent Snippet\"            ).OnClick2(Do2 actionClick () )\nlet actGetFsCode      = Action.New(\"Get F# Code\"                ).OnClick2(Do2 actionClick () )\nlet actEvalCode       = Action.New(\"Evaluate F#\"                ).OnClick2(Do2 actionClick () )\nlet actRunWSNewTab    = Action.New(\"Run WebSharper in new tab\"  ).OnClick2(Do2 actionClick () )\nlet actRunWSHere      = Action.New(\"Run WebSharper in WS Result\").OnClick2(Do2 actionClick () )\nlet actParseCode      = Action.New(\"Parse F#\"                   ).OnClick2(Do2 actionClick () )\nlet actCompileWS      = Action.New(\"Compile WebSharper\"         ).OnClick2(Do2 actionClick () )\n\nlet menu1 =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile      .MenuEntry\n                        actSaveFile      .MenuEntry\n                    ]\n            ) \n        MenuEntry.New(\"Code\")\n            .SubMenu(\n                    [\n                        actAddSnippet    .MenuEntry.MenuNode\n                        actDeleteSnippet .MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actIndentSnippet .MenuEntry.MenuNode\n                        actOutdentSnippet.MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actGetFsCode     .MenuEntry.MenuNode \n                    ]\n            ) \n        MenuEntry.New(\"Run\")\n            .SubMenu(\n                    [\n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet buttons =\n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              actLoadFile      .Button.Render\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actRunWSNewTab   .Button.Render\n              actCompileWS     .Button.Render\n//              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n\n\nprintfn \"Menu1\"\n\ndiv [\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -19px\" ]\n           <| menu1.Render \n           <| menu1.Render\n    buttons\n]       \n|> RunCode.RunNode().AddBootstrap.RunHtml","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"8346ae00-dde8-4368-acad-f8cca1164ff6"}],"id":{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},"expanded":true,"level":0,"properties":{}},{"name":"kimsereyblog single-page-app-with-websharper-uinext","content":"// https://kimsereyblog.blogspot.com/2015/08/single-page-app-with-websharper-uinext.html\n\n#r \"WebSharper.JQuery.dll\"\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule Domain =\n    type Claim = {\n        id: string\n        name: string\n    }\n\n    type Claims = Claim list\n\n    type User = {\n        id: string\n        fullName: string\n        emailAddress: Option<string>\n        phoneNumber: Option<string>\n        enabled: bool\n        claims: Claims\n    }\n\n[<JavaScript>]\nmodule Async =\n    let map f xAsync = async { let! x = xAsync\n                               return f x      }\n    let retn x       = async { return   x      }\n\n[<JavaScript>]\nmodule AsyncApi =\n    type ApiResult<'a> =\n        | Success of 'a\n        | Failure of ApiResponseException list\n\n    and ApiResponseException =\n        | Unauthorized of string\n        | NotFound of string\n        | UnsupportedMediaType of string\n        | BadRequest of string\n        | JsonDeserializeError of string\n        override this.ToString() =\n            match this with\n            | ApiResponseException.Unauthorized         err -> err\n            | ApiResponseException.NotFound             err -> err\n            | ApiResponseException.UnsupportedMediaType err -> err\n            | ApiResponseException.BadRequest           err -> err\n            | ApiResponseException.JsonDeserializeError err -> err\n\n    let map f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x   -> return Success(f x)\n            | Failure err -> return Failure err\n        }\n\n    let retn x = async { return ApiResult.Success x }\n\n    let apply fAsyncApiResult xAsyncApiResult =\n        async {\n            let! fApiResult = fAsyncApiResult\n            let! xApiResult = xAsyncApiResult\n            match fApiResult, xApiResult with\n            | Success f   , Success x    -> return Success(f x)\n            | Success f   , Failure err  -> return Failure err\n            | Failure err , Success f    -> return Failure err\n            | Failure err1, Failure err2 -> return Failure(List.concat [ err1; err2 ])\n        }\n\n    let bind f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x -> return! f x\n            | Failure err -> return (Failure err)\n        }\n\n    let start xAsyncApiRes =\n        xAsyncApiRes\n        |> Async.map (fun x -> ())\n        |> Async.Start\n\n    type ApiCallBuilder() =\n\n        member this.Bind(x, f) =\n            async {\n                let! xApiResult = x\n                match xApiResult with\n                | Success x -> return! f x\n                | Failure err -> return (Failure err)\n            }\n        member this.Return x = async { return ApiResult.Success x }\n        member this.ReturnFrom x = x\n\n    let apiCall = new ApiCallBuilder()\n\n[<JavaScript>]\nmodule ApiClient =\n    open WebSharper.JavaScript\n    open WebSharper.JQuery\n    open AsyncApi\n    open Domain\n    open WebSharper.UI.Next\n\n    type AuthToken =\n        { Token : string\n          Expiry : DateTime }\n        member this.IsExpired() = DateTime.UtcNow - this.Expiry < TimeSpan.FromMinutes(10.0)\n\n        static member Make token =\n            { Token = token\n              Expiry = DateTime.UtcNow }\n\n        static member Default =\n            { Token = \"\"\n              Expiry = DateTime.UtcNow }\n\n    type ValidToken =\n        | ValidToken of string\n\n    type Credentials =\n        { Username : string\n          Password : string }\n        static member Default =\n            { Username = \"admin\"\n              Password = \"admin\" }\n\n    type RequestSettings =\n        { RequestType :  JQuery.RequestType\n          Url         :  string\n          ContentType :  string option\n          Headers     : (string * string) list option\n          Data        :  string option }\n        member this.toAjaxSettings ok ko =\n            let success  (result:obj)  (_ : string) (_ : JqXHR ) : unit = ok (result :?> string)\n            let errorf   (jqXHR:JqXHR) (_ : string) (_ : string) : unit = ko (System.Exception(string jqXHR.Status))\n            let settings =\n                JQuery.AjaxSettings\n                    (Url      = \"http://localhost/api/\" + this.Url\n                   , Type     = this.RequestType\n                   , DataType = JQuery.DataType.Text\n                   , Success  = Action<obj,string,JqXHR> success\n                   , Error    = Action<JqXHR,string,string> errorf)\n\n            this.Headers     |> Option.iter (fun h -> settings.Headers     <- Object<string>(h |> Array.ofList))\n            this.ContentType |> Option.iter (fun c -> settings.ContentType <- Union2Of2 c                      )\n            this.Data        |> Option.iter (fun d -> settings.Data        <- d                                )\n            settings\n\n    type Api =\n        { Login     : Credentials -> Async<ApiResult<unit>>\n          Logout    : unit        -> unit\n          GetUsers  : unit        -> Async<ApiResult<User list>>\n          GetClaims : unit        -> Async<ApiResult<Claims>> }\n\n    [<Literal>]\n    let tokenStorageKey = \"authtoken\"\n\n    let private ajaxCall (requestSettings : RequestSettings) =\n        Async.FromContinuations <| fun (ok, ko, _) ->\n            requestSettings.toAjaxSettings ok ko\n            |> JQuery.Ajax\n            |> ignore\n\n    let private matchErrorStatusCode url code =\n        match code with\n        | \"401\" ->\n            Failure\n                [ ApiResponseException.Unauthorized\n                  <| sprintf \"\"\"\"%s\" - 401 The Authorization header did not pass security\"\"\" url ]\n        | \"404\" -> Failure [ ApiResponseException.NotFound <| sprintf \"\"\"\"%s\" - 404 Endpoint not found\"\"\" url ]\n        | \"415\" ->\n            Failure\n                [ ApiResponseException.UnsupportedMediaType\n                  <| sprintf \"\"\"\"%s\" - 415 The request Content-Type is not supported/invalid\"\"\" url ]\n        | code -> Failure [ ApiResponseException.BadRequest <| sprintf \"\"\"\"%s\" - %s Bad request\"\"\" url code ]\n\n    let private tryDeserialize deserialization input =\n        try\n            deserialization input |> ApiResult.Success\n        with _ ->\n            Failure [ ApiResponseException.JsonDeserializeError <| sprintf \"\"\"\"{%s}\" cannot be deserialized\"\"\" input ]\n        |> Async.retn\n\n    let private getToken() =\n        try\n            JS.Window.LocalStorage.GetItem tokenStorageKey\n            |> Json.Deserialize<AuthToken>\n            |> ApiResult.Success\n        with ex -> ApiResult.Failure [ Unauthorized \"Unauthorized\" ]\n        |> Async.retn\n\n    let private refreshToken (authToken : AuthToken) =\n        async {\n            let url = \"auth/login/token/renew\"\n            if not (authToken.IsExpired()) then return ApiResult.Success authToken.Token\n            else\n                try\n                    let! token = ajaxCall {\n                                    RequestType = JQuery.RequestType.POST\n                                    Url = url\n                                    ContentType = None\n                                    Headers = Some [ \"Authorization\", \"Bearer \" + authToken.Token ]\n                                    Data = None }\n                    return ApiResult.Success token\n                with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<string>)\n        |> AsyncApi.map (ValidToken)\n\n    let private login credentials =\n        async {\n            let url = \"auth/login/token\"\n            try\n                let! token = ajaxCall {\n                                RequestType = JQuery.RequestType.POST\n                                Url = url\n                                ContentType = Some \"application/json\"\n                                Headers = None\n                                Data = Some(Json.Serialize<Credentials>(credentials)) }\n                return ApiResult.Success token\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (Json.Deserialize<string>\n                          >> AuthToken.Make\n                          |> tryDeserialize)\n        |> AsyncApi.map (fun token -> JS.Window.LocalStorage.SetItem(tokenStorageKey, Json.Serialize<AuthToken>(token)))\n\n    let private logout() = JS.Window.LocalStorage.RemoveItem(tokenStorageKey)\n\n    let private getClaims (ValidToken token) =\n        async {\n            let url = \"auth/claims\"\n            try\n                let! claims = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success(claims)\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<Claims>)\n\n    let private getUsers (ValidToken token) =\n        async {\n            let url = \"users\"\n            try\n                let! users = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success users\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<User list>)\n\n    let api =\n        { Login    = login\n          Logout   = logout\n          GetUsers = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getUsers  validToken\n                                }\n          GetClaims = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getClaims validToken\n                                } }\n\n[<JavaScript>]\nmodule BootstrapUI =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n\n    module Button =\n        type private ButtonColor =\n            | Default\n            | Primary\n\n        type private ButtonStyle =\n            | FullWidth\n            | Inline\n\n        let private makeButton txt btnColor btnStyle action =\n            let classes =\n                [ yield \"btn\"\n                  yield match btnColor with\n                        | Default -> \"btn-default\"\n                        | Primary -> \"btn-primary\"\n                  yield match btnStyle with\n                        | FullWidth -> \"full\"\n                        | Inline -> \"inline\" ]\n                |> String.concat (\" \")\n            Doc.Button <| txt <| [ attr.``class`` classes\n                                   attr.``type`` \"submit\" ]\n            <| action\n\n        let bsBtnDefaultInline txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.Inline action\n\n        let bsBtnDefaultFull txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.FullWidth action\n\n        let bsBtnPrimaryInline txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.Inline action\n\n        let bsBtnPrimaryFull txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.FullWidth action\n\n    let bsNav brand leftLinks rightLinks =\n        let navHeader =\n            divAttr [ attr.``class`` \"navbar-header\" ]\n                    [ buttonAttr [ attr.``class`` \"navbar-toggle collapsed\"\n                                   Attr.Create \"data-toggle\" \"collapse\"\n                                   Attr.Create \"data-target\" \"#menu\"\n                                   Attr.Create \"aria-expanded\" \"false\" ]\n                                 [ spanAttr [ attr.``class`` \"sr-only\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] [] ]\n                      aAttr [ attr.``class`` \"navbar-brand title\"\n                              attr.href \"#\" ] [ text brand ] ]\n\n        let navMenu =\n            divAttr [ attr.``class`` \"collapse navbar-collapse\"\n                      attr.id \"menu\" ]\n                    [ ulAttr [ attr.``class`` \"nav navbar-nav\" ] [ leftLinks ]\n                      ulAttr [ attr.``class`` \"nav navbar-nav navbar-right\" ]\n                             [ rightLinks ] ]\n\n        navAttr [ attr.``class`` \"navbar navbar-default\" ]\n            [ divAttr [ attr.``class`` \"container-fluid\" ]\n                      [ navHeader; navMenu ] ] :> Doc\n\n    let bsInput placeHolder rvTxt =\n        Doc.Input [ attr.``class`` \"form-control\"\n                    attr.placeholder placeHolder ] rvTxt\n\n    let bsPasswordInput placeHolder rvPwd =\n        Doc.PasswordBox [ attr.``class`` \"form-control\"\n                          attr.placeholder placeHolder ] rvPwd\n\n    let bsPanelDefault body =\n        divAttr [ attr.``class`` \"panel panel-default\" ] [ divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsPanelDefaultWithTitle title body =\n        divAttr [ attr.``class`` \"panel panel-default\" ]\n                [ divAttr [ attr.``class`` \"panel-heading\" ]\n                          [ h3Attr  [ attr.``class`` \"panel-title\" ]\n                                    [ text title ] ]\n                  divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsAlertDanger message =\n        divAttr [ attr.``class`` \"alert alert-danger\"\n                  Attr.Create \"role\" \"alert\" ] [ text message ] :> Doc\n\n    let bsRow bsCol = divAttr [ attr.``class`` \"row\" ] bsCol\n\n    let bsCol3 body = divAttr [ attr.``class`` \"col-md-3\" ] body\n\n    let bsCol4 body = divAttr [ attr.``class`` \"col-md-4\" ] body\n\n    let bsContainer body = divAttr [ attr.``class`` \"container\" ] body\n\n    let bsJumbotron title body =\n        divAttr [ attr.``class`` \"jumbotron\" ]\n                [ divAttr [ attr.``class`` \"container\" ]\n                          [ h1 [ text title ] \n                            body ] ]\n\n[<JavaScript>]\nmodule ClientRoutes =\n    open WebSharper.UI.Next\n\n    type Page =\n        | Home\n        | Claims\n        | Users\n        | Login\n        override this.ToString() =\n            match this with\n            | Home -> \"Home\"\n            | Claims -> \"Claims\"\n            | Users -> \"Users\"\n            | Login -> \"Login\"\n\n    let private map =\n        function\n        | Home -> []\n        | Claims -> [ \"claims\" ]\n        | Users -> [ \"users\" ]\n        | Login -> [ \"login\" ]\n\n    let private reverMap =\n        function\n        | [] -> Home\n        | [ \"home\" ] -> Home\n        | [ \"claims\" ] -> Claims\n        | [ \"users\" ] -> Users\n        | [ \"login\" ] -> Login\n        | _ -> failwith \"404\"\n\n    let install () =\n        RouteMap.Create map reverMap\n        |> RouteMap.Install\n\n[<JavaScript>]\nmodule NavBarPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n    open ApiClient\n\n    let private makeNavlinks routerView go =\n        routerView\n        |> View.Map(fun currentPage ->\n               [ ClientRoutes.Home; ClientRoutes.Claims; ClientRoutes.Users ]\n               |> List.map\n                      (fun page ->\n                      liAttr [ if page = currentPage then yield attr.``class`` \"active\" ]\n                             [ Doc.Link (string page) [] (fun _ -> go page) ] :> Doc)\n               |> Doc.Concat)\n        |> Doc.EmbedView\n\n    let private logout go =\n        li [ Doc.Link \"Log out\" [] (fun () ->\n                                     api.Logout()\n                                     go ClientRoutes.Login) ] :> Doc\n\n    let doc routerView go = bsNav \"admin portal\" (makeNavlinks routerView go) (logout go)\n\n\n[<JavaScript>]\nmodule LoginPage =\n    open BootstrapUI\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open ApiClient\n\n    let private login rvUsername rvPassword rvLoginError go () =\n        async {\n            let! login = api.Login { Username = Var.Get rvUsername\n                                     Password = Var.Get rvPassword }\n            match login with\n            | AsyncApi.Failure err ->\n                Var.Set rvLoginError\n                        \"You may have keyed in an invalid Username or Password. Please try again.\"\n                api.Logout()\n            | _ -> ()\n            return login\n        }\n        |> AsyncApi.map (fun _ -> go ClientRoutes.Home)\n        |> AsyncApi.start\n\n    let doc go =\n        let rvUsername = Var.Create \"\"\n        let rvPassword = Var.Create \"\"\n        let rvErr = Var.Create \"\"\n\n        let nameInput = bsInput \"Username\" rvUsername\n        let pwdInput = bsPasswordInput \"Password\" rvPassword\n        let errDiv = rvErr.View\n                     |> View.Map(fun err ->     if err = \"\" then Doc.Empty\n                                                else bsAlertDanger err)\n                     |> Doc.EmbedView\n\n        let buttons =\n            bsPanelDefault\n                [ form [ errDiv\n                         nameInput\n                         pwdInput\n                         Button.bsBtnDefaultFull \"Log in\"\n                                                 (login rvUsername rvPassword rvErr go) ] ]\n        bsRow [ bsCol4 [ Doc.Empty ]\n                bsCol4 [ h1Attr [attr.``class`` \"title\"]\n                                [text \"admin portal\"]\n                         buttons ]\n                bsCol4 [ Doc.Empty ] ]\n\n\n[<JavaScript>]\nmodule HomePage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Hello,\"\n                    ([p [text \"Welcome to the admin portal v1.0.\"] :> Doc\n                      Button.bsBtnPrimaryInline \"View claims\"\n                                                (fun () -> go ClientRoutes.Claims) :> Doc\n                      Button.bsBtnPrimaryInline \"View users\"\n                                                (fun () -> go ClientRoutes.Users) :> Doc]\n                     |> Doc.Concat)\n\n[<JavaScript>]\nmodule ClaimsPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Claims\" Doc.Empty\n\n[<JavaScript>]\nmodule UsersPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Users\" Doc.Empty\n\n[<JavaScript>]\nmodule Client =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let Main =\n        let router = ClientRoutes.install()\n\n        let doc =\n            router.View\n            |> View.Map(fun page ->\n                   let go = Var.Set router\n\n                   let addNavBar body =\n                       [ NavBarPage.doc router.View go\n                         body ]\n                       |> Doc.Concat\n\n                   let embedInContainer body = bsContainer [ body ]\n\n                   match page with\n                   | ClientRoutes.Login ->\n                       LoginPage.doc go\n                       |> embedInContainer :> Doc\n                   | ClientRoutes.Home ->\n                       HomePage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Claims ->\n                       ClaimsPage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Users ->\n                       UsersPage.doc go\n                       |> embedInContainer\n                       |> addNavBar)\n            |> Doc.EmbedView\n\n        RunCode.RunNode().AddBootstrap.RunDoc doc","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[],"id":{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},"expanded":true,"level":0,"properties":{}},{"name":"Check All WebSharper Code","content":"// add everyone as a predecessor to check if they parse/compile","parent":{"$":0,"Item":"57a30378-4a52-4122-b297-fe5cec1bd067"},"predecessors":[{"$":0,"Item":"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"},{"$":0,"Item":"b9ca9697-6cb4-4085-b509-9f702a62086f"},{"$":0,"Item":"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"},{"$":0,"Item":"8ee8705a-f115-437e-8d7d-418773f3c6d4"},{"$":0,"Item":"332b130a-111b-48ca-bd75-26f96dcbb779"},{"$":0,"Item":"58e71035-74ac-4b97-8798-3a15d4944467"},{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}],"id":{"$":0,"Item":"a3bec308-c3bd-4fad-b400-b9a33d1b15c8"},"expanded":true,"level":0,"properties":{}},{"name":"Client-Server Demo","content":"module WSServer = ","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"id":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"expanded":false,"level":0,"properties":{}},{"name":"Client (and Rpc)","content":"\nlet invert (txt: string) : string = txt |> Seq.rev |> Seq.map string |> String.concat \"\"\n\n[< Rpc >]\nlet invertA txt = async { return invert txt }\n\n[< JavaScript >]\nlet ClientForm () =\n    let inp = Template.Input.New(\"Type something...\")\n    div [ \n      ``class`` \"container\"    \n      Template.Bootstrap().Render\n      Template.Panel.New\n        .Title(\"Client Server Demo\")\n        .Header([])\n        .Content(\n          [ h3 [\n              inp.Render\n              htmlText inp.Var\n              htmlElement \"h2\" [ htmlText inp.Var ]\n              h1 [ htmlText <| Val.mapAsync invertA inp.Var ]\n            ]\n          ]).Render\n    ] |> renderDoc\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"40614ad6-3f81-468b-a4ff-034124b82ae1"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},"expanded":true,"level":0,"properties":{}},{"name":"Site","content":"open WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\nopen WebSharper.UI.Next\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(\n        Title = \"Main Page\"\n      , Head  = [ Html.scriptAttr [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] ]\n      , Body  = [ Html.client <@  ClientForm () @> ])\n\nlet site = Application.MultiPage content\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"0dabc34f-673d-4f79-ae00-3960ca196392"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"id":{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"},"expanded":true,"level":0,"properties":{}},{"name":"ClientServerDemo","content":"#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n#r @\"HttpMultipartParser.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9000/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some site\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA = ref 0\n            let maxB = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"92837099-e4e4-4c7f-ac52-6c922824304f"}],"id":{"$":0,"Item":"7e36bd56-d4fa-4509-bece-b4444df38c5c"},"expanded":true,"level":0,"properties":{}},{"name":"compile & run ClientServerDemo","content":"open System.IO\nopen FsStationShared\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\n\nWrap.wrapper {\n    let  options   = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Client-Server Demo/ClientServerDemo\"\n                     + siteOptions\n    let  exeFile   = options?Output\n    let  site      = Path.GetFullPath(options?Website)\n    let! res       = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    do   printfn     \"Starting %s\"     exeFile\n    let  url       = @\"http://localhost:9001/\"\n    let  parms     = sprintf \"%A %A\" site url \n    do   runProcess  exeFile parms |> ignore\n    do   runProcess  url     \"\"    |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n","parent":{"$":0,"Item":"210013b7-280e-4692-a5b1-0b1512666b10"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},"expanded":true,"level":0,"properties":{}},{"name":"ACTIONS","content":"module Actions =","predecessors":[],"id":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"expanded":false,"level":0,"properties":{}},{"name":"SAVE Editor2.js","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetJS @\"..\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/Editor2\"\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},"expanded":true,"level":0,"properties":{}},{"name":"SAVE CodeEditor.fsx","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetFsx @\"..\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation/Editor2\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},"expanded":true,"level":0,"properties":{}},{"name":"SAVE FsJson File","content":"FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveWholeFile @\"..\\..\" \"CodeEditor\"","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b5ce4e03-57ad-4ec2-a8f2-445831815f01"},{"$":0,"Item":"b37f91be-7579-4fea-8263-bd10ec60f7e4"}],"id":{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"},"expanded":true,"level":0,"properties":{}},{"name":"DO Saves","content":"// Click Evaluate F#","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"},{"$":0,"Item":"56b4fb1e-909e-4b83-b312-8993751d0685"},{"$":0,"Item":"df25d045-936b-4f0e-9a22-429cd4f8848a"}],"id":{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},"expanded":true,"level":0,"properties":{}},{"name":"Compile Modules","content":"#define FSS_SERVER\n#define COMPILING\nopen FSSGlobal.FsStationShared // open's need to be here\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nlet fsStation = FsStationClient(\"Compile Modules\")\n[\n\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FSAutoComplete/FSAutoComplete\"    |> compileOptionsExeDebug    ","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"9c6e4168-1ae8-47f1-a1e3-b4dd93c2c900"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsTranslator/FsTranslator\"        |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"b89801cc-5412-4025-bd88-c6ec0624a970"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FsStationShared/SelfHostedServer\" |> compileOptionsExeDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"2db6dbb4-6c03-4c3d-990f-abfb997e9855"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"(\"FSSGlobal/F# Code/UsefulDotNet/RemotingDll\"        |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + opDirectory   /= \"Compiled/RemotingDll2\"\n  + wsProjectOptions\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"8deb7606-0602-4a16-83b4-4528985f267e"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/FSAutoComplete/FSAutoCompleteDll\" |> compileOptionsDllDebug\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"53c32bfe-219e-4ff1-8913-adbc067b40d4"},"expanded":true,"level":0,"properties":{}},{"name":"","content":"\"FSSGlobal/F# Code/Snippets/Calculate primes\"        |> compileOptionsWinExeDebug","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[],"id":{"$":0,"Item":"7196e914-b38c-489b-a119-c980432ac41b"},"expanded":true,"level":0,"properties":{}},{"name":"Compile","content":"// select the module(s) to compile\n\n] |> Seq.iter (id \n        //>> swap (+) [ opGenInternal /= \"showoptions\" ] \n        >> fsStation.CompileSnippetW \n        >> Wrap.runSynchronouslyS true\n        >> printfn \"%s\"\n     )\n","parent":{"$":0,"Item":"15ddb111-736f-4f18-9ff3-9b13f9560cb8"},"predecessors":[{"$":0,"Item":"53c32bfe-219e-4ff1-8913-adbc067b40d4"}],"id":{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},"expanded":true,"level":0,"properties":{}},{"name":"COMPILE FsAutoComplete.exe","content":"open FSSGlobal.FsStationShared\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nFsStationClient(\"Compile FsAutoComplete.exe\").CompileSnippetW(compileOptionsExeDebug \"FSSGlobal/F# Code/FSAutoComplete/FSAutoComplete\") |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n\n\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}],"id":{"$":0,"Item":"24394c61-747d-41ff-816e-c70e46573bb7"},"expanded":true,"level":0,"properties":{}},{"name":"RUN FsAutoComplete.exe","content":"FSSGlobal.UsefulDotNet.runProcess  \"Compiled\\FsAutoComplete.exe\" \"\" |> ignore // running the copy because I dont remember how to change the directory\n\n//FSSGlobal.Useful.runProcess  \"Compiled\\FsAutoComplete\\FsAutoComplete.exe\" \"\" |> ignore\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"b30f4582-64bd-49e5-aca2-29897fef74c5"},{"$":0,"Item":"9642aff4-4b1b-4807-93c3-7bf27a5b447f"}],"id":{"$":0,"Item":"c578e375-e299-4450-957e-1596e7af2007"},"expanded":true,"level":0,"properties":{}},{"name":"DO/check all ACTIONS","content":"// Just Select as predecessors all the actions you want to execute \n// and then click on Evaluate F#\n","parent":{"$":0,"Item":"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"},"predecessors":[{"$":0,"Item":"5e8209e0-9203-4fe0-8289-fb4579b24038"},{"$":0,"Item":"d39e3783-fb76-4963-b9fe-2da76c4b2a86"},{"$":0,"Item":"c8c93861-321c-4d73-beb0-2fef0052bc7b"},{"$":0,"Item":"e307def4-b29d-4abf-9ec6-8744c0b8d75a"},{"$":0,"Item":"c578e375-e299-4450-957e-1596e7af2007"},{"$":0,"Item":"24394c61-747d-41ff-816e-c70e46573bb7"},{"$":0,"Item":"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"}],"id":{"$":0,"Item":"64f180f8-8781-4630-9239-b5610a6329b6"},"expanded":true,"level":0,"properties":{}}]