{
"version": 3,
"sourceRoot": "Source",
"sources": ["RuleEditor/RuleEditor.fs"],
"sourcesContent": ["#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1547005003252 -d:WEBSHARPER\n////#cd @\"..\\projects\\RuleEditor\\src\"\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1547005003252\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            [< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDay()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\n            let nowStamp() = \n                let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n                t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n            \n            let [<Inline>] inline traceT t v = tee (sprintf \"%A\" >> (fun s -> s.[..min 100 s.Length-1]) >> printfn \"%s %s: %A\" (nowStamp()) t) v\n            let [<Inline>] inline trace   v = traceT \"trace\" v\n            let [<Inline>] inline traceI  v = trace          v |> ignore\n            \n            module Log =\n                let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n                let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n                let [<Inline>] inline InA    n f p = async { return! In  n f p }\n                let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n                let [<Inline>] inline InOut  n     = In  n >> Out  n\n                let [<Inline>] inline InOutA n f p = async {\n                    let!   r = InA n f  p\n                    do         Out n id r |> ignore\n                    return r \n                  }\n            \n                let [<Inline>] inline TimeIt n f p =\n                    printfn \"Starting %s\" n\n                    let start = System.DateTime.UtcNow.Ticks\n                    f p\n                    let elapsedSpan = new System.TimeSpan(System.DateTime.UtcNow.Ticks - start)\n                    print <| elapsedSpan.ToString()\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let warningf  fmt = Printf.ksprintf Warning  fmt\n                let infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let rtn                          = Ok\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | Ok    v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                       | Error e ->       e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofAsync            a  = FAM(fun (s, r) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                    let inline ofFusionM     (FM fm) = FAM(fun (s, r) -> async.Return (fm (s, r)) )\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n                \n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            module Var =\n                let mutable private counter = 1\n                let freshId () =\n                    counter <- counter + 1\n                    \"varuid\" + string counter\n                        \n                let lensView get update view0 (var: Var<_>) =\n                    let id   = freshId()\n                    let view = View.Map2 (fun v _ -> get v) var.View view0\n                    { new Var<'V>() with\n                        member this.Get        () = get (var.Get())\n                        member this.Set         v = var.Update(fun t -> update t v)\n                        member this.SetFinal    v = this.Set(v)\n                        member this.Update      f = var.Update(fun t -> update t (f (get t)))\n                        member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n                        member this.View          = view\n                        member this.Id            = id\n                    }\n            \n            module ListModel =\n                let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.FindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.TryFindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let lensDef def k (m:ListModel<_,_>) =\n                    let get = Option.defaultValue def\n                    lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n            \n                let currentLensUpd def curr upd (model:ListModel<_,_>) = \n                    curr \n                    |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                                    (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                                    model.View\n                let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n                    let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n                    Var.Make view upd\n                let currentLens def curr (model:ListModel<_,_>) = \n                    model \n                    |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n                \n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n    \n    module CalculationModel =\n        [< JavaScript >]\n        module CalculationModel =\n            open System\n            \n            type DimType =\n                | DtDataType\n                | DtTime\n                | DtVersion\n                | DtTCalc\n                | DtCalc\n                | DtMeasure\n                | DtOther\n            \n            type CubeType =\n                | CtOther\n                | CtCalc\n                | CtFreeze\n            \n            type AttType =\n                | AtString\n                | AtNumber\n            \n            type ElmType =\n                | EtString\n                | EtNumber\n            \n            type ModId = ModId of Guid with member x.Id = match x with ModId id -> id\n            type AttId = AttId of Guid with member x.Id = match x with AttId id -> id\n            type ElmId = ElmId of Guid with member x.Id = match x with ElmId id -> id\n            type CubId = CubId of Guid with member x.Id = match x with CubId id -> id\n            type DimId = DimId of Guid with member x.Id = match x with DimId id -> id\n            type CalId = CalId of Guid with member x.Id = match x with CalId id -> id\n            type TotId = TotId of Guid with member x.Id = match x with TotId id -> id\n            type ForId = ForId of Guid with member x.Id = match x with ForId id -> id\n            type RulId = RulId of Guid with member x.Id = match x with RulId id -> id\n            \n            type Attribute = {\n                attId          : AttId\n                attName        : string\n                attType        : AttType\n                attTableNum    : int\n            }\n            \n            type Element = {\n                elmId          : ElmId\n                elmDim         : DimId\n                elmType        : ElmType\n                elmName        : string\n                elmDescription : string\n                elmAttributes  : Map<AttId, string> \n                elmParents     : ElmId     []\n            } \n            \n            type Dimension = {\n                dimId               : DimId\n                dimName             : string\n                dimPrefix           : string\n                dimOrder            : string\n                dimExclude          : bool\n                dimFreeze           : bool\n                dimType             : DimType\n                defaultElm          : ElmId     option\n                mutable dimElements : Element   []\n                dimAttributes       : Attribute []\n                isCalcDim           : bool\n            }\n            \n            type UnaryOp = \n                | UoMinus\n                | UoPlus\n                \n            type Operator = \n                | OpAdd      \n                | OpSubtract \n                | OpMultiply \n                | OpDivide   \n                | OpEQ    \n                | OpNE\n                | OpGT       \n                | OpGE       \n                | OpLT       \n                | OpLE       \n                | OpAnd      \n                | OpOr           \n            \n            type Function = Function of string\n            \n            type ElmReference =\n                | ElemFixed   of DimId * ElmId\n                | ElemDynamic of DimId * ExpressionText\n                    \n            and  ExpressionText =\n                | ExtNA\n                | ExtStet\n                | ExtSlice      of Slice\n                | ExtString     of string\n                | ExtDimElement of DimId\n                | ExtDimName    of DimId\n                | ExtFunction   of Function         * ExpressionAny []\n                | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n            \n            and  ExpressionNumber =\n                | ExnNA\n                | ExnStet\n                | ExnSlice      of Slice\n                | ExnNumber     of float\n                | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n                | ExnUnaryN     of UnaryOp          * ExpressionNumber\n                | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n                | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n                | ExnFunction   of Function         * ExpressionAny []\n                | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n                | ExnIsNA       of ExpressionNumber\n                | ExnIsNAt      of ExpressionText\n                | ExnIsNAa      of ExpressionAny\n                \n            and ExpressionAny =    \n                | ExiNA\n                | ExiStet\n                | ExiSlice      of Slice\n                | ExNumeric     of ExpressionNumber\n                | ExText        of ExpressionText\n                | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n                \n            and  Slice = {\n                sliDims     : Map<DimId, ElmReference>   \n                calculation : CalId option\n                cube        : CubId option\n            } \n            \n            type ForType = \n                | ForBase\n                | ForConsolidated\n                | ForAll\n            \n            type Formula = {\n                forId          : ForId\n                forDestDecl    : Map<DimId, string>\n                forDestination : ElmReference list\n                forDescription : string\n                forText        : string\n                forExpression  : ExpressionAny\n                forType        : ForType\n                forOrder       : string\n            }\n            \n            type Calculation = {\n                calId          : CalId\n                calName        : string\n                calDescription : string\n                calOrder       : string\n                format         : string\n                isText         : bool\n                isInput        : bool\n                isBalance      : bool\n                calDims        : Set<DimId>\n                calFormulas    : Formula []\n                cubIdO         : CubId   option\n                properties     : Map<string, string>\n            }\n            \n            type NodeId =\n                | Calc of CalId\n                | Tot  of TotId\n            \n            type Total = {\n                totId          : TotId\n                totName        : string\n                totOrder       : string\n                totFormat      : string\n                children       : (float * NodeId) []\n            }\n            \n            type RuleKey = \n                | RuleKey     of RulId\n                | CalcRuleKey of CalId\n                | FormulaKey  of ForId\n                | ForTextKey  of ForId\n                | ActualRuleKey \n                | InputRuleKey\n                | ConsolidatedRuleKey\n            \n            type Cube = {\n                cubId          : CubId\n                cubName        : string\n                cubRules       : Map<RuleKey, Rule option>\n                cubRuleXmls    : Map<RuleKey, string>\n                cubDims        : DimId []\n                measureDim     : DimId option\n                cubType        : CubeType\n            }\n            \n            and  Rule = {\n                rulId          : RulId\n                rulSourceId    : IComparable\n                rulDescription : string\n                rulDestination : ElmReference list\n                rulExpression  : ExpressionAny\n                rulType        : ForType\n                rulOrder       : string\n                rulXml         : string\n            }\n            \n            type RuleMsg =\n            | GetInitModelStats\n            | GetRulesForCube of CubId\n            \n            type ReplyMsg =\n            | ReplyInformation of string\n            | ReplyRules       of (RuleKey * string) []\n            \n            [<NoComparison ; NoEquality>]\n            type Model = {\n                modId           : ModId\n                server          : string\n                actualElem      : string\n                modDims         : Dimension   []\n                modCubes        : Cube        []\n                modCalculations : Calculation []\n            } \n            \n            let Xmodel = \n              {\n                modId           = ModId <| Guid.NewGuid()\n                server          = @\"local\\Budget\"\n                actualElem      = \"Actual\"\n                modDims         = [||]\n                modCubes        = [||]\n                modCalculations = [||]\n              }\n                \n            let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n            let calcSlice calc : Slice = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = Some calc.calId\n                         cube          = None\n                     }\n                \n            type HelperTypeN = HelperTypeN with\n                static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n                static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n                static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n                static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n                static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n                static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n                \n            let [< Inline >] inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n            \n            type HelperTypeT = HelperTypeT with\n                static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n                static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n                static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n                static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n                static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n            \n            let [< Inline >] inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n            \n            type HelperTypeA = HelperTypeA with\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n            \n            let [< Inline >] inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n        \n            type Message =\n                | DimensionNotFound      of DimId\n                | DimensionHasNoElements of string\n                | ElementNotFound        of string * ElmId\n                | CubeNotFound           of CubId\n                | CubeHasNoMeasureDim    of string\n                | CalculationNotFound    of CalId\n                | CalculationHasNoCube   of string\n        \n            let ofOptF f = Result.ofOption (fun () -> Message <| f())\n            let ofOptS s = Result.ofOption (fun () -> Message <| s  )\n        \n            module internal Model0 =\n                let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n                let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n                let getDimR       dId mdl = getDimO  dId mdl |> Result.ofOption (fun () -> DimensionNotFound   dId)\n        \n            module Element  =\n                let newElement name = \n                  {\n                    elmId          = ElmId <| Guid.NewGuid()\n                    elmDim         = DimId <| Guid.NewGuid()\n                    elmType        = EtString\n                    elmName        = name\n                    elmDescription = name\n                    elmAttributes  = Map.empty\n                    elmParents     = [||]\n                  }\n        \n            module ElmReference =\n                let dimId elr =\n                    match elr with\n                    | ElemFixed  (id, _)\n                    | ElemDynamic(id, _) -> id\n        \n            module Slice =\n                let newSlice ds = {\n                         sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                         calculation   = None\n                         cube          = None\n                }\n                let forAll = {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = None\n                }\n                let addRef      elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n                let containsDim did slc = slc.sliDims |> Map.containsKey did\n           \n            module Dimension =\n                let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n                let getElementR      eId dim = getElementO eId dim |> Result.ofOption (fun () -> ElementNotFound(dim.dimName, eId))\n                let newDimension id name isCalcDim =\n                      {\n                        dimId          = id \n                        dimName        = name\n                        dimPrefix      = \"\"\n                        dimOrder       = \"\"\n                        dimExclude     = false\n                        dimFreeze      = false\n                        dimType        = DtOther\n                        defaultElm     = None\n                        dimElements    = [|  |]\n                        dimAttributes  = [|  |]      \n                        isCalcDim      = isCalcDim\n                      }\n                let newDimensionNonCalc id name  = newDimension id name false\n                let newDimensionCalc    id name  = newDimension id name true \n                let New                    name  = newDimension (DimId <| Guid.NewGuid()) name false\n                let [< Inline >] inline getElmReference it dim =\n                    match toExpT it with \n                    | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                                      let elm =\n                                         dim.dimElements                                 \n                                         |> Seq.tryFind (fun e -> e.elmName = s2)\n                                         |> Option.defaultWith (fun () -> \n                                             let newE = Element.newElement s2\n                                             dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                             newE\n                                         )\n                                      ElemFixed  (dim.dimId, elm.elmId) \n                    | exp          -> ElemDynamic(dim.dimId, exp      )  \n        //        member inline this.Item (it) = getElmReference it this\n                //member inline this.__     it     = this.Item it\n                //member inline this.M      it     = this.Item it\n                //member inline this.E      it     = this.Item it\n                //member inline this.I      it     = this.Item it\n                let prefix  pr   dim  = { dim with dimPrefix = pr   }\n                let dType   dt   dim  = { dim with dimType   = dt   }\n                let setName name dim  = { dim with dimName   = name }\n                let filter     dtypes : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\n                let sort             (ds:Dimension seq)                  = ds |> Seq.sortBy (fun d -> d.dimOrder)\n                let filterSort dtypes : (Dimension seq -> Dimension seq) = filter dtypes >> sort\n        \n            type Dimension with\n                [< Inline >] \n                member inline this.Item (it) = Dimension.getElmReference it this\n        \n        \n            module Cube =\n                let slice cub : Slice  = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = Some cub.cubId\n                     }\n                let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n                let isCalcCube                cub = cub.cubType = CtCalc    \n                let newCubeId id name dims mDimO cType = \n                        {\n                          cubId       = id\n                          cubName     = name\n                          cubDims     = dims\n                          cubRules    = Map.empty\n                          cubRuleXmls = Map.empty\n                          measureDim  = mDimO\n                          cubType     = cType\n                        }\n                let newCube     name            = newCubeId <| CubId (Guid.NewGuid()) <| name\n                let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n                let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n                let New()                       = newCube \"\" [||] None CtOther\n                let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n                let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n                //member inline this.Calc ()    = { this with cubType = CtCalc } \n                let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n                let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n                let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n                let measureDimR     model cub   = cub.measureDim         |> Result.ofOption (fun () -> CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n                let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n                \n            module Calculation =\n                let slice calc = calcSlice calc\n                let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n                let newInput id (name: string) dims  =\n                     {\n                        calId          = id\n                        calName        = name.Replace(\"_\", \" \").Trim()\n                        calDescription = \"\"\n                        calOrder       = \"\"\n                        format         = \"#,##0.00\"\n                        isText         = false\n                        isInput        = true\n                        isBalance      = false\n                        calDims        = dims |> Set \n                        calFormulas    = [||]\n                        cubIdO         = None\n                        properties     = Map.empty\n                     }\n                let newCalc id name dims      = { newInput id name dims     with isInput     = false  }\n                let New        ()             =   newInput (CalId <| Guid.NewGuid()) \"\"   []\n                let setName    name      calc = { calc                   with calName     = name   }\n                let setIsText  istext    calc = { calc                   with isText      = istext }\n                let setOrder   order     calc = { calc                   with calOrder    = order  }\n                let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n                let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n                let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n                let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n                let [< Inline >] getElemRefO(model: Model) calc =\n                    calc.cubIdO \n                    |> Option.bind (swap Model0.getCubeO model)\n                    |> Option.bind (fun cub ->  cub.measureDim) \n                    |> Option.bind (swap Model0.getDimO  model)\n                    |> Option.map  (Dimension.getElmReference calc.calName)\n                let cubeR           c = c.cubIdO        |> ofOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n                let [< Inline >] getElemRefR   m c = getElemRefO m c |> ofOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n                let sort             (cs:Calculation seq)                  = cs |> Seq.sortBy (fun c -> c.calOrder)\n        \n            module Total =\n                let newTotal name  = {\n                    totId          = TotId  <| System.Guid.NewGuid()\n                    totName        = name\n                    totOrder       = \"\"\n                    totFormat      = \"\"\n                    children       = [||]\n                }\n                let New() = newTotal \"\"\n                \n            module Model =\n                let mergeBy f a b = Array.append (Seq.toArray a) (Array.filter (fun e -> a |> Seq.map f |> Seq.contains (f e) |> not ) b)\n                let addCalcs     cs   mdl = { mdl with modCalculations = mergeBy (fun c -> c.calId) cs mdl.modCalculations }\n                let addDims      ds   mdl = { mdl with modDims         = mergeBy (fun c -> c.dimId) ds mdl.modDims         }\n                let addCubes     cs   mdl = { mdl with modCubes        = mergeBy (fun c -> c.cubId) cs mdl.modCubes        }\n                let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n                let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n                let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n                let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n                let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n                let getDimO               = Model0.getDimO\n                let getDimR               = Model0.getDimR\n                let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n                let getCubeO              = Model0.getCubeO\n                let getCalcR      cId mdl = getCalcO cId mdl |> Result.ofOption (fun () -> CalculationNotFound cId)\n                let getCubeR      cId mdl = getCubeO cId mdl |> Result.ofOption (fun () -> CubeNotFound        cId)\n                let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n                let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n                let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n                let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n                let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n                let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n                let timeDimO          mdl = pickDimO  DtTime     mdl\n                let versionDimO       mdl = pickDimO  DtVersion  mdl\n                let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n                let getCalcCube dims  mdl = \n                    mdl.modCubes \n                    |> Seq.filter  Cube.isCalcCube\n                    |> Seq.tryFind (fun cub -> \n                        cub.cubDims \n                        |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                        |> Set = dims )\n                let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n                let withDimsO mdl cube f =\n                    let (<*>)   = Option.apply\n                    let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n                    Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n                let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n                let dimCombinations model =\n                    model.modCalculations\n                    |>  Seq.map (fun c -> c.calDims)\n                    |>  Seq.distinct \n                let cubePrefix    = \"Z\"\n                let measurePrefix = \"M\"\n                let orderedDims dimIds model =\n                        model.modDims \n                        |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n                let autoName dimIds model =\n                    let nameBase =\n                        model\n                        |> orderedDims dimIds\n                        |> Seq.map (fun d -> d.dimPrefix)\n                        |>  String.concat \"\"\n                    let similar =\n                        model.modCubes\n                        |> Seq.choose (fun c -> \n                            match cubePrefix + nameBase with\n                            | n when c.cubName          = n -> Some -1\n                            | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> ParseO.parseIntO\n                            | _                             -> None\n                        ) \n                    nameBase\n                  + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n            \n                let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n                let fixForDimensions model =\n                    //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n                    let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n                    { model with modCalculations = calcs }\n                let newCalcCube dimIds model =\n                    let name = autoName dimIds model\n                    let mDim = Dimension.newDimensionCalc <| DimId (Guid.NewGuid()) <| measurePrefix + name\n                    let orderedDimIds = \n                        model\n                        |> orderedDims dimIds\n                        |> Seq.append <| [ mDim ]\n                        |> Seq.map (fun d -> d.dimId)\n                        |> Seq.toArray\n                    let dims  = Array.append model.modDims  [| mDim                                                                 |]\n                    let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n                    { model with modDims = dims ; modCubes = cubes }\n                let fixCalcsAndCubes model =\n                    let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cubIdO |> Option.bind (swap getCubeO model) |> Option.isNone)\n                    if Seq.isEmpty calNoCube then model else\n                        let modelN =\n                            calNoCube\n                            |> Seq.map      (fun c -> c.calDims)\n                            |> Seq.distinct\n                            |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                            |> Seq.fold      (swap newCalcCube) model\n                        let calcs =\n                            modelN.modCalculations\n                            |> Array.map (fun oldC ->\n                                    calNoCube \n                                    |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                                    |> Option.map  (fun newC -> { newC with Calculation.cubIdO = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                                    |> Option.defaultValue oldC\n                              )\n                        { modelN with modCalculations = calcs }\n                let prepareModel model =\n                    model\n                    |> fixForDimensions \n                    |> fixCalcsAndCubes\n                let addRules rules model =\n                    rules\n                    |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n                    |> Seq.fold (fun mdl (cubId, rules) ->\n                        getCubeO cubId mdl\n                        |> Option.map(fun cube ->\n                            rules \n                            |> Seq.map (fun (_, key, rule) -> key, rule)\n                            |> Cube.addRules <| cube\n                            |> swap setCube mdl\n                        )\n                        |> Option.defaultValue mdl\n                    ) model\n                    \n            \n            module Formula =\n                let [< Inline >] inline newFormula id dest exp  typ =\n                      {\n                          forId          = id\n                          forDestDecl    = Map.empty\n                          forDestination = dest\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = toExpA exp\n                          forType        = typ\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline newBase    id expr      = newFormula id []   expr ForBase        \n                let [< Inline >] inline newBaseFor id expr dest = newFormula id dest expr ForBase        \n                let [< Inline >] inline newCons    id expr      = newFormula id []   expr ForConsolidated\n                let [< Inline >] inline newConsFor id expr dest = newFormula id dest expr ForConsolidated\n                let [< Inline >] inline newAll     id expr      = newFormula id []   expr ForAll         \n                let [< Inline >] inline newAllFor  id expr dest = newFormula id dest expr ForAll         \n                let [< Inline >] inline New        ()        =\n                      {\n                          forId          = ForId <| Guid.NewGuid()\n                          forDestDecl    = Map.empty\n                          forDestination = []\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = ExiStet\n                          forType        = ForBase\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline forId      f         = f.forId\n                let                     conso      frm       = { frm with forType  = ForConsolidated }\n                let                     setText    txt  frm  = { frm with forText  = txt             }\n                let                     setOrder   ord  frm  = { frm with forOrder = ord             }\n                let getDimDest dim frm = \n                    frm.forDestination \n                    |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n                \n        \n            module Rule =\n                let [< Inline >] inline newRule0     dest exp typ order =\n                      {\n                          rulId          = RulId <| Guid.NewGuid()\n                          rulDestination = dest\n                          rulDescription = \"\"\n                          rulExpression  = exp\n                          rulType        = typ\n                          rulOrder       = order\n                          rulSourceId    = None\n                          rulXml         = \"\"\n                      }\n                let [< Inline >] inline newRule     dest exp typ order = newRule0     dest (toExpA exp) typ order\n                let [< Inline >] inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n                let New() = newRule0 [] ExiStet ForBase \"\"\n                let conso rul = { rul with rulType = ForConsolidated }    \n            \n            module Attribute =\n                let New() = \n                    {\n                        attId            = AttId <| Guid.NewGuid()\n                        attName          = \"\"\n                        attTableNum      = 1\n                        attType          = AtString\n                    }\n            \n    //#cd @\"..\\projects\\RuleEditor\\src\"\n    //#define WEBSHARPER\n    [< JavaScript >]\n    module RuleEditor =\n        //#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n         \n        //#r @\"Compiled\\CalculationModelDll\\CalculationModelDll.dll\"\n        open CalculationModel.CalculationModel\n        \n        type TreeNodeId = TreeNodeId\n        \n        type Selection  = (TreeNodeId * (ForId option)) option\n        \n        type Version = {\n            major     : int\n            minor     : int\n            majorDate : string\n            minorDate : string\n        }\n        \n        module Version =\n            let New() = {\n                major     = 0\n                minor     = 0\n                majorDate = \"\"\n                minorDate = \"\"\n            }\n            let incrementMinor v = { v with minor = v.minor + 1; minorDate = nowStamp() }\n            let incrementMajor v = {        major = v.major + 1; majorDate = nowStamp()\n                                            minor = 0          ; minorDate = nowStamp() }\n        \n        type ModelUI = {\n            //treeHierarchy : Var<TreeNode []>\n            calculations  : ListModel<CalId        , Calculation>\n            totals        : ListModel<TotId        , Total      >\n            dimensions    : ListModel<DimId        , Dimension  >\n            cubes         : ListModel<CubId        , Cube       >\n            globalDefs    : Var<string>\n            server        : Var<string>\n            selection     : Var<Selection>\n            selectedDim   : Var<DimId option>\n            selectedCube  : Var<CubId option>\n            collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n            cubePrefix    : Var<string>\n            measurePrefix : Var<string>\n            outputMsgs    : Var<string>\n            codeFS        : Var<string>\n            parserMsgs    : Var<string>\n            fileName      : Var<string>\n            version       : Var<Version>\n        }\n        \n        type MsgModel =\n        | AddTotal\n        | SelectTotal       of TotId\n        | RemoveTotal       of TotId\n        | AddCalculation\n        | RemoveCube        of CubId\n        | RenameCube        of CubId * string\n        | AddCube           of         string * Set<DimId>\n        | RemoveCalculation of CalId\n        | SelectCalculation of CalId\n        | AddFormula        of CalId\n        | RemoveFormula     of ForId\n        | SelectFormula     of ForId\n        //| SelectFormNode    of ForId * TreeNodeId\n        | SelectNode        of         TreeNodeId\n        //| ExpandNode        of bool  * TreeNodeId\n        //| IndentNode        of bool  * TreeNodeId\n        //| MoveNode          of bool  * TreeNodeId * TreeNodeId\n        | AddDimension\n        | RemoveDimension   of DimId\n        | SelectDimension   of DimId\n        | AddFormDim        of ForId * DimId * string\n        | RemoveFormDim     of ForId * DimId\n        | RemoveCalcDim     of CalId * DimId\n        | AddCalcDim        of CalId * DimId\n        | RemoveForDest     of CalId * ForId * DimId \n        | SetForDest        of CalId * ForId * DimId * string\n        | SaveTextFile      of string\n        | LoadTextFile      of string\n        | NoOp\n        \n        module ModelUI =\n            //let isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\n            let selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n            \n            let nonTotal        = { Total      .New()                with totId = TotId System.Guid.Empty }\n            let nonCalculation  = { Calculation.New()                with calId = CalId System.Guid.Empty } \n            let nonFormula      = { Formula    .New()                with forId = ForId System.Guid.Empty }\n            //let nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n            \n            let nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            let nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\n            let nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            \n            //let isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n        \n            let refreshView, refreshNow =\n                let refresh = Var.Create ()\n                refresh.View, fun () -> refresh.Value <- ()\n            //let setHierarchy model (nodes: TreeNode seq) =\n            //    nodes\n            //    |> Seq.map (fun n -> parents.Remove n.nid |> ignore ; n)\n            //    |> Seq.toArray\n            //    |> model.treeHierarchy.Set\n        \n            let [<Inline>] inline mapIds f vls = vls |> View.Map (Seq.map f >> Seq.toArray) |> View.consistent\n        \n            let getDimsCubeO cubes = cubes\n            \n            \n        [< AutoOpen >]\n        module Global =\n            let model = {\n                //treeHierarchy = Var.Create [||]\n                calculations  = ListModel.Create (fun v -> v.calId) [||]\n                totals        = ListModel.Create (fun v -> v.totId) [||]\n                dimensions    = ListModel.Create (fun v -> v.dimId) [||]\n                cubes         = ListModel.Create (fun v -> v.cubId) [||]\n                globalDefs    = Var.Create \"\"\n                server        = Var.Create \"\"\n                selection     = Var.Create None\n                selectedDim   = Var.Create None\n                selectedCube  = Var.Create None\n                collapsed     = ListModel.Create id [||]\n                cubePrefix    = Var.Create \"Z\"\n                measurePrefix = Var.Create \"M\"\n                outputMsgs    = Var.Create \"\"\n                codeFS        = Var.Create \"\"\n                parserMsgs    = Var.Create \"\"\n                fileName      = Var.Create \"NewFile.json\"\n                version       = Var.Create <| Version.New()\n            }\n            \n            let mutable processor = fun (msg:MsgModel) -> ()\n            \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText model.outputMsgs msg\n            let inline appendParser msg = appendText model.parserMsgs msg\n        \n        module TableDimensions =\n            open Templating\n        \n            let dtypes =   [ \n                DtDataType\n                DtTime\n                DtVersion\n                DtOther    ] \n        \n            let tableDimensions () =\n                TemplateLib.DimensionTable()\n                    .TBody(\n                        model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n                            //let selDimW = V (model.selectedDim.V = Some did)\n                            TemplateLib.DimensionRow()\n                                .Name(          Lens dimV.V.dimName       )\n                                .Abbreviation(  Lens dimV.V.dimPrefix     )\n                                .Order(         Lens dimV.V.dimOrder      )\n                                .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                                .ExcludeName(   Lens dimV.V.dimExclude    )\n                                .IncludeFreeze( Lens dimV.V.dimFreeze     )\n                                .Remove(        fun _ -> RemoveDimension did |> processor )\n                                .Select(        fun _ -> SelectDimension did |> processor )\n                                .Doc()        \n                        )\n                    )\n                    .Doc()\n        module MainProgram =\n            open FusionAsyncM\n            open Operators\n            open Templating\n        \n            open FsRoot\n            module AF = AppFramework \n        \n            let RuleEditorLyt = \"RuleEditorLyt\"\n        \n            let scrollToBottom (e:Dom.Element) (_:obj) = \n                async { \n                    do! Async.Sleep 100\n                    do  e.ScrollTop <- e.ScrollHeight\n                } |> Async.Start\n        \n        //    let mainLayout() =\n        //        TemplateLib.Layout()\n        //            .CalculationTable( tableCalculations()                  )\n        //            .FormulaDetail(    details          ()                  )\n        //            .DimsSelected(     dimsSelected     ()                  )\n        //            .DimensionTable(   tableDimensions  ()                  )\n        //            .GlobalText(       globalDefs       ()                  )\n        //            .Server(           model.server                         )\n        //            .Output(           model.outputMsgs                     )\n        //            .FSCode(           model.codeFS                         )\n        //            .Parser(           model.parserMsgs                     )\n        //            .Filename(         model.fileName                       )\n        //            .AddCalculation(   fun _ -> AddCalculation |> processor )\n        //            .AddTotal(         fun _ -> AddTotal       |> processor )\n        //            .NewDimension(     fun _ -> AddDimension   |> processor )\n        //            .SaveAs(           fun _ -> SaveLoad.saveAsFile()       )\n        //            .LoadFileChanged(  fun e -> SaveLoad.loadFile e.Target  )\n        //            .LoadFileClear(    fun e -> e.Target?value <- \"\"        )\n        //            .UpdateRules(      fun _ -> UpdateAlea.updateModel()    )        \n        //            .IndentIn(         fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        //            .IndentOut(        fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n        //        //    .Reorder(          fun _ -> reorder()                                    )\n        //            .JumpRef(ParseFS.jumpToRef)\n        //            .OutputAfterRender(fun e -> model.outputMsgs.View |> View.Sink (scrollToBottom e))\n        //            .Doc()\n        \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = \"RuleEditor\"\n                    AF.plgVars    = [| AF.newVar  \"fileName\"        model.fileName\n                                       //AF.newVar  \"SnippetName\"     (Lens Snippets.currentSnippetV.V.snpName)\n                                       //AF.newVar  \"Content\"         (Lens Snippets.currentSnippetV.V.snpContent)\n                                       //AF.newVar  \"Output\"          outputMsgs\n                                       AF.newVar  \"Server\"          model.server\n                                    |]  \n                    AF.plgViews   = [| //AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                                       //AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                                       //AF.newViw  \"CurrentPath\"     Snippets.currentPathW\n                                    |]  \n                    AF.plgDocs    = [| //AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                                       //AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                                       //AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                                       //AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                                       //AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                                       AF.newDoc  \"Dimensions\"      (lazy TableDimensions.tableDimensions() )\n                                    |]  \n                    AF.plgActions = [| //AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                                       //AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                                       //AF.newAct  \"IndentIn\"        Snippets.indentIn       \n                                       //AF.newAct  \"IndentOut\"       Snippets.indentOut\n                                       //AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                                       //AF.newAct  \"RunFS\"           runFsCode\n                                       //AF.newAct  \"AbortFsi\"        FsiAgent.abortFsiExe\n                                       //AF.newAct  \"DisposeFsi\"      FsiAgent.disposeFsiExe\n                                       AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadTextFile |> processor  ), \"FileElement\")\n                                       AF.newActF  \"SaveAs\"          <| AF.FunAct1 ((fun o -> unbox o |> SaveTextFile |> processor  ), \"FileElement\")\n                                       //AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile     ), \"FileElement\")\n                                       //AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef        ), \"textarea\"   )\n                                       //AF.newActF \"ButtonClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.buttonClick), \"button\"     )\n                                       //AF.newActF \"ActionClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.actionClick), \"name\"       )\n                                       AF.newAct  \"AddDimension\"    (fun () -> AddDimension   |> processor)\n                                    |]\n                    AF.plgQueries = [|                                               \n                                    |]\n                }\n                match JS.Document.GetElementById(\"GlobalLayout\") with\n                | null ->\n                   \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -200 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS none x btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddDimension  button RuleEditor.AddDimension      \"\"                  \"Add Dimension \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                   \"\"\"\n                | e -> e.TextContent\n                |> LayoutEngine.newLyt RuleEditorLyt\n                |> LayoutEngine.addLayout\n        \n                None\n                |> Option.defaultValue RuleEditorLyt\n                |> AF.mainDocV.Set\n        \n                async {\n                  //do! Monaco.loader\n                  //WcSplitter.init horizontal vertical\n                  //WcTabStrip.init()\n                  //let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n                  return AF.getMainDoc.Value\n                } |> Doc.Async            \n                \n        module UpdateModelUI =\n                                            \n            let rec updateModelR model msg = \n                let doForCalc cid f       = model.calculations.TryFindByKey cid |> Option.iter f\n                let doForForm cid fid f   = doForCalc cid <| fun c -> c.calFormulas |> Seq.tryFind(fun f -> f.forId = fid) |> Option.iter (f c)\n                let doForCube cid f       = model.cubes       .TryFindByKey cid |> Option.iter f\n                let setSelection sel      = if model.selection.Value = sel then false else\n                                            model.selection.Value   <- sel\n                                            true\n                let tryFindCalcForm fid   = model.calculations.Value |> Seq.tryFind(fun calc -> calc.calFormulas |> Seq.exists (fun f -> f.forId = fid))\n                match msg with\n            //    | AddCalculation         -> let n = Calculation.New()\n            //                                model.calculations.Add n\n            //                                let nn = TreeNode.newNodeCalc n.calId\n            //                                model.treeHierarchy.Value\n            //                                |> Array.append [| nn |]\n            //                                |> model.treeHierarchy.Set\n            //                                SelectNode  nn.nid |> updateModelR model\n            //    | AddTotal               -> let n = Total.New()\n            //                                model.totals.Add n\n            //                                let nn = TreeNode.newNodeTot  n.totId\n            //                                model.treeHierarchy.Value\n            //                                |> Array.append [| nn |]\n            //                                |> model.treeHierarchy.Set\n            //                                SelectNode  nn.nid |> updateModelR model\n            //    | AddFormula         cid -> if  cid = ModelUI.nonCalculation.calId then false else\n            //                                let n = Formula.New()\n            //                                model.calculations.TryFindByKey cid\n            //                                |> Option.iter(fun calc -> { calc with calFormulas = Array.append calc.calFormulas [| n |] } |> model.calculations.Add)\n            //                                model.treeHierarchy.Value \n            //                                |> TreeNode.tryFindSelNode model.selection.Value\n            //                                |> Option.map (fun nn -> SelectFormNode (n.forId, nn.nid ) |> updateModelR model)\n            //                                |> Option.defaultValue true\n                | AddDimension           -> let n = Dimension.New \"\"\n                                            model.dimensions.Add n\n                                            SelectDimension n.dimId |> updateModelR model\n            //    | AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n            //                                true\n            ////    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n            ////                                    model.childrenRels.Value <- model.childrenRels.Value |> Map.add (tid, ch) we\n            ////                                    true\n            ////                                ) |> Option.defaultValue false\n            ////    | RemoveChild (tid, ch)  -> model.childrenRels.Value <- model.childrenRels.Value |> Map.remove (tid, ch)\n            ////                                true\n            //    | RemoveTotal        tid -> model.totals.RemoveByKey    tid\n            //                                setSelection None |> ignore\n            //                                model.treeHierarchy.Value \n            //                                |> TreeNode.removeNodes (TreeNode.forTId ((=) tid)) \n            //                                |> ModelUI.setHierarchy model\n            //                                true\n            //    | RemoveCalculation  cid -> setSelection None |> ignore\n            //                                model.calculations.RemoveByKey cid\n            //                                model.totals.Value\n            //                                |> Seq.choose (fun t -> \n            //                                    let eq, ne = t.children |> Array.partition (fun (_, nid) -> nid = Calc cid )\n            //                                    if eq.Length = 0 then None else\n            //                                    Some { t with children = ne }\n            //                                )\n            //                                |> Seq.iter model.totals.Add\n            //                                model.treeHierarchy.Value \n            //                                |> TreeNode.removeNodes (TreeNode.forCId ((=) cid)) \n            //                                |> ModelUI.setHierarchy model\n            //                                true\n            //    | RemoveFormula      fid -> tryFindCalcForm fid\n            //                                |> Option.iter(fun calc -> { calc with calFormulas = calc.calFormulas |> Array.filter (fun f -> f.forId <> fid) } \n            //                                                           |> model.calculations.Add )\n            //                                true\n            //    | RemoveDimension    did -> model.dimensions.RemoveByKey did\n            //                                true\n            ////    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n            ////                                true\n            //    | SelectNode         nid -> (nid, None    ) |> Some |> setSelection\n            //    | ExpandNode    (ex, nid)-> let rec mapper finished (node:TreeNode) =\n            //                                    if finished             then node                       , true\n            //                                    elif node.nid = nid     then { node with expanded = ex }, true\n            //                                    else let ch, dn = node.children |> Seq.mapFold mapper false\n            //                                         { node with children = Seq.toArray ch }            , dn\n            //                                model.treeHierarchy.Value \n            //                                |> Seq.mapFold mapper false \n            //                                |> fst\n            //                                |> Seq.toArray\n            //                                |> model.treeHierarchy.Set\n            //                                true\n            //    | IndentNode   (iin, nid)-> let indent = if iin then Tree.indentNode else Tree.outdentNode\n            //                                model.treeHierarchy.Value\n            //                                |> TreeNode.tryFindNode nid\n            //                                |> Option.iter(\n            //                                   Tree.toNode \n            //                                   >> swap indent (Tree.toSeqNode model.treeHierarchy.Value) \n            //                                   >> TreeNode.fromSeqNode \n            //                                   >> ModelUI.setHierarchy model)\n            //                                true\n            //    | MoveNode(aft,fnid,tnid)-> Tree.moveToSibling2 aft fnid tnid (Tree.toSeqNode model.treeHierarchy.Value) \n            //                                |> TreeNode.fromSeqNode \n            //                                |> ModelUI.setHierarchy model\n            //                                true\n            //    | SelectFormNode(fid,nid)-> (nid, Some fid) |> Some |> setSelection\n            //    | SelectTotal        tid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeTId tid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n            //    | SelectCalculation  cid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n            //    | SelectFormula      fid -> tryFindCalcForm fid       |> Option.map(fun c -> c.calId) |> Option.bind(fun cid -> \n            //                                model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid) |> Option.map (fun n -> n.nid, Some fid) |> setSelection\n            //    | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n            //                                |> (fun s -> if s = model.selectedDim.Value then false else\n            //                                             model.selectedDim.Value    <- s\n            //                                             true)\n            //    | AddCalcDim   (cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.add    did }\n            //                                false\n            //    | RemoveCalcDim(cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.remove did }\n            //                                false\n            //    | AddCube      (n, ds)   -> model.cubes.Add <| Cube.newCubeCalc n (ds |> Seq.toArray) None\n            //                                false\n            //    | RemoveCube    cid      -> model.cubes.RemoveByKey cid\n            //                                false\n            //    | RenameCube   (cid, n)  -> doForCube cid <| fun c -> model.cubes.Add { c with cubName = n }\n            //                                false\n            //    | _ -> false\n        \n            \n            let updateModel model msg = if updateModelR model msg then ModelUI.refreshNow()\n            processor <- updateModel model\n        //#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#define FSS_SERVER\n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            let varInt  = Var.Create 1\n            printfn \"varInt %A\" varInt.Value\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n                Content.Page(Title = \"Main Page\" \n                           , Body  = [\n                                Html.client <@ MainProgram.mainProgram() @>\n                                Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                             ])\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
