{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Sitelets/Router.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Sitelets\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen System.Collections.Generic\nopen System.Text\n\n#nowarn \"64\" // type parameter renaming warnings \n\n[<NamedUnionCases \"result\"; RequireQualifiedAccess>]\ntype ParseRequestResult<'T> =\n    | [<CompiledName \"success\">]\n      Success of endpoint: 'T\n    | [<CompiledName \"invalidMethod\">]\n      InvalidMethod of endpoint: 'T * ``method``: string\n    | [<CompiledName \"invalidJson\">]\n      InvalidJson of endpoint: 'T\n    | [<CompiledName \"missingQueryParameter\">]\n      MissingQueryParameter of endpoint: 'T * queryParam: string\n    | [<CompiledName \"missingFormData\">]\n      MissingFormData of endpoint: 'T * formFieldName: string\n\n    member this.Value =\n        match this with\n        | Success a\n        | InvalidMethod (a, _)\n        | InvalidJson a\n        | MissingQueryParameter (a, _)\n        | MissingFormData (a, _) -> a\n\n    [<System.Obsolete \"Use Value instead\">]\n    member this.Action = this.Value\n\n[<System.Obsolete \"Use ParseRequestResult instead of ActionEncoding.DecodeResult\">]\n/// For back-compatibility only, use ParseRequestResult instead of ActionEncoding.DecodeResult\nmodule ActionEncoding =\n\n    type DecodeResult<'T> = ParseRequestResult<'T>\n\n    let Success endpoint = ParseRequestResult.Success endpoint\n    let InvalidMethod (endpoint, ``method``) = ParseRequestResult.InvalidMethod(endpoint, ``method``)\n    let InvalidJson endpoint = ParseRequestResult.InvalidJson endpoint\n    let MissingQueryParameter (endpoint, queryParam) = ParseRequestResult.MissingQueryParameter(endpoint, queryParam)\n    let MissingFormData (endpoint, formFieldName) = ParseRequestResult.MissingFormData(endpoint, formFieldName)\n\nmodule StringEncoding =\n\n    [<JavaScript>]\n    let isUnreserved isLast c =\n        match c with\n        | '-' | '_' -> true\n        | '.' -> not isLast\n        | c when c >= 'A' && c <= 'Z' -> true\n        | c when c >= 'a' && c <= 'z' -> true\n        | c when c >= '0' && c <= '9' -> true\n        | _ -> false\n    \n    let writeEscaped (w: System.Text.StringBuilder) isLast c =\n        let k = int c\n        if isUnreserved isLast c then w.Append c\n        elif k < 256 then w.AppendFormat(\"~{0:x2}\", k)\n        else w.AppendFormat(\"~u{0:x4}\", k)\n        |> ignore\n\n    [<JavaScript>]\n    let writeEscapedAsString isLast c =\n        let k = int c\n        if isUnreserved isLast c then string c\n        elif k < 256 then \"~\" + k.JS.ToString(16).PadLeft(2, '0')\n        else \"~u\" + k.JS.ToString(16).PadLeft(4, '0')\n\n    [<JavaScript>]\n    let write (s: string) = \n        if IsClient then\n            s |> Seq.mapi (fun i c ->\n                writeEscapedAsString (i + 1 = s.Length) c\n            )\n            |> String.concat \"\"\n        else\n            let b = System.Text.StringBuilder()\n            s |> Seq.iteri (fun i c ->\n                writeEscaped b (i + 1 = s.Length) c)\n            string b\n\n    [<JavaScript>]\n    let inline ( ++ ) (a: int) (b: int) = (a <<< 4) + b\n\n    [<Literal>]\n    let EOF = -1\n\n    [<Literal>]\n    let ERROR = -2\n\n    let readEscaped (r: System.IO.TextReader) =\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match r.Read() with\n        | x when x = int '~' ->\n            match r.Read() with\n            | x when x = int 'u' ->\n                let a = r.Read()\n                let b = r.Read()\n                let c = r.Read()\n                let d = r.Read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = r.Read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n\n    [<JavaScript>]\n    let readEscapedFromChars (chars: int list) =\n        let mutable chars = chars\n        let read() =\n            match chars with\n            | [] -> -1\n            | h :: t ->\n                chars <- t\n                h\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match read() with\n        | x when x = int '~' ->\n            match read() with\n            | x when x = int 'u' ->\n                let a = read()\n                let b = read()\n                let c = read()\n                let d = read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n        , chars\n\n    [<JavaScript>]\n    let read (s: string) = \n        if IsClient then\n            let buf = ResizeArray()\n            let rec loop chars =\n                match readEscapedFromChars chars with\n                | ERROR, _ -> None\n                | EOF, _ -> Some (buf |> String.concat \"\")\n                | x, chars -> \n                    buf.Add(string (char x))\n                    loop chars\n            s |> Seq.map int |> List.ofSeq |> loop\n        else\n            let buf = System.Text.StringBuilder()\n            use i = new System.IO.StringReader(s)\n            let rec loop () =\n                match readEscaped i with\n                | ERROR -> None\n                | EOF -> Some (string buf)\n                | x -> buf.Append(char x) |> ignore; loop ()\n            loop ()\n\ntype internal PathUtil =\n    static member WriteQuery q =\n        let sb = StringBuilder 128\n        let mutable start = true\n        q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n            if start then\n                start <- false\n            else \n                sb.Append('&') |> ignore                    \n            sb.Append(k).Append('=').Append(v) |> ignore\n        )\n        sb.ToString()\n\n    static member WriteLink s q =\n        let sb = StringBuilder 128\n        if List.isEmpty s then\n            sb.Append('/') |> ignore\n        else\n            s |> List.iter (fun x ->\n                if not (System.String.IsNullOrEmpty x) then\n                    sb.Append('/').Append(x) |> ignore\n            )\n        if Map.isEmpty q then () \n        else \n            let mutable start = true\n            sb.Append('?') |> ignore                    \n            q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n                if start then\n                    start <- false\n                else \n                    sb.Append('&') |> ignore                    \n                sb.Append(k).Append('=').Append(v) |> ignore\n            )\n        sb.ToString()\n\n[<Proxy(typeof<PathUtil>)>]\ntype internal PathUtilProxy =\n    static member Concat xs = \n        let sb = System.Collections.Generic.Queue()\n        let mutable start = true\n        xs |> List.iter (fun x ->\n            if not (System.String.IsNullOrEmpty x) then\n                if start then\n                    start <- false\n                else \n                    sb.Enqueue(\"/\") |> ignore                    \n                sb.Enqueue(x) |> ignore\n        )\n        sb |> System.String.Concat\n\n    static member WriteQuery q =\n        q |> Map.toSeq |> Seq.map (fun (k, v) -> k + \"=\" + v) |> String.concat \"&\"\n\n    static member WriteLink s q =\n        let query = \n            if Map.isEmpty q then \"\" \n            else \"?\" + PathUtil.WriteQuery(q)\n        \"/\" + PathUtilProxy.Concat s + query\n\n[<JavaScript>]\ntype Route =\n    {\n        Segments : list<string>\n        QueryArgs : Map<string, string>\n        FormData : Map<string, string>\n        Method : option<string> \n        Body : Lazy<string>\n    }\n\n    static member Empty =\n        {\n            Segments = []\n            QueryArgs = Map.empty\n            FormData = Map.empty\n            Method = None\n            Body = Lazy.CreateFromValue null\n        }\n    \n    static member Segment s =\n        { Route.Empty with\n            Segments = [ s ]\n        }\n\n    static member Segment s =\n        { Route.Empty with\n            Segments = s\n        }\n\n    static member Segment (s, m) =\n        { Route.Empty with\n            Segments = s\n            Method = m\n        }\n\n    static member Combine (paths: seq<Route>) =\n        let paths = Seq.toArray paths\n        match paths.Length with\n        | 1 -> paths.[0]\n        | 0 -> Route.Empty\n        | _ ->\n        let mutable method = None\n        let mutable body = null\n        let segments = System.Collections.Generic.Queue()\n        let mutable queryArgs = Map.empty\n        let mutable formData = Map.empty\n        let mutable i = 0\n        let l = paths.Length\n        while i < l do\n            let p = paths.[i]\n            match p.Method with\n            | Some _ as m ->\n                method <- m\n            | _ -> ()\n            match p.Body.Value with\n            | null -> ()\n            | b ->\n                body <- b\n            queryArgs <- p.QueryArgs |> Map.foldBack Map.add queryArgs \n            formData <- p.FormData |> Map.foldBack Map.add formData \n            p.Segments |> List.iter segments.Enqueue\n            i <- i + 1\n        {\n            Segments = List.ofSeq segments\n            QueryArgs = queryArgs\n            FormData = formData\n            Method = method\n            Body = Lazy.CreateFromValue body\n        }\n\n    static member ParseQuery(q: string) =\n        q.Split('&') |> Array.choose (fun kv ->\n            match kv.Split('=') with\n            | [| k; v |] -> Some (k, v)\n            | _ -> \n                printfn \"wrong format for query argument: %s\" kv\n                None\n        ) |> Map.ofSeq\n    \n    static member WriteQuery(q) = PathUtil.WriteQuery q\n\n    static member FromUrl(path: string, ?strict: bool) =\n        let s, q = \n            match path.IndexOf '?' with\n            | -1 -> path, Map.empty\n            | i -> \n                path.Substring(0, i),\n                path.Substring(i + 1) |> Route.ParseQuery\n        let splitOptions =\n            if Option.isSome strict && strict.Value then \n                System.StringSplitOptions.None\n            else\n                System.StringSplitOptions.RemoveEmptyEntries\n        { Route.Empty with\n            Segments = \n                s.Split([| '/' |], splitOptions) |> List.ofArray\n            QueryArgs = q\n        }\n\n    [<JavaScript false>]\n    static member FromRequest(r: Http.Request) =\n        let u = r.Uri\n        let p =\n            if u.IsAbsoluteUri then \n                u.AbsolutePath \n            else \n                let s = u.OriginalString\n                match s.IndexOf('?') with\n                | -1 -> s\n                | q -> s.Substring(0, q)\n        {\n            Segments = p.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries) |> List.ofArray\n            QueryArgs = r.Get.ToList() |> Map.ofList\n            FormData = r.Post.ToList() |> Map.ofList\n            Method = Some (r.Method.ToString())\n            Body = lazy r.BodyText\n        }\n\n    static member FromHash(path: string, ?strict: bool) =\n        match path.IndexOf \"#\" with\n        | -1 -> Route.Empty\n        | i -> \n            let h = path.Substring(i + 1)\n            if Option.isSome strict && strict.Value then \n                if h = \"\" || h = \"/\" then\n                    Route.Empty\n                elif h.StartsWith \"/\" then\n                    Route.FromUrl(h.Substring(1), true)\n                else\n                    Route.Segment(h)                    \n            else\n                Route.FromUrl(path.Substring(i), false)\n\n    member this.ToLink() = PathUtil.WriteLink this.Segments this.QueryArgs\n\n[<JavaScript>]\nmodule internal List =\n    let rec startsWith s l =\n        match s, l with\n        | [], _ -> Some l\n        | sh :: sr, lh :: lr when sh = lh -> startsWith sr lr\n        | _ -> None\n\ntype IRouter<'T> =\n    abstract Route : Http.Request -> option<'T>\n    abstract Link : 'T -> option<System.Uri>\n\n[<JavaScript>]\ntype Router =\n    {\n        Parse : Route -> Route seq\n        Segment : seq<Route> \n    }\n    \n    static member FromString (name: string) =\n        let parts = name.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton path\n                Segment = Seq.empty\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p })\n                    | _ -> Seq.empty\n                Segment = \n                    Seq.singleton (Route.Segment parts)\n            }\n\n    static member (/) (before: Router, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Segment = \n                Seq.append before.Segment after.Segment\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router, b: Router) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Segment = a.Segment\n        }\n\n    [<Inline>]\n    static member Combine<'A, 'B when 'A: equality and 'B: equality>(a: Router<'A>, b: Router<'B>) : Router<'A * 'B> =\n        a / b\n\nand [<JavaScript>] Router<'T when 'T: equality> =\n    {\n        Parse : Route -> (Route * 'T) seq\n        Write : 'T -> option<seq<Route>> \n    }\n    \n    static member (/) (before: Router<'T>, after: Router<'U>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun (p, y) -> (p, (x, y))))\n            Write = fun (v1, v2) ->\n                match before.Write v1, after.Write v2 with\n                | Some p1, Some p2 -> Some (Seq.append p1 p2)\n                | _ -> None\n        }\n\n    static member (/) (before: Router, after: Router<'T>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Write = fun v ->\n                after.Write v |> Option.map (Seq.append before.Segment)\n        }\n\n    static member (/) (before: Router<'T>, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun p -> (p, x)))\n            Write = fun v ->\n                before.Write v |> Option.map (fun x -> Seq.append x after.Segment)\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router<'T>) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router<'T>, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router<'T>, b: Router<'T>) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Write = fun value ->\n                match a.Write value with\n                | None -> b.Write value\n                | p -> p\n        }\n\n    interface IRouter<'T> with\n        [<JavaScript false>]\n        member this.Route req = \n            let path = Route.FromRequest req\n            this.Parse path\n            |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n        [<JavaScript false>]\n        member this.Link ep =\n            this.Write ep |> Option.map (fun p -> System.Uri((Route.Combine p).ToLink(), System.UriKind.Relative))\n        \n[<JavaScript>]\nmodule Router =\n    [<Inline>]\n    let Combine (a: Router<'A>) (b: Router<'B>) = a / b\n    \n    [<Inline>]\n    let Shift (prefix: string) (router: Router<'A>) =\n        prefix / router\n\n    let Empty<'A when 'A: equality> : Router<'A> =\n        {\n            Parse = fun _ -> Seq.empty\n            Write = fun _ -> None\n        }\n\n    /// Creates a fully customized router.\n    let New (route: Http.Request -> option<'T>) (link: 'T -> option<System.Uri>) =\n        { new IRouter<'T> with\n            member this.Route req = route req\n            member this.Link e = link e\n        }\n\n    /// Creates a router for parsing/writing a full route using URL segments.\n    let Create (ser: 'T -> list<string>) (des: list<string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des path.Segments with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment(ser value)))\n        } : Router<'T>\n\n    /// Creates a router for parsing/writing a full route using URL segments and query parameters.\n    let CreateWithQuery (ser: 'T -> list<string> * Map<string, string>) (des: list<string> * Map<string, string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des (path.Segments, path.QueryArgs) with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                let s, q = ser value\n                Some (Seq.singleton { Route.Empty with Segments = s; QueryArgs = q })\n        }\n    \n    /// Parses/writes a single value from a query argument with the given key instead of url path.\n    let Query key (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.empty\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (p, v) ->\n                        { path with QueryArgs = newQa }, v\n                    )\n            Write = fun value ->\n                item.Write value |> Option.map (fun p -> \n                    let p = Route.Combine p\n                    match p.Segments with\n                    | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                    | _ -> Seq.empty\n                )\n        }\n\n    /// Parses/writes a single option value from an optional query argument with the given key instead of url path.\n    let QueryOption key (item: Router<'A>) : Router<option<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, None)\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, Some v\n                    )\n            Write = fun value ->\n                match value with\n                | None -> Some Seq.empty\n                | Some v ->\n                    item.Write v |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n        }\n\n    /// Parses/writes a single nullable value from an optional query argument with the given key instead of url path.\n    let QueryNullable key (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, System.Nullable())\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, System.Nullable v\n                    )\n            Write = fun value ->\n                if value.HasValue then\n                    item.Write value.Value |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n                else\n                    Some Seq.empty\n        }\n\n    let Method (m: string) : Router =\n        {\n            Parse = fun path ->\n                match path.Method with\n                | Some pm when pm = m -> Seq.singleton path\n                | _ -> Seq.empty\n            Segment =\n                Seq.singleton { Route.Empty with Method = Some m }\n        }\n\n    let Body (deserialize: string -> option<'A>) (serialize: 'A -> string) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.Body.Value with\n                | null -> Seq.empty\n                | x ->\n                    match deserialize x with\n                    | Some b -> Seq.singleton ({ path with Body = Lazy.CreateFromValue null}, b)\n                    | _ -> Seq.empty\n            Write = fun value ->\n                Some <| Seq.singleton { Route.Empty with Body = Lazy.CreateFromValue (serialize value) }\n        }\n\n    let FormData (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                item.Parse { path with QueryArgs = path.FormData }\n                |> Seq.map (fun (_, r) -> path, r)\n            Write = fun value ->\n                item.Write value\n                |> Option.map (Seq.map (fun p -> { p with QueryArgs = Map.empty; FormData = p.QueryArgs }))  \n        }\n    \n    let Parse (router: Router<'A>) path =\n        router.Parse path\n        |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n\n    let Write (router: Router<'A>) endpoint =\n        router.Write endpoint |> Option.map Route.Combine \n\n    let TryLink (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> Some (p.ToLink())\n        | None -> None\n\n    let Link (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> p.ToLink()\n        | None -> \"\"\n\n    let Ajax (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some path ->\n            let settings = AjaxSettings(DataType = DataType.Text)\n            match path.Method with\n            | Some m -> settings.Type <- As m\n            | _ -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    settings.ContentType <- Union1Of2 false\n                    settings.Data <- fd\n                    settings.ProcessData <- false\n            | b ->\n                settings.ContentType <- Union2Of2 \"application/json\"\n                settings.Data <- b\n                settings.ProcessData <- false\n            if Option.isNone path.Method then settings.Type <- RequestType.POST \n            Async.FromContinuations (fun (ok, err, cc) ->\n                settings.Success <- fun res _ _ -> ok (As<string> res) \n                settings.Error <- fun _ _ msg -> err (exn msg)\n                // todo: cancellation\n                let url = path.ToLink()\n                JQuery.Ajax(url, settings) |> ignore\n            )\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let Fetch (router: Router<'A>) endpoint : Promise<Response> =\n        match Write router endpoint with\n        | Some path ->\n            let options = RequestOptions()\n            match path.Method with\n            | Some m -> options.Method <- m\n            | None -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    options.Body <- fd\n            | b ->\n                options.Body <- b\n            if Option.isNone path.Method then options.Method <- \"POST\"\n            JS.Fetch(path.ToLink(), options)\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let HashLink (router: Router<'A>)  endpoint =\n        \"#\" + Link router endpoint\n    \n    /// Maps a router to a narrower router type. The decode function must return None if the\n    /// value can't be mapped to a value of the target.\n    let Slice (decode: 'T -> 'U option) (encode: 'U -> 'T) (router: Router<'T>) : Router<'U> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Maps a router to a wider router type. The encode function must return None if the\n    /// value can't be mapped back to a value of the source.\n    let Embed (decode: 'A -> 'B) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Maps a router with a bijection.\n    let Map (decode: 'A -> 'B) (encode: 'B -> 'A) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Combination of Slice and Embed, a mapping from a subset of source values to\n    /// a subset of target values. Both encode and decode must return None if\n    /// there is no mapping to a value of the other type.\n    let TryMap (decode: 'A -> 'B option) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Filters a router, only parsing/writing values that pass the predicate check.\n    let Filter predicate router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.filter (snd >> predicate)\n            Write = fun value ->\n                if predicate value then router.Write value else None\n        }\n\n    [<Name \"Box\">]\n    let private BoxImpl tryUnbox (router: Router<'A>): Router<obj> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, box v) \n            Write = fun value ->\n                tryUnbox value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts to Router<obj>. When writing, a type check against type A is performed.\n    let Box (router: Router<'A>): Router<obj> =\n        BoxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Inline>]\n    let Json<'T when 'T: equality> : Router<'T> =\n        Body (fun s -> try Some (Json.Deserialize<'T> s) with _ -> None) Json.Serialize<'T>\n\n    [<Name \"Unbox\">]\n    let UnboxImpl<'A when 'A: equality> tryUnbox (router: Router<obj>) : Router<'A> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryUnbox v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                box value |> router.Write\n        }\n\n    [<Inline>]\n    /// Converts from Router<obj>. When parsing, a type check against type A is performed.\n    let Unbox<'A when 'A: equality> (router: Router<obj>) : Router<'A> =\n        UnboxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Name \"Cast\">]\n    let private CastImpl tryParseCast tryWriteCast (router: Router<'A>): Router<'B> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryParseCast v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                tryWriteCast value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts a Router<A> to Router<B>. When parsing and writing, type checks are performed.\n    /// Upcasting do not change set of parsed routes, downcasting restricts it within the target type.\n    let Cast (router: Router<'A>): Router<'B> =\n        CastImpl (fun v -> match box v with :? 'B as v -> Some v | _ -> None) (fun v -> match box v with :? 'A as v -> Some v | _ -> None) router\n\n    /// Maps a single-valued (non-generic) Router to a specific value.\n    let MapTo value (router: Router) =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun p -> p, value) \n            Write = fun v ->\n                if v = value then Some router.Segment else None\n        }\n\n    /// Parses/writes using any of the routers, attempts are made in the given order.\n    let Sum (routers: seq<Router<_>>) =\n        let routers = Array.ofSeq routers\n        {\n            Parse = fun path ->\n                routers |> Seq.collect (fun r -> r.Parse path)\n            Write = fun value ->\n                routers |> Seq.tryPick (fun r -> r.Write value)\n        }\n    \n    // todo: optimize\n    let Table<'T when 'T : equality> (mapping: seq<'T * string>) : Router<'T> =\n        mapping |> Seq.map (fun (v, s) -> Router.FromString s |> MapTo v) |> Sum \n\n    let Single<'T when 'T : equality> (endpoint: 'T) (route: string) : Router<'T> =\n        let parts = route.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton (path, endpoint)\n                Write = fun value -> if value = endpoint then Some Seq.empty else None\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p }, endpoint)\n                    | _ -> Seq.empty\n                Write = fun value ->\n                    if value = endpoint then Some (Seq.singleton (Route.Segment parts)) else None\n            }\n\n    let Delay<'T when 'T: equality> (getRouter: unit -> Router<'T>) : Router<'T> =\n        let r = lazy getRouter()\n        {\n            Parse = fun path -> r.Value.Parse path\n            Write = fun value -> r.Value.Write value\n        }\n\n    /// Creates a router for parsing/writing an Array of values.\n    let Array (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Int32.TryParse h with\n                    | true, l ->\n                        let rec collect l path acc =\n                            if l = 0 then Seq.singleton (path, Array.ofList (List.rev acc))\n                            else item.Parse path |> Seq.collect(fun (p, a) -> collect (l - 1) p (a :: acc))\n                        collect l { path with Segments = t } []\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (Seq.append (Seq.singleton (Route.Segment (string value.Length))) (parts |> Seq.collect Option.get))\n                else None                      \n        }\n\n    /// Creates a router for parsing/writing a Nullable value.\n    let Nullable (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"null\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, System.Nullable())\n                | _ ->\n                    item.Parse path |> Seq.map (fun (p, v) -> p, System.Nullable v)\n            Write = fun value ->\n                if value.HasValue then \n                    item.Write value.Value\n                else \n                    Some (Seq.singleton (Route.Segment \"null\"))\n        }\n\n    /// Creates a router for parsing/writing an F# option of a value.\n    let Option (item: Router<'A>) : Router<'A option> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"None\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, None)\n                | \"Some\" :: p ->\n                    item.Parse { path with Segments = p } |> Seq.map (fun (p, v) -> p, Some v)\n                | _ ->\n                    Seq.empty\n            Write = fun value ->\n                match value with \n                | None -> Some (Seq.singleton (Route.Segment \"None\"))\n                | Some v -> \n                    item.Write v |> Option.map (Seq.append (Seq.singleton (Route.Segment \"Some\")))\n        }\n\n    module FArray = Collections.Array\n\n    type IListArrayConverter =\n        abstract OfArray: obj -> obj\n        abstract ToArray: obj -> obj\n\n    type ListArrayConverter<'T>() =\n        interface IListArrayConverter with\n            member this.OfArray a = List.ofArray (unbox<'T []> a) |> box\n            member this.ToArray l = List.toArray (unbox<'T list> l) |> box\n\n    /// Creates a router for parsing/writing an F# list of a value.\n    let List (item: Router<'A>) : Router<'A list> =\n        Array item |> Map List.ofArray FArray.ofList\n\ntype Router with\n    [<Inline>]\n    member this.MapTo(value: 'T) =\n        Router.MapTo value this\n\n    [<Inline>]\n    static member Sum ([<System.ParamArray>] routers: Router<'T>[]) =\n        Router.Sum routers\n\n    [<Inline>]\n    static member Empty<'T when 'T: equality>() =\n        Router.Empty<'T>\n\n    [<JavaScript false>]\n    static member New(route: System.Func<Http.Request, 'T>, link: System.Func<'T, System.Uri>) =\n        Router.New (route.Invoke >> Option.ofObj) (link.Invoke >> Option.ofObj)\n\n    [<Inline>]\n    static member Method(method:string) =\n        Router.Method method\n\n    [<Inline>]\n    static member Body(des:System.Func<string, 'T>, ser: System.Func<'T, string>) =\n        Router.Body (fun s -> des.Invoke s |> Option.ofObj) ser.Invoke \n\n    [<Inline>]\n    static member Json<'T when 'T: equality>() =\n        Router.Json<'T>\n\n    [<Inline>]\n    static member Table([<System.ParamArray>] mapping: ('T * string)[]) =\n        Router.Table mapping\n\n    [<Inline>]\n    static member Single(endpoint, route) =\n        Router.Single endpoint route\n\n    [<Inline>]\n    static member Delay(getRouter: System.Func<Router<'T>>) =\n        Router.Delay getRouter.Invoke\n\ntype Router<'T when 'T: equality> with\n\n    [<Inline>]\n    member this.Query(key: string) =\n        Router.Query key this\n\n    [<Inline>]\n    member this.Link(endpoint: 'T) =\n        Router.Link this endpoint\n\n    [<Inline>]\n    member this.TryLink(endpoint: 'T, link: byref<string>) =\n        match Router.TryLink this endpoint with\n        | Some l ->\n            link <- l\n            true\n        | _ -> false\n               \n    [<Inline>]\n    member this.HashLink(endpoint: 'T) =\n        Router.HashLink this endpoint\n\n    [<Inline>]\n    member this.Map(decode: System.Func<'T, 'U>, encode: System.Func<'U, 'T>) =\n        Router.TryMap (decode.Invoke >> ofObjNoConstraint) (encode.Invoke >> ofObjNoConstraint) this\n\n    [<Inline>]\n    member this.Filter(predicate: System.Func<'T, bool>) =\n        Router.Filter predicate.Invoke this\n\n    [<Inline>]\n    member this.Cast<'U when 'U: equality>() : Router<'U> =\n        Router.Cast this\n\n    [<Inline>]\n    member this.FormData() =\n        Router.FormData this\n\n    [<Inline>]\n    member this.Ajax(endpoint) =\n        Router.Ajax this endpoint |> Async.StartAsTask\n\n    [<Inline>]\n    member this.Box() =\n        Router.Box this\n\n    [<Inline>]\n    member this.Array() =\n        Router.Array this\n\nopen System.Runtime.CompilerServices\n    \n[<Extension>]\ntype RouterExtensions =\n    [<Inline>]\n    static member QueryNullable(router, key) =\n        Router.QueryNullable key router\n\n    [<Inline>]\n    static member Unbox<'T when 'T: equality>(router) =\n        Router.Unbox<'T> router\n\n    [<Inline>]\n    static member Nullable(router) =\n        Router.Nullable router\n\nmodule IRouter =\n    open System\n\n    let Empty : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route _ = None\n            member this.Link _ = None\n        }        \n\n    let Add (r1: IRouter<'T>) (r2: IRouter<'T>) =\n        { new IRouter<'T> with\n            member this.Route req = match r1.Route req with Some _ as l -> l | _ -> r2.Route req\n            member this.Link e = match r1.Link e with Some _ as l -> l | _ -> r2.Link e\n        }        \n\n    let Sum (routers: seq<IRouter<'T>>) : IRouter<'T> =\n        let routers = Array.ofSeq routers\n        if Seq.isEmpty routers then Empty else\n            { new IRouter<'T> with\n                member this.Route req = routers |> Array.tryPick (fun r -> r.Route req)\n                member this.Link e = routers |> Array.tryPick (fun r -> r.Link e)\n            }        \n            \n    let Map encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> router.Link\n        } \n        \n    let TryMap encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.bind encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let Embed encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let private makeUri uri =\n        let mutable res = null\n        if Uri.TryCreate(uri, UriKind.Relative, &res) then res else\n            Uri(uri, UriKind.Absolute)\n    \n    let private path (uri: Uri) =\n        if uri.IsAbsoluteUri\n        then uri.AbsolutePath\n        else uri.OriginalString |> joinWithSlash \"/\"\n        \n    let private trimFinalSlash (s: string) =\n        match s.TrimEnd('/') with\n        | \"\" -> \"/\"\n        | s -> s\n    \n    let Shift prefix (router: IRouter<'T>) =\n        let prefix = joinWithSlash \"/\" prefix\n        let shift (loc: System.Uri) =\n            if loc.IsAbsoluteUri then loc else\n                makeUri (joinWithSlash prefix (path loc) |> trimFinalSlash)\n        { new IRouter<'T> with\n            member this.Route req =\n                let builder = UriBuilder req.Uri\n                if builder.Path.StartsWith prefix then\n                    builder.Path <- builder.Path.Substring prefix.Length\n                    router.Route (req.WithUri(builder.Uri))\n                else\n                    None\n            member this.Link e = router.Link e |> Option.map shift\n        }     \n        \n    let Box (router: IRouter<'T>) : IRouter<obj> =\n        { new IRouter<obj> with\n            member this.Route req = router.Route req |> Option.map box\n            member this.Link e = tryUnbox<'T> e |> Option.bind router.Link\n        } \n\n    let Unbox (router: IRouter<obj>) : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route req = router.Route req |> Option.bind tryUnbox<'T>\n            member this.Link e = box e |> router.Link\n        } \n\n[<JavaScript>]\nmodule RouterOperators =\n    let rRoot : Router =\n        {\n            Parse = fun path -> Seq.singleton path\n            Segment = Seq.empty\n        }\n    \n    [<Inline>]\n    /// Parse/write a specific string.\n    let r name : Router = Router.FromString name\n\n    /// Parse/write a string using URL encode/decode.\n    let rString : Router<string> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some s ->\n                        Seq.singleton ({ path with Segments = t }, s)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if isNull value then \"null\" else StringEncoding.write value)))\n        }\n\n    /// Parse/write a char.\n    let rChar : Router<char> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some c when c.Length = 1 ->\n                        Seq.singleton ({ path with Segments = t }, char c)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    [<Inline>]\n    let inline rTryParse< ^T when ^T: (static member TryParse: string * byref< ^T> -> bool) and ^T: equality>() =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    let mutable res = Unchecked.defaultof< ^T>\n                    let ok = (^T: (static member TryParse: string * byref< ^T> -> bool) (h, &res))\n                    if ok then \n                        Seq.singleton ({ path with Segments = t }, res)\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    /// Parse/write a Guid.\n    let rGuid = rTryParse<System.Guid>()\n    /// Parse/write an int.\n    let rInt = rTryParse<int>()\n    /// Parse/write a double.\n    let rDouble = rTryParse<double>()\n    /// Parse/write a signed byte.\n    let rSByte = rTryParse<sbyte>() \n    /// Parse/write a byte.\n    let rByte = rTryParse<byte>() \n    /// Parse/write a 16-bit int.\n    let rInt16 = rTryParse<int16>() \n    /// Parse/write a 16-bit unsigned int.\n    let rUInt16 = rTryParse<uint16>() \n    /// Parse/write an unsigned int.\n    let rUInt = rTryParse<uint32>() \n    /// Parse/write a 64-bit int.\n    let rInt64 = rTryParse<int64>() \n    /// Parse/write a 64-bit unsigned int.\n    let rUInt64 = rTryParse<uint64>() \n    /// Parse/write a single.\n    let rSingle = rTryParse<single>() \n\n    /// Parse/write a bool.\n    let rBool : Router<bool> =\n        // we define rBool not with rTryParse so that fragments are capitalized\n        // to be fully consistent on client+server\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Boolean.TryParse h with\n                    | true, g ->\n                        Seq.singleton ({ path with Segments = t }, g)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if value then \"True\" else \"False\")))\n        }\n\n    /// Parses any remaining part of the URL as a string, no URL encode/decode is done.\n    let rWildcard : Router<string> = \n        {\n            Parse = fun path ->\n                let s = path.Segments |> String.concat \"/\"\n                Seq.singleton ({ path with Segments = [] }, s)\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment value))\n        }\n    \n    let rWildcardArray (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, Array.ofList (List.rev acc))\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let rWildcardList (item: Router<'A>) : Router<'A list> = \n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, List.rev acc)\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> List.map item.Write\n                if List.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    /// Parse/write a DateTime in `YYYY-MM-DD-HH.mm.ss` format.\n    let rDateTime : Router<System.DateTime> =\n        let pInt x =\n            match System.Int32.TryParse x with\n            | true, i -> Some i\n            | _ -> None\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    if h.Length = 19 && h.[4] = '-' && h.[7] = '-' && h.[10] = '-' && h.[13] = '.' && h.[16] = '.' then\n                        match pInt h.[0 .. 3], pInt h.[5 .. 6], pInt h.[8 .. 9], pInt h.[11 .. 12], pInt h.[14 .. 15], pInt h.[17 .. 18] with\n                        | Some y, Some m, Some d, Some h, Some mi, Some s  ->\n                            Seq.singleton ({ path with Segments = t }, System.DateTime(y, m, d, h, mi, s))\n                        | _ -> Seq.empty\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun d ->\n                let pad2 (x: int) =\n                    let s = string x\n                    if s.Length = 1 then \"0\" + s else s\n                let pad4 (x: int) =\n                    let s = string x\n                    match s.Length with\n                    | 1 -> \"000\" + s\n                    | 2 -> \"00\" + s\n                    | 3 -> \"0\" + s\n                    | _ -> s\n                let s = \n                    pad4 d.Year + \"-\" + pad2 d.Month + \"-\" + pad2 d.Day\n                    + \"-\" + pad2 d.Hour + \".\" + pad2 d.Minute + \".\" + pad2 d.Second\n                Some (Seq.singleton (Route.Segment s))\n        }\n      \n    let internal Tuple (readItems: obj -> obj[]) (createTuple: obj[] -> obj) (items: Router<obj>[]) =\n        {\n            Parse = fun path ->\n                let rec collect elems path acc =\n                    match elems with \n                    | [] -> Seq.singleton (path, createTuple (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect (List.ofArray items) path []\n            Write = fun value ->\n                let parts =\n                    (readItems value, items) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let internal JSTuple (items: Router<obj>[]) : Router<obj> =\n        let readItems (value: obj) =\n            Array.init items.Length (fun i ->\n                (As<Array<obj>> value).[i]\n            )\n        Tuple readItems box items\n\n    [<Inline>]\n    let internal JSEmpty () : Router<obj> = Router.Empty<obj>\n\n    [<Inline>]\n    let internal JSArray item = Router.Array item\n    \n    [<Inline>]\n    let internal JSList item = Router.List item\n\n    [<Inline>]\n    let internal JSOption item = Router.Option item\n\n    [<Inline>]\n    let internal JSNullable item = Router.Nullable item\n\n    [<Inline>]\n    let internal JSQuery key item = Router.Query key item\n\n    [<Inline>]\n    let internal JSQueryOption key item = Router.QueryOption key item\n\n    [<Inline>]\n    let internal JSQueryNullable key item = Router.QueryNullable key item\n\n    [<Inline>]\n    let internal JSFormData item = Router.FormData item\n\n    [<Inline>]\n    let internal JSJson<'T when 'T: equality> = Router.Json<'T>\n\n    [<Inline>]\n    let internal JSBox item = Router.Box item\n\n    [<Inline>]\n    let internal JSDelayed getRouter = Router.Delay getRouter\n        \n    let internal JSRecord (t: obj) (fields: (string * bool * Router<obj>)[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createRecord fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let fields = fields |> Array.map (fun (_, _, r) -> r)\n        let fieldsList =  List.ofArray fields        \n        {\n            Parse = fun path ->\n                let rec collect fields path acc =\n                    match fields with \n                    | [] -> Seq.singleton (path, createRecord (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect fieldsList path []\n            Write = fun value ->\n                let parts =\n                    (readFields value, fields) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n    \n    let internal isCorrectMethod m p =\n        match p, m with\n        | Some pm, Some m -> pm = m\n        | _, Some _ -> false\n        | _ -> true\n\n    let internal JSUnion (t: obj) (cases: (option<obj> * (option<string> * string[])[] * Router<obj>[])[]) : Router<obj> = \n        let getTag value = \n            let constIndex =\n                cases |> Seq.tryFindIndex (\n                    function\n                    | Some c, _, _ -> value = c\n                    | _ -> false\n                )\n            match constIndex with\n            | Some i -> i\n            | _ -> value?(\"$\") \n        let readFields tag value =\n            let _, _, fields = cases.[tag]\n            Array.init fields.Length (fun i ->\n                value?(\"$\" + string i)\n            )\n        let createCase tag fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            match cases.[tag] with\n            | Some constant, _, _ -> constant\n            | _ ->\n                o?(\"$\") <- tag\n                fieldValues |> Seq.iteri (fun i v ->\n                    o?(\"$\" + string i) <- v\n                )\n                o\n        let parseCases =\n            cases |> Seq.indexed |> Seq.collect (fun (i, (_, eps, fields)) ->\n                eps |> Seq.map (fun (m, p) -> i, m, p, fields)    \n            )\n        {                                                    \n            Parse = fun path ->\n                parseCases |> Seq.collect (fun (i, m, s, fields) ->\n                    if isCorrectMethod m path.Method then\n                        match path.Segments |> List.startsWith (List.ofArray s) with\n                        | Some p -> \n                            match List.ofArray fields with\n                            | [] -> Seq.singleton ({ path with Segments = p }, createCase i [||])\n                            | fields -> \n                                let rec collect fields path acc =\n                                    match fields with \n                                    | [] -> Seq.singleton (path, createCase i (Array.ofList (List.rev acc)))\n                                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                                collect fields { path with Segments = p } []\n                        | None -> Seq.empty\n                    else\n                        Seq.empty\n                )\n            Write = fun value ->\n                let tag = getTag value\n                let _, eps, fields = cases.[tag]\n                let method, path = eps.[0]\n                let casePath = Seq.singleton (Route.Segment (List.ofArray path, method))\n                match fields with\n                | [||] -> Some casePath\n                | _ ->\n                    let fieldParts =\n                        (readFields tag value, fields) ||> Array.map2 (fun v f -> f.Write v)\n                    if Array.forall Option.isSome fieldParts then\n                        Some (Seq.append casePath (fieldParts |> Seq.collect Option.get))\n                    else None                      \n        }\n\n    let internal JSClass (ctor: unit -> obj) (fields: (string * bool * Router<obj>)[]) (endpoints: (option<string> * Union<string, int>[])[]) (subClasses: Router<obj>[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createObject fieldValues =\n            let o = ctor()\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let partsAndRoutersLists =\n            endpoints |> Array.map (fun (m, ep) ->\n                m, \n                ep |> Seq.map (fun p ->\n                    match p with\n                    | Union1Of2 s -> Choice1Of2 s\n                    | Union2Of2 i -> \n                        let _, _, r = fields.[i]\n                        Choice2Of2 (i, r)\n                ) |> List.ofSeq\n            )\n        let thisClass =\n            {\n                Parse = fun path ->\n                    let rec collect fields path arr =\n                        match fields with \n                        | [] -> \n                            Seq.singleton (path, createObject arr)\n                        | Choice1Of2 p :: t -> \n                            match path.Segments with\n                            | pp :: pr when pp = p ->\n                                collect t { path with Segments = pr } arr\n                            | _ -> Seq.empty\n                        | Choice2Of2 (i, h) :: t -> \n                            h.Parse path |> Seq.collect(fun (p, a) -> \n                                let narr = Array.copy arr\n                                narr.[i] <- a\n                                collect t p narr\n                            )\n                    partsAndRoutersLists |> Seq.collect (fun (m, ps) -> \n                        if isCorrectMethod m path.Method then\n                            let arr = Array.zeroCreate fields.Length\n                            collect ps path arr\n                        else Seq.empty\n                    )\n                Write = fun value ->\n                    let values = readFields value\n                    let method, ep = endpoints.[0]\n                    let parts =\n                        ep |> Array.map (function\n                            | Union1Of2 p -> Some (Seq.singleton (Route.Segment(p)))\n                            | Union2Of2 i ->\n                                let _, _, r = fields.[i] \n                                r.Write(values.[i])\n                        )\n                    if Array.forall Option.isSome parts then\n                        let w = parts |> Seq.collect Option.get\n                        match method with\n                        | Some _ -> Some (Seq.append (Seq.singleton { Route.Empty with Method = method }) w)\n                        | None -> Some w\n                    else None                      \n            }\n        if Array.isEmpty subClasses then\n            thisClass\n        else\n            Router.Sum (Seq.append subClasses (Seq.singleton thisClass))\n"],
"names": [],
"mappings": "82B,AAkLsB,EAAa,Q,AAQW,gCANxB,uBAAqB,CAAK,C,AAAA,I,AAA1B,CAA0B,G,AAAA,G,AAA1B,EAA0B,Q,AAA1B,IAA0B,S,AAA1B,CAA0B,G,AAAA,G,AAA1B,EAA0B,O,AAA1B,QAEY,CAAO,sCAAA,SAAA,CAAgB,C,AAAhB,CAAgB,C,AAAA,K,AAAF,EAAE,C,AAAA,I,AAAA,C,AAFT,M,AAI5B,CAAG,M,AAAK,eAAR,CACU,G,AADY,C,AAAC,I,AAAvB,CACU,G,AAAA,I,AACoB,C,AAAlB,OAAU,C,AAA9B,MAAK,mBAAQ,CAAG,a,AAAA,E,AAAA,C,AAAX,CAAW,C,AAAA,C,AAAc,C,AAAQ,sF,AA1ChC,CAAK,K,AAAA,E,AAAL,EAGF,CACC,G,AAAA,E,AADD,EAAA,CACC,G,AAAA,E,AADD,EAAS,CAAC,E,AACT,C,AAAA,C,AAJM,E,AAAL,EAAK,uB,AAOF,CAAC,E,AAAQ,GAAG,a,AAAA,E,AAAI,CAAC,E,AAAQ,GAAG,a,AAAA,C,AAAI,CAAC,C,AAAO,GAAG,a,AAAA,C,AAC3C,CAAC,E,AAAQ,GAAG,a,AAAA,E,AAAI,CAAC,E,AAAQ,GAAG,a,AAAA,C,AAAI,CAAC,C,AAAO,GAAG,a,AAAA,C,AAAG,EAAE,C,AAChD,CAAC,E,AAAQ,GAAG,a,AAAA,E,AAAI,CAAC,E,AAAQ,GAAG,a,AAAA,C,AAAI,CAAC,C,AAAO,GAAG,a,AAAA,C,AAAG,EAAE,C,AAClD,EAAK,I,AAZI,CAAK,S,AAanB,EAAA,GAAM,C,AACH,CAAC,G,AAAO,GAAG,a,AAAA,E,AACV,EAAA,GAAM,C,AACH,CAAC,G,AAAO,GAAG,a,AAAA,E,AACZ,EAAI,GAAM,E,AACV,EAAI,GAAM,E,AACV,EAAI,GAAM,E,AACV,EAAI,GAAM,C,AACX,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,C,AACnC,cAAA,cAAA,cAAA,EAAI,CAAC,C,AAAA,C,AAAI,EAAI,CAAC,C,AAAA,C,AAAA,C,AAAI,EAAI,CAAC,C,AAAA,C,AAAA,C,AAAI,EAAI,CAAC,C,AAAA,C,AAAA,C,AAC/B,EAAK,C,AAJL,C,AADA,C,AADA,G,AAQD,EAAI,GAAM,C,AACX,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,E,AAAI,CAAC,C,AACf,cAAA,EAAI,CAAC,C,AAAA,C,AAAI,EAAI,CAAC,C,AAAA,C,AAAA,C,AACb,EAAK,C,AAbF,E,AAeZ,CAAC,E,AACH,CAAK,sC,AAnE2B,CAAC,CAAC,E,AAAK,CAAC,E,AAAI,CAAC,8B,AAZ/C,SAIO,EAAgB,C,AAAhB,OAHE,qBACD,uBAAsB,CAAC,C,AAAG,CAAC,G,AAAG,CAAC,O,AAAO,C,AAAE,CAAC,C,AAAA,E,AAAA,C,AADxC,CACwC,C,AAE1B,C,AAKX,gD,AAhBA,CAAC,a,AAAA,Q,AACV,eAAa,CAAM,C,AAAC,CAAC,C,AAAA,C,AAAM,CAAQ,C,AACjC,CAAC,C,AAAG,GAAG,C,AAAM,GAAG,C,AAAG,cAAA,CAAI,U,AAAU,EAAE,C,AAAC,C,AAAS,CAAC,C,AAAE,GAAG,C,AAAC,C,AACpD,IAAI,C,AAAG,cAAA,CAAI,U,AAAU,EAAE,C,AAAC,C,AAAS,CAAC,C,AAAE,GAAG,C,AAAC,uC,AApBvC,CAAC,G,AAAD,GAAC,G,AAAD,CAAC,G,AAAD,GAAC,C,AAAD,CAEO,CAAM,C,AAFb,CAAC,G,AAAD,GAAC,G,AAGE,CAAC,E,AAAI,GAAG,E,AAAI,CAAC,E,AAAI,GAAG,G,AACpB,CAAC,E,AAAI,GAAG,E,AAAI,CAAC,E,AAAI,GAAG,E,AACpB,CAAC,E,AAAI,GAAG,E,AAAI,CAAC,E,AAAI,GAAG,C,AALtB,C,AAAA,C,AAAA,qC,AAsLY,CAAC,c,AAAA,C,AAAM,EAAE,C,AACnB,GAAG,C,AAAG,aAAoB,CAAC,C,AAAC,O,AACrC,GAAG,C,AAAG,SAAqB,CAAC,C,AAAA,C,AAAG,CAAK,mD,AANK,CAAC,C,AAAG,GAAG,C,AAAG,CAAC,S,AAApD,SAAyD,GAAiB,C,AAAjB,MAAvC,iCAAmC,C,AAAhD,OAAS,G,AAAuC,C,AAAqB,C,AAAA,kC,AAbjE,EAAkC,G,AACvB,IAAI,Q,AAClB,eACC,CAAK,gBAA4B,CAAC,C,AAAA,E,AAC9B,CAAK,C,AACJ,EAAS,KAAK,C,AAEd,CAAE,M,AAAS,GAAG,C,AAAW,C,AAC7B,CAAE,M,AAAS,CAAC,I,AACnB,C,AAPK,CAOL,2B,AACK,CAAoB,iD,AAgJP,YAAmB,IAAa,S,AAAA,C,AAAC,IAAc,U,AAAf,C,AAAe,+C,AAd5D,CAAI,S,AAAS,GAAG,C,AAAA,Q,AAAhB,CAAgB,G,AAAhB,EAAgB,C,AACd,aAAW,E,AAEX,EAAI,CAAI,W,AAAW,CAAC,C,AAAG,CAAC,C,AAAC,C,AACZ,CAAM,M,AAAA,E,AAAI,CAAM,G,AAAM,C,AAChC,CAAC,G,AAAG,EAAE,E,AAAI,CAAC,G,AAAG,GAAG,C,AAChB,aAAW,C,AACV,aAAA,CAAC,C,AAAY,GAAG,C,AAAA,C,AACjB,UAAc,CAAC,W,AAAW,CAAC,C,AAAC,C,AAAE,QAAA,IAAI,C,AAAA,C,AAAC,C,AAEnC,YAAc,CAAC,C,AAAC,C,AAEpB,UAAc,CAAI,W,AAAW,CAAC,C,AAAC,C,AAAE,QAAA,KAAK,C,AAAA,C,AAAC,C,AAZzB,wC,AApCZ,EAAA,CAAI,S,AAAS,GAAG,C,AAAA,C,AAAhB,CAAgB,G,AAAhB,EAAgB,C,AACd,CAAA,CAAI,C,AAAE,aAAS,C,AAAA,C,AAEnB,CAAA,YAAA,CAAI,C,AAAW,CAAC,C,AAAE,CAAC,C,AAAC,C,AACK,YAAgB,C,AAAzC,CAAI,W,AAAW,CAAC,C,AAAG,CAAC,C,AAAC,C,AAAoB,C,AAAA,I,AAM/C,aAAW,Q,AAAb,MAE4C,SAAY,C,AAAhD,aAbJ,CAAI,G,AAaC,C,AAAO,CAAG,GAAG,C,AAAG,C,AANJ,CAAM,M,AAAA,E,AAAI,CAAM,G,AAAM,C,AACnC,CAA8B,C,AAE9B,CAA4C,C,AAGZ,C,AAAgB,C,AAbpD,CAAI,G,AAcS,C,AAHjB,CAIC,S,AAAA,C,AAJD,CAIC,O,AAAA,C,AAJD,CAIC,K,AAAA,C,AAAA,mC,AAlByB,aAAoB,CAAC,C,AAAA,mC,AAR/C,kBAMK,SANW,sBACN,aAAA,CAAE,C,AAAF,CAAS,GAAG,C,AAAC,G,AAAA,O,AAAb,UAAA,CAAa,C,AAAb,IAAa,C,AAAA,E,AAAb,CAAa,O,AAAA,G,AAAb,CAAa,E,AACH,EAAA,MAAA,CAAW,C,AAAX,CAAW,C,AAAA,C,AAAX,QAAM,CAAA,MAAN,CAAW,C,AAAX,CAAW,C,AAAJ,C,AAAE,CAAC,C,AAAA,C,AAAC,G,AAEvB,CAAQ,4FAAqC,wB,AAAA,E,AAA7C,CAA6C,M,AACzC,C,AAJW,E,AAKtB,C,AANe,aAAhB,CAAC,C,AAAD,CAAQ,GAAG,C,AAAC,G,AAMX,C,AAAa,E,AAAA,mD,AAzCF,QAAY,CAAK,C,AAAA,G,AACvB,SAAA,CAAK,C,AAAO,I,AAAZ,CAAY,G,AAAZ,CAAY,Q,AAAZ,aAAY,S,AAAZ,CAAY,G,AAAZ,CAAY,Q,AAAZ,MACC,CAAK,C,AAAE,CAAC,C,AADG,Q,AAIG,IAAI,G,AACN,IAAI,G,AACR,EAAkC,G,AACzB,aAAS,G,AACV,aAAS,G,AAChB,CAAC,G,AACT,SAAA,CAAK,C,AAAO,O,AACd,CAAC,C,AAAG,CAAC,yB,AACC,MAAA,CAAK,C,AAAE,CAAC,C,AAAC,G,AACX,CAAQ,O,AAAA,C,AAAR,eAAQ,C,AAEV,EAAU,CAAC,C,AACR,MAAE,G,AACH,CAAM,K,AAAA,I,AAAM,C,AAAZ,CAAY,G,AAAZ,IAAY,C,AACR,MAAE,C,AAER,EAAQ,CAAC,G,AACA,WAAe,wBAAa,EAAO,S,AAAA,E,AAAU,C,AAA9B,CAA8B,C,AAA7C,CAAW,U,AAAkC,C,AAAA,G,AAC9C,WAAc,wBAAa,EAAO,S,AAAA,E,AAAS,C,AAA7B,CAA6B,C,AAA3C,CAAU,S,AAAiC,C,AAAA,Q,AACzC,YAAU,CAAgB,M,AAAhB,CAAgB,C,AAAA,E,AAAA,C,AAAxC,CAAU,S,AAA8B,I,AACnC,CAAC,C,AAAG,CAAC,a,AAdV,MAgBW,QAAW,CAAQ,C,AAAA,C,AAClB,CAAS,C,AACV,CAAQ,C,AACV,CAAM,C,AACR,kBAAqB,CAAI,C,AAAA,C,AApB/B,oC,AAjBH,aAAW,Q,AAAb,MACe,CAAC,C,AADhB,CAGC,U,AAAA,C,AAHD,CAGC,S,AAAA,C,AADY,CAAC,C,AAFd,CAGC,K,AAAA,C,AAAA,mC,AARC,aAAW,Q,AAAb,MACe,CAAC,C,AADhB,CAEC,U,AAAA,C,AAFD,CAEC,S,AAAA,C,AAFD,CAEC,O,AAAA,C,AAFD,CAEC,K,AAAA,C,AAAA,mC,AAPC,aAAW,Q,AAAb,MACe,WAAE,CAAC,E,AAAE,C,AADpB,CAEC,U,AAAA,C,AAFD,CAEC,S,AAAA,C,AAFD,CAEC,O,AAAA,C,AAFD,CAEC,K,AAAA,C,AAAA,iC,AAXD,MACe,SAAE,C,AACD,aAAS,C,AACV,aAAS,C,AACX,IAAI,C,AACN,kBAAqB,IAAI,C,AAAA,C,AACnC,yI,AAyHK,CAAI,K,AAAA,C,AAAJ,CAAI,K,AAAA,C,AAEgB,SAAxB,CAAQ,G,AAAkB,C,AAAhB,CAAQ,G,AAAa,C,AAAA,E,AAAP,GAAd,CAAQ,G,AAFV,C,AAEE,CAAQ,G,AAFV,C,AAER,CAAQ,G,AAFA,C,AAER,CAAQ,G,AAFA,G,AAEuB,E,AAAP,CAAO,C,AAF3B,CAAI,C,AAAJ,CAAI,e,AACC,QAAK,CAAC,C,AAAA,e,AACoB,aAAW,IAAE,C,AAAC,IAAE,C,AAAA,e,AAC9C,IAAI,uC,AA+CX,MACY,mBACJ,SAAY,CAAO,O,AAAC,CAAI,C,AAAA,C,AAAG,CAAO,O,AAAC,CAAI,C,AAAA,C,AAAC,E,AAAA,C,AAClC,CAAS,Q,AAAA,C,AACtB,sC,AAlBD,MACY,mBACJ,UAAiC,CAAW,M,AAAA,C,AAA5C,CAAY,O,AAAC,CAAI,C,AAA2B,C,AAAA,E,AAAA,C,AAE5C,SAAW,CAAc,Q,AAAA,C,AAAC,CAAa,Q,AAAA,C,AAAA,C,AAC9C,sC,AAxBW,aAAA,CAAI,C,AAAO,CAAG,GAAG,C,AAAG,C,AAAE,CAA4C,C,AAAC,Q,AAC9D,CAAK,U,AAAA,C,AAClB,MACY,kBAAY,CAAc,CAAI,C,AAAA,E,AAAA,C,AAC5B,EAAS,C,AACtB,E,AAEG,EAAQ,UAAa,CAAK,C,AAAA,C,AAC9B,MACY,oBACE,aAAiB,CAAqB,C,AAAtC,CAAa,S,AAAyB,C,AAAA,Q,AAAtC,eAAsC,C,AAExC,CAAe,MAAf,CAA0C,G,AAAH,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAC,C,AACvC,EAAS,E,AAAA,C,AAEhB,CAAe,YAAc,CAAK,C,AAAA,C,AAAC,C,AAC1C,C,AAAA,wF,AAkEL,QACY,mBACJ,SAAY,CAAO,O,AAAC,CAAI,C,AAAA,C,AAAG,CAAO,O,AAAC,CAAI,C,AAAA,C,AAAC,E,AAAA,C,AACpC,oBACE,CAAO,O,AAAC,CAAK,C,AAAA,Q,AAAb,CAAa,M,AAAA,C,AACT,CAAO,O,AAAC,CAAK,C,AAAA,C,AAChB,CAAC,E,AAAA,C,AACf,wC,AArBD,QACY,mCAC4C,MAAiB,kBAAmB,CAAA,CAAC,C,AAAE,CAAC,C,AAAA,E,AAAE,C,AAA1C,CAAW,O,AAAC,CAAC,C,AAA6B,C,AAAA,S,AAA1F,UAAqB,iCAAsE,C,AAA3F,CAAY,O,AAAC,CAAI,C,AAA0E,C,AAAA,E,AAAA,C,AACvF,oBACJ,CAAY,O,AAAC,CAAC,C,AAAA,Q,AAAI,qBAAqB,SAAW,IAAC,C,AAAC,CAAa,Q,AAAA,C,AAAA,C,AAAC,E,AAAA,C,AACzE,wC,AAbD,QACY,mBACJ,UAAiC,CAAW,M,AAAA,C,AAA5C,CAAY,O,AAAC,CAAI,C,AAA2B,C,AAAA,E,AAAA,C,AACxC,oBACJ,CAAW,O,AAAC,CAAC,C,AAAA,Q,AAAI,qBAAY,SAAW,CAAc,Q,AAAA,C,AAAzB,IAAyB,C,AAAA,C,AAAC,E,AAAA,C,AAC9D,wC,AAfD,QACY,kDACqF,CAAA,CAAC,C,AAAG,CAAA,CAAC,C,AAAE,CAAC,C,AAAA,C,AAAC,S,AAAlD,MAAiB,iCAAmC,C,AAApD,CAAW,O,AAAC,CAAC,C,AAAuC,C,AAAA,S,AAApG,UAAqB,iCAAgF,C,AAArG,CAAY,O,AAAC,CAAI,C,AAAoF,C,AAAA,E,AAAA,C,AACjG,wBACE,CAAY,O,AADT,CAAE,G,AACU,C,AAAA,G,AAAE,CAAW,O,AADzB,CAAE,G,AAC0B,C,AAAA,Q,AAA/B,eAA+B,G,AAA/B,eAA+B,G,AAA/B,GACJ,CAAO,G,AAD4B,C,AAC1B,CAAO,G,AADmB,M,AAAA,C,AAAA,C,AAAA,C,AACf,QAAM,SAAW,IAAE,C,AAAC,IAAE,C,AAAA,C,AAAC,C,AACtC,IAAI,E,AAAA,C,AAClB,mK,AA0d2B,SAAc,CAAgB,C,AAAQ,mF,AADtC,UAAc,CAAc,C,AAAQ,iC,AAF/D,gBAAkB,oC,AA3HnB,QACY,oCACiD,EAAa,CAAC,C,AAAA,Q,AAAd,eAAc,C,AAAgB,QAAM,CAAA,CAAC,C,AAAP,CAAW,G,AAAD,C,AAAA,C,AAAC,C,AAAQ,IAAI,S,AAA1G,SAAqB,iCAAsF,C,AAA3G,CAAY,O,AAAC,CAAI,C,AAA0F,C,AAAA,E,AAAA,C,AACvG,oBACJ,EAAa,CAAK,C,AAAA,Q,AAAI,aAAY,CAAY,M,AAAA,M,AAAA,E,AAAA,C,AACrD,gC,AAnBD,QACY,oCACiD,EAAS,CAAC,C,AAAA,Q,AAAV,eAAU,C,AAAgB,QAAM,CAAA,CAAC,C,AAAP,CAAW,G,AAAD,C,AAAA,C,AAAC,C,AAAQ,IAAI,S,AAAtG,SAAqB,iCAAkF,C,AAAvG,CAAY,O,AAAC,CAAI,C,AAAsF,C,AAAA,E,AAAA,C,AAE1F,CAAY,M,AAAA,C,AAChC,8B,AAvBD,QACY,kCACwC,CAAA,CAAC,C,AAAE,CAAK,C,AAAA,S,AAApD,MAAqB,iCAAgC,C,AAArD,CAAY,O,AAAC,CAAI,C,AAAoC,C,AAAA,E,AAAA,C,AACjD,oBACJ,EAAS,CAAK,C,AAAA,Q,AAAI,aAAY,CAAY,M,AAAA,M,AAAA,E,AAAA,C,AACjD,6B,AA6JD,MAAc,SAA8B,C,AAA9B,QAA8B,C,AAA9B,QAAR,CAAI,C,AAAkC,C,AAAA,+B,AA7B5C,QACY,sBACE,CAAa,S,AAAA,uB,AAIiD,CAAA,CAAC,C,AAAE,QAAK,CAAC,C,AAAA,C,AAAA,S,AAJvE,CAAa,K,AAAA,C,AACjB,CAAW,G,AADM,G,AAAb,MAAa,E,AAAb,EACJ,CAAW,G,AADM,E,AAAA,E,AACjB,CAAW,G,AADM,G,AAAb,MAAa,E,AAAb,EACJ,CAAW,G,AADM,E,AAAA,E,AAAb,CAAa,C,AAAb,CAAa,e,AAEf,CAAe,CAAA,MAAuB,CAAC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,IAAI,C,AAAA,C,AAAC,e,AAEhD,MAAyC,iCAAiC,C,AAA1E,CAAU,O,AAAC,MAAuB,CAAC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAqC,C,AAAA,c,AAE1E,EAAS,G,AAAA,C,AACT,6BACE,eAAK,E,AAAL,EAGF,CAAU,O,AAAV,CAA8E,G,AAAlE,C,AAAA,K,AAAgB,EAAY,CAAe,YAAc,MAAM,C,AAAA,C,AAAC,C,AAAhD,mBAAA,SAAA,CAAiD,C,AAAjD,CAAiD,C,AAAA,E,AAAA,E,AAA7D,6BAA8D,C,AAHvE,E,AAAL,QACU,CAAe,YAAc,MAAM,C,AAAA,C,AAAC,C,AADzC,E,AAGuE,C,AACzF,iC,AA9BD,QACY,0CAK0C,CAAA,CAAC,C,AAAE,CAAiB,C,AAAA,I,AAJ5D,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,G,AACjB,CAAW,G,AADM,G,AAAb,MAAa,G,AAAb,EACJ,CAAW,G,AADM,K,AAAA,C,AAAA,C,AAAA,C,AAEf,CAAe,CAAA,MAAuB,CAAC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,IAAiB,C,AAAA,C,AAAC,C,AAE7D,MAAmB,iCAA4C,C,AAA/D,CAAU,O,AAAC,CAAI,C,AAAgD,C,AAAA,E,AAAA,C,AAC/D,mBACD,CAAK,M,AAAS,C,AACb,CAAU,O,AAAC,MAAA,CAAK,C,AAAM,C,AAAA,C,AAEtB,QAAM,CAAe,YAAc,MAAM,C,AAAA,C,AAAC,C,AAAC,E,AAAA,C,AACtD,8B,AAjCD,QACY,+DAO0D,EAAS,CAAC,C,AAAG,CAAC,C,AAAE,CAAC,C,AAAE,gBAAA,CAAC,I,AAAI,CAAG,E,AAAA,C,AAAC,S,AAD3E,CAAC,G,AAAG,CAAC,C,AAAM,CAAe,CAAA,CAAI,C,AAAE,SAAc,MAAS,CAAG,C,AAAA,C,AAAC,C,AAAA,C,AAAC,C,AAC1D,UAAmB,iCAAuD,C,AAA1E,CAAU,O,AAAC,CAAI,C,AAA2D,C,AAAA,I,AANrF,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,E,AAET,GAAA,EAAA,CAAuB,E,AAAvB,gBAAA,CAAuB,G,AAAA,C,AAAvB,iDAAuB,C,AAAA,C,AAAvB,CAAuB,C,AAAA,E,AAAvB,CAAuB,G,AAAA,C,AAEzB,EAAA,CAGuC,G,AAA9B,C,AAAC,MALR,CAAuB,G,AAKS,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAC,SAAE,C,AAAA,C,AACpC,EAAS,E,AACb,EAAS,E,AAAA,C,AACZ,oBACQ,MAAmB,CAAU,M,AAAA,C,AAApB,CAAoB,C,AAAA,Q,AACtC,SAAa,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,C,AAC/B,QAAM,SAAY,CAAe,YAAe,EAAO,SAAA,CAAK,C,AAAO,C,AAAA,C,AAAC,C,AAAC,C,AAAG,UAAS,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AAAC,C,AACxG,IAAI,E,AAAA,C,AAChB,+B,AAzBO,SAAA,CAAgB,C,AAAA,Q,AACxB,QACY,mBAAY,CAAC,I,AAAY,O,AAAC,CAAI,C,AAAA,E,AAAA,C,AAC9B,mBAAa,CAAC,I,AAAY,O,AAAC,CAAK,C,AAAA,E,AAAA,C,AAC3C,oC,AAvBW,aAAA,CAAK,C,AAAO,CAAG,GAAG,C,AAAG,C,AAAE,CAA4C,C,AAAC,Q,AAC/D,CAAK,U,AAAA,C,AAClB,QACY,kBAAY,CAAe,CAAA,CAAI,C,AAAE,CAAQ,C,AAAA,C,AAAC,E,AAAA,C,AAC1C,mBAAgB,SAAA,CAAK,C,AAAG,CAAQ,C,AAAA,C,AAAM,QAAK,EAAS,C,AAAA,C,AAAM,IAAI,E,AAAA,C,AACzE,E,AAEG,EAAQ,UAAa,CAAK,C,AAAA,C,AAC9B,QACY,oBACE,aAAiB,CAAqB,C,AAAtC,CAAa,S,AAAyB,C,AAAA,Q,AAAtC,eAAsC,C,AAExC,CAAe,CAAA,MAAf,CAAoD,G,AAAb,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,CAAQ,C,AAAA,C,AAAC,C,AACjD,EAAS,E,AAAA,C,AACZ,mBACD,SAAA,CAAK,C,AAAG,CAAQ,C,AAAA,C,AAAM,QAAM,CAAe,YAAc,CAAK,C,AAAA,C,AAAC,C,AAAC,C,AAAM,IAAI,E,AAAA,C,AACpF,C,AAAA,8C,AAnB6B,QAAuB,CAAO,C,AAAP,aAAL,CAAC,C,AAAW,C,AAAA,S,AAAK,KAAG,C,AAAxE,MAAW,iCAAsD,C,AAAtD,CAAsD,C,AAAA,C,AAAO,6B,AAV1D,QAAY,CAAO,C,AAAA,Q,AACjC,QACY,mBACJ,UAAW,mBAAsB,CAAO,O,AAAC,CAAI,C,AAAA,E,AAAA,C,AAAlC,CAAkC,C,AAAC,E,AAAA,C,AAC1C,mBACJ,UAAW,mBAAsB,CAAO,O,AAAC,CAAK,C,AAAA,E,AAAA,C,AAAnC,CAAmC,C,AAAC,E,AAAA,C,AACtD,gC,AAfD,QACY,mBACJ,MAAqB,kBAAkB,CAAA,CAAC,C,AAAE,CAAK,C,AAAA,E,AAAC,C,AAAhD,CAAY,O,AAAC,CAAI,C,AAA+B,C,AAAA,E,AAAA,C,AAC5C,mBACD,SAAA,CAAC,C,AAAG,CAAK,C,AAAA,C,AAAM,QAAK,CAAc,Q,AAAA,C,AAAA,C,AAAM,IAAI,E,AAAA,C,AACtD,iC,AA7DD,QACY,iCAC6B,CAAG,G,AAAA,S,AAApC,SAAqB,4BAA6B,C,AAAlD,CAAY,O,AAAC,CAAI,C,AAAiC,C,AAAA,E,AAAA,C,AAC9C,mBACD,EAAU,CAAK,C,AAAA,C,AAAM,CAAY,O,AAAC,CAAK,C,AAAA,C,AAAM,IAAI,E,AAAA,C,AAC3D,mC,AAdD,QACY,oCAC2C,EAAO,CAAC,C,AAAA,Q,AAAI,qBAAqB,CAAA,CAAC,C,AAAE,IAAC,C,AAAA,C,AAAC,S,AAArF,SAAqB,iCAAiE,C,AAAtF,CAAY,O,AAAC,CAAI,C,AAAqE,C,AAAA,E,AAAA,C,AAClF,oBACJ,EAAO,CAAK,C,AAAA,Q,AAAI,aAAY,CAAY,M,AAAA,M,AAAA,E,AAAA,C,AAC/C,gC,AAhBD,QACY,kCACwC,CAAA,CAAC,C,AAAE,EAAO,CAAC,C,AAAA,C,AAAA,S,AAAvD,MAAqB,iCAAmC,C,AAAxD,CAAY,O,AAAC,CAAI,C,AAAuC,C,AAAA,E,AAAA,C,AACpD,mBACY,CAAY,M,AAAA,C,AAA5B,EAAO,CAAK,C,AAAA,C,AAAgB,E,AAAA,C,AACnC,kC,AAdD,QACY,kCACwC,CAAA,CAAC,C,AAAE,EAAO,CAAC,C,AAAA,C,AAAA,S,AAAvD,MAAqB,iCAAmC,C,AAAxD,CAAY,O,AAAC,CAAI,C,AAAuC,C,AAAA,E,AAAA,C,AACpD,oBACJ,EAAO,CAAK,C,AAAA,Q,AAAI,aAAY,CAAY,M,AAAA,M,AAAA,E,AAAA,C,AAC/C,kC,AAfD,QACY,oCAC2C,EAAO,CAAC,C,AAAA,Q,AAAI,qBAAqB,CAAA,CAAC,C,AAAE,IAAC,C,AAAA,C,AAAC,S,AAArF,SAAqB,iCAAiE,C,AAAtF,CAAY,O,AAAC,CAAI,C,AAAqE,C,AAAA,E,AAAA,C,AAClF,mBACY,CAAY,M,AAAA,C,AAA5B,EAAO,CAAK,C,AAAA,C,AAAgB,E,AAAA,C,AACnC,kC,AAVD,GAAG,C,AAAG,OAAK,CAAM,C,AAAC,CAAQ,C,AAAA,2C,AApBpB,QAAM,CAAM,C,AAAC,CAAQ,C,AAAA,Q,AAArB,eAAqB,E,AAEnB,EAAA,CAAO,G,AAAA,E,AAAP,EAAU,EAAgB,E,AAC9B,EAAM,CAAW,O,AAAA,C,AAAX,CAAW,M,AAAA,C,AAAX,MAAW,C,AACL,CAAO,Q,AAAP,CAAmB,G,AAAA,G,AAEzB,CAAS,K,AAAA,I,AAAM,C,AAAf,CAAe,G,AAAf,IAAe,C,AAEd,CAAiB,CAAa,S,AAAA,c,AAAA,E,AACzB,EAAK,gBAAqB,W,AACb,qBAAqB,CAAE,Q,AAAQ,CAAC,C,AAAE,CAAC,C,AAAC,E,AAAC,C,AAAtD,CAAa,S,AAAyC,E,AACtD,CAAO,M,AAAS,CAAE,E,AAHtB,MAAuC,C,AAKvC,CAAO,M,AAAS,CAAC,C,AACJ,CAAW,O,AAAA,M,AAAA,C,AAAM,CAAO,Q,AAAW,MAAM,C,AAA1D,MAAiC,Y,AACxB,CAAI,S,AAAS,C,AAAE,CAAO,C,AAAC,C,AAbrB,C,AAAA,E,AAeX,WAAS,mCAAmC,C,AAAA,4C,AA/C1C,QAAM,CAAM,C,AAAC,CAAQ,C,AAAA,Q,AAArB,eAAqB,E,AAEnB,EAAA,CAAQ,G,AAAA,E,AAAR,GAAW,EAAA,EAAsC,C,AAAtC,CAAsC,U,AAAd,MAAa,E,AAAC,G,AACrD,EAAM,CAAW,O,AAAA,C,AAAX,eAAW,C,AACL,CAAQ,M,AAAR,CAAqB,G,AAAA,C,AAC1B,MAAE,G,AACH,CAAS,K,AAAA,I,AAAM,C,AAAf,CAAe,G,AAAf,IAAe,C,AAEd,CAAiB,CAAa,S,AAAA,c,AAAA,E,AACzB,EAAK,gBAAqB,W,AACb,qBAAqB,CAAE,Q,AAAQ,CAAC,C,AAAE,CAAC,C,AAAC,E,AAAC,C,AAAtD,CAAa,S,AAAyC,E,AACtD,CAAQ,a,AAAgB,KAAe,C,AACvC,CAAQ,M,AAAS,CAAE,C,AACnB,CAAQ,a,AAAgB,KAAK,E,AALjC,MAAuC,E,AAOvC,CAAQ,a,AAAgB,kBAA4B,C,AACpD,CAAQ,M,AAAS,CAAC,C,AAClB,CAAQ,a,AAAgB,KAAK,E,AAChB,CAAW,O,AAAA,M,AAAA,C,AAAM,CAAQ,M,AAAS,MAAgB,C,AAAnE,MAAiC,mC,AAE7B,CAAQ,S,AAAY,mBAAQ,EAAW,CAAc,C,AAAxB,E,AAAyB,C,AACtD,CAAQ,O,AAAU,uBAAI,EAAgB,YAAI,CAAG,C,AAAA,C,AAAtB,E,AAAuB,C,AAGhB,OADpB,CAAI,S,AACC,C,AAAE,CAAQ,C,AAAW,G,AACvC,C,AAvBW,C,AAAA,E,AAyBZ,WAAS,mCAAmC,C,AAAA,gC,AAhC1C,QAAM,CAAM,C,AAAC,CAAQ,C,AAAA,Q,AAArB,CAAqB,M,AAAA,C,AAArB,EAAqB,C,AACf,CAAU,G,AAAT,S,AADc,mC,AALrB,QAAM,CAAM,C,AAAC,CAAQ,C,AAAA,Q,AAArB,CAAqB,M,AAAA,C,AAArB,IAAqB,C,AAArB,QACM,CAAiB,G,AAAV,S,AAAS,C,AADD,iC,AAH3B,CAAY,O,AAAC,CAAQ,C,AAAA,Q,AAAI,qCAAwB,gD,AAHI,CAAa,S,AAAA,K,AAAA,C,AAAM,QAAK,CAAK,C,AAAA,C,AAAM,IAAI,S,AAD5F,UACG,iCAA0F,C,AAD7F,CAAY,O,AAAC,CAAI,C,AAC4E,C,AAAA,iC,AAX7F,QACY,kCAEa,CAAS,CAAI,C,AAAE,CAAC,C,AAAf,S,AADlB,MACG,iCAA+B,C,AADlC,CAAU,O,AAAC,MAAA,CAAuC,S,AAAA,C,AAAf,CAAa,S,AAAA,C,AAArC,CAAuC,S,AAAA,C,AAAvC,CAAuC,O,AAAA,C,AAAvC,CAAuC,K,AAAA,C,AAAA,C,AAChB,C,AAAA,E,AAAA,C,AAC9B,oBACJ,CAAU,O,AAAC,CAAK,C,AAAA,Q,AACb,qBAAY,MAAA,mBAAkB,MAAA,CAAwD,S,AAAA,C,AAAnC,aAAS,C,AAAa,CAAW,U,AAAA,C,AAAtD,CAAwD,O,AAAA,C,AAAxD,CAAwD,K,AAAA,C,AAAA,E,AAAC,C,AAA3E,IAA2E,C,AAAA,C,AAAC,E,AAAA,C,AAClG,+B,AApBD,QACY,sBACE,CAAS,K,AAAA,I,AAAM,Q,AAAf,CAAe,G,AAAf,IAAe,C,AACX,EAAS,E,AAET,EAAA,EAAY,CAAC,C,AAAA,C,AAAb,eAAa,C,AACP,CAAe,CAAA,MAAA,CAA6C,S,AAAA,C,AAA7C,CAA6C,U,AAAA,C,AAA7C,CAA6C,S,AAAA,C,AAA7C,CAA6C,O,AAAA,C,AAA1B,kBAAqB,IAAI,C,AAAA,C,AAAC,C,AAA5D,CAAgE,G,AAAD,C,AAAA,C,AAAC,C,AACrE,EAAS,C,AALC,E,AAKD,C,AAChB,wBACJ,QAAA,EAAsB,EAAE,aAAW,C,AAAb,MAAA,CAAkE,S,AAAA,C,AAAlE,CAAkE,U,AAAA,C,AAAlE,CAAkE,S,AAAA,C,AAAlE,CAAkE,O,AAAA,C,AAAxC,kBAAsB,EAAU,CAAK,C,AAAA,C,AAAC,C,AAAE,E,AAApF,C,AAAoF,E,AAAA,C,AAC/F,qC,AApBD,MACY,sBACE,CAAW,O,AAAA,Q,AAAX,eAAW,G,AACf,CAAO,G,AAAQ,G,AAAG,CAAC,G,AAAN,EAAb,CAAO,G,AADQ,K,AACI,C,AADJ,C,AAAA,C,AACQ,CAAc,CAAI,C,AAAA,C,AACpC,EAAS,E,AAAA,C,AAEhB,EAAc,EAAE,aAAW,C,AAAb,MAAA,CAAoC,S,AAAA,C,AAApC,CAAoC,U,AAAA,C,AAApC,CAAoC,S,AAAA,C,AAAR,QAAK,CAAC,C,AAAA,C,AAAlC,CAAoC,K,AAAA,C,AAAA,E,AAAA,C,AACzD,wC,AA9BD,QACY,4CAMiB,CACb,MAAA,CAA+B,S,AAAA,C,AAAP,CAAK,C,AAA7B,CAA+B,S,AAAA,C,AAA/B,CAA+B,O,AAAA,C,AAA/B,CAA+B,K,AAAA,C,AAAA,C,AAAE,CAAiB,C,AADpC,I,AALhB,CAAc,U,AAAA,S,AAAS,CAAG,C,AAAA,Q,AAA1B,eAA0B,E,AAA1B,EAGU,CAAc,U,AAAkB,U,AAAA,C,AAC5C,MACG,iCAEF,C,AAHD,CAAU,Q,AAAC,EAAE,aAAW,C,AAAb,MAA8B,WADrC,CAAK,G,AACmC,E,AAAE,C,AAAnC,CAAqC,U,AAAA,C,AAArC,CAAqC,S,AAAA,C,AAArC,CAAqC,O,AAAA,C,AAArC,CAAqC,K,AAAA,C,AAAA,E,AAG/C,C,AAAA,E,AAPC,CACmB,CAAA,CAAI,C,AAAE,IAAiB,C,AAAA,C,AADhB,E,AAO3B,C,AACD,+BACD,CAAK,M,AAAS,E,AACb,EAAA,CAAU,O,AAAC,MAAA,CAAK,C,AAAM,C,AAAA,C,AAAI,sBAClB,EACE,UADgB,IAAC,C,AACP,S,AAAA,C,AAAV,CAAU,K,AAAA,G,AACd,CAAK,G,AADS,K,AAAA,G,AAAV,EACJ,CAAK,G,AADS,K,AAAA,C,AAAA,C,AAAA,C,AACL,EAAc,EAAE,aAAW,C,AAAb,MAAA,CAAsD,S,AAAA,C,AAAvB,kBAAW,WAAE,CAAA,CAAG,C,AAAE,CAAC,C,AAAA,E,AAAE,E,AAAA,C,AAApD,CAAsD,S,AAAA,C,AAAtD,CAAsD,O,AAAA,C,AAAtD,CAAsD,K,AAAA,C,AAAA,E,AAAA,C,AACxE,EAAS,E,AACnB,E,AAED,QAAK,EAAS,C,AAAA,E,AAAA,C,AACzB,sC,AA5CD,QACY,4CAMiB,CACb,MAAA,CAA+B,S,AAAA,C,AAAP,CAAK,C,AAA7B,CAA+B,S,AAAA,C,AAA/B,CAA+B,O,AAAA,C,AAA/B,CAA+B,K,AAAA,C,AAAA,C,AAAE,QAAK,CAAC,C,AAAA,C,AADzB,I,AALhB,CAAc,U,AAAA,S,AAAS,CAAG,C,AAAA,Q,AAA1B,eAA0B,E,AAA1B,EAGU,CAAc,U,AAAkB,U,AAAA,C,AAC5C,MACG,iCAEF,C,AAHD,CAAU,Q,AAAC,EAAE,aAAW,C,AAAb,MAA8B,WADrC,CAAK,G,AACmC,E,AAAE,C,AAAnC,CAAqC,U,AAAA,C,AAArC,CAAqC,S,AAAA,C,AAArC,CAAqC,O,AAAA,C,AAArC,CAAqC,K,AAAA,C,AAAA,E,AAG/C,C,AAAA,E,AAPC,CACmB,CAAA,CAAI,C,AAAE,IAAI,C,AAAA,C,AADH,E,AAO3B,C,AACD,+BACE,eAAK,E,AAAL,EAGF,CAAU,O,AAAV,CAKC,G,AALW,C,AAAA,C,AAAI,sBACR,EACE,UADgB,IAAC,C,AACP,S,AAAA,C,AAAV,CAAU,K,AAAA,G,AACd,CAAK,G,AADS,K,AAAA,G,AAAV,EACJ,CAAK,G,AADS,K,AAAA,C,AAAA,C,AAAA,C,AACL,EAAc,EAAE,aAAW,C,AAAb,MAAA,CAAsD,S,AAAA,C,AAAvB,kBAAW,WAAE,CAAA,CAAG,C,AAAE,CAAC,C,AAAA,E,AAAE,E,AAAA,C,AAApD,CAAsD,S,AAAA,C,AAAtD,CAAsD,O,AAAA,C,AAAtD,CAAsD,K,AAAA,C,AAAA,E,AAAA,C,AACxE,EAAS,E,AACnB,E,AARC,QACS,EAAS,C,AADb,E,AAQN,C,AACZ,gC,AAzCD,QACY,4CAOI,CAAA,MAAA,CAA+B,S,AAAA,C,AAAP,CAAK,C,AAA7B,CAA+B,S,AAAA,C,AAA/B,CAA+B,O,AAAA,C,AAA/B,CAA+B,K,AAAA,C,AAAA,C,AAAE,CAAC,C,AAAA,I,AANpC,CAAc,U,AAAA,S,AAAS,CAAG,C,AAAA,Q,AAA1B,eAA0B,E,AAA1B,EAGU,CAAc,U,AAAkB,U,AAAA,C,AAC5C,MACG,iCAEF,C,AAHD,CAAU,Q,AAAC,EAAE,aAAW,C,AAAb,MAA8B,WADrC,CAAK,G,AACmC,E,AAAE,C,AAAnC,CAAqC,U,AAAA,C,AAArC,CAAqC,S,AAAA,C,AAArC,CAAqC,O,AAAA,C,AAArC,CAAqC,K,AAAA,C,AAAA,E,AAG/C,C,AAAA,E,AAPC,EAA0B,E,AAO3B,C,AACD,0BACJ,CAAU,O,AAAC,CAAK,C,AAAA,Q,AAAI,sBACZ,EACE,UADgB,IAAC,C,AACP,S,AAAA,C,AAAV,CAAU,K,AAAA,G,AACd,CAAK,G,AADS,K,AAAA,G,AAAV,EACJ,CAAK,G,AADS,K,AAAA,C,AAAA,C,AAAA,C,AACL,EAAc,EAAE,aAAW,C,AAAb,MAAA,CAAsD,S,AAAA,C,AAAvB,kBAAW,WAAE,CAAA,CAAG,C,AAAE,CAAC,C,AAAA,E,AAAE,E,AAAA,C,AAApD,CAAsD,S,AAAA,C,AAAtD,CAAsD,O,AAAA,C,AAAtD,CAAsD,K,AAAA,C,AAAA,E,AAAA,C,AACxE,EAAS,E,AACnB,E,AAAA,C,AACR,0C,AA/BD,QACY,oBACE,EAAK,CAAa,S,AAAA,C,AAAE,CAAc,U,AAAA,C,AAAC,Q,AAAnC,CAAmC,M,AAAA,C,AAAnC,EAAmC,C,AAAnC,CAEa,CAAA,MAAuB,SAAE,C,AAAzB,CAA2B,U,AAAA,C,AAA3B,CAA2B,S,AAAA,C,AAA3B,CAA2B,O,AAAA,C,AAA3B,CAA2B,K,AAAA,C,AAAA,C,AAA1C,CAA+C,G,AAAD,C,AAAA,C,AAFT,E,AAI5B,C,AACT,sBACO,EAAI,CAAK,C,AAAA,O,AACpB,QAAM,EAAc,EAAE,aAAW,C,AAAb,MADhB,CAAI,G,AAC2C,C,AAD/C,CAAI,G,AAC0D,C,AAA9C,CAAgD,S,AAAA,C,AAAhD,CAAgD,O,AAAA,C,AAAhD,CAAgD,K,AAAA,C,AAAA,E,AAAA,C,AAAC,E,AAAA,C,AAC5E,iC,AAvBD,QACY,oBACE,EAAI,CAAa,S,AAAA,C,AAAA,Q,AAAjB,CAAiB,M,AAAA,C,AAAjB,EAAiB,C,AAAjB,CAEa,CAAA,MAAuB,SAAE,C,AAAzB,CAA2B,U,AAAA,C,AAA3B,CAA2B,S,AAAA,C,AAA3B,CAA2B,O,AAAA,C,AAA3B,CAA2B,K,AAAA,C,AAAA,C,AAA1C,CAA+C,G,AAAD,C,AAAA,C,AAF3B,E,AAIV,C,AACT,kBACJ,QAAM,CAAe,YAAc,EAAI,CAAK,C,AAAA,C,AAAC,C,AAAC,C,AAAC,E,AAAA,C,AACtD,qQ,AA66BU,CAAG,E,AACE,EAAI,CAAK,C,AAAE,CAAE,C,AAAA,C,AACd,SAAA,CAAC,C,AAAG,MAAY,C,AAAA,C,AAAM,IAAQ,C,AAAM,QAAU,CAAC,C,AAAC,E,AAEnD,CAAK,C,AAAE,CAAE,C,AAAA,S,AALjB,MAAU,sCAMT,C,AANS,CAMT,C,AAAA,+C,AAGsC,eAChC,CAAG,K,AACI,eAAiB,C,AAGnB,CAAC,C,AAAE,CAAE,E,AAAL,CAAW,G,AAAA,O,AAEf,CAAC,C,AAAE,CAAE,E,AAAK,CAAC,E,AAAA,I,AARX,GAAM,G,AACY,2CAAA,sCAQzB,U,AAAA,yC,AAIG,CAAA,CAAC,C,AAOI,OAAU,C,AANf,MAAM,mBACI,OAAA,CAAC,U,AAAA,C,AAAD,QAIU,CAAA,CAAC,C,AAAE,CADX,MAAU,CAAM,C,AAAE,CAAC,C,AAAZ,I,AACK,C,AAAA,C,AAJb,C,AAAD,QACsB,CAAC,C,AADtB,E,AAIc,C,AALnB,CAKmB,C,AACxB,C,AAAc,C,AAAA,I,AARnB,MAAa,iCASZ,C,AATY,CASZ,C,AAAA,G,AAED,QACY,0EAY8B,CAAG,Q,AAAA,O,AACzB,EAAI,C,AAAE,CAAC,C,AAAK,EAAC,W,AACL,EAAC,C,AAAC,EAAC,C,AAAC,EAAI,U,AAZlB,CAAM,K,AAAA,C,AAGV,CAAiB,G,AAHP,K,AAAA,E,AAAN,EAGJ,CAAiB,G,AAKA,G,AARP,G,AAAA,K,AAGV,CAAiB,G,AAHP,C,AASR,UAAgB,qCAIf,C,AAVH,CAAiB,G,AAKA,G,AARP,G,AASD,O,AAAC,CAAI,C,AAIX,C,AAAA,C,AAbO,G,AAAN,GAII,CAAa,S,AAAA,C,AAAb,EAAa,K,AAAA,G,AACjB,EAAQ,G,AAAQ,G,AAFpB,CAAiB,G,AAAL,G,AAEY,G,AAAN,IAAd,EAAQ,G,AADS,C,AACjB,EAAQ,G,AADS,M,AACG,C,AADH,C,AAAA,C,AAEf,EAHN,CAAiB,G,AAGF,C,AAAC,MAAuB,KAAE,C,AAAzB,CAA2B,U,AAAA,C,AAA3B,CAA2B,S,AAAA,C,AAA3B,CAA2B,O,AAAA,C,AAA3B,CAA2B,K,AAAA,C,AAAA,C,AAAC,CAAG,C,AAAA,C,AACtC,EAAS,C,AAPR,C,AAAN,CAEa,CAAA,CAAI,C,AAAE,EAAa,CAAG,C,AAAA,C,AAAA,C,AAF7B,yB,AAeT,kBAAgB,CAAC,C,AAAC,CAAW,O,AAAA,C,AAAA,C,AACxB,EACI,CAAE,C,AAAC,CAAI,C,AAAC,SADW,SAAA,CAAM,C,AAAO,M,AACrB,C,AADZ,C,AAEN,EAAS,S,AAnBlB,UAewB,iCAIN,C,AAJM,CAIN,C,AACjB,E,AAAA,C,AACG,8BACS,EAAW,CAAK,C,AAAA,G,AACZ,MAAA,CAAS,C,AAAE,CAAC,C,AAAC,G,AAA1B,CAAU,G,AAAA,G,AAEV,MAAM,oBAAW,OAAA,EAIU,U,AAJF,C,AAIjB,CADI,MAAU,CAAM,C,AAAE,EAAC,C,AAAZ,I,AACJ,O,AAAC,MAAA,CAAM,C,AAAE,EAAC,C,AAAC,C,AAJD,C,AAAR,QACU,CAAe,YAAc,EAAC,C,AAAC,C,AAAC,C,AADlC,E,AAKxB,C,AAPD,CAAU,G,AAOT,C,AAAA,Q,AACF,SAAa,oBAAA,EAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,E,AAC3B,EAAI,UAAS,oBAAY,EAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AACjC,CAAM,M,AAAA,C,AAAN,QAES,CAAC,C,AAFJ,C,AAAN,QACY,SAAY,EAAc,EAAE,aAAW,C,AAAb,MAAA,CAAoC,S,AAAA,C,AAApC,CAAoC,U,AAAA,C,AAApC,CAAoC,S,AAAA,C,AAAR,CAAM,C,AAAlC,CAAoC,K,AAAA,C,AAAA,E,AAAA,C,AAAE,CAAC,C,AAAA,C,AADvE,E,AAGX,IAAI,E,AAAA,C,AAChB,Q,AACY,CAAU,U,AAAA,C,AACvB,CAAS,C,AAET,MAAY,SAAW,CAAU,C,AAAE,CAAc,CAAS,C,AAAA,C,AAAC,C,AAAC,0E,AAvIpD,eAAQ,E,AACU,SAAA,CAAK,C,AAAL,CAAS,G,AAAA,C,AAAA,I,AAF/B,eAAS,4BAGO,C,AAHP,CAGO,C,AACf,Q,AACC,eAAU,C,AACJ,CAAC,G,AAAA,C,AACN,CAAK,E,AAAK,yB,AAEb,OACO,SAAA,CADP,MAAe,CAAK,C,AAAE,CAAG,C,AAAb,I,AACC,C,AAAO,C,AAAE,mBACtB,CAAK,C,AAAE,GAAG,C,AAAG,EAAO,CAAC,C,AAAA,C,AAAA,E,AAAA,C,AAFT,8B,AAKE,CAAC,M,AAAA,C,AAAM,EAAM,C,AAAM,IAAO,CAAC,E,AAAA,G,AACvC,MAAA,CAAK,C,AAAE,CAAG,C,AAAC,O,AAAX,CAAA,EAAA,CAAW,G,AAAA,gB,AAAA,E,AAAX,CAAW,G,AACgB,G,AAAA,E,AAE7B,CAAC,G,AAAU,CAAG,S,AACC,cACX,CAAC,C,AAAE,GAAG,C,AAAG,EAAO,CAAC,C,AAAA,E,AAAK,CAAC,E,AAC1B,C,AAFc,CAEd,G,AACA,C,AAPY,8C,AAUiB,CAAA,CAAC,C,AAAE,CAAC,C,AAAE,CAAC,C,AAAE,CAAM,C,AAAA,I,AADH,CAAc,G,AAAA,Q,AACxD,MAAO,iCAAsC,C,AADH,CAAc,G,AACX,C,AAAC,I,AADlD,UAAwB,iCAEvB,C,AAFQ,SAAW,G,AAEnB,C,AAAA,Q,AACL,QACY,iGAWsE,GAAQ,EAAC,C,AAAC,EAAC,C,AAAE,gBAAA,EAAC,I,AAAI,EAAG,E,AAAA,C,AAAC,S,AAFtE,EAAM,K,AAAA,E,AAAN,GAEM,EAAiE,G,AAAA,C,AAAjE,UAAgB,qCAAiD,C,AAAjE,EAAiE,G,AAA1D,O,AAAC,EAAI,C,AAAqD,C,AAAA,E,AAFvE,CACiB,CAAA,EAAI,C,AAAE,IAAc,SAAc,MAAS,EAAG,C,AAAA,C,AAAC,C,AAAC,C,AAAA,C,AAD3D,S,AAPzB,kBAAgB,CAAC,C,AAAC,CAAW,O,AAAA,C,AAAA,E,AACtB,EAAA,aAAiB,UAA8B,CAAC,C,AAAC,C,AAAjD,CAAa,S,AAAoC,C,AAAA,C,AAAjD,CAAiD,M,AAAA,C,AAAjD,EAAiD,E,AAAjD,EAEI,CAAmB,G,AAAA,E,AAAnB,EAAA,UAAa,CAAM,C,AAAA,C,AAAnB,CAAmB,K,AAAA,C,AACjB,CAAe,CAAA,MAAuB,CAAC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,IAAa,EAAI,C,AAAA,C,AAAA,C,AAAC,C,AAEjE,GAIQ,CAAM,C,AAAC,MAAuB,CAAC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAC,SAAE,C,AAAA,C,AATG,C,AAAA,E,AAYvD,EAAS,S,AAdjB,UAAc,2CAeb,C,AAfa,CAeb,C,AAAA,E,AAAA,C,AACG,oDAS8D,EAAO,O,AAAC,CAAC,C,AAAA,I,AARjE,EAAO,CAAK,C,AAAA,G,AACD,MAAA,CAAK,C,AAAE,CAAG,C,AAAC,G,AAA5B,CAAc,G,AAAA,G,AACC,MADf,CAAc,G,AACI,C,AAAE,CAAC,C,AAAC,G,AACX,CAAe,UAAe,UADzC,CAAY,G,AAC8C,C,AAAA,C,AAD1D,CAAY,G,AACsD,C,AAAC,C,AAAC,O,AAClE,UAAA,CAAM,C,AAAN,IAAM,C,AAAA,E,AAAN,CAAM,O,AAAA,G,AAAN,CAAM,C,AACF,QAAK,CAAQ,C,AAAA,E,AAEf,EACA,EAAmC,qBAAA,CAAiC,C,AAAA,E,AAAnE,EAAW,CAAG,C,AAAC,CAAK,C,AAAA,K,AAA+C,C,AACrE,SAAa,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAU,C,AAAA,C,AACpC,QAAM,SAAW,CAAQ,C,AAAE,UAAc,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AAAC,C,AAChE,IAAI,C,AAPD,E,AAOC,C,AACpB,0C,AAlEK,eAAI,C,AAAJ,eAAI,C,AAAJ,SACJ,CAAO,G,AAAc,C,AAAZ,CAAM,G,AAAU,C,AADjB,C,AAAJ,IAAI,C,AAAJ,EAAA,eAAI,C,AAAA,iF,AAtCC,CAAG,E,AACE,EAAI,CAAK,C,AAAE,CAAE,C,AAAA,C,AACd,SAAA,CAAC,C,AAAG,MAAY,C,AAAA,C,AAAM,IAAQ,C,AAAM,QAAU,CAAC,C,AAAC,E,AAEnD,CAAK,C,AAAE,CAAE,C,AAAA,S,AALjB,MAAU,sCAMT,C,AANS,CAMT,C,AAAA,+C,AAGsC,eAChC,CAAG,K,AACI,eAAiB,C,AAGnB,CAAC,C,AAAE,CAAE,E,AAAL,CAAW,G,AAAA,O,AAEf,CAAC,C,AAAE,CAAE,E,AAAK,CAAC,E,AAAA,I,AARD,CAAC,M,AAAA,C,AAAM,EAAM,C,AAAM,IAAO,CAAC,E,AAAA,G,AACnB,2CAAA,sCAQzB,U,AAAA,4C,AAEkC,CAAC,I,AAA3B,MAAU,sCAA8B,C,AAA9B,CAA8B,C,AAAA,G,AACnC,UAAa,CAAM,C,AAAA,Q,AACrC,QACY,2DAIsD,EAAQ,CAAC,C,AAAC,CAAC,C,AAAE,gBAAA,CAAC,I,AAAI,CAAG,E,AAAA,C,AAAC,S,AAFtE,CAAM,K,AAAA,E,AAAN,EAEM,CAAiE,G,AAAA,C,AAAjE,UAAgB,iCAAiD,C,AAAjE,CAAiE,G,AAA1D,O,AAAC,CAAI,C,AAAqD,C,AAAA,E,AAFvE,CACiB,CAAA,CAAI,C,AAAE,EAAc,SAAc,MAAS,CAAG,C,AAAA,C,AAAC,C,AAAC,C,AAAA,C,AAD3D,S,AADhB,EAIQ,CAAU,C,AAAC,CAAI,C,AAAC,SAAE,C,AAAA,E,AAAA,C,AACtB,yCAGI,CAAO,O,AAAC,CAAC,C,AAAA,I,AADb,EAA+B,qBAAA,CAE9B,C,AAAA,E,AAFA,EAAW,CAAK,C,AAAA,K,AAEhB,Q,AACF,SAAa,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,C,AAC/B,QAAM,UAAS,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AACrC,IAAI,E,AAAA,C,AAChB,gC,AAhFG,QAIE,mBAHF,OAAW,SAAA,CAAK,C,AAAO,C,AAAE,mBACpB,CAAoB,C,AAAG,CAAC,C,AAAC,E,AAAA,C,AAC7B,E,AACU,C,AAAC,IAAG,C,AAAC,CAAK,C,AAJC,kC,AAlB1B,QACY,2DAIsD,EAAQ,CAAC,C,AAAC,CAAC,C,AAAE,gBAAA,CAAC,I,AAAI,CAAG,E,AAAA,C,AAAC,S,AAFtE,CAAK,K,AAAA,E,AAAL,EAEM,CAAiE,G,AAAA,C,AAAjE,UAAgB,iCAAiD,C,AAAjE,CAAiE,G,AAA1D,O,AAAC,CAAI,C,AAAqD,C,AAAA,E,AAFvE,CACiB,CAAA,CAAI,C,AAAE,EAAa,SAAc,MAAS,CAAG,C,AAAA,C,AAAC,C,AAAC,C,AAAA,C,AAD3D,S,AADf,EAIS,UAAa,CAAK,C,AAAA,C,AAAE,CAAI,C,AAAC,SAAE,C,AAAA,E,AAAA,C,AAChC,yCAGI,CAAO,O,AAAC,CAAC,C,AAAA,I,AADb,EAA6B,qBAAA,CAE5B,C,AAAA,E,AAFA,EAAU,CAAK,C,AAAA,K,AAEf,Q,AACF,SAAa,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,C,AAC/B,QAAM,UAAS,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AACrC,IAAI,E,AAAA,C,AAChB,6F,AAjED,QACY,mDAKiD,EAAQ,CAAC,C,AAAE,gBAAA,CAAC,I,AAAI,CAAG,E,AAAA,C,AAAC,S,AAH/D,CAAa,S,AAAA,K,AAAA,C,AACX,CAAe,CAAA,CAAI,C,AAAE,MAAS,CAAG,C,AAAA,C,AAAA,C,AAAC,C,AAEtC,UAAmB,iCAA+C,C,AAAlE,CAAU,O,AAAC,CAAI,C,AAAmD,C,AAAA,S,AAJ1E,EAKQ,CAAI,C,AAAC,SAAE,C,AAAA,E,AAAA,C,AACX,oBACQ,MAAkB,CAAU,M,AAAA,C,AAAnB,CAAmB,C,AAAA,Q,AACrC,SAAY,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,C,AAC9B,QAAM,UAAS,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AACrC,IAAI,E,AAAA,C,AAChB,uC,AA7BD,QACY,mDAKiD,EAAQ,CAAC,C,AAAE,gBAAA,CAAC,I,AAAI,CAAG,E,AAAA,C,AAAC,S,AAH/D,CAAa,S,AAAA,K,AAAA,C,AACX,CAAe,CAAA,CAAI,C,AAAE,SAAc,MAAS,CAAG,C,AAAA,C,AAAC,C,AAAA,C,AAAC,C,AAErD,UAAmB,iCAA+C,C,AAAlE,CAAU,O,AAAC,CAAI,C,AAAmD,C,AAAA,S,AAJ1E,EAKQ,CAAI,C,AAAC,SAAE,C,AAAA,E,AAAA,C,AACX,oBACQ,MAAmB,CAAU,M,AAAA,C,AAApB,CAAoB,C,AAAA,Q,AACtC,SAAa,mBAAA,CAAa,M,AAAA,E,AAAA,C,AAAC,CAAK,C,AAAA,C,AAC/B,QAAM,UAAS,mBAAY,CAAU,G,AAAA,E,AAAA,C,AAAtB,CAAsB,C,AAAA,C,AAAC,C,AACrC,IAAI,E,AAAA,C,AAChB,k1B,AAqBS,EAAA,CAAuB,E,AAAvB,gBAAsB,CAAC,C,AAAvB,iDAAuB,C,AAAA,C,AAAvB,CAAuB,C,AAAA,S,AAAvB,CAAuB,G,AAAA,C,AAChB,QAAA,CAAM,G,AAAA,C,AAAA,C,AACZ,IAAI,U,AA1vBf,QACY,iBAAI,EAAC,E,AAAa,C,AAClB,kBAAI,IAAC,E,AAAQ,C,AACxB,S,AAymBD,MACY,kBAAY,CAAc,CAAI,C,AAAA,E,AAAA,C,AAC5B,EAAS,C,AACtB,W,AAQD,QACY,sBACE,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,E,AAET,EAAA,OAAA,CAAqB,G,AAAA,C,AAAA,C,AAArB,eAAqB,C,AAEvB,CAAe,CAAA,MAFb,CAAqB,G,AAEgB,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAzC,CAA6C,G,AAAD,C,AAAA,C,AAAC,C,AAC1C,EAAS,E,AACb,EAAS,E,AAAA,C,AACZ,kBACJ,QAAM,CAAe,YAAyB,CAAK,M,AAAA,C,AAAM,MAAM,C,AAAM,QAAqB,CAAK,C,AAAA,C,AAAC,C,AAAC,C,AAAC,E,AAAA,C,AACzG,S,AAID,QACY,wBACE,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,E,AAET,EAAA,OAAA,CAAqB,G,AAAA,C,AAAA,C,AAArB,eAAqB,G,AACzB,CAAM,G,AAAO,O,AAAO,G,AAAG,CAAC,G,AAAZ,EAAZ,CAAM,G,AADmB,K,AACD,C,AADC,C,AAAA,C,AAEvB,CAAe,CAAA,MAFb,CAAqB,G,AAEgB,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,QAAK,CAAC,C,AAAA,C,AAAA,C,AAAC,C,AAC/C,EAAS,E,AACb,EAAS,E,AAAA,C,AACZ,kBACJ,QAAM,CAAe,YAAe,CAAY,C,AAAC,C,AAAC,C,AAAC,E,AAAA,C,AAC1D,S,AAmBO,qPAAwB,Q,AAEzB,uPAAgB,W,AAEb,gOAAmB,U,AAEpB,uPAAkB,S,AAEnB,sPAAiB,U,AAEhB,uPAAkB,W,AAEjB,wPAAmB,S,AAErB,wPAAmB,U,AAElB,uPAAkB,W,AAEjB,wPAAmB,W,AAEnB,gOAAmB,S,AAM7B,QACY,wBACE,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,E,AAET,GAAA,EAAA,IAAyB,E,AAAzB,eAAA,CAAyB,G,AAAA,C,AAAzB,iDAAyB,C,AAAA,C,AAAzB,CAAyB,C,AAAA,E,AAAzB,CAAyB,G,AAAA,C,AAE3B,CAAe,CAAA,MAFb,CAAyB,G,AAEY,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAzC,CAA6C,G,AAAD,C,AAAA,C,AAAC,C,AAC1C,EAAS,E,AACb,EAAS,E,AAAA,C,AACZ,kBACJ,QAAM,CAAe,YAAkB,CAAK,C,AAAM,MAAM,C,AAAM,OAAO,C,AAAC,C,AAAC,C,AAAC,E,AAAA,C,AAC/E,a,AAID,QACY,kBACA,CACW,CAAA,MAAuB,SAAE,C,AAAzB,CAA2B,U,AAAA,C,AAA3B,CAA2B,S,AAAA,C,AAA3B,CAA2B,O,AAAA,C,AAA3B,CAA2B,K,AAAA,C,AAAA,C,AAAE,SADnB,GAAiB,C,AAAlC,CAAa,S,AAAqB,C,AACG,C,AAAA,C,AADxC,E,AACyC,C,AAC1C,kBACJ,QAAM,CAAe,YAAc,CAAK,C,AAAA,C,AAAC,C,AAAC,E,AAAA,C,AACjD,a,AAoCG,QAKQ,oCACE,CAAa,S,AAAA,Q,AAAb,CAAa,K,AAAA,E,AAEf,EAAA,CAKc,G,AAAA,C,AALX,CAAC,O,AAAO,G,AAAG,EAAE,E,AAAI,CAAC,C,AAAE,CAAC,C,AAAC,G,AAAG,GAAG,E,AAAI,CAAC,C,AAAE,CAAC,C,AAAC,G,AAAG,GAAG,E,AAAI,CAAC,C,AAAE,EAAE,C,AAAC,G,AAAG,GAAG,E,AAAI,CAAC,C,AAAE,EAAE,C,AAAC,G,AAAG,GAAG,E,AAAI,CAAC,C,AAAE,EAAE,C,AAAC,G,AAAG,GAAG,E,AACpF,EAAA,EAAK,SAAA,CAAC,C,AAAE,QAAA,CAAC,C,AAAA,C,AAAI,QAAA,CAAC,C,AAAA,C,AAAC,C,AAAA,I,AAAE,EAAK,SAAA,CAAC,C,AAAE,QAAA,CAAC,C,AAAA,C,AAAI,QAAA,CAAC,C,AAAA,C,AAAC,C,AAAA,I,AAAE,EAAK,SAAA,CAAC,C,AAAE,QAAA,CAAC,C,AAAA,C,AAAI,QAAA,CAAC,C,AAAA,C,AAAC,C,AAAA,I,AAAE,EAAK,SAAA,CAAC,C,AAAE,QAAA,EAAE,C,AAAA,C,AAAI,QAAA,EAAE,C,AAAA,C,AAAC,C,AAAA,I,AAAE,EAAK,SAAA,CAAC,C,AAAE,QAAA,EAAE,C,AAAA,C,AAAI,QAAA,EAAE,C,AAAA,C,AAAC,C,AAAA,I,AAAE,EAAK,SAAA,CAAC,C,AAAE,QAAA,EAAE,C,AAAA,C,AAAI,QAAA,EAAE,C,AAAA,C,AAAC,C,AAAA,C,AAA1G,eAA0G,G,AAA1G,eAA0G,G,AAA1G,eAA0G,G,AAA1G,eAA0G,G,AAA1G,eAA0G,G,AAA1G,eAA0G,G,AAA1G,GACY,CAAM,G,AADwF,C,AACtF,CAAM,G,AADgF,C,AACtG,CAAM,G,AADgG,C,AAC9E,CAAO,G,AADuE,C,AACrE,CAAM,G,AAD+D,C,AAC9G,CAAM,G,AADwG,M,AAAA,C,AAAA,C,AAAA,C,AAAA,C,AAAA,C,AAAA,C,AAAA,C,AAE5G,CAAe,CAAA,MAHvB,CAKc,G,AAFiC,C,AAAxB,CAA0B,U,AAAA,C,AAA1B,CAA0B,S,AAAA,C,AAA1B,CAA0B,O,AAAA,C,AAA1B,CAA0B,K,AAAA,C,AAAA,C,AAAE,YAAgB,IAAC,C,AAAE,IAAC,G,AAAE,IAAC,C,AAAE,IAAC,C,AAAE,IAAE,C,AAAE,IAAC,Y,AAAC,C,AAAA,C,AAAC,C,AAC3E,EAAS,K,AAHgG,E,AAI/G,EAAS,E,AACX,EAAS,E,AAAA,C,AACZ,0CAEQ,EAAO,CAAC,C,AAAA,Q,AACb,CAAC,O,AAAO,G,AAAG,CAAC,C,AAAM,GAAG,C,AAAG,CAAC,C,AAAM,CAAC,Q,AAFnC,QAaE,CAAe,YAFjB,CAAA,EAPQ,EAAO,YAOV,CAAC,gB,AAPU,C,AAAA,E,AACV,EAAA,CAAC,O,AAAO,C,AAAR,CAAQ,G,AAAR,CAAQ,C,AACP,KAAK,C,AAAG,CAAC,C,AADV,CAAQ,G,AAAR,CAAQ,C,AAEP,IAAI,C,AAAG,CAAC,C,AAFT,CAAQ,G,AAAR,CAAQ,C,AAGP,GAAG,C,AAAG,CAAC,C,AAHR,CAAQ,C,AAMH,E,AAAG,GAAG,C,AAAG,EAAK,YAAA,CAAC,e,AAAM,C,AAAA,C,AAAG,GAAG,C,AAAG,EAAK,YAAA,CAAC,Y,AAAI,C,AAAA,C,AACjD,GAAG,C,AAAG,EAAK,YAAA,CAAC,a,AAAK,C,AAAA,C,AAAG,GAAG,C,AAAG,EAAK,YAAA,CAAC,e,AAAO,C,AAAA,C,AAAG,GAAG,C,AAAG,EAAK,YAAA,CAAC,e,AAAO,C,AAAA,C,AAC/B,C,AAAC,C,AAbpB,E,AAaqB,C,AA7BpC,Q;"
}
