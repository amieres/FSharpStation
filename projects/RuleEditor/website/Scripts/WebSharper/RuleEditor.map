{
"version": 3,
"sourceRoot": "Source",
"sources": ["RuleEditor/RuleEditor.fs"],
"sourcesContent": ["#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1547097944900 -d:WEBSHARPER\n////#cd @\"..\\projects\\RuleEditor\\src\"\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n//#r @\"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1547097944900\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            [< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDay()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\n            let nowStamp() = \n                let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n                t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n            \n            let [<Inline>] inline traceT t v = tee (sprintf \"%A\" >> (fun s -> s.[..min 100 s.Length-1]) >> printfn \"%s %s: %A\" (nowStamp()) t) v\n            let [<Inline>] inline trace   v = traceT \"trace\" v\n            let [<Inline>] inline traceI  v = trace          v |> ignore\n            \n            module Log =\n                let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n                let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n                let [<Inline>] inline InA    n f p = async { return! In  n f p }\n                let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n                let [<Inline>] inline InOut  n     = In  n >> Out  n\n                let [<Inline>] inline InOutA n f p = async {\n                    let!   r = InA n f  p\n                    do         Out n id r |> ignore\n                    return r \n                  }\n            \n                let [<Inline>] inline TimeIt n f p =\n                    printfn \"Starting %s\" n\n                    let start = System.DateTime.UtcNow.Ticks\n                    f p\n                    let elapsedSpan = new System.TimeSpan(System.DateTime.UtcNow.Ticks - start)\n                    print <| elapsedSpan.ToString()\n            \n            \n            (* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\n            module IDict =\n            #if WEBSHARPER\n                [< Inline >]\n            #endif\n                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            *)\n            module Dict =\n                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            \n            module LDict =\n                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n                let [<Inline>] inline tryGetValue fitem key  dict =\n                    if containsKey key dict then Some (fitem key)\n                    else None\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let warningf  fmt = Printf.ksprintf Warning  fmt\n                let infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            /// returns a function that delays its execution\n            /// runs only once even if multiple calls happen before the delay\n            let delayed delay doF =\n                let cancellationTokenSourceO = ref None\n                fun parm -> \n                    let asy = async {\n                        do! Async.Sleep delay\n                        doF parm\n                    } \n                    !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n                    cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n                    Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let rtn                          = Ok\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | Ok    v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                       | Error e ->       e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                /// Taken from Nick Palladino's https://github.com/palladin/Eff\n                [< AutoOpen >]\n                module Eff =\n                    open System\n                \n                    type Effect = abstract UnPack     : Lambda         -> Effect \n                    and  Lambda = abstract Invoke<'X> : ('X -> Effect) -> ('X -> Effect)\n                \n                    type Eff<'U, 'A when 'U :> Effect> = Eff of (('A -> Effect) -> Effect) \n                        with  member this.Cont = match this with Eff cont -> cont\n                \n                    type Done<'A>(v : 'A) =\n                        member self.Value = v\n                        interface Effect with member self.UnPack(_ : Lambda) : Effect = self :> _ //new Done<'A>(v) :> _\n                \n                    let inline rtn  v = Eff (fun k -> k v)\n                    let bind  (f: 'a -> Eff<'U, 'b>) (effA: Eff<'U, 'a>) : Eff<'U, 'b> = \n                                        Eff (fun k -> \n                                                let (Eff effKa) = effA\n                                                effKa (fun v -> \n                                                    let (Eff effKb) = f v\n                                                    effKb k\n                                                )\n                                            )\n                \n                    module Eff =\n                //        [< Inline \"$effect.FsRoot_Library_Monads_Eff_Effect$UnPack({FsRoot_Library_Monads_Eff_Lambda$Invoke:function(k) { return function(p) { return $loop(k(p)) }; }})\" >]\n                //        let unpack loop (effect:Effect) = effect.UnPack { new Lambda with member self.Invoke<'X> (k' : 'X -> Effect) =  k' >> loop }\n                \n                        type LambdaT(loop) =\n                            interface Lambda with\n                                member __.Invoke<'X> (k : 'X -> Effect) : ('X -> Effect) = k >> loop \n                        let unpack loop (effect:Effect) = effect.UnPack (new LambdaT(loop))\n                        let done' (v :  'A) : Effect                           = new Done<'A>(v) :> _ \n                        let return' v  = Eff( fun _ -> done' v )\n                        let run<'U, 'A when 'U :> Effect> (eff: Eff<'U, 'A>) : 'A =\n                            match eff.Cont done' with\n                            | :? Done<'A> as done' -> done'.Value\n                            | v                    -> failwithf \"Unhandled effect %A\" v\n                        let runResult<'U, 'A when 'U :> Effect> (eff: Eff<'U, 'A>) = \n                            try\n                                match eff.Cont done' with\n                                | :? Done<'A> as done' -> Ok done'.Value\n                                //| v                    -> box v |> unbox<NoOp<_>> |> fun noop -> noop.K () |> loop\n                                | v                    -> Error <| errorMsgf \"Unhandled effect %A expecting\" v //typedefof<'A>\n                            with e -> \n                                Error <| ResultMessage.ExceptMsg(e.Message, e.StackTrace)\n                \n                \n                    let inline map   f  m  = bind (f >> rtn) m\n                    let inline apply fR vR = fR |> bind (fun f -> map f vR)\n                    \n                    [< AutoOpen >]\n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)\n                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)\n                    \n                    type EffBuilder() = \n                        member self.Zero      (                 ) = rtn ()\n                        member self.Return    (v   :         'A ) = rtn v\n                        member self.ReturnFrom(eff : Eff<'U, 'A>) = eff\n                        member self.Bind      (eff, f           ) = bind f eff\n                        member self.Combine (first : Eff<'U, unit>, second : Eff<'U, 'B>) : Eff<'U, 'B> =  self.Bind(first, fun () -> second)\n                        member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)\n                    //    member inline __.Delay       f                  = f\n                        member __.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                        member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                        member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                    let body' = fun () -> body disposable\n                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    fun () -> this.Delay(fun () -> body enum.Current)))\n                    \n                    \n                    let eff = new EffBuilder()\n                    \n                    module Reader = \n                        type Reader<'E> = inherit Effect\n                        type Ask<'E>(k : 'E -> Effect) =\n                            member self.K = k\n                            interface Reader<'E> with\n                                member self.UnPack(lambda : Lambda) : Effect = new Ask<'E>(lambda.Invoke<'E> k) :> _\n                    \n                        let ask<'U, 'E when 'U :> Reader<'E>>() : Eff<'U, 'E> = Eff (fun k -> new Ask<'E>(k) :> _)\n                    \n                        let rec readerHandler<'U, 'E, 'A when 'U :> Reader<'E>> (env:'E) (eff: Eff<'U, 'A>) : Eff<'U, 'A> = \n                            let rec loop : Effect -> Effect = function\n                                | :? Ask< 'E> as ask   -> ask.K env          |>            loop \n                                | effect               -> effect             |> Eff.unpack loop \n                            Eff (fun doneK             -> eff.Cont Eff.done' |>            loop )\n                    \n                        type EffReader<'a> = inherit Reader<'a>\n                    \n                        let readerFun f = ask() |> map f \n                    \n                        \n                    module Rsl = \n                        type Rsl<'M> = inherit Effect\n                    \n                        type Fail<    'M>(v : 'M, k : unit -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Rsl<'M> with member self.UnPack(lambda : Lambda) : Effect = new Fail<    'M>(v, lambda.Invoke<unit> k) :> _\n                    \n                    \n                        let fail<'U, 'M when 'U :> Rsl<'M>> (s:'M) : Eff<'U, unit> = Eff (fun k -> new Fail<    'M>(s, k) :> _)\n                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {\n                            match res with\n                            | Ok    v   -> return v\n                            | Error msg -> let! m = fail msg\n                                           return box () |> unbox\n                        }\n                    \n                        \n                        let rec RslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = \n                            let rec loop (doneK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function\n                                | :? Done<    'A> as done' -> doneK (Ok    done'.Value)\n                                | :? Fail<    'M> as fail  -> doneK (Error fail .Value)\n                                | effect                   -> effect             |> Eff.unpack (loop doneK)\n                            Eff (fun doneK                 -> eff.Cont Eff.done' |>             loop doneK)\n                    \n                        let inline absorbR     vvEf             = vvEf  |> bind ofResult\n                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR\n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofAsync            a  = FAM(fun (s, r) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                    let inline ofFusionM     (FM fm) = FAM(fun (s, r) -> async.Return (fm (s, r)) )\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type ResultM<'v, 'm> = ResultM of Option<'v> * ResultMessage<'m>\n                \n                let inline OkM              v    = ResultM (Some v, NoMsg)\n                let inline OkMWithMsg       v m  = ResultM(Some v, m)\n                //let inline OkMWithMsgs      v ms = ms |> ResultMessage.reduceMsgs |> OkMWithMsg v\n                \n                let inline ErrorM             m  = ResultM (None  , m    )\n                //let inline ErrorMWithMsgs     ms = ms |> ResultMessage.reduceMsgs |> ErrorM\n                let (|OkM|ErrorM|)             r = match r with\n                                                    | ResultM(Some v, m) -> OkM   (v, m)\n                                                    | ResultM(None  , e) -> ErrorM e\n                module ResultM =\n                \n                    type CheckError<'T> = CheckErrorF of ('T -> bool)\n                    let checkError   () = CheckErrorF (fun _ -> true )\n                    let checkErrorW  () = CheckErrorF (fun _ -> false)\n                \n                    let inline rtn                 v = OkM v\n                    let inline rtnM                m = OkMWithMsg () m\n                    let inline rtnr               vR = vR  |> Result.map OkM          |> Result.defaultWith       ErrorM\n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let inline toResult            r = match r with\n                                                       | ResultM(Some v, _) -> Ok     v\n                                                       | ResultM(None  , e) -> Error  e\n                    let inline toResultD           r = match r with\n                                                       | ResultM(Some v, m) -> Ok    (v, m)\n                                                       | ResultM(None  , e) -> Error  e\n                    let toOption                   r = r   |> function ResultM (v,_) -> v\n                    let defaultWith              f r = r   |> toResult |> Result.defaultWith   f\n                    let defaultValue             d r = r   |> toResult |> Result.defaultValue  d\n                    let map         f  (ResultM (v, m)) = ResultM (v |> Option.map f, m)\n                    let mapMessage  fM (ResultM (v, m)) = ResultM (v, fM m)\n                    let bind                  f    r = match r with\n                                                       | ResultM(Some v, m) -> f v |> mapMessage (ResultMessage.addMsg m)\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | ResultM(Some v, m) -> try f v |> mapMessage (ResultMessage.addMsg m)\n                                                                               with  e -> ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    let bindM                 f    m = rtnM m |> bindP f\n                \n                    let check (CheckErrorF k) vR = vR |> function ResultM(Some _, m) when ResultMessage.isFatalF k m -> ErrorM m |_-> vR\n                \n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m\n                    let iter                  fM f r = r   |> mapP f |> function ResultM(Some (), m) | ResultM(None, m) -> fM m  : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map OkM          |> Option.defaultWith (f >> ErrorM)\n                    let ofResult                  vR = vR  |> rtnr\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> OkM None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let addMsg                  m  r = r |> mapMessage (ResultMessage.addMsg m)\n                    let failIfFatalMsgF         f  r = r |> function OkM (v, m) when ResultMessage.isFatalF f m -> ErrorM m |_-> r\n                    let failIfFatalMsg             r = r |> function OkM (v, m) when ResultMessage.isFatal    m -> ErrorM m |_-> r\n                    let failIfFatalMsgW            r = r |> function OkM (v, m) when ResultMessage.isFatalW   m -> ErrorM m |_-> r\n                    let (>>=)                    r f = bind f r\n                    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline __.Return          x       = rtn  x\n                        member inline __.ReturnFrom      x       =     (x:Result<_,_>)\n                        member inline __.ReturnFrom      x       = rtnM x\n                        member        __.Bind           (w , r ) = bindP  r w\n                        member        __.Bind           (w , r ) = bindM  r w\n                        member inline __.Zero           ()       = rtn ()\n                        member inline __.Delay           f       = f\n                        member inline __.Combine        (a, b)   = a |> bind b\n                        member inline __.Run             f       = OkM () |> bindP f\n                        member __.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member __.TryFinally(body, compensation) = try body() finally   compensation()\n                        member __.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member __.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                \n                [< AutoOpen >]\n                module ResultMAutoOpen =\n                    open ResultM\n                    \n                    let resultM = Builder()\n                    \n                \n                \n                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResult =\n                    let mapError fE v  = v |> Async.map (Result.mapError fE)\n                    let freeMessage v  = v |> Async.map  Result.freeMessage\n                \n                    let rtn        v   = async.Return(Ok v  )\n                    let rtnR       vR  = async.Return    vR\n                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n                    let bind  fRA  vRA = async { \n                        let! vR       = vRA\n                        return! match   vR with\n                                | Ok    v -> fRA v\n                                | Error m -> async { return Error m }\n                    }\n                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | Ok    v -> return! fRA   v\n                            | Error m -> return  Error m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n                    }\n                    let inline map  f m = bind  (f >> rtn) m            \n                    let inline mapP f m = bindP (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map (Result.bindP   id)\n                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n                \n                type AsyncResultBuilder() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                            = fRA\n                    member __.Run              fRA                            = fRA ()\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                    th.While(enum.MoveNext,\n                                                                                      th.Delay(fun () -> fRA enum.Current)))\n                let asyncResult = AsyncResultBuilder()\n                \n                type AsyncResultBuilderP() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                                          = fRA\n                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                              th.While(enum.MoveNext,\n                                                                                                th.Delay(fun () -> fRA enum.Current)))\n                let asyncResultP = AsyncResultBuilderP()\n                \n                [<AutoOpen>]\n                module Extensions =      \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultBuilder with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                \n                    type AsyncResultBuilderP with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n                \n                \n                \n                type AsyncResultM<'v, 'm> = Async<ResultM<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResultM =\n                    let mapError fE v  = v |> Async.map (ResultM.mapMessage fE)\n                    let freeMessage v  = v |> Async.map  ResultM.freeMessage\n                \n                    let rtn         v   = async.Return(OkM v  )\n                    let rtnr        vR  = async.Return(ResultM.rtnr vR)\n                    let rtnR        vR  = async.Return    vR\n                    let rtnM        vM  = async.Return(ResultM.rtnM vM)\n                    let rtnrA       vrA = vrA |> Async.map    ResultM.ofResult\n                    let iterS  fE f vRA = Async.iterS (ResultM.iter fE f) vRA\n                    let iterA  fE f vRA = Async.iterA (ResultM.iter fE f) vRA\n                    let iterpS    f vRA = vRA |> iterS (ResultMessage.summarized >> print) f\n                    let iterpA    f vRA = vRA |> iterA (ResultMessage.summarized >> print) f\n                    let bind  (fRA:'a -> Async<ResultM<'b,'c>>)  (vRA: Async<ResultM<'a,'c>>) : Async<ResultM<'b,'c>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | OkM   (v, m) -> return! fRA   v |> Async.map (ResultM.addMsg m)\n                            | ErrorM    m  -> return  ErrorM m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                    }\n                    let inline bindr  f a  = rtnr   a |> bind f : AsyncResultM<_,_>\n                    let inline bindM  f a  = rtnM   a |> bind f : AsyncResultM<_,_>\n                    let inline bindrA f a  = rtnrA  a |> bind f : AsyncResultM<_,_>\n                    let inline bindR  f a  = rtnR   a |> bind f : AsyncResultM<_,_>\n                    let inline map    f m = bind  (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map (Result.bindP   id)\n                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n                    type AsyncResultMBuilder() =\n                        member __.ReturnFrom vRA        : Async<ResultM<'v  , 'm>> =           vRA\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnr      vR\n                        member __.ReturnFrom vR         : Async<ResultM<unit, 'm>> = rtnM      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnR      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnrA     vR\n                        member __.Return     v          : Async<ResultM<'v  , 'm>> = rtn       v  \n                        member __.Zero       ()         : Async<ResultM<unit, 'm>> = rtn       () \n                        member __.Bind      (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Bind       (w , r )                              = bindr   r w\n                        member __.Bind       (w , r )                              = bindM   r w\n                        member __.Bind       (w , r )                              = bindR   r w\n                        member __.Bind       (w , r )                              = bindrA  r w\n                        member __.Combine   (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Combine   (vR ,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA (vR  |> rtnR)\n                        member __.Delay            fRA                             = fRA\n                        member __.Run              fRA                             = fRA ()\n                        member __.TryWith   (fRA , hnd) : Async<ResultM<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                        member __.TryFinally(fRA , fn ) : Async<ResultM<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                        member __.Using(resource , fRA) : Async<ResultM<'a  , 'm>> = async.Using(resource,       fRA)\n                        member __.While   (guard , fRA) : Async<ResultM<unit, 'a>> = whileLoop guard fRA \n                        member th.For  (s: 'a seq, fRA) : Async<ResultM<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fRA enum.Current)))\n                \n                [<AutoOpen>]\n                module AsyncResultMAutoOpen =\n                    open AsyncResultM\n                \n                    let asyncResultM = AsyncResultMBuilder()\n                \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultMBuilder with\n                    member __.ReturnFrom (vA: Async<_>     ) : Async<ResultM<_,_>> =           Async.map OkM vA\n                    member __.Bind       (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                    member __.Combine    (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = this.Substring2(0, n)\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n            \n            module Array =\n            \n                /// Non-mutable element replace\n                /// produces a new array with the new element\n                let replace i item (array: _[]) = \n                    seq {\n                        if i > 0            then yield! array.[.. i - 1]\n                        yield item\n                        if i < array.Length then yield! array.[i + 1 ..]\n                    } |> Seq.toArray\n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n                \n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n            /// Adapted from here http://fssnip.net/7V5   Usage:\n            /// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n            ///         \n            /// abs  1 |> printfn \"%A\" // 1\n            /// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\n            type Hole = Hole with\n                [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n                static member inline Incomplete id : 'T = failwithf \"Incomplete hole '%s'\" id        \n                    \n            \n            /// Tree structure to implement a hierarchical user interface but using Eff Reader and Rsl monad\n            module TreeEff =\n            \n                type Node<'I, 'T, 'Eff when 'Eff :> Effect> = {\n                    id                : unit                   -> 'I\n                    getData           : unit                   -> 'T\n                    isExpandedEf      : unit                   -> Eff<'Eff, bool                     >\n                    canHaveChildrenEf : unit                   -> Eff<'Eff, bool                     >\n                    childrenEf        : unit                   -> Eff<'Eff, Node<'I, 'T, 'Eff> seq   >\n                    pathEf            : unit                   -> Eff<'Eff, 'I list                  >  // list of parents excluding itself\n                    parentOEf         : Node<'I, 'T, 'Eff> seq -> Eff<'Eff, Node<'I, 'T, 'Eff> option>\n                    newChildrenEf     : Node<'I, 'T, 'Eff> []  -> Eff<'Eff, Node<'I, 'T, 'Eff>       >  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n                }\n            \n                //let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n                //let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n            \n                let rec listNodes level (nodes: Node<_,_,_> seq) =\n                    nodes\n                    |> Seq.map(fun node -> \n                        node.isExpandedEf() \n                        >>= (fun exp -> if exp then node.childrenEf() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n                        |>> (fun nodes -> Seq.append [ node, level ] nodes)\n                    ) \n                    |> sequenceSeq\n                    |>> Seq.collect id\n            \n                let removeNode (node:Node<_,_,_>) nodes = eff { // better use version removeNode2\n                    let! path = node.pathEf()\n                    printfn \"path = %A\" path\n                    let rec chRemove (n:Node<_,_,_>) = eff {\n                        if                  n.id() = node.id() then printfn \"found it\" ; return  None\n                        elif List.contains (n.id())  path      then printfn \"deeper\" ; return! n.childrenEf()\n                                                                            |>> Seq.toArray\n                                                                            |>> Seq.map chRemove \n                                                                            >>= sequenceSeq \n                                                                            |>> Seq.choose id \n                                                                            |>> Seq.toArray\n                                                                            >>= n.newChildrenEf  \n                                                                            |>> Some\n                        else                                        printfn \"not\" ;return  Some n\n                    }\n                    return! nodes |> Seq.map chRemove |> sequenceSeq |>> Seq.choose id\n                }\n            \n                let removeNodes p nodes = eff {\n                    let rec folder pair (n:Node<_,_,_>) = eff {\n                        let! children, noparent = pair\n                        let! children2 = n.childrenEf() |>> Seq.toArray\n                        let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n                        if p n then return (        children, ch @ np)\n                               else let! xxx = n.newChildrenEf (ch |> Seq.rev |> Seq.toArray)\n                                    return ( xxx :: children,      np)\n                    }\n                    let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n                    return noparent @ res |> List.rev\n                }\n            \n                let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n                    seq [ for n in nodes do\n                            if p n then\n                                if after then yield n    ; yield node\n                                else          yield node ; yield n\n                            else              yield n\n                    ]\n                    \n                let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenEf\n            \n                let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n                    sibling.pathEf() >>= function\n                    | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n                    | parent :: path -> \n                    let rec mapAdd (n:Node<_,_,_>) =\n                        if                  n.id() = parent then     n.childrenEf() |>> Seq.toArray >>= addToParent after theSibling node n\n                        elif List.contains (n.id()) path    then     n.childrenEf() |>> Seq.toArray |>> Seq.map mapAdd >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenEf \n                        else                                     rtn n\n                    nodes |> Seq.map mapAdd |> sequenceSeq\n            \n                let tryFind p (nodes:Node<_,_,_> seq) = \n                    let rec folder resEf (node:Node<_,_,_>) =\n                        resEf >>= function\n                        | Some v -> rtn (Some v)\n                        | None   ->\n                        if p node then rtn <| Some node else \n                        node.childrenEf() >>= Seq.fold folder (rtn None)\n                    nodes                 |>  Seq.fold folder (rtn None)\n                    \n                let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n            \n                let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    nodes\n                    |>  removeNode node\n                    >>= addSibling after node sibling\n            \n                let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = eff {\n                    let!  nodeO = nodes |> tryFindId nodeId\n                    match nodeO with\n                    | None         -> return  nodes\n                    | Some node    ->\n                    let!  siblingO = nodes |> tryFindId siblingId\n                    match siblingO with\n                    | None         -> return  nodes\n                    | Some sibling -> return! moveToSibling after node sibling nodes\n                }\n            \n                let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = eff {\n                    let! path = parentN.pathEf()\n                    let rec mapAppend (n:Node<_,_,_>) =\n                        if   n.id() = parentN.id()       then \n                            if append                    then n.childrenEf() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenEf\n                            else                              n.childrenEf() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenEf\n                        elif List.contains (n.id()) path then n.childrenEf() |>> Seq.toArray |>>      Seq.map mapAppend   >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenEf\n                        else                                  rtn n\n                    return! nodes |> Seq.map mapAppend |> sequenceSeq\n                }\n            \n                let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    node.parentOEf nodes >>= function\n                    | None        -> rtn nodes\n                    | Some parent -> parent.childrenEf() |>> (Seq.toArray >> Seq.ofArray)\n                    |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n                    >>= Seq.fold      (fun newParentOEf n -> n.canHaveChildrenEf() >>= (fun can -> if can then rtn(Some n) else newParentOEf)) (rtn None)\n                    >>= function\n                    | None           -> rtn nodes\n                    | Some newParent ->\n                    nodes\n                    |>  removeNode node \n                    >>= addChild true node newParent\n            \n                let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.parentOEf nodes\n                    |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n                    >>= Option.defaultValue (rtn nodes)\n                    \n                let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.childrenEf()\n                    >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n                    >>= removeNode node\n                    \n                \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            module Var =\n                let mutable private counter = 1\n                let freshId () =\n                    counter <- counter + 1\n                    \"varuid\" + string counter\n                        \n                let lensView get update view0 (var: Var<_>) =\n                    let id   = freshId()\n                    let view = View.Map2 (fun v _ -> get v) var.View view0\n                    { new Var<'V>() with\n                        member this.Get        () = get (var.Get())\n                        member this.Set         v = var.Update(fun t -> update t v)\n                        member this.SetFinal    v = this.Set(v)\n                        member this.Update      f = var.Update(fun t -> update t (f (get t)))\n                        member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n                        member this.View          = view\n                        member this.Id            = id\n                    }\n            \n            module ListModel =\n                let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.FindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.TryFindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let lensDef def k (m:ListModel<_,_>) =\n                    let get = Option.defaultValue def\n                    lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n            \n                let currentLensUpd def curr upd (model:ListModel<_,_>) = \n                    curr \n                    |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                                    (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                                    model.View\n                let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n                    let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n                    Var.Make view upd\n                let currentLens def curr (model:ListModel<_,_>) = \n                    model \n                    |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n                \n            \n            /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n            /// onChange gets called when the editor changes but not when the var changes\n            let bindVarEditor setEvent getVal setVal onChange (var:Var<string>) =\n                let editorChanged = ref 0L\n                let varChanged    = ref 0L\n                setEvent(fun _ ->\n                    let v = getVal() \n                    if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange() \n                )\n                var.View |> View.Sink (fun _ ->\n                    if  !editorChanged > !varChanged then varChanged := !editorChanged\n                    elif getVal() <> var.Value then setVal var.Value\n                )\n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module LoadFiles =\n            \n                let createScript fn =\n                    let fileRef = JS.Document.CreateElement(\"script\")\n                    fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n                    fileRef.SetAttribute(\"src\" , fn                 )\n                    fileRef\n                \n                let createCss fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n                    fileRef.SetAttribute(\"type\", \"text/css\"       )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let createHtml fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"import\"         )\n                    fileRef.SetAttribute(\"type\", \"text/html\"      )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let LoadFile(file: string) =\n                    let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n                    match file with\n                    | EndsWith \".js\"   ()\n                    | EndsWith \".fsx\"  ()\n                    | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                            createScript file |> Some\n                    | EndsWith \".css\"  ()-> createCss    file |> Some\n                    | EndsWith \".html\" ()-> createHtml   file |> Some\n                    | _                  -> None\n                    |> Option.map         (fun ref -> \n                        Async.FromContinuations <| \n                            fun (cont, econt, _ccont) -> \n                                try \n                                    ref?onload <- cont\n                                    JS.Document.Head.AppendChild ref |> ignore\n                                with e -> econt e\n                    )\n                    |> Option.defaultWith (fun ()  -> async { return () })\n                \n                let LoadFilesAsync(files: string []) =\n                    async {\n                        if IsClient then\n                            for file in files do\n                                do! LoadFile file\n                    }\n                \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            [< JavaScript >]\n            module ResizeObserver =\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module Monaco =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri   = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f)\"  >] static member File(_f)       : Uri   = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8\n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                open WebSharper.Core.Resources\n            \n                type MonacoResources() =\n                    inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n            \n                [< Require(typeof<MonacoResources>) >]\n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (unit   -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        //do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             = \n                    async {\n                      do! loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                          )    \n                        ] []\n                    } |> Doc.Async\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n            module FsAutoComplete =\n                [<JavaScript ; AutoOpen >]\n                module CommTypes =\n                    type ResponseError =\n                        {\n                          Code: int\n                          Message: string\n                          //AdditionalData: 'T\n                        }\n                    type Location =\n                      {\n                        File: string\n                        Line: int\n                        Column: int\n                      }\n                    type CompletionResponse =\n                      {\n                        Name: string\n                        ReplacementText: string\n                        Glyph: string\n                        GlyphChar: string\n                      }\n                    //type ProjectResponse =\n                    //  {\n                    //    Project: ProjectFilePath\n                    //    Files: List<SourceFilePath>\n                    //    Output: string\n                    //    References: List<ProjectFilePath>\n                    //    Logs: Map<string, string>\n                    //  }\n                    type OverloadDescription =\n                      {\n                        Signature: string\n                        Comment  : string\n                        Footer   : string\n                      }\n                    type OverloadParameter =\n                      {\n                        Name : string\n                        CanonicalTypeTextForSorting : string\n                        Display : string\n                        Description : string\n                      }\n                    type Overload =\n                      {\n                        Tip : OverloadDescription list list\n                        TypeText : string\n                        Parameters : OverloadParameter list\n                        IsStaticArguments : bool\n                      }\n                    type Parameter = {\n                        Name : string\n                        Type : string\n                      }\n                    type SignatureData = {\n                        OutputType : string\n                        Parameters : Parameter list list\n                      }\n                    type MethodResponse =\n                      {\n                        Name : string\n                        CurrentParameter : int\n                        Overloads : Overload list\n                      }\n                    type SymbolUseRange =\n                      {\n                        FileName: string\n                        StartLine: int\n                        StartColumn: int\n                        EndLine: int\n                        EndColumn: int\n                        IsFromDefinition: bool\n                        IsFromAttribute : bool\n                        IsFromComputationExpression : bool\n                        IsFromDispatchSlotImplementation : bool\n                        IsFromPattern : bool\n                        IsFromType : bool\n                      }\n                    type SymbolUseResponse =\n                      {\n                        Name: string\n                        Uses: SymbolUseRange list\n                      }\n                    type HelpTextResponse =\n                      {\n                        Name: string\n                        Overloads: OverloadDescription list list\n                      }\n                    type CompilerLocationResponse =\n                      {\n                        Fsc: string\n                        Fsi: string\n                        MSBuild: string\n                      }\n                    type FSharpErrorInfo =\n                      {\n                        FileName    : string\n                        StartLine   : int\n                        EndLine     : int\n                        StartColumn : int\n                        EndColumn   : int\n                        Severity    : string\n                        Message     : string\n                        Subcategory : string\n                      }\n                    type ErrorResponse =\n                      {\n                        File: string\n                        Errors: FSharpErrorInfo []\n                      }\n                    type Colorization =\n                      {\n                    //    Range: Range\n                        Kind: string\n                      }\n                    type Declaration =\n                      {\n                        UniqueName: string\n                        Name: string\n                        Glyph: string\n                        GlyphChar: string\n                        IsTopLevel: bool\n                    //  Range     : Utils.Range\n                    //    BodyRange : Utils.Range\n                        File : string\n                        EnclosingEntity: string\n                        IsAbstract: bool\n                      }\n                    type DeclarationResponse = {\n                        Declaration : Declaration;\n                        Nested : Declaration []\n                    }\n                    type OpenNamespace = {\n                      Namespace : string\n                      Name : string\n                      Type : string\n                      Line : int\n                      Column : int\n                      MultipleNames : bool\n                    }\n                    type QualifySymbol = {\n                      Name : string\n                      Qualifier : string\n                    }\n                    type ResolveNamespaceResponse = {\n                      Opens : OpenNamespace []\n                      Qualifies: QualifySymbol []\n                      Word : string\n                    }\n                    type UnionCaseResponse = {\n                      Text : string\n                    //  Position : Pos\n                    }\n                    type Kind = \n                    | KInfo             of string\n                    | KError            of ResponseError\n                    | KHelpText         of HelpTextResponse\n                    | KCompletion       of CompletionResponse  []\n                    | KSymbolUse        of SymbolUseResponse\n                    | KHelp             of string\n                    | KMethod           of MethodResponse\n                    | KErrors           of ErrorResponse\n                    | KColorizations    of Colorization list\n                    | KFindDecl         of Location\n                    | KDeclarations     of DeclarationResponse []\n                    | KToolTip          of OverloadDescription [][]\n                    | KTypeSig          of string\n                    | KSignatureData    of SignatureData\n                    | KCompilerLocation of CompilerLocationResponse\n                    | KNamespaces       of ResolveNamespaceResponse\n                    | KUnionCase        of UnionCaseResponse\n                    | KMultiple         of Kind                []\n                    \n                //#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n                //#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n                //#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n                \n                open System.Net\n                open System.Text\n                open System.IO\n                open FSharp.Data\n                open FSharp.Data.JsonExtensions\n                open Newtonsoft.Json\n                \n                open Utils\n                \n                [<JavaScript ; AutoOpen >]\n                module MsgTypes =\n                \n                    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n                    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n                    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n                    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n                    type ProjectRequest       = { FileName  : string                                                                                                               }\n                    type LintRequest          = { FileName  : string                                                                                                               }\n                    type HelptextRequest      = { Symbol    : string                                                                                                               }\n                    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n                \n                    type FARequest =\n                        | FarParse         of ParseRequest         \n                        | FarDeclarations  of DeclarationsRequest  \n                        | FarCompletion    of CompletionRequest    \n                        | FarPosition      of PositionRequest      \n                        | FarProject       of ProjectRequest       \n                        | FarLint          of LintRequest          \n                        | FarHelptext      of HelptextRequest      \n                        | FarWorkspacePeek of WorkspacePeekRequest    \n                \n                let toJson =\n                    function\n                    | FarParse         data -> JsonConvert.SerializeObject data \n                    | FarDeclarations  data -> JsonConvert.SerializeObject data \n                    | FarCompletion    data -> JsonConvert.SerializeObject data \n                    | FarPosition      data -> JsonConvert.SerializeObject data \n                    | FarProject       data -> JsonConvert.SerializeObject data \n                    | FarLint          data -> JsonConvert.SerializeObject data \n                    | FarHelptext      data -> JsonConvert.SerializeObject data \n                    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n                \n                let fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\n                let jsonData2Obj item = item?Data.ToString() |> fromJson\n                \n                let HttpRequestCall (url:string) (data:string) =\n                    async {\n                        //printfn \"RpcCall %s\" (extract 100 data)\n                        let req = WebRequest.Create(url) :?> HttpWebRequest \n                        req.Timeout         <- 300_000\n                        req.ProtocolVersion <- HttpVersion.Version10\n                        req.Method          <- \"POST\"\n                        req.ContentType     <- \"application/json\"\n                        let postBytes = Encoding.ASCII.GetBytes(data)\n                        //printfn \"<---\\n%s\\n\" data\n                        req.ContentLength <- int64 postBytes.Length\n                        let reqStream = req.GetRequestStream() \n                        reqStream.Write(postBytes, 0, postBytes.Length);\n                        reqStream.Close()\n                        use resp   = req.GetResponse() \n                        use stream = resp.GetResponseStream() \n                        use reader = new StreamReader(stream)\n                        let msg    = reader.ReadToEnd()\n                        //print msg\n                        //printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n                        let jsonV  = JsonValue.Parse msg\n                        return       jsonV\n                    }\n                \n                let KindError msg = KError { Code = 0 ; Message = msg }\n                \n                let json2Kind (v:JsonValue) = \n                    let item =JsonValue.Parse <| v.AsString()\n                    match item?Kind.AsString() with\n                    | \"info\"             -> jsonData2Obj item |> KInfo\n                    | \"error\"            -> jsonData2Obj item |> KError\n                    | \"errors\"           -> jsonData2Obj item |> KErrors\n                    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n                    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n                    | \"completion\"       -> jsonData2Obj item |> KCompletion\n                    | \"signature\"        -> jsonData2Obj item |> KTypeSig\n                    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n                    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n                    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n                    | \"helptext\"         -> jsonData2Obj item |> KHelpText\n                    | \"declarations\"     -> jsonData2Obj item |> KDeclarations\n                    | \"symboluse\"        -> jsonData2Obj item |> KSymbolUse\n                    | _                  -> KindError <| v.ToString()\n                \n                let UrlAddress = \"http://localhost:9001/\"\n                \n                [< Rpc >]\n                let FSAutocompleteCall0 cmd (req: FARequest) : Async<Result<Kind [],ResultMessage<Kind[]>>> = asyncResult {\n                        let  data          = req |> toJson\n                        let! jsonV         = HttpRequestCall (UrlAddress + cmd) data\n                        return               jsonV.AsArray() |> Array.map json2Kind\n                    } \n                \n                [<JavaScript ; AutoOpen>]\n                module Calls =\n                    let FSAutocompleteCall cmd f req = asyncResult {\n                            let! several       = FSAutocompleteCall0 cmd req\n                            let  goods, others = several |> Array.partition (f >> Option.isSome)\n                            let! good          = goods   |> Seq.choose f |> Seq.tryHead |> Result.ofOption (fun () -> others |> Message)\n                            return               good, others\n                        } \n                    \n                    let parseCode        file code asy ver   = FSAutocompleteCall \"parse\"               (function KErrors        v -> Some v |_-> None)\n                                                                     <| FarParse       { FileName        = file\n                                                                                         IsAsync         = asy   \n                                                                                         Lines           = code           \n                                                                                         Version         = ver\n                                                                                       }\n                    let toolTip          file lin col filter = FSAutocompleteCall \"tooltip\"             (function KToolTip       v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signature        file lin col filter = FSAutocompleteCall \"signature\"           (function KTypeSig v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signatureData    file lin col filter = FSAutocompleteCall \"signatureData\"       (function KSignatureData v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let completion  tx kw file ln col filter = FSAutocompleteCall \"completion\"          (function KCompletion    v -> Some v |_-> None)\n                                                                      <| FarCompletion { FileName        = file\n                                                                                         Line            = ln         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                         SourceLine      = tx\n                                                                                         IncludeKeywords = kw\n                                                                                        }\n                    \n                    let findTypeDecl     file lin col filter = FSAutocompleteCall \"findtypedeclaration\" (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let findDeclaration  file lin col filter = FSAutocompleteCall \"finddeclaration\"     (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let declarations    file code ver        = FSAutocompleteCall \"declarations\"       (function KDeclarations v -> Some v |_-> None)\n                                                                      <| FarDeclarations{ FileName       = file\n                                                                                          Lines          = code         \n                                                                                          Version        = ver\n                                                                                        }\n                    let helpText               symbol        = FSAutocompleteCall \"helptext\"            (function KHelpText     v -> Some v |_-> None)\n                                                                      <| FarHelptext    { Symbol         = symbol\n                                                                                        }\n                    let symbolUse       file lin col filter  = FSAutocompleteCall \"symboluse\"           (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let symbolUseProject file lin col filter = FSAutocompleteCall \"symboluseproject\"    (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    \n                    \n    \n    //#cd @\"..\\projects\\RuleEditor\\src\"\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    \n    \n    //#define WEBSHARPER\n    [< JavaScript >]\n    module RuleEditor =\n        //#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n         \n        [< JavaScript >]\n        module CalculationModel =\n            open System\n            \n            type DimType =\n                | DtDataType\n                | DtTime\n                | DtVersion\n                | DtTCalc\n                | DtCalc\n                | DtMeasure\n                | DtOther\n            \n            type CubeType =\n                | CtOther\n                | CtCalc\n                | CtFreeze\n            \n            type AttType =\n                | AtString\n                | AtNumber\n            \n            type ElmType =\n                | EtString\n                | EtNumber\n            \n            type ModId = ModId of Guid with member x.Id = match x with ModId id -> id\n            type AttId = AttId of Guid with member x.Id = match x with AttId id -> id\n            type ElmId = ElmId of Guid with member x.Id = match x with ElmId id -> id\n            type CubId = CubId of Guid with member x.Id = match x with CubId id -> id\n            type DimId = DimId of Guid with member x.Id = match x with DimId id -> id\n            type CalId = CalId of Guid with member x.Id = match x with CalId id -> id\n            type TotId = TotId of Guid with member x.Id = match x with TotId id -> id\n            type ForId = ForId of Guid with member x.Id = match x with ForId id -> id\n            type RulId = RulId of Guid with member x.Id = match x with RulId id -> id\n            \n            type Attribute = {\n                attId          : AttId\n                attName        : string\n                attType        : AttType\n                attTableNum    : int\n            }\n            \n            type Element = {\n                elmId          : ElmId\n                elmDim         : DimId\n                elmType        : ElmType\n                elmName        : string\n                elmDescription : string\n                elmAttributes  : Map<AttId, string> \n                elmParents     : ElmId     []\n            } \n            \n            type Dimension = {\n                dimId               : DimId\n                dimName             : string\n                dimPrefix           : string\n                dimOrder            : string\n                dimExclude          : bool\n                dimFreeze           : bool\n                dimType             : DimType\n                defaultElm          : ElmId     option\n                mutable dimElements : Element   []\n                dimAttributes       : Attribute []\n                isCalcDim           : bool\n            }\n            \n            type UnaryOp = \n                | UoMinus\n                | UoPlus\n                \n            type Operator = \n                | OpAdd      \n                | OpSubtract \n                | OpMultiply \n                | OpDivide   \n                | OpEQ    \n                | OpNE\n                | OpGT       \n                | OpGE       \n                | OpLT       \n                | OpLE       \n                | OpAnd      \n                | OpOr           \n            \n            type Function = Function of string\n            \n            type ElmReference =\n                | ElemFixed   of DimId * ElmId\n                | ElemDynamic of DimId * ExpressionText\n                    \n            and  ExpressionText =\n                | ExtNA\n                | ExtStet\n                | ExtSlice      of Slice\n                | ExtString     of string\n                | ExtDimElement of DimId\n                | ExtDimName    of DimId\n                | ExtFunction   of Function         * ExpressionAny []\n                | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n            \n            and  ExpressionNumber =\n                | ExnNA\n                | ExnStet\n                | ExnSlice      of Slice\n                | ExnNumber     of float\n                | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n                | ExnUnaryN     of UnaryOp          * ExpressionNumber\n                | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n                | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n                | ExnFunction   of Function         * ExpressionAny []\n                | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n                | ExnIsNA       of ExpressionNumber\n                | ExnIsNAt      of ExpressionText\n                | ExnIsNAa      of ExpressionAny\n                \n            and ExpressionAny =    \n                | ExiNA\n                | ExiStet\n                | ExiSlice      of Slice\n                | ExNumeric     of ExpressionNumber\n                | ExText        of ExpressionText\n                | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n                \n            and  Slice = {\n                sliDims     : Map<DimId, ElmReference>   \n                calculation : CalId option\n                cube        : CubId option\n            } \n            \n            type ForType = \n                | ForBase\n                | ForConsolidated\n                | ForAll\n            \n            type Formula = {\n                forId          : ForId\n                forDestDecl    : Map<DimId, string>\n                forDestination : ElmReference list\n                forDescription : string\n                forText        : string\n                forExpression  : ExpressionAny\n                forType        : ForType\n                forOrder       : string\n            }\n            \n            type Calculation = {\n                calId          : CalId\n                calName        : string\n                calDescription : string\n                calOrder       : string\n                format         : string\n                isText         : bool\n                isInput        : bool\n                isBalance      : bool\n                calDims        : Set<DimId>\n                calFormulas    : Formula []\n                cubIdO         : CubId   option\n                properties     : Map<string, string>\n            }\n            \n            type NodeId =\n                | Calc of CalId\n                | Tot  of TotId\n            \n            type Total = {\n                totId          : TotId\n                totName        : string\n                totOrder       : string\n                totFormat      : string\n                children       : (float * NodeId) []\n            }\n            \n            type RuleKey = \n                | RuleKey     of RulId\n                | CalcRuleKey of CalId\n                | FormulaKey  of ForId\n                | ForTextKey  of ForId\n                | ActualRuleKey \n                | InputRuleKey\n                | ConsolidatedRuleKey\n            \n            type Cube = {\n                cubId          : CubId\n                cubName        : string\n                cubRules       : Map<RuleKey, Rule option>\n                cubRuleXmls    : Map<RuleKey, string>\n                cubDims        : DimId []\n                measureDim     : DimId option\n                cubType        : CubeType\n            }\n            \n            and  Rule = {\n                rulId          : RulId\n                rulSourceId    : IComparable\n                rulDescription : string\n                rulDestination : ElmReference list\n                rulExpression  : ExpressionAny\n                rulType        : ForType\n                rulOrder       : string\n                rulXml         : string\n            }\n            \n            type RuleMsg =\n            | GetInitModelStats\n            | GetRulesForCube of CubId\n            \n            type ReplyMsg =\n            | ReplyInformation of string\n            | ReplyRules       of (RuleKey * string) []\n            \n            [<NoComparison ; NoEquality>]\n            type Model = {\n                modId           : ModId\n                server          : string\n                actualElem      : string\n                modDims         : Dimension   []\n                modCubes        : Cube        []\n                modCalculations : Calculation []\n            } \n            \n            let Xmodel = \n              {\n                modId           = ModId <| Guid.NewGuid()\n                server          = @\"local\\Budget\"\n                actualElem      = \"Actual\"\n                modDims         = [||]\n                modCubes        = [||]\n                modCalculations = [||]\n              }\n                \n            let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n            let calcSlice calc : Slice = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = Some calc.calId\n                         cube          = None\n                     }\n                \n            type HelperTypeN = HelperTypeN with\n                static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n                static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n                static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n                static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n                static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n                static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n                \n            let [< Inline >] inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n            \n            type HelperTypeT = HelperTypeT with\n                static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n                static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n                static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n                static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n                static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n            \n            let [< Inline >] inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n            \n            type HelperTypeA = HelperTypeA with\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n            \n            let [< Inline >] inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n        \n            type Message =\n                | DimensionNotFound      of DimId\n                | DimensionHasNoElements of string\n                | ElementNotFound        of string * ElmId\n                | CubeNotFound           of CubId\n                | CubeHasNoMeasureDim    of string\n                | CalculationNotFound    of CalId\n                | CalculationHasNoCube   of string\n        \n            let ofOptF f = Result.ofOption (fun () -> Message <| f())\n            let ofOptS s = Result.ofOption (fun () -> Message <| s  )\n        \n            module internal Model0 =\n                let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n                let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n                let getDimR       dId mdl = getDimO  dId mdl |> Result.ofOption (fun () -> DimensionNotFound   dId)\n        \n            module Element  =\n                let newElement name = \n                  {\n                    elmId          = ElmId <| Guid.NewGuid()\n                    elmDim         = DimId <| Guid.NewGuid()\n                    elmType        = EtString\n                    elmName        = name\n                    elmDescription = name\n                    elmAttributes  = Map.empty\n                    elmParents     = [||]\n                  }\n        \n            module ElmReference =\n                let dimId elr =\n                    match elr with\n                    | ElemFixed  (id, _)\n                    | ElemDynamic(id, _) -> id\n        \n            module Slice =\n                let newSlice ds = {\n                         sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                         calculation   = None\n                         cube          = None\n                }\n                let forAll = {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = None\n                }\n                let addRef      elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n                let containsDim did slc = slc.sliDims |> Map.containsKey did\n           \n            module Dimension =\n                let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n                let getElementR      eId dim = getElementO eId dim |> Result.ofOption (fun () -> ElementNotFound(dim.dimName, eId))\n                let newDimension id name isCalcDim =\n                      {\n                        dimId          = id \n                        dimName        = name\n                        dimPrefix      = \"\"\n                        dimOrder       = \"\"\n                        dimExclude     = false\n                        dimFreeze      = false\n                        dimType        = DtOther\n                        defaultElm     = None\n                        dimElements    = [|  |]\n                        dimAttributes  = [|  |]      \n                        isCalcDim      = isCalcDim\n                      }\n                let newDimensionNonCalc id name  = newDimension id name false\n                let newDimensionCalc    id name  = newDimension id name true \n                let New                    name  = newDimension (DimId <| Guid.NewGuid()) name false\n                let [< Inline >] inline getElmReference it dim =\n                    match toExpT it with \n                    | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                                      let elm =\n                                         dim.dimElements                                 \n                                         |> Seq.tryFind (fun e -> e.elmName = s2)\n                                         |> Option.defaultWith (fun () -> \n                                             let newE = Element.newElement s2\n                                             dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                             newE\n                                         )\n                                      ElemFixed  (dim.dimId, elm.elmId) \n                    | exp          -> ElemDynamic(dim.dimId, exp      )  \n        //        member inline this.Item (it) = getElmReference it this\n                //member inline this.__     it     = this.Item it\n                //member inline this.M      it     = this.Item it\n                //member inline this.E      it     = this.Item it\n                //member inline this.I      it     = this.Item it\n                let prefix  pr   dim  = { dim with dimPrefix = pr   }\n                let dType   dt   dim  = { dim with dimType   = dt   }\n                let setName name dim  = { dim with dimName   = name }\n                let filter     dtypes : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\n                let sort             (ds:Dimension seq)                  = ds |> Seq.sortBy (fun d -> d.dimOrder)\n                let filterSort dtypes : (Dimension seq -> Dimension seq) = filter dtypes >> sort\n        \n            type Dimension with\n                [< Inline >] \n                member inline this.Item (it) = Dimension.getElmReference it this\n        \n        \n            module Cube =\n                let slice cub : Slice  = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = Some cub.cubId\n                     }\n                let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n                let isCalcCube                cub = cub.cubType = CtCalc    \n                let newCubeId id name dims mDimO cType = \n                        {\n                          cubId       = id\n                          cubName     = name\n                          cubDims     = dims\n                          cubRules    = Map.empty\n                          cubRuleXmls = Map.empty\n                          measureDim  = mDimO\n                          cubType     = cType\n                        }\n                let newCube     name            = newCubeId <| CubId (Guid.NewGuid()) <| name\n                let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n                let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n                let New()                       = newCube \"\" [||] None CtOther\n                let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n                let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n                //member inline this.Calc ()    = { this with cubType = CtCalc } \n                let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n                let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n                let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n                let measureDimR     model cub   = cub.measureDim         |> Result.ofOption (fun () -> CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n                let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n                \n            module Calculation =\n                let slice calc = calcSlice calc\n                let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n                let newInput id (name: string) dims  =\n                     {\n                        calId          = id\n                        calName        = name.Replace(\"_\", \" \").Trim()\n                        calDescription = \"\"\n                        calOrder       = \"\"\n                        format         = \"#,##0.00\"\n                        isText         = false\n                        isInput        = true\n                        isBalance      = false\n                        calDims        = dims |> Set \n                        calFormulas    = [||]\n                        cubIdO         = None\n                        properties     = Map.empty\n                     }\n                let newCalc id name dims      = { newInput id name dims     with isInput     = false  }\n                let New        ()             =   newInput (CalId <| Guid.NewGuid()) \"\"   []\n                let setName    name      calc = { calc                   with calName     = name   }\n                let setIsText  istext    calc = { calc                   with isText      = istext }\n                let setOrder   order     calc = { calc                   with calOrder    = order  }\n                let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n                let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n                let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n                let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n                let [< Inline >] getElemRefO(model: Model) calc =\n                    calc.cubIdO \n                    |> Option.bind (swap Model0.getCubeO model)\n                    |> Option.bind (fun cub ->  cub.measureDim) \n                    |> Option.bind (swap Model0.getDimO  model)\n                    |> Option.map  (Dimension.getElmReference calc.calName)\n                let cubeR           c = c.cubIdO        |> ofOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n                let [< Inline >] getElemRefR   m c = getElemRefO m c |> ofOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n                let sort             (cs:Calculation seq)                  = cs |> Seq.sortBy (fun c -> c.calOrder)\n        \n            module Total =\n                let newTotal name  = {\n                    totId          = TotId  <| System.Guid.NewGuid()\n                    totName        = name\n                    totOrder       = \"\"\n                    totFormat      = \"\"\n                    children       = [||]\n                }\n                let New() = newTotal \"\"\n                \n            module Model =\n                let mergeBy f a b = Array.append (Seq.toArray a) (Array.filter (fun e -> a |> Seq.map f |> Seq.contains (f e) |> not ) b)\n                let addCalcs     cs   mdl = { mdl with modCalculations = mergeBy (fun c -> c.calId) cs mdl.modCalculations }\n                let addDims      ds   mdl = { mdl with modDims         = mergeBy (fun c -> c.dimId) ds mdl.modDims         }\n                let addCubes     cs   mdl = { mdl with modCubes        = mergeBy (fun c -> c.cubId) cs mdl.modCubes        }\n                let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n                let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n                let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n                let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n                let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n                let getDimO               = Model0.getDimO\n                let getDimR               = Model0.getDimR\n                let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n                let getCubeO              = Model0.getCubeO\n                let getCalcR      cId mdl = getCalcO cId mdl |> Result.ofOption (fun () -> CalculationNotFound cId)\n                let getCubeR      cId mdl = getCubeO cId mdl |> Result.ofOption (fun () -> CubeNotFound        cId)\n                let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n                let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n                let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n                let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n                let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n                let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n                let timeDimO          mdl = pickDimO  DtTime     mdl\n                let versionDimO       mdl = pickDimO  DtVersion  mdl\n                let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n                let getCalcCube dims  mdl = \n                    mdl.modCubes \n                    |> Seq.filter  Cube.isCalcCube\n                    |> Seq.tryFind (fun cub -> \n                        cub.cubDims \n                        |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                        |> Set = dims )\n                let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n                let withDimsO mdl cube f =\n                    let (<*>)   = Option.apply\n                    let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n                    Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n                let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n                let dimCombinations model =\n                    model.modCalculations\n                    |>  Seq.map (fun c -> c.calDims)\n                    |>  Seq.distinct \n                let cubePrefix    = \"Z\"\n                let measurePrefix = \"M\"\n                let orderedDims dimIds model =\n                        model.modDims \n                        |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n                let autoName dimIds model =\n                    let nameBase =\n                        model\n                        |> orderedDims dimIds\n                        |> Seq.map (fun d -> d.dimPrefix)\n                        |>  String.concat \"\"\n                    let similar =\n                        model.modCubes\n                        |> Seq.choose (fun c -> \n                            match cubePrefix + nameBase with\n                            | n when c.cubName          = n -> Some -1\n                            | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> ParseO.parseIntO\n                            | _                             -> None\n                        ) \n                    nameBase\n                  + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n            \n                let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n                let fixForDimensions model =\n                    //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n                    let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n                    { model with modCalculations = calcs }\n                let newCalcCube dimIds model =\n                    let name = autoName dimIds model\n                    let mDim = Dimension.newDimensionCalc <| DimId (Guid.NewGuid()) <| measurePrefix + name\n                    let orderedDimIds = \n                        model\n                        |> orderedDims dimIds\n                        |> Seq.append <| [ mDim ]\n                        |> Seq.map (fun d -> d.dimId)\n                        |> Seq.toArray\n                    let dims  = Array.append model.modDims  [| mDim                                                                 |]\n                    let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n                    { model with modDims = dims ; modCubes = cubes }\n                let fixCalcsAndCubes model =\n                    let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cubIdO |> Option.bind (swap getCubeO model) |> Option.isNone)\n                    if Seq.isEmpty calNoCube then model else\n                        let modelN =\n                            calNoCube\n                            |> Seq.map      (fun c -> c.calDims)\n                            |> Seq.distinct\n                            |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                            |> Seq.fold      (swap newCalcCube) model\n                        let calcs =\n                            modelN.modCalculations\n                            |> Array.map (fun oldC ->\n                                    calNoCube \n                                    |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                                    |> Option.map  (fun newC -> { newC with Calculation.cubIdO = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                                    |> Option.defaultValue oldC\n                              )\n                        { modelN with modCalculations = calcs }\n                let prepareModel model =\n                    model\n                    |> fixForDimensions \n                    |> fixCalcsAndCubes\n                let addRules rules model =\n                    rules\n                    |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n                    |> Seq.fold (fun mdl (cubId, rules) ->\n                        getCubeO cubId mdl\n                        |> Option.map(fun cube ->\n                            rules \n                            |> Seq.map (fun (_, key, rule) -> key, rule)\n                            |> Cube.addRules <| cube\n                            |> swap setCube mdl\n                        )\n                        |> Option.defaultValue mdl\n                    ) model\n                    \n            \n            module Formula =\n                let [< Inline >] inline newFormula id dest exp  typ =\n                      {\n                          forId          = id\n                          forDestDecl    = Map.empty\n                          forDestination = dest\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = toExpA exp\n                          forType        = typ\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline newBase    id expr      = newFormula id []   expr ForBase        \n                let [< Inline >] inline newBaseFor id expr dest = newFormula id dest expr ForBase        \n                let [< Inline >] inline newCons    id expr      = newFormula id []   expr ForConsolidated\n                let [< Inline >] inline newConsFor id expr dest = newFormula id dest expr ForConsolidated\n                let [< Inline >] inline newAll     id expr      = newFormula id []   expr ForAll         \n                let [< Inline >] inline newAllFor  id expr dest = newFormula id dest expr ForAll         \n                let [< Inline >] inline New        ()        =\n                      {\n                          forId          = ForId <| Guid.NewGuid()\n                          forDestDecl    = Map.empty\n                          forDestination = []\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = ExiStet\n                          forType        = ForBase\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline forId      f         = f.forId\n                let                     conso      frm       = { frm with forType  = ForConsolidated }\n                let                     setText    txt  frm  = { frm with forText  = txt             }\n                let                     setOrder   ord  frm  = { frm with forOrder = ord             }\n                let getDimDest dim frm = \n                    frm.forDestination \n                    |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n                \n        \n            module Rule =\n                let [< Inline >] inline newRule0     dest exp typ order =\n                      {\n                          rulId          = RulId <| Guid.NewGuid()\n                          rulDestination = dest\n                          rulDescription = \"\"\n                          rulExpression  = exp\n                          rulType        = typ\n                          rulOrder       = order\n                          rulSourceId    = None\n                          rulXml         = \"\"\n                      }\n                let [< Inline >] inline newRule     dest exp typ order = newRule0     dest (toExpA exp) typ order\n                let [< Inline >] inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n                let New() = newRule0 [] ExiStet ForBase \"\"\n                let conso rul = { rul with rulType = ForConsolidated }    \n            \n            module Attribute =\n                let New() = \n                    {\n                        attId            = AttId <| Guid.NewGuid()\n                        attName          = \"\"\n                        attTableNum      = 1\n                        attType          = AtString\n                    }\n            \n        module Tree =\n            open CalculationModel\n            open TreeEff\n        //    open FusionM\n            open Operators\n        \n            type TreeNodeId = TreeNodeId of System.Guid\n        \n            type Weight =\n            | Zero\n            | Add\n            | Subtract\n        \n            type TreeNode = {\n                nid      : TreeNodeId\n                expanded : bool\n                element  : NodeId\n                children : TreeNode []\n                weight   : Weight\n            } \n        \n            type TreeCollection = {\n                getParentO  : TreeNodeId                 -> TreeNode option\n                //getNode     : TreeNodeId                 -> TreeNode\n                getPath     : TreeNodeId                 -> TreeNodeId list\n                setChildren : TreeNode   -> TreeNode seq -> TreeNode\n            }\n        \n            let getParentOEf  nid     = Reader.ask() |>> fun treeC -> treeC.getParentO  nid\n            //let getNodeEf     nid     = Reader.ask() |>> fun treeC -> treeC.getNode     nid\n            let getPathEf     nid     = Reader.ask() |>> fun treeC -> treeC.getPath     nid\n            let setChildrenEf node ch = Reader.ask() |>> fun treeC -> treeC.setChildren node ch\n        \n        //        static member FromNode (n:Tree.Node<_>) = n :?> TreeNode\n        //        interface Tree.Node<TreeNodeId> with\n        //            member node.Id                 = node.nid\n        //            member node.isExpanded         = node.expanded\n        //            member node.canHaveChildren    = match node.element with | Calc _ -> false | _ -> true\n        //            member node.path               =   \n        //                let rec getPath nid = parents |> Dict.tryGetValue nid |> Option.map Tree.toNode |> Option.map (fun n -> n.Id :: n.path) |> Option.defaultValue []\n        //                getPath node.nid\n        //            member node.children           =   node     .children   |> Tree.toSeqNode\n        //            member node.newChildren     ch = { node with children = ch \n        //                                                                    |> Seq.map   (fun n -> n :?> TreeNode    ) \n        //                                                                    |> Seq.filter(fun n -> \n        //                                                                        parents \n        //                                                                        |> Dict.tryGetValue n.nid \n        //                                                                        |> Option.map (fun v -> \n        //                                                                            if v :?> TreeNode <> node then \n        //                                                                                parents.Remove n.nid |> ignore\n        //                                                                                parents.Add(n.nid, node)\n        //                                                                        )\n        //                                                                        |> Option.defaultWith(fun () ->\n        //                                                                            parents.Add(n.nid, node)\n        //                                                                        )\n        //                                                                        true)\n        //                                                                    |> Seq.toArray } |> Tree.toNode\n        //            member node.parent          ns = parents |> Dict.tryGetValue node.nid |> Option.map Tree.toNode\n        \n        module TreeNode =\n            open Tree\n            open TreeEff\n            open CalculationModel\n        \n            let ofNode    n  = n.getData()\n            let rec treenode (node:TreeNode) =\n                {\n                    id                 = fun () -> node.nid\n                    getData            = fun () -> node\n                    isExpandedEf       = fun () -> rtn <| node.expanded\n                    canHaveChildrenEf  = fun () -> rtn <| match node.element with | Calc _ -> false | _ -> true\n                    childrenEf         = fun () -> node.children |> Seq.map treenode |> rtn \n                    newChildrenEf      = fun ch -> ch |> Seq.map ofNode |> setChildrenEf node     |>> treenode      \n                    parentOEf          = fun _ns-> getParentOEf        node.nid |>> Option.map treenode\n                    pathEf             = fun () -> getPathEf           node.nid\n                }\n        \n            let newTreeNode ch = {\n                nid      = TreeNodeId <| System.Guid.NewGuid()\n                expanded = true\n                children = [||]\n                element  = ch\n                weight   = Add\n            }\n            let newNodeCalc cid = newTreeNode <| Calc cid\n            let newNodeTot  tid = newTreeNode <| Tot  tid\n            let removeNodesEf    p   (nodes: TreeNode seq) = nodes |> Seq.map treenode |> TreeEff.removeNodes (ofNode >> p) |>> Seq.map ofNode\n            let getElement n = n.element\n            let getTId = function | Tot  tid -> Some tid | _ -> None\n            let getCId = function | Calc cid -> Some cid | _ -> None\n            let forTId p = getElement >> getTId >> (Option.map p ) >> Option.defaultValue false\n            let forCId p = getElement >> getCId >> (Option.map p ) >> Option.defaultValue false\n        \n            let tryFindTreeNodeEf  p   (nodes: TreeNode seq) = nodes |> Seq.map treenode |> TreeEff.tryFind     (ofNode >> p) |>> Option.map ofNode\n            let tryFindNodeEf      nid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (fun n -> n.nid = nid)\n            let tryFindSelNodeEf   sel (nodes: TreeNode seq) = sel   |> Option.map fst     |> Option.map (swap tryFindNodeEf nodes) |> insertO |>> Option.bind id\n            let tryFindSelChildEf  sel (nodes: TreeNode seq) = nodes |> tryFindSelNodeEf sel |>> Option.map getElement\n            let tryFindNodeTIdEf   tid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (forTId ((=) tid) )\n            let tryFindNodeCIdEf   cid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (forCId ((=) cid) )    \n        \n        module Monaco =\n            open Monaco\n            type HoverProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideHover(model:Model, pos:Position, token:obj) =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      {\n                          contents = { value = word?word |> sprintf \"The word is: %s\" ; isTrusted = true } |> Array.singleton\n                          range    = {\n                                        startLineNumber = pos.lineNumber\n                                        endLineNumber   = pos.lineNumber\n                                        startColumn     = word.startColumn\n                                        endColumn       = word.endColumn\n                                     }\n                      }\n        \n            type CompletionItemProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj): CompletionItem[] =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      [|\n                        { kind = CompletionItemKind.Function ; label = \"Hello\"   ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"How\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"Are\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"You\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = word?word ; detail = \"\"}\n        \n                      |]\n                  member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n            type DefinitionProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideDefinition(model: Model, pos: Position, token: obj): Location =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      let ms = model.FindMatches(word.word, false, false, true, \" <>()+-=.,/#@$%^&*\\\"\", false, 1)\n                      if ms.Length = 0    then box null |> unbox else\n                      { range = ms.[0].range\n                        uri = model.uri\n                      }\n        \n            let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\\nHint (4, 7) - (4, 12): \\\"This shows over there as a hint\\\".\"\n            let transformAnnotations msgs =\n                let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                             -> Some (ty, int fl, int fc, int tl, int tc, msg)\n                    | _      -> None\n                )\n                |> Array.map (fun (ty, fl, fc, tl, tc, msg) ->\n                        { message  = msg\n                          severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                          startColumn     = fc\n                          endColumn       = tc\n                          startLineNumber = fl\n                          endLineNumber   = tl\n                        }\n                  )        \n                    \n                \n            let monacoNew        (var           : Var<string>                         ) \n                                 (annotationsWO : View<MarkerData []>           option) \n                                 (showToolTipO  :(string -> int -> int -> unit) option) \n                                 (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                               -> string -> int -> int -> unit) option) =\n            \n                let setDirtyCond() = ()\n                let getHints    _  = ()\n                                    \n                Monaco.newVar var\n                |> onRender(fun ed -> \n                    Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                    Editor.SetTheme(\"vs-dark\")\n                    let hp = new HoverProvider         (ed)\n                    let cp = new CompletionItemProvider(ed)\n                    let dp = new DefinitionProvider    (ed)\n                    hp.provideHover |> print\n                    cp.provideCompletionItems |> print\n                    cp.resolveCompletionItem  |> print\n                    dp.provideDefinition      |> print\n                    Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                    Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                    Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                    annotationsWO\n                    |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) \n                    )\n                )\n        \n                \n        //#r @\"Compiled\\CalculationModelDll\\CalculationModelDll.dll\"\n        open CalculationModel\n        \n        type Selection  = (Tree.TreeNodeId * (ForId option)) option\n        \n        type Version = {\n            major     : int\n            minor     : int\n            majorDate : string\n            minorDate : string\n        }\n        \n        module Version =\n            let New() = {\n                major     = 0\n                minor     = 0\n                majorDate = \"\"\n                minorDate = \"\"\n            }\n            let incrementMinor v = { v with minor = v.minor + 1; minorDate = nowStamp() }\n            let incrementMajor v = {        major = v.major + 1; majorDate = nowStamp()\n                                            minor = 0          ; minorDate = nowStamp() }\n        \n        type ModelUI = {\n            treeHierarchy : Var<Tree.TreeNode []>\n            calculations  : ListModel<CalId        , Calculation>\n            totals        : ListModel<TotId        , Total      >\n            dimensions    : ListModel<DimId        , Dimension  >\n            cubes         : ListModel<CubId        , Cube       >\n            globalDefs    : Var<string>\n            server        : Var<string>\n            selection     : Var<Selection>\n            selectedDim   : Var<DimId option>\n            selectedCube  : Var<CubId option>\n            collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n            cubePrefix    : Var<string>\n            measurePrefix : Var<string>\n            outputMsgs    : Var<string>\n            codeFS        : Var<string>\n            parserMsgs    : Var<string>\n            fileName      : Var<string>\n            version       : Var<Version>\n        }\n        \n        type MsgModel =\n        | AddTotal\n        | SelectTotal       of TotId\n        | RemoveTotal       of TotId\n        | AddCalculation\n        | RemoveCube        of CubId\n        | RenameCube        of CubId * string\n        | AddCube           of         string * Set<DimId>\n        | RemoveCalculation of CalId\n        | SelectCalculation of CalId\n        | AddFormula        of CalId\n        | RemoveFormula     of ForId\n        | SelectFormula     of ForId\n        | SelectFormNode    of ForId * Tree.TreeNodeId\n        | SelectNode        of         Tree.TreeNodeId\n        | ExpandNode        of bool  * Tree.TreeNodeId\n        | IndentNode        of bool  * Tree.TreeNodeId\n        | MoveNode          of bool  * Tree.TreeNodeId * Tree.TreeNodeId\n        | AddDimension\n        | RemoveDimension   of DimId\n        | SelectDimension   of DimId\n        | AddFormDim        of ForId * DimId * string\n        | RemoveFormDim     of ForId * DimId\n        | RemoveCalcDim     of CalId * DimId\n        | AddCalcDim        of CalId * DimId\n        | RemoveForDest     of CalId * ForId * DimId \n        | SetForDest        of CalId * ForId * DimId * string\n        | SaveTextFile      of string\n        | LoadTextFile      of string\n        | NoOp\n        \n        module ModelUI =\n            let isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\n            let selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n            \n            let nonTotal        = { Total      .New()                with totId = TotId System.Guid.Empty }\n            let nonCalculation  = { Calculation.New()                with calId = CalId System.Guid.Empty } \n            let nonFormula      = { Formula    .New()                with forId = ForId System.Guid.Empty }\n            //let nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n            \n            let nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            let nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\n            let nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            \n            let isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n        \n            let refreshView, refreshNow =\n                let refresh = Var.Create ()\n                refresh.View, fun () -> refresh.Value <- ()\n            let setHierarchy model (nodes: Tree.TreeNode seq) =\n                //nodes |> Seq.iter (fun n -> parents.Remove n.nid |> ignore)\n                nodes\n                |> Seq.toArray\n                |> model.treeHierarchy.Set\n        \n            let [<Inline>] inline mapIds f vls = vls |> View.Map (Seq.map f >> Seq.toArray) |> View.consistent\n        \n            let getDimsCubeO cubes = cubes\n        \n        \n            \n        [< AutoOpen >]\n        module Global =\n            let model = {\n                treeHierarchy = Var.Create [||]\n                calculations  = ListModel.Create (fun v -> v.calId) [||]\n                totals        = ListModel.Create (fun v -> v.totId) [||]\n                dimensions    = ListModel.Create (fun v -> v.dimId) [||]\n                cubes         = ListModel.Create (fun v -> v.cubId) [||]\n                globalDefs    = Var.Create \"\"\n                server        = Var.Create \"\"\n                selection     = Var.Create None\n                selectedDim   = Var.Create None\n                selectedCube  = Var.Create None\n                collapsed     = ListModel.Create id [||]\n                cubePrefix    = Var.Create \"Z\"\n                measurePrefix = Var.Create \"M\"\n                outputMsgs    = Var.Create \"\"\n                codeFS        = Var.Create \"\"\n                parserMsgs    = Var.Create \"\"\n                fileName      = Var.Create \"NewFile.json\"\n                version       = Var.Create <| Version.New()\n            }\n            \n            let mutable processor = fun (msg:MsgModel) -> ()\n            \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText model.outputMsgs msg\n            let inline appendParser msg = appendText model.parserMsgs msg\n        \n        module FSCode =\n            open CalculationModel\n        \n            let trace = id\n        \n            type LocationDet =\n            | InDimension   of DimId\n            | InCalculation of CalId\n            | InGlobalDefs\n            | InFormula     of ForId\n            | InFormulaDest of ForId\n            | InFsCode\n            \n            type MsgLocation = {\n                lines    : int\n                indent   : int\n                location : LocationDet\n            }\n            \n            let getDimO  did = model.dimensions  .TryFindByKey did\n            let getCalcO cid = model.calculations.TryFindByKey cid\n            let getFormO fid = model.calculations.Value |> Seq.tryPick (fun c -> c.calFormulas |> Seq.tryPick (fun f -> if f.forId = fid then Some(c, f) else None))\n            \n            let fixName (c:string) = c.Trim().Replace(\" \", \"_\").Replace(\"-\",\"_\")\n            \n            let newDimS  d = sprintf \"    let %s = newDim (DimId (Guid.Parse %A)) %A %A %A\" (fixName d.dimName) d.dimId.Id d.dimName d.dimType (if d.dimExclude then \"\" else d.dimPrefix) |> trace, InDimension d.dimId \n            \n        //    let getDims () = model.dimensions.Value |> Seq.sortBy getorder |> Seq.map newDimS\n            \n            let dimMeasureName  cubeName = model.measurePrefix.Value + (cubeName:string).Substring(1)\n            let cubeMeasureName cube     = cube.cubName  |> dimMeasureName\n            let newMeasureDimS  cube     = cube |> cubeMeasureName |> (fun c -> sprintf \"    let %s = newDim (DimId (Guid.Parse %A)) %A %A %A\" (fixName c) cube.cubId.Id c DtCalc \"\" ) |> trace\n            \n            let getMeasureDims () =\n                model.cubes.Value\n                |> Seq.map newMeasureDimS\n            \n            let getCubeDims (c:Cube) =\n                c.cubDims\n                |> Seq.choose    (model.dimensions.TryFindByKey)\n                |> Seq.map       (fun d -> d.dimName)\n                |> Seq.append <| [ dimMeasureName c.cubName ]\n                |> String.concat \" ; \"\n            \n            let newCubeS c = sprintf \"    let %s = newCube (CubId (Guid.Parse %A)) %A CtCalc [ %s ] (Some %s)\" (fixName c.cubName) c.cubId.Id c.cubName (getCubeDims c) (cubeMeasureName c |> fixName) |> trace\n            //let getCubes () = model.cubes.Value |> Seq.map newCubeS\n            \n            let getCalcCubeNameW cdims = \n                model.cubes.TryFindAsView (fun cub -> cub.cubDims |> Set = cdims)\n                |> View.Map(\n                   Option.map (fun c -> fixName c.cubName)\n                >> Option.defaultValue \"NoCubeYet\" >> trace\n                )\n                |> View.consistent\n            let newCalcSW c = V( sprintf \"    let %s = newCalc (CalId (Guid.Parse %A)) %s %A %A %A %s\" (fixName c.calName) c.calId.Id (if c.isInput then \"Input\" else \"Calc\") c.calName c.calOrder c.isText (getCalcCubeNameW c.calDims).V |> trace, InCalculation c.calId) \n        \n            //let getCalcCubeName calc = \n            //    model.cubes.TryFind (fun cub -> cub.cubDims |> Set = calc.calDims)\n            //    |> Option.map (fun c -> fixName c.cubName)\n            //    |> Option.defaultValue \"NoCubeYet\" \n            //let newCalcS  c = sprintf \"    let %s = newCalc (CalId (Guid.Parse %A)) %s %A %A %A %s\" (fixName c.calName) c.calId.Id (if c.isInput then \"Input\" else \"Calc\") c.calName c.calOrder c.isText (getCalcCubeName c) |> trace, c.calId\n            //let getCalcs () = model.calculations.Value |> Seq.sortBy (fun c -> c.calOrder) |> Seq.map newCalcS\n            \n            let getDest f =\n                f.forDestDecl\n                |> Seq.choose (fun d -> getDimO d.Key |> Option.map (fun dim -> sprintf \"%s.[%A]\" dim.dimName d.Value ))\n                |> String.concat \" ; \"\n                |> sprintf \"[ %s ]\"\n            \n            let prepareFormula (f:string) =\n                f.Replace(\"@=\", \"&=\").Replace(\"@<\", \"&<\").Replace(\"@>\", \"&>\")\n                |> String.unindent\n                |> Seq.map ((+) \"    \")\n            \n            let fixText txt = (txt |> Seq.map String.trim |> Seq.map (fun s -> s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\\"\", \"\\\\\\\"\")) |> String.concat \" \")\n            \n            let newFormS (c, f) =\n                let txt   = prepareFormula f.forText\n                [ \n                    yield! txt\n                    yield  sprintf \"    |> newForm (ForId (Guid.Parse %A)) %s %s %s %A %A \"  \n                                f.forId.Id (fixName c.calName) (sprintf \"%A\" f.forType)    \n                                (getDest f)  f.forOrder ((fixText txt).Left 495)\n                ] |> String.concat \"\\n\"  |> trace\n              , InFormula f.forId\n            \n            let getForms c = \n                c.calFormulas\n                |> Seq.sortBy (fun f -> f.forOrder)\n                |> Seq.map    (fun f -> c, f)\n                |> Seq.map newFormS\n                |> Seq.toArray\n            \n            let preface majorVersion server =\n                sprintf \"\"\"\n                #nowarn \"86\"\n                #r @\"..\\CalculationModelDll\\CalculationModelDll.dll\"\n                module Definition%d =\n                    open FSSGlobal.CalculationModel\n                    open CalculationModel\n                    open CalculationSyntax\n                    open InitModel\n                    open System\n                    \n                    let NoCubeYet = newCube (CubId <| Guid.NewGuid()) \"NOCUBEYET\" CtCalc [] None\n                    \n                    {\n                        modId           = ModId <| System.Guid.NewGuid()\n                        server          = @%A\n                        actualElem      = \"Actual\"\n                        modCubes        = [| |]\n                        modDims         = [| |]\n                        modCalculations = [| |]\n                    } |> setInitModel\n                        \"\"\" majorVersion server\n                |> trace |> String.unindent \n            \n            let fsCodeForCalc c =\n                let fsForms = getForms  c |> Seq.map fst |> String.concat \"\\n\"\n                let fsCalc  = newCalcSW c |> View.TryGet |> Option.map fst |> Option.defaultValue \"View.TryGet failed for some reason\"\n                let header  =\n                    sprintf \"\n                        module Formula =\n                            open FSSGlobal.CalculationModel\n                            open CalculationModel\n                            open CalculationSyntax\n                            open InitModel\n                            open System \n                            open Definition%d\\n\" model.version.Value.major\n                    |> String.unindentStr\n                header\n                + fsCalc\n                + \"\\n    addCalcs()\\n\"\n                + fsForms\n                + \"\\n    addFrms() \" \n                + \"\\n    \"\n        \n            let mapSeqCached0 map f (lmodel:ListModel<_, _>) =\n                lmodel.View\n                |> View.Map map\n                |> View.MapSeqCachedBy lmodel.Key  (lmodel.Key >> lmodel.TryFindByKeyAsView >> f )\n                \n            /// from 'a -> View<'x>   to:  'a option -> View<'x option>\n            let optviewMerge f = function | None -> View.Const None | Some v -> f v |> View.Map Some \n            let inline viewSeqChoose v = v |> View.Map View.Sequence |> View.Join |> View.Map (Seq.choose id)\n            let mapSeqCached  map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Map  (Option.map   f)) model   |> viewSeqChoose\n            let mapSeqCachedW map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Bind (optviewMerge f)) model   |> viewSeqChoose\n            let bindSeqCached map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Map  (Option.bind  f)) model   |> viewSeqChoose\n        \n            let loc     lc nl   = { lines = nl ; indent = 4 ; location = lc }\n            let txtLocn lc txts =   txts  |> String.concat \"\\n\", [| loc lc (txts |> Seq.length) |]\n            let txtLoc1 lc txt  = [ txt ] |> txtLocn lc\n        \n            let groupLoc1s cs = cs |> Seq.map fst |> String.concat \"\\n\" , cs |> Seq.map (fun (_, lc) -> loc lc 1                           ) |> Seq.toArray\n            let groupLocns fs = fs |> Seq.map fst |> String.concat \"\\n\" , fs |> Seq.map (fun (t, lc) -> loc lc (t.Split '\\n' |> Seq.length)) |> Seq.toArray                         \n            \n            let collectCode v =\n                v |> Seq.filter (fst >> ((<>) \"\"))\n                  |> Seq.toArray\n                  |> Array.unzip\n                  |> fun (ts, ls) -> ts |> String.concat \"\\n\", Array.collect id ls\n            \n            let fsCode() =\n                let prefaceV   = View.Do {\n                    let! version = model.version.View\n                    let! server  = model.server .View\n                    return preface version.major server |> txtLocn InFsCode\n                }\n                let newDimsV   =    model.dimensions   |> mapSeqCached  Dimension.sort newDimS\n                let newMDimsV  =    model.cubes        |> mapSeqCached  id             newMeasureDimS\n                let newCubesV  =    model.cubes        |> mapSeqCached  id             newCubeS\n                let newCalcsV  =    model.calculations |> mapSeqCachedW id             newCalcSW\n                let newFormsV  =    model.calculations |> mapSeqCached  id             getForms\n                let globalDefV = V( model.globalDefs.V |> (String.indent 4 >> txtLocn InGlobalDefs ) )\n                let newMDimsSV = V( newMDimsV       .V |>                     txtLocn InFsCode       )\n                let newCubesSV = V( newCubesV       .V |>                     txtLocn InFsCode       )\n                let newFormsSV = V( newFormsV       .V |> (Seq.collect id  >> groupLocns        ) )\n                let newDimsSV  = V( newDimsV        .V |>                     groupLoc1s          )\n                let newCalcsSV = V( newCalcsV       .V |>                     groupLoc1s          )\n                [   prefaceV\n                    newDimsSV\n                    newMDimsSV\n                    txtLoc1 InFsCode \"    addDims()\"  |> View.Const\n                    newCubesSV\n                    txtLoc1 InFsCode \"    addCubes()\" |> View.Const\n                    newCalcsSV\n                    txtLoc1 InFsCode \"    addCalcs()\" |> View.Const\n                    globalDefV\n                    newFormsSV\n                    txtLoc1 InFsCode \"    addFrms()\"  |> View.Const\n                ] \n                |> View.Sequence\n                |> View.Map collectCode\n        \n            let fsCodeVO = if IsClient then Some <| fsCode() else None\n        \n        \n        module ParseFS =\n            open FSCode\n        \n            let adaptMessage locs (lf:int) (cf:int) (lt:int) (ct:int) msg =\n                locs \n                |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n                |> fst\n                |> Seq.tryFind (fun (from, l) -> lf - 1 >= from && lf - 1 < from + l.lines)\n                |> Option.bind (fun (from, l) -> \n                    match l.location with \n                    | InDimension   did -> getDimO  did      |> Option.map (fun  dim  -> sprintf \"%s: %A. %A\"                     dim.dimName                                                                 msg did )\n                    | InCalculation cid -> getCalcO cid      |> Option.map (fun  clc  -> sprintf \"%s: %A. %A\"                     clc.calName                                                                 msg cid )\n                    | InFormulaDest fid -> getFormO fid      |> Option.map (fun (c,f) -> sprintf \"%s: %A. %A\"                     c  .calName                                                                 msg fid )\n                    | InFormula     fid -> getFormO fid      |> Option.map (fun (c,f) -> sprintf \"%s: (%d,%d) - (%d,%d): %A. %A\"  c  .calName (lf - from) (cf - l.indent) (lt - from) (ct - l.indent) msg fid )\n                    | InFsCode          -> Some                            (             sprintf \"F# Code (%d,%d) - (%d,%d): %A.\"              lf          cf              lt          ct             msg     )\n                    | InGlobalDefs      -> Some                            (             sprintf \"Global  (%d,%d) - (%d,%d): %A.\"             (lf - from) (cf - l.indent) (lt - from) (ct - l.indent) msg     )\n                )\n                |> Option.defaultWith (fun () -> sprintf \"%d %d - %d %d %s\" lf cf lt ct msg)\n        \n            let adaptMessages locs ms =\n                let rex = \"\"\".*\\((\\d+),(\\d+)\\) - \\((\\d+),(\\d+)\\) ([^\"]*?)\"(?:\\n|$)\"\"\"\n                match ms with\n                | REGEX rex \"g\" m ->    m\n                |               m -> [| m |]\n                |> Array.map (\n                    function\n                    | REGEX rex \"\" [| _ ; lf ; cf ; lt ; ct ; msg |] -> adaptMessage locs (int lf) (int cf) (int lt) (int ct) msg \n                    | o                                              -> o\n                )\n        \n            let parseFile = \"RuleEditor.fsx\"\n        \n            open FsAutoComplete.CommTypes\n            //let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"RuleEditor\")//, endPoint = JS.Window.Location.Href)\n        \n            let adaptErrors locs (errs: ErrorResponse) = \n                errs.Errors\n                |> Seq.map(fun err ->\n                    adaptMessage locs err.StartLine err.StartColumn err.EndLine err.EndColumn err.Message\n                )\n        \n            if IsClient then\n        \n                let parseFsCode _ =\n                    asyncResult {\n                        model.parserMsgs.Value   <- \"Parsing...\\n\" + String.skipFirstLine model.parserMsgs.Value\n                        match FSCode.fsCodeVO with\n                        | None                   -> ()\n                        | Some fsCodeV           ->\n                        let! fs, locs             = fsCodeV |> View.GetAsync\n                        let! errs, _others        = FsAutoComplete.Calls.parseCode parseFile (fs.Split '\\n') true 0\n                        let  res                  = adaptErrors locs errs |> String.concat \"\\n\"\n                        //model.outputMsgs.Value   <- locs |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\"\n                        model.codeFS.Value       <- fs\n                        model.parserMsgs.Value   <- \"Parsed!\\n\" + res\n                    } |> AsyncResult.iterA (ResultMessage.summarized >> print) id\n                    \n                let parseFsCodeD = delayed 1000 parseFsCode \n                FSCode.fsCodeVO |> Option.iter (View.Sink parseFsCodeD)\n        \n            let sForId = ForId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n            let sCalId = CalId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n            let sTotId = TotId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n            let sDimId = DimId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n        \n            let rexGlobal =      \"\"\"(Global)  \\(\"\"\"  \n            let rexTotId  = \"\"\"\\\"\\. (\"\"\" + sTotId + \") \" + \"\\\"\" + rexGuid\n            let rexCalcId = \"\"\"\\\"\\. (\"\"\" + sCalId + \") \" + \"\\\"\" + rexGuid\n            let rexFormId = \"\"\"\\\"\\. (\"\"\" + sForId + \") \" + \"\\\"\" + rexGuid\n            let rexDimId  = \"\"\"\\\"\\. (\"\"\" + sDimId + \") \" + \"\\\"\" + rexGuid\n        \n            let jumpToLine (line:string) = \n                let rex = [ rexGlobal\n                            rexTotId \n                            rexCalcId\n                            rexFormId\n                            rexDimId     \n                          ] |> String.concat \"|\" |> sprintf \"(?:%s)\"\n                match line with\n                | REGEX rex \"\" p -> \n                    p\n                    |> Array.skip 1\n                    |> Array.filter (isUndefined >> not)\n                    |> function\n                       | [| v ; guid |] when v = sForId -> SelectFormula     (System.Guid guid |> ForId) |> processor\n                       | [| v ; guid |] when v = sCalId -> SelectCalculation (System.Guid guid |> CalId) |> processor\n                       | [| v ; guid |] when v = sTotId -> SelectTotal       (System.Guid guid |> TotId) |> processor\n                       | [| v ; guid |] when v = sDimId -> SelectDimension   (System.Guid guid |> DimId) |> processor       \n                       | _ -> ()\n                | _ -> ()\n            \n            let jumpToRef (e:obj) = \n                let v : string = e?Target?value |> unbox\n                let s : int    = e?Target?selectionStart |> unbox\n                let i = v.[0..s].LastIndexOf '\\n'\n                jumpToLine v.[i+1..]\n        \n            let showToolTips lc txt line col =\n                asyncResult {\n                    match FSCode.fsCodeVO with\n                    | None           -> ()\n                    | Some fsv       ->\n                    let! _, locs      = fsv  |> View.GetAsync\n                    let   locsm,  _   = locs |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n                    match locsm      |> Seq.tryFind (fun (_,l) -> l.location = lc) with\n                    | None           -> () \n                    | Some(from, loc)->\n                    let  sub          = REGEX.getStartWord txt col |> String.length\n                    let  add0         = REGEX.getEndWord   txt col |> String.length\n                    let  add          = if sub = 0 && add0 = 0 then 2 else add0\n                    let  lf           = line       + 1 + from\n                    let  lt           = line       + 1 + from\n                    let  cf           = col  - sub + 1 + loc.indent\n                    let  ct           = col  + add + 1 + loc.indent\n                    let! tip, others  = FsAutoComplete.Calls.toolTip parseFile lf cf \"\"\n                    let  tipText      = tip |> Seq.collect id |> Seq.collect (fun (t:OverloadDescription) -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n                    let  msg          = adaptMessage locs lf cf lt ct tipText\n                    //let  msg          = sprintf \"Global  %A - %A: %A.\" (line + 1, col - sub + 1) (line + 1, col + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n                    if not <| model.parserMsgs.Value.Contains msg then \n                        appendParser msg\n                } |> AsyncResult.iterA (ResultMessage.summarized >> print) id\n        \n            let getSymbolType chr =\n                match chr with\n                | \"C\"   -> \"class\"     \n                | \"Cn\"  -> \"Constant\"  \n                | \"D\"   -> \"delegate\"  \n                | \"E\"   -> \"enum\"      \n                | \"P\"   -> \"property\"  \n                | \"e\"   -> \"event\"     \n                | \"X\"   -> \"exception\" \n                | \"F\"   -> \"field\"     \n                | \"I\"   -> \"interface\" \n                | \"M\"   -> \"function\"    \n                | \"N\"   -> \"module\"    \n                | \"S\"   -> \"struct\"    \n                | \"T\"   -> \"type\"      \n                | \"V\"   -> \"Variable\"  \n                | _     -> chr\n        \n        \n            let getHints lc showHints txt line col =\n                asyncResult {\n                    match FSCode.fsCodeVO with\n                    | None           -> ()\n                    | Some fsv       ->\n                    let! _, locs      = fsv  |> View.GetAsync\n                    let   locsm,  _   = locs |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n                    match locsm      |> Seq.tryFind (fun (_,l) -> l.location = lc) with\n                    | None           -> () \n                    | Some(from, loc)->\n                    let  word         = REGEX.getStartWord txt col\n                    printfn \"getHints '%s' <= %d :%s => \" word col txt\n                    let  lf           = line + 1 + from\n                    let  cf           = col  + 1 + loc.indent\n                    let! crs, others  = FsAutoComplete.Calls.completion (String.replicate loc.indent \" \" + txt) true parseFile lf cf \"\"\n                    let  hints        = crs |> Array.map (fun (cr:CompletionResponse) -> cr.ReplacementText, (sprintf \"%-40s %20s\" cr.Name (getSymbolType cr.GlyphChar)), cr.Glyph)\n                    showHints hints (line, col - word.Length) (line, col)\n                } |> AsyncResult.iterA (ResultMessage.summarized >> print) id\n        \n            \n            //let filterGlobal msgs =\n            //    let rex  = \"\"\"Global  \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n            //    match msgs with\n            //    | REGEX rex \"g\" m -> m\n            //    | _               -> [||]\n            //    |> Array.choose (fun v ->\n            //        match v with\n            //        | REGEX rex \"\" [| _ ; fl;     fc;     tl;     tc; msg |] \n            //                 -> Some (int fl, int fc, int tl, int tc, msg)\n            //        | _      -> None\n            //    )\n            //    |> Array.map (fun (fl, fc, tl, tc, msg) ->\n            //            { Lint.Response.message  = msg\n            //              Lint.Response.severity = \"error\"\n            //              Lint.Response.from     = cmPos(fl - 1, fc - 1) \n            //              Lint.Response.``to``   = cmPos(tl - 1, tc - 1)\n            //            }\n            //      )        \n            \n            let rexFormula   = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\. ForId \"\"\" + \"\\\"\" + rexGuid // \"\n            let filterFormula msgs fidO =\n                match msgs with\n                | REGEX rexFormula \"g\" m -> m\n                | _                 -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rexFormula \"\" [| _ ; fl;     fc;     tl;     tc; msg; guid |] when fidO = Some(guid |> System.Guid |> ForId) \n                                    -> Some (int fl, int fc, int tl, int tc, msg)\n                    | _             -> None\n                )\n                |> Array.map (fun (fl, fc, tl, tc, msg) ->\n                        { Monaco.MarkerData.message         = msg\n                          Monaco.MarkerData.severity        = Monaco.MarkerSeverity.Error\n                          Monaco.MarkerData.startLineNumber = fl - 1\n                          Monaco.MarkerData.startColumn     = fc - 1\n                          Monaco.MarkerData.endLineNumber   = tl - 1\n                          Monaco.MarkerData.endColumn       = tc - 1\n                        }\n                  )        \n            \n            \n        module Render =\n            let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then e?scrollIntoViewIfNeeded())\n        \n            //let selTotIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getTId)\n            //let selCalIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getCId)\n            //let selForIdOV =                                                                model.selection.View |> View.Map2 (Option.bind snd            )\n          \n            //let lensForm getF view (calcV:Var<Calculation>) = \n            //    calcV |> Var.lensView\n            //               (fun c   -> c.calFormulas |> Seq.tryFind      getF |> Option.defaultValue ModelUI.nonFormula)\n            //               (fun c y -> c.calFormulas |> Seq.tryFindIndex getF |> Option.map (fun i -> { c with calFormulas = Array.replace i y c.calFormulas } )\n            //                                                                  |> Option.defaultValue c)\n            //               view\n          \n            let mapDefW def = View.Map (Option.defaultValue def) \n          \n            let zx = {\n                Tree.nid      = System.Guid.Empty |> Tree.TreeNodeId\n                Tree.expanded = false\n                Tree.element  = System.Guid.Empty |> CalId |> Calc // NodeId\n                Tree.children = [||] // TreeNode []\n                Tree.weight   =  Tree.Add        \n            }\n        \n            open Tree\n        \n            let parents = new System.Collections.Generic.Dictionary<TreeNodeId, TreeNode>()\n        \n            let setChildren (node:TreeNode) (ch: TreeNode seq) : TreeNode =\n                let toIdSet ns = ns |> Seq.map (fun n -> n.nid) |> Set\n                toIdSet  node.children - toIdSet ch |> Seq.iter (parents.Remove >> ignore)\n                ch |> Seq.iter (fun chn -> Dict.add chn.nid node parents)\n                { node with children = Seq.toArray ch }\n        \n            let getParentO  nid = Dict.tryGetValue nid parents        \n        \n            let rec getPath     nid =\n                match getParentO nid with\n                | Some node -> node.nid :: getPath node.nid\n                | None      -> []\n        \n            let getTreeEffReaderResource() = {\n                Tree.getParentO  = getParentO\n                //Tree.getNode     = fun _   -> Hole.Incomplete \"Tree.getNode    \" //    TreeNodeId ->                 TreeNode\n                Tree.getPath     = getPath\n                Tree.setChildren = setChildren\n            }\n        \n            type EffReader<'read> = inherit Reader.Reader<'read>\n        \n            let runEff     Ef = Ef |> Reader.readerHandler (getTreeEffReaderResource()) |> (Eff.run : (Eff<EffReader<_>,_> -> _) )\n            let iterEff  f m  = m |> map (f: 'a -> unit) |> runEff |> fun vR -> vR \n        \n            let tryFindNode nid = TreeNode.tryFindNodeEf nid\n        \n            let currentCalcOW = View.Do {\n                let! nodes = model.treeHierarchy.View\n                let! selO  = model.selection    .View\n                let! calcs = model.calculations .View\n                return\n                    nodes \n                    |> TreeNode.tryFindSelNodeEf selO\n                    |> runEff \n                    |> Option.bind (fun node -> match node.element with Calc cid -> Some cid |_-> None)\n                    |> Option.bind (fun cid  -> calcs |> Seq.tryFind (fun c -> c.calId = cid))\n            }\n            let setCurrentCalc v = \n                async {\n                    let! currCalcO = currentCalcOW |> View.GetAsync \n                    if   currCalcO.IsNone then () else\n                    model.calculations.Add v\n                } |> Async.Start\n            let currentCalcV  = Var.Make (mapDefW ModelUI.nonCalculation currentCalcOW ) setCurrentCalc\n            \n            //let currentCalcV  = ListModel.currentLens ModelUI.nonCalculation selCalIdOV model.calculations\n            //let currentFormV  = currentCalcV |> lensForm (fun f -> match model.selection.Value with Some(_, Some fid) -> fid = f.forId |_-> false) model.selection.View\n          \n            let lensForm (calcV:Var<Calculation>) getFidO =\n                if not IsClient then ModelUI.nonFormulaV else\n                let calcFormsV = Lens calcV.V.calFormulas\n                let formOW = View.Do {\n                    let! calc = calcV.View\n                    return\n                        getFidO()\n                        |> Option.bind (fun fid -> \n                            if calc.calId = ModelUI.nonCalculation.calId then None else \n                            calc.calFormulas |> Seq.tryFind (fun f -> f.forId = fid) )\n                }\n                let setForm v = \n                    async {\n                        let! formO = formOW |> View.GetAsync \n                        if   formO.IsNone then () else\n                        calcFormsV.Value \n                        |> Seq.tryFindIndex (fun f -> f.forId = v.forId)\n                        |> Option.iter(fun i -> calcFormsV.Value <- calcFormsV.Value |> Array.replace i v)\n                    } |> Async.Start\n                Var.Make (mapDefW ModelUI.nonFormula formOW) setForm\n            let currentFormV = lensForm currentCalcV (fun () -> model.selection.Value |> Option.bind snd)\n            \n            let calcTypeV (calcV:Var<Calculation>) = (Lens calcV.V.isInput).Lens (function true->\"Input\" |_->\"Calc\") (fun _ s -> match s with |\"Calc\" -> false | _ -> true) \n            let formTypeV (formV:Var<Formula    >) = (Lens formV.V.forType).Lens (fun t -> (sprintf \"%A\" t).[3..]  ) (fun _ s -> match s with |\"Base\" -> ForBase |\"Consolidated\" -> ForConsolidated | _ -> ForAll  ) \n            \n            let dtypes =   [ \n              DtDataType\n              DtTime\n              DtVersion\n              DtOther    ] \n          \n        \n            \n        module DragDrop =\n        \n            type DragInfo = \n                | DragNone\n                | DragNode of Tree.TreeNodeId\n                | DragForm of CalId * Formula\n            \n            let mutable drag        = DragNone\n            let setDragNone ()      = drag <- DragNone\n            let setDragNode tnid    = drag <- DragNode tnid\n            let setDragForm cid frm = drag <- DragForm(cid, frm)\n            \n            let getDragFormO cid fid = match drag with DragForm (dcid, dfor) when fid  <> dfor.forId && dcid = cid -> Some dfor | _ -> None\n            let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n            let isDragForm   cid fid = getDragFormO cid fid |> function None -> false | _ -> true\n            \n            let [< Inline >] inline moveItem dropId elems getId item =\n                elems\n                |> Seq.filter (getId >> ((<>) (getId item)) )\n                |> Seq.toArray\n                |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                             [fst ; [| item |] ; snd])\n                |> Seq.collect id\n                |> Seq.toArray\n            \n            let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n            let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n            \n            let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n            \n        module TableDimensions =\n            open Templating\n        \n            let dtypes =   [ \n                DtDataType\n                DtTime\n                DtVersion\n                DtOther    ] \n        \n            let tableDimensions () =\n                TemplateLib.DimensionTable()\n                    .TBody(\n                        model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n                            //let selDimW = V (model.selectedDim.V = Some did)\n                            TemplateLib.DimensionRow()\n                                .Name(          Lens dimV.V.dimName       )\n                                .Abbreviation(  Lens dimV.V.dimPrefix     )\n                                .Order(         Lens dimV.V.dimOrder      )\n                                .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                                .ExcludeName(   Lens dimV.V.dimExclude    )\n                                .IncludeFreeze( Lens dimV.V.dimFreeze     )\n                                .Remove(        fun _ -> RemoveDimension did |> processor )\n                                .Select(        fun _ -> SelectDimension did |> processor )\n                                .Doc()        \n                        )\n                    )\n                    .Doc()\n        module TableCalculations =\n            let rowFormula (tnId:Tree.TreeNodeId) (calcV : Var<Calculation>) fid =\n                let cid      = calcV.Value.calId\n                let formsV   =        Lens     calcV.V.calFormulas\n                let formV    = Render.lensForm calcV (fun () -> Some fid) \n                let selFormW = V (ModelUI.isNodeFormSelected fid tnId model.selection.V)\n                let formForW = V (formV.V.forDestDecl \n                                  |> Seq.map(fun f -> \n                                      sprintf \"%s:%s\" \n                                          (model.dimensions.View.V \n                                           |> Seq.tryFind(fun d -> d.dimId = f.Key) \n                                           |> function Some dim -> dim.dimName |_-> \"\") \n                                          f.Value) \n                                  |> String.concat \", \")\n                TemplateLib.FormulaRow()\n                    .SelectedMark( ModelUI.selectedString \">\"        selFormW )\n                    .Selected(     ModelUI.selectedString \"selected\" selFormW )\n                    .FormulaFor(   formForW                                   )\n                    .Formula(      Lens formV.V.forText                       )\n                    .FormType(     Render.formTypeV formV                     )\n                    .Remove(       fun _  -> RemoveFormula  fid        |> processor                               )\n                    .Select(       fun _  -> SelectFormNode(fid, tnId) |> processor                               )\n                    .Drag(         fun ev ->    DragDrop.setDragForm cid formV.Value ; ev.Event.StopPropagation() )\n                    .DragOver(     fun ev -> if DragDrop .isDragForm cid fid then      ev.Event.PreventDefault () )\n                    .Drop(         fun ev -> do                                        ev.Event.PreventDefault ()\n                                             DragDrop.getDragFormO cid fid |> DragDrop.moveItemInListModel fid formsV Formula.forId )\n                    .AfterRender(  Render.scrollIntoView selFormW )\n                    .Doc()\n                    \n            let rowTreeNode (tnId:Tree.TreeNodeId, nid:NodeId, level:int) =\n                let depth             = sprintf \"%dem\" level\n                let isSelW            = V (ModelUI.isNodeSelected tnId model.selection.V)\n                let rowCalculation (calcV:Var<Calculation>) cid       =\n                    let formsDoc      = V (calcV.V |> fun c -> c.calFormulas |> Seq.map Formula.forId) |> Doc.BindSeqCached (rowFormula tnId calcV)\n                    TemplateLib.CalculationRow()\n                        .SelectedMark( \"\" )\n                        .Selected(     ModelUI.selectedString \"selected\" isSelW )\n                        .Indent(       depth                            )\n                        .CalcName(     Lens calcV.V.calName   )\n                        .Format(       Lens calcV.V.format    )\n                        .IsText(       Lens calcV.V.isText    )\n                        .IsBalance(    Lens calcV.V.isBalance )\n                        .OrderCalc(    Lens calcV.V.calOrder  )\n                        .CalcType(     Render.calcTypeV calcV )\n                        .Remove(       fun _ -> RemoveCalculation cid |> processor        )\n                        .Select(       fun _ -> isSelW |> View.Get (fun s -> if not s then SelectNode tnId |> processor)  )\n                        .Formulas(     formsDoc )\n                        .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n                        .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n                        .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                                 DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n                        .AfterRender(  Render.scrollIntoView isSelW )\n                        .Doc()\n                 \n                let rowTotal (totV:Var<Total>) tid =\n                    let totV         = model.totals |> ListModel.lensDef ModelUI.nonTotal tid\n                    let nodeW        = V (TreeNode.tryFindNodeEf tnId model.treeHierarchy.V |> Render.runEff )\n                    let markW        = V (nodeW.V |> Option.map (fun node -> if node.expanded then \"-\" else \"+\") |> Option.defaultValue \"*\")\n                    TemplateLib.TotalRow()\n                        .SelectedMark( markW                                           )\n                        .Selected(     ModelUI.selectedString \"selected\" isSelW        )\n                        .Indent(       depth                                           )\n                        .TotName(      Lens totV.V.totName                             )\n                        .Format(       Lens totV.V.totFormat                           )\n                        .OrderTot(     Lens totV.V.totOrder                            )\n                        .Remove(       fun _ -> RemoveTotal tid           |> processor )\n                        .Select(       fun _ -> SelectNode  tnId          |> processor )\n                        .Collapse(     fun _ -> nodeW |> View.Get (Option.iter (fun node -> (not node.expanded, node.nid) |> ExpandNode |> processor)) )\n                        .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n                        .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n                        .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                                 DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n                        .AfterRender(  Render.scrollIntoView isSelW )\n                        .Doc()\n            \n                match  nid with\n                | Calc cid -> rowCalculation (model.calculations |> ListModel.lensDef ModelUI.nonCalculation cid) cid\n                | Tot  tid -> rowTotal       (model.totals       |> ListModel.lensDef ModelUI.nonTotal       tid) tid\n                \n            let tableCalculations() =\n                TemplateLib.CalculationTable()\n                    .TBody( \n                        V (model.treeHierarchy.V\n                           |> Seq.map TreeNode.treenode\n                           |> TreeEff.listNodes 0 \n                           |> Render.runEff\n                           |> (Seq.map (fun (tn,l) -> tn.id(), (TreeNode.ofNode tn).element, l) ) \n                        )\n                        |> Doc.BindSeqCached rowTreeNode\n                     )\n                    .Doc()\n            \n        let details () =\n            let noCalcAttr             () = attr.disabledDynPred (V \"\") (V (Render.currentCalcV.V.calId = ModelUI.nonCalculation.calId))\n            let noFormAttr             () = attr.disabledDynPred (V \"\") (V (Render.currentFormV.V.forId = ModelUI.nonFormula    .forId))\n            let getAnnot                  = V (model.selection.V |> Option.bind snd |> ParseFS.filterFormula model.parserMsgs.V) |> View.consistent\n            let showToolTips txt line col = Render.currentFormV.View |> View.Get (fun frm -> ParseFS.showToolTips (FSCode.InFormula frm.forId)   txt line col)\n            let getHints   f txt line col = Render.currentFormV.View |> View.Get (fun frm -> ParseFS.getHints     (FSCode.InFormula frm.forId) f txt line col)\n            let editor                    =\n                Monaco.monacoNew \n                    <| Lens Render.currentFormV.V.forText\n                    <| Some getAnnot\n                    <| Some showToolTips\n                    <| Some getHints\n                |> Monaco.render\n            \n            TemplateLib.FormulaDetail()\n                .CalcName(    Lens Render.currentCalcV.V.calName   )\n                .Format(      Lens Render.currentCalcV.V.format    )\n                .IsText(      Lens Render.currentCalcV.V.isText    )\n                .IsBalance(   Lens Render.currentCalcV.V.isBalance )\n                //.AlsoActual(  Lens Render.currentFormV.V.alsoActual)\n                .CalcType(    Render.calcTypeV Render.currentCalcV        )\n                .FormType(    Render.formTypeV Render.currentFormV        )\n                .Formula(     editor                        )\n                .DisableCalc1(noCalcAttr())\n                .DisableCalc2(noCalcAttr())\n                .DisableCalc3(noCalcAttr())\n                .DisableCalc4(noCalcAttr())\n                .DisableCalc5(noCalcAttr())\n                .DisableCalc6(noCalcAttr())\n                .DisableCalc7(noCalcAttr())\n                .DisableForm1(noFormAttr())\n                .DisableForm2(noFormAttr())\n                .AddFormula(  fun _ -> (V Render.currentCalcV.V.calId) |> View.Get (AddFormula >> processor) )\n                //.UpdateCalc(  fun _ -> UpdateAlea.updateCalc()  )\n                .Doc()\n            \n        \n        let dimsSelected () =\n            let destV = Lens Render.currentFormV.V.forDestDecl\n        \n            let cubeBaseNameW  = View.Do {\n                let! prefix    = model.cubePrefix.View\n                let! dims      = model.dimensions.View\n                let  dimsSort  = dims     |> Dimension.filterSort Render.dtypes\n                let  dimPrxs   = dimsSort |> Seq.map(fun d -> d.dimId, if d.dimExclude then \"\" else d.dimPrefix) |> Seq.toArray\n                let  dimIds    = dimPrxs  |> Array.map fst\n                let! cubes     = model.cubes     .View\n                let  cubeDims  = cubes    |> Seq.filter (fun c -> c.cubType = CtCalc) |> Seq.map(fun c -> c.cubDims |> Array.filter (swap Array.contains dimIds) |> Set , c) |> Seq.toArray\n                let! currCalc  = Render.currentCalcV    .View\n                let  currDims  = currCalc.calDims\n                let  currCubeO = cubeDims |> Seq.tryFind(fst >> ((=) currDims)) |> Option.map snd\n                let  baseName  = if currCubeO.IsSome then \"\" else\n                                 dimPrxs  |> Seq.choose (fun (did, pr) -> if Set.contains did currDims then Some pr else None)\n                                          |> String.concat \"\" |> ((+) prefix)\n                return currCubeO, baseName\n            }\n            let currCubeOW       = cubeBaseNameW |> View.Map  fst\n            let cubePlaceholderW = cubeBaseNameW |> View.Map  snd\n            let cubeNameW        = currCubeOW    |> View.Map (function Some cub -> cub.cubName |_-> \"\")\n            let setCubeName   (n:string) =\n                async { \n                    let  nm = n.Trim()\n                    let! currCubeO = currCubeOW |> View.GetAsync\n                    match currCubeO with\n                    | Some cube -> if nm = \"\" \n                                   then RemoveCube  cube.cubId \n                                   else RenameCube (cube.cubId , nm)\n                    | None      -> if nm = \"\"\n                                   then NoOp\n                                   else AddCube    (nm, Render.currentCalcV.Value.calDims)\n                    |> processor\n                } |> Async.Start\n            TemplateLib.DimsSelected()\n                .CubeName(        Var.Make cubeNameW setCubeName)\n                .PossibleCubeName(cubePlaceholderW)\n                .TBody(\n                    model.dimensions |> ListModel.docLensMapView (Dimension.filterSort Render.dtypes) (fun did dimV ->\n                        let destW     = View.Do {\n                            let!  currForm  = Render.currentFormV.View\n                            match currForm.forDestDecl.TryFind did with\n                            | Some txt -> return txt\n                            | None     -> return \"\"\n                        }\n                        let setDest (v:string) =\n                            let t = v.Trim()\n                            if Render.currentFormV.Value.forId = ModelUI.nonFormula.forId then () else\n                            destV.Value <- \n                                if  t = \"\" \n                                then destV.Value |> Map.remove did\n                                else destV.Value |> Map.add    did t\n                        let dimCheckW = V (Render.currentCalcV.V.calDims |> Seq.contains did)\n                        let setCheck v = \n                            if v \n                            then    AddCalcDim(Render.currentCalcV.Value.calId, did)\n                            else RemoveCalcDim(Render.currentCalcV.Value.calId, did)\n                            |> processor\n                        let visibFor = V(if Render.currentFormV.V.forId <> ModelUI.nonFormula.forId && dimCheckW.V then \"\" else \"Hidden\")\n                        TemplateLib.DimSelectedRow()\n                            .Dimension(      V dimV.V.dimName           )\n                            .DimensionCheck( Var.Make dimCheckW setCheck)\n                            .Destination(    Var.Make destW     setDest )\n                            .Hidden(         visibFor                   )\n                            .Doc()\n                    )\n                )\n                .Doc()    \n        \n        let globalDefs () =\n            //let getAnnot = V (Monaco.filterGlobal model.parserMsgs.V) |> View.consistent\n            \n            Monaco.monacoNew\n                <| model.globalDefs \n                <| None //Some getAnnot\n                <| None //Some (ParseFS.showToolTips FSCode.InGlobalDefs)\n                <| None //Some (ParseFS.getHints     FSCode.InGlobalDefs)\n        \n            |> Monaco.render\n        \n        module MainProgram =\n            open FusionAsyncM\n            open Operators\n            open Templating\n        \n            open FsRoot\n            module AF = AppFramework \n        \n            let RuleEditorLyt = \"RuleEditorLyt\"\n        \n            let scrollToBottom (e:Dom.Element) (_:obj) = \n                async { \n                    do! Async.Sleep 100\n                    do  e.ScrollTop <- e.ScrollHeight\n                } |> Async.Start\n        \n        //    let mainLayout() =\n        //        TemplateLib.Layout()\n        //            .CalculationTable( tableCalculations()                  )\n        //            .FormulaDetail(    details          ()                  )\n        //            .DimsSelected(     dimsSelected     ()                  )\n        //            .DimensionTable(   tableDimensions  ()                  )\n        //            .GlobalText(       globalDefs       ()                  )\n        //            .Server(           model.server                         )\n        //            .Output(           model.outputMsgs                     )\n        //            .FSCode(           model.codeFS                         )\n        //            .Parser(           model.parserMsgs                     )\n        //            .Filename(         model.fileName                       )\n        //            .AddCalculation(   fun _ -> AddCalculation |> processor )\n        //            .AddTotal(         fun _ -> AddTotal       |> processor )\n        //            .NewDimension(     fun _ -> AddDimension   |> processor )\n        //            .SaveAs(           fun _ -> SaveLoad.saveAsFile()       )\n        //            .LoadFileChanged(  fun e -> SaveLoad.loadFile e.Target  )\n        //            .LoadFileClear(    fun e -> e.Target?value <- \"\"        )\n        //            .UpdateRules(      fun _ -> UpdateAlea.updateModel()    )        \n        //            .IndentIn(         fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        //            .IndentOut(        fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n        //        //    .Reorder(          fun _ -> reorder()                                    )\n        //            .JumpRef(ParseFS.jumpToRef)\n        //            .OutputAfterRender(fun e -> model.outputMsgs.View |> View.Sink (scrollToBottom e))\n        //            .Doc()\n        \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = \"RuleEditor\"\n                    AF.plgVars    = [| AF.newVar  \"fileName\"        model.fileName\n                                       AF.newVar  \"CodeFS\"          model.codeFS\n                                       AF.newVar  \"Output\"          model.outputMsgs\n                                       AF.newVar  \"Parser\"          model.parserMsgs\n                                       AF.newVar  \"Server\"          model.server\n                                       AF.newVar  \"GlobalDefs\"      model.globalDefs\n                                    |]  \n                    AF.plgViews   = [| //AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                                       //AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                                       //AF.newViw  \"CurrentPath\"     Snippets.currentPathW\n                                    |]  \n                    AF.plgDocs    = [| //AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                                       //AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                                       //AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                                       //AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                                       //AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                                       AF.newDoc  \"globalDefs\"      (lazy globalDefs                         () )\n                                       AF.newDoc  \"Dimensions\"      (lazy TableDimensions  .tableDimensions  () )\n                                       AF.newDoc  \"Calculations\"    (lazy TableCalculations.tableCalculations() )\n                                       AF.newDoc  \"details\"         (lazy details                            () )\n                                       AF.newDoc  \"dimsSelected\"    (lazy dimsSelected                       () )\n                                    |]  \n                    AF.plgActions = [| //AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                                       //AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                                       AF.newAct  \"IndentIn\"        <| fun () -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor)\n                                       AF.newAct  \"IndentOut\"       <| fun () -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor)\n                                       //AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                                       //AF.newAct  \"RunFS\"           runFsCode\n                                       //AF.newAct  \"AbortFsi\"        FsiAgent.abortFsiExe\n                                       //AF.newAct  \"DisposeFsi\"      FsiAgent.disposeFsiExe\n                                       AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadTextFile |> processor  ), \"FileElement\")\n                                       AF.newActF  \"SaveAs\"          <| AF.FunAct1 ((fun o -> unbox o |> SaveTextFile |> processor  ), \"FileElement\")\n                                       //AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile     ), \"FileElement\")\n                                       //AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef        ), \"textarea\"   )\n                                       //AF.newActF \"ButtonClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.buttonClick), \"button\"     )\n                                       //AF.newActF \"ActionClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.actionClick), \"name\"       )\n                                       AF.newAct  \"AddCalculation\"  (fun () -> AddCalculation |> processor)\n                                       AF.newAct  \"AddTotal\"        (fun () -> AddTotal       |> processor)\n                                       AF.newAct  \"AddDimension\"    (fun () -> AddDimension   |> processor)\n                                    |]\n                    AF.plgQueries = [|                                               \n                                    |]\n                }\n                match JS.Document.GetElementById(\"GlobalLayout\") with\n                | null ->\n                   \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -200 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS none x btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddDimension  button RuleEditor.AddDimension      \"\"                  \"Add Dimension \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                   \"\"\"\n                | e -> e.TextContent\n                |> LayoutEngine.newLyt RuleEditorLyt\n                |> LayoutEngine.addLayout\n        \n                None\n                |> Option.defaultValue RuleEditorLyt\n                |> AF.mainDocV.Set\n        \n                async {\n                  //do! Monaco.loader\n                  //WcSplitter.init horizontal vertical\n                  //WcTabStrip.init()\n                  //let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n                  return AF.getMainDoc.Value\n                } |> Doc.Async            \n                \n        module UpdateModelUI =\n                                            \n            let rec updateModelR model msg = \n                let doForCalc cid f       = model.calculations.TryFindByKey cid |> Option.iter f\n                let doForForm cid fid f   = doForCalc cid <| fun c -> c.calFormulas |> Seq.tryFind(fun f -> f.forId = fid) |> Option.iter (f c)\n                let doForCube cid f       = model.cubes       .TryFindByKey cid |> Option.iter f\n                let setSelection sel      = if model.selection.Value = sel then false else\n                                            model.selection.Value   <- sel\n                                            true\n                let tryFindCalcForm fid   = model.calculations.Value |> Seq.tryFind(fun calc -> calc.calFormulas |> Seq.exists (fun f -> f.forId = fid))\n                match msg with\n                | AddCalculation         -> let n = Calculation.New()\n                                            model.calculations.Add n\n                                            let nn = TreeNode.newNodeCalc n.calId\n                                            model.treeHierarchy.Value\n                                            |> Array.append [| nn |]\n                                            |> model.treeHierarchy.Set\n                                            SelectNode  nn.nid |> updateModelR model\n                | AddTotal               -> let n = Total.New()\n                                            model.totals.Add n\n                                            let nn = TreeNode.newNodeTot  n.totId\n                                            model.treeHierarchy.Value\n                                            |> Array.append [| nn |]\n                                            |> model.treeHierarchy.Set\n                                            SelectNode  nn.nid |> updateModelR model\n                | AddFormula         cid -> if  cid = ModelUI.nonCalculation.calId then false else\n                                            let n = Formula.New()\n                                            model.calculations.TryFindByKey cid\n                                            |> Option.iter(fun calc -> { calc with calFormulas = Array.append calc.calFormulas [| n |] } |> model.calculations.Add)\n                                            model.treeHierarchy.Value \n                                            |> TreeNode.tryFindSelNodeEf model.selection.Value\n                                            |> Render.runEff\n                                            |> Option.map (fun nn -> SelectFormNode (n.forId, nn.nid ) |> updateModelR model)\n                                            |> Option.defaultValue true\n                | AddDimension           -> let n = Dimension.New \"\"\n                                            model.dimensions.Add n\n                                            SelectDimension n.dimId |> updateModelR model\n                //| AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n                //                            true\n            ////    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n            ////                                    model.childrenRels.Value <- model.childrenRels.Value |> Map.add (tid, ch) we\n            ////                                    true\n            ////                                ) |> Option.defaultValue false\n            ////    | RemoveChild (tid, ch)  -> model.childrenRels.Value <- model.childrenRels.Value |> Map.remove (tid, ch)\n            ////                                true\n                | RemoveTotal        tid -> model.totals.RemoveByKey    tid\n                                            setSelection None |> ignore\n                                            model.treeHierarchy.Value \n                                            |> TreeNode.removeNodesEf (TreeNode.forTId ((=) tid))\n                                            |> Render.runEff\n                                            |> ModelUI.setHierarchy model\n                                            true\n                | RemoveCalculation  cid -> setSelection None |> ignore\n                                            model.calculations.RemoveByKey cid\n                                            model.totals.Value\n                                            |> Seq.choose (fun t -> \n                                                let eq, ne = t.children |> Array.partition (fun (_, nid) -> nid = Calc cid )\n                                                if eq.Length = 0 then None else\n                                                Some { t with children = ne }\n                                            )\n                                            |> Seq.iter model.totals.Add\n                                            model.treeHierarchy.Value \n                                            |> TreeNode.removeNodesEf (TreeNode.forCId ((=) cid))\n                                            |> Render.runEff\n                                            |> ModelUI.setHierarchy model\n                                            true\n                | RemoveFormula      fid -> tryFindCalcForm fid\n                                            |> Option.iter(fun calc -> { calc with calFormulas = calc.calFormulas |> Array.filter (fun f -> f.forId <> fid) } \n                                                                       |> model.calculations.Add )\n                                            true\n                | RemoveDimension    did -> model.dimensions.RemoveByKey did\n                                            true\n            ////    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n            ////                                true\n                | SelectNode         nid -> (nid, None    ) |> Some |> setSelection\n                | ExpandNode    (ex, nid)-> let rec mapper finished (node:Tree.TreeNode) =\n                                                if finished             then node                       , true\n                                                elif node.nid = nid     then { node with expanded = ex }, true\n                                                else let ch, dn = node.children |> Seq.mapFold mapper false\n                                                     { node with children = Seq.toArray ch }            , dn\n                                            model.treeHierarchy.Value \n                                            |> Seq.mapFold mapper false \n                                            |> fst\n                                            |> Seq.toArray\n                                            |> model.treeHierarchy.Set\n                                            true\n                | IndentNode   (iin, nid)-> let indent = if iin then TreeEff.indentNode else TreeEff.outdentNode\n                                            eff {\n                                                let! nodeO = model.treeHierarchy.Value |> TreeNode.tryFindNodeEf nid\n                                                match nodeO with\n                                                | None      -> ()\n                                                | Some node ->\n                                                    let! nodes = TreeNode.treenode node\n                                                              |> swap indent (Seq.map TreeNode.treenode model.treeHierarchy.Value) \n                                                    nodes \n                                                    |> Seq.map TreeNode.ofNode\n                                                    |> ModelUI.setHierarchy model\n                                            } |> Render.iterEff id\n                                            true\n                | MoveNode(aft,fnid,tnid)-> TreeEff.moveToSibling2 aft fnid tnid (Seq.map TreeNode.treenode model.treeHierarchy.Value)\n                                            |>> Seq.map TreeNode.ofNode\n                                            |>> ModelUI.setHierarchy model\n                                            |> Render.iterEff id\n                                            true\n                | SelectFormNode(fid,nid)-> (nid, Some fid) |> Some |> setSelection\n                | SelectTotal        tid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeTIdEf tid  |>> Option.map (fun n -> n.nid, None    ) |>> setSelection |> Render.runEff\n                | SelectCalculation  cid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeCIdEf cid  |>> Option.map (fun n -> n.nid, None    ) |>> setSelection |> Render.runEff\n                | SelectFormula      fid -> tryFindCalcForm fid       |> Option.map(fun c -> c.calId)   |>  Option.map (fun cid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeCIdEf cid)\n                                                                         |> insertO |>> Option.bind id |>>  Option.map (fun n -> n.nid, Some fid) |>> setSelection |> Render.runEff\n                | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n                                            |> (fun s -> if s = model.selectedDim.Value then false else\n                                                         model.selectedDim.Value    <- s\n                                                         true)\n                | AddCalcDim   (cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.add    did }\n                                            false\n                | RemoveCalcDim(cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.remove did }\n                                            false\n                | AddCube      (n, ds)   -> model.cubes.Add <| Cube.newCubeCalc n (ds |> Seq.toArray) None\n                                            false\n                | RemoveCube    cid      -> model.cubes.RemoveByKey cid\n                                            false\n                | RenameCube   (cid, n)  -> doForCube cid <| fun c -> model.cubes.Add { c with cubName = n }\n                                            false\n                | _ -> printfn \"Msg not implemented: %A\" msg ; false\n        \n            \n            let updateModel model msg = if updateModelR model msg then ModelUI.refreshNow()\n            processor <- updateModel model\n        //#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#define FSS_SERVER\n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            let varInt  = Var.Create 1\n            printfn \"varInt %A\" varInt.Value\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n                Content.Page(Title = \"Main Page\" \n                           , Body  = [\n                                Html.client <@ MainProgram.mainProgram() @>\n                                Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                             ])\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
