{
"version": 3,
"sourceRoot": "Source",
"sources": ["RuleEditor/RuleEditor.fs"],
"sourcesContent": ["#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1547097944900 -d:WEBSHARPER\n////#cd @\"..\\projects\\RuleEditor\\src\"\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1547097944900\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            [< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDay()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\n            let nowStamp() = \n                let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n                t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n            \n            let [<Inline>] inline traceT t v = tee (sprintf \"%A\" >> (fun s -> s.[..min 100 s.Length-1]) >> printfn \"%s %s: %A\" (nowStamp()) t) v\n            let [<Inline>] inline trace   v = traceT \"trace\" v\n            let [<Inline>] inline traceI  v = trace          v |> ignore\n            \n            module Log =\n                let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n                let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n                let [<Inline>] inline InA    n f p = async { return! In  n f p }\n                let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n                let [<Inline>] inline InOut  n     = In  n >> Out  n\n                let [<Inline>] inline InOutA n f p = async {\n                    let!   r = InA n f  p\n                    do         Out n id r |> ignore\n                    return r \n                  }\n            \n                let [<Inline>] inline TimeIt n f p =\n                    printfn \"Starting %s\" n\n                    let start = System.DateTime.UtcNow.Ticks\n                    f p\n                    let elapsedSpan = new System.TimeSpan(System.DateTime.UtcNow.Ticks - start)\n                    print <| elapsedSpan.ToString()\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let warningf  fmt = Printf.ksprintf Warning  fmt\n                let infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let rtn                          = Ok\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | Ok    v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                       | Error e ->       e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                /// Taken from Nick Palladino's https://github.com/palladin/Eff\n                [< AutoOpen >]\n                module Eff =\n                    open System\n                \n                    type Effect = abstract UnPack     : Lambda         -> Effect \n                    and  Lambda = abstract Invoke<'X> : ('X -> Effect) -> ('X -> Effect)\n                \n                    type Eff<'U, 'A when 'U :> Effect> = Eff of (('A -> Effect) -> Effect) \n                        with  member this.Cont = match this with Eff cont -> cont\n                \n                    type Done<'A>(v : 'A) =\n                        member self.Value = v\n                        interface Effect with member self.UnPack(_ : Lambda) : Effect = self :> _ //new Done<'A>(v) :> _\n                \n                    let inline rtn  v = Eff (fun k -> k v)\n                    let bind  (f: 'a -> Eff<'U, 'b>) (effA: Eff<'U, 'a>) : Eff<'U, 'b> = \n                                        Eff (fun k -> \n                                                let (Eff effKa) = effA\n                                                effKa (fun v -> \n                                                    let (Eff effKb) = f v\n                                                    effKb k\n                                                )\n                                            )\n                \n                    module Eff =\n                //        [< Inline \"$effect.FsRoot_Library_Monads_Eff_Effect$UnPack({FsRoot_Library_Monads_Eff_Lambda$Invoke:function(k) { return function(p) { return $loop(k(p)) }; }})\" >]\n                //        let unpack loop (effect:Effect) = effect.UnPack { new Lambda with member self.Invoke<'X> (k' : 'X -> Effect) =  k' >> loop }\n                \n                        type LambdaT(loop) =\n                            interface Lambda with\n                                member __.Invoke<'X> (k : 'X -> Effect) : ('X -> Effect) = k >> loop \n                        let unpack loop (effect:Effect) = effect.UnPack (new LambdaT(loop))\n                        let done' (v :  'A) : Effect                           = new Done<'A>(v) :> _ \n                        let return' v  = Eff( fun _ -> done' v )\n                        let run<'U, 'A when 'U :> Effect> (eff: Eff<'U, 'A>) : 'A =\n                            match eff.Cont done' with\n                            | :? Done<'A> as done' -> done'.Value\n                            | v                    -> failwithf \"Unhandled effect %A\" v\n                        let runResult<'U, 'A when 'U :> Effect> (eff: Eff<'U, 'A>) = \n                            try\n                                match eff.Cont done' with\n                                | :? Done<'A> as done' -> Ok done'.Value\n                                //| v                    -> box v |> unbox<NoOp<_>> |> fun noop -> noop.K () |> loop\n                                | v                    -> Error <| errorMsgf \"Unhandled effect %A expecting\" v //typedefof<'A>\n                            with e -> \n                                Error <| ResultMessage.ExceptMsg(e.Message, e.StackTrace)\n                \n                \n                    let inline map   f  m  = bind (f >> rtn) m\n                    let inline apply fR vR = fR |> bind (fun f -> map f vR)\n                    \n                    [< AutoOpen >]\n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)\n                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)\n                    \n                    type EffBuilder() = \n                        member self.Zero      (                 ) = rtn ()\n                        member self.Return    (v   :         'A ) = rtn v\n                        member self.ReturnFrom(eff : Eff<'U, 'A>) = eff\n                        member self.Bind      (eff, f           ) = bind f eff\n                        member self.Combine (first : Eff<'U, unit>, second : Eff<'U, 'B>) : Eff<'U, 'B> =  self.Bind(first, fun () -> second)\n                        member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)\n                    //    member inline __.Delay       f                  = f\n                        member __.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                        member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                        member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                    let body' = fun () -> body disposable\n                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    fun () -> this.Delay(fun () -> body enum.Current)))\n                    \n                    \n                    let eff = new EffBuilder()\n                    \n                    module Reader = \n                        type Reader<'E> = inherit Effect\n                        type Ask<'E>(k : 'E -> Effect) =\n                            member self.K = k\n                            interface Reader<'E> with\n                                member self.UnPack(lambda : Lambda) : Effect = new Ask<'E>(lambda.Invoke<'E> k) :> _\n                    \n                        let ask<'U, 'E when 'U :> Reader<'E>>() : Eff<'U, 'E> = Eff (fun k -> new Ask<'E>(k) :> _)\n                    \n                        let rec readerHandler<'U, 'E, 'A when 'U :> Reader<'E>> (env:'E) (eff: Eff<'U, 'A>) : Eff<'U, 'A> = \n                            let rec loop : Effect -> Effect = function\n                                | :? Ask< 'E> as ask   -> ask.K env          |>            loop \n                                | effect               -> effect             |> Eff.unpack loop \n                            Eff (fun doneK             -> eff.Cont Eff.done' |>            loop )\n                    \n                        type EffReader<'a> = inherit Reader<'a>\n                    \n                        let readerFun f = ask() |> map f \n                    \n                        \n                    module Rsl = \n                        type Rsl<'M> = inherit Effect\n                    \n                        type Fail<    'M>(v : 'M, k : unit -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Rsl<'M> with member self.UnPack(lambda : Lambda) : Effect = new Fail<    'M>(v, lambda.Invoke<unit> k) :> _\n                    \n                    \n                        let fail<'U, 'M when 'U :> Rsl<'M>> (s:'M) : Eff<'U, unit> = Eff (fun k -> new Fail<    'M>(s, k) :> _)\n                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {\n                            match res with\n                            | Ok    v   -> return v\n                            | Error msg -> let! m = fail msg\n                                           return box () |> unbox\n                        }\n                    \n                        \n                        let rec RslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = \n                            let rec loop (doneK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function\n                                | :? Done<    'A> as done' -> doneK (Ok    done'.Value)\n                                | :? Fail<    'M> as fail  -> doneK (Error fail .Value)\n                                | effect                   -> effect             |> Eff.unpack (loop doneK)\n                            Eff (fun doneK                 -> eff.Cont Eff.done' |>             loop doneK)\n                    \n                        let inline absorbR     vvEf             = vvEf  |> bind ofResult\n                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR\n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofAsync            a  = FAM(fun (s, r) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                    let inline ofFusionM     (FM fm) = FAM(fun (s, r) -> async.Return (fm (s, r)) )\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n            module Array =\n            \n                /// Non-mutable element replace\n                /// produces a new array with the new element\n                let replace i item (array: _[]) = \n                    seq {\n                        if i > 0            then yield! array.[.. i - 1]\n                        yield item\n                        if i < array.Length then yield! array.[i + 1 ..]\n                    } |> Seq.toArray\n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n                \n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n            /// Adapted from here http://fssnip.net/7V5   Usage:\n            /// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n            ///         \n            /// abs  1 |> printfn \"%A\" // 1\n            /// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\n            type Hole = Hole with\n                [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n                static member inline Incomplete id : 'T = failwithf \"Incomplete hole '%s'\" id        \n                    \n            \n            /// Tree structure to implement a hierarchical user interface but using Eff Reader and Rsl monad\n            module TreeEff =\n            \n                type Node<'I, 'T, 'Eff when 'Eff :> Effect> = {\n                    id                : unit                   -> 'I\n                    getData           : unit                   -> 'T\n                    isExpandedEf      : unit                   -> Eff<'Eff, bool                     >\n                    canHaveChildrenEf : unit                   -> Eff<'Eff, bool                     >\n                    childrenEf        : unit                   -> Eff<'Eff, Node<'I, 'T, 'Eff> seq   >\n                    pathEf            : unit                   -> Eff<'Eff, 'I list                  >  // list of parents excluding itself\n                    parentOEf         : Node<'I, 'T, 'Eff> seq -> Eff<'Eff, Node<'I, 'T, 'Eff> option>\n                    newChildrenEf     : Node<'I, 'T, 'Eff> []  -> Eff<'Eff, Node<'I, 'T, 'Eff>       >  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n                }\n            \n                //let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n                //let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n            \n                let rec listNodes level (nodes: Node<_,_,_> seq) =\n                    nodes\n                    |> Seq.map(fun node -> \n                        node.isExpandedEf() \n                        >>= (fun exp -> if exp then node.childrenEf() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n                        |>> (fun nodes -> Seq.append [ node, level ] nodes)\n                    ) \n                    |> sequenceSeq\n                    |>> Seq.collect id\n            \n                let removeNode (node:Node<_,_,_>) nodes = eff { // better use version removeNode2\n                    let! path = node.pathEf()\n                    printfn \"path = %A\" path\n                    let rec chRemove (n:Node<_,_,_>) = eff {\n                        if                  n.id() = node.id() then printfn \"found it\" ; return  None\n                        elif List.contains (n.id())  path      then printfn \"deeper\" ; return! n.childrenEf()\n                                                                            |>> Seq.toArray\n                                                                            |>> Seq.map chRemove \n                                                                            >>= sequenceSeq \n                                                                            |>> Seq.choose id \n                                                                            |>> Seq.toArray\n                                                                            >>= n.newChildrenEf  \n                                                                            |>> Some\n                        else                                        printfn \"not\" ;return  Some n\n                    }\n                    return! nodes |> Seq.map chRemove |> sequenceSeq |>> Seq.choose id\n                }\n            \n                let removeNodes p nodes = eff {\n                    let rec folder pair (n:Node<_,_,_>) = eff {\n                        let! children, noparent = pair\n                        let! children2 = n.childrenEf() |>> Seq.toArray\n                        let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n                        if p n then return (        children, ch @ np)\n                               else let! xxx = n.newChildrenEf (ch |> Seq.rev |> Seq.toArray)\n                                    return ( xxx :: children,      np)\n                    }\n                    let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n                    return noparent @ res |> List.rev\n                }\n            \n                let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n                    seq [ for n in nodes do\n                            if p n then\n                                if after then yield n    ; yield node\n                                else          yield node ; yield n\n                            else              yield n\n                    ]\n                    \n                let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenEf\n            \n                let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n                    sibling.pathEf() >>= function\n                    | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n                    | parent :: path -> \n                    let rec mapAdd (n:Node<_,_,_>) =\n                        if                  n.id() = parent then     n.childrenEf() |>> Seq.toArray >>= addToParent after theSibling node n\n                        elif List.contains (n.id()) path    then     n.childrenEf() |>> Seq.toArray |>> Seq.map mapAdd >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenEf \n                        else                                     rtn n\n                    nodes |> Seq.map mapAdd |> sequenceSeq\n            \n                let tryFind p (nodes:Node<_,_,_> seq) = \n                    let rec folder resEf (node:Node<_,_,_>) =\n                        resEf >>= function\n                        | Some v -> rtn (Some v)\n                        | None   ->\n                        if p node then rtn <| Some node else \n                        node.childrenEf() >>= Seq.fold folder (rtn None)\n                    nodes                 |>  Seq.fold folder (rtn None)\n                    \n                let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n            \n                let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    nodes\n                    |>  removeNode node\n                    >>= addSibling after node sibling\n            \n                let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = eff {\n                    let!  nodeO = nodes |> tryFindId nodeId\n                    match nodeO with\n                    | None         -> return  nodes\n                    | Some node    ->\n                    let!  siblingO = nodes |> tryFindId siblingId\n                    match siblingO with\n                    | None         -> return  nodes\n                    | Some sibling -> return! moveToSibling after node sibling nodes\n                }\n            \n                let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = eff {\n                    let! path = parentN.pathEf()\n                    let rec mapAppend (n:Node<_,_,_>) =\n                        if   n.id() = parentN.id()       then \n                            if append                    then n.childrenEf() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenEf\n                            else                              n.childrenEf() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenEf\n                        elif List.contains (n.id()) path then n.childrenEf() |>> Seq.toArray |>>      Seq.map mapAppend   >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenEf\n                        else                                  rtn n\n                    return! nodes |> Seq.map mapAppend |> sequenceSeq\n                }\n            \n                let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    node.parentOEf nodes >>= function\n                    | None        -> rtn nodes\n                    | Some parent -> parent.childrenEf() |>> (Seq.toArray >> Seq.ofArray)\n                    |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n                    >>= Seq.fold      (fun newParentOEf n -> n.canHaveChildrenEf() >>= (fun can -> if can then rtn(Some n) else newParentOEf)) (rtn None)\n                    >>= function\n                    | None           -> rtn nodes\n                    | Some newParent ->\n                    nodes\n                    |>  removeNode node \n                    >>= addChild true node newParent\n            \n                let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.parentOEf nodes\n                    |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n                    >>= Option.defaultValue (rtn nodes)\n                    \n                let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.childrenEf()\n                    >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n                    >>= removeNode node\n                    \n                \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            module Var =\n                let mutable private counter = 1\n                let freshId () =\n                    counter <- counter + 1\n                    \"varuid\" + string counter\n                        \n                let lensView get update view0 (var: Var<_>) =\n                    let id   = freshId()\n                    let view = View.Map2 (fun v _ -> get v) var.View view0\n                    { new Var<'V>() with\n                        member this.Get        () = get (var.Get())\n                        member this.Set         v = var.Update(fun t -> update t v)\n                        member this.SetFinal    v = this.Set(v)\n                        member this.Update      f = var.Update(fun t -> update t (f (get t)))\n                        member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n                        member this.View          = view\n                        member this.Id            = id\n                    }\n            \n            module ListModel =\n                let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.FindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.TryFindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let lensDef def k (m:ListModel<_,_>) =\n                    let get = Option.defaultValue def\n                    lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n            \n                let currentLensUpd def curr upd (model:ListModel<_,_>) = \n                    curr \n                    |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                                    (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                                    model.View\n                let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n                    let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n                    Var.Make view upd\n                let currentLens def curr (model:ListModel<_,_>) = \n                    model \n                    |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n                \n            \n            /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n            /// onChange gets called when the editor changes but not when the var changes\n            let bindVarEditor setEvent getVal setVal onChange (var:Var<string>) =\n                let editorChanged = ref 0L\n                let varChanged    = ref 0L\n                setEvent(fun _ ->\n                    let v = getVal() \n                    if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange() \n                )\n                var.View |> View.Sink (fun _ ->\n                    if  !editorChanged > !varChanged then varChanged := !editorChanged\n                    elif getVal() <> var.Value then setVal var.Value\n                )\n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module LoadFiles =\n            \n                let createScript fn =\n                    let fileRef = JS.Document.CreateElement(\"script\")\n                    fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n                    fileRef.SetAttribute(\"src\" , fn                 )\n                    fileRef\n                \n                let createCss fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n                    fileRef.SetAttribute(\"type\", \"text/css\"       )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let createHtml fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"import\"         )\n                    fileRef.SetAttribute(\"type\", \"text/html\"      )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let LoadFile(file: string) =\n                    let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n                    match file with\n                    | EndsWith \".js\"   ()\n                    | EndsWith \".fsx\"  ()\n                    | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                            createScript file |> Some\n                    | EndsWith \".css\"  ()-> createCss    file |> Some\n                    | EndsWith \".html\" ()-> createHtml   file |> Some\n                    | _                  -> None\n                    |> Option.map         (fun ref -> \n                        Async.FromContinuations <| \n                            fun (cont, econt, _ccont) -> \n                                try \n                                    ref?onload <- cont\n                                    JS.Document.Head.AppendChild ref |> ignore\n                                with e -> econt e\n                    )\n                    |> Option.defaultWith (fun ()  -> async { return () })\n                \n                let LoadFilesAsync(files: string []) =\n                    async {\n                        if IsClient then\n                            for file in files do\n                                do! LoadFile file\n                    }\n                \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            [< JavaScript >]\n            module ResizeObserver =\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module Monaco =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri   = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f)\"  >] static member File(_f)       : Uri   = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8\n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                open WebSharper.Core.Resources\n            \n                type MonacoResources() =\n                    inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n            \n                [< Require(typeof<MonacoResources>) >]\n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (unit   -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        //do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             = \n                    async {\n                      do! loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                          )    \n                        ] []\n                    } |> Doc.Async\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n    \n    module CalculationModel =\n        [< JavaScript >]\n        module CalculationModel =\n            open System\n            \n            type DimType =\n                | DtDataType\n                | DtTime\n                | DtVersion\n                | DtTCalc\n                | DtCalc\n                | DtMeasure\n                | DtOther\n            \n            type CubeType =\n                | CtOther\n                | CtCalc\n                | CtFreeze\n            \n            type AttType =\n                | AtString\n                | AtNumber\n            \n            type ElmType =\n                | EtString\n                | EtNumber\n            \n            type ModId = ModId of Guid with member x.Id = match x with ModId id -> id\n            type AttId = AttId of Guid with member x.Id = match x with AttId id -> id\n            type ElmId = ElmId of Guid with member x.Id = match x with ElmId id -> id\n            type CubId = CubId of Guid with member x.Id = match x with CubId id -> id\n            type DimId = DimId of Guid with member x.Id = match x with DimId id -> id\n            type CalId = CalId of Guid with member x.Id = match x with CalId id -> id\n            type TotId = TotId of Guid with member x.Id = match x with TotId id -> id\n            type ForId = ForId of Guid with member x.Id = match x with ForId id -> id\n            type RulId = RulId of Guid with member x.Id = match x with RulId id -> id\n            \n            type Attribute = {\n                attId          : AttId\n                attName        : string\n                attType        : AttType\n                attTableNum    : int\n            }\n            \n            type Element = {\n                elmId          : ElmId\n                elmDim         : DimId\n                elmType        : ElmType\n                elmName        : string\n                elmDescription : string\n                elmAttributes  : Map<AttId, string> \n                elmParents     : ElmId     []\n            } \n            \n            type Dimension = {\n                dimId               : DimId\n                dimName             : string\n                dimPrefix           : string\n                dimOrder            : string\n                dimExclude          : bool\n                dimFreeze           : bool\n                dimType             : DimType\n                defaultElm          : ElmId     option\n                mutable dimElements : Element   []\n                dimAttributes       : Attribute []\n                isCalcDim           : bool\n            }\n            \n            type UnaryOp = \n                | UoMinus\n                | UoPlus\n                \n            type Operator = \n                | OpAdd      \n                | OpSubtract \n                | OpMultiply \n                | OpDivide   \n                | OpEQ    \n                | OpNE\n                | OpGT       \n                | OpGE       \n                | OpLT       \n                | OpLE       \n                | OpAnd      \n                | OpOr           \n            \n            type Function = Function of string\n            \n            type ElmReference =\n                | ElemFixed   of DimId * ElmId\n                | ElemDynamic of DimId * ExpressionText\n                    \n            and  ExpressionText =\n                | ExtNA\n                | ExtStet\n                | ExtSlice      of Slice\n                | ExtString     of string\n                | ExtDimElement of DimId\n                | ExtDimName    of DimId\n                | ExtFunction   of Function         * ExpressionAny []\n                | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n            \n            and  ExpressionNumber =\n                | ExnNA\n                | ExnStet\n                | ExnSlice      of Slice\n                | ExnNumber     of float\n                | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n                | ExnUnaryN     of UnaryOp          * ExpressionNumber\n                | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n                | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n                | ExnFunction   of Function         * ExpressionAny []\n                | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n                | ExnIsNA       of ExpressionNumber\n                | ExnIsNAt      of ExpressionText\n                | ExnIsNAa      of ExpressionAny\n                \n            and ExpressionAny =    \n                | ExiNA\n                | ExiStet\n                | ExiSlice      of Slice\n                | ExNumeric     of ExpressionNumber\n                | ExText        of ExpressionText\n                | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n                \n            and  Slice = {\n                sliDims     : Map<DimId, ElmReference>   \n                calculation : CalId option\n                cube        : CubId option\n            } \n            \n            type ForType = \n                | ForBase\n                | ForConsolidated\n                | ForAll\n            \n            type Formula = {\n                forId          : ForId\n                forDestDecl    : Map<DimId, string>\n                forDestination : ElmReference list\n                forDescription : string\n                forText        : string\n                forExpression  : ExpressionAny\n                forType        : ForType\n                forOrder       : string\n            }\n            \n            type Calculation = {\n                calId          : CalId\n                calName        : string\n                calDescription : string\n                calOrder       : string\n                format         : string\n                isText         : bool\n                isInput        : bool\n                isBalance      : bool\n                calDims        : Set<DimId>\n                calFormulas    : Formula []\n                cubIdO         : CubId   option\n                properties     : Map<string, string>\n            }\n            \n            type NodeId =\n                | Calc of CalId\n                | Tot  of TotId\n            \n            type Total = {\n                totId          : TotId\n                totName        : string\n                totOrder       : string\n                totFormat      : string\n                children       : (float * NodeId) []\n            }\n            \n            type RuleKey = \n                | RuleKey     of RulId\n                | CalcRuleKey of CalId\n                | FormulaKey  of ForId\n                | ForTextKey  of ForId\n                | ActualRuleKey \n                | InputRuleKey\n                | ConsolidatedRuleKey\n            \n            type Cube = {\n                cubId          : CubId\n                cubName        : string\n                cubRules       : Map<RuleKey, Rule option>\n                cubRuleXmls    : Map<RuleKey, string>\n                cubDims        : DimId []\n                measureDim     : DimId option\n                cubType        : CubeType\n            }\n            \n            and  Rule = {\n                rulId          : RulId\n                rulSourceId    : IComparable\n                rulDescription : string\n                rulDestination : ElmReference list\n                rulExpression  : ExpressionAny\n                rulType        : ForType\n                rulOrder       : string\n                rulXml         : string\n            }\n            \n            type RuleMsg =\n            | GetInitModelStats\n            | GetRulesForCube of CubId\n            \n            type ReplyMsg =\n            | ReplyInformation of string\n            | ReplyRules       of (RuleKey * string) []\n            \n            [<NoComparison ; NoEquality>]\n            type Model = {\n                modId           : ModId\n                server          : string\n                actualElem      : string\n                modDims         : Dimension   []\n                modCubes        : Cube        []\n                modCalculations : Calculation []\n            } \n            \n            let Xmodel = \n              {\n                modId           = ModId <| Guid.NewGuid()\n                server          = @\"local\\Budget\"\n                actualElem      = \"Actual\"\n                modDims         = [||]\n                modCubes        = [||]\n                modCalculations = [||]\n              }\n                \n            let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n            let calcSlice calc : Slice = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = Some calc.calId\n                         cube          = None\n                     }\n                \n            type HelperTypeN = HelperTypeN with\n                static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n                static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n                static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n                static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n                static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n                static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n                \n            let [< Inline >] inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n            \n            type HelperTypeT = HelperTypeT with\n                static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n                static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n                static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n                static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n                static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n            \n            let [< Inline >] inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n            \n            type HelperTypeA = HelperTypeA with\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n            \n            let [< Inline >] inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n        \n            type Message =\n                | DimensionNotFound      of DimId\n                | DimensionHasNoElements of string\n                | ElementNotFound        of string * ElmId\n                | CubeNotFound           of CubId\n                | CubeHasNoMeasureDim    of string\n                | CalculationNotFound    of CalId\n                | CalculationHasNoCube   of string\n        \n            let ofOptF f = Result.ofOption (fun () -> Message <| f())\n            let ofOptS s = Result.ofOption (fun () -> Message <| s  )\n        \n            module internal Model0 =\n                let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n                let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n                let getDimR       dId mdl = getDimO  dId mdl |> Result.ofOption (fun () -> DimensionNotFound   dId)\n        \n            module Element  =\n                let newElement name = \n                  {\n                    elmId          = ElmId <| Guid.NewGuid()\n                    elmDim         = DimId <| Guid.NewGuid()\n                    elmType        = EtString\n                    elmName        = name\n                    elmDescription = name\n                    elmAttributes  = Map.empty\n                    elmParents     = [||]\n                  }\n        \n            module ElmReference =\n                let dimId elr =\n                    match elr with\n                    | ElemFixed  (id, _)\n                    | ElemDynamic(id, _) -> id\n        \n            module Slice =\n                let newSlice ds = {\n                         sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                         calculation   = None\n                         cube          = None\n                }\n                let forAll = {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = None\n                }\n                let addRef      elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n                let containsDim did slc = slc.sliDims |> Map.containsKey did\n           \n            module Dimension =\n                let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n                let getElementR      eId dim = getElementO eId dim |> Result.ofOption (fun () -> ElementNotFound(dim.dimName, eId))\n                let newDimension id name isCalcDim =\n                      {\n                        dimId          = id \n                        dimName        = name\n                        dimPrefix      = \"\"\n                        dimOrder       = \"\"\n                        dimExclude     = false\n                        dimFreeze      = false\n                        dimType        = DtOther\n                        defaultElm     = None\n                        dimElements    = [|  |]\n                        dimAttributes  = [|  |]      \n                        isCalcDim      = isCalcDim\n                      }\n                let newDimensionNonCalc id name  = newDimension id name false\n                let newDimensionCalc    id name  = newDimension id name true \n                let New                    name  = newDimension (DimId <| Guid.NewGuid()) name false\n                let [< Inline >] inline getElmReference it dim =\n                    match toExpT it with \n                    | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                                      let elm =\n                                         dim.dimElements                                 \n                                         |> Seq.tryFind (fun e -> e.elmName = s2)\n                                         |> Option.defaultWith (fun () -> \n                                             let newE = Element.newElement s2\n                                             dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                             newE\n                                         )\n                                      ElemFixed  (dim.dimId, elm.elmId) \n                    | exp          -> ElemDynamic(dim.dimId, exp      )  \n        //        member inline this.Item (it) = getElmReference it this\n                //member inline this.__     it     = this.Item it\n                //member inline this.M      it     = this.Item it\n                //member inline this.E      it     = this.Item it\n                //member inline this.I      it     = this.Item it\n                let prefix  pr   dim  = { dim with dimPrefix = pr   }\n                let dType   dt   dim  = { dim with dimType   = dt   }\n                let setName name dim  = { dim with dimName   = name }\n                let filter     dtypes : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\n                let sort             (ds:Dimension seq)                  = ds |> Seq.sortBy (fun d -> d.dimOrder)\n                let filterSort dtypes : (Dimension seq -> Dimension seq) = filter dtypes >> sort\n        \n            type Dimension with\n                [< Inline >] \n                member inline this.Item (it) = Dimension.getElmReference it this\n        \n        \n            module Cube =\n                let slice cub : Slice  = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = Some cub.cubId\n                     }\n                let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n                let isCalcCube                cub = cub.cubType = CtCalc    \n                let newCubeId id name dims mDimO cType = \n                        {\n                          cubId       = id\n                          cubName     = name\n                          cubDims     = dims\n                          cubRules    = Map.empty\n                          cubRuleXmls = Map.empty\n                          measureDim  = mDimO\n                          cubType     = cType\n                        }\n                let newCube     name            = newCubeId <| CubId (Guid.NewGuid()) <| name\n                let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n                let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n                let New()                       = newCube \"\" [||] None CtOther\n                let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n                let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n                //member inline this.Calc ()    = { this with cubType = CtCalc } \n                let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n                let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n                let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n                let measureDimR     model cub   = cub.measureDim         |> Result.ofOption (fun () -> CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n                let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n                \n            module Calculation =\n                let slice calc = calcSlice calc\n                let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n                let newInput id (name: string) dims  =\n                     {\n                        calId          = id\n                        calName        = name.Replace(\"_\", \" \").Trim()\n                        calDescription = \"\"\n                        calOrder       = \"\"\n                        format         = \"#,##0.00\"\n                        isText         = false\n                        isInput        = true\n                        isBalance      = false\n                        calDims        = dims |> Set \n                        calFormulas    = [||]\n                        cubIdO         = None\n                        properties     = Map.empty\n                     }\n                let newCalc id name dims      = { newInput id name dims     with isInput     = false  }\n                let New        ()             =   newInput (CalId <| Guid.NewGuid()) \"\"   []\n                let setName    name      calc = { calc                   with calName     = name   }\n                let setIsText  istext    calc = { calc                   with isText      = istext }\n                let setOrder   order     calc = { calc                   with calOrder    = order  }\n                let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n                let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n                let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n                let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n                let [< Inline >] getElemRefO(model: Model) calc =\n                    calc.cubIdO \n                    |> Option.bind (swap Model0.getCubeO model)\n                    |> Option.bind (fun cub ->  cub.measureDim) \n                    |> Option.bind (swap Model0.getDimO  model)\n                    |> Option.map  (Dimension.getElmReference calc.calName)\n                let cubeR           c = c.cubIdO        |> ofOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n                let [< Inline >] getElemRefR   m c = getElemRefO m c |> ofOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n                let sort             (cs:Calculation seq)                  = cs |> Seq.sortBy (fun c -> c.calOrder)\n        \n            module Total =\n                let newTotal name  = {\n                    totId          = TotId  <| System.Guid.NewGuid()\n                    totName        = name\n                    totOrder       = \"\"\n                    totFormat      = \"\"\n                    children       = [||]\n                }\n                let New() = newTotal \"\"\n                \n            module Model =\n                let mergeBy f a b = Array.append (Seq.toArray a) (Array.filter (fun e -> a |> Seq.map f |> Seq.contains (f e) |> not ) b)\n                let addCalcs     cs   mdl = { mdl with modCalculations = mergeBy (fun c -> c.calId) cs mdl.modCalculations }\n                let addDims      ds   mdl = { mdl with modDims         = mergeBy (fun c -> c.dimId) ds mdl.modDims         }\n                let addCubes     cs   mdl = { mdl with modCubes        = mergeBy (fun c -> c.cubId) cs mdl.modCubes        }\n                let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n                let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n                let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n                let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n                let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n                let getDimO               = Model0.getDimO\n                let getDimR               = Model0.getDimR\n                let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n                let getCubeO              = Model0.getCubeO\n                let getCalcR      cId mdl = getCalcO cId mdl |> Result.ofOption (fun () -> CalculationNotFound cId)\n                let getCubeR      cId mdl = getCubeO cId mdl |> Result.ofOption (fun () -> CubeNotFound        cId)\n                let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n                let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n                let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n                let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n                let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n                let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n                let timeDimO          mdl = pickDimO  DtTime     mdl\n                let versionDimO       mdl = pickDimO  DtVersion  mdl\n                let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n                let getCalcCube dims  mdl = \n                    mdl.modCubes \n                    |> Seq.filter  Cube.isCalcCube\n                    |> Seq.tryFind (fun cub -> \n                        cub.cubDims \n                        |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                        |> Set = dims )\n                let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n                let withDimsO mdl cube f =\n                    let (<*>)   = Option.apply\n                    let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n                    Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n                let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n                let dimCombinations model =\n                    model.modCalculations\n                    |>  Seq.map (fun c -> c.calDims)\n                    |>  Seq.distinct \n                let cubePrefix    = \"Z\"\n                let measurePrefix = \"M\"\n                let orderedDims dimIds model =\n                        model.modDims \n                        |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n                let autoName dimIds model =\n                    let nameBase =\n                        model\n                        |> orderedDims dimIds\n                        |> Seq.map (fun d -> d.dimPrefix)\n                        |>  String.concat \"\"\n                    let similar =\n                        model.modCubes\n                        |> Seq.choose (fun c -> \n                            match cubePrefix + nameBase with\n                            | n when c.cubName          = n -> Some -1\n                            | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> ParseO.parseIntO\n                            | _                             -> None\n                        ) \n                    nameBase\n                  + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n            \n                let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n                let fixForDimensions model =\n                    //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n                    let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n                    { model with modCalculations = calcs }\n                let newCalcCube dimIds model =\n                    let name = autoName dimIds model\n                    let mDim = Dimension.newDimensionCalc <| DimId (Guid.NewGuid()) <| measurePrefix + name\n                    let orderedDimIds = \n                        model\n                        |> orderedDims dimIds\n                        |> Seq.append <| [ mDim ]\n                        |> Seq.map (fun d -> d.dimId)\n                        |> Seq.toArray\n                    let dims  = Array.append model.modDims  [| mDim                                                                 |]\n                    let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n                    { model with modDims = dims ; modCubes = cubes }\n                let fixCalcsAndCubes model =\n                    let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cubIdO |> Option.bind (swap getCubeO model) |> Option.isNone)\n                    if Seq.isEmpty calNoCube then model else\n                        let modelN =\n                            calNoCube\n                            |> Seq.map      (fun c -> c.calDims)\n                            |> Seq.distinct\n                            |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                            |> Seq.fold      (swap newCalcCube) model\n                        let calcs =\n                            modelN.modCalculations\n                            |> Array.map (fun oldC ->\n                                    calNoCube \n                                    |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                                    |> Option.map  (fun newC -> { newC with Calculation.cubIdO = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                                    |> Option.defaultValue oldC\n                              )\n                        { modelN with modCalculations = calcs }\n                let prepareModel model =\n                    model\n                    |> fixForDimensions \n                    |> fixCalcsAndCubes\n                let addRules rules model =\n                    rules\n                    |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n                    |> Seq.fold (fun mdl (cubId, rules) ->\n                        getCubeO cubId mdl\n                        |> Option.map(fun cube ->\n                            rules \n                            |> Seq.map (fun (_, key, rule) -> key, rule)\n                            |> Cube.addRules <| cube\n                            |> swap setCube mdl\n                        )\n                        |> Option.defaultValue mdl\n                    ) model\n                    \n            \n            module Formula =\n                let [< Inline >] inline newFormula id dest exp  typ =\n                      {\n                          forId          = id\n                          forDestDecl    = Map.empty\n                          forDestination = dest\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = toExpA exp\n                          forType        = typ\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline newBase    id expr      = newFormula id []   expr ForBase        \n                let [< Inline >] inline newBaseFor id expr dest = newFormula id dest expr ForBase        \n                let [< Inline >] inline newCons    id expr      = newFormula id []   expr ForConsolidated\n                let [< Inline >] inline newConsFor id expr dest = newFormula id dest expr ForConsolidated\n                let [< Inline >] inline newAll     id expr      = newFormula id []   expr ForAll         \n                let [< Inline >] inline newAllFor  id expr dest = newFormula id dest expr ForAll         \n                let [< Inline >] inline New        ()        =\n                      {\n                          forId          = ForId <| Guid.NewGuid()\n                          forDestDecl    = Map.empty\n                          forDestination = []\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = ExiStet\n                          forType        = ForBase\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline forId      f         = f.forId\n                let                     conso      frm       = { frm with forType  = ForConsolidated }\n                let                     setText    txt  frm  = { frm with forText  = txt             }\n                let                     setOrder   ord  frm  = { frm with forOrder = ord             }\n                let getDimDest dim frm = \n                    frm.forDestination \n                    |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n                \n        \n            module Rule =\n                let [< Inline >] inline newRule0     dest exp typ order =\n                      {\n                          rulId          = RulId <| Guid.NewGuid()\n                          rulDestination = dest\n                          rulDescription = \"\"\n                          rulExpression  = exp\n                          rulType        = typ\n                          rulOrder       = order\n                          rulSourceId    = None\n                          rulXml         = \"\"\n                      }\n                let [< Inline >] inline newRule     dest exp typ order = newRule0     dest (toExpA exp) typ order\n                let [< Inline >] inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n                let New() = newRule0 [] ExiStet ForBase \"\"\n                let conso rul = { rul with rulType = ForConsolidated }    \n            \n            module Attribute =\n                let New() = \n                    {\n                        attId            = AttId <| Guid.NewGuid()\n                        attName          = \"\"\n                        attTableNum      = 1\n                        attType          = AtString\n                    }\n            \n    //#cd @\"..\\projects\\RuleEditor\\src\"\n    //#define WEBSHARPER\n    [< JavaScript >]\n    module RuleEditor =\n        //#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n         \n        module Tree =\n            open CalculationModel.CalculationModel\n            open TreeEff\n        //    open FusionM\n            open Operators\n        \n            type TreeNodeId = TreeNodeId of System.Guid\n        \n            type Weight =\n            | Zero\n            | Add\n            | Subtract\n        \n            type TreeNode = {\n                nid      : TreeNodeId\n                expanded : bool\n                element  : NodeId\n                children : TreeNode []\n                weight   : Weight\n            } \n        \n            type TreeCollection = {\n                getParentO  :                 TreeNodeId -> TreeNode option\n                getNode     :                 TreeNodeId -> TreeNode\n                getPath     :                 TreeNodeId -> TreeNodeId list\n                setChildren : TreeNode seq -> TreeNodeId -> TreeNode\n            }\n        \n            let getParentOEf  nid    = Reader.ask() |>> fun treeC -> treeC.getParentO     nid\n            let getNodeEf     nid    = Reader.ask() |>> fun treeC -> treeC.getNode        nid\n            let getPathEf     nid    = Reader.ask() |>> fun treeC -> treeC.getPath        nid\n            let setChildrenEf nid ch = Reader.ask() |>> fun treeC -> treeC.setChildren ch nid\n        \n        //        static member FromNode (n:Tree.Node<_>) = n :?> TreeNode\n        //        interface Tree.Node<TreeNodeId> with\n        //            member node.Id                 = node.nid\n        //            member node.isExpanded         = node.expanded\n        //            member node.canHaveChildren    = match node.element with | Calc _ -> false | _ -> true\n        //            member node.path               =   \n        //                let rec getPath nid = parents |> Dict.tryGetValue nid |> Option.map Tree.toNode |> Option.map (fun n -> n.Id :: n.path) |> Option.defaultValue []\n        //                getPath node.nid\n        //            member node.children           =   node     .children   |> Tree.toSeqNode\n        //            member node.newChildren     ch = { node with children = ch \n        //                                                                    |> Seq.map   (fun n -> n :?> TreeNode    ) \n        //                                                                    |> Seq.filter(fun n -> \n        //                                                                        parents \n        //                                                                        |> Dict.tryGetValue n.nid \n        //                                                                        |> Option.map (fun v -> \n        //                                                                            if v :?> TreeNode <> node then \n        //                                                                                parents.Remove n.nid |> ignore\n        //                                                                                parents.Add(n.nid, node)\n        //                                                                        )\n        //                                                                        |> Option.defaultWith(fun () ->\n        //                                                                            parents.Add(n.nid, node)\n        //                                                                        )\n        //                                                                        true)\n        //                                                                    |> Seq.toArray } |> Tree.toNode\n        //            member node.parent          ns = parents |> Dict.tryGetValue node.nid |> Option.map Tree.toNode\n        \n        module TreeNode =\n            open Tree\n            open TreeEff\n            open CalculationModel.CalculationModel\n        \n            let fromNode    n  = n.getData()\n            let rec treenode (node:TreeNode) =\n                {\n                    id                 = fun () -> node.nid\n                    getData            = fun () -> node\n                    isExpandedEf       = fun () -> rtn <| node.expanded\n                    canHaveChildrenEf  = fun () -> rtn <| match node.element with | Calc _ -> false | _ -> true\n                    childrenEf         = fun () -> node.children |> Seq.map treenode |> rtn \n                    newChildrenEf      = fun ch -> node |> treenode |> rtn// ch |> Seq.map fromNode |> setChildrenEf node.nid |>> treenode      \n                    parentOEf          = fun _ns-> getParentOEf                            node.nid |>> Option.map treenode\n                    pathEf             = fun () -> getPathEf                               node.nid\n                }\n        \n            let fromSeqNode ns = ns |> Seq.map fromNode \n        \n            let newTreeNode ch = {\n                nid      = TreeNodeId <| System.Guid.NewGuid()\n                expanded = true\n                children = [||]\n                element  = ch\n                weight   = Add\n            }\n            let newNodeCalc cid = newTreeNode <| Calc cid\n            let newNodeTot  tid = newTreeNode <| Tot  tid\n            let removeNodesEf    p   (nodes: TreeNode seq) = nodes |> Seq.map treenode |> TreeEff.removeNodes (fromNode >> p) |>> fromSeqNode\n            let getElement n = n.element\n            let getTId = function | Tot  tid -> Some tid | _ -> None\n            let getCId = function | Calc cid -> Some cid | _ -> None\n            let forTId p = getElement >> getTId >> (Option.map p ) >> Option.defaultValue false\n            let forCId p = getElement >> getCId >> (Option.map p ) >> Option.defaultValue false\n        \n            let tryFindTreeNodeEf  p   (nodes: TreeNode seq) = nodes |> Seq.map treenode |> TreeEff.tryFind     (fromNode >> p) |>> Option.map fromNode\n            let tryFindNodeEf      nid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (fun n -> n.nid = nid)\n            let tryFindSelNodeEf   sel (nodes: TreeNode seq) = sel   |> Option.map fst     |> Option.map (swap tryFindNodeEf nodes) |> insertO |>> Option.bind id\n            let tryFindSelChildEf  sel (nodes: TreeNode seq) = nodes |> tryFindSelNodeEf sel |>> Option.map getElement\n            let tryFindNodeTIdEf   tid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (forTId ((=) tid) )\n            let tryFindNodeCIdEf   cid (nodes: TreeNode seq) = nodes |> tryFindTreeNodeEf (forCId ((=) cid) )    \n        \n        module Monaco =\n            open Monaco\n            type HoverProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideHover(model:Model, pos:Position, token:obj) =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      {\n                          contents = { value = word?word |> sprintf \"The word is: %s\" ; isTrusted = true } |> Array.singleton\n                          range    = {\n                                        startLineNumber = pos.lineNumber\n                                        endLineNumber   = pos.lineNumber\n                                        startColumn     = word.startColumn\n                                        endColumn       = word.endColumn\n                                     }\n                      }\n        \n            type CompletionItemProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj): CompletionItem[] =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      [|\n                        { kind = CompletionItemKind.Function ; label = \"Hello\"   ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"How\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"Are\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = \"You\"     ; detail = \"\"}\n                        { kind = CompletionItemKind.Function ; label = word?word ; detail = \"\"}\n        \n                      |]\n                  member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n            type DefinitionProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideDefinition(model: Model, pos: Position, token: obj): Location =\n                      let word = model.GetWordAtPosition pos\n                      if isUndefined word then box null |> unbox else\n                      let ms = model.FindMatches(word.word, false, false, true, \" <>()+-=.,/#@$%^&*\\\"\", false, 1)\n                      if ms.Length = 0    then box null |> unbox else\n                      { range = ms.[0].range\n                        uri = model.uri\n                      }\n        \n            let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\\nHint (4, 7) - (4, 12): \\\"This shows over there as a hint\\\".\"\n            let transformAnnotations msgs =\n                let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                             -> Some (ty, int fl, int fc, int tl, int tc, msg)\n                    | _      -> None\n                )\n                |> Array.map (fun (ty, fl, fc, tl, tc, msg) ->\n                        { message  = msg\n                          severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                          startColumn     = fc\n                          endColumn       = tc\n                          startLineNumber = fl\n                          endLineNumber   = tl\n                        }\n                  )        \n                    \n                \n            let monacoNew        (var           : Var<string>                         ) \n                                 (annotationsWO : View<MarkerData []>           option) \n                                 (showToolTipO  :(string -> int -> int -> unit) option) \n                                 (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                               -> string -> int -> int -> unit) option) =\n            \n                let setDirtyCond() = ()\n                let getHints    _  = ()\n                                    \n                Monaco.newVar var\n                |> onRender(fun ed -> \n                    Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                    Editor.SetTheme(\"vs-dark\")\n                    let hp = new HoverProvider         (ed)\n                    let cp = new CompletionItemProvider(ed)\n                    let dp = new DefinitionProvider    (ed)\n                    hp.provideHover |> print\n                    cp.provideCompletionItems |> print\n                    cp.resolveCompletionItem  |> print\n                    dp.provideDefinition      |> print\n                    Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                    Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                    Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                    annotationsWO\n                    |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) \n                    )\n                )\n        //#r @\"Compiled\\CalculationModelDll\\CalculationModelDll.dll\"\n        open CalculationModel.CalculationModel\n        \n        type Selection  = (Tree.TreeNodeId * (ForId option)) option\n        \n        type Version = {\n            major     : int\n            minor     : int\n            majorDate : string\n            minorDate : string\n        }\n        \n        module Version =\n            let New() = {\n                major     = 0\n                minor     = 0\n                majorDate = \"\"\n                minorDate = \"\"\n            }\n            let incrementMinor v = { v with minor = v.minor + 1; minorDate = nowStamp() }\n            let incrementMajor v = {        major = v.major + 1; majorDate = nowStamp()\n                                            minor = 0          ; minorDate = nowStamp() }\n        \n        type ModelUI = {\n            treeHierarchy : Var<Tree.TreeNode []>\n            calculations  : ListModel<CalId        , Calculation>\n            totals        : ListModel<TotId        , Total      >\n            dimensions    : ListModel<DimId        , Dimension  >\n            cubes         : ListModel<CubId        , Cube       >\n            globalDefs    : Var<string>\n            server        : Var<string>\n            selection     : Var<Selection>\n            selectedDim   : Var<DimId option>\n            selectedCube  : Var<CubId option>\n            collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n            cubePrefix    : Var<string>\n            measurePrefix : Var<string>\n            outputMsgs    : Var<string>\n            codeFS        : Var<string>\n            parserMsgs    : Var<string>\n            fileName      : Var<string>\n            version       : Var<Version>\n        }\n        \n        type MsgModel =\n        | AddTotal\n        | SelectTotal       of TotId\n        | RemoveTotal       of TotId\n        | AddCalculation\n        | RemoveCube        of CubId\n        | RenameCube        of CubId * string\n        | AddCube           of         string * Set<DimId>\n        | RemoveCalculation of CalId\n        | SelectCalculation of CalId\n        | AddFormula        of CalId\n        | RemoveFormula     of ForId\n        | SelectFormula     of ForId\n        | SelectFormNode    of ForId * Tree.TreeNodeId\n        | SelectNode        of         Tree.TreeNodeId\n        | ExpandNode        of bool  * Tree.TreeNodeId\n        | IndentNode        of bool  * Tree.TreeNodeId\n        | MoveNode          of bool  * Tree.TreeNodeId * Tree.TreeNodeId\n        | AddDimension\n        | RemoveDimension   of DimId\n        | SelectDimension   of DimId\n        | AddFormDim        of ForId * DimId * string\n        | RemoveFormDim     of ForId * DimId\n        | RemoveCalcDim     of CalId * DimId\n        | AddCalcDim        of CalId * DimId\n        | RemoveForDest     of CalId * ForId * DimId \n        | SetForDest        of CalId * ForId * DimId * string\n        | SaveTextFile      of string\n        | LoadTextFile      of string\n        | NoOp\n        \n        module ModelUI =\n            let isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\n            let selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n            \n            let nonTotal        = { Total      .New()                with totId = TotId System.Guid.Empty }\n            let nonCalculation  = { Calculation.New()                with calId = CalId System.Guid.Empty } \n            let nonFormula      = { Formula    .New()                with forId = ForId System.Guid.Empty }\n            //let nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n            \n            let nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            let nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\n            let nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            \n            let isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n        \n            let refreshView, refreshNow =\n                let refresh = Var.Create ()\n                refresh.View, fun () -> refresh.Value <- ()\n            let setHierarchy model (nodes: Tree.TreeNode seq) =\n                //nodes |> Seq.iter (fun n -> parents.Remove n.nid |> ignore)\n                nodes\n                |> Seq.toArray\n                |> model.treeHierarchy.Set\n        \n            let [<Inline>] inline mapIds f vls = vls |> View.Map (Seq.map f >> Seq.toArray) |> View.consistent\n        \n            let getDimsCubeO cubes = cubes\n        \n        \n            \n        [< AutoOpen >]\n        module Global =\n            let model = {\n                treeHierarchy = Var.Create [||]\n                calculations  = ListModel.Create (fun v -> v.calId) [||]\n                totals        = ListModel.Create (fun v -> v.totId) [||]\n                dimensions    = ListModel.Create (fun v -> v.dimId) [||]\n                cubes         = ListModel.Create (fun v -> v.cubId) [||]\n                globalDefs    = Var.Create \"\"\n                server        = Var.Create \"\"\n                selection     = Var.Create None\n                selectedDim   = Var.Create None\n                selectedCube  = Var.Create None\n                collapsed     = ListModel.Create id [||]\n                cubePrefix    = Var.Create \"Z\"\n                measurePrefix = Var.Create \"M\"\n                outputMsgs    = Var.Create \"\"\n                codeFS        = Var.Create \"\"\n                parserMsgs    = Var.Create \"\"\n                fileName      = Var.Create \"NewFile.json\"\n                version       = Var.Create <| Version.New()\n            }\n            \n            let mutable processor = fun (msg:MsgModel) -> ()\n            \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText model.outputMsgs msg\n            let inline appendParser msg = appendText model.parserMsgs msg\n        \n        module Render =\n            let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then e?scrollIntoViewIfNeeded())\n        \n            //let selTotIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getTId)\n            //let selCalIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getCId)\n            //let selForIdOV =                                                                model.selection.View |> View.Map2 (Option.bind snd            )\n          \n            //let lensForm getF view (calcV:Var<Calculation>) = \n            //    calcV |> Var.lensView\n            //               (fun c   -> c.calFormulas |> Seq.tryFind      getF |> Option.defaultValue ModelUI.nonFormula)\n            //               (fun c y -> c.calFormulas |> Seq.tryFindIndex getF |> Option.map (fun i -> { c with calFormulas = Array.replace i y c.calFormulas } )\n            //                                                                  |> Option.defaultValue c)\n            //               view\n          \n            let mapDefW def = View.Map (Option.defaultValue def) \n          \n            let zx = {\n                Tree.nid      = System.Guid.Empty |> Tree.TreeNodeId\n                Tree.expanded = false\n                Tree.element  = System.Guid.Empty |> CalId |> Calc // NodeId\n                Tree.children = [||] // TreeNode []\n                Tree.weight   =  Tree.Add        \n            }\n        \n            let getTreeEffReaderResource() = {\n                Tree.getParentO  = fun _   -> Hole.Incomplete \"Tree.getParentO \" //                    TreeNodeId -> TreeNode option\n                Tree.getNode     = fun _   -> Hole.Incomplete \"Tree.getNode    \" //                    TreeNodeId -> TreeNode\n                Tree.getPath     = fun _   -> Hole.Incomplete \"Tree.getPath    \" //                    TreeNodeId -> TreeNodeId list\n                Tree.setChildren = fun _ i -> Hole.Incomplete \"Tree.setChildren\" //    TreeNode seq -> TreeNodeId -> TreeNode\n            }\n        \n            type EffReader<'read> = inherit Reader.Reader<'read>\n        \n            let runEff     Ef = Ef |> Reader.readerHandler (getTreeEffReaderResource()) |> (Eff.run : (Eff<EffReader<_>,_> -> _) )\n            let iterEff  f m  = m |> map (f: 'a -> unit) |> runEff |> fun vR -> vR \n        \n            let tryFindNode nid = TreeNode.tryFindNodeEf nid\n        \n            let currentCalcOW = View.Do {\n                let! nodes = model.treeHierarchy.View\n                let! selO  = model.selection    .View\n                let! calcs = model.calculations .View\n                return\n                    nodes \n                    |> TreeNode.tryFindSelNodeEf selO\n                    |> runEff \n                    |> Option.bind (fun node -> match node.element with Calc cid -> Some cid |_-> None)\n                    |> Option.bind (fun cid  -> calcs |> Seq.tryFind (fun c -> c.calId = cid))\n            }\n            let setCurrentCalc v = \n                async {\n                    let! currCalcO = currentCalcOW |> View.GetAsync \n                    if   currCalcO.IsNone then () else\n                    model.calculations.Add v\n                } |> Async.Start\n            let currentCalcV  = Var.Make (mapDefW ModelUI.nonCalculation currentCalcOW ) setCurrentCalc\n            \n            //let currentCalcV  = ListModel.currentLens ModelUI.nonCalculation selCalIdOV model.calculations\n            //let currentFormV  = currentCalcV |> lensForm (fun f -> match model.selection.Value with Some(_, Some fid) -> fid = f.forId |_-> false) model.selection.View\n          \n            let lensForm (calcV:Var<Calculation>) getFidO =\n                if not IsClient then ModelUI.nonFormulaV else\n                let calcFormsV = Lens calcV.V.calFormulas\n                let formOW = View.Do {\n                    let! calc = calcV.View\n                    return\n                        getFidO()\n                        |> Option.bind (fun fid -> \n                            if calc.calId = ModelUI.nonCalculation.calId then None else \n                            calc.calFormulas |> Seq.tryFind (fun f -> f.forId = fid) )\n                }\n                let setForm v = \n                    async {\n                        let! formO = formOW |> View.GetAsync \n                        if   formO.IsNone then () else\n                        calcFormsV.Value \n                        |> Seq.tryFindIndex (fun f -> f.forId = v.forId)\n                        |> Option.iter(fun i -> calcFormsV.Value <- calcFormsV.Value |> Array.replace i v)\n                    } |> Async.Start\n                Var.Make (mapDefW ModelUI.nonFormula formOW) setForm\n            let currentFormV = lensForm currentCalcV (fun () -> model.selection.Value |> Option.bind snd)\n            \n            let calcTypeV (calcV:Var<Calculation>) = (Lens calcV.V.isInput).Lens (function true->\"Input\" |_->\"Calc\") (fun _ s -> match s with |\"Calc\" -> false | _ -> true) \n            let formTypeV (formV:Var<Formula    >) = (Lens formV.V.forType).Lens (fun t -> (sprintf \"%A\" t).[3..]  ) (fun _ s -> match s with |\"Base\" -> ForBase |\"Consolidated\" -> ForConsolidated | _ -> ForAll  ) \n            \n            let dtypes =   [ \n              DtDataType\n              DtTime\n              DtVersion\n              DtOther    ] \n          \n        \n            \n        module DragDrop =\n        \n            type DragInfo = \n                | DragNone\n                | DragNode of Tree.TreeNodeId\n                | DragForm of CalId * Formula\n            \n            let mutable drag        = DragNone\n            let setDragNone ()      = drag <- DragNone\n            let setDragNode tnid    = drag <- DragNode tnid\n            let setDragForm cid frm = drag <- DragForm(cid, frm)\n            \n            let getDragFormO cid fid = match drag with DragForm (dcid, dfor) when fid  <> dfor.forId && dcid = cid -> Some dfor | _ -> None\n            let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n            let isDragForm   cid fid = getDragFormO cid fid |> function None -> false | _ -> true\n            \n            let [< Inline >] inline moveItem dropId elems getId item =\n                elems\n                |> Seq.filter (getId >> ((<>) (getId item)) )\n                |> Seq.toArray\n                |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                             [fst ; [| item |] ; snd])\n                |> Seq.collect id\n                |> Seq.toArray\n            \n            let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n            let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n            \n            let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n            \n        module TableDimensions =\n            open Templating\n        \n            let dtypes =   [ \n                DtDataType\n                DtTime\n                DtVersion\n                DtOther    ] \n        \n            let tableDimensions () =\n                TemplateLib.DimensionTable()\n                    .TBody(\n                        model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n                            //let selDimW = V (model.selectedDim.V = Some did)\n                            TemplateLib.DimensionRow()\n                                .Name(          Lens dimV.V.dimName       )\n                                .Abbreviation(  Lens dimV.V.dimPrefix     )\n                                .Order(         Lens dimV.V.dimOrder      )\n                                .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                                .ExcludeName(   Lens dimV.V.dimExclude    )\n                                .IncludeFreeze( Lens dimV.V.dimFreeze     )\n                                .Remove(        fun _ -> RemoveDimension did |> processor )\n                                .Select(        fun _ -> SelectDimension did |> processor )\n                                .Doc()        \n                        )\n                    )\n                    .Doc()\n        module TableCalculations =\n            let rowFormula (tnId:Tree.TreeNodeId) (calcV : Var<Calculation>) fid =\n                let cid      = calcV.Value.calId\n                let formsV   =        Lens     calcV.V.calFormulas\n                let formV    = Render.lensForm calcV (fun () -> Some fid) \n                let selFormW = V (ModelUI.isNodeFormSelected fid tnId model.selection.V)\n                let formForW = V (formV.V.forDestDecl \n                                  |> Seq.map(fun f -> \n                                      sprintf \"%s:%s\" \n                                          (model.dimensions.View.V \n                                           |> Seq.tryFind(fun d -> d.dimId = f.Key) \n                                           |> function Some dim -> dim.dimName |_-> \"\") \n                                          f.Value) \n                                  |> String.concat \", \")\n                TemplateLib.FormulaRow()\n                    .SelectedMark( ModelUI.selectedString \">\"        selFormW )\n                    .Selected(     ModelUI.selectedString \"selected\" selFormW )\n                    .FormulaFor(   formForW                                   )\n                    .Formula(      Lens formV.V.forText                       )\n                    .FormType(     Render.formTypeV formV                     )\n                    .Remove(       fun _  -> RemoveFormula  fid        |> processor                               )\n                    .Select(       fun _  -> SelectFormNode(fid, tnId) |> processor                               )\n                    .Drag(         fun ev ->    DragDrop.setDragForm cid formV.Value ; ev.Event.StopPropagation() )\n                    .DragOver(     fun ev -> if DragDrop .isDragForm cid fid then      ev.Event.PreventDefault () )\n                    .Drop(         fun ev -> do                                        ev.Event.PreventDefault ()\n                                             DragDrop.getDragFormO cid fid |> DragDrop.moveItemInListModel fid formsV Formula.forId )\n                    .AfterRender(  Render.scrollIntoView selFormW )\n                    .Doc()\n                    \n            let rowTreeNode (tnId:Tree.TreeNodeId, nid:NodeId, level:int) =\n                let depth             = sprintf \"%dem\" level\n                let isSelW            = V (ModelUI.isNodeSelected tnId model.selection.V)\n                let rowCalculation (calcV:Var<Calculation>) cid       =\n                    let formsDoc      = V (calcV.V |> fun c -> c.calFormulas |> Seq.map Formula.forId) |> Doc.BindSeqCached (rowFormula tnId calcV)\n                    TemplateLib.CalculationRow()\n                        .SelectedMark( \"\" )\n                        .Selected(     ModelUI.selectedString \"selected\" isSelW )\n                        .Indent(       depth                            )\n                        .CalcName(     Lens calcV.V.calName   )\n                        .Format(       Lens calcV.V.format    )\n                        .IsText(       Lens calcV.V.isText    )\n                        .IsBalance(    Lens calcV.V.isBalance )\n                        .OrderCalc(    Lens calcV.V.calOrder  )\n                        .CalcType(     Render.calcTypeV calcV )\n                        .Remove(       fun _ -> RemoveCalculation cid |> processor        )\n                        .Select(       fun _ -> isSelW |> View.Get (fun s -> if not s then SelectNode tnId |> processor)  )\n                        .Formulas(     formsDoc )\n                        .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n                        .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n                        .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                                 DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n                        .AfterRender(  Render.scrollIntoView isSelW )\n                        .Doc()\n                 \n                let rowTotal (totV:Var<Total>) tid =\n                    let totV         = model.totals |> ListModel.lensDef ModelUI.nonTotal tid\n                    let nodeW        = V (TreeNode.tryFindNodeEf tnId model.treeHierarchy.V |> Render.runEff )\n                    let markW        = V (nodeW.V |> Option.map (fun node -> if node.expanded then \"-\" else \"+\") |> Option.defaultValue \"*\")\n                    TemplateLib.TotalRow()\n                        .SelectedMark( markW                                           )\n                        .Selected(     ModelUI.selectedString \"selected\" isSelW        )\n                        .Indent(       depth                                           )\n                        .TotName(      Lens totV.V.totName                             )\n                        .Format(       Lens totV.V.totFormat                           )\n                        .OrderTot(     Lens totV.V.totOrder                            )\n                        .Remove(       fun _ -> RemoveTotal tid           |> processor )\n                        .Select(       fun _ -> SelectNode  tnId          |> processor )\n                        .Collapse(     fun _ -> nodeW |> View.Get (Option.iter (fun node -> (not node.expanded, node.nid) |> ExpandNode |> processor)) )\n                        .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n                        .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n                        .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                                 DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n                        .AfterRender(  Render.scrollIntoView isSelW )\n                        .Doc()\n            \n                match  nid with\n                | Calc cid -> rowCalculation (model.calculations |> ListModel.lensDef ModelUI.nonCalculation cid) cid\n                | Tot  tid -> rowTotal       (model.totals       |> ListModel.lensDef ModelUI.nonTotal       tid) tid\n                \n            let tableCalculations() =\n                TemplateLib.CalculationTable()\n                    .TBody( \n                        V (model.treeHierarchy.V\n                           |> Seq.map TreeNode.treenode\n                           |> TreeEff.listNodes 0 \n                           |> Render.runEff\n                           |> (Seq.map (fun (tn,l) -> tn.id(), (TreeNode.fromNode tn).element, l) ) \n                        )\n                        |> Doc.BindSeqCached rowTreeNode\n                     )\n                    .Doc()\n            \n        let globalDefs () =\n            //let getAnnot = V (Monaco.filterGlobal model.parserMsgs.V) |> View.consistent\n            \n            Monaco.monacoNew\n                <| model.globalDefs \n                <| None //Some getAnnot\n                <| None //Some (ParseFS.showToolTips FSCode.InGlobalDefs)\n                <| None //Some (ParseFS.getHints     FSCode.InGlobalDefs)\n        \n            |> Monaco.render\n        \n        module MainProgram =\n            open FusionAsyncM\n            open Operators\n            open Templating\n        \n            open FsRoot\n            module AF = AppFramework \n        \n            let RuleEditorLyt = \"RuleEditorLyt\"\n        \n            let scrollToBottom (e:Dom.Element) (_:obj) = \n                async { \n                    do! Async.Sleep 100\n                    do  e.ScrollTop <- e.ScrollHeight\n                } |> Async.Start\n        \n        //    let mainLayout() =\n        //        TemplateLib.Layout()\n        //            .CalculationTable( tableCalculations()                  )\n        //            .FormulaDetail(    details          ()                  )\n        //            .DimsSelected(     dimsSelected     ()                  )\n        //            .DimensionTable(   tableDimensions  ()                  )\n        //            .GlobalText(       globalDefs       ()                  )\n        //            .Server(           model.server                         )\n        //            .Output(           model.outputMsgs                     )\n        //            .FSCode(           model.codeFS                         )\n        //            .Parser(           model.parserMsgs                     )\n        //            .Filename(         model.fileName                       )\n        //            .AddCalculation(   fun _ -> AddCalculation |> processor )\n        //            .AddTotal(         fun _ -> AddTotal       |> processor )\n        //            .NewDimension(     fun _ -> AddDimension   |> processor )\n        //            .SaveAs(           fun _ -> SaveLoad.saveAsFile()       )\n        //            .LoadFileChanged(  fun e -> SaveLoad.loadFile e.Target  )\n        //            .LoadFileClear(    fun e -> e.Target?value <- \"\"        )\n        //            .UpdateRules(      fun _ -> UpdateAlea.updateModel()    )        \n        //            .IndentIn(         fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        //            .IndentOut(        fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n        //        //    .Reorder(          fun _ -> reorder()                                    )\n        //            .JumpRef(ParseFS.jumpToRef)\n        //            .OutputAfterRender(fun e -> model.outputMsgs.View |> View.Sink (scrollToBottom e))\n        //            .Doc()\n        \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = \"RuleEditor\"\n                    AF.plgVars    = [| AF.newVar  \"fileName\"        model.fileName\n                                       //AF.newVar  \"SnippetName\"     (Lens Snippets.currentSnippetV.V.snpName)\n                                       //AF.newVar  \"Content\"         (Lens Snippets.currentSnippetV.V.snpContent)\n                                       //AF.newVar  \"Output\"          outputMsgs\n                                       AF.newVar  \"Server\"          model.server\n                                    |]  \n                    AF.plgViews   = [| //AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                                       //AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                                       //AF.newViw  \"CurrentPath\"     Snippets.currentPathW\n                                    |]  \n                    AF.plgDocs    = [| //AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                                       //AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                                       //AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                                       //AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                                       //AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                                       AF.newDoc  \"globalDefs\"      (lazy globalDefs() )\n                                       AF.newDoc  \"Dimensions\"      (lazy TableDimensions  .tableDimensions  () )\n                                       AF.newDoc  \"Calculations\"    (lazy TableCalculations.tableCalculations() )\n                                    |]  \n                    AF.plgActions = [| //AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                                       //AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                                       //AF.newAct  \"IndentIn\"        Snippets.indentIn       \n                                       //AF.newAct  \"IndentOut\"       Snippets.indentOut\n                                       //AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                                       //AF.newAct  \"RunFS\"           runFsCode\n                                       //AF.newAct  \"AbortFsi\"        FsiAgent.abortFsiExe\n                                       //AF.newAct  \"DisposeFsi\"      FsiAgent.disposeFsiExe\n                                       AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadTextFile |> processor  ), \"FileElement\")\n                                       AF.newActF  \"SaveAs\"          <| AF.FunAct1 ((fun o -> unbox o |> SaveTextFile |> processor  ), \"FileElement\")\n                                       //AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile     ), \"FileElement\")\n                                       //AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef        ), \"textarea\"   )\n                                       //AF.newActF \"ButtonClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.buttonClick), \"button\"     )\n                                       //AF.newActF \"ActionClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.actionClick), \"name\"       )\n                                       AF.newAct  \"AddDimension\"    (fun () -> AddDimension   |> processor)\n                                       AF.newAct  \"AddCalculation\"  (fun () -> AddCalculation |> processor)\n                                       AF.newAct  \"AddTotal\"        (fun () -> AddTotal       |> processor)\n                                       AF.newAct  \"AddDimension\"    (fun () -> AddDimension   |> processor)\n                                    |]\n                    AF.plgQueries = [|                                               \n                                    |]\n                }\n                match JS.Document.GetElementById(\"GlobalLayout\") with\n                | null ->\n                   \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -200 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS none x btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddDimension  button RuleEditor.AddDimension      \"\"                  \"Add Dimension \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                   \"\"\"\n                | e -> e.TextContent\n                |> LayoutEngine.newLyt RuleEditorLyt\n                |> LayoutEngine.addLayout\n        \n                None\n                |> Option.defaultValue RuleEditorLyt\n                |> AF.mainDocV.Set\n        \n                async {\n                  //do! Monaco.loader\n                  //WcSplitter.init horizontal vertical\n                  //WcTabStrip.init()\n                  //let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n                  return AF.getMainDoc.Value\n                } |> Doc.Async            \n                \n        module UpdateModelUI =\n                                            \n            let rec updateModelR model msg = \n                let doForCalc cid f       = model.calculations.TryFindByKey cid |> Option.iter f\n                let doForForm cid fid f   = doForCalc cid <| fun c -> c.calFormulas |> Seq.tryFind(fun f -> f.forId = fid) |> Option.iter (f c)\n                let doForCube cid f       = model.cubes       .TryFindByKey cid |> Option.iter f\n                let setSelection sel      = if model.selection.Value = sel then false else\n                                            model.selection.Value   <- sel\n                                            true\n                let tryFindCalcForm fid   = model.calculations.Value |> Seq.tryFind(fun calc -> calc.calFormulas |> Seq.exists (fun f -> f.forId = fid))\n                match msg with\n                | AddCalculation         -> let n = Calculation.New()\n                                            model.calculations.Add n\n                                            let nn = TreeNode.newNodeCalc n.calId\n                                            model.treeHierarchy.Value\n                                            |> Array.append [| nn |]\n                                            |> model.treeHierarchy.Set\n                                            SelectNode  nn.nid |> updateModelR model\n                | AddTotal               -> let n = Total.New()\n                                            model.totals.Add n\n                                            let nn = TreeNode.newNodeTot  n.totId\n                                            model.treeHierarchy.Value\n                                            |> Array.append [| nn |]\n                                            |> model.treeHierarchy.Set\n                                            SelectNode  nn.nid |> updateModelR model\n                | AddFormula         cid -> if  cid = ModelUI.nonCalculation.calId then false else\n                                            let n = Formula.New()\n                                            model.calculations.TryFindByKey cid\n                                            |> Option.iter(fun calc -> { calc with calFormulas = Array.append calc.calFormulas [| n |] } |> model.calculations.Add)\n                                            model.treeHierarchy.Value \n                                            |> TreeNode.tryFindSelNodeEf model.selection.Value\n                                            |> Render.runEff\n                                            |> Option.map (fun nn -> SelectFormNode (n.forId, nn.nid ) |> updateModelR model)\n                                            |> Option.defaultValue true\n                | AddDimension           -> let n = Dimension.New \"\"\n                                            model.dimensions.Add n\n                                            SelectDimension n.dimId |> updateModelR model\n            //    | AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n            //                                true\n            ////    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n            ////                                    model.childrenRels.Value <- model.childrenRels.Value |> Map.add (tid, ch) we\n            ////                                    true\n            ////                                ) |> Option.defaultValue false\n            ////    | RemoveChild (tid, ch)  -> model.childrenRels.Value <- model.childrenRels.Value |> Map.remove (tid, ch)\n            ////                                true\n            //    | RemoveTotal        tid -> model.totals.RemoveByKey    tid\n            //                                setSelection None |> ignore\n            //                                model.treeHierarchy.Value \n            //                                |> TreeNode.removeNodes (TreeNode.forTId ((=) tid)) \n            //                                |> ModelUI.setHierarchy model\n            //                                true\n                | RemoveCalculation  cid -> setSelection None |> ignore\n                                            model.calculations.RemoveByKey cid\n                                            model.totals.Value\n                                            |> Seq.choose (fun t -> \n                                                let eq, ne = t.children |> Array.partition (fun (_, nid) -> nid = Calc cid )\n                                                if eq.Length = 0 then None else\n                                                Some { t with children = ne }\n                                            )\n                                            |> Seq.iter model.totals.Add\n                                            model.treeHierarchy.Value \n                                            |> TreeNode.removeNodesEf (TreeNode.forCId ((=) cid))\n                                            |> Render.runEff\n                                            |> ModelUI.setHierarchy model\n                                            true\n            //    | RemoveFormula      fid -> tryFindCalcForm fid\n            //                                |> Option.iter(fun calc -> { calc with calFormulas = calc.calFormulas |> Array.filter (fun f -> f.forId <> fid) } \n            //                                                           |> model.calculations.Add )\n            //                                true\n            //    | RemoveDimension    did -> model.dimensions.RemoveByKey did\n            //                                true\n            ////    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n            ////                                true\n            //    | SelectNode         nid -> (nid, None    ) |> Some |> setSelection\n            //    | ExpandNode    (ex, nid)-> let rec mapper finished (node:TreeNode) =\n            //                                    if finished             then node                       , true\n            //                                    elif node.nid = nid     then { node with expanded = ex }, true\n            //                                    else let ch, dn = node.children |> Seq.mapFold mapper false\n            //                                         { node with children = Seq.toArray ch }            , dn\n            //                                model.treeHierarchy.Value \n            //                                |> Seq.mapFold mapper false \n            //                                |> fst\n            //                                |> Seq.toArray\n            //                                |> model.treeHierarchy.Set\n            //                                true\n            //    | IndentNode   (iin, nid)-> let indent = if iin then Tree.indentNode else Tree.outdentNode\n            //                                model.treeHierarchy.Value\n            //                                |> TreeNode.tryFindNode nid\n            //                                |> Option.iter(\n            //                                   Tree.toNode \n            //                                   >> swap indent (Tree.toSeqNode model.treeHierarchy.Value) \n            //                                   >> TreeNode.fromSeqNode \n            //                                   >> ModelUI.setHierarchy model)\n            //                                true\n            //    | MoveNode(aft,fnid,tnid)-> Tree.moveToSibling2 aft fnid tnid (Tree.toSeqNode model.treeHierarchy.Value) \n            //                                |> TreeNode.fromSeqNode \n            //                                |> ModelUI.setHierarchy model\n            //                                true\n            //    | SelectFormNode(fid,nid)-> (nid, Some fid) |> Some |> setSelection\n            //    | SelectTotal        tid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeTId tid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n            //    | SelectCalculation  cid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n            //    | SelectFormula      fid -> tryFindCalcForm fid       |> Option.map(fun c -> c.calId) |> Option.bind(fun cid -> \n            //                                model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid) |> Option.map (fun n -> n.nid, Some fid) |> setSelection\n            //    | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n            //                                |> (fun s -> if s = model.selectedDim.Value then false else\n            //                                             model.selectedDim.Value    <- s\n            //                                             true)\n            //    | AddCalcDim   (cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.add    did }\n            //                                false\n            //    | RemoveCalcDim(cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.remove did }\n            //                                false\n            //    | AddCube      (n, ds)   -> model.cubes.Add <| Cube.newCubeCalc n (ds |> Seq.toArray) None\n            //                                false\n            //    | RemoveCube    cid      -> model.cubes.RemoveByKey cid\n            //                                false\n            //    | RenameCube   (cid, n)  -> doForCube cid <| fun c -> model.cubes.Add { c with cubName = n }\n            //                                false\n                  | _ -> printfn \"Msg not implemented: %A\" msg ; false\n        \n            \n            let updateModel model msg = if updateModelR model msg then ModelUI.refreshNow()\n            processor <- updateModel model\n        //#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#define FSS_SERVER\n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            let varInt  = Var.Create 1\n            printfn \"varInt %A\" varInt.Value\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n                Content.Page(Title = \"Main Page\" \n                           , Body  = [\n                                Html.client <@ MainProgram.mainProgram() @>\n                                Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                             ])\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
