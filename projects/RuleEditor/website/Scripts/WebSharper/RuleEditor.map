{
"version": 3,
"sourceRoot": "Source",
"sources": ["RuleEditor/RuleEditor.fs"],
"sourcesContent": ["#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1541588788569 -d:WEBSHARPER\n////#cd @\"..\\projects\\RuleEditor\\src\"\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1541588788569\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            [< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDay()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\n            let nowStamp() = \n                let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n                t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n            \n            let [<Inline>] inline traceT t v = tee (sprintf \"%A\" >> (fun s -> s.[..100]) >> printfn \"%s %s: %A\" (nowStamp()) t) v\n            let [<Inline>] inline trace   v = traceT \"trace\" v\n            let [<Inline>] inline traceI  v = trace          v |> ignore\n            \n            module Log =\n                let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n                let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n                let [<Inline>] inline InA    n f p = async { return! In  n f p }\n                let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n                let [<Inline>] inline InOut  n     = In  n >> Out  n\n                let [<Inline>] inline InOutA n f p = async {\n                    let!   r = InA n f  p\n                    do         Out n id r |> ignore\n                    return r \n                  }\n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = ms |> Seq.fold addMsg NoMsg\n            \n                let summaryF f msg =        \n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = summaryF f msg + msg.ToString()\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let rtn                          = Ok\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | Ok    v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                       | Error e ->       e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = bindP  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofFusionM     (FM fm) = FAM(fun (s,r) -> async.Return (fm (s, r)) )\n                    let inline ofAsync            a  = FAM(fun (s ,r ) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n                \n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            module Var =\n                let mutable private counter = 1\n                let freshId () =\n                    counter <- counter + 1\n                    \"varuid\" + string counter\n                        \n                let lensView get update view0 (var: Var<_>) =\n                    let id   = freshId()\n                    let view = View.Map2 (fun v _ -> get v) var.View view0\n                    { new Var<'V>() with\n                        member this.Get        () = get (var.Get())\n                        member this.Set         v = var.Update(fun t -> update t v)\n                        member this.SetFinal    v = this.Set(v)\n                        member this.Update      f = var.Update(fun t -> update t (f (get t)))\n                        member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n                        member this.View          = view\n                        member this.Id            = id\n                    }\n            \n            module ListModel =\n                let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.FindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.TryFindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let lensDef def k (m:ListModel<_,_>) =\n                    let get = Option.defaultValue def\n                    lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n            \n                let currentLensUpd def curr upd (model:ListModel<_,_>) = \n                    curr \n                    |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                                    (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                                    model.View\n                let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n                    let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n                    Var.Make view upd\n                let currentLens def curr (model:ListModel<_,_>) = \n                    model \n                    |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n                \n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n    \n    module CalculationModel =\n        [< JavaScript >]\n        module CalculationModel =\n            open System\n            \n            type DimType =\n                | DtDataType\n                | DtTime\n                | DtVersion\n                | DtTCalc\n                | DtCalc\n                | DtMeasure\n                | DtOther\n            \n            type CubeType =\n                | CtOther\n                | CtCalc\n                | CtFreeze\n            \n            type AttType =\n                | AtString\n                | AtNumber\n            \n            type ElmType =\n                | EtString\n                | EtNumber\n            \n            type ModId = ModId of Guid with member x.Id = match x with ModId id -> id\n            type AttId = AttId of Guid with member x.Id = match x with AttId id -> id\n            type ElmId = ElmId of Guid with member x.Id = match x with ElmId id -> id\n            type CubId = CubId of Guid with member x.Id = match x with CubId id -> id\n            type DimId = DimId of Guid with member x.Id = match x with DimId id -> id\n            type CalId = CalId of Guid with member x.Id = match x with CalId id -> id\n            type TotId = TotId of Guid with member x.Id = match x with TotId id -> id\n            type ForId = ForId of Guid with member x.Id = match x with ForId id -> id\n            type RulId = RulId of Guid with member x.Id = match x with RulId id -> id\n            \n            type Attribute = {\n                attId          : AttId\n                attName        : string\n                attType        : AttType\n                attTableNum    : int\n            }\n            \n            type Element = {\n                elmId          : ElmId\n                elmDim         : DimId\n                elmType        : ElmType\n                elmName        : string\n                elmDescription : string\n                elmAttributes  : Map<AttId, string> \n                elmParents     : ElmId     []\n            } \n            \n            type Dimension = {\n                dimId               : DimId\n                dimName             : string\n                dimPrefix           : string\n                dimOrder            : string\n                dimExclude          : bool\n                dimFreeze           : bool\n                dimType             : DimType\n                defaultElm          : ElmId     option\n                mutable dimElements : Element   []\n                dimAttributes       : Attribute []\n                isCalcDim           : bool\n            }\n            \n            type UnaryOp = \n                | UoMinus\n                | UoPlus\n                \n            type Operator = \n                | OpAdd      \n                | OpSubtract \n                | OpMultiply \n                | OpDivide   \n                | OpEQ    \n                | OpNE\n                | OpGT       \n                | OpGE       \n                | OpLT       \n                | OpLE       \n                | OpAnd      \n                | OpOr           \n            \n            type Function = Function of string\n            \n            type ElmReference =\n                | ElemFixed   of DimId * ElmId\n                | ElemDynamic of DimId * ExpressionText\n                    \n            and  ExpressionText =\n                | ExtNA\n                | ExtStet\n                | ExtSlice      of Slice\n                | ExtString     of string\n                | ExtDimElement of DimId\n                | ExtDimName    of DimId\n                | ExtFunction   of Function         * ExpressionAny []\n                | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n            \n            and  ExpressionNumber =\n                | ExnNA\n                | ExnStet\n                | ExnSlice      of Slice\n                | ExnNumber     of float\n                | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n                | ExnUnaryN     of UnaryOp          * ExpressionNumber\n                | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n                | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n                | ExnFunction   of Function         * ExpressionAny []\n                | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n                | ExnIsNA       of ExpressionNumber\n                | ExnIsNAt      of ExpressionText\n                | ExnIsNAa      of ExpressionAny\n                \n            and ExpressionAny =    \n                | ExiNA\n                | ExiStet\n                | ExiSlice      of Slice\n                | ExNumeric     of ExpressionNumber\n                | ExText        of ExpressionText\n                | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n                \n            and  Slice = {\n                sliDims     : Map<DimId, ElmReference>   \n                calculation : CalId option\n                cube        : CubId option\n            } \n            \n            type ForType = \n                | ForBase\n                | ForConsolidated\n                | ForAll\n            \n            type Formula = {\n                forId          : ForId\n                forDestDecl    : Map<DimId, string>\n                forDestination : ElmReference list\n                forDescription : string\n                forText        : string\n                forExpression  : ExpressionAny\n                forType        : ForType\n                forOrder       : string\n            }\n            \n            type Calculation = {\n                calId          : CalId\n                calName        : string\n                calDescription : string\n                calOrder       : string\n                format         : string\n                isText         : bool\n                isInput        : bool\n                isBalance      : bool\n                calDims        : Set<DimId>\n                calFormulas    : Formula []\n                cubIdO         : CubId   option\n                properties     : Map<string, string>\n            }\n            \n            type NodeId =\n                | Calc of CalId\n                | Tot  of TotId\n            \n            type Total = {\n                totId          : TotId\n                totName        : string\n                totOrder       : string\n                totFormat      : string\n                children       : (float * NodeId) []\n            }\n            \n            type RuleKey = \n                | RuleKey     of RulId\n                | CalcRuleKey of CalId\n                | FormulaKey  of ForId\n                | ForTextKey  of ForId\n                | ActualRuleKey \n                | InputRuleKey\n                | ConsolidatedRuleKey\n            \n            type Cube = {\n                cubId          : CubId\n                cubName        : string\n                cubRules       : Map<RuleKey, Rule option>\n                cubRuleXmls    : Map<RuleKey, string>\n                cubDims        : DimId []\n                measureDim     : DimId option\n                cubType        : CubeType\n            }\n            \n            and  Rule = {\n                rulId          : RulId\n                rulSourceId    : IComparable\n                rulDescription : string\n                rulDestination : ElmReference list\n                rulExpression  : ExpressionAny\n                rulType        : ForType\n                rulOrder       : string\n                rulXml         : string\n            }\n            \n            type RuleMsg =\n            | GetInitModelStats\n            | GetRulesForCube of CubId\n            \n            type ReplyMsg =\n            | ReplyInformation of string\n            | ReplyRules       of (RuleKey * string) []\n            \n            [<NoComparison ; NoEquality>]\n            type Model = {\n                modId           : ModId\n                server          : string\n                actualElem      : string\n                modDims         : Dimension   []\n                modCubes        : Cube        []\n                modCalculations : Calculation []\n            } \n            \n            let Xmodel = \n              {\n                modId           = ModId <| Guid.NewGuid()\n                server          = @\"local\\Budget\"\n                actualElem      = \"Actual\"\n                modDims         = [||]\n                modCubes        = [||]\n                modCalculations = [||]\n              }\n                \n            let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n            let calcSlice calc : Slice = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = Some calc.calId\n                         cube          = None\n                     }\n                \n            type HelperTypeN = HelperTypeN with\n                static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n                static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n                static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n                static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n                static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n                static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n                \n            let [< Inline >] inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n            \n            type HelperTypeT = HelperTypeT with\n                static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n                static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n                static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n                static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n                static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n            \n            let [< Inline >] inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n            \n            type HelperTypeA = HelperTypeA with\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n                [< Inline >] \n                static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n                [< Inline >]\n                static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n            \n            let [< Inline >] inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n        \n            type Message =\n                | DimensionNotFound      of DimId\n                | DimensionHasNoElements of string\n                | ElementNotFound        of string * ElmId\n                | CubeNotFound           of CubId\n                | CubeHasNoMeasureDim    of string\n                | CalculationNotFound    of CalId\n                | CalculationHasNoCube   of string\n        \n            let ofOptF f = Result.ofOption (fun () -> Message <| f())\n            let ofOptS s = Result.ofOption (fun () -> Message <| s  )\n        \n            module internal Model0 =\n                let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n                let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n                let getDimR       dId mdl = getDimO  dId mdl |> Result.ofOption (fun () -> DimensionNotFound   dId)\n        \n            module Element  =\n                let newElement name = \n                  {\n                    elmId          = ElmId <| Guid.NewGuid()\n                    elmDim         = DimId <| Guid.NewGuid()\n                    elmType        = EtString\n                    elmName        = name\n                    elmDescription = name\n                    elmAttributes  = Map.empty\n                    elmParents     = [||]\n                  }\n        \n            module ElmReference =\n                let dimId elr =\n                    match elr with\n                    | ElemFixed  (id, _)\n                    | ElemDynamic(id, _) -> id\n        \n            module Slice =\n                let newSlice ds = {\n                         sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                         calculation   = None\n                         cube          = None\n                }\n                let forAll = {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = None\n                }\n                let addRef      elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n                let containsDim did slc = slc.sliDims |> Map.containsKey did\n           \n            module Dimension =\n                let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n                let getElementR      eId dim = getElementO eId dim |> Result.ofOption (fun () -> ElementNotFound(dim.dimName, eId))\n                let newDimension id name isCalcDim =\n                      {\n                        dimId          = id \n                        dimName        = name\n                        dimPrefix      = \"\"\n                        dimOrder       = \"\"\n                        dimExclude     = false\n                        dimFreeze      = false\n                        dimType        = DtOther\n                        defaultElm     = None\n                        dimElements    = [|  |]\n                        dimAttributes  = [|  |]      \n                        isCalcDim      = isCalcDim\n                      }\n                let newDimensionNonCalc id name  = newDimension id name false\n                let newDimensionCalc    id name  = newDimension id name true \n                let New                    name  = newDimension (DimId <| Guid.NewGuid()) name false\n                let [< Inline >] inline getElmReference it dim =\n                    match toExpT it with \n                    | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                                      let elm =\n                                         dim.dimElements                                 \n                                         |> Seq.tryFind (fun e -> e.elmName = s2)\n                                         |> Option.defaultWith (fun () -> \n                                             let newE = Element.newElement s2\n                                             dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                             newE\n                                         )\n                                      ElemFixed  (dim.dimId, elm.elmId) \n                    | exp          -> ElemDynamic(dim.dimId, exp      )  \n        //        member inline this.Item (it) = getElmReference it this\n                //member inline this.__     it     = this.Item it\n                //member inline this.M      it     = this.Item it\n                //member inline this.E      it     = this.Item it\n                //member inline this.I      it     = this.Item it\n                let prefix  pr   dim  = { dim with dimPrefix = pr   }\n                let dType   dt   dim  = { dim with dimType   = dt   }\n                let setName name dim  = { dim with dimName   = name }\n                let filter     dtypes : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\n                let sort             (ds:Dimension seq)                  = ds |> Seq.sortBy (fun d -> d.dimOrder)\n                let filterSort dtypes : (Dimension seq -> Dimension seq) = filter dtypes >> sort\n        \n            type Dimension with\n                [< Inline >] \n                member inline this.Item (it) = Dimension.getElmReference it this\n        \n        \n            module Cube =\n                let slice cub : Slice  = \n                     {\n                         sliDims       = Map.empty\n                         calculation   = None\n                         cube          = Some cub.cubId\n                     }\n                let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n                let isCalcCube                cub = cub.cubType = CtCalc    \n                let newCubeId id name dims mDimO cType = \n                        {\n                          cubId       = id\n                          cubName     = name\n                          cubDims     = dims\n                          cubRules    = Map.empty\n                          cubRuleXmls = Map.empty\n                          measureDim  = mDimO\n                          cubType     = cType\n                        }\n                let newCube     name            = newCubeId <| CubId (Guid.NewGuid()) <| name\n                let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n                let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n                let New()                       = newCube \"\" [||] None CtOther\n                let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n                let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n                //member inline this.Calc ()    = { this with cubType = CtCalc } \n                let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n                let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n                let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n                let measureDimR     model cub   = cub.measureDim         |> Result.ofOption (fun () -> CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n                let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n                \n            module Calculation =\n                let slice calc = calcSlice calc\n                let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n                let newInput id (name: string) dims  =\n                     {\n                        calId          = id\n                        calName        = name.Replace(\"_\", \" \").Trim()\n                        calDescription = \"\"\n                        calOrder       = \"\"\n                        format         = \"#,##0.00\"\n                        isText         = false\n                        isInput        = true\n                        isBalance      = false\n                        calDims        = dims |> Set \n                        calFormulas    = [||]\n                        cubIdO         = None\n                        properties     = Map.empty\n                     }\n                let newCalc id name dims      = { newInput id name dims     with isInput     = false  }\n                let New        ()             =   newInput (CalId <| Guid.NewGuid()) \"\"   []\n                let setName    name      calc = { calc                   with calName     = name   }\n                let setIsText  istext    calc = { calc                   with isText      = istext }\n                let setOrder   order     calc = { calc                   with calOrder    = order  }\n                let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n                let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n                let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n                let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n                let [< Inline >] getElemRefO(model: Model) calc =\n                    calc.cubIdO \n                    |> Option.bind (swap Model0.getCubeO model)\n                    |> Option.bind (fun cub ->  cub.measureDim) \n                    |> Option.bind (swap Model0.getDimO  model)\n                    |> Option.map  (Dimension.getElmReference calc.calName)\n                let cubeR           c = c.cubIdO        |> ofOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n                let [< Inline >] getElemRefR   m c = getElemRefO m c |> ofOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n                let sort             (cs:Calculation seq)                  = cs |> Seq.sortBy (fun c -> c.calOrder)\n        \n            module Total =\n                let newTotal name  = {\n                    totId          = TotId  <| System.Guid.NewGuid()\n                    totName        = name\n                    totOrder       = \"\"\n                    totFormat      = \"\"\n                    children       = [||]\n                }\n                let New() = newTotal \"\"\n                \n            module Model =\n                let mergeBy f a b = Array.append (Seq.toArray a) (Array.filter (fun e -> a |> Seq.map f |> Seq.contains (f e) |> not ) b)\n                let addCalcs     cs   mdl = { mdl with modCalculations = mergeBy (fun c -> c.calId) cs mdl.modCalculations }\n                let addDims      ds   mdl = { mdl with modDims         = mergeBy (fun c -> c.dimId) ds mdl.modDims         }\n                let addCubes     cs   mdl = { mdl with modCubes        = mergeBy (fun c -> c.cubId) cs mdl.modCubes        }\n                let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n                let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n                let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n                let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n                let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n                let getDimO               = Model0.getDimO\n                let getDimR               = Model0.getDimR\n                let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n                let getCubeO              = Model0.getCubeO\n                let getCalcR      cId mdl = getCalcO cId mdl |> Result.ofOption (fun () -> CalculationNotFound cId)\n                let getCubeR      cId mdl = getCubeO cId mdl |> Result.ofOption (fun () -> CubeNotFound        cId)\n                let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n                let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n                let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n                let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n                let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n                let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n                let timeDimO          mdl = pickDimO  DtTime     mdl\n                let versionDimO       mdl = pickDimO  DtVersion  mdl\n                let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n                let getCalcCube dims  mdl = \n                    mdl.modCubes \n                    |> Seq.filter  Cube.isCalcCube\n                    |> Seq.tryFind (fun cub -> \n                        cub.cubDims \n                        |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                        |> Set = dims )\n                let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n                let withDimsO mdl cube f =\n                    let (<*>)   = Option.apply\n                    let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n                    Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n                let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n                let dimCombinations model =\n                    model.modCalculations\n                    |>  Seq.map (fun c -> c.calDims)\n                    |>  Seq.distinct \n                let cubePrefix    = \"Z\"\n                let measurePrefix = \"M\"\n                let orderedDims dimIds model =\n                        model.modDims \n                        |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n                let autoName dimIds model =\n                    let nameBase =\n                        model\n                        |> orderedDims dimIds\n                        |> Seq.map (fun d -> d.dimPrefix)\n                        |>  String.concat \"\"\n                    let similar =\n                        model.modCubes\n                        |> Seq.choose (fun c -> \n                            match cubePrefix + nameBase with\n                            | n when c.cubName          = n -> Some -1\n                            | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> ParseO.parseIntO\n                            | _                             -> None\n                        ) \n                    nameBase\n                  + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n            \n                let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n                let fixForDimensions model =\n                    //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n                    let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n                    { model with modCalculations = calcs }\n                let newCalcCube dimIds model =\n                    let name = autoName dimIds model\n                    let mDim = Dimension.newDimensionCalc <| DimId (Guid.NewGuid()) <| measurePrefix + name\n                    let orderedDimIds = \n                        model\n                        |> orderedDims dimIds\n                        |> Seq.append <| [ mDim ]\n                        |> Seq.map (fun d -> d.dimId)\n                        |> Seq.toArray\n                    let dims  = Array.append model.modDims  [| mDim                                                                 |]\n                    let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n                    { model with modDims = dims ; modCubes = cubes }\n                let fixCalcsAndCubes model =\n                    let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cubIdO |> Option.bind (swap getCubeO model) |> Option.isNone)\n                    if Seq.isEmpty calNoCube then model else\n                        let modelN =\n                            calNoCube\n                            |> Seq.map      (fun c -> c.calDims)\n                            |> Seq.distinct\n                            |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                            |> Seq.fold      (swap newCalcCube) model\n                        let calcs =\n                            modelN.modCalculations\n                            |> Array.map (fun oldC ->\n                                    calNoCube \n                                    |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                                    |> Option.map  (fun newC -> { newC with Calculation.cubIdO = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                                    |> Option.defaultValue oldC\n                              )\n                        { modelN with modCalculations = calcs }\n                let prepareModel model =\n                    model\n                    |> fixForDimensions \n                    |> fixCalcsAndCubes\n                let addRules rules model =\n                    rules\n                    |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n                    |> Seq.fold (fun mdl (cubId, rules) ->\n                        getCubeO cubId mdl\n                        |> Option.map(fun cube ->\n                            rules \n                            |> Seq.map (fun (_, key, rule) -> key, rule)\n                            |> Cube.addRules <| cube\n                            |> swap setCube mdl\n                        )\n                        |> Option.defaultValue mdl\n                    ) model\n                    \n            \n            module Formula =\n                let [< Inline >] inline newFormula id dest exp  typ =\n                      {\n                          forId          = id\n                          forDestDecl    = Map.empty\n                          forDestination = dest\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = toExpA exp\n                          forType        = typ\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline newBase    id expr      = newFormula id []   expr ForBase        \n                let [< Inline >] inline newBaseFor id expr dest = newFormula id dest expr ForBase        \n                let [< Inline >] inline newCons    id expr      = newFormula id []   expr ForConsolidated\n                let [< Inline >] inline newConsFor id expr dest = newFormula id dest expr ForConsolidated\n                let [< Inline >] inline newAll     id expr      = newFormula id []   expr ForAll         \n                let [< Inline >] inline newAllFor  id expr dest = newFormula id dest expr ForAll         \n                let [< Inline >] inline New        ()        =\n                      {\n                          forId          = ForId <| Guid.NewGuid()\n                          forDestDecl    = Map.empty\n                          forDestination = []\n                          forDescription = \"\"\n                          forText        = \"\"\n                          forExpression  = ExiStet\n                          forType        = ForBase\n                          forOrder       = \"\"\n                      }\n                let [< Inline >] inline forId      f         = f.forId\n                let                     conso      frm       = { frm with forType  = ForConsolidated }\n                let                     setText    txt  frm  = { frm with forText  = txt             }\n                let                     setOrder   ord  frm  = { frm with forOrder = ord             }\n                let getDimDest dim frm = \n                    frm.forDestination \n                    |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n                \n        \n            module Rule =\n                let [< Inline >] inline newRule0     dest exp typ order =\n                      {\n                          rulId          = RulId <| Guid.NewGuid()\n                          rulDestination = dest\n                          rulDescription = \"\"\n                          rulExpression  = exp\n                          rulType        = typ\n                          rulOrder       = order\n                          rulSourceId    = None\n                          rulXml         = \"\"\n                      }\n                let [< Inline >] inline newRule     dest exp typ order = newRule0     dest (toExpA exp) typ order\n                let [< Inline >] inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n                let New() = newRule0 [] ExiStet ForBase \"\"\n                let conso rul = { rul with rulType = ForConsolidated }    \n            \n            module Attribute =\n                let New() = \n                    {\n                        attId            = AttId <| Guid.NewGuid()\n                        attName          = \"\"\n                        attTableNum      = 1\n                        attType          = AtString\n                    }\n            \n    //#cd @\"..\\projects\\RuleEditor\\src\"\n    //#define WEBSHARPER\n    [< JavaScript >]\n    module RuleEditor =\n        //#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n         \n        //#r @\"Compiled\\CalculationModelDll\\CalculationModelDll.dll\"\n        open CalculationModel.CalculationModel\n        \n        //type Selection  = (TreeNodeId * (ForId option)) option\n        \n        type Version = {\n            major     : int\n            minor     : int\n            majorDate : string\n            minorDate : string\n        }\n        \n        module Version =\n            let New() = {\n                major     = 0\n                minor     = 0\n                majorDate = \"\"\n                minorDate = \"\"\n            }\n            let incrementMinor v = { v with minor = v.minor + 1; minorDate = nowStamp() }\n            let incrementMajor v = {        major = v.major + 1; majorDate = nowStamp()\n                                            minor = 0          ; minorDate = nowStamp() }\n        \n        type ModelUI = {\n            //treeHierarchy : Var<TreeNode []>\n            calculations  : ListModel<CalId        , Calculation>\n            totals        : ListModel<TotId        , Total      >\n            dimensions    : ListModel<DimId        , Dimension  >\n            cubes         : ListModel<CubId        , Cube       >\n            globalDefs    : Var<string>\n            server        : Var<string>\n            //selection     : Var<Selection>\n            selectedDim   : Var<DimId option>\n            selectedCube  : Var<CubId option>\n            collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n            cubePrefix    : Var<string>\n            measurePrefix : Var<string>\n            outputMsgs    : Var<string>\n            codeFS        : Var<string>\n            parserMsgs    : Var<string>\n            fileName      : Var<string>\n            version       : Var<Version>\n        }\n        \n        type MsgModel =\n        | AddTotal\n        | SelectTotal       of TotId\n        | RemoveTotal       of TotId\n        | AddCalculation\n        | RemoveCube        of CubId\n        | RenameCube        of CubId * string\n        | AddCube           of         string * Set<DimId>\n        | RemoveCalculation of CalId\n        | SelectCalculation of CalId\n        | AddFormula        of CalId\n        | RemoveFormula     of ForId\n        | SelectFormula     of ForId\n        //| SelectFormNode    of ForId * TreeNodeId\n        //| SelectNode        of         TreeNodeId\n        //| ExpandNode        of bool  * TreeNodeId\n        //| IndentNode        of bool  * TreeNodeId\n        //| MoveNode          of bool  * TreeNodeId * TreeNodeId\n        | AddDimension\n        | RemoveDimension   of DimId\n        | SelectDimension   of DimId\n        | AddFormDim        of ForId * DimId * string\n        | RemoveFormDim     of ForId * DimId\n        | RemoveCalcDim     of CalId * DimId\n        | AddCalcDim        of CalId * DimId\n        | RemoveForDest     of CalId * ForId * DimId \n        | SetForDest        of CalId * ForId * DimId * string\n        | NoOp\n        \n        module ModelUI =\n            //let isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\n            let selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n            \n            let nonTotal        = { Total      .New()                with totId = TotId System.Guid.Empty }\n            let nonCalculation  = { Calculation.New()                with calId = CalId System.Guid.Empty } \n            let nonFormula      = { Formula    .New()                with forId = ForId System.Guid.Empty }\n            //let nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n            \n            let nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            let nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\n            let nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n            \n            //let isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n        \n            let refreshView, refreshNow =\n                let refresh = Var.Create ()\n                refresh.View, fun () -> refresh.Value <- ()\n            //let setHierarchy model (nodes: TreeNode seq) =\n            //    nodes\n            //    |> Seq.map (fun n -> parents.Remove n.nid |> ignore ; n)\n            //    |> Seq.toArray\n            //    |> model.treeHierarchy.Set\n        \n            let [<Inline>] inline mapIds f vls = vls |> View.Map (Seq.map f >> Seq.toArray) |> View.consistent\n        \n            let getDimsCubeO cubes = cubes\n            \n            \n        [< AutoOpen >]\n        module Global =\n            let model = {\n                //treeHierarchy = Var.Create [||]\n                calculations  = ListModel.Create (fun v -> v.calId) [||]\n                totals        = ListModel.Create (fun v -> v.totId) [||]\n                dimensions    = ListModel.Create (fun v -> v.dimId) [||]\n                cubes         = ListModel.Create (fun v -> v.cubId) [||]\n                globalDefs    = Var.Create \"\"\n                server        = Var.Create \"\"\n                //selection     = Var.Create None\n                selectedDim   = Var.Create None\n                selectedCube  = Var.Create None\n                collapsed     = ListModel.Create id [||]\n                cubePrefix    = Var.Create \"Z\"\n                measurePrefix = Var.Create \"M\"\n                outputMsgs    = Var.Create \"\"\n                codeFS        = Var.Create \"\"\n                parserMsgs    = Var.Create \"\"\n                fileName      = Var.Create \"NewFile.json\"\n                version       = Var.Create <| Version.New()\n            }\n            \n            let mutable processor = fun (msg:MsgModel) -> ()\n            \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText model.outputMsgs msg\n            let inline appendParser msg = appendText model.parserMsgs msg\n        \n        module TableDimensions =\n            open Templating\n        \n            let dtypes =   [ \n                DtDataType\n                DtTime\n                DtVersion\n                DtOther    ] \n        \n            let tableDimensions () =\n                TemplateLib.DimensionTable()\n                    .TBody(\n                        model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n                            //let selDimW = V (model.selectedDim.V = Some did)\n                            TemplateLib.DimensionRow()\n                                .Name(          Lens dimV.V.dimName       )\n                                .Abbreviation(  Lens dimV.V.dimPrefix     )\n                                .Order(         Lens dimV.V.dimOrder      )\n                                .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                                .ExcludeName(   Lens dimV.V.dimExclude    )\n                                .IncludeFreeze( Lens dimV.V.dimFreeze     )\n                                .Remove(        fun _ -> RemoveDimension did |> processor )\n                                .Select(        fun _ -> SelectDimension did |> processor )\n                                .Doc()        \n                        )\n                    )\n                    .Doc()\n        module MainProgram =\n            open FusionAsyncM\n            open Operators\n            open Templating\n        \n            open FsRoot\n            module AF = AppFramework \n        \n            let RuleEditorLyt = \"RuleEditorLyt\"\n        \n            let scrollToBottom (e:Dom.Element) (_:obj) = \n                async { \n                    do! Async.Sleep 100\n                    do  e.ScrollTop <- e.ScrollHeight\n                } |> Async.Start\n        \n        //    let mainLayout() =\n        //        TemplateLib.Layout()\n        //            .CalculationTable( tableCalculations()                  )\n        //            .FormulaDetail(    details          ()                  )\n        //            .DimsSelected(     dimsSelected     ()                  )\n        //            .DimensionTable(   tableDimensions  ()                  )\n        //            .GlobalText(       globalDefs       ()                  )\n        //            .Server(           model.server                         )\n        //            .Output(           model.outputMsgs                     )\n        //            .FSCode(           model.codeFS                         )\n        //            .Parser(           model.parserMsgs                     )\n        //            .Filename(         model.fileName                       )\n        //            .AddCalculation(   fun _ -> AddCalculation |> processor )\n        //            .AddTotal(         fun _ -> AddTotal       |> processor )\n        //            .NewDimension(     fun _ -> AddDimension   |> processor )\n        //            .SaveAs(           fun _ -> SaveLoad.saveAsFile()       )\n        //            .LoadFileChanged(  fun e -> SaveLoad.loadFile e.Target  )\n        //            .LoadFileClear(    fun e -> e.Target?value <- \"\"        )\n        //            .UpdateRules(      fun _ -> UpdateAlea.updateModel()    )        \n        //            .IndentIn(         fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        //            .IndentOut(        fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n        //        //    .Reorder(          fun _ -> reorder()                                    )\n        //            .JumpRef(ParseFS.jumpToRef)\n        //            .OutputAfterRender(fun e -> model.outputMsgs.View |> View.Sink (scrollToBottom e))\n        //            .Doc()\n        \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = \"RuleEditor\"\n                    AF.plgVars    = [| //AF.newVar  \"fileName\"        LoadSave.fileName\n                                       //AF.newVar  \"SnippetName\"     (Lens Snippets.currentSnippetV.V.snpName)\n                                       //AF.newVar  \"Content\"         (Lens Snippets.currentSnippetV.V.snpContent)\n                                       //AF.newVar  \"Output\"          outputMsgs\n                                       //AF.newVar  \"Parser\"          FStation.annotationsV\n                                    |]  \n                    AF.plgViews   = [| //AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                                       //AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                                       //AF.newViw  \"CurrentPath\"     Snippets.currentPathW\n                                    |]  \n                    AF.plgDocs    = [| //AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                                       //AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                                       //AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                                       //AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                                       //AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                                       AF.newDoc  \"Dimensions\"      (lazy TableDimensions.tableDimensions() )\n                                    |]  \n                    AF.plgActions = [| //AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                                       //AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                                       //AF.newAct  \"IndentIn\"        Snippets.indentIn       \n                                       //AF.newAct  \"IndentOut\"       Snippets.indentOut\n                                       //AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                                       //AF.newAct  \"SaveAs\"          LoadSave.saveAs\n                                       //AF.newAct  \"RunFS\"           runFsCode\n                                       //AF.newAct  \"AbortFsi\"        FsiAgent.abortFsiExe\n                                       //AF.newAct  \"DisposeFsi\"      FsiAgent.disposeFsiExe\n                                       //AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadSave.loadTextFile   ), \"FileElement\")\n                                       //AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile     ), \"FileElement\")\n                                       //AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef        ), \"textarea\"   )\n                                       //AF.newActF \"ButtonClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.buttonClick), \"button\"     )\n                                       //AF.newActF \"ActionClick\"     <| AF.FunAct1 ((fun o -> unbox o |> CustomAction.actionClick), \"name\"       )\n                                       AF.newAct  \"AddDimension\"    (fun () -> AddDimension   |> processor)\n                                    |]\n                    AF.plgQueries = [|                                               \n                                    |]\n                }\n                \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -200 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS none x btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddDimension  button RuleEditor.AddDimension      \"\"                  \"Add Dimension \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                \"\"\"\n                |> String.unindentStr\n                |> LayoutEngine.newLyt RuleEditorLyt\n                |> LayoutEngine.addLayout\n        \n                None\n                |> Option.defaultValue RuleEditorLyt\n                |> AF.mainDocV.Set\n        \n                async {\n                  //do! Monaco.loader\n                  //WcSplitter.init horizontal vertical\n                  //WcTabStrip.init()\n                  //let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n                  return AF.getMainDoc.Value\n                } |> Doc.Async            \n                \n        //#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#define FSS_SERVER\n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n                Content.Page(Title = \"Main Page\" \n                           , Body  = [\n                                Html.client <@ MainProgram.mainProgram() @>\n                                Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                             ])\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
