{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Sitelets/Router.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Sitelets\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen System.Collections.Generic\nopen System.Text\n\n#nowarn \"64\" // type parameter renaming warnings \n\n[<NamedUnionCases \"result\"; RequireQualifiedAccess>]\ntype ParseRequestResult<'T> =\n    | [<CompiledName \"success\">]\n      Success of endpoint: 'T\n    | [<CompiledName \"invalidMethod\">]\n      InvalidMethod of endpoint: 'T * ``method``: string\n    | [<CompiledName \"invalidJson\">]\n      InvalidJson of endpoint: 'T\n    | [<CompiledName \"missingQueryParameter\">]\n      MissingQueryParameter of endpoint: 'T * queryParam: string\n    | [<CompiledName \"missingFormData\">]\n      MissingFormData of endpoint: 'T * formFieldName: string\n\n    member this.Value =\n        match this with\n        | Success a\n        | InvalidMethod (a, _)\n        | InvalidJson a\n        | MissingQueryParameter (a, _)\n        | MissingFormData (a, _) -> a\n\n    [<System.Obsolete \"Use Value instead\">]\n    member this.Action = this.Value\n\n[<System.Obsolete \"Use ParseRequestResult instead of ActionEncoding.DecodeResult\">]\n/// For back-compatibility only, use ParseRequestResult instead of ActionEncoding.DecodeResult\nmodule ActionEncoding =\n\n    type DecodeResult<'T> = ParseRequestResult<'T>\n\n    let Success endpoint = ParseRequestResult.Success endpoint\n    let InvalidMethod (endpoint, ``method``) = ParseRequestResult.InvalidMethod(endpoint, ``method``)\n    let InvalidJson endpoint = ParseRequestResult.InvalidJson endpoint\n    let MissingQueryParameter (endpoint, queryParam) = ParseRequestResult.MissingQueryParameter(endpoint, queryParam)\n    let MissingFormData (endpoint, formFieldName) = ParseRequestResult.MissingFormData(endpoint, formFieldName)\n\nmodule StringEncoding =\n\n    [<JavaScript>]\n    let isUnreserved isLast c =\n        match c with\n        | '-' | '_' -> true\n        | '.' -> not isLast\n        | c when c >= 'A' && c <= 'Z' -> true\n        | c when c >= 'a' && c <= 'z' -> true\n        | c when c >= '0' && c <= '9' -> true\n        | _ -> false\n    \n    let writeEscaped (w: System.Text.StringBuilder) isLast c =\n        let k = int c\n        if isUnreserved isLast c then w.Append c\n        elif k < 256 then w.AppendFormat(\"~{0:x2}\", k)\n        else w.AppendFormat(\"~u{0:x4}\", k)\n        |> ignore\n\n    [<JavaScript>]\n    let writeEscapedAsString isLast c =\n        let k = int c\n        if isUnreserved isLast c then string c\n        elif k < 256 then \"~\" + k.JS.ToString(16).PadLeft(2, '0')\n        else \"~u\" + k.JS.ToString(16).PadLeft(4, '0')\n\n    [<JavaScript>]\n    let write (s: string) = \n        if IsClient then\n            s |> Seq.mapi (fun i c ->\n                writeEscapedAsString (i + 1 = s.Length) c\n            )\n            |> String.concat \"\"\n        else\n            let b = System.Text.StringBuilder()\n            s |> Seq.iteri (fun i c ->\n                writeEscaped b (i + 1 = s.Length) c)\n            string b\n\n    [<JavaScript>]\n    let inline ( ++ ) (a: int) (b: int) = (a <<< 4) + b\n\n    [<Literal>]\n    let EOF = -1\n\n    [<Literal>]\n    let ERROR = -2\n\n    let readEscaped (r: System.IO.TextReader) =\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match r.Read() with\n        | x when x = int '~' ->\n            match r.Read() with\n            | x when x = int 'u' ->\n                let a = r.Read()\n                let b = r.Read()\n                let c = r.Read()\n                let d = r.Read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = r.Read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n\n    [<JavaScript>]\n    let readEscapedFromChars (chars: int list) =\n        let mutable chars = chars\n        let read() =\n            match chars with\n            | [] -> -1\n            | h :: t ->\n                chars <- t\n                h\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match read() with\n        | x when x = int '~' ->\n            match read() with\n            | x when x = int 'u' ->\n                let a = read()\n                let b = read()\n                let c = read()\n                let d = read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n        , chars\n\n    [<JavaScript>]\n    let read (s: string) = \n        if IsClient then\n            let buf = ResizeArray()\n            let rec loop chars =\n                match readEscapedFromChars chars with\n                | ERROR, _ -> None\n                | EOF, _ -> Some (buf |> String.concat \"\")\n                | x, chars -> \n                    buf.Add(string (char x))\n                    loop chars\n            s |> Seq.map int |> List.ofSeq |> loop\n        else\n            let buf = System.Text.StringBuilder()\n            use i = new System.IO.StringReader(s)\n            let rec loop () =\n                match readEscaped i with\n                | ERROR -> None\n                | EOF -> Some (string buf)\n                | x -> buf.Append(char x) |> ignore; loop ()\n            loop ()\n\ntype internal PathUtil =\n    static member WriteQuery q =\n        let sb = StringBuilder 128\n        let mutable start = true\n        q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n            if start then\n                start <- false\n            else \n                sb.Append('&') |> ignore                    \n            sb.Append(k).Append('=').Append(v) |> ignore\n        )\n        sb.ToString()\n\n    static member WriteLink s q =\n        let sb = StringBuilder 128\n        if List.isEmpty s then\n            sb.Append('/') |> ignore\n        else\n            s |> List.iter (fun x ->\n                if not (System.String.IsNullOrEmpty x) then\n                    sb.Append('/').Append(x) |> ignore\n            )\n        if Map.isEmpty q then () \n        else \n            let mutable start = true\n            sb.Append('?') |> ignore                    \n            q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n                if start then\n                    start <- false\n                else \n                    sb.Append('&') |> ignore                    \n                sb.Append(k).Append('=').Append(v) |> ignore\n            )\n        sb.ToString()\n\n[<Proxy(typeof<PathUtil>)>]\ntype internal PathUtilProxy =\n    static member Concat xs = \n        let sb = System.Collections.Generic.Queue()\n        let mutable start = true\n        xs |> List.iter (fun x ->\n            if not (System.String.IsNullOrEmpty x) then\n                if start then\n                    start <- false\n                else \n                    sb.Enqueue(\"/\") |> ignore                    \n                sb.Enqueue(x) |> ignore\n        )\n        sb |> System.String.Concat\n\n    static member WriteQuery q =\n        q |> Map.toSeq |> Seq.map (fun (k, v) -> k + \"=\" + v) |> String.concat \"&\"\n\n    static member WriteLink s q =\n        let query = \n            if Map.isEmpty q then \"\" \n            else \"?\" + PathUtil.WriteQuery(q)\n        \"/\" + PathUtilProxy.Concat s + query\n\n[<JavaScript>]\ntype Route =\n    {\n        Segments : list<string>\n        QueryArgs : Map<string, string>\n        FormData : Map<string, string>\n        Method : option<string> \n        Body : Lazy<string>\n    }\n\n    static member Empty =\n        {\n            Segments = []\n            QueryArgs = Map.empty\n            FormData = Map.empty\n            Method = None\n            Body = Lazy.CreateFromValue null\n        }\n    \n    static member Segment s =\n        { Route.Empty with\n            Segments = [ s ]\n        }\n\n    static member Segment s =\n        { Route.Empty with\n            Segments = s\n        }\n\n    static member Segment (s, m) =\n        { Route.Empty with\n            Segments = s\n            Method = m\n        }\n\n    static member Combine (paths: seq<Route>) =\n        let paths = Seq.toArray paths\n        match paths.Length with\n        | 1 -> paths.[0]\n        | 0 -> Route.Empty\n        | _ ->\n        let mutable method = None\n        let mutable body = null\n        let segments = System.Collections.Generic.Queue()\n        let mutable queryArgs = Map.empty\n        let mutable formData = Map.empty\n        let mutable i = 0\n        let l = paths.Length\n        while i < l do\n            let p = paths.[i]\n            match p.Method with\n            | Some _ as m ->\n                method <- m\n            | _ -> ()\n            match p.Body.Value with\n            | null -> ()\n            | b ->\n                body <- b\n            queryArgs <- p.QueryArgs |> Map.foldBack Map.add queryArgs \n            formData <- p.FormData |> Map.foldBack Map.add formData \n            p.Segments |> List.iter segments.Enqueue\n            i <- i + 1\n        {\n            Segments = List.ofSeq segments\n            QueryArgs = queryArgs\n            FormData = formData\n            Method = method\n            Body = Lazy.CreateFromValue body\n        }\n\n    static member ParseQuery(q: string) =\n        q.Split('&') |> Array.choose (fun kv ->\n            match kv.Split('=') with\n            | [| k; v |] -> Some (k, v)\n            | _ -> \n                printfn \"wrong format for query argument: %s\" kv\n                None\n        ) |> Map.ofSeq\n    \n    static member WriteQuery(q) = PathUtil.WriteQuery q\n\n    static member FromUrl(path: string, ?strict: bool) =\n        let s, q = \n            match path.IndexOf '?' with\n            | -1 -> path, Map.empty\n            | i -> \n                path.Substring(0, i),\n                path.Substring(i + 1) |> Route.ParseQuery\n        let splitOptions =\n            if Option.isSome strict && strict.Value then \n                System.StringSplitOptions.None\n            else\n                System.StringSplitOptions.RemoveEmptyEntries\n        { Route.Empty with\n            Segments = \n                s.Split([| '/' |], splitOptions) |> List.ofArray\n            QueryArgs = q\n        }\n\n    [<JavaScript false>]\n    static member FromRequest(r: Http.Request) =\n        let u = r.Uri\n        let p =\n            if u.IsAbsoluteUri then \n                u.AbsolutePath \n            else \n                let s = u.OriginalString\n                match s.IndexOf('?') with\n                | -1 -> s\n                | q -> s.Substring(0, q)\n        {\n            Segments = p.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries) |> List.ofArray\n            QueryArgs = r.Get.ToList() |> Map.ofList\n            FormData = r.Post.ToList() |> Map.ofList\n            Method = Some (r.Method.ToString())\n            Body = lazy r.BodyText\n        }\n\n    static member FromHash(path: string, ?strict: bool) =\n        match path.IndexOf \"#\" with\n        | -1 -> Route.Empty\n        | i -> \n            let h = path.Substring(i + 1)\n            if Option.isSome strict && strict.Value then \n                if h = \"\" || h = \"/\" then\n                    Route.Empty\n                elif h.StartsWith \"/\" then\n                    Route.FromUrl(h.Substring(1), true)\n                else\n                    Route.Segment(h)                    \n            else\n                Route.FromUrl(path.Substring(i), false)\n\n    member this.ToLink() = PathUtil.WriteLink this.Segments this.QueryArgs\n\n[<JavaScript>]\nmodule internal List =\n    let rec startsWith s l =\n        match s, l with\n        | [], _ -> Some l\n        | sh :: sr, lh :: lr when sh = lh -> startsWith sr lr\n        | _ -> None\n\ntype IRouter<'T> =\n    abstract Route : Http.Request -> option<'T>\n    abstract Link : 'T -> option<System.Uri>\n\n[<JavaScript>]\ntype Router =\n    {\n        Parse : Route -> Route seq\n        Segment : seq<Route> \n    }\n    \n    static member FromString (name: string) =\n        let parts = name.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton path\n                Segment = Seq.empty\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p })\n                    | _ -> Seq.empty\n                Segment = \n                    Seq.singleton (Route.Segment parts)\n            }\n\n    static member (/) (before: Router, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Segment = \n                Seq.append before.Segment after.Segment\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router, b: Router) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Segment = a.Segment\n        }\n\n    [<Inline>]\n    static member Combine<'A, 'B when 'A: equality and 'B: equality>(a: Router<'A>, b: Router<'B>) : Router<'A * 'B> =\n        a / b\n\nand [<JavaScript>] Router<'T when 'T: equality> =\n    {\n        Parse : Route -> (Route * 'T) seq\n        Write : 'T -> option<seq<Route>> \n    }\n    \n    static member (/) (before: Router<'T>, after: Router<'U>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun (p, y) -> (p, (x, y))))\n            Write = fun (v1, v2) ->\n                match before.Write v1, after.Write v2 with\n                | Some p1, Some p2 -> Some (Seq.append p1 p2)\n                | _ -> None\n        }\n\n    static member (/) (before: Router, after: Router<'T>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Write = fun v ->\n                after.Write v |> Option.map (Seq.append before.Segment)\n        }\n\n    static member (/) (before: Router<'T>, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun p -> (p, x)))\n            Write = fun v ->\n                before.Write v |> Option.map (fun x -> Seq.append x after.Segment)\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router<'T>) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router<'T>, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router<'T>, b: Router<'T>) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Write = fun value ->\n                match a.Write value with\n                | None -> b.Write value\n                | p -> p\n        }\n\n    interface IRouter<'T> with\n        [<JavaScript false>]\n        member this.Route req = \n            let path = Route.FromRequest req\n            this.Parse path\n            |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n        [<JavaScript false>]\n        member this.Link ep =\n            this.Write ep |> Option.map (fun p -> System.Uri((Route.Combine p).ToLink(), System.UriKind.Relative))\n        \n[<JavaScript>]\nmodule Router =\n    [<Inline>]\n    let Combine (a: Router<'A>) (b: Router<'B>) = a / b\n    \n    [<Inline>]\n    let Shift (prefix: string) (router: Router<'A>) =\n        prefix / router\n\n    let Empty<'A when 'A: equality> : Router<'A> =\n        {\n            Parse = fun _ -> Seq.empty\n            Write = fun _ -> None\n        }\n\n    /// Creates a fully customized router.\n    let New (route: Http.Request -> option<'T>) (link: 'T -> option<System.Uri>) =\n        { new IRouter<'T> with\n            member this.Route req = route req\n            member this.Link e = link e\n        }\n\n    /// Creates a router for parsing/writing a full route using URL segments.\n    let Create (ser: 'T -> list<string>) (des: list<string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des path.Segments with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment(ser value)))\n        } : Router<'T>\n\n    /// Creates a router for parsing/writing a full route using URL segments and query parameters.\n    let CreateWithQuery (ser: 'T -> list<string> * Map<string, string>) (des: list<string> * Map<string, string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des (path.Segments, path.QueryArgs) with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                let s, q = ser value\n                Some (Seq.singleton { Route.Empty with Segments = s; QueryArgs = q })\n        }\n    \n    /// Parses/writes a single value from a query argument with the given key instead of url path.\n    let Query key (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.empty\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (p, v) ->\n                        { path with QueryArgs = newQa }, v\n                    )\n            Write = fun value ->\n                item.Write value |> Option.map (fun p -> \n                    let p = Route.Combine p\n                    match p.Segments with\n                    | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                    | _ -> Seq.empty\n                )\n        }\n\n    /// Parses/writes a single option value from an optional query argument with the given key instead of url path.\n    let QueryOption key (item: Router<'A>) : Router<option<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, None)\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, Some v\n                    )\n            Write = fun value ->\n                match value with\n                | None -> Some Seq.empty\n                | Some v ->\n                    item.Write v |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n        }\n\n    /// Parses/writes a single nullable value from an optional query argument with the given key instead of url path.\n    let QueryNullable key (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, System.Nullable())\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, System.Nullable v\n                    )\n            Write = fun value ->\n                if value.HasValue then\n                    item.Write value.Value |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n                else\n                    Some Seq.empty\n        }\n\n    let Method (m: string) : Router =\n        {\n            Parse = fun path ->\n                match path.Method with\n                | Some pm when pm = m -> Seq.singleton path\n                | _ -> Seq.empty\n            Segment =\n                Seq.singleton { Route.Empty with Method = Some m }\n        }\n\n    let Body (deserialize: string -> option<'A>) (serialize: 'A -> string) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.Body.Value with\n                | null -> Seq.empty\n                | x ->\n                    match deserialize x with\n                    | Some b -> Seq.singleton ({ path with Body = Lazy.CreateFromValue null}, b)\n                    | _ -> Seq.empty\n            Write = fun value ->\n                Some <| Seq.singleton { Route.Empty with Body = Lazy.CreateFromValue (serialize value) }\n        }\n\n    let FormData (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                item.Parse { path with QueryArgs = path.FormData }\n                |> Seq.map (fun (_, r) -> path, r)\n            Write = fun value ->\n                item.Write value\n                |> Option.map (Seq.map (fun p -> { p with QueryArgs = Map.empty; FormData = p.QueryArgs }))  \n        }\n    \n    let Parse (router: Router<'A>) path =\n        router.Parse path\n        |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n\n    let Write (router: Router<'A>) endpoint =\n        router.Write endpoint |> Option.map Route.Combine \n\n    let TryLink (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> Some (p.ToLink())\n        | None -> None\n\n    let Link (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> p.ToLink()\n        | None -> \"\"\n\n    let Ajax (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some path ->\n            let settings = AjaxSettings(DataType = DataType.Text)\n            match path.Method with\n            | Some m -> settings.Type <- As m\n            | _ -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    settings.ContentType <- Union1Of2 false\n                    settings.Data <- fd\n                    settings.ProcessData <- false\n            | b ->\n                settings.ContentType <- Union2Of2 \"application/json\"\n                settings.Data <- b\n                settings.ProcessData <- false\n            if Option.isNone path.Method then settings.Type <- RequestType.POST \n            Async.FromContinuations (fun (ok, err, cc) ->\n                settings.Success <- fun res _ _ -> ok (As<string> res) \n                settings.Error <- fun _ _ msg -> err (exn msg)\n                // todo: cancellation\n                let url = path.ToLink()\n                JQuery.Ajax(url, settings) |> ignore\n            )\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let Fetch (router: Router<'A>) endpoint : Promise<Response> =\n        match Write router endpoint with\n        | Some path ->\n            let options = RequestOptions()\n            match path.Method with\n            | Some m -> options.Method <- m\n            | None -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    options.Body <- fd\n            | b ->\n                options.Body <- b\n            if Option.isNone path.Method then options.Method <- \"POST\"\n            JS.Fetch(path.ToLink(), options)\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let HashLink (router: Router<'A>)  endpoint =\n        \"#\" + Link router endpoint\n    \n    /// Maps a router to a narrower router type. The decode function must return None if the\n    /// value can't be mapped to a value of the target.\n    let Slice (decode: 'T -> 'U option) (encode: 'U -> 'T) (router: Router<'T>) : Router<'U> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Maps a router to a wider router type. The encode function must return None if the\n    /// value can't be mapped back to a value of the source.\n    let Embed (decode: 'A -> 'B) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Maps a router with a bijection.\n    let Map (decode: 'A -> 'B) (encode: 'B -> 'A) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Combination of Slice and Embed, a mapping from a subset of source values to\n    /// a subset of target values. Both encode and decode must return None if\n    /// there is no mapping to a value of the other type.\n    let TryMap (decode: 'A -> 'B option) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Filters a router, only parsing/writing values that pass the predicate check.\n    let Filter predicate router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.filter (snd >> predicate)\n            Write = fun value ->\n                if predicate value then router.Write value else None\n        }\n\n    [<Name \"Box\">]\n    let private BoxImpl tryUnbox (router: Router<'A>): Router<obj> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, box v) \n            Write = fun value ->\n                tryUnbox value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts to Router<obj>. When writing, a type check against type A is performed.\n    let Box (router: Router<'A>): Router<obj> =\n        BoxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Inline>]\n    let Json<'T when 'T: equality> : Router<'T> =\n        Body (fun s -> try Some (Json.Deserialize<'T> s) with _ -> None) Json.Serialize<'T>\n\n    [<Name \"Unbox\">]\n    let UnboxImpl<'A when 'A: equality> tryUnbox (router: Router<obj>) : Router<'A> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryUnbox v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                box value |> router.Write\n        }\n\n    [<Inline>]\n    /// Converts from Router<obj>. When parsing, a type check against type A is performed.\n    let Unbox<'A when 'A: equality> (router: Router<obj>) : Router<'A> =\n        UnboxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Name \"Cast\">]\n    let private CastImpl tryParseCast tryWriteCast (router: Router<'A>): Router<'B> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryParseCast v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                tryWriteCast value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts a Router<A> to Router<B>. When parsing and writing, type checks are performed.\n    /// Upcasting do not change set of parsed routes, downcasting restricts it within the target type.\n    let Cast (router: Router<'A>): Router<'B> =\n        CastImpl (fun v -> match box v with :? 'B as v -> Some v | _ -> None) (fun v -> match box v with :? 'A as v -> Some v | _ -> None) router\n\n    /// Maps a single-valued (non-generic) Router to a specific value.\n    let MapTo value (router: Router) =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun p -> p, value) \n            Write = fun v ->\n                if v = value then Some router.Segment else None\n        }\n\n    /// Parses/writes using any of the routers, attempts are made in the given order.\n    let Sum (routers: seq<Router<_>>) =\n        let routers = Array.ofSeq routers\n        {\n            Parse = fun path ->\n                routers |> Seq.collect (fun r -> r.Parse path)\n            Write = fun value ->\n                routers |> Seq.tryPick (fun r -> r.Write value)\n        }\n    \n    // todo: optimize\n    let Table<'T when 'T : equality> (mapping: seq<'T * string>) : Router<'T> =\n        mapping |> Seq.map (fun (v, s) -> Router.FromString s |> MapTo v) |> Sum \n\n    let Single<'T when 'T : equality> (endpoint: 'T) (route: string) : Router<'T> =\n        let parts = route.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton (path, endpoint)\n                Write = fun value -> if value = endpoint then Some Seq.empty else None\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p }, endpoint)\n                    | _ -> Seq.empty\n                Write = fun value ->\n                    if value = endpoint then Some (Seq.singleton (Route.Segment parts)) else None\n            }\n\n    let Delay<'T when 'T: equality> (getRouter: unit -> Router<'T>) : Router<'T> =\n        let r = lazy getRouter()\n        {\n            Parse = fun path -> r.Value.Parse path\n            Write = fun value -> r.Value.Write value\n        }\n\n    /// Creates a router for parsing/writing an Array of values.\n    let Array (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Int32.TryParse h with\n                    | true, l ->\n                        let rec collect l path acc =\n                            if l = 0 then Seq.singleton (path, Array.ofList (List.rev acc))\n                            else item.Parse path |> Seq.collect(fun (p, a) -> collect (l - 1) p (a :: acc))\n                        collect l { path with Segments = t } []\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (Seq.append (Seq.singleton (Route.Segment (string value.Length))) (parts |> Seq.collect Option.get))\n                else None                      \n        }\n\n    /// Creates a router for parsing/writing a Nullable value.\n    let Nullable (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"null\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, System.Nullable())\n                | _ ->\n                    item.Parse path |> Seq.map (fun (p, v) -> p, System.Nullable v)\n            Write = fun value ->\n                if value.HasValue then \n                    item.Write value.Value\n                else \n                    Some (Seq.singleton (Route.Segment \"null\"))\n        }\n\n    /// Creates a router for parsing/writing an F# option of a value.\n    let Option (item: Router<'A>) : Router<'A option> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"None\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, None)\n                | \"Some\" :: p ->\n                    item.Parse { path with Segments = p } |> Seq.map (fun (p, v) -> p, Some v)\n                | _ ->\n                    Seq.empty\n            Write = fun value ->\n                match value with \n                | None -> Some (Seq.singleton (Route.Segment \"None\"))\n                | Some v -> \n                    item.Write v |> Option.map (Seq.append (Seq.singleton (Route.Segment \"Some\")))\n        }\n\n    module FArray = Collections.Array\n\n    type IListArrayConverter =\n        abstract OfArray: obj -> obj\n        abstract ToArray: obj -> obj\n\n    type ListArrayConverter<'T>() =\n        interface IListArrayConverter with\n            member this.OfArray a = List.ofArray (unbox<'T []> a) |> box\n            member this.ToArray l = List.toArray (unbox<'T list> l) |> box\n\n    /// Creates a router for parsing/writing an F# list of a value.\n    let List (item: Router<'A>) : Router<'A list> =\n        Array item |> Map List.ofArray FArray.ofList\n\ntype Router with\n    [<Inline>]\n    member this.MapTo(value: 'T) =\n        Router.MapTo value this\n\n    [<Inline>]\n    static member Sum ([<System.ParamArray>] routers: Router<'T>[]) =\n        Router.Sum routers\n\n    [<Inline>]\n    static member Empty<'T when 'T: equality>() =\n        Router.Empty<'T>\n\n    [<JavaScript false>]\n    static member New(route: System.Func<Http.Request, 'T>, link: System.Func<'T, System.Uri>) =\n        Router.New (route.Invoke >> Option.ofObj) (link.Invoke >> Option.ofObj)\n\n    [<Inline>]\n    static member Method(method:string) =\n        Router.Method method\n\n    [<Inline>]\n    static member Body(des:System.Func<string, 'T>, ser: System.Func<'T, string>) =\n        Router.Body (fun s -> des.Invoke s |> Option.ofObj) ser.Invoke \n\n    [<Inline>]\n    static member Json<'T when 'T: equality>() =\n        Router.Json<'T>\n\n    [<Inline>]\n    static member Table([<System.ParamArray>] mapping: ('T * string)[]) =\n        Router.Table mapping\n\n    [<Inline>]\n    static member Single(endpoint, route) =\n        Router.Single endpoint route\n\n    [<Inline>]\n    static member Delay(getRouter: System.Func<Router<'T>>) =\n        Router.Delay getRouter.Invoke\n\ntype Router<'T when 'T: equality> with\n\n    [<Inline>]\n    member this.Query(key: string) =\n        Router.Query key this\n\n    [<Inline>]\n    member this.Link(endpoint: 'T) =\n        Router.Link this endpoint\n\n    [<Inline>]\n    member this.TryLink(endpoint: 'T, link: byref<string>) =\n        match Router.TryLink this endpoint with\n        | Some l ->\n            link <- l\n            true\n        | _ -> false\n               \n    [<Inline>]\n    member this.HashLink(endpoint: 'T) =\n        Router.HashLink this endpoint\n\n    [<Inline>]\n    member this.Map(decode: System.Func<'T, 'U>, encode: System.Func<'U, 'T>) =\n        Router.TryMap (decode.Invoke >> ofObjNoConstraint) (encode.Invoke >> ofObjNoConstraint) this\n\n    [<Inline>]\n    member this.Filter(predicate: System.Func<'T, bool>) =\n        Router.Filter predicate.Invoke this\n\n    [<Inline>]\n    member this.Cast<'U when 'U: equality>() : Router<'U> =\n        Router.Cast this\n\n    [<Inline>]\n    member this.FormData() =\n        Router.FormData this\n\n    [<Inline>]\n    member this.Ajax(endpoint) =\n        Router.Ajax this endpoint |> Async.StartAsTask\n\n    [<Inline>]\n    member this.Box() =\n        Router.Box this\n\n    [<Inline>]\n    member this.Array() =\n        Router.Array this\n\nopen System.Runtime.CompilerServices\n    \n[<Extension>]\ntype RouterExtensions =\n    [<Inline>]\n    static member QueryNullable(router, key) =\n        Router.QueryNullable key router\n\n    [<Inline>]\n    static member Unbox<'T when 'T: equality>(router) =\n        Router.Unbox<'T> router\n\n    [<Inline>]\n    static member Nullable(router) =\n        Router.Nullable router\n\nmodule IRouter =\n    open System\n\n    let Empty : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route _ = None\n            member this.Link _ = None\n        }        \n\n    let Add (r1: IRouter<'T>) (r2: IRouter<'T>) =\n        { new IRouter<'T> with\n            member this.Route req = match r1.Route req with Some _ as l -> l | _ -> r2.Route req\n            member this.Link e = match r1.Link e with Some _ as l -> l | _ -> r2.Link e\n        }        \n\n    let Sum (routers: seq<IRouter<'T>>) : IRouter<'T> =\n        let routers = Array.ofSeq routers\n        if Seq.isEmpty routers then Empty else\n            { new IRouter<'T> with\n                member this.Route req = routers |> Array.tryPick (fun r -> r.Route req)\n                member this.Link e = routers |> Array.tryPick (fun r -> r.Link e)\n            }        \n            \n    let Map encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> router.Link\n        } \n        \n    let TryMap encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.bind encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let Embed encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let private makeUri uri =\n        let mutable res = null\n        if Uri.TryCreate(uri, UriKind.Relative, &res) then res else\n            Uri(uri, UriKind.Absolute)\n    \n    let private path (uri: Uri) =\n        if uri.IsAbsoluteUri\n        then uri.AbsolutePath\n        else uri.OriginalString |> joinWithSlash \"/\"\n        \n    let private trimFinalSlash (s: string) =\n        match s.TrimEnd('/') with\n        | \"\" -> \"/\"\n        | s -> s\n    \n    let Shift prefix (router: IRouter<'T>) =\n        let prefix = joinWithSlash \"/\" prefix\n        let shift (loc: System.Uri) =\n            if loc.IsAbsoluteUri then loc else\n                makeUri (joinWithSlash prefix (path loc) |> trimFinalSlash)\n        { new IRouter<'T> with\n            member this.Route req =\n                let builder = UriBuilder req.Uri\n                if builder.Path.StartsWith prefix then\n                    builder.Path <- builder.Path.Substring prefix.Length\n                    router.Route (req.WithUri(builder.Uri))\n                else\n                    None\n            member this.Link e = router.Link e |> Option.map shift\n        }     \n        \n    let Box (router: IRouter<'T>) : IRouter<obj> =\n        { new IRouter<obj> with\n            member this.Route req = router.Route req |> Option.map box\n            member this.Link e = tryUnbox<'T> e |> Option.bind router.Link\n        } \n\n    let Unbox (router: IRouter<obj>) : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route req = router.Route req |> Option.bind tryUnbox<'T>\n            member this.Link e = box e |> router.Link\n        } \n\n[<JavaScript>]\nmodule RouterOperators =\n    let rRoot : Router =\n        {\n            Parse = fun path -> Seq.singleton path\n            Segment = Seq.empty\n        }\n    \n    [<Inline>]\n    /// Parse/write a specific string.\n    let r name : Router = Router.FromString name\n\n    /// Parse/write a string using URL encode/decode.\n    let rString : Router<string> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some s ->\n                        Seq.singleton ({ path with Segments = t }, s)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if isNull value then \"null\" else StringEncoding.write value)))\n        }\n\n    /// Parse/write a char.\n    let rChar : Router<char> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some c when c.Length = 1 ->\n                        Seq.singleton ({ path with Segments = t }, char c)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    [<Inline>]\n    let inline rTryParse< ^T when ^T: (static member TryParse: string * byref< ^T> -> bool) and ^T: equality>() =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    let mutable res = Unchecked.defaultof< ^T>\n                    let ok = (^T: (static member TryParse: string * byref< ^T> -> bool) (h, &res))\n                    if ok then \n                        Seq.singleton ({ path with Segments = t }, res)\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    /// Parse/write a Guid.\n    let rGuid = rTryParse<System.Guid>()\n    /// Parse/write an int.\n    let rInt = rTryParse<int>()\n    /// Parse/write a double.\n    let rDouble = rTryParse<double>()\n    /// Parse/write a signed byte.\n    let rSByte = rTryParse<sbyte>() \n    /// Parse/write a byte.\n    let rByte = rTryParse<byte>() \n    /// Parse/write a 16-bit int.\n    let rInt16 = rTryParse<int16>() \n    /// Parse/write a 16-bit unsigned int.\n    let rUInt16 = rTryParse<uint16>() \n    /// Parse/write an unsigned int.\n    let rUInt = rTryParse<uint32>() \n    /// Parse/write a 64-bit int.\n    let rInt64 = rTryParse<int64>() \n    /// Parse/write a 64-bit unsigned int.\n    let rUInt64 = rTryParse<uint64>() \n    /// Parse/write a single.\n    let rSingle = rTryParse<single>() \n\n    /// Parse/write a bool.\n    let rBool : Router<bool> =\n        // we define rBool not with rTryParse so that fragments are capitalized\n        // to be fully consistent on client+server\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Boolean.TryParse h with\n                    | true, g ->\n                        Seq.singleton ({ path with Segments = t }, g)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if value then \"True\" else \"False\")))\n        }\n\n    /// Parses any remaining part of the URL as a string, no URL encode/decode is done.\n    let rWildcard : Router<string> = \n        {\n            Parse = fun path ->\n                let s = path.Segments |> String.concat \"/\"\n                Seq.singleton ({ path with Segments = [] }, s)\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment value))\n        }\n    \n    let rWildcardArray (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, Array.ofList (List.rev acc))\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let rWildcardList (item: Router<'A>) : Router<'A list> = \n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, List.rev acc)\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> List.map item.Write\n                if List.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    /// Parse/write a DateTime in `YYYY-MM-DD-HH.mm.ss` format.\n    let rDateTime : Router<System.DateTime> =\n        let pInt x =\n            match System.Int32.TryParse x with\n            | true, i -> Some i\n            | _ -> None\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    if h.Length = 19 && h.[4] = '-' && h.[7] = '-' && h.[10] = '-' && h.[13] = '.' && h.[16] = '.' then\n                        match pInt h.[0 .. 3], pInt h.[5 .. 6], pInt h.[8 .. 9], pInt h.[11 .. 12], pInt h.[14 .. 15], pInt h.[17 .. 18] with\n                        | Some y, Some m, Some d, Some h, Some mi, Some s  ->\n                            Seq.singleton ({ path with Segments = t }, System.DateTime(y, m, d, h, mi, s))\n                        | _ -> Seq.empty\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun d ->\n                let pad2 (x: int) =\n                    let s = string x\n                    if s.Length = 1 then \"0\" + s else s\n                let pad4 (x: int) =\n                    let s = string x\n                    match s.Length with\n                    | 1 -> \"000\" + s\n                    | 2 -> \"00\" + s\n                    | 3 -> \"0\" + s\n                    | _ -> s\n                let s = \n                    pad4 d.Year + \"-\" + pad2 d.Month + \"-\" + pad2 d.Day\n                    + \"-\" + pad2 d.Hour + \".\" + pad2 d.Minute + \".\" + pad2 d.Second\n                Some (Seq.singleton (Route.Segment s))\n        }\n      \n    let internal Tuple (readItems: obj -> obj[]) (createTuple: obj[] -> obj) (items: Router<obj>[]) =\n        {\n            Parse = fun path ->\n                let rec collect elems path acc =\n                    match elems with \n                    | [] -> Seq.singleton (path, createTuple (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect (List.ofArray items) path []\n            Write = fun value ->\n                let parts =\n                    (readItems value, items) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let internal JSTuple (items: Router<obj>[]) : Router<obj> =\n        let readItems (value: obj) =\n            Array.init items.Length (fun i ->\n                (As<Array<obj>> value).[i]\n            )\n        Tuple readItems box items\n\n    [<Inline>]\n    let internal JSEmpty () : Router<obj> = Router.Empty<obj>\n\n    [<Inline>]\n    let internal JSArray item = Router.Array item\n    \n    [<Inline>]\n    let internal JSList item = Router.List item\n\n    [<Inline>]\n    let internal JSOption item = Router.Option item\n\n    [<Inline>]\n    let internal JSNullable item = Router.Nullable item\n\n    [<Inline>]\n    let internal JSQuery key item = Router.Query key item\n\n    [<Inline>]\n    let internal JSQueryOption key item = Router.QueryOption key item\n\n    [<Inline>]\n    let internal JSQueryNullable key item = Router.QueryNullable key item\n\n    [<Inline>]\n    let internal JSFormData item = Router.FormData item\n\n    [<Inline>]\n    let internal JSJson<'T when 'T: equality> = Router.Json<'T>\n\n    [<Inline>]\n    let internal JSBox item = Router.Box item\n\n    [<Inline>]\n    let internal JSDelayed getRouter = Router.Delay getRouter\n        \n    let internal JSRecord (t: obj) (fields: (string * bool * Router<obj>)[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createRecord fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let fields = fields |> Array.map (fun (_, _, r) -> r)\n        let fieldsList =  List.ofArray fields        \n        {\n            Parse = fun path ->\n                let rec collect fields path acc =\n                    match fields with \n                    | [] -> Seq.singleton (path, createRecord (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect fieldsList path []\n            Write = fun value ->\n                let parts =\n                    (readFields value, fields) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n    \n    let internal isCorrectMethod m p =\n        match p, m with\n        | Some pm, Some m -> pm = m\n        | _, Some _ -> false\n        | _ -> true\n\n    let internal JSUnion (t: obj) (cases: (option<obj> * (option<string> * string[])[] * Router<obj>[])[]) : Router<obj> = \n        let getTag value = \n            let constIndex =\n                cases |> Seq.tryFindIndex (\n                    function\n                    | Some c, _, _ -> value = c\n                    | _ -> false\n                )\n            match constIndex with\n            | Some i -> i\n            | _ -> value?(\"$\") \n        let readFields tag value =\n            let _, _, fields = cases.[tag]\n            Array.init fields.Length (fun i ->\n                value?(\"$\" + string i)\n            )\n        let createCase tag fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            match cases.[tag] with\n            | Some constant, _, _ -> constant\n            | _ ->\n                o?(\"$\") <- tag\n                fieldValues |> Seq.iteri (fun i v ->\n                    o?(\"$\" + string i) <- v\n                )\n                o\n        let parseCases =\n            cases |> Seq.indexed |> Seq.collect (fun (i, (_, eps, fields)) ->\n                eps |> Seq.map (fun (m, p) -> i, m, p, fields)    \n            )\n        {                                                    \n            Parse = fun path ->\n                parseCases |> Seq.collect (fun (i, m, s, fields) ->\n                    if isCorrectMethod m path.Method then\n                        match path.Segments |> List.startsWith (List.ofArray s) with\n                        | Some p -> \n                            match List.ofArray fields with\n                            | [] -> Seq.singleton ({ path with Segments = p }, createCase i [||])\n                            | fields -> \n                                let rec collect fields path acc =\n                                    match fields with \n                                    | [] -> Seq.singleton (path, createCase i (Array.ofList (List.rev acc)))\n                                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                                collect fields { path with Segments = p } []\n                        | None -> Seq.empty\n                    else\n                        Seq.empty\n                )\n            Write = fun value ->\n                let tag = getTag value\n                let _, eps, fields = cases.[tag]\n                let method, path = eps.[0]\n                let casePath = Seq.singleton (Route.Segment (List.ofArray path, method))\n                match fields with\n                | [||] -> Some casePath\n                | _ ->\n                    let fieldParts =\n                        (readFields tag value, fields) ||> Array.map2 (fun v f -> f.Write v)\n                    if Array.forall Option.isSome fieldParts then\n                        Some (Seq.append casePath (fieldParts |> Seq.collect Option.get))\n                    else None                      \n        }\n\n    let internal JSClass (ctor: unit -> obj) (fields: (string * bool * Router<obj>)[]) (endpoints: (option<string> * Union<string, int>[])[]) (subClasses: Router<obj>[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createObject fieldValues =\n            let o = ctor()\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let partsAndRoutersLists =\n            endpoints |> Array.map (fun (m, ep) ->\n                m, \n                ep |> Seq.map (fun p ->\n                    match p with\n                    | Union1Of2 s -> Choice1Of2 s\n                    | Union2Of2 i -> \n                        let _, _, r = fields.[i]\n                        Choice2Of2 (i, r)\n                ) |> List.ofSeq\n            )\n        let thisClass =\n            {\n                Parse = fun path ->\n                    let rec collect fields path arr =\n                        match fields with \n                        | [] -> \n                            Seq.singleton (path, createObject arr)\n                        | Choice1Of2 p :: t -> \n                            match path.Segments with\n                            | pp :: pr when pp = p ->\n                                collect t { path with Segments = pr } arr\n                            | _ -> Seq.empty\n                        | Choice2Of2 (i, h) :: t -> \n                            h.Parse path |> Seq.collect(fun (p, a) -> \n                                let narr = Array.copy arr\n                                narr.[i] <- a\n                                collect t p narr\n                            )\n                    partsAndRoutersLists |> Seq.collect (fun (m, ps) -> \n                        if isCorrectMethod m path.Method then\n                            let arr = Array.zeroCreate fields.Length\n                            collect ps path arr\n                        else Seq.empty\n                    )\n                Write = fun value ->\n                    let values = readFields value\n                    let method, ep = endpoints.[0]\n                    let parts =\n                        ep |> Array.map (function\n                            | Union1Of2 p -> Some (Seq.singleton (Route.Segment(p)))\n                            | Union2Of2 i ->\n                                let _, _, r = fields.[i] \n                                r.Write(values.[i])\n                        )\n                    if Array.forall Option.isSome parts then\n                        let w = parts |> Seq.collect Option.get\n                        match method with\n                        | Some _ -> Some (Seq.append (Seq.singleton { Route.Empty with Method = method }) w)\n                        | None -> Some w\n                    else None                      \n            }\n        if Array.isEmpty subClasses then\n            thisClass\n        else\n            Router.Sum (Seq.append subClasses (Seq.singleton thisClass))\n"],
"names": [],
"mappings": "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"
}
