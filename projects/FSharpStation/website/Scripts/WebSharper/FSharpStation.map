{
"version": 3,
"sourceRoot": "Source",
"sources": ["FSharpStation/FSharpStation.fs"],
"sourcesContent": ["#nowarn \"3242\"\n#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1568639954583 -d:TEE -d:WEBSHARPER\n////#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FSharpStation\\src\"\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\System.Reactive\\lib\\net46\\System.Reactive.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Control.Reactive\\lib\\net46\\FSharp.Control.Reactive.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\CommonServiceLocator\\lib\\portable-net4+sl5+netcore45+wpa81+wp8\\Microsoft.Practices.ServiceLocation.dll\"\n//#nowarn \"3242\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1568639954583\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if !NETSTANDARD20\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n    \n    #if WEBSHARPER\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    #endif\n    #endif\n    #if WEBSHARPER\n    //#nowarn \"3242\" \n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            inherit System.Attribute()\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            inherit System.Attribute()\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library = \n            let Error = Result.Error\n        \n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            //#define TEE\n            \n            let [< Inline \"new Date(0).getTime()\" >] Utc1970_01_01                 = System.DateTime(1970,1,1,0,0,0,System.DateTimeKind.Utc)\n            let [< Inline \"$d\"                    >] date2Long (d:System.DateTime) = d.Subtract(Utc1970_01_01).Ticks / 10000L\n            let [< Inline \"$l\"                    >] long2Date (l:int64          ) = Utc1970_01_01.Add(System.TimeSpan(l * 10000L) )\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let inline errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let inline warningf  fmt = Printf.ksprintf Warning  fmt\n                let inline infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            module Memoize =\n            \n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )\n                    (checkO, getOrAdd), cache.Clear\n            \n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )\n            \n                /// Memoizes function f using the provided cache\n                /// getCache() returns 1 function:\n                ///    getOrAdd: ('p->('p->'v)->'v) \n                [< Inline >]\n                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =\n                    fun p -> getOrAdd p f\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let (check, getOrAdd), clear = getStore()\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, clear\n            \n                /// Memoizes the function f using the provided Dictionary\n                [<Inline>]\n                let memoizeWithDict dict f =\n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF\n            \n                /// Memoizes the function f and returns Dictionary\n                [<Inline>]\n                let memoizeDict f =\n                    let dict = System.Collections.Generic.Dictionary<_, _>() \n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, dict\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            /// returns a function that delays its execution\n            /// runs only once even if multiple calls happen before the delay\n            let delayed delay doF =\n                let cancellationTokenSourceO = ref None\n                fun parm -> \n                    let asy = async {\n                        do! Async.Sleep delay\n                        doF parm\n                    } \n                    !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n                    cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n                    Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    let ofOption vO = \n                        match vO with\n                        | Some v -> Seq.singleton v\n                        | None   -> Seq.empty\n                \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let errorf fmt = Printf.ksprintf Error fmt\n                \n                    let rtn                          = Ok\n                    let join                       r = Result.bind id r\n                    let flatten                    r = Result.bind id r\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bind (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bind f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                    \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                        | Ok   v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                        | Error e ->      e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iterP                 fE f r = r   |> mapP f |> defaultWith fE                                                 : unit    \n                    \n                    type BuilderP() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let resultP = BuilderP()\n                    \n                    \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofAsync            a  = FAM(fun (s, r) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                    let inline ofFusionM     (FM fm) = FAM(fun (s, r) -> async.Return (fm (s, r)) )\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type ResultM<'v, 'm> = ResultM of Option<'v> * ResultMessage<'m>\n                \n                let inline OkM              v    = ResultM (Some v, NoMsg)\n                let inline OkMWithMsg       v m  = ResultM(Some v, m)\n                //let inline OkMWithMsgs      v ms = ms |> ResultMessage.reduceMsgs |> OkMWithMsg v\n                \n                let inline ErrorM             m  = ResultM (None  , m    )\n                //let inline ErrorMWithMsgs     ms = ms |> ResultMessage.reduceMsgs |> ErrorM\n                let (|OkM|ErrorM|)             r = match r with\n                                                    | ResultM(Some v, m) -> OkM   (v, m)\n                                                    | ResultM(None  , e) -> ErrorM e\n                module ResultM =\n                \n                    type CheckError<'T> = CheckErrorF of ('T -> bool)\n                    let checkError   () = CheckErrorF (fun _ -> true )\n                    let checkErrorW  () = CheckErrorF (fun _ -> false)\n                \n                    let inline rtn                 v = OkM v\n                    let inline rtnM                m = OkMWithMsg () m\n                    let inline rtnr               vR = vR  |> Result.map OkM          |> Result.defaultWith       ErrorM\n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let inline toResult            r = match r with\n                                                       | ResultM(Some v, _) -> Ok     v\n                                                       | ResultM(None  , e) -> Error  e\n                    let inline toResultD           r = match r with\n                                                       | ResultM(Some v, m) -> Ok    (v, m)\n                                                       | ResultM(None  , e) -> Error  e\n                    let toOption                   r = r   |> function ResultM (v,_) -> v\n                    let defaultWith              f r = r   |> toResult |> Result.defaultWith   f\n                    let defaultValue             d r = r   |> toResult |> Result.defaultValue  d\n                    let map         f  (ResultM (v, m)) = ResultM (v |> Option.map f, m)\n                    let mapMessage  fM (ResultM (v, m)) = ResultM (v, fM m)\n                    let bind                  f    r = match r with\n                                                       | ResultM(Some v, m) -> f v |> mapMessage (ResultMessage.addMsg m)\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | ResultM(Some v, m) -> try f v |> mapMessage (ResultMessage.addMsg m)\n                                                                               with  e -> ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    let bindM                 f    m = rtnM m |> bindP f\n                \n                    let check (CheckErrorF k) vR = vR |> function ResultM(Some _, m) when ResultMessage.isFatalF k m -> ErrorM m |_-> vR\n                \n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m\n                    let iter                  fM f r = r   |> mapP f |> function | ResultM(Some (), m) -> () | ResultM(None, m) -> fM m  : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map OkM          |> Option.defaultWith (f >> ErrorM)\n                    let ofResult                  vR = vR  |> rtnr\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> OkM None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let addMsg                  m  r = r |> mapMessage (ResultMessage.addMsg m)\n                    let failIfFatalMsgF         f  r = r |> function OkM (v, m) when ResultMessage.isFatalF f m -> ErrorM m |_-> r\n                    let failIfFatalMsg             r = r |> function OkM (v, m) when ResultMessage.isFatal    m -> ErrorM m |_-> r\n                    let failIfFatalMsgW            r = r |> function OkM (v, m) when ResultMessage.isFatalW   m -> ErrorM m |_-> r\n                    let (>>=)                    r f = bind f r\n                    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline __.Return          x       = rtn  x\n                        member inline __.ReturnFrom      x       =     (x:ResultM<_,_>)\n                        member inline __.ReturnFrom      x       =     (x:Result< _,_>)\n                        member inline __.ReturnFrom      x       = rtnM x\n                        member        __.Bind           (w , r ) = bindP  r w\n                        member        __.Bind           (w , r ) = bindM  r w\n                        member inline __.Zero           ()       = rtn ()\n                        member inline __.Delay           f       = f\n                        member inline __.Combine        (a, b)   = a |> bind b\n                        member inline __.Run             f       = OkM () |> bindP f\n                        member __.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member __.TryFinally(body, compensation) = try body() finally   compensation()\n                        member __.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member __.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                \n                [< AutoOpen >]\n                module ResultMAutoOpen =\n                    open ResultM\n                    \n                    let resultM = Builder()\n                    \n                \n                \n                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResult =\n                    let mapError fE v  = v |> Async.map (Result.mapError fE)\n                    let freeMessage v  = v |> Async.map  Result.freeMessage\n                \n                    let rtn        v   = async.Return(Ok v  )\n                    let rtnR       vR  = async.Return    vR\n                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n                    let bind  fRA  vRA = async { \n                        let! vR       = vRA\n                        match   vR with\n                        | Ok    v -> return! fRA v\n                        | Error m -> return  Error m \n                    }\n                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | Ok    v -> return! fRA   v\n                            | Error m -> return  Error m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n                    }\n                    let inline map  f m = bind  (f >> rtn) m            \n                    let inline mapP f m = bindP (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map  Result.join\n                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n                \n                type AsyncResultBuilder() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                            = fRA\n                    member __.Run              fRA                            = AsyncResult.rtn () |> AsyncResult.bind fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                    th.While(enum.MoveNext,\n                                                                                      th.Delay(fun () -> fRA enum.Current)))\n                let asyncResult = AsyncResultBuilder()\n                \n                type AsyncResultBuilderP() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                                          = fRA\n                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                              th.While(enum.MoveNext,\n                                                                                                th.Delay(fun () -> fRA enum.Current)))\n                let asyncResultP = AsyncResultBuilderP()\n                \n                [<AutoOpen>]\n                module Extensions =      \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultBuilder with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                \n                    type AsyncResultBuilderP with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n                \n                \n                \n                type AsyncResultM<'v, 'm> = Async<ResultM<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResultM =\n                    let mapError fE v  = v |> Async.map (ResultM.mapMessage fE)\n                    let freeMessage v  = v |> Async.map  ResultM.freeMessage\n                \n                    let rtn         v   = async.Return(OkM v  )\n                    let rtnr        vR  = async.Return(ResultM.rtnr vR)\n                    let rtnR        vR  = async.Return    vR\n                    let rtnM        vM  = async.Return(ResultM.rtnM vM)\n                    let rtnrA       vrA = vrA |> Async.map    ResultM.ofResult\n                    let errorMsgf   fmt = Printf.ksprintf (ErrorMsg >> ErrorM >> async.Return) fmt\n                    let iterS  fE f vRA = Async.iterS (ResultM.iter fE f) vRA\n                    let iterA  fE f vRA = Async.iterA (ResultM.iter fE f) vRA\n                    let iterpS    f vRA = vRA |> iterS (ResultMessage.summarized >> print) f\n                    let iterpA    f vRA = vRA |> iterA (ResultMessage.summarized >> print) f\n                    let bind  (fRA:'a -> Async<ResultM<'b,'c>>)  (vRA: Async<ResultM<'a,'c>>) : Async<ResultM<'b,'c>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | OkM   (v, m) -> return! fRA   v |> Async.map (ResultM.addMsg m)\n                            | ErrorM    m  -> return  ErrorM m\n                        with  e -> return ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                    }\n                    let inline bindr  f a  = rtnr   a |> bind f : AsyncResultM<_,_>\n                    let inline bindM  f a  = rtnM   a |> bind f : AsyncResultM<_,_>\n                    let inline bindrA f a  = rtnrA  a |> bind f : AsyncResultM<_,_>\n                    let inline bindR  f a  = rtnR   a |> bind f : AsyncResultM<_,_>\n                    let inline map    f m = bind  (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map (ResultM.bindP   id)\n                    let absorbO f vORA                         = vORA |> Async.map (ResultM.absorbO  f)\n                    let getResultM       (a:AsyncResultM<_,_>) = a    |> Async.map  OkM   \n                    type AsyncResultMBuilder() =\n                        member __.ReturnFrom vRA        : Async<ResultM<'v  , 'm>> =           vRA\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnr      vR\n                        member __.ReturnFrom vR         : Async<ResultM<unit, 'm>> = rtnM      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnR      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnrA     vR\n                        member __.Return     v          : Async<ResultM<'v  , 'm>> = rtn       v  \n                        member __.Zero       ()         : Async<ResultM<unit, 'm>> = rtn       () \n                        member __.Bind      (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Bind       (w , r )                              = bindr   r w\n                        member __.Bind       (w , r )                              = bindM   r w\n                        member __.Bind       (w , r )                              = bindR   r w\n                        member __.Bind       (w , r )                              = bindrA  r w\n                        member __.Combine   (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Combine   (vR ,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA (vR  |> rtnR)\n                        member __.Delay            fRA                             = fRA\n                        member __.Run              fRA                             = rtn () |> bind fRA\n                        member __.TryWith   (fRA , hnd) : Async<ResultM<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                        member __.TryFinally(fRA , fn ) : Async<ResultM<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                        member __.Using(resource , fRA) : Async<ResultM<'a  , 'm>> = async.Using(resource,       fRA)\n                        member __.While   (guard , fRA) : Async<ResultM<unit, 'a>> = whileLoop guard fRA \n                        member th.For  (s: 'a seq, fRA) : Async<ResultM<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fRA enum.Current)))\n                \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>->) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                \n                [<AutoOpen>]\n                module AsyncResultMAutoOpen =\n                    open AsyncResultM\n                \n                    let asyncResultM = AsyncResultMBuilder()\n                \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultMBuilder with\n                    member __.ReturnFrom (vA: Async<_>     ) : Async<ResultM<_,_>> =           Async.map OkM vA\n                    member __.Bind       (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                    member __.Combine    (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from >= this.Length then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = if n < 0 \n                                                  then this.Substring2(0, this.Length + n)\n                                                  else this.Substring2(0, n              )\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n                member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n                let thousands n =\n                    let v = n.ToString()\n                    let r = v.Length % 3 \n                    let s = if r = 0 then 3 else r\n                    [   yield v.[0.. s - 1]\n                        for i in 0..(v.Length - s)/ 3 - 1 do\n                            yield v.[i * 3 + s .. i * 3 + s + 2]\n                    ] |> String.concat \",\"\n            \n            [< Inline \"$a + '/' + $b\" >]\n            let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n            \n            \n                /// Javascript adds time zone information when parsing a date and that can change the result\n                let parseDateO2  = (fun s -> s + \"T00:00:00\") >> tryParseWith System.DateTime.TryParse\n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseInt64O  = tryParseWith System.Int64   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Int64 |_|) = parseInt64O\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n            type ResourceAgentState<'R, 'C> = {\n                useCount      : int\n                limitCount    : int\n                resource      : 'R\n                configuration : 'C\n            }\n            \n            type ResourceAgent<'R, 'C when 'C : equality>(maxUseCount, ctor: 'C -> 'R, configuration, ?cleanup, ?isAlive, ?respawnAfter) =\n                let clean                          = defaultArg cleanup ignore\n                let alive                          = defaultArg isAlive (fun _ -> true)\n                let initConfig                     = configuration\n                let respawnRightAfter              = defaultArg respawnAfter true\n                let respawn                  state = clean state.resource\n                                                     { state with useCount = 0 ; resource = ctor state.configuration }\n                let check                cfg state = if state.useCount < state.limitCount && alive state.resource && cfg = state.configuration\n                                                     then state \n                                                     else respawn { state with configuration = cfg }\n                let increment                state = { state with useCount = state.useCount + 1 }\n                                                     |> if respawnRightAfter then (check state.configuration) else id\n                let agent                          = Mailbox.stateFull (fun ex st -> print ex ; respawn st)  \n                                                        {   useCount      = 0\n                                                            limitCount    = maxUseCount\n                                                            configuration = initConfig\n                                                            resource      = ctor initConfig\n                                                        }\n                member __.AsyncProcessA(work,?cfg) = agent \n                                                    |> Mailbox.StateFull.applyReplyA(fun st -> async { \n                                                         let  st2 = st |> check (defaultArg cfg st.configuration) \n                                                         let! res = work st2.resource\n                                                         return increment st2, res \n                                                     })\n                member oo.ProcessA     (work,?cfg) = oo.AsyncProcessA((fun v -> async { return work v }), ?cfg=cfg)\n                [< Inline \"throw 'ResourceAgent.Process not available in JavaScript'\" >]\n                member oo.Process      (work,?cfg) = oo.ProcessA(work, ?cfg=cfg) |> Async.RunSynchronously\n                member __.State                    = agent |> Mailbox.StateFull.getState\n                member oo.LimitCount    with get() = oo.State.limitCount\n                member oo.Configuration with get() = oo.State.configuration\n                member __.LimitCount    with set n = agent |> Mailbox.StateFull.apply(fun s -> { s with limitCount    = n })\n                member oo.Configuration with set c = if c <> oo.Configuration then agent |> Mailbox.StateFull.apply(fun s -> respawn { s with configuration = c})\n                member __.Respawn               () = agent |> Mailbox.StateFull.apply respawn\n                interface System.IDisposable with\n                    member this.Dispose () = try clean this.State.resource with _ -> ()\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            module AgentReaderM =\n                open FusionAsyncM\n                open Operators\n            \n                let createAgentRm                         f  v = readerFun(fun  (agent:ResourceAgent<_,_>, cfg)     -> agent.AsyncProcessA((fun resource -> f resource v)  , cfg) ) >>= ofAsync\n                let ofResourceRm                     (FAM f)   = FAM      (fun ((agent:ResourceAgent<_,_>, cfg), m) -> \n                                                                            agent.AsyncProcessA((fun resource -> async {\n                                                                                    let! vO, _, m = f(resource, m) \n                                                                                    return vO, (agent, cfg), m \n                                                                                }), cfg) \n                                                                            )\n                let run            agent cfg                 m = runReader (agent,       cfg          ) m\n                let runSameConfig (agent:ResourceAgent<_,_>) m = runReader (agent, agent.Configuration) m\n            \n            [< AutoOpen >]\n            module CommArgRoot =\n                open FusionM\n                open Operators\n            \n                type CommArgId = CommArgId of System.Guid\n                \n                type CommArgBuild =\n                    | TInt    of (int    -> string)\n                    | TString of (string -> string)\n                    | TBool   of (bool   -> string)\n                    | TFloat  of (float  -> string)\n                \n                type CommArg = {\n                    cargId : CommArgId\n                    name   : string\n                    unique : bool\n                    build  : CommArgBuild\n                }\n                type CommArgValue<'T,  'M> = FusionM<'T, CommArgCollection<     'M>, 'M>\n                and  ArgValueTuple<    'M> = CommArg *   CommArgValue<obj,      'M>\n                and  CommArgCollection<'M> = CommArgCollection of ArgValueTuple<'M> seq\n                    with \n                        member oo.CommArgs = match oo with CommArgCollection v -> v\n                \n                type TypedCommArg<'T> = TypedCommArg of CommArg\n                    with\n                    member oo.CommArg = match oo with TypedCommArg v -> v\n                    static member (/=) (arg: TypedCommArg<'T>, v:                        'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, rtn v        |>> box)\n                    static member (/=) (arg: TypedCommArg<'T>, v: CommArgValue<          'T, _>) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg,     v        |>> box)\n                    static member (/=) (arg: TypedCommArg<'T>, f: CommArgCollection<'M>->'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, getS() |>> f |>> box)\n                \n                module CommArg  =\n                    let New0 (name, unique, build) = {\n                        cargId = CommArgId <| System.Guid.NewGuid()\n                        name   = name\n                        unique = unique\n                        build  = build\n                    }\n                    let NewInt   (name, unique, build): TypedCommArg<int   > = New0(name, unique, build |> TInt   ) |> TypedCommArg\n                    let NewString(name, unique, build): TypedCommArg<string> = New0(name, unique, build |> TString) |> TypedCommArg\n                    let NewBool  (name, unique, build): TypedCommArg<bool  > = New0(name, unique, build |> TBool  ) |> TypedCommArg\n                    let NewFloat (name, unique, build): TypedCommArg<float > = New0(name, unique, build |> TFloat ) |> TypedCommArg\n                    let argumentRm (a:CommArg) (vRm:CommArgValue<obj,_>) = fusion {\n                        let! v = vRm\n                        return\n                            match a.build with\n                            | TInt    f -> unbox<int   > v |> f\n                            | TString f -> unbox<string> v |> f\n                            | TBool   f -> unbox<bool  > v |> f\n                            | TFloat  f -> unbox<float > v |> f\n                    }\n                    let argumentTRm(a,v) = argumentRm a v\n                    let getIntR    (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TInt    _ -> unbox<int   > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TInt\"\n                    let getStringR (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TString _ -> unbox<string> o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TString\"\n                    let getBoolR   (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TBool   _ -> unbox<bool  > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TBool\"\n                    let getFloatR  (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TFloat  _ -> unbox<float > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TFloat\"\n                \n                module CommArgCollection =\n                \n                    let trueForAll                        _ = true\n                    let contains      (TypedCommArg arg) (CommArgCollection args) = args |> Seq.map (fun (a,_) -> a.cargId) |> Seq.contains arg.cargId\n                    let argsRm                           () = readerFun(fun (CommArgCollection args) -> args                 )\n                    let existsRm                          f = readerFun(fun (CommArgCollection args) -> args |> Seq.exists f )\n                    let filterRm                          p = readerFun(fun (CommArgCollection args) -> args |> Seq.filter p )\n                    let argumentsRm                  filter = filterRm filter >>= traverseSeq CommArg.argumentTRm\n                    let containsAnyOfRm (ids:CommArgId Set) = readerFun(fun (CommArgCollection args) -> args |> Seq.exists (fun (a,_) -> Set.contains a.cargId ids) )\n                    let argumentNotFound  targ = fun () -> match targ with | TypedCommArg arg -> sprintf \"argument not found: %s\" arg.name |> ErrorMsg\n                    let tryFindArgO   (TypedCommArg arg) (CommArgCollection args) = Seq.tryFind (fun (a,_) -> a.cargId = arg.cargId) args \n                    let tryFindArgORm     targ = readerFun(fun coll -> tryFindArgO targ coll |> Option.map insertFst |> insertO ) >>= id\n                    let tryGetIntORm      targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getIntR    targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetStringORm   targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getStringR targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetBoolORm     targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getBoolR   targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetFloatORm    targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getFloatR  targ o)) |>> Result.insertO >>= ofResultRM\n                    let findArgRm         targ = tryFindArgORm   targ >>= ofOption (argumentNotFound targ)\n                    let getIntRm          targ = tryGetIntORm    targ >>= ofOption (argumentNotFound targ)\n                    let getStringRm       targ = tryGetStringORm targ >>= ofOption (argumentNotFound targ)\n                    let getFloatRm        targ = tryGetFloatORm  targ >>= ofOption (argumentNotFound targ)\n                    let getBoolRm   def   targ = tryGetBoolORm   targ |>> Option.defaultValue def\n                    //[< Inline \"throw 'getBoolR not available in JavaScript'\" >]\n                    let getBoolR def targ args = getBoolRm def targ |> run args |> fun (bO, _, m) -> bO |> Result.ofOption (fun () -> m)   //|> Async.RunSynchronously //|> Result. Option.defaultValue false\n                \n                    let addPair(commArg:CommArg, vRm:FusionM<obj, CommArgCollection<_>, _>) (CommArgCollection args) =\n                        args\n                        |> if commArg.unique then Seq.filter (fun (a,_) -> a.cargId <> commArg.cargId) else id\n                        |> Seq.append <| [ commArg, vRm ]\n                        |> Seq.toArray\n                        |> Seq.ofArray\n                        |> CommArgCollection\n                    let append (args1: CommArgCollection<'M>) (args2: CommArgCollection<'M> ) = args2.CommArgs |> Seq.fold (swap (unbox >> addPair)) args1\n                    let addPairs pairs collection = append collection (CommArgCollection pairs)\n                        \n                //    let produceRm = ReaderM(fun (CommArgCollection args) ->\n                //        args\n                //        |> ReaderM.traverseSeq (fun (a, vRm) -> CommArg.produceRm a vRm |> ReaderM.map (fun v -> a, v))\n                //        |> ReaderM.map Seq.toArray\n                //        |> ReaderM.run (CommArgCollection args)\n                //    )\n                \n                type  CommArgCollection<'M> with\n                    static member (+) (args: CommArgCollection<_>, args2                    ) = args |> CommArgCollection.addPairs args2\n                    static member (+) (args: CommArgCollection<_>, arg                      ) = args |> CommArgCollection.addPair  arg  \n                    static member (+) (args: CommArgCollection<_>, (CommArgCollection args2)) = args |> CommArgCollection.addPairs args2\n                \n                \n            type FsCode = FsCode of string\n            \n            module FsCode =\n            \n                type PreproDirective =\n                | PrepoCd     of string\n                | PrepoR      of string\n                | PrepoDefine of string\n                | PrepoLoad   of string\n                | PrepoLine   of string //* int\n                | PrepoNoWarn of string\n                | PrepoI      of string\n                | PrepoIf     of string\n                | PrepoElIf   of string\n                | PrepoElse   \n                | PrepoEndIf\n                | PrepoLight  of bool\n                | PrepoOther  of string\n                | NoPrepo\n                \n                let extractDefines(FsCode code) = \n                    if code.StartsWith \"////-d:\" \n                    then code.[4..code.IndexOf '\\n' - 1]\n                    else \"\"\n            \n                let separatePrepros (code:string[]) =\n                    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n                    let  rest   (line:string) = line.Trim() |> String.splitInTwoO \" \" |> Option.map snd |> Option.defaultValue \"\" |> fun s -> s.Trim()\n                    let  comment = ((+)\"//\") \n                    let  prepro (line:string) = \n                        match true with \n                        | true when line       .StartsWith(\"#define\") -> (comment line, line |> rest   |> PrepoDefine)\n                        | true when line       .StartsWith(\"#cd\"    ) -> (comment line, line |> quoted |> PrepoCd    )\n                        | true when line       .StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                        | true when line       .StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                        | true when line       .StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                        | true when line.Trim().StartsWith(\"# \"     ) -> (comment line, line |> quoted |> PrepoLine  )\n                        | true when line.Trim().StartsWith(\"#line\"  ) -> (comment line, line |> quoted |> PrepoLine  )\n                        | true when line       .StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                        | true when line       .StartsWith(\"#if\"    ) -> (        line, line |> rest   |> PrepoIf    )\n                        | true when line       .StartsWith(\"#elif\"  ) -> (        line, line |> rest   |> PrepoElIf  )\n                        | true when line       .StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                        | true when line       .StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                        | true when line       .StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                        | true when line       .StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                        | _                                           -> (        line,                   NoPrepo    ) \n                    code |> Array.map prepro\n            \n                type PrepState = \n                | LevelZero\n                | TrueValue of PrepState\n                | Looking   of PrepState\n                | Found     of PrepState\n            \n                let isActive = function\n                | LevelZero\n                | TrueValue _ -> true\n                | Looking   _ -> false\n                | Found     _ -> false\n            \n                let prev = function\n                | LevelZero    -> LevelZero\n                | TrueValue pr -> pr\n                | Looking   pr -> pr\n                | Found     pr -> pr\n            \n                let filterPreps (preps:PreproDirective seq) =\n                    let  defines  = preps |> Seq.choose (function | PrepoDefine d -> Some d | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let isDefined (def:string) =    defines |> Seq.contains (def.Replace(\"!\",\"\").Trim()) |> (if def.Trim().StartsWith \"!\" then not else id)\n                    (LevelZero, preps) \n                    ||> Seq.mapFold(fun st prep ->\n                        match st, prep with\n                        | TrueValue _ , PrepoIf    def             \n                        | LevelZero   , PrepoIf    def -> None     , if isDefined def then TrueValue st else Looking st\n                        | Looking   _ , PrepoIf    _             \n                        | Found     _ , PrepoIf    _   -> None     , Found st\n                        |           _ , PrepoEndIf     -> None     , prev  st\n                        | TrueValue pr, PrepoElIf  _\n                        | TrueValue pr, PrepoElse      -> None     , Found     pr\n                        | Looking   pr, PrepoElIf  def -> None     , if isDefined def then TrueValue st else Looking pr\n                        | Looking   pr, PrepoElse      -> None     , TrueValue pr\n                        | Found     pr, PrepoElIf  _\n                        | Found     pr, PrepoElse      -> None     , Found     pr\n                        | TrueValue _ , _             \n                        | LevelZero   , _              -> Some prep, st\n                        | _                            -> None     , st\n                        )\n                    |>  fst\n                    |>  Seq.choose id\n                    |>  Seq.toArray\n            \n                let getTopDirectives (fsNass:(string * PreproDirective) seq) =\n                    let  directs  = fsNass |> Seq.map snd |> Seq.filter (function \n                                        | PrepoDefine _\n                                        | PrepoR      _ \n                                        | PrepoI      _\n                                        | PrepoNoWarn _\n                                        | PrepoCd     _ \n                                        | PrepoIf     _\n                                        | PrepoEndIf  \n                                        | PrepoElIf   _\n                                        | PrepoElse    -> true\n                                        |_             -> false) |> Seq.toArray\n                    let  code     = fsNass |> Seq.map fst |> Seq.toArray\n                    code, directs\n                    \n                let separateDirectives (fsNass:PreproDirective seq) =\n                    let  defines  = fsNass |> Seq.choose (function | PrepoDefine d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  preps    = filterPreps fsNass\n                    let  assembs  = preps  |> Seq.choose (function | PrepoR      assemb -> Some assemb | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  prepoIs  = preps  |> Seq.choose (function | PrepoI      d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  nowarns  = preps  |> Seq.choose (function | PrepoNoWarn d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  cd       = preps  |> Seq.choose (function | PrepoCd     dir    -> Some dir    | _ -> None) |> Seq.tryHead\n                    assembs, defines, prepoIs, nowarns, cd\n                    \n                let getSourceDir srcDir (lines:string[]) =\n                    match lines.[0], Array.tryItem 1 lines with\n                    |         String.StartsWith \"////#cd @\\\"\" dirq, _ \n                    | _, Some(String.StartsWith \"////#cd @\\\"\" dirq) ->  dirq.Trim()\n                                                                        |> function\n                                                                        | String.EndsWith \"\\\"\" dir\n                                                                        |                      dir ->\n                                                                        match dir with\n                                                                        | String.StartsWith \"\\\\\" _\n                                                                        | String.StartsWith \"/\"  _            -> dir\n                                                                        | _ when Seq.tryItem 1 dir = Some ':' -> dir\n                                                                        | _ -> srcDir  +/+                       dir\n                    | _                                                     -> srcDir\n            \n            \n            type SnippetId = SnippetId of System.Guid with member x.Id = match x with SnippetId id -> id\n                                                           static member Empty = SnippetId System.Guid.Empty\n            \n            type Snippet = {\n                snpId           : SnippetId    \n                snpName         : string\n                snpContent      : string\n                snpParentIdO    : SnippetId option\n                snpPredIds      : SnippetId Set\n                snpProperties   : (string* string) []\n                snpModified     : System.DateTime\n            }\n            \n            type SnippetReference =\n            | RefSnippetId   of SnippetId\n            | RefSnippetPath of string[]\n            \n            type Reduced = ((SnippetId * string * int * int) [] * string [] * FsCode.PreproDirective [] ) option\n            \n            type SnippetCollection = {\n                generation       : System.DateTime\n                ordered          : Snippet seq\n                fetcher          : SnippetId -> Snippet Option\n                predecesorsCache : unit -> ((SnippetId -> SnippetId list option) * (SnippetId -> (SnippetId -> SnippetId list) -> SnippetId list))\n                reducedCache     : unit -> (((bool * SnippetId * Set<SnippetId>) -> Reduced option) * ((bool * SnippetId * Set<SnippetId>) -> ((bool * SnippetId * Set<SnippetId>) -> Reduced) -> Reduced))\n                prepCode         : Snippet -> string                             \n            }\n            \n            module Snippet =\n                open System\n                open FusionM\n                open Operators\n            \n                let getNextModified() = DateTime.Now\n                //let getNextGeneration, setGeneration = \n                //    let mutable generation  = 1\n                //    (fun () -> generation <- generation + 1 ; generation)\n                //  , (fun n  -> generation <- n                          )  \n                let New name content parentO = \n                    {\n                        snpId           = SnippetId <| System.Guid.NewGuid()   \n                        snpName         = name\n                        snpContent      = content\n                        snpParentIdO    = parentO\n                        snpPredIds      = Set.empty\n                        snpProperties   = Array.empty\n                        snpModified     = getNextModified()\n                    }\n                let defaultSnippet              = {\n                    snpId           = SnippetId <| System.Guid.Empty\n                    snpName         = \"\"\n                    snpContent      = \"\"\n                    snpParentIdO    = None\n                    snpPredIds      = Set.empty\n                    snpProperties   = Array.empty\n                    snpModified     = Utc1970_01_01\n                }    \n                let snippetName name (content: string) =\n                    if name <> \"\" then name else \n                    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n                    |> Seq.map    (fun l -> l.Trim())\n                    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n                    |> Seq.tryHead\n                    |> Option.defaultValue \"<empty>\"    \n                let nameSanitized snp =\n                    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                                    '\\\\'  ; '/'|] //\"\n                    snp.snpName \n                    |> String.filter (fun c -> not <| Array.contains c illegal)\n                    |> fun c -> c + \" \" + snp.snpId.Id.ToString()\n                let propertyO       n snp = snp.snpProperties |> Array.tryPick (fun (name, value) -> if name = n then Some value else None)\n                let tieFighter            = \"|\" + \"-\" + \"|\"\n                let propertyPair      prv = (prv:string).Split([| tieFighter |], StringSplitOptions.None) |> fun vs -> vs.[0], vs |> Array.tryItem 1 |> Option.defaultValue vs.[0]\n                let propertyPairO   n snp = propertyO n snp |> Option.map propertyPair\n                let snippetORm        sid = readerFun (fun { fetcher    = ftch } -> ftch sid                                               )\n                let parentORm         snp = readerFun (fun { fetcher    = ftch } -> snp.snpParentIdO |> Option.bind ftch                   )\n                let predecessorsRm    snp = readerFun (fun { fetcher    = ftch } -> snp.snpPredIds   |> Seq.choose  ftch                   )\n                let maxGenerationRm   ()  = readerFun (fun { ordered    = snps } -> snps |> Seq.map (fun s -> s.snpModified  ) |> Seq.max  )\n                let modifiedRm        snp = readerFun (fun { generation = gen  } -> snp.snpModified   > gen                                )\n                let childrenRm        sid = readerFun (fun { ordered    = snps } -> snps |> Seq.filter(fun s -> s.snpParentIdO = Some sid) )\n                let orderedRm         ()  = readerFun (fun { ordered    = snps } -> snps                                                   )\n                let prepareCodeRm     snp = readerFun (fun { prepCode   = prep } -> prep snp                                               )\n                let snippetRm         sid = snippetORm sid |> absorbO (fun () -> sprintf \"Snippet not found %A\" sid |> ErrorMsg)\n                let snippetNameRm     sid = snippetRm  sid |>> (fun snp -> snippetName snp.snpName snp.snpContent)\n                let rec pathRm        sid = snippetORm sid \n                                            |>> Option.map parentORm \n                                            >>= insertO \n                                            |>> Option.bind id\n                                            |>> Option.map (fun prn -> pathRm prn.snpId |>> fun rest -> prn.snpId :: rest ) \n                                            >>= insertO \n                                            |>> Option.defaultValue []\n                let snippetFromPathORm pth = fusion {\n                    let! snps = orderedRm()\n                    return\n                        snps\n                        |> Seq.mapFold (fun (path, prntO) snp -> \n                                           if path |> Array.length = 0                       then None    , ([||]      , prntO         ) else\n                                           let name = snippetName snp.snpName snp.snpContent\n                                           if  name <> path.[0] || snp.snpParentIdO <> prntO then None    , (path      , prntO         ) else\n                                           if path |> Array.length > 1                       then None    , (path.[1..], Some snp.snpId) else\n                                                                                                  Some snp, ([||]      , prntO         )                               \n                                       ) \n                                       (pth, None)\n                        |> fst\n                        |> Seq.choose id\n                        |> Seq.tryHead\n                }\n                let snippetFromRefORm     = function\n                                            | RefSnippetId   sid -> snippetORm         sid\n                                            | RefSnippetPath pth -> snippetFromPathORm pth\n                let predsLRm (sid : SnippetId) = fusion {\n                        let mutable ins  = [sid]  \n                        let mutable outs = [   ]\n                        while not ins.IsEmpty do\n                            match ins with\n                            | []         -> ()\n                            | hd :: rest -> if outs |> List.contains hd then\n                                                ins  <- rest\n                                            else\n                                                let! snpO  = snippetORm hd\n                                                let  preds = snpO \n                                                             |> Option.map(fun snp -> Seq.toList snp.snpPredIds @ Option.toList snp.snpParentIdO ) \n                                                             |> Option.defaultValue []\n                                                ins  <- rest @ preds\n                                                outs <- hd::outs\n                        return outs\n                    }\n                let predsLRmMemo()        = memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n            //    let predsLRmMemo<'m>  : SnippetId -> ReaderMResult<SnippetId list,SnippetCollection,'m>        \n            //        = ReaderM.memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n            //#if FIX_GENERIC\n            //    (predsLRmMemo : (SnippetId -> Monads.ReaderMonads.ReaderMResult<SnippetId list,SnippetCollection,string>) )\n            //#endif    \n                let uniquePredsRm     snp = predsLRmMemo() snp.snpId\n                let predsGenerationRm snp = fusion {\n                                                let! preds = uniquePredsRm snp >>= traverseSeq snippetRm\n                                                return preds (* |> Seq.append [ snp ] *) |> Seq.map (fun snp -> snp.snpModified  ) |> Seq.max \n                                            }\n                let rec modifiedRecRm snp = fusion {\n                    let! modified         = modifiedRm     snp\n                    if modified then return true else\n                    let! predIds          = uniquePredsRm  snp\n                    let! predOs           = predIds |> Seq.map snippetORm                  |> sequenceSeq\n                    let! mods             = predOs  |> Seq.choose id |> Seq.map modifiedRm |> sequenceSeq\n                    return Seq.contains true mods\n                }\n                let rec propertyHierORm n snp = fusion {\n                    match propertyO n snp with\n                    | Some v -> return Some (snp, propertyPair v)\n                    | None   -> let! parentO = parentORm   snp\n                                match parentO with\n                                | Some p -> let!   propO = propertyHierORm n p\n                                            return propO |> Option.map(fun (sn, (_, next)) -> sn, (next, next) )\n                                | None   -> return None\n                }\n                let indentRm          snp =\n                    let rec indentMeChildNextRm          snp = fusion {\n                        let  propIndentChildren = \"IndentChildren\"\n                        let  currO, nextO       = propertyPairO propIndentChildren snp |> function Some (curr, next) ->  ParseO.parseIntO curr, ParseO.parseIntO next | _-> None, None \n                        let! parentO            = parentORm   snp\n                        match parentO with\n                        | Some p -> let! _, (me, next) = indentMeChildNextRm p\n                                    return me, (me + (currO |> Option.defaultValue next), nextO |> Option.defaultValue next)\n                        | None   -> return 0 , (      currO |> Option.defaultValue 4    , nextO |> Option.defaultValue 4   )\n                    }\n                    indentMeChildNextRm snp |>> fst\n                let levelRm           snp = \n                    let rec levelRm2 snp lv = fusion {\n                        let!  parentO = parentORm snp\n                        match parentO with\n                        | None   -> return  lv\n                        | Some p -> return! levelRm2 p (lv + 1)\n                    }\n                    levelRm2 snp 0\n                let ancestorsRm   snp = \n                    let rec  ancestorsRm2 snp lst = fusion {\n                        let! parentO = parentORm snp\n                        match parentO with\n                        | Some p -> return! ancestorsRm2 p <| p::lst\n                        | None   -> return  lst\n                    }\n                    ancestorsRm2 snp []\n                let separateCodeRm snp = fusion {\n                    let! indent        = indentRm snp\n                    let  indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n                    let! code          = prepareCodeRm snp\n                    //let  name          = nameSanitized snp\n                    let  code, directs =\n                        code.Split('\\n')\n                        |> FsCode.separatePrepros\n                        |> indentF\n                        |> FsCode.getTopDirectives\n                    return\n                        [| snp.snpId, snippetName snp.snpName snp.snpContent, code.Length, indent |] , code, directs\n                }\n                let addSeps (lines1:(SnippetId*string*int*int)[], code1:string[], directs1:FsCode.PreproDirective[])\n                            (lines2:(SnippetId*string*int*int)[], code2:string[], directs2:FsCode.PreproDirective[]) =\n                    Array.append lines1   lines2\n                  , Array.append code1    code2\n                  , Array.append directs1 directs2\n                let reducedCodeRm  snippets = fusion {\n                    let! parts    = snippets |> traverseSeq separateCodeRm\n                    let  reduced  = parts\n                                    |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||] ] else snps\n                                    |> Seq.reduce addSeps\n                                    |> fun (lines, code                                         , directs) ->\n                                           (lines, code |> String.concat \"\\n\" |> Array.singleton, directs)\n                    return reduced\n                }\n                let finishCode (lines:(SnippetId*string*int*int)[],code:string[], directs:FsCode.PreproDirective[]) =\n                    let assembs, defines, prepIs, nowarns, cdO = FsCode.separateDirectives directs\n                    let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n                    let part1  =\n                      [ if config <> \"\" then yield \"////\" + config\n                        if cdO.IsSome   then yield sprintf \"////#cd @\\\"%s\\\"\" cdO.Value\n                        yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n                        yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n                        yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\" )\n                      ]\n                    Seq.append part1 code |> String.concat \"\\n\"\n                  , lines \n                    |> Seq.mapFold (fun firstLine (id, name, len, ind) -> ((id, name), (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n                    |> fst\n                    |> Seq.toArray\n                //let codeAndStartsRm   snpIds = reader {\n                //    let! snippets = orderedRm() |>> Seq.filter(fun snp -> snpIds |> Seq.contains snp.snpId)\n                //    let! reduced  = reducedCodeRm snippets\n                //    return finishCode reduced\n                //}\n                //let codeFsxRm         snippets = codeAndStartsRm snippets |> ReaderM.map fst\n                let reducedOthersORm (before, snpId, snpIds) = fusion {\n                    let  skipTake = if before then Seq.takeWhile else Seq.skipWhile\n                    let! snippets = orderedRm() |>> skipTake (fun snp -> snp.snpId <> snpId) |>> Seq.filter(fun snp -> snp.snpId <> snpId && snpIds |> Set.contains snp.snpId) \n                    if snippets |> Seq.isEmpty then return None else\n                    let! reduced = reducedCodeRm snippets\n                    return Some reduced\n                }\n                let reducedOthersORmMemo() = memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n            //    let reducedOthersORmMemo<'m> : bool * SnippetId * Set<SnippetId> -> ReaderMResult<Reduced,SnippetCollection,'m> \n            //        = ReaderM.memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n                let fastReducedRm  curIdO lastIdO = fusion {\n                    let!  curSnippetO  = curIdO  |> Option.map snippetORm |> insertO\n                    let! lastSnippetO  = lastIdO |> Option.map snippetORm |> insertO\n                    match (Option.bind id curSnippetO, Option.bind id lastSnippetO) with\n                    | _              , None\n                    | None           , _                -> return! reducedCodeRm Seq.empty\n                    | Some curSnippet, Some lastSnippet ->\n                    let! preds = uniquePredsRm lastSnippet\n                    let  preds = Set preds\n                    let! reducedBeforeO = reducedOthersORmMemo() (true , curSnippet.snpId, preds)\n                    let! reducedAfterO  = reducedOthersORmMemo() (false, curSnippet.snpId, preds)\n                    let! currentCode    = separateCodeRm           curSnippet\n                    let part1 = reducedBeforeO |> Option.map (swap addSeps currentCode) |> Option.defaultValue currentCode\n                    return      reducedAfterO  |> Option.map (     addSeps part1      ) |> Option.defaultValue part1\n                }\n                let fastCodeRm  curIdO lastIdO = fusion {\n                    let! reduced  = fastReducedRm curIdO lastIdO\n                    return finishCode reduced\n                }\n                let codeFsxRm    curId = fastCodeRm  (Some curId) (Some curId) |>> fst\n                \n            /// Adapted from here http://fssnip.net/7V5   Usage:\n            /// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n            ///         \n            /// abs  1 |> printfn \"%A\" // 1\n            /// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\n            type Hole = Hole with\n                [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n                static member inline Incomplete id : 'T = failwithf \"Incomplete hole '%s'\" id        \n                    \n            \n            /// Tree structure to implement a hierarchical user interface but using readerMonad\n            module TreeReader =\n                open FusionM\n                open Operators\n            \n                type Node<'I, 'R, 'T> = {\n                    id                : unit                 -> 'I\n                    isExpandedRm      : unit                 -> FusionM<bool                   , 'R, 'T>\n                    canHaveChildrenRm : unit                 -> FusionM<bool                   , 'R, 'T>\n                    childrenRm        : unit                 -> FusionM<Node<'I, 'R, 'T> seq   , 'R, 'T>\n                    pathRm            : unit                 -> FusionM<'I list                , 'R, 'T>  // list of parents excluding itself\n                    parentORm         : Node<'I, 'R, 'T> seq -> FusionM<Node<'I, 'R, 'T> option, 'R, 'T>\n                    newChildrenRm     : Node<'I, 'R, 'T> []  -> FusionM<Node<'I, 'R, 'T>       , 'R, 'T>  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n                }\n            \n                let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n                let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n            \n                let rec listNodes level (nodes: Node<_,_,_> seq) =\n                    nodes\n                    |> Seq.map(fun node -> \n                        node.isExpandedRm() \n                        >>= (fun exp -> if exp then node.childrenRm() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n                        |>> (fun nodes -> Seq.append [ node, level ] nodes)\n                    ) \n                    |> sequenceSeq\n                    |>> Seq.collect id\n            \n                let removeNode (node:Node<_,_,_>) nodes = fusion { // better use version removeNode2\n                    let! path = node.pathRm()\n                    let rec chRemove (n:Node<_,_,_>) = fusion {\n                        if                  n.id() = node.id() then return  None\n                        elif List.contains (n.id())  path      then return! n.childrenRm()\n                                                                            |>> Seq.toArray\n                                                                            |>> Seq.map chRemove \n                                                                            >>= sequenceSeq \n                                                                            |>> Seq.choose id \n                                                                            |>> Seq.toArray\n                                                                            >>= n.newChildrenRm  \n                                                                            |>> Some\n                        else                                        return  Some n\n                    }\n                    return! nodes |> Seq.map chRemove |> sequenceSeq |>> Seq.choose id\n                }\n            \n                let removeNodes p nodes = fusion {\n                    let rec folder pair (n:Node<_,_,_>) = fusion {\n                        let! children, noparent = pair\n                        let! children2 = n.childrenRm() |>> Seq.toArray\n                        let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n                        if p n then return (        children, ch @ np)\n                               else let! xxx = n.newChildrenRm (ch |> Seq.rev |> Seq.toArray)\n                                    return ( xxx :: children,      np)\n                    }\n                    let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n                    return noparent @ res |> List.rev\n                }\n            \n                let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n                    seq [ for n in nodes do\n                            if p n then\n                                if after then yield n    ; yield node\n                                else          yield node ; yield n\n                            else              yield n\n                    ]\n                    \n                let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenRm\n            \n                let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n                    sibling.pathRm() >>= function\n                    | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n                    | parent :: path -> \n                    let rec mapAdd (n:Node<_,_,_>) =\n                        if                  n.id() = parent then     n.childrenRm() |>> Seq.toArray >>= addToParent after theSibling node n\n                        elif List.contains (n.id()) path    then     n.childrenRm() |>> Seq.toArray |>> Seq.map mapAdd >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenRm \n                        else                                     rtn n\n                    nodes |> Seq.map mapAdd |> sequenceSeq\n            \n                let tryFind p (nodes:Node<_,_,_> seq) = \n                    let rec folder resRm (node:Node<_,_,_>) =\n                        resRm >>= function\n                        | Some v -> rtn (Some v)\n                        | None   ->\n                        if p node then rtn <| Some node else \n                        node.childrenRm() >>= Seq.fold folder (rtn None)\n                    nodes                 |>  Seq.fold folder (rtn None)\n                    \n                let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n            \n                let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    nodes\n                    |>  removeNode node\n                    >>= addSibling after node sibling\n            \n                let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = fusion {\n                    let!  nodeO = nodes |> tryFindId nodeId\n                    match nodeO with\n                    | None         -> return nodes\n                    | Some node    ->\n                    let!  siblingO = nodes |> tryFindId siblingId\n                    match siblingO with\n                    | None         -> return nodes\n                    | Some sibling -> return! moveToSibling after node sibling nodes\n                }\n            \n                let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = fusion {\n                    let! path = parentN.pathRm()\n                    let rec mapAppend (n:Node<_,_,_>) =\n                        if   n.id() = parentN.id()       then \n                            if append                    then n.childrenRm() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                            else                              n.childrenRm() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                        elif List.contains (n.id()) path then n.childrenRm() |>> Seq.toArray |>>      Seq.map mapAppend   >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenRm\n                        else                                  rtn n\n                    return! nodes |> Seq.map mapAppend |> sequenceSeq\n                }\n            \n                let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    node.parentORm nodes >>= function\n                    | None        -> rtn nodes\n                    | Some parent -> parent.childrenRm() |>> (Seq.toArray >> Seq.ofArray)\n                    |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n                    >>= Seq.fold      (fun newParentORm n -> n.canHaveChildrenRm() >>= (fun can -> if can then rtn(Some n) else newParentORm)) (rtn None)\n                    >>= function\n                    | None           -> rtn nodes\n                    | Some newParent ->\n                    nodes\n                    |>  removeNode node \n                    >>= addChild true node newParent\n            \n                let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.parentORm nodes\n                    |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n                    >>= Option.defaultValue (rtn nodes)\n                    \n                let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.childrenRm()\n                    |>> Seq.toArray\n                    >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n                    >>= removeNode node\n                    \n                \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\System.Reactive\\lib\\net46\\System.Reactive.dll\"\n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Control.Reactive\\lib\\net46\\FSharp.Control.Reactive.dll\"\n            module RunProcess =\n                open System.Diagnostics\n                open System.Text\n                open FSharp.Control.Reactive\n                open FSharp.Control.Reactive.WaitHandle\n                open FSharp.Control\n            \n                let startProcess p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let proc        = new Process(StartInfo = procStart)\n                    proc.Start() \n                \n                let startProcessDir p ops dir =\n                    let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n                    let proc        = new Process(StartInfo = procStart)\n                    proc.Start() \n                \n                type ShellResponse =\n                    | ShellDidNotStart \n                    | ShellExit                  of int * stdout: string * stderr:string\n                    | ShellNoExit                of       stdout: string * stderr:string\n                    | ShellCrashed               of       stdout: string * stderr:string\n                    with \n                    override msg.ToString() = \n                        match msg with\n                        | ShellDidNotStart                 -> [ \"Shell did not start\" ]\n                        | ShellExit        (cod, out, err) -> [ if cod <> 0 then yield sprintf \"exit(%d)\" cod\n                                                                yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellCrashed     (     out, err) -> [ yield \"Shell crashed!\" ; yield out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellNoExit      (     out, err) -> [ yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        |> String.concat \"\\n\"\n                \n                type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl, ?priorityClass) =\n                    let bufferOutput                      = new StringBuilder()\n                    let bufferError                       = new StringBuilder()\n                    let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\")                       |> ignore\n                    let consume (sb: StringBuilder)       = sb.ToString() |>! (fun _ -> sb.Clear()      |> ignore)\n                    let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n                    let outputHandler                     = append bufferOutput |> dataHandler\n                    let errorHandler                      = append bufferError  |> dataHandler\n                    do  startInfo.RedirectStandardInput  <- true\n                        startInfo.RedirectStandardOutput <- true\n                        startInfo.RedirectStandardError  <- true\n                        startInfo.UseShellExecute        <- false\n                    let proc                              = new Process(\n                                                                StartInfo           = startInfo\n                                                              , EnableRaisingEvents = true     )\n                    do  outputHandler                    |>             proc.OutputDataReceived.AddHandler\n                        errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n                        Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n                        Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n                //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n                      \n                    new          (program, args, ?priorityClass) = let startInfo                     = new ProcessStartInfo()\n                                                                   do  startInfo.FileName           <- program\n                                                                       startInfo.Arguments          <- args\n                                                                   new ShellEx(startInfo, ?priorityClass = priorityClass)\n                    member ____.Start                         () = let r = proc.Start() \n                                                                   priorityClass |> Option.iter (fun p -> proc.PriorityClass <- p)\n                                                                   proc.BeginOutputReadLine()\n                                                                   proc.BeginErrorReadLine ()\n                                                                   r\n                    member ____.WaitToFinish                  () = proc.WaitForExit()\n                                                                   let    output  = (consume bufferOutput).Trim()\n                                                                   let    error   = (consume bufferError ).Trim()\n                                                                   ((if proc.HasExited then proc.ExitCode else -99999), output, error)\n                    member ____.WaitForInputIdle              () = proc.WaitForInputIdle()\n                    member this.StartAndWait                  () = let _started = this.Start()\n                                                                   this.WaitToFinish()\n                    member this.StartAndWaitS                 () = this.StartAndWait()\n                                                                   |>! fun _ -> (this :> System.IDisposable).Dispose()\n                                                                   |> ShellExit\n                    member this.stdOutErr2Result exit out errs   = if exit <> 0\n                                                                   then Result.Error <| ErrorMsg(\n                                                                           [| if out  <> \"\"              then yield \"stdout: \" + out           \n                                                                              if errs <> \"\"              then yield errs                       \n                                                                              if errs  = \"\" || exit <> 1 then yield sprintf \"ExitCode: %d\" exit\n                                                                           |] |> String.concat \"\\n\")\n                                                                   else Result.Ok (out, errs)\n                    member this.StartAndWaitR                 () = let r = this.StartAndWait()\n                                                                   (this :> System.IDisposable).Dispose()\n                                                                   r |||> this.stdOutErr2Result\n                    member this.RunToFinish                   () = this.StartAndWaitS().ToString()\n                    member this.RunOutputToFileR            file = proc.OutputDataReceived.RemoveHandler outputHandler\n                                                                   use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n                                                                   let _started = proc.Start() \n                                                                   proc.BeginErrorReadLine ()\n                                                                   proc.StandardOutput.BaseStream.CopyTo stream\n                                                                   this.WaitToFinish()\n                                                                   |> ShellExit\n                    member this.RunOutputToFile             file = this.RunOutputToFileR file\n                                                                   |> fun v -> v.ToString() \n                    member ____.Send                (txt:string) = proc.StandardInput.WriteLine txt\n                    member ____.Output                        () = consume bufferOutput\n                    member ____.Error                         () = consume bufferError\n                    member ____.Response(out:string, err:string) = match out.Trim(), err.Trim() with\n                                                                   | good, \"\"  -> Result.Ok    <| good               \n                                                                   | good, bad -> Result.Error <| Message(ShellNoExit(good, bad))\n                    member this.Response                      () = this.Response(this.Output(), this.Error())\n                    member this.SendAndWait (send, wait, ?onErr) =\n                        let waitOnError = defaultArg onErr false\n                        let obsWait   = if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                                          |> Observable.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.Ok v else None) with _ -> None)\n                        let obsAll    = Observable.merge obsWait  (Event.map (fun _ -> Result.Error <| Message (ShellCrashed(this.Output(), this.Error()))) proc.Exited)\n                        asyncResult {\n                            //do! Result.tryProtection()\n                            async { \n                                do!    Async.Sleep 20 \n                                this.Send send        } |> Async.Start\n                            let!  waited = Observable.wait (obsAll |> Observable.take 1) \n                            do!   Async.Sleep 200\n                            return! if waitOnError\n                                    then this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                                    else this.Response()\n                        }\n                    member ____.HasExited = try proc.HasExited with _ -> true\n                    member ____.Abort()   = try proc.Kill   () with _ -> ()\n                    member ____.Process   = proc\n                    interface System.IDisposable with\n                        member ____.Dispose () =\n                            try proc.Close  ()\n                                proc.Kill   ()\n                                proc.Dispose() \n                            with _ ->       ()\n                \n                \n                let runAndWaitS p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.StartAndWaitS() \n                \n                let runToFinish p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n                    shell.RunToFinish() \n                \n                let runOutputToFile p ops file =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.RunOutputToFile file \n                \n                \n            module CopyIfMust =\n                open System.IO\n                \n                let copyIfNotExistsToFile from dest =\n                    let fit = FileInfo dest\n                    if not fit.Exists then\n                        File.Copy(from, dest, true )\n                \n                let toFile from dest =\n                    let fit = FileInfo dest\n                    let must = \n                        match fit.Exists with \n                        | false -> true\n                        | true  ->\n                            let fif = FileInfo dest\n                            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n                    if must then\n                        File.Copy(from, dest, true )\n                \n                let toDir from destDir =\n                    let dest = Path.Combine(destDir, Path.GetFileName(from))\n                    toFile from dest\n                \n            module FsCode =\n                open CommArg\n                open CommArgCollection\n                open FsCode\n                open System.IO\n                    \n                let flag t f p = function true -> p + t |_-> p + f\n                let flagpm   p = flag \"+\" \"-\" p\n            \n                let intRootDir       = NewString(\"RootDir\"      , true , sprintf  \"++root:%s\"        )\n                let intSnippet       = NewString(\"Snippet\"      , true , sprintf  \"++snippet:%s\"     )\n                let intCreateDir     = NewBool  (\"CreateDir\"    , true , fun v ->  if v then \"++createdirectory\" else \"\")\n                let intDirectory     = NewString(\"Directory\"    , true , sprintf  \"++directory:%s\"   )\n                let intName          = NewString(\"Name\"         , true , sprintf  \"++name:%s\"        )\n                let intExtension     = NewString(\"Extension\"    , true , sprintf  \"++extension:%s\"   )\n                let intFileName      = NewString(\"Filename\"     , true , sprintf  \"++filename:%s\"    )\n                let intOutputFile    = NewString(\"OutputFile\"   , true , sprintf  \"++fileout:%s\"     )\n                let intConfig        = NewString(\"Config\"       , true , sprintf  \"++config:%s\"      )\n                let intCopyConfig    = NewBool  (\"CopyConfig\"   , true , flagpm   \"++copyconfig\"     )\n                let intWebSharper    = NewBool  (\"WebSharper\"   , true , flagpm   \"++websharper\"     )\n                let intStaticLinkAll = NewBool  (\"StaticLinkAll\", true , flagpm   \"++staticlinkall\"  )\n                let intCopyAssem     = NewBool  (\"CopyAssem\"    , true , flagpm   \"++copyassemblies\" )\n                let intShowArgs      = NewBool  (\"ShowArgs\"     , true , flagpm   \"++showargs\"       )\n                let intRemLineDir    = NewBool  (\"RemLineDir\"   , true , flagpm   \"++remlinedir\"     )\n                \n                let internalArgs = \n                    Set [\n                        intSnippet      .CommArg.cargId\n                        intDirectory    .CommArg.cargId\n                        intName         .CommArg.cargId\n                        intExtension    .CommArg.cargId\n                        intFileName     .CommArg.cargId\n                        intOutputFile   .CommArg.cargId\n                        intConfig       .CommArg.cargId\n                        intWebSharper   .CommArg.cargId\n                        intStaticLinkAll.CommArg.cargId\n                        intCopyAssem    .CommArg.cargId\n                        intShowArgs     .CommArg.cargId\n                    ]\n            \n                let fscIOption     = NewString(\"IOption\"    , false, sprintf \"-I:%A\"          )\n                let fscReference   = NewString(\"Reference\"  , false, sprintf \"-r:%A\"          )\n                let fscSource      = NewString(\"Source\"     , false, sprintf \"%A\"             )\n                let fscTarget      = NewString(\"Target\"     , true , sprintf \"--target:%s\"    )\n                let fscPlatform    = NewString(\"Platform\"   , true , sprintf \"--platform:%s\"  )\n                let fscOutput      = NewString(\"Output\"     , true , sprintf \"-o:%A\"          )\n                let fscDebug       = NewString(\"Debug\"      , true , sprintf \"--debug:%s\"     )\n                let fscDefine      = NewString(\"Define\"     , false, sprintf \"--define:%s\"    )\n                let fscStaticLink  = NewString(\"StaticLink\" , false, sprintf \"--staticlink:%s\")\n                let fscGenFSharp1  = NewString(\"GenFSharp1\" , false, sprintf \"-%s\"            )\n                let fscGenFSharp2  = NewString(\"GenFSharp2\" , false, sprintf \"--%s\"           )\n                let fscNoFramework = NewBool  (\"NoFramework\", true , function true -> \"--noframework\" |_-> \"\" )\n                \n                let FSharpArgs = \n                    Set [\n                          fscIOption    .CommArg.cargId\n                          fscReference  .CommArg.cargId\n                          fscSource     .CommArg.cargId\n                          fscTarget     .CommArg.cargId\n                          fscPlatform   .CommArg.cargId\n                          fscOutput     .CommArg.cargId\n                          fscDebug      .CommArg.cargId\n                          fscDefine     .CommArg.cargId\n                          fscStaticLink .CommArg.cargId\n                          fscGenFSharp1 .CommArg.cargId\n                          fscGenFSharp2 .CommArg.cargId\n                          fscNoFramework.CommArg.cargId\n                ] \n                \n                let wscWebSite      = NewString(\"Website\"     , true , sprintf \"--wsoutput:%A\"              )\n                let wscProjectFile  = NewString(\"WsProject\"   , true , sprintf \"--project:%A\"               )\n                let wscProjectType  = NewString(\"ProjectType\" , true , sprintf \"--ws:%s\"                    )\n                let wscGenWSharper  = NewString(\"GenWSharper\" , false, sprintf \"--%s\"                       )\n                let wscJSMap        = NewBool  (\"JSMap\"       , false, flagpm  \"--jsmap\"                    )\n                let wscDeadCodeElim = NewBool  (\"DeadCodeElim\", false, flagpm  \"--dce\"                      )\n                let wscWarnOnly     = NewBool  (\"WarnOnly\"    , false, flagpm  \"--wswarnonly\"               )\n                let wscDownloadResc = NewBool  (\"DownloadResc\", false, flagpm  \"--dlres\"                    )\n                let wscPrintJS      = NewBool  (\"PrintJS\"     , false, flagpm  \"--printjs\"                  )\n                let wscClosures     = NewBool  (\"Closures\"    , false, flagpm  \"--closures\"                 )\n                let wscClosrMoveTop = NewBool  (\"ClosrMoveTop\", false, flag    \"--closures:movetotop\" \"\" \"\" )\n                let wscJsOutput     = NewString(\"JsOutput\"    , true , sprintf \"--jsoutput:%A\"              )\n            \n                let WebSharpArgs = \n                    Set [\n                          wscWebSite     .CommArg.cargId\n                          wscProjectFile .CommArg.cargId\n                          wscProjectType .CommArg.cargId\n                          wscGenWSharper .CommArg.cargId\n                          wscJSMap       .CommArg.cargId\n                          wscDeadCodeElim.CommArg.cargId\n                          wscWarnOnly    .CommArg.cargId\n                          wscDownloadResc.CommArg.cargId\n                          wscPrintJS     .CommArg.cargId\n                          wscClosures    .CommArg.cargId\n                          wscClosrMoveTop.CommArg.cargId\n                          wscJsOutput    .CommArg.cargId\n                    ] \n                \n                let dllOptions   () = CommArgCollection [ fscTarget      /= \"library\"                                                                     ] \n                let exeOptions   () = CommArgCollection [ fscTarget      /= \"exe\"     ; intCopyAssem /= true ; intCopyConfig /= true ]\n                let winExeOptions() = CommArgCollection [ fscTarget      /= \"winexe\"  ; intCopyAssem /= true ; intCopyConfig /= true ]\n                \n                open FusionM\n                open Operators\n                \n                let gS v = getStringRm     v\n                let gB v = getBoolRm false v\n            \n                let genericOptions () = \n                  CommArgCollection\n                    [\n            //           intSnippet     /= \"Test\"\n                        intRootDir     /= Path.GetFullPath \"..\"\n                        intName        /= (rtn (fun s     -> String.splitByChar '/' s |> Array.last ) <*> gS intSnippet                                       )\n                        intDirectory   /= (rtn (fun r     -> r                                      ) <*> gS intRootDir                                       )\n                        intFileName    /= (rtn (fun d n   -> d +/+ \"src\" +/+ n + \".fs\"              ) <*> gS intDirectory  <*> gS intName                     )\n                        fscOutput      /= (rtn (fun d n e -> d +/+ \"bin\" +/+ n + \".\" + e            ) <*> gS intDirectory  <*> gS intName <*> gS intExtension )\n                        intExtension   /= (rtn (function \"library\" -> \"dll\" |_-> \"exe\"              ) <*> gS fscTarget                                        )\n                        intOutputFile  /= (rtn               Path.GetFileName                         <*> gS fscOutput                                        )\n                        intConfig      /= (rtn (fun o     -> o + \".config\"                          ) <*> gS intOutputFile                                    )\n                        intWebSharper  /=       containsAnyOfRm WebSharpArgs\n                        fscSource      /=       gS intFileName\n                        fscNoFramework /=  fusion {\n                                                let!   args  = filterRm (fun (a,v) -> a.cargId = fscReference.CommArg.cargId)\n                                                let!   args2 = args |> traverseSeq (fun (a,b) -> argumentRm a b)\n                                                return args2 \n                                                       |> Seq.map(fun s -> s.ToLower()) \n                                                       |> Seq.exists(fun s -> s.Contains(\"fsharp.core.dll\") || s.Contains(\"mscorlib.dll\") )\n                                            }\n                    ]\n                    \n                let siteOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectType /=       \"Site\"\n                       wscWebSite     /= (rtn (fun d   -> d +/+ \"website\"  ) <*> gS intDirectory )\n                       wscJsOutput    /= (rtn (fun d n -> d +/+ n + \"0.js\" ) <*> gS wscWebSite  <*> gS intName )\n                       wscProjectFile /=       gS intName\n                       wscJSMap       /=       true\n                    |] \n                 \n                let wsProjectOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectFile /= gS intName\n                    |] \n                 \n                let debugOptions() = \n                  CommArgCollection\n                    [|\n                       fscGenFSharp1  /= \"g\"\n                       fscDebug       /= \"full\"\n                       fscDefine      /= \"DEBUG\"\n                       fscDefine      /= \"TRACE\"\n                       fscGenFSharp2  /= \"optimize-\"\n                       fscGenFSharp2  /= \"tailcalls-\"\n                    |]\n                \n                let otherOptions () =\n                  CommArgCollection\n                    [|\n                       //@\"--noframework\"\n                       fscGenFSharp2  /= \"warn:3\"\n                       fscGenFSharp2  /= \"nowarn:1178\"\n                       fscGenFSharp2  /= \"nowarn:1182\"\n                       fscGenFSharp2  /= \"nowarn:52\"\n                       fscGenFSharp2  /= \"warnaserror:76\"\n                       fscGenFSharp2  /= \"vserrors\"\n                       fscGenFSharp2  /= \"utf8output\"\n                       fscGenFSharp2  /= \"fullpaths\"\n                       fscGenFSharp2  /= \"flaterrors\"\n                       fscGenFSharp2  /= \"subsystemversion:6.00\"\n                       fscGenFSharp2  /= \"highentropyva+\"\n                       intRemLineDir  /= true\n                    |]\n                \n                let compileOptionsDll (snp:string) = \n                    genericOptions()\n                    + dllOptions  ()\n                    + otherOptions()\n                    + intSnippet     /= snp\n                    \n                let compileOptionsDllDebug   (snp:string) = compileOptionsDll      snp + debugOptions ()       \n                let compileOptionsExeDebug    snp         = compileOptionsDllDebug snp + exeOptions   ()\n                let compileOptionsWinExeDebug snp         = compileOptionsDllDebug snp + winExeOptions()\n                    \n                let prepOptions (args:CommArgCollection<_>) (assembs : string [], defines : string [], prepoIs : string []) =\n                    let staticLinksAll = CommArgCollection.getBoolR false intStaticLinkAll args\n                    args + [\n                        yield! prepoIs |> Array.map ((/=) fscIOption  ) \n                        yield! assembs |> Array.map ((/=) fscReference)\n                        yield! defines |> Array.map ((/=) fscDefine   )\n                        if staticLinksAll = Ok true then \n                            yield! assembs |> Array.map (fun f -> fscStaticLink /= System.IO.Path.GetFileNameWithoutExtension f)\n                    ]\n                    \n                let processArgs code assembs nowarns = fusion {        \n                    let! show      = gB intShowArgs\n                    if show      then let! args = argumentsRm (fun _ -> true)\n                                      args |> Seq.sort |> Seq.iter (printfn \"%s\")\n                    let! workDir   = getStringRm intDirectory\n                    let! fileName  = gS intFileName\n                    let! output    = gS fscOutput\n                    let! copyAssem = gB intCopyAssem\n                    let! createDir = gB intCreateDir\n                    let  srcDir    = Path.GetDirectoryName fileName\n                    let  outDir    = Path.GetDirectoryName output\n                    if createDir then \n                                     Directory.CreateDirectory workDir |> ignore\n                                     Directory.CreateDirectory  srcDir |> ignore\n                                     Directory.CreateDirectory  outDir |> ignore\n                    let  code2     = [\n                                        yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n                                        yield! code \n                                     ] |> String.concat \"\\n\"\n                    do               File.WriteAllText(fileName, code2)\n                    if copyAssem then assembs |> Array.iter (fun f -> outDir |> CopyIfMust.toDir f)      \n                }\n                \n            module FsiEvaluator =\n                open System.Diagnostics\n                open RunProcess\n                \n                \n                let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n                [< Literal >]\n                let endToken = \"xXxY\" + \"yYyhH\"\n                type FsiExe(config:string, workingDir, ?outHndl, ?errHndl) =\n                    let silent                     = ref false\n                    let fsiexe                     = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Test2\\FSharp.Compiler.Tools\\tools\" +/+ if config.Contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n                    let startInfo                  = ProcessStartInfo(fsiexe, config, WorkingDirectory= workingDir)\n                    let outHndlS                   = outHndl |> Option.map(fun outh v -> if !silent then () else outh v)\n                    let errHndlS                   = errHndl |> Option.map(fun errh v -> if !silent then () else errh v)\n                    let shell                      = new ShellEx(startInfo, ?outHndl = outHndlS, ?errHndl = errHndlS)  // --noninteractive\n                    do  startInfo.CreateNoWindow  <- false\n                        shell.Start() |> ignore\n                    member __.Eval (FsCode code)   = asyncResult {\n                                                        shell.Output() |> ignore\n                                                        shell.Error () |> ignore\n                                                        shell.Send code\n                                                        shell.Send \";;\"\n                                                        return! shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                                                     }\n                    member __.IsAlive              = not shell.HasExited\n                    member __.Abort()              = shell.Abort()\n                    member __.Process              = shell.Process\n                    member __.Shell                = shell\n                    member oo.EvalSilent code      = asyncResult {\n                                                        try     silent := true\n                                                                return! oo.Eval code\n                                                        finally silent := false\n                                                     }\n                    interface System.IDisposable with\n                        member this.Dispose ()     = (shell :> System.IDisposable).Dispose()\n            \n                open FusionAsyncM\n                open Operators\n            \n                let evaluateRm   code = getS() >>= (fun (fsi:FsiExe) -> fsi.Eval       code |> ofAsyncResultRM) \n                let evalSilentRm code = getS() >>= (fun (fsi:FsiExe) -> fsi.EvalSilent code |> ofAsyncResultRM) \n            \n            module FsiCodePresence =\n                open FusionAsyncM\n                open FsiEvaluator\n                open Operators\n            \n                let installPresenceRm() = \n                    \"\"\"\n                    module CodePresence =\n                        let mutable present : Map<string, string>  = Map.empty\n                        let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n                        let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n                    \"\"\"\n                    |>  String.unindentStr\n                    |>  FsCode\n                    |>  evalSilentRm \n                    |>> ignore\n            \n                let addPresenceRm (name:string) (v:string) = fusion {\n                    let  code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v |> FsCode\n                    let! res  = evalSilentRm code |>> String.splitByChar '\\n' |>> Seq.head\n                    match res with\n                    | \"ok\"   -> ()\n                    |_       -> do! installPresenceRm()\n                                do! evalSilentRm code |>> ignore\n                }\n                        \n                let getPresenceRm (name:string)   = fusion {\n                    let! res = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n                               |> FsCode\n                               |> evalSilentRm\n                               |>> String.splitByChar '\\n' |>> Seq.head\n                               |> getOption\n                    match res with\n                    | None                     -> do! installPresenceRm()\n                                                  return None\n                    | Some v when v = endToken -> do! installPresenceRm()\n                                                  return None\n                    | Some \"--\"                -> return None\n                    | Some v                   -> return Some v\n                }\n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER \n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            \n            module PromiseM =\n                let ofAsyncResultM (v: Async<ResultM<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function OkM(ok, _) -> resolve ok | ErrorM er -> reject <| ResultMessage.summarized er), reject, reject)\n                    )        \n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            module Pojo =\n                let addProp prop (pojo:JSObject) = pojo.Add prop ; pojo\n                \n                let newPojo props =\n                    let pojo = JSObject()\n                    if IsClient then\n                        props |> Seq.iter (swap addProp pojo >> ignore)\n                    pojo\n            \n                let newPojoOpt (propOs : seq<string * obj option>) =\n                    propOs\n                    |> Seq.choose(fun (n,vO) -> vO |> Option.map(fun v -> n,v))\n                    |> newPojo\n            \n            module GenEditor =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    line : int\n                    col  : int\n                }\n            \n                type AnnotationType =\n                | Error   \n                | Warning \n                | Info    \n                | Hint\n                | Other of string\n            \n                type Annotation = {\n                    startP        : Position\n                    endP          : Position\n                    severity      : AnnotationType\n                    message       : string\n                }\n            \n                type Completion = {\n                    kind                : string\n                    label               : string\n                    detail              : string\n                    replace             : Position * Position\n                }\n            \n                [<NoComparison ; NoEquality>]\n                type GenEditorHook<'T> = {\n                    generateDoc       :  GenEditor<'T> -> ('T -> unit)     -> Doc\n                    getValue          :  unit                              -> string\n                    setValue          :  string                            -> unit\n                    setDisabled       :  bool                              -> unit\n                    showAnnotations   :  Annotation seq                    -> unit\n                    posFromIndex      :  int                               -> Position\n                    indexFromPos      :  Position                          -> int\n                    getWordAt         :  Position                          -> (string * Position) option\n                    getSelectionText  :  unit                              -> string\n                    getUri            :  unit                              -> string\n                    setUri            :  string                            -> unit\n                    hookOnChange      : (obj           -> unit           ) -> unit\n                }\n            \n                and GenEditor<'T> = {\n                    var             :  Var< string        >\n                    disabled        :  View<bool          >\n                    annotations     :  View<Annotation seq>\n                    onChange        : (GenEditor<'T> -> string      -> unit                              ) option\n                    onRender        : (GenEditor<'T>                -> unit                              )\n                    autoCompletion  : (GenEditor<'T> -> Position    -> Async<Completion []>              ) option\n                    toolTip         : (GenEditor<'T> -> Position    -> Async<string              option >) option\n                    declaration     : (GenEditor<'T> -> Position    -> Async<(Position * string) option >) option\n                    mutable editorO :  'T option\n            \n                    editorHook      : GenEditorHook<'T>\n                }\n                \n                let inline setVar   v   genE = { genE with var      = v   }\n                let inline onChange f   genE = { genE with onChange = f   }\n                let inline onRender f   genE = { genE with onRender = f   }\n                let inline disabled dis genE = { genE with disabled = dis }\n            \n                let inline var          genE = genE.var\n            \n                let newVar edh var = {\n                    var            = var \n                    disabled       = V false\n                    annotations    = V Seq.empty\n                    onChange       = None\n                    onRender       = ignore\n                    editorHook     = edh\n                    autoCompletion = None\n                    toolTip        = None\n                    declaration    = None\n                    editorO        = None\n                }\n            \n                let newText edh (v:string)             = newVar edh (Var.Create v)\n                let newVarO edh (v:Var<string option>) = \n                    Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                    |> newVar edh\n                    |> disabled(V (Option.isNone v.V))\n            \n                /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n                /// onChange gets called when the editor changes but not when the var changes\n                let bindVarEditor setEvent getVal setVal onChange (var:Var<_>) =\n                    let editorChanged = ref 0L\n                    let varChanged    = ref 0L\n                    setEvent(fun _ ->\n                        let v = getVal() \n                        if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange v \n                    )\n                    var.View |> View.Sink (fun _ ->\n                        if  !editorChanged > !varChanged then varChanged := !editorChanged\n                        elif getVal() <> var.Value then setVal var.Value\n                    )\n            \n                let generateDoc genE = \n                    let onChange = genE.onChange |> Option.map(fun f -> f genE) |> Option.defaultValue ignore\n                    genE.editorHook.generateDoc genE (fun ed ->\n                        genE.editorO        <- Some ed\n                        genE.var            |> bindVarEditor  genE.editorHook.hookOnChange    \n                                                              genE.editorHook.getValue \n                                                              genE.editorHook.setValue \n                                                              onChange\n                        genE.annotations    |> View.Sink      genE.editorHook.showAnnotations\n                        genE.disabled       |> View.Sink      genE.editorHook.setDisabled\n                        genE.onRender genE\n                    )\n            \n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module Serializer =\n                open System\n                \n                type SerS<'T> = ('T  -> string)        //      Serialization function\n                type SerD<'T> = (obj -> 'T    )        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>    // both Serialization functions\n                \n                let inline ifUndef  def v   = if isUndefined v then def   else   v\n                let inline ifUndefF def f v = if isUndefined v then def v else f v\n                \n                let (|Exists|_|) field o = if isUndefined o?(field) then None else Some o?(field)\n                \n                let deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n                \n                let serFloat  : Ser<float   > = sprintU               , (unbox >> ifUndef 0.0             )\n                let serInt    : Ser<int     > = sprintU               , (unbox >> ifUndef 0               )\n                let serBool   : Ser<bool    > = sprintU               , (unbox >> ifUndef false           )\n                let serString : Ser<string  > = Json.Serialize        , (unbox >> ifUndef \"\"              )\n                let serDate   : Ser<DateTime> = (date2Long >> sprintU), (unbox >> ifUndef 0L >> long2Date )\n            \n                let [< Inline >] inline serId  (get: 'a->System.Guid) (set:System.Guid->'a) (print: 'a->string) : Ser<'a> =\n                    let s           = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ          = sprintf \"%A\" s\n                    let serialize   = fun id       -> get id |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize = fun (x: obj) -> x?(s) |> deserGuid |> set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * _ * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser >> Some, (fun rc o -> set (deser o) rc) \n                    \n                let serFieldO (name:string) (get:'D->'e option) (set:'e option->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * _ * _ = \n                    serFuncs |> fun (ser, deser) -> name, get >> Option.map ser, (fun rc o -> set (if isUndefined o then None else Some(deser o) ) rc) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * ('D -> string option) * ('D -> SerD<'D>))>) : Ser<'D> =\n                    let serialize   dim = fields |> Seq.choose(fun (n, ser, _deser) -> ser dim |> Option.map (sprintf \"%A: %s\" n)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, _ser,  deser) ->  deser dim (o?(n)) )   init\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser))               )\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toArray)\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\") , (unbox<obj  > >> ifUndefF (fun _ -> None     ) (         snd ser   >> Some      ))\n                let serDup serFst serSnd : Ser<'a * 'b    > = (fun (f,s) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s)), (unbox<obj[]> >> ifUndefF (fun _ -> snd serFst null, snd serSnd null ) (fun os -> snd serFst os.[0], snd serSnd os.[1] ) )\n                let serMap serKey serElm : Ser<Map<'k, 'e>> = serDup serKey serElm |> serSeq |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Map)       )\n            \n                let serVarField (name:string) (var:'D->Var<'e>) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, (var >> Var.Get >> ser), (fun rc o -> var rc |> Var.Set <| deser o ; rc)\n            \n                let serLMdField (name:string) (lmd:'D->ListModel<_,'e>) serE  : string * SerS<'D> * ('D -> SerD<'D>) = \n                    let serS              = serSeq serE\n                    let serializer   rc   = lmd rc |> (fun lm -> lm.Value) |> fst serS\n                    let deserializer rc b = lmd rc |> (fun lm -> lm.Set  ) <| snd serS b ; rc\n                    name, serializer, deserializer\n            \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let rexEmail = \"\"\"(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            [< JavaScript >]\n            module Hoverable =\n                open WebSharper.UI.Html\n            \n                [<NoComparison ; NoEquality>]\n                type Hoverable         = { hover : Var<bool>        } with\n                    static member  New() = { hover = Var.Create false }\n                    member inline this.Attributes = [ attr.classDynPred (View.Const \"hovering\") this.hover.View\n                                                      on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n                                                      on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n                                                    ]   \n                    member inline this.Content    (ds: Doc seq) = div this.Attributes ds\n                    member inline this.Content    ( e: Elt    ) = e.OnMouseEnter(fun _ _ -> e.AddClass    \"hovering\") // THIS ONE ADDS ONE EXTRA SPACE\n                                                                   .OnMouseLeave(fun _ _ -> e.RemoveClass \"hovering\") // THAT THIS ONE DOES NOT REMOVE      \n                    //member inline this.Content    ( e: Elt    ) = e.WithAttrs this.Attributes\n                    static member  Demo  = Hoverable.New().Content(Elt.div [ attr.style \"flex-flow: column;\" ] [ text \"Hover over me!\" ])\n            \n                let hoverable (e:Elt) = Hoverable.New().Content e\n                \n            [< JavaScript >]\n            module ResizeObserver =\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module WebComponent =\n            \n                [< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\n                let ReflectConstruct () = X<_>\n                \n                [< Inline \"\"\"console.log('defineWebComponent: ' + $_nm);\n                            Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n                            Object.setPrototypeOf($_c, $global.HTMLElement);\n                            Object.setPrototypeOf($_o.prototype, $_c.prototype);\n                            $global.customElements.define($_nm, $_o)\"\"\" >]\n                let defineWebComponent_ _nm _o _c = X<_>\n            \n                let defineWebComponent _nm _o _c = \n                    try defineWebComponent_ _nm _o _c\n                    with _ -> printfn \"Failed to define WebComponent. Not supported.\"\n            \n                module WcTabStrip =\n                    open WebSharper.UI.Html\n                    //open TabStrip\n                    open Hoverable\n                \n                    let css = @\"\n                .tab-panel {\n                 overflow  : hidden   ;\n                 display   : flex     ;\n                 flex-flow : column   ;\n                 background: lightgray;\n                 height    : 100%    ;\n                 width     : 100%    ;\n                }\n                .tab-content {\n                 flex      : 1 1     ;\n                 overflow  : auto    ;\n                 position  : relative;\n                }\n                .tab-children {\n                 height    : 100%    ;\n                 width     : 100%    ;\n                 position  : absolute;\n                 display   : grid    ;\n                }\n                .tab-strip {\n                 padding   : 0pt     ;\n                 flex      : 0 0     ;\n                }\n                .tab {\n                 border     : 0.2pt solid transparent;\n                 padding    : 0pt 4pt;\n                 display    : inline-block;\n                 font-family: sans-serif;\n                 font-weight: 200;\n                 font-size  : small;\n                 color      : #666;\n                 cursor     : pointer;\n                }\n                .top>.tab {\n                 border-radius: 2pt 2pt 0pt 0pt;\n                 border-bottom-width: 0pt;\n                 vertical-align: bottom;\n                }\n                .bottom>.tab {\n                 border-top-width: 0pt;\n                 border-radius: 0pt 0pt 2pt 2pt;\n                 vertical-align: top;\n                }\n                .horizontal>.tab:not(:first-child) {\n                 border-left-width: 0pt;\n                }\n                .tab.hovering {\n                 background: red;\n                }\n                .tab.selected {\n                 background: white;\n                 border-left-width: 0.2pt;\n                 color: black;\n                 font-weight: 500;\n                 border-color: black;\n                }\n                .horizontal>.tab.selected {\n                 border-left-width: 0.2pt;\n                }\n                ::slotted(*              ) { \n                 width : 100%;\n                 height: 100%;\n                }\n                        \"\n                \n                    let tabStrip (selected:Var<int>) top horizontal tabs content =\n                        let strip =\n                            div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\n                                                        (if top        then \"top\"        else \"bottom\"  ) \n                                                        (if horizontal then \"horizontal\" else \"vertical\")\n                                ]\n                                [ for i, (txt, _) in  tabs |> Seq.indexed  do\n                                      yield Hoverable.New().Content (\n                                          Elt.div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i + 1 then \" selected\" else \"\")) selected.View\n                                                    attr.draggable \"true\"\n                                                    on.click   (fun _  _  -> selected.Value <- i + 1 ) \n                                                  ]\n                                                  [ text txt ]) :> Doc\n                                ] \n                        div [ attr.``class`` \"tab-panel\" \n                                //on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n                                //on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n                            ]\n                            [   if     top then yield strip\n                                yield div [ attr.``class`` \"tab-content\" ] [ content ]\n                                if not top then yield strip\n                                yield Elt.Element \"style\" [] [ text css ] :> Doc\n                                yield Elt.Element \"style\" [] \n                                        [ Doc.TextView <| View.Map (sprintf \"\"\"\n                                              ::slotted(*              ) { display: none }\n                                              ::slotted(*:nth-child(%d)) { display: grid }\n                                           \"\"\") selected.View \n                                        ] \n                                    :> Doc\n                            ]\n                \n                    type WcTabStripT () =\n                        let mutable added = false\n                        let selected = Var.Create 1\n                        do printfn \"WcTabStripT initializer\"\n                        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcTabStripT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot       = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh = JS.Document.CreateElement \"div\"\n                                shadowRoot.AppendChild elsh |> ignore\n                                let addTab () =\n                                    //printfn \"my-el modified %A %A\" added this?outerHTML\n                                    let top  = el.HasAttribute \"bottom\" |> not\n                                    let tabs = [ for i in 1..el.ChildNodes.Length do \n                                                    let node = el.ChildNodes.[i - 1]\n                                                    if node.NodeType = Dom.NodeType.Element then\n                                                        let elem = node :?> Dom.Element\n                                                        let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                                        yield (tabName, elem)\n                                                ]\n                                    while elsh.ChildNodes.Length > 0 do\n                                        elsh.RemoveChild elsh.LastChild |> ignore\n                                    Elt.Element \"slot\" [] []\n                                    |> tabStrip selected top true tabs\n                                    |> Doc.Run elsh\n                                addTab()\n                                el.AddEventListener(\"DOMSubtreeModified\", delayed 50 addTab)\n                                added <- true\n                    let init =\n                        lazy\n                            let x = WcTabStripT().connectedCallback\n                            if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n                    \n                module WcSplitter =    \n                    open ResizeObserver\n                    \n                    type Layout = View<string> -> (Dom.Element -> unit) -> (Dom.Element -> unit) -> (Dom.MouseEvent -> unit) -> View<string> -> Doc\n                    \n                    let mutable layoutHorizontal : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    let mutable layoutVertical   : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    \n                    type WcSplitterT () =\n                        let mutable added = false\n                        do printfn \"WcSplitterT initializer\"\n                        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcSplitter.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcSplitterT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh        = JS.Document.CreateElement \"div\"\n                                let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n                                let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n                                let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n                                let first       =    el.HasAttribute \"second\"   |> not\n                                let vertical    =    el.HasAttribute \"vertical\"\n                                let size        = ref        (0.0, 0.0)\n                                let padding     = ref         0.0\n                                let gap         = Var.Create  0.0\n                                let sizeCalc (sh:Dom.Element) : float * float =\n                                    let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                                                 else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                                    let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                                    let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                                    gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                                    padding := pt + pb\n                                    el.GetBoundingClientRect() \n                                    |> fun r -> \n                                         match vertical, first with\n                                         | true , true  ->  r.Width , r.Height \n                                         | true , false -> -r.Width , r.Height\n                                         | false, true  ->  r.Height, r.Width\n                                         | false, false -> -r.Height, r.Width\n                                let dragging : bool               ref = ref false   \n                                let startP   : float              ref = ref 0.0\n                                let start    : float              ref = ref 0.0\n                                let domElem  : Dom.Element option ref = ref None                 \n                                let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                                let drag (ev: Dom.Event) =\n                                    ev :?> Dom.MouseEvent\n                                    |> mouseCoord\n                                    |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                                    |> fun v   -> value.Value <- min maxV (max minV v)\n                                   \n                                let rec finishDragging (_: Dom.Event) =\n                                    if !dragging then\n                                        dragging := false\n                                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                                let startDragging (ev: Dom.MouseEvent) =\n                                    if not !dragging then\n                                        dragging := true\n                                        startP   := value.Value\n                                        start    := mouseCoord ev\n                                        size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                                        ev.PreventDefault()\n                                    //div [\n                                    //    SomeAttr  <| on.mouseDown startDragging\n                                    //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                                    //    style     <| styleSplitter !gap\n                                    //    style        \"z-index: 10; background-color: #eef\"\n                                    //]\n                                let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                                             , (sz - gap - pad) * (100.0 - spl) / 100.0\n                                let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n                                let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n                                //div [ \n                                //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                                //    style <| Val.map styleSizes value\n                                //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                                //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                                //    slot [ name \"splitter\" ; splitter                                               ]\n                                //]\n                                let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n                                //addResizeObserver recalc el\n                                (if vertical then layoutVertical else layoutHorizontal)\n                                    <| View.Map styleSizes value.View\n                                    <| fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc()\n                                    <| fun  sp              -> domElem :=          Some sp ; recalc()\n                                    <| fun  me              -> startDragging me\n                                    <| View.Map (sprintf \"%Apx\") gap.View\n                                |> Doc.Run elsh\n                                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                                added <- true\n                    let init layoutH layoutV =\n                        let x = WcSplitterT().connectedCallback\n                        layoutHorizontal <- layoutH\n                        layoutVertical   <- layoutV\n                        if IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n                    \n            [< JavaScriptExport >]\n            module Monaco =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri    = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f) \" >] static member File(_f)       : Uri    = X<_>\n                    [< Inline \"$this.toString()             \" >] override this.ToString()     : string = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.uri                                           \" >] member mo.GetUri()                        : Uri            = X<_>\n                    [< Inline \"$mo.uri = $_v                                     \" >] member mo.SetUri(_v:Uri)                  : unit           = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.getPositionAt($_i)                            \" >] member mo.GetPositionAt(_i: int     )     : Position       = X<_>\n                    [< Inline \"$mo.getOffsetAt($_p)                              \" >] member mo.GetOffsetAt(  _p: Position)     : int            = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    [< Inline \"$mo.getValueInRange($_r)                          \" >] member mo.GetValueInRange(  _r: Range)    : string         = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8 \n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                open WebSharper.Core.Resources\n                type MonacoResources() =\n                    inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n            \n                [< Require(typeof<MonacoResources>) >]\n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    [< Inline \"$monc.getSelection()              \" >] member monc.GetSelection()                              : Range           = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (string -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        //do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             = \n                    async {\n                      do! loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> GenEditor.bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                          )    \n                        ] []\n                    } |> Doc.Async\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n            [< JavaScriptExport >]\n            module MonacoGenAdapter =\n                open Monaco\n                open GenEditor\n                open WebSharper.UI.Html\n            \n                type MonacoRT = {\n                    mutable editorO     : Monaco.Editor option\n                    mutable onChange    : obj -> unit\n                    options             : obj\n                    overrides           : obj\n                }\n            \n                let iterEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> ()\n                    | Some ed -> f ed\n            \n                let mapEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> None\n                    | Some ed -> Some (f ed)\n            \n                let bindEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> None\n                    | Some ed -> f ed\n            \n                let posGen2Ed (p:GenEditor.Position) : Monaco.Position = \n                    {\n                        column     = p.col \n                        lineNumber = p.line\n                    }\n            \n                let posEd2Gen (p:Monaco.Position) : GenEditor.Position = \n                    {\n                        col  = p.column    \n                        line = p.lineNumber\n                    }\n            \n                let indexFromPos monRT p =\n                    mapEditor monRT <| fun ed ->\n                        ed.GetModel().GetOffsetAt(posGen2Ed p)            \n                    |> Option.defaultValue -1\n            \n                let posFromIndex monRT i =\n                    mapEditor monRT <| fun ed ->\n                        ed.GetModel().GetPositionAt i\n                        |> posEd2Gen\n                    |> Option.defaultValue { col = 1 ; line = 1 }\n            \n                let convertGlyphChar =\n                    function\n                    | \"C\" -> CompletionItemKind.Class\n                    | \"E\" -> CompletionItemKind.Enum\n                    | \"S\" -> CompletionItemKind.Value\n                    | \"I\" -> CompletionItemKind.Interface\n                    | \"N\" -> CompletionItemKind.Module\n                    | \"M\" -> CompletionItemKind.Method\n                    | \"P\" -> CompletionItemKind.Property\n                    | \"F\" -> CompletionItemKind.Field\n                    | \"T\" -> CompletionItemKind.Class\n                    | \"K\" -> CompletionItemKind.Keyword\n                    | _   -> 0 |> unbox\n            \n                type CompletionItemProvider(autoComplete: GenEditor.Position -> Async<Completion[]>) =\n                    do()\n                   with\n                      member __.provideCompletionItems(model:Model, pos:Monaco.Position, token:obj, context: obj) =\n                        asyncResultM {\n                            let! comps = autoComplete  { col = pos.column ; line = pos.lineNumber }\n                            return comps \n                                    |> Array.map(fun (comp:Completion) -> \n                                        { \n                                            kind   = convertGlyphChar comp.kind\n                                            label  = comp.label\n                                            detail = comp.detail\n                                        } )\n                        } |> PromiseM.ofAsyncResultM\n                      member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n            \n            \n                type HoverProvider(toolTip: GenEditor.Position -> Async<string option> ) =\n                    do()\n                   with\n                      member __.provideHover(model:Model, pos:Monaco.Position, token:obj) =\n                        asyncResultM {\n                            let! desc = toolTip { col = pos.column ; line = pos.lineNumber }\n                            match desc with\n                            | None      -> return (box null |> unbox)\n                            | Some desc ->\n                            return {\n                                    contents = [| { value = desc ; isTrusted = true } |]\n                                    range    = (box null |> unbox)\n                                }\n                        } |> PromiseM.ofAsyncResultM\n            \n                type DefinitionProvider(declaration: GenEditor.Position -> Async<(Position * string) option> ) =\n                    do()\n                   with\n                        member __.provideDefinition(model: Model, pos: Monaco.Position, token: obj) =\n                            asyncResultM {\n                                let! declO =  declaration { col = pos.column ; line = pos.lineNumber }\n                                match declO with\n                                | None             -> return box null |> unbox\n                                | Some (pos, file) ->\n                                return {\n                                    range = {\n                                                startColumn     = pos.col\n                                                endColumn       = pos.col\n                                                startLineNumber = pos.line\n                                                endLineNumber   = pos.line\n                                    }\n                                    uri   = Uri.Parse file\n                                }\n                            } |> PromiseM.ofAsyncResultM\n            \n                let generateDoc monRT genE onRender =\n                    async {\n                      do! Monaco.loader\n                      return\n                          div [ on.afterRender (fun elchild  ->\n                                    let editor        = Monaco.Editor.Create elchild.ParentElement monRT.options monRT.overrides\n                                    ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                    elchild.ParentNode.RemoveChild elchild |> ignore\n                                    monRT.editorO     <- Some editor\n                                    onRender                  editor\n                                    editor.OnDidChangeModelContent monRT.onChange\n                                    genE.toolTip        |> Option.iter (fun f -> Editor.RegisterHoverProvider         (\"fsharp\", new HoverProvider         (f genE) ) |> ignore )\n                                    genE.declaration    |> Option.iter (fun f -> Editor.RegisterDefinitionProvider    (\"fsharp\", new DefinitionProvider    (f genE) ) |> ignore )\n                                    genE.autoCompletion |> Option.iter (fun f -> Editor.RegisterCompletionItemProvider(\"fsharp\", new CompletionItemProvider(f genE) ) |> ignore )\n                          )    \n                        ] []\n                    } |> Doc.Async\n            \n                let getUri    monRT     = mapEditor  monRT    <| (fun ed -> ed.GetModel().GetUri().ToString() ) |> Option.defaultValue \"\" \n                let setUri    monRT uri = iterEditor monRT    <|  fun ed -> ed.GetModel().SetUri(Uri.Parse uri) \n                let getValue  monRT     = mapEditor  monRT    <| (fun ed -> ed.GetValue()   ) |> Option.defaultValue \"\" \n                let setValue  monRT txt = iterEditor monRT    <|  fun ed -> ed.SetValue txt \n                let getWordAt monRT pos = bindEditor monRT    <|  fun ed -> let word = ed.GetModel().GetWordAtPosition {    \n                                                                                column     = (pos:GenEditor.Position).col\n                                                                                lineNumber = pos.line }\n                                                                            if isUndefined word then None else \n                                                                            (word.word, {   col  = word.startColumn\n                                                                                            line = pos.line })\n                                                                            |> Some\n                let getSelect monRT     = mapEditor  monRT    <| (fun ed -> ed.GetSelection() |> ed.GetModel().GetValueInRange ) |> Option.defaultValue \"\" \n            \n                let showAnnotations monRT ans =\n                    iterEditor monRT <| fun ed ->\n                        let ms =\n                            ans\n                            |> Seq.map (fun (an:Annotation) ->\n                                {   message           = an.message\n                                    severity          = match an.severity with \n                                                        | Error   -> MarkerSeverity.Error \n                                                        | Warning -> MarkerSeverity.Warning  \n                                                        | Hint    -> MarkerSeverity.Hint \n                                                        | _       -> MarkerSeverity.Info\n                                    startColumn       = an.startP.col\n                                    startLineNumber   = an.startP.line\n                                    endColumn         = an.endP  .col\n                                    endLineNumber     = an.endP  .line\n                                }\n                            )\n                            |> Seq.toArray\n                        Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)\n            \n                let newHook monRT = {\n                    generateDoc      =            generateDoc  monRT \n                    getValue         = fun ()  -> getValue     monRT\n                    setValue         =            setValue     monRT\n                    getWordAt        =            getWordAt    monRT\n                    showAnnotations  = showAnnotations         monRT\n                    setDisabled      = ignore //  bool                              -> unit\n                    hookOnChange     = fun f   -> monRT.onChange <- f \n                    posFromIndex     =            posFromIndex monRT\n                    indexFromPos     =            indexFromPos monRT\n                    getUri           = fun ()  -> getUri       monRT\n                    setUri           =            setUri       monRT\n                    getSelectionText = fun ()  -> getSelect    monRT\n                }\n            \n                let newRT options overrides = {\n                    editorO     = None\n                    onChange    = ignore\n                    options     = options   \n                    overrides   = overrides \n                }\n            \n                let newVar options overrides v =\n                    newRT options overrides\n                    |> newHook\n                    |> GenEditor.newVar <| v\n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            module FsiAgent =\n                open FusionAsyncM\n                open FsiEvaluator\n                open FsiCodePresence\n                open Operators\n            \n                [< JavaScript >]\n                type Config = Config of workDir:string * parms:Set<string>\n            \n                let fuseConfigs workDir a b =\n                    match a, b with\n                    | Config(dirA, parmsA), Config(dirB, parmsB) ->\n                    Config((if dirB <> workDir then dirB else dirA), Set.union parmsA parmsB)\n            \n                let queueOutput send =\n                    let output        = new System.Text.StringBuilder()\n                    let append    txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n                    let consume   ()  = let v = output.ToString()\n                                        output.Clear() |> ignore\n                                        v\n                    let queue         = Mailbox.iter print (fun msg -> \n                                            match msg with\n                                            | Some txt -> append txt\n                                            | None     -> let txt2send =  consume()\n                                                          if  txt2send <> \"\" then send txt2send\n                                        )\n                    fun          txt -> txt |> Some |> queue.Post\n                                        async { do! Async.Sleep 100\n                                                queue.Post None } |> Async.Start\n            \n                let mutable outHndl      = ignore\n                let mutable errHndl      = ignore\n            \n                let setQueueHandlers send =\n                    let queue = queueOutput send \n                    outHndl <-                  queue\n                    errHndl <- ((+) \"Err: \") >> queue\n            \n                let ctor, aborter, disposer, getIdO, sendInput =\n                    let mutable fsiO = None\n                    let ctor (Config (workDir, config)) =\n                        let fsi = new FsiExe(config |> String.concat \" \", workDir, outHndl, errHndl)\n                        fsiO <- Some fsi\n                        fsi\n                    ctor\n                  , (fun ()  -> fsiO |> Option.iter (fun fsi ->  fsi                       .Abort      () ) )\n                  , (fun ()  -> fsiO |> Option.iter (fun fsi -> (fsi :> System.IDisposable).Dispose    () ) )\n                  , (fun ()  -> fsiO |> Option.map  (fun fsi ->  fsi                       .Process.Id    ) )\n                  , (fun txt -> fsiO |> Option.iter (fun fsi ->  fsi                       .Shell.Send txt) )\n            \n                let fsiExeL = lazy new ResourceAgent<_, _>( 70\n                                                         , ctor\n                                                         , Config (\".\", Set [\"--nologo\" ; \"--quiet\"])\n                                                         , (fun fsi    -> fsi.Abort()               ) \n                                                         , (fun fsi    -> fsi.IsAlive               )\n                                                         )\n            \n                [< JavaScript >]\n                let extractConfig workDir (FsCode fsCode) = \n                    Config(\n                        FsCode.getSourceDir workDir <| String.splitByChar '\\n' fsCode\n                      , FsCode.extractDefines (FsCode fsCode)\n                        |> String.splitByChar ' '\n                        |> Set\n                        |> Set.union  (Set[\" --nologo\" ; \"--quiet \"])\n                    )\n            \n                [< Rpc >]\n                let evalCode workDir code = \n                    evaluateRm code\n                    |> AgentReaderM.ofResourceRm\n                    |> AgentReaderM.run fsiExeL.Value (extractConfig workDir code)\n            \n                [< Rpc >]\n                let evalCodeSameConfig code = \n                    evaluateRm code\n                    |> AgentReaderM.ofResourceRm |> id\n                    |> AgentReaderM.runSameConfig fsiExeL.Value\n                \n                [< Rpc >]\n                let evalCodeWithPresence  workDir presenceKey presenceValue presenceCode code = \n                    let config = \n                        fuseConfigs       workDir\n                        <| extractConfig  workDir presenceCode\n                        <| extractConfig  workDir         code\n                    fusion {    \n                        let! currentValueO  = getPresenceRm presenceKey\n                        if   currentValueO <> Some presenceValue then\n                            do!  addPresenceRm presenceKey presenceValue\n                            do!  evaluateRm    presenceCode |>> ignore\n                        return! evaluateRm code\n                    }\n                    |> AgentReaderM.ofResourceRm\n                    |> AgentReaderM.run fsiExeL.Value config\n             \n                [<Rpc>]    \n                let abortFsiExe  () = aborter()\n                \n                [<Rpc>]    \n                /// like abortFsiExe but prevents respawning until next command\n                let disposeFsiExe() = disposer()\n            \n                [<Rpc>]\n                let sendFsiInput txt = async { sendInput txt }\n            \n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                //#define WEBSHARPER\n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n                \n                open System\n                open System.Threading\n                open System.Net.WebSockets\n                \n                [< JavaScript false >]\n                module Client =\n                    let startStateFull receive initAndfolder =\n                        async {\n                            let! initState, folder = initAndfolder\n                            let agentBox = Mailbox.foldA (fun ex st -> print ex; st) folder initState\n                            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n                            let error  a = agentBox.Post CMessage.Error ; finish a\n                            Async.StartWithContinuations(receive agentBox, finish, error, error)\n                        }\n                \n                    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n                        let conn = new ClientWebSocket()\n                        let chunkSize = 8192\n                        let send (txt:string)  =\n                            async {\n                                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                                let chunks = buffer.Length / chunkSize\n                                for i = 0 to chunks do\n                                    let last = i = chunks\n                                    let size = if last then buffer.Length % chunkSize else chunkSize\n                                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n                            }\n                        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n                            let buffer : byte[] = Array.create chunkSize 0uy\n                            let builder         = System.Text.StringBuilder()\n                            let keepgo          = ref true\n                            async {\n                                receiverBox.Post CMessage.Open\n                                while conn.State = WebSocketState.Open && !keepgo do\n                                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                                    match result.MessageType with\n                                    | WebSocketMessageType.Close -> keepgo := false\n                                    | WebSocketMessageType.Text ->\n                                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                                        builder.Append txt |> ignore\n                                        if result.EndOfMessage then\n                                            let txt = builder.ToString()\n                                            builder.Clear() |> ignore\n                                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                                    | _ -> ()\n                                return \"WebSocketServer receive Closed.\"\n                            }\n                        let brokerBox = Mailbox.iterA print (Json.Serialize >> send)\n                        let connect initAndfolder =\n                            async {\n                                printfn \"Connecting %s\" uri\n                                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                                printfn \"Connected %A\" WebSocketState.Open\n                                do! startStateFull receive initAndfolder\n                            }\n                        member this.WebSocket        = conn\n                        member this.Post (msg: 'C2S) = brokerBox.Post msg\n                        member this.Connect          = connect\n                \n                    let ConnectStateful<'S2C, 'C2S> uri getInitAndfolder =\n                        async {\n                            let  server          = WebSocketServer uri\n                            do!  server.Connect (getInitAndfolder server)\n                            return server\n                        }\n                \n                    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n                        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =\n                            f { new IServer with\n                                  member this.Post  v = serverP.Post v\n                                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                                        |> Async.AwaitTask |> Async.RunSynchronously            \n                               }\n                        ConnectStateful uri2 func\n                        |> Async.map ignore\n                        \n                //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open System\n                open WebSharper.Owin.WebSocket\n                open WebSharper.Owin.WebSocket.Client\n                \n                //#define FSS_SERVER\n                //#define WEBSHARPER\n                \n                type  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n                \n                type ClientTypeFSharp    = FSharp\n                #if WEBSHARPER\n                type ClientTypeFSStation = FSStation\n                type ClientTypeJScript   = JScript\n                \n                [< Inline >]\n                let ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n                    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n                        f { new IServer with\n                              member this.Post  v = serverP.Post v\n                              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n                           }\n                    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n                    ConnectStateful endPoint func\n                    |> Async.map ignore\n                #endif\n                \n                module ReplyHandler =\n                    type WaitForReplyMsg =\n                        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n                        | Reply  of Guid *   MessageGeneric\n                        | Excpn  of Guid *   exn\n                        | Cancel of Guid *   OperationCanceledException\n                        \n                    type Handler (defProc) =\n                        let waitingAgent =    \n                            Mailbox.fold Mailbox.defHandler (fun waitingForReply action ->\n                                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def\n                                                      Map.remove  key     waitingForReply\n                                match action with\n                                | Add   (key, fns) -> Map.add     key fns waitingForReply\n                                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)\n                                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore\n                                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore\n                            ) Map.empty\n                        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post\n                        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post\n                        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post\n                        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post\n                \n                [< Inline \"window.location.href\" >]\n                let getEndPoint() = \n                #if FSS_SERVER\n                    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n                #else\n                    \"http://localhost:9005/#/Snippet/47149dff-c248-4229-8076-db0dc48a3b0e\"\n                #endif\n                \n                let extractEndPoint() = \n                    let ep : string = getEndPoint()\n                    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n                    ep2.Split('/').[0]\n                \n                type WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n                        , clientId:string, ?timeout:int, ?endPoint:string) =    \n                    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n                    let clientAddress = Address clientId\n                    let wsTimeout     = defaultArg timeout 60000\n                \n                    let mutable out = printfn \"%s\"\n                    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n                    let mutable serverO : IServer option = None\n                    let mutable payloadProcessorO : (string -> Async<string>) option = None\n                    let waiting = ReplyHandler.Handler (fun msg -> printfn \"Reply from '%s': %s\" msg.from.txt msg.payload)\n                \n                    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n                    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n                \n                    let processReply      msg = waiting.Reply msg.id msg\n                    let mapPayloadWrap (fW: _ -> Async<_> ) msg =\n                        async {\n                            let! r  = fW msg.payload\n                            return msg |> mapPayload (fun _ -> r)\n                        }\n                    let processMessage msg =\n                        //printfn \"%A\" msg\n                        match msg.msgType with\n                        | MsgFromBroker     \n                        | MsgReply           -> processReply msg\n                        | MsgInformation     -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                        | MsgRequest         -> match payloadProcessorO with \n                                                | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                                                | Some processor ->\n                                                msg |> mapPayloadWrap processor |> Async.iterA (makeReply >> reply) \n                        | MsgRequestForEcho  -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n                        | MsgRequestForId    -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n                    \n                    let connectToWebSocketServer() =\n                        printfn \"in connectToWebSocketServer\"\n                        async {\n                            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                                return 0, fun state wsmsg -> async {\n                                    try match wsmsg with\n                                        | CMessage.Message msg -> processMessage msg\n                                        | CMessage.Open        -> printfn \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                                        | CMessage.Close       -> printfn \"WebSocket %s connection closed.\" clientId ; close()\n                                        | CMessage.Error       -> printfn \"WebSocket %s connection error!\"  clientId\n                                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                                    return state\n                                }\n                            }\n                            printfn \"connectToWebSocketServer with server\"\n                            \n                        }\n                \n                    let checkServer = Mailbox.callA print ( fun () -> async {\n                        //printfn \"getServer\"\n                        if serverO.IsNone then\n                            printfn \"getServer Connecting\"\n                            do! connectToWebSocketServer()\n                            do! Async.Sleep 200\n                        return serverO |> Result.ofOption (fun () -> ErrorMsg \"could not connect to Server\")\n                    })        \n                \n                    let getServer() : AsyncResult<IServer, _> = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n                        \n                    let postR (server: IServer) rpl msg = \n                        let m = msg |> from clientAddress |> replier rpl \n                        try       server.Post m\n                        with e -> serverO <- None\n                                  raise e\n                \n                    let sendAndForget msg = asyncResult {\n                        let! server = getServer()\n                        msg |> postR server NoReply\n                    }\n                        \n                    let sendAndReply rpl msg = asyncResult {\n                        let! server  = getServer()\n                        let  replyA  = Async.FromContinuations(fun fns -> \n                            waiting.Add msg.id fns\n                            msg |> postR server rpl\n                            if wsTimeout > 0 then\n                                async {\n                                    do! Async.Sleep wsTimeout\n                                    waiting.Raise msg.id (TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn)\n                                } |> Async.Start\n                        )\n                        return! replyA\n                    }\n                        \n                    let sendAndVerify msg = asyncResult {\n                        let! reply   = sendAndReply Broker msg \n                        do!  match reply.msgType with\n                             | MsgFromBroker  -> let  bm = msgPayload reply\n                                                 if   bm = BMOk \n                                                 then Result.Ok    () \n                                                 else Result.Error <| ResultMessage.Message bm\n                             | _              ->      Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                    }\n                    \n                    let sendGetReply msg =\n                        asyncResult {\n                            let! reply   = sendAndReply Receiver msg \n                            let! result =\n                                match reply.msgType with\n                                | MsgReply      -> Result.Ok     reply.payload\n                                | MsgFromBroker -> let bm = msgPayload reply\n                                                   Result.Error <| ResultMessage.Message bm\n                                | _             -> Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                            return result\n                        }\n                \n                    let getListeners() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRConnections listeners -> return listeners\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let getProcessId() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetProcessId\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRPid pid -> return pid\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let sendMsg msg =\n                        asyncResult {\n                            if msg.replier = NoReply\n                            then do!     sendAndForget msg\n                                 return  \"\"\n                            else return! sendGetReply  msg\n                        }\n                    member this.MBListeners            = getListeners()\n                    member this.MBProcessId            = getProcessId()\n                    member this.EndPoint               = wsEndPoint\n                    member this.ClientId               = clientId\n                    member this.SendMsg           msg  = sendMsg msg\n                    [<  Inline >]\n                    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n                    [<  Inline >]\n                    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n                    [<  Inline >]\n                    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> AsyncResult.map Json.Deserialize\n                    member this.Out with set fout      = out <- fout\n                    [<  Inline >]\n                    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Async.map Json.Serialize))\n                                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                                         |> msgType MsgInformation\n                                                         |> sendAndForget |> AsyncResult.iterA (string >> failwith) id\n                    interface IDisposable with\n                        member this.Dispose() = close()\n                \n                #if FSS_SERVER   \n                    [< JavaScript false >]\n                    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                    [< JavaScript false >]\n                    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #if WEBSHARPER\n                    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                \n                \n            [< JavaScript >]\n            type FSMessage =\n            | MsgGetId\n            | MsgGetSnippets     of SnippetReference[]\n            | MsgGetCode         of SnippetReference\n            | MsgGetPredecessors of SnippetReference\n            | MsgAction          of string[]\n            | MsgGetUrl\n            | MsgGetValue        of string\n            | MsgSetValue        of string * string\n            | MsgGetModified     of SnippetReference\n            \n            [< JavaScript >]\n            type FSResponse =\n            | RespString         of string\n            | RespSnippets       of Snippet[]\n            | RespDateTime       of System.DateTime\n            \n            module FSharpStationClient =\n                open WebSockets\n            \n                let mutable fsharpStationAddress = Address \"FSharpStation1568639954583\"\n            \n                let [< Rpc >] setAddress address = async { \n                    fsharpStationAddress <- address \n                    printfn \"set %A\" fsharpStationAddress\n                }\n            \n                let fsharpStationClient, sendMessage : WSMessagingClient * (FSMessage -> AsyncResult<FSResponse, _>) = \n                    let client =\n            #if WEBSHARPER \n                        if IsClient then \n                            new WSMessagingClient(\"FSharpStationClientJS\"       )\n                        else\n            #endif            \n            #if FSS_SERVER            \n                            new WSMessagingClient(\"FSharpStationClientFSStation\", FSStation)\n            #else\n                            new WSMessagingClient(\"FSharpStationClientFSharp\"   , FSharp)\n            #endif\n                    client, fun m -> client.SendGetReply fsharpStationAddress m |> AsyncResult.absorbR\n            \n                let respString response = asyncResult { \n                    match response with\n                    | RespString code -> return code\n                    | _               -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let respDateTime response = asyncResult { \n                    match response with\n                    | RespDateTime time -> return time\n                    | _                 -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let respSnippet response = asyncResult { \n                    match response with\n                    | RespSnippets [| snp |] -> return snp\n                    | _                      -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let getCode path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> MsgGetCode\n                    |> sendMessage\n                    |> AsyncResult.bind respString\n            \n                let getModified path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> MsgGetModified\n                    |> sendMessage\n                    |> AsyncResult.bind respDateTime\n            \n                let getSnippet path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> Array.singleton\n                    |> MsgGetSnippets\n                    |> sendMessage\n                    |> AsyncResult.bind respSnippet\n            \n                let getUrl      () = MsgGetUrl            |> sendMessage |> AsyncResult.bind respString\n                let getValue vrw   = MsgGetValue vrw      |> sendMessage |> AsyncResult.bind respString\n                let setValue var v = MsgSetValue (var, v) |> sendMessage |> AsyncResult.bind respString\n            \n                let execJS      js          = sendMessage (MsgAction [| \"ExecJS\"      ; js              |]) |> AsyncResult.bind respString\n                let setProperty path prop v = sendMessage (MsgAction [| \"SetProperty\" ; path ; prop ; v |]) |> AsyncResult.bind respString\n                let sendOutput  txt         = sendMessage (MsgAction [| \"AddOutput\"   ; txt             |])\n                let actionCall0 act         = sendMessage (MsgAction [|  act                            |])\n                let actionCall1 act p1      = sendMessage (MsgAction [|  act          ; p1              |])\n                let actionCall2 act p1 p2   = sendMessage (MsgAction [|  act          ; p1   ; p2       |])\n                                        \n                let getBrokerProcessId() = fsharpStationClient.MBProcessId\n            module FsAutoComplete =\n                [<JavaScript ; AutoOpen >]\n                module CommTypes =\n                    type ResponseError =\n                        {\n                          Code: int\n                          Message: string\n                          //AdditionalData: 'T\n                        }\n                    type Location =\n                      {\n                        File: string\n                        Line: int\n                        Column: int\n                      }\n                    type CompletionResponse =\n                      {\n                        Name: string\n                        ReplacementText: string\n                        Glyph: string\n                        GlyphChar: string\n                      }\n                    //type ProjectResponse =\n                    //  {\n                    //    Project: ProjectFilePath\n                    //    Files: List<SourceFilePath>\n                    //    Output: string\n                    //    References: List<ProjectFilePath>\n                    //    Logs: Map<string, string>\n                    //  }\n                    type OverloadDescription =\n                      {\n                        Signature: string\n                        Comment  : string\n                        Footer   : string\n                      }\n                    type OverloadParameter =\n                      {\n                        Name : string\n                        CanonicalTypeTextForSorting : string\n                        Display : string\n                        Description : string\n                      }\n                    type Overload =\n                      {\n                        Tip : OverloadDescription list list\n                        TypeText : string\n                        Parameters : OverloadParameter list\n                        IsStaticArguments : bool\n                      }\n                    type Parameter = {\n                        Name : string\n                        Type : string\n                      }\n                    type SignatureData = {\n                        OutputType : string\n                        Parameters : Parameter list list\n                      }\n                    type MethodResponse =\n                      {\n                        Name : string\n                        CurrentParameter : int\n                        Overloads : Overload list\n                      }\n                    type SymbolUseRange =\n                      {\n                        FileName: string\n                        StartLine: int\n                        StartColumn: int\n                        EndLine: int\n                        EndColumn: int\n                        IsFromDefinition: bool\n                        IsFromAttribute : bool\n                        IsFromComputationExpression : bool\n                        IsFromDispatchSlotImplementation : bool\n                        IsFromPattern : bool\n                        IsFromType : bool\n                      }\n                    type SymbolUseResponse =\n                      {\n                        Name: string\n                        Uses: SymbolUseRange list\n                      }\n                    type HelpTextResponse =\n                      {\n                        Name: string\n                        Overloads: OverloadDescription list list\n                      }\n                    type CompilerLocationResponse =\n                      {\n                        Fsc: string\n                        Fsi: string\n                        MSBuild: string\n                      }\n                    type FSharpErrorInfo =\n                      {\n                        FileName    : string\n                        StartLine   : int\n                        EndLine     : int\n                        StartColumn : int\n                        EndColumn   : int\n                        Severity    : string\n                        Message     : string\n                        Subcategory : string\n                      }\n                    type ErrorResponse =\n                      {\n                        File: string\n                        Errors: FSharpErrorInfo []\n                      }\n                    type Colorization =\n                      {\n                    //    Range: Range\n                        Kind: string\n                      }\n                    type Declaration =\n                      {\n                        UniqueName: string\n                        Name: string\n                        Glyph: string\n                        GlyphChar: string\n                        IsTopLevel: bool\n                    //  Range     : Utils.Range\n                    //    BodyRange : Utils.Range\n                        File : string\n                        EnclosingEntity: string\n                        IsAbstract: bool\n                      }\n                    type DeclarationResponse = {\n                        Declaration : Declaration;\n                        Nested : Declaration []\n                    }\n                    type OpenNamespace = {\n                      Namespace : string\n                      Name : string\n                      Type : string\n                      Line : int\n                      Column : int\n                      MultipleNames : bool\n                    }\n                    type QualifySymbol = {\n                      Name : string\n                      Qualifier : string\n                    }\n                    type ResolveNamespaceResponse = {\n                      Opens : OpenNamespace []\n                      Qualifies: QualifySymbol []\n                      Word : string\n                    }\n                    type UnionCaseResponse = {\n                      Text : string\n                    //  Position : Pos\n                    }\n                    type Kind = \n                    | KInfo             of string\n                    | KError            of ResponseError\n                    | KHelpText         of HelpTextResponse\n                    | KCompletion       of CompletionResponse  []\n                    | KSymbolUse        of SymbolUseResponse\n                    | KHelp             of string\n                    | KMethod           of MethodResponse\n                    | KErrors           of ErrorResponse\n                    | KColorizations    of Colorization list\n                    | KFindDecl         of Location\n                    | KDeclarations     of DeclarationResponse []\n                    | KToolTip          of OverloadDescription [][]\n                    | KTypeSig          of string\n                    | KSignatureData    of SignatureData\n                    | KCompilerLocation of CompilerLocationResponse\n                    | KNamespaces       of ResolveNamespaceResponse\n                    | KUnionCase        of UnionCaseResponse\n                    | KMultiple         of Kind                []\n                    \n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n                \n                open System.Net\n                open System.Text\n                open System.IO\n                open FSharp.Data\n                open FSharp.Data.JsonExtensions\n                open Newtonsoft.Json\n                \n                open Utils\n                \n                [<JavaScript ; AutoOpen >]\n                module MsgTypes =\n                \n                    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n                    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n                    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n                    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n                    type ProjectRequest       = { FileName  : string                                                                                                               }\n                    type LintRequest          = { FileName  : string                                                                                                               }\n                    type HelptextRequest      = { Symbol    : string                                                                                                               }\n                    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n                \n                    type FARequest =\n                        | FarParse         of ParseRequest         \n                        | FarDeclarations  of DeclarationsRequest  \n                        | FarCompletion    of CompletionRequest    \n                        | FarPosition      of PositionRequest      \n                        | FarProject       of ProjectRequest       \n                        | FarLint          of LintRequest          \n                        | FarHelptext      of HelptextRequest      \n                        | FarWorkspacePeek of WorkspacePeekRequest    \n                \n                let toJson =\n                    function\n                    | FarParse         data -> JsonConvert.SerializeObject data \n                    | FarDeclarations  data -> JsonConvert.SerializeObject data \n                    | FarCompletion    data -> JsonConvert.SerializeObject data \n                    | FarPosition      data -> JsonConvert.SerializeObject data \n                    | FarProject       data -> JsonConvert.SerializeObject data \n                    | FarLint          data -> JsonConvert.SerializeObject data \n                    | FarHelptext      data -> JsonConvert.SerializeObject data \n                    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n                \n                let fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\n                let jsonData2Obj item = item?Data.ToString() |> fromJson\n                \n                let HttpRequestCall (url:string) (data:string) =\n                    async {\n                        //printfn \"RpcCall %s\" (extract 100 data)\n                        let req = WebRequest.Create(url) :?> HttpWebRequest \n                        req.Timeout         <- 300_000\n                        req.ProtocolVersion <- HttpVersion.Version10\n                        req.Method          <- \"POST\"\n                        req.ContentType     <- \"application/json\"\n                        let postBytes = Encoding.ASCII.GetBytes(data)\n                        //printfn \"<---\\n%s\\n\" data\n                        req.ContentLength <- int64 postBytes.Length\n                        let reqStream = req.GetRequestStream() \n                        reqStream.Write(postBytes, 0, postBytes.Length);\n                        reqStream.Close()\n                        use resp   = req.GetResponse() \n                        use stream = resp.GetResponseStream() \n                        use reader = new StreamReader(stream)\n                        let msg    = reader.ReadToEnd()\n                        //print msg\n                        //printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n                        let jsonV  = JsonValue.Parse msg\n                        return       jsonV\n                    }\n                \n                let KindError msg = KError { Code = 0 ; Message = msg }\n                \n                let json2Kind (v:JsonValue) = \n                    let item =JsonValue.Parse <| v.AsString()\n                    match item?Kind.AsString() with\n                    | \"info\"             -> jsonData2Obj item |> KInfo\n                    | \"error\"            -> jsonData2Obj item |> KError\n                    | \"errors\"           -> jsonData2Obj item |> KErrors\n                    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n                    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n                    | \"completion\"       -> jsonData2Obj item |> KCompletion\n                    | \"signature\"        -> jsonData2Obj item |> KTypeSig\n                    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n                    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n                    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n                    | \"helptext\"         -> jsonData2Obj item |> KHelpText\n                    | \"declarations\"     -> jsonData2Obj item |> KDeclarations\n                    | \"symboluse\"        -> jsonData2Obj item |> KSymbolUse\n                    | _                  -> KindError <| v.ToString()\n                \n                let UrlAddress = \"http://localhost:9001/\"\n                \n                [< Rpc >]\n                let FSAutocompleteCall0 cmd (req: FARequest) : Async<Result<Kind [],ResultMessage<Kind[]>>> = asyncResult {\n                        let  data          = req |> toJson\n                        let! jsonV         = HttpRequestCall (UrlAddress + cmd) data\n                        return               jsonV.AsArray() |> Array.map json2Kind\n                    } \n                \n                [<JavaScript ; AutoOpen>]\n                module Calls =\n                    let FSAutocompleteCall cmd f req = asyncResult {\n                            let! several       = FSAutocompleteCall0 cmd req\n                            let  goods, others = several |> Array.partition (f >> Option.isSome)\n                            let! good          = goods   |> Seq.choose f |> Seq.tryHead |> Result.ofOption (fun () -> others |> Message)\n                            return               good, others\n                        } \n                    \n                    let parseCode        file code asy ver   = FSAutocompleteCall \"parse\"               (function KErrors        v -> Some v |_-> None)\n                                                                     <| FarParse       { FileName        = file\n                                                                                         IsAsync         = asy   \n                                                                                         Lines           = code           \n                                                                                         Version         = ver\n                                                                                       }\n                    let toolTip          file lin col filter = FSAutocompleteCall \"tooltip\"             (function KToolTip       v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signature        file lin col filter = FSAutocompleteCall \"signature\"           (function KTypeSig v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signatureData    file lin col filter = FSAutocompleteCall \"signatureData\"       (function KSignatureData v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let completion  tx kw file ln col filter = FSAutocompleteCall \"completion\"          (function KCompletion    v -> Some v |_-> None)\n                                                                      <| FarCompletion { FileName        = file\n                                                                                         Line            = ln         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                         SourceLine      = tx\n                                                                                         IncludeKeywords = kw\n                                                                                        }\n                    \n                    let findTypeDecl     file lin col filter = FSAutocompleteCall \"findtypedeclaration\" (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let findDeclaration  file lin col filter = FSAutocompleteCall \"finddeclaration\"     (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let declarations    file code ver        = FSAutocompleteCall \"declarations\"       (function KDeclarations v -> Some v |_-> None)\n                                                                      <| FarDeclarations{ FileName       = file\n                                                                                          Lines          = code         \n                                                                                          Version        = ver\n                                                                                        }\n                    let helpText               symbol        = FSAutocompleteCall \"helptext\"            (function KHelpText     v -> Some v |_-> None)\n                                                                      <| FarHelptext    { Symbol         = symbol\n                                                                                        }\n                    let symbolUse       file lin col filter  = FSAutocompleteCall \"symboluse\"           (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let symbolUseProject file lin col filter = FSAutocompleteCall \"symboluseproject\"    (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    \n                    \n    \n    //#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FSharpStation\\src\"\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    \n    //#define WEBSHARPER\n    [< JavaScript >]\n    module FSharpStation =\n        //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        module FStation =\n        \n            let [< Rpc >] getRootDirs() = async {\n                //let res = let dir = System.Environment.CurrentDirectory\n                          //if dir.EndsWith @\"\\bin\" |> not then dir else\n                          //dir.[0..dir.Length - 5] |>! fun set -> System.Environment.CurrentDirectory <- set\n                let dir = System.Environment.CurrentDirectory\n                return dir, System.IO.Path.GetFullPath(dir +/+ \"..\"     ), System.IO.Path.GetFullPath(dir +/+ \"..\\\\src\")\n            }\n        \n            [< Inline \"(Date.now())\" >]\n            let now() = 0\n            let id = \"FSharpStation\" + (now() |> string)\n        \n            let mutable rootDir  = \".\"\n            let mutable srcDir   = \".\"\n            async {\n                let! dir, root, src = getRootDirs()\n                rootDir   <- root\n                srcDir    <- src\n                printfn \"fileName = %s\\\\%s.fsx\" srcDir id\n            } |> Async.Start\n            \n            let annotationsV = Var.Create \"\"\n            let outputMsgs   = Var.Create \"\"\n        \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText outputMsgs msg\n        \n        \n        module Snippets =\n            open TreeReader\n            open FusionM\n            open Operators\n            \n            let private snippets               = ListModel<SnippetId, Snippet> (fun s -> s.snpId)\n            let private hierarchy              = Var.Create [||]\n            let private generation             = Var.Create System.DateTime.MinValue\n            let         currentSnippetIdOV     = Var.Create (None:SnippetId option)\n            let private codeSnippetIdOV        = Var.Create (None:SnippetId option)\n            let private collapsedV             = Var.Create Set.empty\n            \n            let predsCache , clearPreds        = Memoize.getStore()\n            let reducCache , clearReduc        = Memoize.getStore()\n            let parentCache, clearParent       = Memoize.getStore()\n            let clearPredsCache ()             = clearPreds ()\n                                                 clearReduc ()\n                                                 clearParent()\n            let prepAnyCode       (cod:string) = cod.Replace(\"##\" + \"FSHARPSTATION_ID\"       + \"##\", FStation.id            )\n                                                    .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href)\n                                                    .Replace(\"##\" + \"FSHOME\"                 + \"##\" , FStation.rootDir)\n            let prepCode                   snp = prepAnyCode snp.snpContent                                         \n            let snippetsColl                () = { generation       = generation.Value\n                                                   ordered          = Seq.delay(fun () -> snippets.Value)\n                                                   fetcher          = snippets.TryFindByKey\n                                                   predecesorsCache = fun _ -> predsCache\n                                                   reducedCache     = fun _ -> reducCache\n                                                   prepCode         = prepCode\n                                                   }\n            let handleError                 er = (er:ResultMessage<string>) |> string |> exn |> raise\n            let iterReader                  rm = rm |> iterReader  handleError id (snippetsColl())\n            let runReaderResult             rm = rm |> runReader                  (snippetsColl()) |> Result.map fst\n            let runReader            handle rm = rm |> runReaderResult |> Result.defaultWith handle\n               \n            let expandParents            snpId = Snippet.pathRm snpId \n                                                 |>> (fun path -> collapsedV.Value - Set path |> collapsedV.Set)\n                                                 |> iterReader\n            \n            let setCurrentSnippetIdO snpIdO    = snpIdO |> Option.iter expandParents \n                                                 currentSnippetIdOV.Set snpIdO\n            let setSnippet                 snp = if snp.snpId.Id <> System.Guid.Empty then snippets.Add { snp with snpModified = System.DateTime.Now }\n            let getSnippetsGen              () = snippets.Value, generation.Value, collapsedV.Value\n        \n            let getParentIdONotMemo      snpId = snippets.TryFindByKey snpId |> Option.bind(fun s -> s.snpParentIdO)\n            let getParentIdO                   = getParentIdONotMemo |> Memoize.memoizeStore (snd parentCache) \n            let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                                 getParentIdO snpId\n                                                 |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                                 |> Option.defaultValue false\n        \n            if IsClient then\n                currentSnippetIdOV.View |> View.Sink (\n                    function\n                    | None       -> ()\n                    | Some curId ->\n                    match codeSnippetIdOV.Value with\n                    | None       -> codeSnippetIdOV.Set (Some curId)\n                    | Some codId ->\n                    codId\n                    |>  Snippet.snippetORm\n                    |>> Option.map Snippet.uniquePredsRm \n                    >>= insertO\n                    |>> Option.toList\n                    |>> List.collect  id\n                    |>> List.contains curId\n                    |>> function false -> codeSnippetIdOV.Set (Some curId) |_->()\n                    |>  iterReader\n                    clearPredsCache()\n                )\n        \n            if IsClient then\n                hierarchy.View |> View.Map (Array.map (fun n -> n.id()) ) |> View.consistent |> View.Sink (fun ids ->\n                    clearPredsCache()\n                    [| for sid in ids do\n                        yield  snippets.FindByKey sid\n                        yield! snippets.Value |> Seq.filter(fun snp -> isDescendantOf sid snp.snpId)\n                    |]\n                    |> snippets.Set\n                )\n        \n            let CurrentSnippetIdW              = currentSnippetIdOV.View |> View.Map (fun sidO -> sidO |> Option.defaultValue Snippet.defaultSnippet.snpId)\n            let currentSnippetW                = currentSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let    codeSnippetW                =    codeSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let currentSnippetV                = Var.Make currentSnippetW setSnippet\n            let selectedClassW           snpId = V (if Some snpId = currentSnippetIdOV.V then \"selected\"    else \"\")\n            let codeSnippetClassW        snpId = V (if Some snpId =    codeSnippetIdOV.V then \"codeSnippet\" else \"\")\n            let findSnippetW             snpId = snippets.TryFindByKeyAsView snpId |> View.Map (Option.defaultValue Snippet.defaultSnippet)\n            let findSnippetV             snpId = Var.Make (findSnippetW snpId) setSnippet\n            let getHierarchyW                  = hierarchy.View \n                                                 |> View.Map2(fun _ -> TreeReader.listNodes 0 >> runReader  handleError) collapsedV.View\n                                                 |> View.Map (Seq.map (fun (tn,l) -> tn.id(), l) ) \n                                                 |> View.Map  Seq.toArray\n            //let codeAndStartsRm            snp =  >>= Snippet.codeAndStartsRm \n            let codeAndStartsW                 = (codeSnippetW, snippets.View) \n                                                 ||> View.MapAsync2 (fun _ _ -> async {\n                                                    do! Async.Sleep 350\n                                                    return\n                                                       Snippet.fastCodeRm currentSnippetIdOV.Value codeSnippetIdOV.Value\n                                                       |> runReader handleError\n                                                 }) \n            let FsCodeW                        = codeAndStartsW |> View.Map fst\n            let codeStartsW                    = codeAndStartsW |> View.Map snd\n            let hasChangedW                snp = V (generation.V < snp.snpModified )\n            let SaveAsClassW                   = View.Map2 (fun snps gen -> if Seq.exists (fun snp -> snp.snpModified > gen) snps then \"btn-primary\" else \"\") \n                                                    snippets  .View \n                                                    generation.View\n            let currentPathW                   = currentSnippetW\n                                                 |> View.Map (fun snp -> \n                                                        fusion { \n                                                            let! path  = Snippet.pathRm snp.snpId\n                                                            let! names = snp.snpId :: path |> traverseSeq Snippet.snippetNameRm\n                                                            return names |> Seq.rev |> String.concat \"/\"\n                                                        } |> runReader (fun _ -> \"\") )\n        \n            let currentLayoutDW                =  \n                currentSnippetW\n                |> View.Map (fun snp -> \n                    fusion {\n                        let! btnsO = Snippet.propertyHierORm \"Buttons\" snp\n                                        |>> Option.map(fun(snB, (txB, _)) ->\n                                        let ls, ats = txB.Trim().Split('\\n')\n                                                      |> fun ls ->  if ls.[0].StartsWith \"\\\"\"\n                                                                    then ls.[1..], ls.[0] \n                                                                    else ls      , \"\\\"\\\"\"\n                                        let ss      = ls\n                                                      |> Seq.filter(fun s -> s.Trim() <> \"\")\n                                                      |> Seq.mapi (fun i btn -> \n                                                            if btn.StartsWith \":\" \n                                                            then btn.[1..]\n                                                            else sprintf \"button \\\"click=@{FSharpStation.ButtonClick}\\\" %A\" btn\n                                                            |> sprintf \"btn%d %s\" i\n                                                        )\n                                        \"Snp_\" + (string snB.snpId.Id).Replace(\"-\", \"\")\n                                        , [ yield \"editorButtons vertical 0-85-100 FStationLyt.menuEditor buttons\"\n                                            yield! ss\n                                            yield [ 0.. Seq.length ss - 1 ] \n                                                    |> Seq.map (sprintf \"btn%d\") \n                                                    |> String.concat \" \" \n                                                    |> sprintf \"buttons div %s %s \" ats\n                                        ] |> String.concat \"\\n\"\n                                    )\n                        return!      Snippet.propertyHierORm \"Layout\"  snp \n                                        |>> Option.map (fun (snL, (txL, _)) ->\n                                        \"Snp_\" + (string snL.snpId.Id).Replace(\"-\", \"\")\n                                        , btnsO |> Option.map (fun (snB, lyB) -> \n                                            [ txL ; lyB ] |> String.concat \"\\n\")\n                                        |> Option.defaultValue txL)\n                                        |>> Option.bindNone (fun () -> btnsO)\n                    } |> runReader (fun _ -> None)\n                ) \n            let currentLayoutJSDW                =  \n                currentSnippetW\n                |> View.Map (fun snp -> \n                    Snippet.propertyHierORm \"LayoutJS\"  snp \n                    |>> Option.map (fun (snL, (txL, _)) -> snL.snpId, txL)\n                    |> runReader (fun _ -> None)\n                )\n                                                    \n            let setChildrenRm snpId ch = fusion {\n                let chIds = ch |> Array.map (fun s -> s.id())\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n                |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n                |> Seq.iter    setSnippet\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n                |> Seq.map    (fun s -> { s with snpParentIdO = None })\n                |> Seq.iter    setSnippet\n                clearPredsCache()\n                let descendants, others = snippets.Value |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n                let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n                [| yield! others.[0..index]\n                   for chid in chIds do\n                       yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n                       yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n                   yield! others.[index+1..]\n                |]\n                |> snippets.Set\n            }\n        \n            let rec treenode (snpId:SnippetId) =\n                {\n                    id                 = fun () -> snpId\n                    isExpandedRm       = fun () -> rtn (not <| Set.contains snpId collapsedV.Value)\n                    canHaveChildrenRm  = fun () -> rtn true\n                    childrenRm         = fun () -> Snippet.childrenRm snpId |>> Seq.map (fun snp -> treenode snp.snpId)\n                    newChildrenRm      = fun ch -> setChildrenRm snpId ch   |>> fun () -> \n                                                   treenode      snpId\n                    parentORm          = fun _ns-> Snippet.snippetORm snpId |>> Option.bind (fun x -> x.snpParentIdO) |>> Option.map treenode\n                    pathRm             = fun () -> Snippet.pathRm snpId\n                }\n                \n            let isIndirectPredecessorW snpId = \n                currentSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let isIncludedPredecessorW snpId = \n                codeSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let togglePredecessor predId =\n                let preds = Lens currentSnippetV.V.snpPredIds\n                preds.Value\n                |> (if Set.contains predId preds.Value then Set.remove else Set.add) predId\n                |> preds.Set\n                clearPredsCache()\n                \n            let expandClassRm snpId =\n                Snippet.childrenRm snpId        >>= fun chs -> \n                if Seq.isEmpty chs then rtn \"\" else\n                (treenode snpId).isExpandedRm() |>> fun exp -> \n                if exp then \"expanded\" else \"collapsed\"\n            \n            let expandClassW snpId = snippets.View |> View.Map2 (fun _ _ -> expandClassRm snpId |> runReader handleError) collapsedV.View\n            \n            let deleteCurrentSnippet _ =\n                currentSnippetIdOV.Value\n                |> Option.iter (fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.removeNodeOutdentChildren (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>> fun () -> snippets.RemoveByKey snpId\n                    |>  iterReader\n                )\n                \n            let indentIn _ =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.indentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let indentOut _ =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.outdentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let moveNode fnid tnid =\n                hierarchy.Value\n                |>  TreeReader.moveToSibling2 false fnid tnid\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let updateGeneration() =\n                fusion {\n                    let! max = Snippet.maxGenerationRm()\n                    generation.Set max\n                } |> iterReader\n        \n            let setSnippetsGen snps coll =\n                collapsedV.Set coll\n                snippets  .Set snps\n                updateGeneration()\n                snps \n                |>  Seq.map(fun snp -> Snippet.parentORm snp |>> function None -> Some snp |_-> None )\n                |>  sequenceSeq\n                |>> Seq.choose id\n                |>> Seq.map (fun snp -> treenode snp.snpId)\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let addSnippetRm snp = \n                snippets.Add snp\n                let hier = hierarchy.Value |> Seq.append [| treenode snp.snpId |]\n                currentSnippetIdOV.Value\n                |>  Option.map Snippet.snippetORm |> insertO |>> Option.bind id\n                >>= function\n                | None     -> hier |> rtn\n                | Some sbl -> hier |> TreeReader.moveToSibling2 true snp.snpId sbl.snpId\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                \n            let newSnippet _ =\n                let snp = Snippet.New \"\" \"\" None\n                addSnippetRm snp\n                |>> fun () -> currentSnippetIdOV.Set (Some snp.snpId)\n                |>  iterReader\n                \n            let toggleCollapse snpId =\n                if Set.contains snpId collapsedV.Value then Set.remove else Set.add\n                <| snpId\n                <| collapsedV.Value\n                |> collapsedV.Set\n        \n            let setProperty snp prop v =\n                if Seq.contains (prop, v) snp.snpProperties then () else\n                { snp with snpProperties =  snp.snpProperties\n                                            |> Seq.filter(fst >> (<>) prop)\n                                            |> Seq.append <| [ prop, v ]\n                                            |> Seq.toArray\n                }\n                |> setSnippet\n        module DragDrop =\n        \n            type DragInfo = \n                | DragNone\n                | DragNode of SnippetId\n            \n            let mutable drag        = DragNone\n            let setDragNone ()      = drag <- DragNone\n            let setDragNode tnid    = drag <- DragNode tnid\n            \n            let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n            \n            let [< Inline >] inline moveItem dropId elems getId item =\n                elems\n                |> Seq.filter (getId >> ((<>) (getId item)) )\n                |> Seq.toArray\n                |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                             [fst ; [| item |] ; snd])\n                |> Seq.collect id\n                |> Seq.toArray\n            \n            let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n            let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n            \n            let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n            \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n        \n        module RenderSnippets =\n            open Snippets\n            \n            let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then try e?scrollIntoViewIfNeeded() with e -> printfn \"%A\" e) \n            \n            let snippets () = \n                Snippets.getHierarchyW\n                |> Doc.BindSeqCached (fun (snpId, l) ->\n                    let snpW     = findSnippetW snpId\n                    let nameW    = View.Do {\n                                        let! snp     = snpW\n                                        let! changed = Snippets.hasChangedW snp\n                                        let  name    = Snippet.snippetName snp.snpName snp.snpContent\n                                        return (if changed then \"*\" else \"\") + name\n                                    }\n                    //let pathW = V( Snippets.getHierarchyW |> (fun _ -> (Snippets.treenode snpId).path () |> Seq.map (fun n -> string n.Id) |> String.concat \" - \") )\n                    let predW    = V(if currentSnippetV.V.snpPredIds |> Set.contains snpId then \"direct-predecessor\"   else\n                                     if (isIndirectPredecessorW snpId).V                   then \"indirect-predecessor\" else \n                                     if (isIncludedPredecessorW  snpId).V                  then \"included-predecessor\" else \"\" )\n                    let errorW   = FStation.annotationsV.View |> View.Map (String.contains <| snpId.Id.ToString() >> function true -> \"ErrorMsg\" |_-> \"\" )\n                    TemplateLib.Snippet()\n                        .Name(          nameW                                                                                        )\n                        .Indent(        string l                                                                                     )\n                        .Parent(        expandClassW snpId                                                                           )\n                        .Predecessor(   predW                                                                                        )\n                        .Selected(    [ (selectedClassW snpId).V ; (codeSnippetClassW snpId).V ] |> String.concat \" \"                )\n                        .ErrorMsg(      errorW                                                                                       )\n                        .Select(        fun _  -> setCurrentSnippetIdO <| Some snpId                                                 )\n                        .AfterRender(   scrollIntoView <| View.Map ((<>) \"\") (Snippets.selectedClassW snpId)                         )\n                        .TogglePred(    fun ev -> togglePredecessor snpId                                                            )\n                        .ToggleCollapse(fun ev -> Snippets.toggleCollapse snpId                                                      )\n                        .Drag(          fun ev ->     DragDrop.setDragNode snpId            ; ev.Event.StopPropagation()             )\n                        .DragOver(      fun ev -> if (DragDrop.getDragNIdO snpId).IsSome then ev.Event.PreventDefault ()             )\n                        .Drop(          fun ev -> do                                          ev.Event.PreventDefault () \n                                                  DragDrop.getDragNIdO snpId |> Option.iter(fun fr -> moveNode fr snpId)             )\n                      .Doc()\n                )\n            \n            let render() = TemplateLib.SnippetList().Snippets( snippets() ).Doc()\n        module RenderProperties =\n            open Snippets\n            \n            let addProperty () = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties \n                                                                                                       [| \"\",\"\" |]                                              }\n            let remProperty i = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties.[0  .. i-1] \n                                                                                                       Snippets.currentSnippetV.Value.snpProperties.[i+1..    ] }\n            let properties() =\n                let propsV = Lens Snippets.currentSnippetV.V.snpProperties\n                let setName  i newName = propsV.Value.[i] <- (newName, snd propsV.Value.[i]) \n                                         propsV.Value |> propsV.Set\n                let setValue i newVal  = if (snd propsV.Value.[i]).Length > 1000 then () else\n                                         propsV.Value.[i] <- (fst propsV.Value.[i], newVal) \n                                         propsV.Value |> propsV.Set\n                V([| 0.. propsV.V.Length - 1|])\n                |> Doc.BindSeqCached (fun i ->\n                    let nameV  = Var.Make <| V( fst propsV.V.[i])\n                                          <| setName  i\n                    let valueV = Var.Make <| V( let v = snd propsV.V.[i]\n                                                if v.Length > 1000 then sprintf \"%s...<%d chars>\" v.[0..100] v.Length else v)\n                                          <| setValue i\n                    TemplateLib.Property()\n                        .Name(   nameV                   )\n                        .Value(  valueV                  )\n                        .Remove( fun ev -> remProperty i )\n                      .Doc()\n                )\n        \n            let render() = \n                TemplateLib.PropertyTable()\n                    .Properties(  properties()           )\n                    .AddProperty( fun _ -> addProperty() )\n                    .Doc()    \n        [< JavaScript false >]\n        module Markdown =\n            open System.Text.RegularExpressions\n        \n            let private stringReplacePatterns =\n                [ \"&lt;\"      , \"<\"\n                  \"&gt;\"      , \">\"\n                  \"&quot;\"    , \"\\\"\"\n                  \"&apos;\"    , \"'\"\n                  \"&amp;\"     , \"&\"\n                  \"<summary>\" , \"**Description**\\n\\n\"\n                  \"</summary>\", \"\\n\"\n                  \"<para>\"    , \"\\n\"\n                  \"</para>\"   , \"\\n\"\n                  \"<remarks>\" , \"\"\n                  \"</remarks>\", \"\\n\" ]\n            let private regexReplacePatterns =\n                let r               pat = Regex(pat, RegexOptions.Compiled ||| RegexOptions.IgnoreCase)\n                let unquote  (s:string) = s.Substring(1, s.Length - 2)\n                let returns     strings = Array.item 0 strings |>                     sprintf \"\\n**Returns**\\n\\n%s\"\n                let param       strings = Array.item 0 strings |> unquote |> fun s -> sprintf \"* `%s`: %s\" s strings.[1]\n                let link        strings = Array.item 0 strings |> unquote\n                let code        strings = Array.item 0 strings |> fun s -> if String.contains \"\\n\" s then \"```forceNoHighlight\" + s + \"```\" else \"`\" + s + \"`\"\n                [ r \"<c>((?:(?!<c>)(?!<\\/c>)[\\s\\S])*)<\\/c>\"                                              , code\n                  r \"\"\"<see\\s+cref=(?:'[^']*'|\"[^\"]*\")>((?:(?!<\\/see>)[\\s\\S])*)<\\/see>\"\"\"                , code\n                  r \"\"\"<param\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/param>)[\\s\\S])*)<\\/param>\"\"\"            , param\n                  r \"\"\"<typeparam\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/typeparam>)[\\s\\S])*)<\\/typeparam>\"\"\", param\n                  r \"\"\"<exception\\s+cref=('[^']*'|\"[^\"]*\")>((?:(?!<\\/exception>)[\\s\\S])*)<\\/exception>\"\"\", param\n                  r \"\"\"<a\\s+href=('[^']*'|\"[^\"]*\")>((?:(?!<\\/a>)[\\s\\S])*)<\\/a>\"\"\"                        , link\n                  r \"\"\"<returns>((?:(?!<\\/returns>)[\\s\\S])*)<\\/returns>\"\"\"                               , returns\n                ] // \"\n        \n            /// Helpers to create a new section in the markdown comment\n            let private suffixXmlKey (tag : string) (value : string) (str : string) = \n                match str.IndexOf(tag) with\n                | x when x <> -1 -> let insertAt = if str.Chars(x - 1) = ' ' \n                                                   then x - 1\n                                                   else x\n                                    str.[0..insertAt] + value + str.[insertAt + 1..]\n                | _              -> str\n        \n            let private suffixTypeparam = suffixXmlKey \"<typeparam\" \"\\n**Type parameters**\\n\\n\"\n            let private suffixException = suffixXmlKey \"<exception\" \"\\n**Exceptions**\\n\\n\"\n            let private suffixParam = suffixXmlKey \"<param\" \"\\n**Parameters**\\n\\n\"\n        \n            /// Replaces XML tags with Markdown equivalents.\n            /// List of standard tags: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/xml-documentation\n            let private replaceXml (str: string) : string =\n                let str =\n                    str\n                    |> suffixTypeparam\n                    |> suffixException\n                    |> suffixParam\n        \n                let res = regexReplacePatterns\n                          |> List.fold (fun res (regex: Regex, formatter: string[] -> string) ->\n                              // repeat replacing with same pattern to handle nested tags, like `<c>..<c>..</c>..</c>`\n                              let rec loop res : string =\n                                  match regex.Match res with\n                                  | m when m.Success -> m.Groups\n                                                        |> Seq.cast<Group>\n                                                        |> Seq.map (fun g -> g.Value)\n                                                        |> Seq.toArray\n                                                        |> Array.splitAt 1\n                                                        |> function \n                                                           | [| firstGroup |], otherGroups -> loop <| res.Replace(firstGroup, formatter otherGroups)\n                                                           |                              _-> res\n                                  |                                                       _-> res\n                              loop res\n                          ) str\n                stringReplacePatterns\n                |> List.fold (fun (res: string) (oldValue, newValue) ->\n                    res.Replace(oldValue, newValue)\n                ) res\n        \n            [< Rpc >]\n            let createCommentBlock (comment: string) = async {\n                return\n                    comment\n                    |> replaceXml\n            }\n        module Monaco =\n            open WebSharper.UI\n            open WebSharper.UI.Html\n            open FsAutoComplete\n            open Monaco\n            \n            let startsV  = Var.Create [||]\n            \n            let defaultStart = Option.defaultValue((SnippetId.Empty, \"\"), (0, 1, 0))\n            let getIndentAndFirst () =\n                let currId = Snippets.currentSnippetV.Value.snpId\n                let _, (indent, first, _) = startsV.Value |> Seq.tryFind (fst >> fst >> (=) currId) |> defaultStart\n                indent, first\n        \n            let getSnipIdIndentAndFirst line =\n                let (snpId, _), (indent, first, _) = startsV.Value |> Seq.tryFind (fun (_, (_, first, last)) -> line >= first && line <= last) |> defaultStart\n                snpId, indent, first\n        \n            let getModelUri txt uri =\n                let model = Editor.GetModel uri \n                            |> fun model -> if isUndefined model then None else Some model\n                            |> Option.defaultWith (fun () -> Editor.CreateModel(\"\", \"fsharp\", uri) )\n                if model.GetValue() <> txt then\n                    model.SetValue txt\n                model\n        \n            let getSnippetModel (sid:SnippetId) =\n                Uri.Parse(\"snpId:\" + sid.Id.ToString())\n                |> getModelUri (Snippet.snippetRm sid |> Snippets.runReader (string >> failwith)).snpContent\n        \n            let fixMarkDown v =\n                v\n                |> String.splitByChar '\\n'\n                |> Seq.map (fun l -> l.Replace(\"\\t\", \"- \"))\n                |> Seq.map (fun l -> let i = l |> Seq.takeWhile ((=) ' ') |> Seq.length\n                                     String.replicate i \"&nbsp;\" + l.[i..] )\n                |> String.concat \"\\n\\n\"\n                \n            let overDescriptions descs =\n                descs \n                |> Seq.collect id \n                |> Seq.collect (fun (d:CommTypes.OverloadDescription) ->\n                    [ if d.Signature |> isUndefined |> not then yield \"```\\n\" + d.Signature + \"\\n```\" |> Async.rtn\n                      if d.Comment   |> isUndefined |> not then yield Markdown.createCommentBlock d.Comment |> Async.map fixMarkDown\n                      if d.Footer    |> isUndefined |> not then yield d.Footer |> fixMarkDown |> Async.rtn] )\n                |> Async.sequenceSeq\n            \n            let mutable fileName = \"none.fsx\"\n        \n            type HoverProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideHover(model:Model, pos:Position, token:obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! descs, other = toolTip fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let! desc = overDescriptions descs \n                      return\n                          {\n                              contents = desc |> Seq.map (fun d -> { value = d |>! print ; isTrusted = true }) |> Seq.toArray\n                              range    = (box null |> unbox)\n                          }\n                    } |> Promise.ofAsyncResult\n        \n            let convertGlyphChar =\n                function\n                | \"C\" -> CompletionItemKind.Class\n                | \"E\" -> CompletionItemKind.Enum\n                | \"S\" -> CompletionItemKind.Value\n                | \"I\" -> CompletionItemKind.Interface\n                | \"N\" -> CompletionItemKind.Module\n                | \"M\" -> CompletionItemKind.Method\n                | \"P\" -> CompletionItemKind.Property\n                | \"F\" -> CompletionItemKind.Field\n                | \"T\" -> CompletionItemKind.Class\n                | \"K\" -> CompletionItemKind.Keyword\n                | _   -> 0 |> unbox\n        \n            type CompletionItemProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let txt = String.replicate indent \" \" + model.GetLineContent(pos.lineNumber)\n                      let! comps, other = completion txt true fileName (pos.lineNumber + first) (pos.column + indent) \"Contains\"\n                      return comps \n                             |> Array.map(fun (comp:CommTypes.CompletionResponse) -> \n                                 { kind   = convertGlyphChar comp.GlyphChar\n                                   label  = comp.Name\n                                   detail = \"\"\n                                 } )\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n                  member __.resolveCompletionItem(item: CompletionItem, token: obj) =\n                    asyncResult {\n                      let! comp, other = helpText item.label\n                      let  desc =  (comp:CommTypes.HelpTextResponse).Overloads \n                                   |> Seq.collect id\n                                   |> Seq.collect (fun d -> \n                                         [ if d.Signature |> isUndefined |> not then yield d.Signature\n                                           if d.Comment   |> isUndefined |> not then yield d.Comment\n                                           if d.Footer    |> isUndefined |> not then yield d.Footer ]\n                                   )\n                                   |> String.concat \"\\n\" \n                      return  { item with detail = desc}\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            type DefinitionProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideDefinition(model: Model, pos: Position, token: obj): Promise<Location> =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! decl, others = findDeclaration fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let  decl : CommTypes.Location = decl\n                      let snpId, indent2, first2 = getSnipIdIndentAndFirst decl.Line\n                      let uri           = Monaco.Uri.Parse <| \"snpId:\" + snpId.Id.ToString()\n                      getSnippetModel snpId |> ignore\n                      return \n                          { range = { startColumn     = decl.Column - indent2\n                                      endColumn       = decl.Column - indent2\n                                      startLineNumber = decl.Line   - first2\n                                      endLineNumber   = decl.Line   - first2\n                                    }\n                            uri   = uri\n                          }\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            let transformAnnotations snp msgs =\n                let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*\\(\"\"\" + rexGuid + \"\"\"\\) \"([^\"]+?)\"\\.\"\"\" //\"\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex \"\" [| _; ty;     fl;     fc;     tl;     tc; guid; msg |] \n                                -> Some (ty, int fl, int fc, int tl, int tc, guid, msg)\n                    | _      -> None\n                )\n                |> Array.choose (fun (ty, fl, fc, tl, tc, guid, msg) ->\n                    if ParseO.parseGuidO guid |> Option.map SnippetId <> Some snp.snpId then None else\n                        Some {  message  = msg\n                                severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                                startColumn     = fc\n                                endColumn       = tc\n                                startLineNumber = fl\n                                endLineNumber   = tl\n                        }\n                  )        \n                    \n            type MonacoOptions  = {\n                fontSize   : int\n                lineHeight : int\n            }\n            \n            let gotoEditor (ed:Editor) codeId line col = async {\n                Snippets.setCurrentSnippetIdO <| Some codeId\n                do! Async.Sleep 200\n                ed.Focus()\n                ed.SetPosition            { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n                ed?revealPositionInCenter { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n            }\n        \n            let openCodeEditor (input:obj, ed:Editor, sideBySide) =\n                async {\n                    match input?resource?path with\n                    | ParseO.Guid guid -> \n                         do! gotoEditor ed (SnippetId guid) input?options?selection?startLineNumber input?options?selection?startColumn\n                         return  ed  \n                    |_-> return (null |> unbox<Editor>)\n                } |> Promise.OfAsync\n        \n            [< Inline \"var m = require('vs/editor/standalone/browser/standaloneServices');\n                       var n = new m.StaticServices.codeEditorService._factory();\n                       n.openCodeEditor = FsRoot.FSharpStation.Monaco.openCodeEditor;\n                       return n;\" >]\n            let getCodeEditorServiceImpl () = X<_>\n                \n            type ITextModelService  = {\n                setEditor                        : Editor -> unit\n                //registerTextModelContentProvider : obj\n                createModelReference             : obj\n            }\n            \n            let textModelResolverService() =\n                let mutable editorO = None\n                {\n                    setEditor            = fun e   -> editorO <- Some e\n                    createModelReference = fun uri -> \n                        async {\n                            let model = getSnippetModel uri\n                            return Monaco.newImmortalReference(model)\n                        } |> Promise.OfAsync\n                }\n        \n            let monacoNew        (var           : Var<string>                         ) \n                                 (annotationsWO : View<MarkerData []>           option) \n                                 (showToolTipO  :(string -> int -> int -> unit) option) \n                                 (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                               -> string -> int -> int -> unit) option) =\n            \n                let setDirtyCond() = ()\n                let getHints    _  = ()\n        \n                async {\n                    return\n                        Monaco.newVar var\n                        |> fun config -> \n                            { config with   options   = \n                                                Pojo.newPojo [   \n                                                    \"fontSize\"   => 12\n                                                    \"lineHeight\" => 14 \n                                                ] \n                                        //overrides = 0 \n                                            overrides = \n                                                Pojo.newPojo [ \n                                                    \"codeEditorService\"        => getCodeEditorServiceImpl()\n                                                    \"textModelResolverService\" => textModelResolverService()\n                                                ]\n                            }\n                        |> onRender(fun ed -> \n                            Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                            Editor.SetTheme(\"vs\")\n                            //ed.UpdateOptions { fontSize   = 12 ; lineHeight = 14 }        \n                            let hp = new HoverProvider         (ed)\n                            let cp = new CompletionItemProvider(ed)\n                            let dp = new DefinitionProvider    (ed)\n                            hp.provideHover |> print\n                            cp.provideCompletionItems |> print\n                            cp.resolveCompletionItem  |> print\n                            dp.provideDefinition      |> print\n                            Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                            Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                            Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                            annotationsWO\n                            |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) )\n                        )\n                }\n        \n            let parse (code: string, starts: ((SnippetId * string) * (int * int * int)) []) =\n              asyncResult {\n                FStation.annotationsV.Value\n                |> String.skipFirstLine\n                |> (+) \"Parsing...\\n\"\n                |> FStation.annotationsV.Set\n                startsV.Set starts\n                let lines         = String.splitByChar '\\n' code\n                fileName         <- FsCode.getSourceDir FStation.srcDir lines +/+ FStation.id + \".fsx\"\n                let! errs, others = parseCode fileName lines true 0\n                (errs:CommTypes.ErrorResponse).Errors\n                |> Seq.map (fun v ->\n                   let (sid, name), (indent, first, _) = starts |> Seq.tryFind(fun (_, (indent, first, last)) -> v.StartLine > first && v.StartLine <= last) |> defaultStart\n                   sprintf \"%s (%d, %d) - (%d, %d) %s(%s) \\\"%s: %s\\\".\"\n                    <| match v.Severity with \"Error\" -> \"Err\" |_-> \"Warn\"\n                    <|  v.StartLine    - first\n                    <|  v.StartColumn  - indent\n                    <|  v.EndLine      - first\n                    <|  v.EndColumn    - indent\n                    <|    name\n                    <|    sid.Id.ToString()\n                    <|  v.Subcategory\n                    <|  v.Message\n                )\n                |> Seq.append [ \"Parsed!\" ]\n                |> String.concat \"\\n\"\n                |> FStation.annotationsV.Set\n                others |> Seq.iter print \n                ()\n              } |> AsyncResult.iterA print print\n        \n            let mutable editorConfigO : MonacoConfig option = None\n            \n            let editorDoc() = \n                async {\n                    do! Monaco.loader\n                    let! cfg = monacoNew <| Lens Snippets.currentSnippetV.V.snpContent\n                            <| Some ( (Snippets.currentSnippetW, FStation.annotationsV.View) ||> View.Map2 transformAnnotations )\n                            <| None\n                            <| None\n                    editorConfigO <- Some cfg\n                    return Monaco.render cfg\n                } |> Doc.Async\n                \n         \n            if IsClient then\n                Snippets.CurrentSnippetIdW |> View.Sink(fun sid ->\n                    try\n                        editorConfigO\n                        |> Option.bind(fun config -> config.editorO                         )\n                        |> Option.iter(fun editor -> getSnippetModel sid |> editor.SetModel \n                                                     FStation.annotationsV.Set FStation.annotationsV.Value\n                        )\n                    with _ -> ()\n                )\n        \n            let goto codeId line col = async {\n                match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n                | Some ed -> do! gotoEditor ed codeId line col\n                | _       -> ()\n            }\n        \n            let getSelection () =\n                match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n                | Some ed -> ed.GetSelection() |> ed.GetModel().GetValueInRange\n                | _       -> \"\"\n               \n        \n        \n        module JumpTo =\n        \n            let rexGuid = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let jumpToLine = \n                function\n                | REGEX rexGuid \"\" [| _ ; line ; col ; _ ; _ ; guid |] -> Monaco.goto <| SnippetId (System.Guid guid) <| int line <| int col \n                                                                          |> Async.Start\n                | _                                                    -> ()\n                \n            let jumpToRef (e:Dom.Element) =\n                let v : string = e?value |> unbox\n                let s : int    = e?selectionStart |> unbox\n                let lines = v.Split '\\n'\n                lines \n                |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n                |> fst\n                |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n                |> jumpToLine        \n        module CustomAction =\n            open FusionAsyncM\n            open Operators\n            open FStation\n        \n            let propO snp p = snp |> Snippet.propertyHierORm p |> ofFusionM |>> Option.map (function (_, (v, _)) -> v)\n        //    let [< Inline \"Object.constructor('return function(button) { return `' + $template + '`}')()($p)\" >] translateTemplate (template: string) p = \"\"\n        \n            let translateString f (code: string) =\n                let rec translate acc (s: string) =\n                    String.delimitedO \"${\" \"}\" s\n                    |> function\n                    | None -> acc + s\n                    | Some (bef, var, aft) ->\n                    translate (acc + bef) (f var + aft)\n                translate \"\" code\n        \n            let getBaseSnippet() = fusion {\n                let     snp     = Snippets.currentSnippetV.Value\n                let!    snpRefO = propO snp \"BaseSnippet\"\n                return! snpRefO\n                        |>  Option.map(fun ref -> \n                                SnippetReference.RefSnippetPath (ref.Split '/') \n                                |> Snippet.snippetFromRefORm\n                                |> ofFusionM)\n                        |>  insertO\n                        |>> Option.flatten\n                        |>> Option.defaultValue snp\n            }\n        \n            let codeModule snp code = fusion {\n                let! openPropO = propO snp \"Open\"\n                match openPropO with\n                | None    -> return code\n                | Some op ->\n                return\n                    op  + \"\\n\" + code \n                    |> String.indentStr 4 \n                    |> sprintf \"module Call%s =\\n%s\" (string <| FStation.now())\n            }\n        \n            let getCode snp name = fusion {\n                let! code        = fusion {\n                    let!  namecodeO = propO snp name\n                    match namecodeO with\n                    | Some code -> return code\n                    | None      ->\n                    if name.StartsWith \":\" then return name.[1..] else \n                    let!   template  = propO snp \"action-template\"\n                    return template |> Option.defaultValue \"${button}() |> printfn \\\"%A\\\"\"\n                }\n                let! code2 = codeModule snp code\n                return Snippets.prepAnyCode code2\n            }\n        \n            module AF = FsRoot.LibraryJS.AppFramework\n        \n            let fetchValue button v =\n                if v = \"button\" then button else\n                \"Snp_\" + (string Snippets.currentSnippetV.Value.snpId.Id).Replace(\"-\", \"\")\n                |> swap AF.splitName v\n                ||> AF.tryGetWoW\n                |> Option.bind View.TryGet\n                |> Option.defaultWith (fun () -> sprintf \"$[not found:%s]\" v)\n        \n            let actionClickRm name = fusion {\n                outputMsgs.Set  <| sprintf \"Action %s ...\" name\n                let! snp         = getBaseSnippet()\n                let! code        = getCode snp name |>> translateString (fetchValue name)\n                do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                let! preCode     = Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst\n                let! gen         = ofFusionM <| Snippet.predsGenerationRm snp\n                return! ofAsync <| FsiAgent.evalCodeWithPresence FStation.srcDir (sprintf \"%A\" snp.snpId) (string gen) (FsCode preCode) (FsCode code)\n            }\n        \n            let setSnippetContent (snpPath:string) content     = \n                fusion {\n                    let!  snpO  = snpPath.Split '/' |> SnippetReference.RefSnippetPath |> Snippet.snippetFromRefORm |> ofFusionM\n                    match snpO with\n                    | None     -> return! ofResultRM <| Error (ErrorMsg (sprintf \"Snippet %s not found\" snpPath) )\n                    | Some snp ->\n                    { snp with snpContent = content }\n                    |> Snippets.setSnippet\n                } |> iterReaderA  print print (Snippets.snippetsColl())\n        \n        \n            let actionSnpRm (snpPath:string) name = fusion {\n                let! snpO        = snpPath.Split '/' |> SnippetReference.RefSnippetPath |> Snippet.snippetFromRefORm |> ofFusionM\n                match snpO with\n                | None     -> return! ofResultRM <| Error (ErrorMsg (sprintf \"Snippet %s not found\" snpPath) )\n                | Some snp ->\n                let! code        = getCode snp name |>> translateString (fetchValue name)\n                do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                let! preCode     = Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst\n                let! gen         = ofFusionM <| Snippet.predsGenerationRm snp\n                return! ofAsync <| FsiAgent.evalCodeWithPresence FStation.srcDir (sprintf \"%A\" snp.snpId) (string gen) (FsCode preCode) (FsCode code)\n            }\n            \n            let actionSnp  path name        = actionSnpRm    path  name              |> iterReaderA  print print (Snippets.snippetsColl())\n            let actionClick name            = actionClickRm        name              |> iterReaderA  print print (Snippets.snippetsColl())\n            let buttonClick (e:Dom.Element) = e.TextContent.Trim()                   |> actionClick\n            let getCurrentProperty        p = propO Snippets.currentSnippetV.Value p |> runReader                (Snippets.snippetsColl()) \n                                                                                     |> AsyncResult.map fst\n                                                                                     |> AsyncResult.absorbO (fun () -> errorMsgf \"Property %s not found\" p)\n            let setCurrentProperty      p v = Snippets.setProperty Snippets.currentSnippetV.Value p v\n            let scrollToBottom (el:Dom.Element) = \n                async { \n                    do! Async.Sleep 100\n                    do  el.ScrollTop <- el.ScrollHeight\n                } |> Async.Start\n        \n            let setScrollToBottom =\n                let mutable elO :Dom.Element option = None\n                outputMsgs.View |> View.Sink(fun _s -> elO |> Option.iter scrollToBottom )\n                fun (el:Dom.Element) -> elO <- Some el ; printfn \"setScrollToBottom\"\n        \n        module Serializer =\n            open Serializer\n        \n            let serSnippetId      = serId (fun (SnippetId      v) -> v) SnippetId      (sprintf \"%A\")     \n        \n            let serSnippet   : Ser<Snippet  > = \n                [|\n                    serSnippetId                                         |> serField  \"snpId\"         (fun s -> s.snpId        ) (fun v  s -> { s with snpId         = v } )\n                    serString                                            |> serField  \"snpName\"       (fun s -> s.snpName      ) (fun v  s -> { s with snpName       = v } )\n                    serString                                            |> serField  \"snpContent\"    (fun s -> s.snpContent   ) (fun v  s -> { s with snpContent    = v } )\n                    serSnippetId                     |> serOpt           |> serField  \"snpParentIdO\"  (fun s -> s.snpParentIdO ) (fun v  s -> { s with snpParentIdO  = v } )\n                    serSnippetId                     |> serSet           |> serField  \"snpPredIds\"    (fun s -> s.snpPredIds   ) (fun v  s -> { s with snpPredIds    = v } )\n                    serString              |> serDup serString |> serArr |> serField  \"snpProperties\" (fun s -> s.snpProperties) (fun v  s -> { s with snpProperties = v } )\n                    serInt                                               |> serFieldO \"snpGeneration\" (fun s -> None           ) (fun vO s -> match vO with None->s |  Some v -> { s with snpModified = Utc1970_01_01.AddHours (float v) } )\n                    serDate                                              |> serField  \"snpModified\"   (fun s -> s.snpModified  ) (fun v  s -> { s with snpModified   = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            type Model = {\n                snippets   : Snippet []\n                modified   : System.DateTime\n                collapsed  : SnippetId Set\n            }\n        \n            let getModel(snippets, gen, coll) =  { snippets = snippets |> Seq.toArray ;  modified = gen ; collapsed = coll}\n        \n            let serModel : Ser<Model> =\n                [|\n                    serSnippet                       |> serArr           |> serField  \"snippets\"   (fun m -> m.snippets  ) (fun v  m -> { m with snippets   = v } )\n                    serInt                                               |> serFieldO \"generation\" (fun m -> None        ) (fun vO m -> match vO with None -> m | Some v -> { m with modified = Utc1970_01_01.AddHours (float v) } )\n                    serDate                                              |> serField  \"modified\"   (fun m -> m.modified  ) (fun v  m -> { m with modified   = v } )\n                    serSnippetId                     |> serSet           |> serField  \"collapsed\"  (fun m -> m.collapsed ) (fun v  m -> { m with collapsed  = v } )\n                |] |> serRecord { snippets = [||] ; modified = Utc1970_01_01 ; collapsed = Set.empty}\n                \n        \n        module LoadSave =\n        \n            let fileName  = Var.Create \"\"\n            let canLoad() = Snippets.SaveAsClassW |> View.TryGet = Some \"\" || JS.Confirm \"Changes have not been saved, do you really want to load?\"\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd Serializer.serModel \n                          |> fun mdl -> Snippets.setSnippetsGen mdl.snippets mdl.collapsed\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let loadTextFile element  =\n                if canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            fileName.Set files.[0].Name\n                            files.[0] |> reader.ReadAsText\n        \n            [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n            let saveAsJavaScript (_name:string) (_txt:string) = ()\n        \n            let saveAs() = \n                let name = match fileName.Value.Split [| '/' ; '\\\\' |] |> Seq.last with \n                           | \"\"    -> \"noname.snippets\" \n                           | fname -> fname\n                Snippets.getSnippetsGen()\n                |> Serializer.getModel\n                |> fst Serializer.serModel\n                |> saveAsJavaScript name\n                Snippets.updateGeneration()\n        \n        module Importer =\n            open Serializer\n        \n            let serSnippetId2 : Ser<SnippetId> = sprintU, fun (x: obj) -> x?Item |> deserGuid |> SnippetId\n        \n            let serSnippet2   : Ser<Snippet  > = \n                [|\n                    serSnippetId2                                        |> serField \"id\"           (fun s -> s.snpId                     ) (fun v s -> { s with snpId         = if v = SnippetId.Empty then SnippetId <| System.Guid.NewGuid() else v } )\n                    serString                                            |> serField \"name\"         (fun s -> s.snpName                   ) (fun v s -> { s with snpName       = v } )\n                    serString                                            |> serField \"content\"      (fun s -> s.snpContent                ) (fun v s -> { s with snpContent    = v } )\n                    serSnippetId2                    |> serOpt           |> serField \"parent\"       (fun s -> s.snpParentIdO              ) (fun v s -> { s with snpParentIdO  = if v = Some SnippetId.Empty then None else v } )\n                    serSnippetId2                    |> serArr           |> serField \"predecessors\" (fun s -> s.snpPredIds |> Seq.toArray ) (fun v s -> { s with snpPredIds    = Set v } )\n                    //serString                        |> serMap serString |> serField \"properties\"   (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            let serSnippets = serSnippet2 |> serArr\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd serSnippets\n                          |> fun snps -> Snippets.setSnippetsGen snps Set.empty\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let importFile element  =\n                if LoadSave.canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            files.[0] |> reader.ReadAsText\n        \n        module MainProgram =\n            open WebComponent\n            open FusionAsyncM\n            open Operators\n            open FStation\n        \n            type EndPoint =\n            |                   Snippet   of System.Guid\n            | [< Wildcard    >] Path      of string[]\n            | [< EndPoint \"\" >] NoSnippet\n        \n            open Sitelets.InferRouter\n            let endPointV = if IsClient then Router.Infer() |> Router.InstallHash NoSnippet else Var.Create NoSnippet\n        \n            if IsClient then\n                endPointV.View |> View.Sink (\n                    function\n                    | NoSnippet      -> View.rtn None\n                    | Snippet guid   -> View.rtn (SnippetId guid |> Some)\n                    | Path    pth    -> Snippets.currentPathW \n                                        |> View.Map (fun p -> \n                                            if p = String.concat \"/\" pth then Snippets.currentSnippetIdOV.Value else\n                                            Snippet.snippetFromPathORm pth\n                                            |> FusionM.map (Option.map (fun s -> s.snpId))\n                                            |> Snippets.runReader Snippets.handleError\n                                        )\n                    >> View.Get (fun sidO -> \n                       if  Snippets.currentSnippetIdOV.Value <> sidO then\n                           Snippets.setCurrentSnippetIdO sidO\n                   ))\n        \n                Snippets.currentSnippetIdOV.View |> View.Sink (\n                    function\n                    | None                 -> View.rtn NoSnippet\n                    | Some(SnippetId guid) -> Snippets.currentPathW\n                                              |> View.Map (fun p ->\n                                                if Path (p.Split '/') = endPointV.Value then endPointV.Value else\n                                                Snippet guid\n                                              )\n                    >> View.Get (fun ep -> \n                       if  endPointV.Value <> ep then\n                           endPointV.Value <- ep\n                   ))\n        \n            let runFsCode () = \n                let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n                Snippets.FsCodeW \n                |> View.TryGet \n                |> Option.iter (fun code ->\n                    fusion {\n                        outputMsgs.Set \"Running F#...\"\n                        do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                        return! ofAsync <| FsiAgent.evalCode FStation.srcDir (FsCode code)\n                    } |> iterResultA (sprintf \"Error:\\n%A\" >> out) ignore\n                )\n        \n            let selectionToFsi () = \n                let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n                fusion {\n                    do! FSharpStationClient.setAddress (WebSockets.Address FStation.id)  |> ofAsync\n                    do! Monaco.getSelection() |> fun s -> s + \";;\" |> FsiAgent.sendFsiInput |> ofAsync \n                } |> iterResultA (sprintf \"Error:\\n%A\" >> out) ignore\n        \n            let deleteSnippet() =\n                let snp = Snippets.currentSnippetV.Value\n                if  snp.snpId <> SnippetId.Empty \n                && JS.Confirm (sprintf \"Do you want to delete %s?\" <| Snippet.snippetName snp.snpName snp.snpContent) then \n                    Snippets.deleteCurrentSnippet()\n        \n            open FsRoot\n            module AF = AppFramework \n        \n            let FStationLyt = \"FStationLyt\"\n        \n            let hookVar plug name func obj =\n                AF.tryGetVar plug name\n                |> Option.map        (fun var -> printfn \"Var    %s.%s hooked\"    plug name ;  func obj var.varVar                  )\n                |> Option.defaultWith(fun ()  -> printfn \"Var    %s.%s not found\" plug name ;       obj                             )\n        \n            let hookViw plug name func obj =\n                AF.tryGetViw plug name\n                |> Option.map        (fun viw -> printfn \"View   %s.%s hooked\"    plug name ;  func obj viw.viwView                 )\n                |> Option.defaultWith(fun ()  -> printfn \"View   %s.%s not found\" plug name ;       obj                             )\n        \n            let hookAct plug name func obj =\n                AF.tryGetAct plug name\n                |> Option.map        (fun act -> printfn \"Action %s.%s hooked\"    plug name ;  func obj (fun _-> act.actFunction |> AF.callFunction () () ) )\n                |> Option.defaultWith(fun ()  -> printfn \"Action %s.%s not found\" plug name ;       obj                             )\n        \n            let hookDoc plug name func obj =\n                AF.tryGetDoc plug name\n                |> Option.map        (fun doc -> printfn \"Doc    %s.%s hooked\"    plug name ;  func obj (AF.mainDocV.View |> View.Map (fun _ -> AF.getLazyDoc doc) |> Doc.EmbedView) )\n                |> Option.defaultWith(fun ()  -> printfn \"Doc    %s.%s not found\" plug name ;       obj                             )\n        \n            let buttonsRight() =\n                TemplateLib.ButtonsRight()\n                |> hookAct \"FSharpStation\" \"AddSnippet\"    (fun tmp    -> tmp.AddSnippet                  )\n                |> hookAct \"FSharpStation\" \"RemoveSnippet\" (fun tmp    -> tmp.RemoveSnippet               )\n                |> hookAct \"FSharpStation\" \"IndentIn\"      (fun tmp    -> tmp.IndentIn                    )\n                |> hookAct \"FSharpStation\" \"IndentOut\"     (fun tmp    -> tmp.IndentOut                   )\n                |> hookAct \"FSharpStation\" \"RunFS\"         (fun tmp    -> tmp.RunFS                       )\n                |> (fun tmp -> tmp.Doc())\n        \n            if IsClient then\n                Snippets.codeAndStartsW |> View.Sink (delayed 300 Monaco.parse)\n        \n                View.Sink (fun m -> \n                    JS.Window.Onbeforeunload <- \n                        if m <> \"\" then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n                        else null\n                ) Snippets.SaveAsClassW \n        \n            let mainDoc() =\n                TemplateLib.Layout()\n                    .LoadFileChanged(  fun ev -> LoadSave.loadTextFile ev.Target                  )\n                    .LoadFileClear(    fun ev -> ev.Target?value <- \"\"                            )\n                    .ImportFileChanged(fun ev -> Importer.importFile ev.Target                    )\n                    .ImportFileClear(  fun ev -> ev.Target?value <- \"\"                            )\n                    .JumpRef(          fun ev -> JumpTo.jumpToRef ev.Target                       )\n                    //.OutputAfterRender(fun ev -> outputMsgs.View |> View.Sink (scrollToBottom ev) )\n                    //|> hookVar \"FSharpStation\" \"Content\"     (fun tmp -> tmp.Content     )\n                    |> hookVar \"FSharpStation\" \"fileName\"      (fun tmp    -> tmp.Filename                    )\n                    |> hookVar \"FSharpStation\" \"SnippetName\"   (fun tmp    -> tmp.Name                        )\n                    |> hookVar \"FSharpStation\" \"Output\"        (fun tmp    -> tmp.Output                      )\n                    |> hookVar \"FSharpStation\" \"Parser\"        (fun tmp    -> tmp.Parser                      )\n                    |> hookViw \"FSharpStation\" \"FSCode\"        (fun tmp vw -> tmp.FSCode (Var.Make vw ignore) )\n                    |> hookViw \"FSharpStation\" \"SaveNeeded\"    (fun tmp    -> tmp.SaveAsClass                 )\n                    |> hookAct \"FSharpStation\" \"SaveAs\"        (fun tmp    -> tmp.SaveAs                      )\n                    |> hookDoc \"FSharpStation\" \"editor\"        (fun tmp    -> tmp.CodeEditor                  )\n                    |> hookDoc \"FSharpStation\" \"Snippets\"      (fun tmp    -> tmp.Snippets                    )            \n                    |> hookDoc \"FSharpStation\" \"Properties\"    (fun tmp    -> tmp.Properties                  )            \n                    |> hookDoc \"FSharpStation\" \"ButtonsRight\"  (fun tmp    -> tmp.ButtonsRight                )            \n                    |> (fun tmp -> tmp.Doc())\n        \n            \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = \"FSharpStation\"\n                    AF.plgVars    = [| AF.newVar  \"fileName\"           LoadSave.fileName\n                                       AF.newVar  \"SnippetName\"        (Lens Snippets.currentSnippetV.V.snpName)\n                                       AF.newVar  \"Content\"            (Lens Snippets.currentSnippetV.V.snpContent)\n                                       AF.newVar  \"Output\"             outputMsgs\n                                       AF.newVar  \"Parser\"             FStation.annotationsV\n                                    |]  \n                    AF.plgViews   = [| AF.newViw  \"FsCode\"             Snippets.FsCodeW\n                                       AF.newViw  \"SaveNeeded\"         Snippets.SaveAsClassW\n                                       AF.newViw  \"CurrentPath\"        Snippets.currentPathW\n                                       AF.newViw  \"FStationId\"         (View.Const FStation.id)\n                                       AF.newViw  \"CurrentSid\"         (Snippets.CurrentSnippetIdW |> View.Map (fun sid -> sid.Id |> string))\n                                    |]  \n                    AF.plgDocs    = [| AF.newDoc  \"mainDoc\"            (lazy mainDoc()                 )\n                                       AF.newDoc  \"editor\"             (lazy (WebSharper.UI.Html.div [] [ Monaco.editorDoc() ]) )\n                                       AF.newDoc  \"Snippets\"           (lazy RenderSnippets  .render() )\n                                       AF.newDoc  \"Properties\"         (lazy RenderProperties.render() )\n                                       AF.newDoc  \"ButtonsRight\"       (lazy buttonsRight           () )\n                                    |]  \n                    AF.plgActions = [| AF.newAct  \"AddSnippet\"         Snippets.newSnippet\n                                       AF.newAct  \"RemoveSnippet\"      deleteSnippet       \n                                       AF.newAct  \"IndentIn\"           Snippets.indentIn       \n                                       AF.newAct  \"IndentOut\"          Snippets.indentOut\n                                       AF.newAct  \"AddProperty\"        RenderProperties.addProperty\n                                       AF.newAct  \"SaveAs\"             LoadSave.saveAs\n                                       AF.newAct  \"RunFS\"              runFsCode\n                                       AF.newAct  \"SelectionToFsi\"     selectionToFsi\n                                       AF.newAct  \"AbortFsi\"           FsiAgent.abortFsiExe\n                                       AF.newAct  \"DisposeFsi\"         FsiAgent.disposeFsiExe\n                                       AF.newActF \"LoadFile\"           <| AF.FunAct1 ((fun o     -> unbox o  |> LoadSave.loadTextFile              ), \"FileElement\")\n                                       AF.newActF \"Import\"             <| AF.FunAct1 ((fun o     -> unbox o  |> Importer.importFile                ), \"FileElement\")\n                                       AF.newActF \"JumpTo\"             <| AF.FunAct1 ((fun o     -> unbox o  |> JumpTo.jumpToRef                   ), \"textarea\"   )\n                                       AF.newActF \"ButtonClick\"        <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.buttonClick           ), \"button\"     )\n                                       AF.newActF \"ActionClick\"        <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.actionClick           ), \"name\"       )\n                                       AF.newActF \"SetScrollToBottom\"  <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.setScrollToBottom     ), \"textarea\"   )\n                                       AF.newActF \"ActionSnp\"          <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.actionSnp (unbox o1)  ), \"snpPath\", \"name\" )\n                                       AF.newActF \"setCurrentProperty\" <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.setCurrentProperty (unbox o1)  ), \"name\", \"value\" )\n                                       AF.newActF \"setSnippetContent\"  <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.setSnippetContent  (unbox o1)  ), \"path\", \"value\" )\n                                    |]\n                    AF.plgQueries = [| AF.newQry  \"PropertyRA\"         <| (fun p -> unbox<string> p |> CustomAction.getCurrentProperty |> box)\n                                    |]\n                }\n        \n                match JS.Document.GetElementById(\"GlobalLayout\") with\n                | null ->\n                  \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -120 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS btnInputFsi btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddSnippet    button FSharpStation.AddSnippet     \"\"                  \"Add Snippet   \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnInputFsi      button FSharpStation.selectionToFsi   \"\"                  \"selection |> Fsi\"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                  \"\"\"\n                | e -> e.TextContent\n                |> LayoutEngine.newLyt FStationLyt\n                |> LayoutEngine.addLayout\n        \n                Snippets.currentLayoutJSDW\n                |> View.consistent\n                |> View.Sink(fun lytO ->\n                    lytO\n                    |> Option.iter (fun (sid, js) ->\n                        try\n                            JavaScript.JS.Apply JavaScript.JS.Window \"eval\" [| \"CIPHERSpaceLoadFilesDoAfter(function(){IntelliFactory.Runtime.Start()})\" |]\n                            JavaScript.JS.Apply JavaScript.JS.Window \"eval\" [| js                                                          |]\n                        with e -> print e\n                    )\n                )\n        \n                Snippets.currentLayoutDW\n                |> View.consistent\n                |> View.Sink(fun lytO ->\n                    lytO\n                    |> Option.bind (fun (name, txt) ->\n                        txt \n                        |> LayoutEngine.newLyt    name\n                        |> LayoutEngine.addLayout \n                        if txt = \"\" then None else \n                        Some name\n                    )\n                    |> Option.defaultValue FStationLyt\n                    |> AF.mainDocV.Set\n                )\n        \n                Snippets.currentPathW\n                |> View.Sink (fun v -> \n                    async {\n                        do! Async.Sleep 500\n                        JS.Window.Document.Title <- v \n                    } |> Async.Start\n                )        \n        \n                //async {\n                //  do! Monaco.loader\n                //  //WcSplitter.init horizontal vertical\n                //  //WcTabStrip.init()\n                //  let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n        \n                //} |> Doc.Async\n                TemplateLib()\n                    .MainContent( AF.getMainDoc.Value )\n                    .Bind()\n        \n        \n        //#define FSS_SERVER\n        module Messaging =\n            open FStation\n            open FusionAsyncM\n            open Operators\n            open MainProgram\n        \n            open FsRoot\n            module AF = AppFramework \n            module Fusion = FusionAsyncM\n        \n            let wsStationClient = if IsClient then new WebSockets.WSMessagingClient(FStation.id) else new WebSockets.WSMessagingClient(\"FStation.id\", WebSockets.FSStation)\n        \n            let actionCall actN p1 p2 = fusion {\n                match actN |> AF.splitName FStationLyt ||> AF.tryGetAct with\n                | None     -> return! ofResultRM <| Error (ErrorMsg (sprintf \"Action %s not found\" actN) )\n                | Some act -> AF.callFunction p1 p2 act.actFunction\n                              return FSResponse.RespString \"Ok\"\n            }\n        \n            let getValue vname = fusion {\n                match vname |> AF.splitName FStationLyt ||> AF.tryGetWoW with\n                | None     -> return! ofResultRM <| Error (ErrorMsg (sprintf \"Var or View %s not found\" vname) )\n                | Some  vw -> let! v = vw |> View.GetAsync |> ofAsync\n                              return FSResponse.RespString v\n            }\n        \n            let setValue vname v = fusion {\n                match vname |> AF.splitName FStationLyt ||> AF.tryGetVar with\n                | None     -> return! ofResultRM <| Error (ErrorMsg (sprintf \"Var %s not found\" vname) )\n                | Some var -> var.varVar.Set v\n                              return FSResponse.RespString \"Ok\"\n            }\n        \n            let processMessage (msg: FSMessage) : Async<Result<FSResponse,ResultMessage<string>>>= \n                fusion {\n                    match msg with\n                    | MsgGetId                          -> return  RespString FStation.id\n                    | MsgGetSnippets               snrs -> let!    snps = snrs |> Fusion.traverseSeq (Snippet.snippetFromRefORm >> ofFusionM)\n                                                           return  snps |> Seq.choose id |> Seq.toArray |> RespSnippets\n                    | MsgGetCode                   snr  -> Snippets.clearPredsCache ()\n                                                           let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           return! Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst |>> RespString\n                    | MsgGetModified               snr  -> let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           let!    ids  = Snippet.predsLRm snp.snpId |> ofFusionM\n                                                           let!    prds = ids |> Fusion.traverseSeq (Snippet.snippetORm >> ofFusionM)\n                                                           return  prds |> Seq.choose (Option.map (fun s -> s.snpModified)) |> Seq.max |> RespDateTime\n                    | MsgGetPredecessors           snr  -> let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           let!    ids  = Snippet.predsLRm snp.snpId |> ofFusionM\n                                                           let!    prds = ids |> Fusion.traverseSeq (Snippet.snippetORm >> ofFusionM)\n                                                           return  prds |> Seq.choose id |> Seq.toArray |> RespSnippets\n                    | MsgAction [| \"AddOutput\" ; txt |] -> appendMsgs txt\n                                                           return  FSResponse.RespString \"Ok\"\n                    | MsgAction [| \"ExecJS\"    ; js  |] -> let! v = try  JS.Apply JS.Window \"eval\" [| js |] |> (function null -> \"\" | s -> sprintf \"%A\" s) |> Ok\n                                                                    with e -> ExceptMsg(e.Message, e.StackTrace) |> Error\n                                                                    |> FusionAsyncM.ofResultRM\n                                                           return  FSResponse.RespString v\n                    | MsgAction [| \"SetProperty\"; path ; prop ; v  |] -> \n                                                           let! res  = Snippet.snippetFromRefORm (RefSnippetPath <| path.Split '/')\n                                                                       |>  ofFusionM  \n                                                                       |>> Option.map (fun snp -> Snippets.setProperty snp prop v ; \"Ok\")\n                                                                       |>  absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found: %s\" path)\n                                                           return  FSResponse.RespString res\n                    | MsgAction [| actN              |] -> return! actionCall actN () ()\n                    | MsgAction [| actN ; p1         |] -> return! actionCall actN p1 ()\n                    | MsgAction [| actN ; p1 ; p2    |] -> return! actionCall actN p1 p2\n                    | MsgGetValue               vrw     -> return! getValue vrw\n                    | MsgSetValue              (var, v) -> return! setValue var v\n                    | MsgGetUrl                         -> return  FSResponse.RespString JS.Document.BaseURI\n                    | _                                 -> return  Hole ?(sprintf \"TODO message: %A\" msg)\n                } |> runReader (Snippets.snippetsColl()) |> AsyncResult.map fst\n            \n            if IsClient then\n                async {\n                    do! Async.Sleep 1000\n                    while true do\n                        try         wsStationClient.ProcessIncoming processMessage\n                                    do! Async.Sleep 60000\n                        with   e -> printfn \"%s\" e.Message\n                                    do! Async.Sleep 1000\n                } |> Async.Start\n                \n        \n            if not IsClient then\n                FsiAgent.setQueueHandlers (fun (txt:string)  -> txt.Replace(FsiEvaluator.endToken, \"Done!\") \n                                                                |> FSharpStationClient.sendOutput \n                                                                |> AsyncResult.iterS print print)\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\CommonServiceLocator\\lib\\portable-net4+sl5+netcore45+wpa81+wp8\\Microsoft.Practices.ServiceLocation.dll\"\n        \n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n        //        Content.Page(Title = \"Main Page\" \n        //                   , Body  = [\n        //                        Html.client <@ MainProgram.mainProgram() @>\n        //                        Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n        //                     ])\n                Content.Page( \n                    TemplateLib()\n                        .Initializer( Html.client <@  MainProgram.mainProgram(); Doc.TextNode \"Initialized\" @> )\n                        .Elt(keepUnfilled = true) \n                )\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                let staticFileOptions = StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory))\n                staticFileOptions.ServeUnknownFileTypes <- true\n                (staticFileOptions.ContentTypeProvider |> unbox<ContentTypes.FileExtensionContentTypeProvider>).Mappings.Add(\".wasm\", \"application/wasm\")\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(staticFileOptions)\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
