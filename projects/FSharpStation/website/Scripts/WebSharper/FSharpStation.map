{
"version": 3,
"sourceRoot": "Source",
"sources": ["FSharpStation/FSharpStation.fs"],
"sourcesContent": ["#nowarn \"3242\"\n#nowarn \"52\"\n////-d:FSS_SERVER -d:FSharpStation1593197096670 -d:TEE -d:WEBSHARPER\n////#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FSharpStation\\src\"\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\System.Reactive\\lib\\net46\\System.Reactive.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Control.Reactive\\lib\\net46\\FSharp.Control.Reactive.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\CommonServiceLocator\\lib\\portable-net4+sl5+netcore45+wpa81+wp8\\Microsoft.Practices.ServiceLocation.dll\"\n//#nowarn \"3242\"\n//#nowarn \"52\"\n/// Root namespace for all code\n//#define FSharpStation1593197096670\n#if !NOFSROOT\n#if INTERACTIVE\nmodule FsRoot   =\n#else\n#if DLL\nnamespace FsRootDll\n#else\nnamespace FsRoot\n#endif\n#endif\n#endif\n    #if !NETSTANDARD20\n    \n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n    \n    #if WEBSHARPER\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    #endif\n    #endif\n    #if WEBSHARPER\n    //#nowarn \"3242\" \n    \n    open WebSharper\n    //open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            inherit System.Attribute()\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            inherit System.Attribute()\n            let a = 1\n            new() = JavaScriptAttribute true\n        type JavaScriptExportAttribute(translate:bool) =\n            inherit System.Attribute()\n            let a = 1\n            new() = JavaScriptExportAttribute true\n        type InlineAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScriptExport ; AutoOpen >]\n        module Library = \n            let Error = Result.Error\n        \n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            \n            type StringId<'T> = StringId of string \n            with\n                member this.Id = match this with StringId v -> v\n            \n            type GuidId<'T> = GuidId of System.Guid\n            with\n                member this.Id = match this with GuidId v -> v\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            //#define TEE\n            \n            let [< Inline \"new Date(0).getTime()\" >] Utc1970_01_01                 = System.DateTime(1970,1,1,0,0,0,System.DateTimeKind.Utc)\n            let [< Inline \"$d\"                    >] date2Long (d:System.DateTime) = d.Subtract(Utc1970_01_01).Ticks / 10000L\n            let [< Inline \"$l\"                    >] long2Date (l:int64          ) = Utc1970_01_01.Add(System.TimeSpan(l * 10000L) )\n            \n            \n            [< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDate()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\n            let nowStamp() = \n                let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n                t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n            \n            let [<Inline>] inline traceT t v = tee (sprintf \"%A\" >> (fun s -> s.[..min 100 s.Length-1]) >> printfn \"%s %s: %A\" (nowStamp()) t) v\n            let [<Inline>] inline trace   v = traceT \"trace\" v\n            let [<Inline>] inline traceI  v = trace          v |> ignore\n            \n            module Log =\n                let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n                let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n                let [<Inline>] inline InA    n f p = async { return! In  n f p }\n                let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n                let [<Inline>] inline InOut  n     = In  n >> Out  n\n                let [<Inline>] inline InOutA n f p = async {\n                    let!   r = InA n f  p\n                    do         Out n id r |> ignore\n                    return r \n                  }\n            \n                let [<Inline>] inline TimeIt n f p =\n                    printfn \"%s Starting %s\" (nowStamp()) n\n                    let start = System.DateTime.UtcNow.Ticks\n                    f p\n                    let elapsedSpan = new System.TimeSpan(System.DateTime.UtcNow.Ticks - start)\n                    printfn \"%s Finished %s %0d:%02d:%02d.%03d\" (nowStamp()) n (int elapsedSpan.TotalHours) elapsedSpan.Minutes elapsedSpan.Seconds elapsedSpan.Milliseconds\n            \n            \n            // issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\n            #if !WEBSHARPER\n            module IDict =\n                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            #endif\n            \n            module Dict =\n                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            \n            module LDict =\n                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n                let [<Inline>] inline tryGetValue fitem key  dict =\n                    if containsKey key dict then Some (fitem key)\n                    else None\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let inline errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let inline warningf  fmt = Printf.ksprintf Warning  fmt\n                let inline infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            module Memoize =\n            \n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )\n                    (checkO, getOrAdd), cache.Clear\n            \n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )\n            \n                /// Memoizes function f using the provided cache\n                /// getCache() returns 1 function:\n                ///    getOrAdd: ('p->('p->'v)->'v) \n                [< Inline >]\n                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =\n                    fun p -> getOrAdd p f\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let (check, getOrAdd), clear = getStore()\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, clear\n            \n                /// Memoizes the function f using the provided Dictionary\n                [<Inline>]\n                let memoizeWithDict dict f =\n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF\n            \n                /// Memoizes the function f and returns Dictionary\n                [<Inline>]\n                let memoizeDict f =\n                    let dict = System.Collections.Generic.Dictionary<_, _>() \n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, dict\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            /// returns a function that delays its execution\n            /// cancels prior when multiple calls happen before the delay\n            let delayedA delay doF =\n                let mutable cancelTokenO = None\n                fun parm -> \n                    let asy = async {\n                        do! Async.Sleep delay\n                        do! doF parm\n                    } \n                    cancelTokenO |> Option.iter (fun (tokenSource: System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n                    cancelTokenO <- Some <| new System.Threading.CancellationTokenSource()\n                    Async.Start(asy, cancellationToken = cancelTokenO.Value.Token)\n            \n            /// returns a function that delays its execution\n            /// cancels prior when multiple calls happen before the delay\n            let delayed delay doF = delayedA delay (doF >> async.Return)\n            \n            #if WEBSHARPER\n            \n            let delayedVar delay (var:Var<_>) =\n                let delayedV = Var.Create var.Value\n                var.View |> View.Sink (delayed delay delayedV.Set)\n                delayedV\n            \n            #endif\n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    let ofOption vO = \n                        match vO with\n                        | Some v -> Seq.singleton v\n                        | None   -> Seq.empty\n                \n                module Option =\n                    open Option\n                    \n                    let rtn    = Some\n                    let iter f = map f >> Option.defaultValue ()\n                \n                    let join o = Option.bind id o\n                    \n                    let apply fO  vO =\n                        match fO, vO with\n                        | Some f, Some v -> f v |> Some\n                        | _     , _      -> None\n                \n                    /// Same as defaultWith\n                    let mapNone  f o = Option.defaultWith f o\n                    let bindNone f o = match o with | Some v -> Some v |_-> f()\n                    \n                    let (>>=)                              v f = bind f v\n                    let traverseSeq            f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    [< Inline \"throw 'traverseSeqS cannot be used in JavaScript!'\" >]\n                    let traverseSeqS (f: 't->Async<_>) (t: 't seq) = async {\n                                                                 let! ct = Async.CancellationToken\n                                                                 return seq {\n                                                                     use enum = t.GetEnumerator ()\n                                                                     while enum.MoveNext() do\n                                                                         yield Async.RunSynchronously (f enum.Current, cancellationToken = ct) }}\n                    let inline sequenceSeqS          sq = traverseSeqS id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                \n                module State =\n                \n                    type State<'T, 'S> = 'S -> ('S * 'T)\n                \n                    let rtn v = fun s -> s, v\n                    let bind (f:'a->State<'b,'S>) (ma:State<'a,'S>) : State<'b,'S> = \n                        fun s1 -> \n                            let s2, a = ma s1\n                            f a s2            \n                    let map f = bind (f >> rtn)\n                \n                \n                    type CEBuilder() =\n                        member __.Bind   (m, f) = bind f m\n                        member __.Return     v  = rtn v\n                        member __.Delay      f  = f ()\n                \n                    let state = CEBuilder()\n                \n                    module Operators =\n                        let (>>=) ma f = bind f ma\n                        let (|>>) ma f = map  f ma\n                module Result =\n                    open Result\n                \n                    let errorf fmt = Printf.ksprintf Error fmt\n                \n                    let rtn                          = Ok\n                    let join                       r = Result.bind id r\n                    let flatten                    r = Result.bind id r\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bind (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bind f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                    \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                        | Ok   v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                        | Error e ->      e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iterP                 fE f r = r   |> mapP f |> defaultWith fE                                                 : unit    \n                    \n                    type BuilderP() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let resultP = BuilderP()\n                    \n                    \n                module Depend =\n                \n                    type Depend<'T> = \n                    | Dependency of (string * obj) option * (obj -> Depend<'T>)\n                    | NoMore     of 'T\n                \n                    let dependByName nm (defF:'f) (kf:'f->'T) = Dependency(Some(nm, box defF), fun f -> NoMore (kf (unbox f)) )\n                \n                    #if !WEBSHARPER\n                    open Microsoft.FSharp.Quotations.Patterns \n                    open Microsoft.FSharp.Quotations.DerivedPatterns \n                \n                    let pname (prop  :System.Reflection.PropertyInfo) = prop  .DeclaringType.FullName + \".\" + prop  .Name\n                    let mname (method:System.Reflection.MethodInfo  ) = method.DeclaringType.FullName + \".\" + method.Name\n                \n                    let shouldBe q = \n                        let rec shouldBe l =\n                            function\n                            | Call(_, method, _) -> Some(mname method, l)\n                            | Lambda(a, q2)      -> shouldBe (l + 1) q2\n                            | _ -> None\n                        match q with\n                        | PropertyGet(o,                                          prop  , [         ]     )-> pname prop  , \"should be 0\"\n                        | Lambda(a,                                    Call(None, method, [         ])    )\n                        | Lambda(a,                                    Call(None, method, [_        ])    )-> mname method, \"should be 1\"\n                        | Lambda(a,Lambda(b,                           Call(None, method, [p;q      ]))   )-> mname method, \"should be 2\"\n                        | Lambda(a,Lambda(b,Lambda(c,                  Call(None, method, [p;q;r    ])))  )-> mname method, \"should be 3\"\n                        | Lambda(a,Lambda(b,Lambda(c,Lambda(d,         Call(None, method, [p;q;r;s  ])))) )-> mname method, \"should be 4\"\n                        | Lambda(a,Lambda(b,Lambda(c,Lambda(d,Lambda(e,Call(None, method, [p;q;r;s;t]))))))-> mname method, \"should be 5\"\n                        | q -> \n                            shouldBe 0 q \n                            |> Option.map(fun (nm,l) -> nm, sprintf \"Not covered %d parms: %A\" l q) \n                            |> Option.defaultWith(fun () -> \"?\", sprintf \"Not covered: %A\" q)\n                        |> fun (nm, m) -> failwithf \" %s : %s\" nm m\n                \n                    let getName0(q:Quotations.Expr<                    'T>) : string *                      'T = \n                        match q with\n                        | PropertyGet(o,                                          prop  , [         ]     )-> pname prop  ,                  prop.GetValue(null, [|         |]) |> unbox \n                        |_-> shouldBe q\n                    let getName1(q:Quotations.Expr<'a                ->'T>) : string * ('a                ->'T) = \n                        match q with\n                        | Lambda(a,                                    Call(None, method, [         ])    )-> mname method, fun a         -> method.Invoke(null, [|         |]) |> unbox \n                        | Lambda(a,                                    Call(None, method, [p        ])    )-> mname method, fun a         -> method.Invoke(null, [|a        |]) |> unbox \n                        |_-> shouldBe q\n                    let getName2(q:Quotations.Expr<'a->'b            ->'T>) : string * ('a->'b            ->'T) = \n                        match q with\n                        | Lambda(a,Lambda(b,                           Call(None, method, [p;q      ]))   )-> mname method, fun a b       -> method.Invoke(null, [|a;b      |]) |> unbox\n                        |_-> shouldBe q\n                    let getName3(q:Quotations.Expr<'a->'b->'c        ->'T>) : string * ('a->'b->'c        ->'T) = \n                        match q with\n                        | Lambda(a,Lambda(b,Lambda(c,                  Call(None, method, [p;q;r    ])))  )-> mname method, fun a b c     -> method.Invoke(null, [|a;b;c    |]) |> unbox\n                        |_-> shouldBe q\n                    let getName4(q:Quotations.Expr<'a->'b->'c->'d    ->'T>) : string * ('a->'b->'c->'d    ->'T) = \n                        match q with\n                        | Lambda(a,Lambda(b,Lambda(c,Lambda(d,         Call(None, method, [p;q;r;s  ])))) )-> mname method, fun a b c d   -> method.Invoke(null, [|a;b;c;d  |]) |> unbox\n                        |_-> shouldBe q\n                    let getName5(q:Quotations.Expr<'a->'b->'c->'d->'e->'T>) : string * ('a->'b->'c->'d->'e->'T) = \n                        match q with\n                        | Lambda(a,Lambda(b,Lambda(c,Lambda(d,Lambda(e,Call(None, method, [p;q;r;s;t]))))))-> mname method, fun a b c d e -> method.Invoke(null, [|a;b;c;d;e|]) |> unbox\n                        |_-> shouldBe q\n                \n                    let depend0   q                                                                      = let (nm, f) = getName0 q in dependByName nm f id\n                    let depend1   q                                                                      = let (nm, f) = getName1 q in dependByName nm f id\n                    let depend2   q                                                                      = let (nm, f) = getName2 q in dependByName nm f id\n                    let depend3   q                                                                      = let (nm, f) = getName3 q in dependByName nm f id\n                    let depend4   q                                                                      = let (nm, f) = getName4 q in dependByName nm f id\n                    let depend5   q                                                                      = let (nm, f) = getName5 q in dependByName nm f id\n                    let replace0 (q:Quotations.Expr<                    'T>) (fr:                    'T) = let (nm, _) = getName0 q in nm, box fr\n                    let replace1 (q:Quotations.Expr<'a->                'T>) (fr:'a->                'T) = let (nm, _) = getName1 q in nm, box fr\n                    let replace2 (q:Quotations.Expr<'a->'b->            'T>) (fr:'a->'b->            'T) = let (nm, _) = getName2 q in nm, box fr\n                    let replace3 (q:Quotations.Expr<'a->'b->'c->        'T>) (fr:'a->'b->'c->        'T) = let (nm, _) = getName3 q in nm, box fr\n                    let replace4 (q:Quotations.Expr<'a->'b->'c->'d->    'T>) (fr:'a->'b->'c->'d->    'T) = let (nm, _) = getName4 q in nm, box fr\n                    let replace5 (q:Quotations.Expr<'a->'b->'c->'d->'e->'T>) (fr:'a->'b->'c->'d->'e->'T) = let (nm, _) = getName5 q in nm, box fr\n                    #endif\n                \n                    let bind (f: 'a -> Depend<'b>) (pa:Depend<'a>) : Depend<'b> = \n                        let rec bindR =\n                            function\n                            | Dependency(dep, k) -> Dependency(dep , fun p -> bindR (k p) ) \n                            | NoMore     v       -> Dependency(None, fun p -> f v         )\n                        bindR pa\n                    let rtn = NoMore\n                    let map f = bind (f >> rtn)\n                    let inline apply fR vR = fR |> bind (swap map  vR)\n                \n                    let replacer lst depend =\n                        let rec replace =\n                            function\n                            | Dependency(None       , k)      -> Dependency(None        , k >> replace)\n                            | Dependency(Some(nm, v), k)      ->\n                                lst \n                                |> Seq.tryFind (fst >> ((=) nm))\n                                |> Option.map  (snd >> fun v2 -> Dependency(Some(nm, v2), k >> replace) )\n                                |> Option.defaultWith(fun ()  -> Dependency(Some(nm, v ), k >> replace) )\n                            | NoMore v                        -> NoMore              v\n                        replace depend\n                \n                    let replacerDef lst depend =\n                        let rec replace =\n                            function\n                            | Dependency(None       , k)          -> Dependency(None         , k >> replace)\n                            | Dependency(Some(nm, v), k)          ->\n                                lst \n                                |> Seq.tryFind (fun (_, (nm2, _)) -> nm2 = nm)\n                                |> Option.map  (fun (nmN,(_, v2)) -> Dependency(Some(nmN, v2), k >> replace) )\n                                |> Option.defaultWith(fun ()      -> Dependency(Some(nm , v ), k >> replace) )\n                            | NoMore v                            -> NoMore               v\n                        replace depend\n                \n                    let resolver lst depend = \n                        let rec resolve =\n                            function\n                            | Dependency(None       , k)      -> k () |> resolve\n                            | Dependency(Some(nm, v), k)      ->\n                                lst \n                                |> Seq.tryFind (fst >> ((=) nm))\n                                |> Option.map  (snd >> fun v2 -> k v2  )\n                                |> Option.defaultWith(fun ()  -> k v )\n                                |> resolve\n                            | NoMore v                        ->   v\n                        resolve depend\n                \n                    type DependBuilder() =\n                        member __.Bind   (m, f) = bind f m\n                        member __.Return     v  = rtn v\n                        member __.Delay      f  = f ()\n                \n                    let depend = DependBuilder()\n                \n                    let getDependencies dep =\n                        let rec collect lst dep =\n                            let     lst2 = dep :: lst\n                            match dep with\n                            | Dependency(None      , k) -> collect lst2 (k () )\n                            | Dependency(Some(_, v), k) -> collect lst2 (k v  )\n                            | NoMore f                  -> lst2\n                        collect [] dep\n                        |> List.filter (function| Depend.Dependency(None,_) -> false |_-> true) \n                        |> List.rev \n                \n                    let toString dep =\n                        getDependencies dep\n                        |> Seq.map       \n                            (function \n                            | Depend.Dependency(Some(nm, v), next) -> sprintf \"%-50s %A\" nm v\n                            | x -> string x)\n                        |> Seq.distinct\n                        |> Seq.sort\n                        |> String.concat \"\\n\"\n                \n                    module Operators =\n                        let rtn        = rtn\n                        let depend     = depend\n                        let (>>=) ma  f = bind f ma\n                        let (|>>) ma  f = map  f ma\n                        let (|*>) p  mf = apply mf (rtn p)\n                        let (>=*) mp mf = apply mf     mp\n                        let (<*>) mf mp = apply mf     mp\n                        let (>*>)  g mf = depend {\n                            let! f = mf\n                            return g >> f\n                        }\n                \n                \n                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)\n                \n                module FusionM =\n                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)\n                    let        bind              f m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, m1)\n                                                              match v2O with\n                                                              | None    -> None, s2, m2\n                                                              | Some v2 ->\n                                                              let (FM fm2) = f v2\n                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                              v3O, s3,                       ResultMessage.addMsg m2 m3\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me\n                                                       )\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FM f\n                    let inline getFun         (FM f) =    f\n                    let inline from                m = m : FusionM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)\n                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )\n                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )\n                \n                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)\n                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)\n                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)\n                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)\n                \n                    let inling getOption          m  = FM(fun (s1,m1) ->\n                                                           try\n                                                               let (FM fm1)  = m\n                                                               let        v2O, s2, m2 = fm1 (s1, m1)\n                                                               Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               None, s1, ResultMessage.addMsg m1 me\n                                                       )\n                \n                \n                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )\n                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)\n                    let inline ofResultMessage     m =                        OkFMsg ()                                               m\n                    let inline ofFusionM           m = from m\n                \n                    let        freeMessageF     f  m = FM(fun (s1,m1) -> \n                                                          try\n                                                              let (FM fm1)  = m\n                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              v2O, s2,                   ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       )\n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                \n                    let mapState           get set m = FM(fun (s1, r) -> \n                                                            let vO, s2, r = getFun m (get s1, r)\n                                                            vO, set s1 s2, r\n                                                        )\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m\n                \n                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            checkO p \n                                                            |> Option.map rtn \n                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                            |> run r\n                                                        )\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline readerFun             f  = getS() |> map f\n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    \n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )\n                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )\n                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                        let body' = fun () -> body disposable\n                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type FusionAsyncM<'T, 'S, 'M> = FAM of ('S * ResultMessage<'M> -> Async<'T option * 'S * ResultMessage<'M> >)\n                \n                module FusionAsyncM =\n                    let inline rtn               v   = FAM(fun (s ,r ) -> async.Return (Some v, s, NoMsg) )\n                    let        bind              f m = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let! v2O, s2, m2 = fm1 (s1, m1)\n                                                               match v2O with\n                                                               | None    -> return None, s2, m2\n                                                               | Some v2 ->\n                                                               let    (FAM fm2) = f v2\n                                                               let! v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)\n                                                               return v3O, s3,            ResultMessage.addMsg m2 m3\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1,           ResultMessage.addMsg m1 me\n                                                        })\n                    let inline map          f     m  = bind (f >> rtn) m\n                \n                    let inline wrap               f  = FAM f\n                    let inline getFun        (FAM f) =    f\n                    let inline from                m = m : FusionAsyncM<_, _, _>\n                \n                    let inline run               s m = getFun m (s, NoMsg)\n                \n                    let inline OkF               v   = FAM(fun (s,r) -> async.Return (Some v , s , NoMsg) )\n                    let inline OkFMsg            v m = FAM(fun (s,r) -> async.Return (Some v , s , m    ) )\n                    let inline ErrorF              m = FAM(fun (s,r) -> async.Return (None   , s , m    ) )\n                \n                    let inline getS               () = FAM(fun (s,r) -> async.Return (Some s , s , NoMsg) )\n                    let inline getR               () = FAM(fun (s,r) -> async.Return (Some r , s , NoMsg) )\n                    let inline putS               s1 = FAM(fun (s,r) -> async.Return (Some (), s1, NoMsg) )\n                    let inline check              () = FAM(fun (s,r) -> async.Return ((if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg) )\n                \n                    let inline getOption          m  = FAM(fun (s1,m1) -> async {\n                                                           try\n                                                               let (FAM fm1)  = m\n                                                               let!        v2O, s2, m2 = fm1 (s1, m1)\n                                                               return Some v2O, s2, m2\n                                                           with e ->\n                                                               let me = ExceptMsg(e.Message, e.StackTrace)\n                                                               return None, s1, ResultMessage.addMsg m1 me\n                                                        })\n                \n                    let inline ofResultRM         r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e\n                    let inline ofResultM          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)\n                    let inline ofResultS          r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)\n                    let inline ofResult           r  = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf \"%A\" e)\n                    let inline ofOption        f  o  = o  |> Option.map OkF |> Option.defaultWith (f >> ErrorF)\n                    let inline ofMessage          m  =                        OkFMsg ()                      (Message                  m)\n                    let inline ofResultMessage    m  =                        OkFMsg ()                                                m\n                    let inline ofAsync            a  = FAM(fun (s, r) -> a |> Async.map (fun v -> Some v, s, NoMsg) )\n                    let inline ofAsyncResultRM    a  = a |> ofAsync |> bind ofResultRM\n                    let inline ofFusionM     (FM fm) = FAM(fun (s, r) -> async.Return (fm (s, r)) )\n                \n                    let        freeMessageF     f  m = FAM(fun (s1,m1) -> async {\n                                                          try\n                                                              let   (FAM fm1)  = m\n                                                              let! v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)\n                                                              return v2O, s2,             ResultMessage.freeMessageF f m2\n                                                          with e ->\n                                                              let me = ExceptMsg(e.Message, e.StackTrace)\n                                                              return None, s1,            ResultMessage.addMsg m1 me |> ResultMessage.freeMessage\n                                                       })\n                    let mapState           get set m = FAM(fun (s1, r) -> async {\n                                                            let! vO, s2, r = getFun m (get s1, r)\n                                                            return vO, set s1 s2, r\n                                                        })\n                \n                    let iterReader     fM f  v     m  = m |> map f |> run v |> Async.iterS (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                    let iterReaderA    fM f  v     m  = m |> map f |> run v |> Async.iterA (fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m)\n                \n                    let memoizeRm      getStore fRm p = FAM(fun (r:'r, m) -> async {\n                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r\n                                                            let store p v = getOrAdd p (fun _ -> v)\n                                                            return! checkO p \n                                                                    |> Option.map rtn \n                                                                    |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                    |> run r\n                                                        })\n                \n                    let inline apply           fR    vR = fR |> bind (swap map  vR)\n                    let (>>=)                       v f = bind f v\n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline freeMessage         m = m |> freeMessageF (sprintf \"%O\" >> ErrorMsg )\n                    let inline freeMessageW        m = m |> freeMessageF (sprintf \"%O\" >> Warning  )\n                    \n                    let inline readerFun          f  = getS() |> map f\n                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                    \n                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM\n                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                    \n                    \n                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)\n                    let runReader           v      m  = m |> run v |> Async.map (fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m))\n                    let runResult                  m  = m |> runReader        ()\n                    let iterResult          fM f   m  = m |> iterReader  fM f ()\n                    let iterResultA         fM f   m  = m |> iterReaderA fM f ()\n                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()\n                    let iterResultPrintA           m  = m |> iterReaderA (ResultMessage.summarized >> print) print ()\n                    \n                    module Operators =\n                        let inline (<*>) f v   = apply f v\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                    \n                    module Builder =\n                        type Builder() =\n                            member inline __.Return      x                  = rtn     x\n                            member inline __.ReturnFrom  x                  = from    x\n                            member        __.Bind       (w , r )            = bind    r w\n                            member inline __.Zero       ()                  = rtn ()\n                            member inline __.Delay       f                  = f\n                            member inline __.Combine    (a, b)              = bind b a\n                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )\n                            member __.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member __.TryWith   (body, handler     ) = (fun (s,m) -> async.TryWith   (body() |> getFun <| (s, m),   handler                ) ) |> wrap\n                            member __.TryFinally(body, compensation) = (fun (s,m) -> async.TryFinally(body() |> getFun <| (s, m),   compensation           ) ) |> wrap\n                            member __.Using     (disposable, body  ) = (fun (s,m) -> async.Using((disposable:#System.IDisposable), fun u -> body u |> getFun <| (s, m)) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                    let fusion = Builder.Builder()\n                        \n                    \n                    \n                type ResultM<'v, 'm> = ResultM of Option<'v> * ResultMessage<'m>\n                \n                let inline OkM              v    = ResultM (Some v, NoMsg)\n                let inline OkMWithMsg       v m  = ResultM(Some v, m)\n                //let inline OkMWithMsgs      v ms = ms |> ResultMessage.reduceMsgs |> OkMWithMsg v\n                \n                let inline ErrorM             m  = ResultM (None  , m    )\n                //let inline ErrorMWithMsgs     ms = ms |> ResultMessage.reduceMsgs |> ErrorM\n                let (|OkM|ErrorM|)             r = match r with\n                                                    | ResultM(Some v, m) -> OkM   (v, m)\n                                                    | ResultM(None  , e) -> ErrorM e\n                module ResultM =\n                \n                    type CheckError<'T> = CheckErrorF of ('T -> bool)\n                    let checkError   () = CheckErrorF (fun _ -> true )\n                    let checkErrorW  () = CheckErrorF (fun _ -> false)\n                \n                    let inline rtn                 v = OkM v\n                    let inline rtnM                m = OkMWithMsg () m\n                    let inline rtnr               vR = vR  |> Result.map OkM          |> Result.defaultWith       ErrorM\n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    let inline toResult            r = match r with\n                                                       | ResultM(Some v, _) -> Ok     v\n                                                       | ResultM(None  , e) -> Error  e\n                    let inline toResultD           r = match r with\n                                                       | ResultM(Some v, m) -> Ok    (v, m)\n                                                       | ResultM(None  , e) -> Error  e\n                    let toOption                   r = r   |> function ResultM (v,_) -> v\n                    let defaultWith              f r = r   |> toResult |> Result.defaultWith   f\n                    let defaultValue             d r = r   |> toResult |> Result.defaultValue  d\n                    let map         f  (ResultM (v, m)) = ResultM (v |> Option.map f, m)\n                    let mapMessage  fM (ResultM (v, m)) = ResultM (v, fM m)\n                    let bind                  f    r = match r with\n                                                       | ResultM(Some v, m) -> f v |> mapMessage (ResultMessage.addMsg m)\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | ResultM(Some v, m) -> try f v |> mapMessage (ResultMessage.addMsg m)\n                                                                               with  e -> ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                                                       | ResultM(None  , e) -> ResultM(None  , e)\n                    let bindM                 f    m = rtnM m |> bindP f\n                \n                    let check (CheckErrorF k) vR = vR |> function ResultM(Some _, m) when ResultMessage.isFatalF k m -> ErrorM m |_-> vR\n                \n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m\n                    let iter                  fM f r = r   |> mapP f |> function | ResultM(Some (), m) -> () | ResultM(None, m) -> fM m  : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map OkM          |> Option.defaultWith (f >> ErrorM)\n                    let ofResult                  vR = vR  |> rtnr\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> OkM None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let addMsg                  m  r = r |> mapMessage (ResultMessage.addMsg m)\n                    let failIfFatalMsgF         f  r = r |> function OkM (v, m) when ResultMessage.isFatalF f m -> ErrorM m |_-> r\n                    let failIfFatalMsg             r = r |> function OkM (v, m) when ResultMessage.isFatal    m -> ErrorM m |_-> r\n                    let failIfFatalMsgW            r = r |> function OkM (v, m) when ResultMessage.isFatalW   m -> ErrorM m |_-> r\n                    let (>>=)                    r f = bind f r\n                    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline __.Return          x       = rtn  x\n                        member inline __.ReturnFrom      x       =     (x:ResultM<_,_>)\n                        member inline __.ReturnFrom      x       =     (x:Result< _,_>)\n                        member inline __.ReturnFrom      x       = rtnM x\n                        member        __.Bind           (w , r ) = bindP  r w\n                        member        __.Bind           (w , r ) = bindM  r w\n                        member inline __.Zero           ()       = rtn ()\n                        member inline __.Delay           f       = f\n                        member inline __.Combine        (a, b)   = a |> bind b\n                        member inline __.Run             f       = OkM () |> bindP f\n                        member __.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member __.TryFinally(body, compensation) = try body() finally   compensation()\n                        member __.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member __.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                \n                [< AutoOpen >]\n                module ResultMAutoOpen =\n                    open ResultM\n                    \n                    let resultM = Builder()\n                    \n                \n                \n                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResult =\n                    let mapError fE v  = v |> Async.map (Result.mapError fE)\n                    let freeMessage v  = v |> Async.map  Result.freeMessage\n                \n                    let rtn        v   = async.Return(Ok v  )\n                    let rtnR       vR  = async.Return    vR\n                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n                    let bind  fRA  vRA = async { \n                        let! vR       = vRA\n                        match   vR with\n                        | Ok    v -> return! fRA v\n                        | Error m -> return  Error m \n                    }\n                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | Ok    v -> return! fRA   v\n                            | Error m -> return  Error m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n                    }\n                    let inline map  f m = bind  (f >> rtn) m            \n                    let inline mapP f m = bindP (f >> rtn) m\n                    let inline getResult (v:AsyncResult<_,_>) = v |> Async.map Result.Ok\n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                       v f = bind f v\n                    let        traverseSeq         f sq = let folder tail head = f head >>= (fun h -> tail >>= (fun t -> Seq.append t (Seq.singleton h) |> rtn))\n                                                          Seq.fold folder  (rtn Seq.empty) sq\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    /// uses Async.RunSynchronously\n                    /// handleError - handles individual error messages. true = continue, false = stop\n                    [< Inline \"throw 'traverseSeqS cannot be used in JavaScript!'\" >]\n                    let traverseSeqS (f: 't->AsyncResult<'u, _>) handleError (t: 't seq)  = async {\n                        let! ct = Async.CancellationToken\n                        return seq {\n                                use enum = t.GetEnumerator ()\n                                let mutable stillOk = true\n                                while enum.MoveNext() do\n                                    match Async.RunSynchronously (f enum.Current, cancellationToken = ct) with\n                                    | Ok v -> yield v\n                                    | Error msg -> stillOk <- handleError msg\n                                } \n                            |> Ok\n                        }\n                    let inline sequenceSeqS          sq = traverseSeqS id sq\n                    let insertO   vRAO                  = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)     = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                  = vRRA |> Async.map  Result.join\n                    let absorbO f vORA                  = vORA |> Async.map (Result.absorbO  f)\n                \n                    let tryWith    hnd (fRA:unit -> AsyncResult<_,_>) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                    let tryFinally fn  (fRA:unit -> AsyncResult<_,_>) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                \n                \n                type AsyncResultBuilder() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                            = fRA\n                    member __.Run              fRA                            = AsyncResult.rtn () |> AsyncResult.bind fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                    th.While(enum.MoveNext,\n                                                                                      th.Delay(fun () -> fRA enum.Current)))\n                let asyncResult = AsyncResultBuilder()\n                \n                type AsyncResultBuilderP() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                                          = fRA\n                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                              th.While(enum.MoveNext,\n                                                                                                th.Delay(fun () -> fRA enum.Current)))\n                let asyncResultP = AsyncResultBuilderP()\n                \n                [<AutoOpen>]\n                module Extensions =      \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultBuilder with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                \n                    type AsyncResultBuilderP with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n                \n                \n                \n                type AsyncResultM<'v, 'm> = Async<ResultM<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResultM =\n                    let mapError fE v  = v |> Async.map (ResultM.mapMessage fE)\n                    let freeMessage v  = v |> Async.map  ResultM.freeMessage\n                \n                    let rtn         v   = async.Return(OkM v  )\n                    let rtnr        vR  = async.Return(ResultM.rtnr vR)\n                    let rtnR        vR  = async.Return    vR\n                    let rtnM        vM  = async.Return(ResultM.rtnM vM)\n                    let rtnrA       vrA = vrA |> Async.map    ResultM.ofResult\n                    let errorMsgf   fmt = Printf.ksprintf (ErrorMsg >> ErrorM >> async.Return) fmt\n                    let iterS  fE f vRA = Async.iterS (ResultM.iter fE f) vRA\n                    let iterA  fE f vRA = Async.iterA (ResultM.iter fE f) vRA\n                    let iterpS    f vRA = vRA |> iterS (ResultMessage.summarized >> print) f\n                    let iterpA    f vRA = vRA |> iterA (ResultMessage.summarized >> print) f\n                    let bind  (fRA:'a -> Async<ResultM<'b,'c>>)  (vRA: Async<ResultM<'a,'c>>) : Async<ResultM<'b,'c>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | OkM   (v, m) -> return! fRA   v |> Async.map (ResultM.addMsg m)\n                            | ErrorM    m  -> return  ErrorM m\n                        with  e -> return ExceptMsg (e.Message, e.StackTrace) |> ErrorM\n                    }\n                    let inline bindr  f a  = rtnr   a |> bind f : AsyncResultM<_,_>\n                    let inline bindM  f a  = rtnM   a |> bind f : AsyncResultM<_,_>\n                    let inline bindrA f a  = rtnrA  a |> bind f : AsyncResultM<_,_>\n                    let inline bindR  f a  = rtnR   a |> bind f : AsyncResultM<_,_>\n                    let inline map    f m = bind  (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map (ResultM.bindP   id)\n                    let absorbO f vORA                         = vORA |> Async.map (ResultM.absorbO  f)\n                    let getResultM       (a:AsyncResultM<_,_>) = a    |> Async.map  OkM   \n                    type AsyncResultMBuilder() =\n                        member __.ReturnFrom vRA        : Async<ResultM<'v  , 'm>> =           vRA\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnr      vR\n                        member __.ReturnFrom vR         : Async<ResultM<unit, 'm>> = rtnM      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnR      vR\n                        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnrA     vR\n                        member __.Return     v          : Async<ResultM<'v  , 'm>> = rtn       v  \n                        member __.Zero       ()         : Async<ResultM<unit, 'm>> = rtn       () \n                        member __.Bind      (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Bind       (w , r )                              = bindr   r w\n                        member __.Bind       (w , r )                              = bindM   r w\n                        member __.Bind       (w , r )                              = bindR   r w\n                        member __.Bind       (w , r )                              = bindrA  r w\n                        member __.Combine   (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\n                        member __.Combine   (vR ,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA (vR  |> rtnR)\n                        member __.Delay            fRA                             = fRA\n                        member __.Run              fRA                             = rtn () |> bind fRA\n                        member __.TryWith   (fRA , hnd) : Async<ResultM<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                        member __.TryFinally(fRA , fn ) : Async<ResultM<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                        member __.Using(resource , fRA) : Async<ResultM<'a  , 'm>> = async.Using(resource,       fRA)\n                        member __.While   (guard , fRA) : Async<ResultM<unit, 'a>> = whileLoop guard fRA \n                        member th.For  (s: 'a seq, fRA) : Async<ResultM<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fRA enum.Current)))\n                \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>->) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                \n                [<AutoOpen>]\n                module AsyncResultMAutoOpen =\n                    open AsyncResultM\n                \n                    let asyncResultM = AsyncResultMBuilder()\n                \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultMBuilder with\n                    member __.ReturnFrom (vA: Async<_>     ) : Async<ResultM<_,_>> =           Async.map OkM vA\n                    member __.Bind       (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                    member __.Combine    (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\n                \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from >= this.Length then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = if n < 0 \n                                                  then this.Substring2(0, this.Length + n)\n                                                  else this.Substring2(0, n              )\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n                //member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let left  n (s:string) = s.Left  n\n                let right n (s:string) = s.Right n\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                let (|WhiteSpace|_|) (s:string) = if s |> Seq.exists (System.Char.IsWhiteSpace >> not) then None else Some()\n                \n                let thousands n =\n                    let v = (if n < 0 then -n else n).ToString()\n                    let r = v.Length % 3 \n                    let s = if r = 0 then 3 else r\n                    [   yield v.[0.. s - 1]\n                        for i in 0..(v.Length - s)/ 3 - 1 do\n                            yield v.[i * 3 + s .. i * 3 + s + 2]\n                    ] \n                    |> String.concat \",\"\n                    |> fun s -> if n < 0 then \"-\" + s else s\n            \n            \n            [< Inline \"$a + '/' + $b\" >]\n            let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n            \n            \n                /// Javascript adds time zone information when parsing a date and that can change the result\n                let parseDateO2  = (fun s -> s + \"T00:00:00\") >> tryParseWith System.DateTime.TryParse\n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseInt64O  = tryParseWith System.Int64   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Int64 |_|) = parseInt64O\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun msg -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n            type ResourceAgentState<'R, 'C> = {\n                useCount      : int\n                limitCount    : int\n                resource      : 'R\n                configuration : 'C\n            }\n            \n            type ResourceAgent<'R, 'C when 'C : equality>(maxUseCount, ctor: 'C -> 'R, configuration, ?cleanup, ?isAlive, ?respawnAfter) =\n                let clean                          = defaultArg cleanup ignore\n                let alive                          = defaultArg isAlive (fun _ -> true)\n                let initConfig                     = configuration\n                let respawnRightAfter              = defaultArg respawnAfter true\n                let respawn                  state = clean state.resource\n                                                     { state with useCount = 0 ; resource = ctor state.configuration }\n                let check                cfg state = if state.useCount < state.limitCount && alive state.resource && cfg = state.configuration\n                                                     then state \n                                                     else respawn { state with configuration = cfg }\n                let increment                state = { state with useCount = state.useCount + 1 }\n                                                     |> if respawnRightAfter then (check state.configuration) else id\n                let agent                          = Mailbox.stateFull (fun ex st -> print ex ; respawn st)  \n                                                        {   useCount      = 0\n                                                            limitCount    = maxUseCount\n                                                            configuration = initConfig\n                                                            resource      = ctor initConfig\n                                                        }\n                member __.AsyncProcessA(work,?cfg) = agent \n                                                    |> Mailbox.StateFull.applyReplyA(fun st -> async { \n                                                         let  st2 = st |> check (defaultArg cfg st.configuration) \n                                                         let! res = work st2.resource\n                                                         return increment st2, res \n                                                     })\n                member oo.ProcessA     (work,?cfg) = oo.AsyncProcessA((fun v -> async { return work v }), ?cfg=cfg)\n                [< Inline \"throw 'ResourceAgent.Process not available in JavaScript'\" >]\n                member oo.Process      (work,?cfg) = oo.ProcessA(work, ?cfg=cfg) |> Async.RunSynchronously\n                member __.State                    = agent |> Mailbox.StateFull.getState\n                member oo.LimitCount    with get() = oo.State.limitCount\n                member oo.Configuration with get() = oo.State.configuration\n                member __.LimitCount    with set n = agent |> Mailbox.StateFull.apply(fun s -> { s with limitCount    = n })\n                member oo.Configuration with set c = if c <> oo.Configuration then agent |> Mailbox.StateFull.apply(fun s -> respawn { s with configuration = c})\n                member __.Respawn               () = agent |> Mailbox.StateFull.apply respawn\n                interface System.IDisposable with\n                    member this.Dispose () = try clean this.State.resource with _ -> ()\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            module AgentReaderM =\n                open FusionAsyncM\n                open Operators\n            \n                let createAgentRm                         f  v = readerFun(fun  (agent:ResourceAgent<_,_>, cfg)     -> agent.AsyncProcessA((fun resource -> f resource v)  , cfg) ) >>= ofAsync\n                let ofResourceRm                     (FAM f)   = FAM      (fun ((agent:ResourceAgent<_,_>, cfg), m) -> \n                                                                            agent.AsyncProcessA((fun resource -> async {\n                                                                                    let! vO, _, m = f(resource, m) \n                                                                                    return vO, (agent, cfg), m \n                                                                                }), cfg) \n                                                                            )\n                let run            agent cfg                 m = runReader (agent,       cfg          ) m\n                let runSameConfig (agent:ResourceAgent<_,_>) m = runReader (agent, agent.Configuration) m\n            \n            [< AutoOpen >]\n            module CommArgRoot =\n                open FusionM\n                open Operators\n            \n                type CommArgId = CommArgId of System.Guid\n                \n                type CommArg = {\n                    cargId : CommArgId\n                    name   : string\n                    unique : bool\n                    build  : obj -> string\n                }\n                type CommArgValue<'T,  'M> = FusionM<'T, CommArgCollection<     'M>, 'M>\n                and  ArgValueTuple<    'M> = CommArg *   CommArgValue<obj,      'M>\n                and  CommArgCollection<'M> = CommArgCollection of ArgValueTuple<'M> seq\n                    with \n                        member oo.CommArgs = match oo with CommArgCollection v -> v\n            \n                let CommArgCollection agvts = Seq.cache agvts |> CommArgCollection\n            \n                type TypedCommArg<'T> = TypedCommArg of CommArg\n                    with\n                    member oo.CommArg = match oo with TypedCommArg v -> v\n                    static member (/=) (arg: TypedCommArg<'T>, v:                        'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, rtn v        |>> box)\n                    static member (/=) (arg: TypedCommArg<'T>, v: CommArgValue<          'T, _>) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg,     v        |>> box)\n                    static member (/=) (arg: TypedCommArg<'T>, f: CommArgCollection<'M>->'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, getS() |>> f |>> box)\n                \n                module CommArg  =\n                    let New (name, unique, build: 'T -> _) : TypedCommArg<'T> = \n                        {\n                            cargId = CommArgId <| System.Guid.NewGuid()\n                            name   = name\n                            unique = unique\n                            build  = unbox >> build\n                        }  |> TypedCommArg\n                    let NewInt   (name, unique, build) : TypedCommArg<int   > = New(name, unique, build)\n                    let NewString(name, unique, build) : TypedCommArg<string> = New(name, unique, build)\n                    let NewBool  (name, unique, build) : TypedCommArg<bool  > = New(name, unique, build)\n                    let NewFloat (name, unique, build) : TypedCommArg<float > = New(name, unique, build)\n                    let argumentRm (a:CommArg) (vRm:CommArgValue<obj,_>) = fusion {\n                        let! v = vRm\n                        let  r = a.build v\n                        return r\n                    }\n                    let inline argumentTRm (a,v) = argumentRm a v\n                    let getVRm (a: TypedCommArg<'T>) (vRm:CommArgValue<obj,_>) : FusionM<'T,_,_> = vRm |>> unbox\n                    let        internal getValueR (a: TypedCommArg<'T>) (o:obj) : Result<'T,_> = unbox<'T> o |> Ok\n                    let inline internal getIntR    a o : Result<int   ,_> = getValueR a o\n                    let inline internal getStringR a o : Result<string,_> = getValueR a o\n                    let inline internal getBoolR   a o : Result<bool  ,_> = getValueR a o\n                    let inline internal getFloatR  a o : Result<float ,_> = getValueR a o\n                \n                module CommArgCollection =\n                \n                    let trueForAll                        _ = true\n                    let contains      (TypedCommArg arg) (CommArgCollection args) = args |> Seq.map (fun (a,_) -> a.cargId) |> Seq.contains arg.cargId\n                    let argsRm                           () = readerFun(fun (CommArgCollection args) -> args                 )\n                    let existsRm                          f = readerFun(fun (CommArgCollection args) -> args |> Seq.exists f )\n                    let filterRm                          p = readerFun(fun (CommArgCollection args) -> args |> Seq.filter p )\n                    let argumentsRm                  filter = filterRm filter >>= traverseSeq CommArg.argumentTRm |>> Seq.filter ((<>) \"\")\n                    let containsAnyOfRm (ids:CommArgId Set) = readerFun(fun (CommArgCollection args) -> args |> Seq.exists (fun (a,_) -> Set.contains a.cargId ids) )\n                    let argumentNotFound  targ = fun () -> match targ with | TypedCommArg arg -> sprintf \"argument not found: %s\" arg.name |> ErrorMsg\n                    let tryFindArgO   (TypedCommArg arg) (CommArgCollection args) = Seq.tryFind (fun (a,_) -> a.cargId = arg.cargId) args \n                    let tryFindArgORm     targ = readerFun(fun coll -> tryFindArgO targ coll |> Option.map insertFst |> insertO) >>= id\n                    let tryGetValueORm    targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getValueR  targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetIntORm      targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getIntR    targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetStringORm   targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getStringR targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetBoolORm     targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getBoolR   targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryGetFloatORm    targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getFloatR  targ o)) |>> Result.insertO >>= ofResultRM\n                    let tryBuildArgORm    targ = tryFindArgORm   targ |>> (Option.map (fun (c, o) -> c.build                 o)) \n                    let findArgRm         targ = tryFindArgORm   targ >>= ofOption (argumentNotFound targ)\n                    let getValueRm        targ = tryGetValueORm  targ >>= ofOption (argumentNotFound targ)\n                    let getIntRm          targ = tryGetIntORm    targ >>= ofOption (argumentNotFound targ)\n                    let getStringRm       targ = tryGetStringORm targ >>= ofOption (argumentNotFound targ)\n                    let getFloatRm        targ = tryGetFloatORm  targ >>= ofOption (argumentNotFound targ)\n                    let getBoolRm   def   targ = tryGetBoolORm   targ |>> Option.defaultValue def\n                    let buildArgRm        targ = tryBuildArgORm  targ >>= ofOption (argumentNotFound targ)\n                    //[< Inline \"throw 'getBoolR not available in JavaScript'\" >]\n                    let getBoolR def targ args = getBoolRm def targ |> run args |> fun (bO, _, m) -> bO |> Result.ofOption (fun () -> m)   //|> Async.RunSynchronously //|> Result. Option.defaultValue false\n                \n                    let addPair(commArg:CommArg, vRm:FusionM<obj, CommArgCollection<_>, _>) (CommArgCollection args) =\n                        args\n                        |> if commArg.unique then Seq.filter (fun (a,_) -> a.cargId <> commArg.cargId) else id\n                        |> Seq.append <| [ commArg, vRm ]\n                        |> Seq.toArray\n                        |> Seq.ofArray\n                        |> CommArgCollection\n                    let append (args1: CommArgCollection<'M>) (args2: CommArgCollection<'M> ) = args2.CommArgs |> Seq.fold (swap (unbox >> addPair)) args1\n                    let addPairs pairs collection = append collection (CommArgCollection pairs)\n            \n                    let appendRm args2 = fusion {\n                        let! args1 = getS()\n                        do!         putS(append args1 args2)\n                    }\n                    let addPairsRm pairs = fusion {\n                        let! args = getS()\n                        do!         putS(addPairs pairs args)\n                    }\n                        \n                //    let produceRm = ReaderM(fun (CommArgCollection args) ->\n                //        args\n                //        |> ReaderM.traverseSeq (fun (a, vRm) -> CommArg.produceRm a vRm |> ReaderM.map (fun v -> a, v))\n                //        |> ReaderM.map Seq.toArray\n                //        |> ReaderM.run (CommArgCollection args)\n                //    )\n                \n                type  CommArgCollection<'M> with\n                    static member (+) (args: CommArgCollection<_>, args2                    ) = args |> CommArgCollection.addPairs args2\n                    static member (+) (args: CommArgCollection<_>, arg                      ) = args |> CommArgCollection.addPair  arg  \n                    static member (+) (args: CommArgCollection<_>, (CommArgCollection args2)) = args |> CommArgCollection.addPairs args2\n                \n                \n            type FsCode = FsCode of string\n            \n            module FsCode =\n                open System\n            \n                type PreproDirective =\n                | PrepoCd     of string\n                | PrepoR      of string\n                | PrepoDefine of string\n                | PrepoLoad   of string\n                | PrepoLine   of string //* int\n                | PrepoNoWarn of string\n                | PrepoI      of string\n                | PrepoIf     of string\n                | PrepoElIf   of string\n                | PrepoElse   \n                | PrepoEndIf\n                | PrepoLight  of bool\n                | PrepoOther  of string\n                | NoPrepo\n                \n                let extractDefines(FsCode code) = \n                    if code.StartsWith \"////-d:\" \n                    then code.[4.. (match code.IndexOf '\\n' with -1 -> code.Length | n -> n)  - 1]\n                    else \"\"\n            \n                let separatePrepros (code:string[]) =\n                    let  quoted (line:string) = line.Trim().Split([| \"\\\"\" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n                    let  rest   (line:string) = line.Trim() |> String.splitInTwoO \" \" |> Option.map snd |> Option.defaultValue \"\" |> fun s -> s.Trim()\n                    let  comment = ((+)\"//\") \n                    let  prepro (line:string) = \n                        match true with \n                        | true when line       .StartsWith(\"#define\") -> (comment line, line |> rest   |> PrepoDefine)\n                        | true when line       .StartsWith(\"#cd\"    ) -> (comment line, line |> quoted |> PrepoCd    )\n                        | true when line       .StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                        | true when line       .StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                        | true when line       .StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                        | true when line.Trim().StartsWith(\"# \"     ) -> (comment line, line |> quoted |> PrepoLine  )\n                        | true when line.Trim().StartsWith(\"#line\"  ) -> (comment line, line |> quoted |> PrepoLine  )\n                        | true when line       .StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                        | true when line       .StartsWith(\"#if\"    ) -> (        line, line |> rest   |> PrepoIf    )\n                        | true when line       .StartsWith(\"#elif\"  ) -> (        line, line |> rest   |> PrepoElIf  )\n                        | true when line       .StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                        | true when line       .StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                        | true when line       .StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                        | true when line       .StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                        | _                                           -> (        line,                   NoPrepo    ) \n                    code |> Array.map prepro\n            \n                type PrepState = \n                | LevelZero\n                | TrueValue of PrepState\n                | Looking   of PrepState\n                | Found     of PrepState\n            \n                let isActive = function\n                | LevelZero\n                | TrueValue _ -> true\n                | Looking   _ -> false\n                | Found     _ -> false\n            \n                let prev = function\n                | LevelZero    -> LevelZero\n                | TrueValue pr -> pr\n                | Looking   pr -> pr\n                | Found     pr -> pr\n            \n                let filterPreps (preps:PreproDirective seq) =\n                    let  defines  = preps |> Seq.choose (function | PrepoDefine d -> Some d | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let isDefined (def:string) =    defines |> Seq.contains (def.Replace(\"!\",\"\").Trim()) |> (if def.Trim().StartsWith \"!\" then not else id)\n                    (LevelZero, preps) \n                    ||> Seq.mapFold(fun st prep ->\n                        match st, prep with\n                        | TrueValue _ , PrepoIf    def             \n                        | LevelZero   , PrepoIf    def -> None     , if isDefined def then TrueValue st else Looking st\n                        | Looking   _ , PrepoIf    _             \n                        | Found     _ , PrepoIf    _   -> None     , Found st\n                        |           _ , PrepoEndIf     -> None     , prev  st\n                        | TrueValue pr, PrepoElIf  _\n                        | TrueValue pr, PrepoElse      -> None     , Found     pr\n                        | Looking   pr, PrepoElIf  def -> None     , if isDefined def then TrueValue st else Looking pr\n                        | Looking   pr, PrepoElse      -> None     , TrueValue pr\n                        | Found     pr, PrepoElIf  _\n                        | Found     pr, PrepoElse      -> None     , Found     pr\n                        | TrueValue _ , _             \n                        | LevelZero   , _              -> Some prep, st\n                        | _                            -> None     , st\n                        )\n                    |>  fst\n                    |>  Seq.choose id\n                    |>  Seq.toArray\n            \n                let getTopDirectives (fsNass:(string * PreproDirective) seq) =\n                    let definesFirstLine = \n                        Seq.tryHead fsNass \n                        |> Option.map (fst >> FsCode >> extractDefines>> fun s-> s.Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) ) \n                        |> Option.defaultValue [||]\n                        |> Seq.map PrepoDefine\n                    let  directs  = fsNass |> Seq.map snd |> Seq.filter (function \n                                        | PrepoDefine _\n                                        | PrepoR      _ \n                                        | PrepoI      _\n                                        | PrepoNoWarn _\n                                        | PrepoCd     _ \n                                        | PrepoIf     _\n                                        | PrepoEndIf  \n                                        | PrepoElIf   _\n                                        | PrepoElse    -> true\n                                        |_             -> false) \n                                        |> Seq.append definesFirstLine\n                                        |> Seq.toArray\n                    let  code     = fsNass |> Seq.map fst |> Seq.toArray\n                    code, directs\n                    \n                let separateDirectives (fsNass:PreproDirective seq) =\n                    let  defines  = fsNass |> Seq.choose (function | PrepoDefine d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  preps    = filterPreps fsNass\n                    let  assembs  = preps  |> Seq.choose (function | PrepoR      assemb -> Some assemb | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  prepoIs  = preps  |> Seq.choose (function | PrepoI      d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  nowarns  = preps  |> Seq.choose (function | PrepoNoWarn d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray\n                    let  cd       = preps  |> Seq.choose (function | PrepoCd     dir    -> Some dir    | _ -> None) |> Seq.tryHead\n                    assembs, defines, prepoIs, nowarns, cd\n                    \n                let getSourceDir srcDir (lines:string[]) =\n                    match lines.[0], Array.tryItem 1 lines with\n                    |         String.StartsWith \"////#cd @\\\"\" dirq, _ \n                    | _, Some(String.StartsWith \"////#cd @\\\"\" dirq) ->  dirq.Trim()\n                                                                        |> function\n                                                                        | String.EndsWith \"\\\"\" dir\n                                                                        |                      dir ->\n                                                                        match dir with\n                                                                        | String.StartsWith \"\\\\\" _\n                                                                        | String.StartsWith \"/\"  _            -> dir\n                                                                        | _ when Seq.tryItem 1 dir = Some ':' -> dir\n                                                                        | _ -> srcDir  +/+                       dir\n                    | _                                                     -> srcDir\n            \n            \n            type SnippetId = SnippetId of System.Guid with member x.Id = match x with SnippetId id -> id\n                                                           static member Empty = SnippetId System.Guid.Empty\n            \n            type Snippet = {\n                snpId           : SnippetId    \n                snpName         : string\n                snpContent      : string\n                snpParentIdO    : SnippetId option\n                snpPredIds      : SnippetId Set\n                snpProperties   : (string* string) []\n                snpModified     : System.DateTime\n            }\n            \n            type SnippetReference =\n            | RefSnippetId   of SnippetId\n            | RefSnippetPath of string[]\n            \n            type Reduced = ((SnippetId * string * int * int) [] * string [] * FsCode.PreproDirective [] ) option\n            \n            type SnippetCollection = {\n                generation       : System.DateTime\n                ordered          : Snippet seq\n                fetcher          : SnippetId -> Snippet Option\n                predecesorsCache : unit -> ((SnippetId -> SnippetId list option) * (SnippetId -> (SnippetId -> SnippetId list) -> SnippetId list))\n                reducedCache     : unit -> (((bool * SnippetId * Set<SnippetId>) -> Reduced option) * ((bool * SnippetId * Set<SnippetId>) -> ((bool * SnippetId * Set<SnippetId>) -> Reduced) -> Reduced))\n                prepCode         : Snippet -> string                             \n            }\n            \n            module Snippet =\n                open System\n                open FusionM\n                open Operators\n            \n                let getNextModified() = DateTime.Now\n                //let getNextGeneration, setGeneration = \n                //    let mutable generation  = 1\n                //    (fun () -> generation <- generation + 1 ; generation)\n                //  , (fun n  -> generation <- n                          )  \n                let New name content parentO = \n                    {\n                        snpId           = SnippetId <| System.Guid.NewGuid()   \n                        snpName         = name\n                        snpContent      = content\n                        snpParentIdO    = parentO\n                        snpPredIds      = Set.empty\n                        snpProperties   = Array.empty\n                        snpModified     = getNextModified()\n                    }\n                let defaultSnippet              = {\n                    snpId           = SnippetId <| System.Guid.Empty\n                    snpName         = \"\"\n                    snpContent      = \"\"\n                    snpParentIdO    = None\n                    snpPredIds      = Set.empty\n                    snpProperties   = Array.empty\n                    snpModified     = Utc1970_01_01\n                }    \n                let snippetName name (content: string) =\n                    if name <> \"\" then name else \n                    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n                    |> Seq.map    (fun l -> l.Trim())\n                    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n                    |> Seq.tryHead\n                    |> Option.defaultValue \"<empty>\"    \n                let nameSanitized snp =\n                    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                                    '\\\\'  ; '/'|] //\"\n                    snp.snpName \n                    |> String.filter (fun c -> not <| Array.contains c illegal)\n                    |> fun c -> c + \" \" + snp.snpId.Id.ToString()\n                let propertyO       n snp = snp.snpProperties |> Array.tryPick (fun (name, value) -> if name = n then Some value else None)\n                let tieFighter            = \"|\" + \"-\" + \"|\"\n                let propertyPair      prv = (prv:string).Split([| tieFighter |], StringSplitOptions.None) |> fun vs -> vs.[0], vs |> Array.tryItem 1 |> Option.defaultValue vs.[0]\n                let propertyPairO   n snp = propertyO n snp |> Option.map propertyPair\n                let snippetORm        sid = readerFun (fun { fetcher    = ftch } -> ftch sid                                               )\n                let parentORm         snp = readerFun (fun { fetcher    = ftch } -> snp.snpParentIdO |> Option.bind ftch                   )\n                let predecessorsRm    snp = readerFun (fun { fetcher    = ftch } -> snp.snpPredIds   |> Seq.choose  ftch                   )\n                let maxGenerationRm   ()  = readerFun (fun { ordered    = snps } -> snps |> Seq.map (fun s -> s.snpModified  ) |> Seq.max  )\n                let modifiedRm        snp = readerFun (fun { generation = gen  } -> snp.snpModified   > gen                                )\n                let childrenRm        sid = readerFun (fun { ordered    = snps } -> snps |> Seq.filter(fun s -> s.snpParentIdO = Some sid) )\n                let orderedRm         ()  = readerFun (fun { ordered    = snps } -> snps                                                   )\n                let prepareCodeRm     snp = readerFun (fun { prepCode   = prep } -> prep snp                                               )\n                let snippetRm         sid = snippetORm sid |> absorbO (fun () -> sprintf \"Snippet not found %A\" sid |> ErrorMsg)\n                let snippetNameRm     sid = snippetRm  sid |>> (fun snp -> snippetName snp.snpName snp.snpContent)\n                let rec pathRm        sid = snippetORm sid \n                                            |>> Option.map parentORm \n                                            >>= insertO \n                                            |>> Option.bind id\n                                            |>> Option.map (fun prn -> pathRm prn.snpId |>> fun rest -> prn.snpId :: rest ) \n                                            >>= insertO \n                                            |>> Option.defaultValue []\n                let snippetFromPathORm pth = fusion {\n                    let! snps = orderedRm()\n                    return\n                        snps\n                        |> Seq.mapFold (fun (path, prntO) snp -> \n                                           if path |> Array.length = 0                       then None    , ([||]      , prntO         ) else\n                                           let name = snippetName snp.snpName snp.snpContent\n                                           if  name <> path.[0] || snp.snpParentIdO <> prntO then None    , (path      , prntO         ) else\n                                           if path |> Array.length > 1                       then None    , (path.[1..], Some snp.snpId) else\n                                                                                                  Some snp, ([||]      , prntO         )                               \n                                       ) \n                                       (pth, None)\n                        |> fst\n                        |> Seq.choose id\n                        |> Seq.tryHead\n                }\n                let snippetFromRefORm     = function\n                                            | RefSnippetId   sid -> snippetORm         sid\n                                            | RefSnippetPath pth -> snippetFromPathORm pth\n                let predsLRm (sid : SnippetId) = fusion {\n                        let mutable ins  = [sid]  \n                        let mutable outs = [   ]\n                        while not ins.IsEmpty do\n                            match ins with\n                            | []         -> ()\n                            | hd :: rest -> if outs |> List.contains hd then\n                                                ins  <- rest\n                                            else\n                                                let! snpO  = snippetORm hd\n                                                let  preds = snpO \n                                                             |> Option.map(fun snp -> Seq.toList snp.snpPredIds @ Option.toList snp.snpParentIdO ) \n                                                             |> Option.defaultValue []\n                                                ins  <- rest @ preds\n                                                outs <- hd::outs\n                        return outs\n                    }\n                let predsLRmMemo()        = memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n            //    let predsLRmMemo<'m>  : SnippetId -> ReaderMResult<SnippetId list,SnippetCollection,'m>        \n            //        = ReaderM.memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n            //#if FIX_GENERIC\n            //    (predsLRmMemo : (SnippetId -> Monads.ReaderMonads.ReaderMResult<SnippetId list,SnippetCollection,string>) )\n            //#endif    \n                let uniquePredsRm     snp = predsLRmMemo() snp.snpId\n                let predsGenerationRm snp = fusion {\n                                                let! preds = uniquePredsRm snp >>= traverseSeq snippetRm\n                                                return preds (* |> Seq.append [ snp ] *) |> Seq.map (fun snp -> snp.snpModified  ) |> Seq.max \n                                            }\n                let rec modifiedRecRm snp = fusion {\n                    let! modified         = modifiedRm     snp\n                    if modified then return true else\n                    let! predIds          = uniquePredsRm  snp\n                    let! predOs           = predIds |> Seq.map snippetORm                  |> sequenceSeq\n                    let! mods             = predOs  |> Seq.choose id |> Seq.map modifiedRm |> sequenceSeq\n                    return Seq.contains true mods\n                }\n                let rec propertyHierORm n snp = fusion {\n                    match propertyO n snp with\n                    | Some v -> return Some (snp, propertyPair v)\n                    | None   -> let! parentO = parentORm   snp\n                                match parentO with\n                                | Some p -> let!   propO = propertyHierORm n p\n                                            return propO |> Option.map(fun (sn, (_, next)) -> sn, (next, next) )\n                                | None   -> return None\n                }\n                let indentRm          snp =\n                    let rec indentMeChildNextRm          snp = fusion {\n                        let  propIndentChildren = \"IndentChildren\"\n                        let  currO, nextO       = propertyPairO propIndentChildren snp |> function Some (curr, next) ->  ParseO.parseIntO curr, ParseO.parseIntO next | _-> None, None \n                        let! parentO            = parentORm   snp\n                        match parentO with\n                        | Some p -> let! _, (me, next) = indentMeChildNextRm p\n                                    return me, (me + (currO |> Option.defaultValue next), nextO |> Option.defaultValue next)\n                        | None   -> return 0 , (      currO |> Option.defaultValue 4    , nextO |> Option.defaultValue 4   )\n                    }\n                    indentMeChildNextRm snp |>> fst\n                let levelRm           snp = \n                    let rec levelRm2 snp lv = fusion {\n                        let!  parentO = parentORm snp\n                        match parentO with\n                        | None   -> return  lv\n                        | Some p -> return! levelRm2 p (lv + 1)\n                    }\n                    levelRm2 snp 0\n                let ancestorsRm   snp = \n                    let rec  ancestorsRm2 snp lst = fusion {\n                        let! parentO = parentORm snp\n                        match parentO with\n                        | Some p -> return! ancestorsRm2 p <| p::lst\n                        | None   -> return  lst\n                    }\n                    ancestorsRm2 snp []\n                let separateCodeRm snp = fusion {\n                    let! indent        = indentRm snp\n                    let  indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n                    let! code          = prepareCodeRm snp\n                    //let  name          = nameSanitized snp\n                    let  code, directs =\n                        code.Split('\\n')\n                        |> FsCode.separatePrepros\n                        |> indentF\n                        |> FsCode.getTopDirectives\n                    return\n                        [| snp.snpId, snippetName snp.snpName snp.snpContent, code.Length, indent |] , code, directs\n                }\n                let addSeps (lines1:(SnippetId*string*int*int)[], code1:string[], directs1:FsCode.PreproDirective[])\n                            (lines2:(SnippetId*string*int*int)[], code2:string[], directs2:FsCode.PreproDirective[]) =\n                    Array.append lines1   lines2\n                  , Array.append code1    code2\n                  , Array.append directs1 directs2\n                let reducedCodeRm  snippets = fusion {\n                    let! parts    = snippets |> traverseSeq separateCodeRm\n                    let  reduced  = parts\n                                    |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||] ] else snps\n                                    |> Seq.reduce addSeps\n                                    |> fun (lines, code                                         , directs) ->\n                                           (lines, code |> String.concat \"\\n\" |> Array.singleton, directs)\n                    return reduced\n                }\n                let finishCode (lines:(SnippetId*string*int*int)[],code:string[], directs:FsCode.PreproDirective[]) =\n                    let assembs, defines, prepIs, nowarns, cdO = FsCode.separateDirectives directs\n                    let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n                    let part1  =\n                      [ if config <> \"\" then yield \"////\" + config\n                        if cdO.IsSome   then yield sprintf \"////#cd @\\\"%s\\\"\" cdO.Value\n                        yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n                        yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n                        yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\" )\n                      ]\n                    Seq.append part1 code |> String.concat \"\\n\"\n                  , lines \n                    |> Seq.mapFold (fun firstLine (id, name, len, ind) -> ((id, name), (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n                    |> fst\n                    |> Seq.toArray\n                //let codeAndStartsRm   snpIds = reader {\n                //    let! snippets = orderedRm() |>> Seq.filter(fun snp -> snpIds |> Seq.contains snp.snpId)\n                //    let! reduced  = reducedCodeRm snippets\n                //    return finishCode reduced\n                //}\n                //let codeFsxRm         snippets = codeAndStartsRm snippets |> ReaderM.map fst\n                let reducedOthersORm (before, snpId, snpIds) = fusion {\n                    let  skipTake = if before then Seq.takeWhile else Seq.skipWhile\n                    let! snippets = orderedRm() |>> skipTake (fun snp -> snp.snpId <> snpId) |>> Seq.filter(fun snp -> snp.snpId <> snpId && snpIds |> Set.contains snp.snpId) \n                    if snippets |> Seq.isEmpty then return None else\n                    let! reduced = reducedCodeRm snippets\n                    return Some reduced\n                }\n                let reducedOthersORmMemo() = memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n            //    let reducedOthersORmMemo<'m> : bool * SnippetId * Set<SnippetId> -> ReaderMResult<Reduced,SnippetCollection,'m> \n            //        = ReaderM.memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n                let fastReducedRm  curIdO lastIdO = fusion {\n                    let!  curSnippetO  = curIdO  |> Option.map snippetORm |> insertO\n                    let! lastSnippetO  = lastIdO |> Option.map snippetORm |> insertO\n                    match (Option.bind id curSnippetO, Option.bind id lastSnippetO) with\n                    | _              , None\n                    | None           , _                -> return! reducedCodeRm Seq.empty\n                    | Some curSnippet, Some lastSnippet ->\n                    let! preds = uniquePredsRm lastSnippet\n                    let  preds = Set preds\n                    let! reducedBeforeO = reducedOthersORmMemo() (true , curSnippet.snpId, preds)\n                    let! reducedAfterO  = reducedOthersORmMemo() (false, curSnippet.snpId, preds)\n                    let! currentCode    = separateCodeRm           curSnippet\n                    let part1 = reducedBeforeO |> Option.map (swap addSeps currentCode) |> Option.defaultValue currentCode\n                    return      reducedAfterO  |> Option.map (     addSeps part1      ) |> Option.defaultValue part1\n                }\n                let fastCodeRm  curIdO lastIdO = fusion {\n                    let! reduced  = fastReducedRm curIdO lastIdO\n                    return finishCode reduced\n                }\n                let codeFsxRm    curId = fastCodeRm  (Some curId) (Some curId) |>> fst\n                \n            /// Adapted from here http://fssnip.net/7V5   Usage:\n            /// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n            ///         \n            /// abs  1 |> printfn \"%A\" // 1\n            /// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\n            type Hole = Hole with\n                [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n                static member inline Incomplete id : 'T = failwithf \"Incomplete hole '%s'\" id        \n                    \n            \n            /// Tree structure to implement a hierarchical user interface but using readerMonad\n            module TreeReader =\n                open FusionM\n                open Operators\n            \n                type Node<'I, 'R, 'T> = {\n                    id                : unit                 -> 'I\n                    isExpandedRm      : unit                 -> FusionM<bool                   , 'R, 'T>\n                    canHaveChildrenRm : unit                 -> FusionM<bool                   , 'R, 'T>\n                    childrenRm        : unit                 -> FusionM<Node<'I, 'R, 'T> seq   , 'R, 'T>\n                    pathRm            : unit                 -> FusionM<'I list                , 'R, 'T>  // list of parents excluding itself\n                    parentORm         : Node<'I, 'R, 'T> seq -> FusionM<Node<'I, 'R, 'T> option, 'R, 'T>\n                    newChildrenRm     : Node<'I, 'R, 'T> []  -> FusionM<Node<'I, 'R, 'T>       , 'R, 'T>  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n                }\n            \n                let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n                let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n            \n                let rec listNodes level (nodes: Node<_,_,_> seq) =\n                    nodes\n                    |> Seq.map(fun node -> \n                        node.isExpandedRm() \n                        >>= (fun exp -> if exp then node.childrenRm() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n                        |>> (fun nodes -> Seq.append [ node, level ] nodes)\n                    ) \n                    |> sequenceSeq\n                    |>> Seq.collect id\n            \n                let removeNode (node:Node<_,_,_>) nodes = fusion { // better use version removeNode2\n                    let! path = node.pathRm()\n                    let rec chRemove (n:Node<_,_,_>) = fusion {\n                        if                  n.id() = node.id() then return  None\n                        elif List.contains (n.id())  path      then return! n.childrenRm()\n                                                                            |>> Seq.toArray\n                                                                            |>> Seq.map chRemove \n                                                                            >>= sequenceSeq \n                                                                            |>> Seq.choose id \n                                                                            |>> Seq.toArray\n                                                                            >>= n.newChildrenRm  \n                                                                            |>> Some\n                        else                                        return  Some n\n                    }\n                    return! nodes |> Seq.map chRemove |> sequenceSeq |>> Seq.choose id\n                }\n            \n                let removeNodes p nodes = fusion {\n                    let rec folder pair (n:Node<_,_,_>) = fusion {\n                        let! children, noparent = pair\n                        let! children2 = n.childrenRm() |>> Seq.toArray\n                        let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n                        if p n then return (        children, ch @ np)\n                               else let! xxx = n.newChildrenRm (ch |> Seq.rev |> Seq.toArray)\n                                    return ( xxx :: children,      np)\n                    }\n                    let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n                    return noparent @ res |> List.rev\n                }\n            \n                let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n                    seq [ for n in nodes do\n                            if p n then\n                                if after then yield n    ; yield node\n                                else          yield node ; yield n\n                            else              yield n\n                    ]\n                    \n                let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenRm\n            \n                let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n                    sibling.pathRm() >>= function\n                    | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n                    | parent :: path -> \n                    let rec mapAdd (n:Node<_,_,_>) =\n                        if                  n.id() = parent then     n.childrenRm() |>> Seq.toArray >>= addToParent after theSibling node n\n                        elif List.contains (n.id()) path    then     n.childrenRm() |>> Seq.toArray |>> Seq.map mapAdd >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenRm \n                        else                                     rtn n\n                    nodes |> Seq.map mapAdd |> sequenceSeq\n            \n                let tryFind p (nodes:Node<_,_,_> seq) = \n                    let rec folder resRm (node:Node<_,_,_>) =\n                        resRm >>= function\n                        | Some v -> rtn (Some v)\n                        | None   ->\n                        if p node then rtn <| Some node else \n                        node.childrenRm() >>= Seq.fold folder (rtn None)\n                    nodes                 |>  Seq.fold folder (rtn None)\n                    \n                let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n            \n                let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    nodes\n                    |>  removeNode node\n                    >>= addSibling after node sibling\n            \n                let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = fusion {\n                    let!  nodeO = nodes |> tryFindId nodeId\n                    match nodeO with\n                    | None         -> return nodes\n                    | Some node    ->\n                    let!  siblingO = nodes |> tryFindId siblingId\n                    match siblingO with\n                    | None         -> return nodes\n                    | Some sibling -> return! moveToSibling after node sibling nodes\n                }\n            \n                let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = fusion {\n                    let! path = parentN.pathRm()\n                    let rec mapAppend (n:Node<_,_,_>) =\n                        if   n.id() = parentN.id()       then \n                            if append                    then n.childrenRm() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                            else                              n.childrenRm() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                        elif List.contains (n.id()) path then n.childrenRm() |>> Seq.toArray |>>      Seq.map mapAppend   >>= sequenceSeq |>> Seq.toArray >>= n.newChildrenRm\n                        else                                  rtn n\n                    return! nodes |> Seq.map mapAppend |> sequenceSeq\n                }\n            \n                let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    node.parentORm nodes >>= function\n                    | None        -> rtn nodes\n                    | Some parent -> parent.childrenRm() |>> (Seq.toArray >> Seq.ofArray)\n                    |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n                    >>= Seq.fold      (fun newParentORm n -> n.canHaveChildrenRm() >>= (fun can -> if can then rtn(Some n) else newParentORm)) (rtn None)\n                    >>= function\n                    | None           -> rtn nodes\n                    | Some newParent ->\n                    nodes\n                    |>  removeNode node \n                    >>= addChild true node newParent\n            \n                let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.parentORm nodes\n                    |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n                    >>= Option.defaultValue (rtn nodes)\n                    \n                let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.childrenRm()\n                    |>> Seq.toArray\n                    >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n                    >>= removeNode node\n                    \n                \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\System.Reactive\\lib\\net46\\System.Reactive.dll\"\n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Control.Reactive\\lib\\net46\\FSharp.Control.Reactive.dll\"\n            module RunProcess =\n                open System.Diagnostics\n                open System.Text\n                open FSharp.Control.Reactive\n                open FSharp.Control.Reactive.WaitHandle\n                open FSharp.Control\n            \n                let startProcess p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let proc        = new Process(StartInfo = procStart)\n                    proc.Start() \n                \n                let startProcessDir p ops dir =\n                    let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n                    let proc        = new Process(StartInfo = procStart)\n                    proc.Start() \n                \n                type ShellResponse =\n                    | ShellDidNotStart \n                    | ShellExit                  of int * stdout: string * stderr:string\n                    | ShellNoExit                of       stdout: string * stderr:string\n                    | ShellCrashed               of       stdout: string * stderr:string\n                    with \n                    override msg.ToString() = \n                        match msg with\n                        | ShellDidNotStart                 -> [ \"Shell did not start\" ]\n                        | ShellExit        (cod, out, err) -> [ if cod <> 0 then yield sprintf \"exit(%d)\" cod\n                                                                yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellCrashed     (     out, err) -> [ yield \"Shell crashed!\" ; yield out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellNoExit      (     out, err) -> [ yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        |> String.concat \"\\n\"\n                \n                type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl, ?priorityClass) =\n                    let bufferOutput                      = new StringBuilder()\n                    let bufferError                       = new StringBuilder()\n                    let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\")                       |> ignore\n                    let consume (sb: StringBuilder)       = sb.ToString() |>! (fun _ -> sb.Clear()      |> ignore)\n                    let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n                    let outputHandler                     = append bufferOutput |> dataHandler\n                    let errorHandler                      = append bufferError  |> dataHandler\n                    do  startInfo.RedirectStandardInput  <- true\n                        startInfo.RedirectStandardOutput <- true\n                        startInfo.RedirectStandardError  <- true\n                        startInfo.UseShellExecute        <- false\n                    let proc                              = new Process(\n                                                                StartInfo           = startInfo\n                                                              , EnableRaisingEvents = true     )\n                    do  outputHandler                    |>             proc.OutputDataReceived.AddHandler\n                        errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n                        Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n                        Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n                //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n                      \n                    new          (program, args, ?priorityClass) = let startInfo                     = new ProcessStartInfo()\n                                                                   do  startInfo.FileName           <- program\n                                                                       startInfo.Arguments          <- args\n                                                                   new ShellEx(startInfo, ?priorityClass = priorityClass)\n                    member ____.Start                         () = let r = proc.Start() \n                                                                   priorityClass |> Option.iter (fun p -> proc.PriorityClass <- p)\n                                                                   proc.BeginOutputReadLine()\n                                                                   proc.BeginErrorReadLine ()\n                                                                   r\n                    member ____.WaitToFinish                  () = proc.WaitForExit()\n                                                                   let    output  = (consume bufferOutput).Trim()\n                                                                   let    error   = (consume bufferError ).Trim()\n                                                                   ((if proc.HasExited then proc.ExitCode else -99999), output, error)\n                    member ____.WaitForInputIdle              () = proc.WaitForInputIdle()\n                    member this.StartAndWait                  () = let _started = this.Start()\n                                                                   this.WaitToFinish()\n                    member this.StartAndWaitS                 () = this.StartAndWait()\n                                                                   |>! fun _ -> (this :> System.IDisposable).Dispose()\n                                                                   |> ShellExit\n                    member this.stdOutErr2Result exit out errs   = if exit <> 0\n                                                                   then Result.Error <| ErrorMsg(\n                                                                           [| if out  <> \"\"              then yield \"stdout: \" + out           \n                                                                              if errs <> \"\"              then yield errs                       \n                                                                              if errs  = \"\" || exit <> 1 then yield sprintf \"ExitCode: %d\" exit\n                                                                           |] |> String.concat \"\\n\")\n                                                                   else Result.Ok (out, errs)\n                    member this.StartAndWaitR                 () = let r = this.StartAndWait()\n                                                                   (this :> System.IDisposable).Dispose()\n                                                                   r |||> this.stdOutErr2Result\n                    member this.RunToFinish                   () = this.StartAndWaitS().ToString()\n                    member this.RunOutputToFileR            file = proc.OutputDataReceived.RemoveHandler outputHandler\n                                                                   use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n                                                                   let _started = proc.Start() \n                                                                   proc.BeginErrorReadLine ()\n                                                                   proc.StandardOutput.BaseStream.CopyTo stream\n                                                                   this.WaitToFinish()\n                                                                   |> ShellExit\n                    member this.RunOutputToFile             file = this.RunOutputToFileR file\n                                                                   |> fun v -> v.ToString() \n                    member ____.Send                (txt:string) = proc.StandardInput.WriteLine txt\n                    member ____.Output                        () = consume bufferOutput\n                    member ____.Error                         () = consume bufferError\n                    member ____.Response(out:string, err:string) = match out.Trim(), err.Trim() with\n                                                                   | good, \"\"  -> Result.Ok    <| good               \n                                                                   | good, bad -> Result.Error <| Message(ShellNoExit(good, bad))\n                    member this.Response                      () = this.Response(this.Output(), this.Error())\n                    member this.SendAndWait (send, wait, ?onErr) =\n                        let waitOnError = defaultArg onErr false\n                        let obsWait   = if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                                          |> Observable.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.Ok v else None) with _ -> None)\n                        let obsAll    = Observable.merge obsWait  (Event.map (fun _ -> Result.Error <| Message (ShellCrashed(this.Output(), this.Error()))) proc.Exited)\n                        asyncResult {\n                            //do! Result.tryProtection()\n                            async { \n                                do!    Async.Sleep 20 \n                                this.Send send        } |> Async.Start\n                            let!  waited = Observable.wait (obsAll |> Observable.take 1) \n                            do!   Async.Sleep 200\n                            return! if waitOnError\n                                    then this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                                    else this.Response()\n                        }\n                    member ____.HasExited = try proc.HasExited with _ -> true\n                    member ____.Abort()   = try proc.Kill   () with _ -> ()\n                    member ____.Process   = proc\n                    interface System.IDisposable with\n                        member ____.Dispose () =\n                            try proc.Close  ()\n                                proc.Kill   ()\n                                proc.Dispose() \n                            with _ ->       ()\n                \n                \n                let runAndWaitS p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.StartAndWaitS() \n                \n                let runToFinish p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n                    shell.RunToFinish() \n                \n                let runOutputToFile p ops file =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.RunOutputToFile file \n                \n                \n            module CopyIfMust =\n                open System.IO\n                \n                let copyIfNotExistsToFile from dest =\n                    let fit = FileInfo dest\n                    if not fit.Exists then\n                        File.Copy(from, dest, true )\n                \n                let toFile from dest =\n                    let fit = FileInfo dest\n                    let must = \n                        match fit.Exists with \n                        | false -> true\n                        | true  ->\n                            let fif = FileInfo dest\n                            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n                    if must then\n                        File.Copy(from, dest, true )\n                \n                let toDir from destDir =\n                    let dest = Path.Combine(destDir, Path.GetFileName(from))\n                    toFile from dest\n                \n            module FsCode =\n                open CommArg\n                open CommArgCollection\n                open FsCode\n                open System.IO\n                    \n                let flag t f p = function true -> p + t |_-> p + f\n                let flagpm   p = flag \"+\" \"-\" p\n            \n                let intRootDir       = NewString(\"RootDir\"      , true , sprintf  \"++root:%s\"        )\n                let intSnippet       = NewString(\"Snippet\"      , true , sprintf  \"++snippet:%s\"     )\n                let intCreateDir     = NewBool  (\"CreateDir\"    , true , fun v ->  if v then \"++createdirectory\" else \"\")\n                let intDirectory     = NewString(\"Directory\"    , true , sprintf  \"++directory:%s\"   )\n                let intName          = NewString(\"Name\"         , true , sprintf  \"++name:%s\"        )\n                let intExtension     = NewString(\"Extension\"    , true , sprintf  \"++extension:%s\"   )\n                let intFileName      = NewString(\"Filename\"     , true , sprintf  \"++filename:%s\"    )\n                let intOutputFile    = NewString(\"OutputFile\"   , true , sprintf  \"++fileout:%s\"     )\n                let intConfig        = NewString(\"Config\"       , true , sprintf  \"++config:%s\"      )\n                let intCopyConfig    = NewBool  (\"CopyConfig\"   , true , flagpm   \"++copyconfig\"     )\n                let intWebSharper    = NewBool  (\"WebSharper\"   , true , flagpm   \"++websharper\"     )\n                let intStaticLinkAll = NewBool  (\"StaticLinkAll\", true , flagpm   \"++staticlinkall\"  )\n                let intCopyAssem     = NewBool  (\"CopyAssem\"    , true , flagpm   \"++copyassemblies\" )\n                let intShowArgs      = NewBool  (\"ShowArgs\"     , true , flagpm   \"++showargs\"       )\n                let intRemLineDir    = NewBool  (\"RemLineDir\"   , true , flagpm   \"++remlinedir\"     )\n                \n                let internalArgs = \n                    Set [\n                        intSnippet      .CommArg.cargId\n                        intDirectory    .CommArg.cargId\n                        intName         .CommArg.cargId\n                        intExtension    .CommArg.cargId\n                        intFileName     .CommArg.cargId\n                        intOutputFile   .CommArg.cargId\n                        intConfig       .CommArg.cargId\n                        intWebSharper   .CommArg.cargId\n                        intStaticLinkAll.CommArg.cargId\n                        intCopyAssem    .CommArg.cargId\n                        intShowArgs     .CommArg.cargId\n                    ]\n            \n                let fscIOption     = NewString(\"IOption\"    , false, sprintf \"-I:%A\"          )\n                let fscReference   = NewString(\"Reference\"  , false, sprintf \"-r:%A\"          )\n                let fscSource      = NewString(\"Source\"     , false, sprintf \"%A\"             )\n                let fscTarget      = NewString(\"Target\"     , true , sprintf \"--target:%s\"    )\n                let fscPlatform    = NewString(\"Platform\"   , true , sprintf \"--platform:%s\"  )\n                let fscOutput      = NewString(\"Output\"     , true , sprintf \"-o:%A\"          )\n                let fscDebug       = NewString(\"Debug\"      , true , sprintf \"--debug:%s\"     )\n                let fscDefine      = NewString(\"Define\"     , false, sprintf \"--define:%s\"    )\n                let fscStaticLink  = NewString(\"StaticLink\" , false, sprintf \"--staticlink:%s\")\n                let fscGenFSharp1  = NewString(\"GenFSharp1\" , false, sprintf \"-%s\"            )\n                let fscGenFSharp2  = NewString(\"GenFSharp2\" , false, sprintf \"--%s\"           )\n                let fscNoFramework = NewBool  (\"NoFramework\", true , function true -> \"--noframework\" |_-> \"\" )\n                \n                let FSharpArgs = \n                    Set [\n                          fscIOption    .CommArg.cargId\n                          fscReference  .CommArg.cargId\n                          fscSource     .CommArg.cargId\n                          fscTarget     .CommArg.cargId\n                          fscPlatform   .CommArg.cargId\n                          fscOutput     .CommArg.cargId\n                          fscDebug      .CommArg.cargId\n                          fscDefine     .CommArg.cargId\n                          fscStaticLink .CommArg.cargId\n                          fscGenFSharp1 .CommArg.cargId\n                          fscGenFSharp2 .CommArg.cargId\n                          fscNoFramework.CommArg.cargId\n                ] \n                \n                let wscWebSite      = NewString(\"Website\"     , true , sprintf \"--wsoutput:%A\"              )\n                let wscProjectFile  = NewString(\"WsProject\"   , true , sprintf \"--project:%A\"               )\n                let wscProjectType  = NewString(\"ProjectType\" , true , sprintf \"--ws:%s\"                    )\n                let wscGenWSharper  = NewString(\"GenWSharper\" , false, sprintf \"--%s\"                       )\n                let wscJSMap        = NewBool  (\"JSMap\"       , false, flagpm  \"--jsmap\"                    )\n                let wscDeadCodeElim = NewBool  (\"DeadCodeElim\", false, flagpm  \"--dce\"                      )\n                let wscWarnOnly     = NewBool  (\"WarnOnly\"    , false, flagpm  \"--wswarnonly\"               )\n                let wscDownloadResc = NewBool  (\"DownloadResc\", false, flagpm  \"--dlres\"                    )\n                let wscPrintJS      = NewBool  (\"PrintJS\"     , false, flagpm  \"--printjs\"                  )\n                let wscClosures     = NewBool  (\"Closures\"    , false, flagpm  \"--closures\"                 )\n                let wscClosrMoveTop = NewBool  (\"ClosrMoveTop\", false, flag    \"--closures:movetotop\" \"\" \"\" )\n                let wscJsOutput     = NewString(\"JsOutput\"    , true , sprintf \"--jsoutput:%A\"              )\n            \n                let WebSharpArgs = \n                    Set [\n                          wscWebSite     .CommArg.cargId\n                          wscProjectFile .CommArg.cargId\n                          wscProjectType .CommArg.cargId\n                          wscGenWSharper .CommArg.cargId\n                          wscJSMap       .CommArg.cargId\n                          wscDeadCodeElim.CommArg.cargId\n                          wscWarnOnly    .CommArg.cargId\n                          wscDownloadResc.CommArg.cargId\n                          wscPrintJS     .CommArg.cargId\n                          wscClosures    .CommArg.cargId\n                          wscClosrMoveTop.CommArg.cargId\n                          wscJsOutput    .CommArg.cargId\n                    ] \n                \n                let dllOptions   () = CommArgCollection [ fscTarget      /= \"library\"                                                                     ] \n                let exeOptions   () = CommArgCollection [ fscTarget      /= \"exe\"     ; intCopyAssem /= true ; intCopyConfig /= true ]\n                let winExeOptions() = CommArgCollection [ fscTarget      /= \"winexe\"  ; intCopyAssem /= true ; intCopyConfig /= true ]\n                \n                open FusionM\n                open Operators\n                \n                let gS v = getStringRm     v\n                let gB v = getBoolRm false v\n            \n                let genericOptions () = \n                  CommArgCollection\n                    [\n            //           intSnippet     /= \"Test\"\n                        intRootDir     /= Path.GetFullPath \"..\"\n                        intName        /= (rtn (fun s     -> String.splitByChar '/' s |> Array.last ) <*> gS intSnippet                                       )\n                        intDirectory   /= (rtn (fun r     -> r                                      ) <*> gS intRootDir                                       )\n                        intFileName    /= (rtn (fun d n   -> d +/+ \"src\" +/+ n + \".fs\"              ) <*> gS intDirectory  <*> gS intName                     )\n                        fscOutput      /= (rtn (fun d n e -> d +/+ \"bin\" +/+ n + \".\" + e            ) <*> gS intDirectory  <*> gS intName <*> gS intExtension )\n                        intExtension   /= (rtn (function \"library\" -> \"dll\" |_-> \"exe\"              ) <*> gS fscTarget                                        )\n                        intOutputFile  /= (rtn               Path.GetFileName                         <*> gS fscOutput                                        )\n                        intConfig      /= (rtn (fun o     -> o + \".config\"                          ) <*> gS intOutputFile                                    )\n                        intWebSharper  /=       containsAnyOfRm WebSharpArgs\n                        fscSource      /=       gS intFileName\n                        fscNoFramework /= fusion {\n                                            let!    args  = filterRm (fun (a,v) -> a.cargId = fscReference.CommArg.cargId)\n                                            let!    args2 = args |> traverseSeq (fun (a,b) -> getVRm fscReference b )\n                                            return  args2\n                                                    |> Seq.map   (fun s -> s.ToLower()) \n                                                    |> Seq.exists(fun s -> s.Contains(\"fsharp.core.dll\") || s.Contains(\"mscorlib.dll\") )\n                                          }\n                    ]\n                    \n                let siteOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectType /=       \"Site\"\n                       wscWebSite     /= (rtn (fun d   -> d +/+ \"website\"  ) <*> gS intDirectory )\n                       wscJsOutput    /= (rtn (fun d n -> d +/+ n + \"0.js\" ) <*> gS wscWebSite  <*> gS intName )\n                       wscProjectFile /=       gS intName\n                       wscJSMap       /=       true\n                    |] \n                 \n                let wsProjectOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectFile /= gS intName\n                    |] \n                 \n                let debugOptions() = \n                  CommArgCollection\n                    [|\n                       fscGenFSharp1  /= \"g\"\n                       fscDebug       /= \"full\"\n                       fscDefine      /= \"DEBUG\"\n                       fscDefine      /= \"TRACE\"\n                       fscGenFSharp2  /= \"optimize-\"\n                       fscGenFSharp2  /= \"tailcalls-\"\n                    |]\n                \n                let otherOptions () =\n                  CommArgCollection\n                    [|\n                       //@\"--noframework\"\n                       fscGenFSharp2  /= \"warn:3\"\n                       fscGenFSharp2  /= \"nowarn:1178\"\n                       fscGenFSharp2  /= \"nowarn:1182\"\n                       fscGenFSharp2  /= \"nowarn:52\"\n                       fscGenFSharp2  /= \"warnaserror:76\"\n                       fscGenFSharp2  /= \"vserrors\"\n                       fscGenFSharp2  /= \"utf8output\"\n                       fscGenFSharp2  /= \"fullpaths\"\n                       fscGenFSharp2  /= \"flaterrors\"\n                       fscGenFSharp2  /= \"subsystemversion:6.00\"\n                       fscGenFSharp2  /= \"highentropyva+\"\n                       intRemLineDir  /= true\n                    |]\n                \n                let compileOptionsDll (snp:string) = \n                    genericOptions()\n                    + dllOptions  ()\n                    + otherOptions()\n                    + intSnippet     /= snp\n                    \n                let compileOptionsDllDebug   (snp:string) = compileOptionsDll      snp + debugOptions ()       \n                let compileOptionsExeDebug    snp         = compileOptionsDllDebug snp + exeOptions   ()\n                let compileOptionsWinExeDebug snp         = compileOptionsDllDebug snp + winExeOptions()\n                    \n                let prepOptionsRm (assembs : string [], defines : string [], prepoIs : string []) = fusion {\n                    let! staticLinksAll = getBoolRm false intStaticLinkAll\n                    return [\n                        yield! prepoIs |> Array.map ((/=) fscIOption  ) \n                        yield! assembs |> Array.map ((/=) fscReference)\n                        yield! defines |> Array.map ((/=) fscDefine   )\n                        if staticLinksAll then \n                            yield! assembs |> Array.map (fun f -> fscStaticLink /= System.IO.Path.GetFileNameWithoutExtension f)\n                    ]\n                }\n                    \n                let processArgs code assembs nowarns = fusion {        \n                    let! show      = getBoolRm false intShowArgs\n                    if   show then \n                        let! args  = filterRm trueForAll\n                        for (targ, vRm) in args do \n                            let! v = vRm\n                            printfn \"%25s = %A\" targ.name v\n                    let! workDir   = gS intDirectory\n                    let! fileName  = gS intFileName\n                    let! output    = gS fscOutput\n                    let! copyAssem = gB intCopyAssem\n                    let! createDir = gB intCreateDir\n                    let  srcDir    = Path.GetDirectoryName fileName\n                    let  outDir    = Path.GetDirectoryName output\n                    if   createDir then \n                                     Directory.CreateDirectory workDir |> ignore\n                                     Directory.CreateDirectory  srcDir |> ignore\n                                     Directory.CreateDirectory  outDir |> ignore\n                    let  code2     = [\n                                        yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n                                        yield! code \n                                     ] |> String.concat \"\\n\"\n                    do               File.WriteAllText(fileName, code2)\n                    if copyAssem then assembs |> Array.iter (fun f -> outDir |> CopyIfMust.toDir f)      \n                }\n                \n                type PreparedCode = {\n                    assemblies : string []\n                    defines    : string []\n                    prepIs     : string []\n                    nowarns    : string []\n                    cd         : string option\n                    code       : FsCode\n                }\n            \n                let prepareCodeRm (FsCode codeFs) = fusion {\n                    let  fs, directs                            = codeFs.Split '\\n' |> separatePrepros |> getTopDirectives\n                    let  assembs, defines, prepIs, nowarns, cdO = separateDirectives directs\n                    let! args2                                  = prepOptionsRm (assembs, defines, prepIs)\n                    do!                                           addPairsRm  args2\n                    do!                                           processArgs fs assembs nowarns\n                    return {\n                        assemblies = assembs\n                        defines    = defines\n                        prepIs     = prepIs\n                        nowarns    = nowarns\n                        cd         = cdO\n                        code       = FsCode codeFs\n                    }\n                }\n            \n            module FsiEvaluator =\n                open System.Diagnostics\n                open RunProcess\n                \n                \n                let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n                [< Literal >]\n                let endToken = \"xXxY\" + \"yYyhH\"\n                type FsiExe(config:string, workingDir, ?outHndl, ?errHndl) =\n                    let silent                     = ref false\n                    let fsiexe                     = if config.Contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n                    let startInfo                  = ProcessStartInfo(fsiexe, config, WorkingDirectory= workingDir)\n                    let outHndlS                   = outHndl |> Option.map(fun outh v -> if !silent then () else outh v)\n                    let errHndlS                   = errHndl |> Option.map(fun errh v -> if !silent then () else errh v)\n                    let shell                      = new ShellEx(startInfo, ?outHndl = outHndlS, ?errHndl = errHndlS)  // --noninteractive\n                    do  startInfo.CreateNoWindow  <- false\n                        shell.Start() |> ignore\n                    member __.Eval (FsCode code)   = asyncResult {\n                                                        shell.Output() |> ignore\n                                                        shell.Error () |> ignore\n                                                        shell.Send code\n                                                        shell.Send \";;\"\n                                                        return! shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                                                     }\n                    member __.IsAlive              = not shell.HasExited\n                    member __.Abort()              = shell.Abort()\n                    member __.Process              = shell.Process\n                    member __.Shell                = shell\n                    member oo.EvalSilent code      = asyncResult {\n                                                        try     silent := true\n                                                                return! oo.Eval code\n                                                        finally silent := false\n                                                     }\n                    interface System.IDisposable with\n                        member this.Dispose ()     = (shell :> System.IDisposable).Dispose()\n            \n                open FusionAsyncM\n                open Operators\n            \n                let evaluateRm   code = getS() >>= (fun (fsi:FsiExe) -> fsi.Eval       code |> ofAsyncResultRM) \n                let evalSilentRm code = getS() >>= (fun (fsi:FsiExe) -> fsi.EvalSilent code |> ofAsyncResultRM) \n            \n            module FsiCodePresence =\n                open FusionAsyncM\n                open FsiEvaluator\n                open Operators\n            \n                let installPresenceRm() = \n                    \"\"\"\n                    module CodePresence =\n                        let mutable present : Map<string, string>  = Map.empty\n                        let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n                        let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n                    \"\"\"\n                    |>  String.unindentStr\n                    |>  FsCode\n                    |>  evalSilentRm \n                    |>> ignore\n            \n                let addPresenceRm (name:string) (v:string) = fusion {\n                    let  code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v |> FsCode\n                    let! res  = evalSilentRm code |>> String.splitByChar '\\n' |>> Seq.head\n                    match res with\n                    | \"ok\"   -> ()\n                    |_       -> do! installPresenceRm()\n                                do! evalSilentRm code |>> ignore\n                }\n                        \n                let getPresenceRm (name:string)   = fusion {\n                    let! res = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n                               |> FsCode\n                               |> evalSilentRm\n                               |>> String.splitByChar '\\n' |>> Seq.head\n                               |> getOption\n                    match res with\n                    | None                     -> do! installPresenceRm()\n                                                  return None\n                    | Some v when v = endToken -> do! installPresenceRm()\n                                                  return None\n                    | Some \"--\"                -> return None\n                    | Some v                   -> return Some v\n                }\n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER \n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                open WebSharper.JavaScript\n            \n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            \n            module PromiseM =\n                open WebSharper.JavaScript\n            \n                let ofAsyncResultM (v: Async<ResultM<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function OkM(ok, _) -> resolve ok | ErrorM er -> reject <| ResultMessage.summarized er), reject, reject)\n                    )        \n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                    \n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Set v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let        traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n                let (<*>)                        =  View.Apply\n                let       traverseListApp f list =  let cons head tail = head :: tail\n                                                    let folder head tail = rtn cons <*> f head <*> tail\n                                                    List.foldBack folder list (rtn [])\n                let inline sequenceListApp  list =  traverseListApp id list\n            \n            module Var =\n                let mutable private counter = 1\n                let freshId () =\n                    counter <- counter + 1\n                    \"varuid\" + string counter\n                        \n                let lensView get update view0 (var: Var<_>) =\n                    let id   = freshId()\n                    let view = View.Map2 (fun v _ -> get v) var.View view0\n                    { new Var<'V>() with\n                        member this.Get        () = get (var.Get())\n                        member this.Set         v = var.Update(fun t -> update t v)\n                        member this.SetFinal    v = this.Set(v)\n                        member this.Update      f = var.Update(fun t -> update t (f (get t)))\n                        member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n                        member this.View          = view\n                        member this.Id            = id\n                    }\n            \n            module ListModel =\n                let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.FindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n                    let id = Var.freshId()\n                    { new Var<'V>() with\n                        member r.Get         () = m.TryFindByKey key |> get\n                        member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n                        member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n                        member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n                        member r.SetFinal    v  = r.Set v\n                        member r.View           = view\n                        member r.Id             = id\n                    }\n                let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n                    Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n                let lensDef def k (m:ListModel<_,_>) =\n                    let get = Option.defaultValue def\n                    lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n            \n                let currentLensUpd def curr upd (model:ListModel<_,_>) = \n                    curr \n                    |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                                    (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                                    model.View\n                let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n                    let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n                    Var.Make view upd\n                let currentLens def curr (model:ListModel<_,_>) = \n                    model \n                    |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n                \n                let refreshLM (lm:ListModel<_,_>) elems =\n                    lm.AppendMany elems\n                    let keys = elems |> Seq.map lm.Key |> Set\n                    lm |> Seq.cache |> Seq.iter(fun e ->\n                        if keys |> Set.contains (lm.Key e) |> not then lm.RemoveByKey (lm.Key e)\n                    )\n            \n                let MapLens predO (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n                    let get k v = f k (m.Lens k)\n                    match predO with\n                    | None       -> m.ViewState |> View.MapSeqCachedViewBy m.Key get \n                    | Some predW ->\n                        (m.ViewState, predW) \n                        ||> View.Map2(fun vms pred -> vms.ToArray (System.Predicate pred)) \n                        |> View.MapSeqCachedViewBy m.Key get \n            \n            module Pojo =\n                let addProp prop (pojo:JSObject) = pojo.Add prop ; pojo\n                \n                let newPojo props =\n                    let pojo = JSObject()\n                    if IsClient then\n                        props |> Seq.iter (swap addProp pojo >> ignore)\n                    pojo\n            \n                let newPojoOpt (propOs : seq<string * obj option>) =\n                    propOs\n                    |> Seq.choose(fun (n,vO) -> vO |> Option.map(fun v -> n,v))\n                    |> newPojo\n            \n            module GenEditor =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    line : int\n                    col  : int\n                }\n            \n                type AnnotationType =\n                | Error   \n                | Warning \n                | Info    \n                | Hint\n                | Other of string\n            \n                type Annotation = {\n                    startP        : Position\n                    endP          : Position\n                    severity      : AnnotationType\n                    message       : string\n                }\n            \n                type Completion = {\n                    kind                : string\n                    label               : string\n                    detail              : string\n                    replace             : Position * Position\n                }\n            \n                [<NoComparison ; NoEquality>]\n                type GenEditorHook<'T> = {\n                    generateDoc       :  GenEditor<'T> -> ('T -> unit)     -> Doc\n                    getValue          :  unit                              -> string\n                    setValue          :  string                            -> unit\n                    setDisabled       :  bool                              -> unit\n                    showAnnotations   :  Annotation seq                    -> unit\n                    posFromIndex      :  int                               -> Position\n                    indexFromPos      :  Position                          -> int\n                    getWordAt         :  Position                          -> (string * Position) option\n                    getSelectionText  :  unit                              -> string\n                    getUri            :  unit                              -> string\n                    setUri            :  string                            -> unit\n                    hookOnChange      : (obj           -> unit           ) -> unit\n                }\n            \n                and GenEditor<'T> = {\n                    var             :  Var< string        >\n                    disabled        :  View<bool          >\n                    annotations     :  View<Annotation seq>\n                    onChange        : (GenEditor<'T> -> string      -> unit                              ) option\n                    onRender        : (GenEditor<'T>                -> unit                              )\n                    autoCompletion  : (GenEditor<'T> -> Position    -> Async<Completion []>              ) option\n                    toolTip         : (GenEditor<'T> -> Position    -> Async<string              option >) option\n                    declaration     : (GenEditor<'T> -> Position    -> Async<(Position * string) option >) option\n                    mutable editorO :  'T option\n            \n                    editorHook      : GenEditorHook<'T>\n                }\n                \n                let inline setVar   v   genE = { genE with var      = v   }\n                let inline onChange f   genE = { genE with onChange = f   }\n                let inline onRender f   genE = { genE with onRender = f   }\n                let inline disabled dis genE = { genE with disabled = dis }\n            \n                let inline var          genE = genE.var\n            \n                let newVar edh var = {\n                    var            = var \n                    disabled       = V false\n                    annotations    = V Seq.empty\n                    onChange       = None\n                    onRender       = ignore\n                    editorHook     = edh\n                    autoCompletion = None\n                    toolTip        = None\n                    declaration    = None\n                    editorO        = None\n                }\n            \n                let newText edh (v:string)             = newVar edh (Var.Create v)\n                let newVarO edh (v:Var<string option>) = \n                    Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                    |> newVar edh\n                    |> disabled(V (Option.isNone v.V))\n            \n                /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n                /// onChange gets called when the editor changes but not when the var changes\n                let bindVarEditor setEvent getVal setVal onChange (var:Var<_>) =\n                    let editorChanged = ref 0L\n                    let varChanged    = ref 0L\n                    setEvent(fun _ ->\n                        let v = getVal() \n                        if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange v \n                    )\n                    var.View |> View.Sink (fun _ ->\n                        if  !editorChanged > !varChanged then varChanged := !editorChanged\n                        elif getVal() <> var.Value then setVal var.Value\n                    )\n            \n                let generateDoc genE = \n                    let onChange = genE.onChange |> Option.map(fun f -> f genE) |> Option.defaultValue ignore\n                    genE.editorHook.generateDoc genE (fun ed ->\n                        genE.editorO        <- Some ed\n                        genE.var            |> bindVarEditor  genE.editorHook.hookOnChange    \n                                                              genE.editorHook.getValue \n                                                              genE.editorHook.setValue \n                                                              onChange\n                        genE.annotations    |> View.Sink      genE.editorHook.showAnnotations\n                        genE.disabled       |> View.Sink      genE.editorHook.setDisabled\n                        genE.onRender genE\n                    )\n            \n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module Serializer =\n                open System\n                open WebSharper.JavaScript\n                \n                type SerS<'T> = ('T  -> string)        //      Serialization function\n                type SerD<'T> = (obj -> 'T    )        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>    // both Serialization functions\n                \n                let inline ifUndef  def v   = if isUndefined v then def   else   v\n                let inline ifUndefF def f v = if isUndefined v then def v else f v\n                \n                let (|Exists|_|) field o = if isUndefined o?(field) then None else Some o?(field)\n                \n                let deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n                \n                let serFloat  : Ser<float   > = sprintU               , (unbox >> ifUndef 0.0             )\n                let serInt    : Ser<int     > = sprintU               , (unbox >> ifUndef 0               )\n                let serBool   : Ser<bool    > = sprintU               , (unbox >> ifUndef false           )\n                let serString : Ser<string  > = Json.Serialize        , (unbox >> ifUndef \"\"              )\n                let serDate   : Ser<DateTime> = (date2Long >> sprintU), (unbox >> ifUndef 0L >> long2Date )\n            \n                let [< Inline >] inline serId  (get: 'a->System.Guid) (set:System.Guid->'a) (print: 'a->string) : Ser<'a> =\n                    let s           = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ          = sprintf \"%A\" s\n                    let serialize   = fun id       -> get id |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize = fun (x: obj) -> x?(s) |> deserGuid |> set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * _ * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser >> Some, (fun rc o -> set (deser o) rc) \n                    \n                let serFieldO (name:string) (get:'D->'e option) (set:'e option->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * _ * _ = \n                    serFuncs |> fun (ser, deser) -> name, get >> Option.map ser, (fun rc o -> set (if isUndefined o then None else Some(deser o) ) rc) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * ('D -> string option) * ('D -> SerD<'D>))>) : Ser<'D> =\n                    let serialize   dim = fields |> Seq.choose(fun (n, ser, _deser) -> ser dim |> Option.map (sprintf \"%A: %s\" n)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, _ser,  deser) ->  deser dim (o?(n)) )   init\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser))               )\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toArray)\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\") , (unbox<obj  > >> ifUndefF (fun _ -> None     ) (         snd ser   >> Some      ))\n                let serDup serFst serSnd : Ser<'a * 'b    > = (fun (f,s) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s)), (unbox<obj[]> >> ifUndefF (fun _ -> snd serFst null, snd serSnd null ) (fun os -> snd serFst os.[0], snd serSnd os.[1] ) )\n                let serMap serKey serElm : Ser<Map<'k, 'e>> = serDup serKey serElm |> serSeq |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Map)       )\n            \n                let serVarField (name:string) (var:'D->Var<'e>) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, (var >> Var.Get >> ser), (fun rc o -> var rc |> Var.Set <| deser o ; rc)\n            \n                let serLMdField (name:string) (lmd:'D->ListModel<_,'e>) serE  : string * SerS<'D> * ('D -> SerD<'D>) = \n                    let serS              = serSeq serE\n                    let serializer   rc   = lmd rc |> (fun lm -> lm.Value) |> fst serS\n                    let deserializer rc b = lmd rc |> (fun lm -> lm.Set  ) <| snd serS b ; rc\n                    name, serializer, deserializer\n            \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(WebSharper.JavaScript.RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let rexEmail = \"\"\"(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            [< JavaScript >]\n            module Hoverable =\n                open WebSharper.UI.Html\n            \n                [<NoComparison ; NoEquality>]\n                type Hoverable         = { hover : Var<bool>        } with\n                    static member  New() = { hover = Var.Create false }\n                    member inline this.Attributes = [ attr.classDynPred (View.Const \"hovering\") this.hover.View\n                                                      on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n                                                      on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n                                                    ]   \n                    member inline this.Content    (ds: Doc seq) = div this.Attributes ds\n                    member inline this.Content    ( e: Elt    ) = e.OnMouseEnter(fun _ _ -> e.AddClass    \"hovering\") // THIS ONE ADDS ONE EXTRA SPACE\n                                                                   .OnMouseLeave(fun _ _ -> e.RemoveClass \"hovering\") // THAT THIS ONE DOES NOT REMOVE      \n                    //member inline this.Content    ( e: Elt    ) = e.WithAttrs this.Attributes\n                    static member  Demo  = Hoverable.New().Content(Elt.div [ attr.style \"flex-flow: column;\" ] [ text \"Hover over me!\" ])\n            \n                let hoverable (e:Elt) = Hoverable.New().Content e\n                \n            [< JavaScript >]\n            module ResizeObserver =\n                open WebSharper.JavaScript\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module WebComponent =\n                open WebSharper.JavaScript\n            \n                [< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\n                let ReflectConstruct () = X<_>\n                \n                [< Inline \"\"\"console.log('defineWebComponent: ' + $_nm);\n                            Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n                            Object.setPrototypeOf($_c, $global.HTMLElement);\n                            Object.setPrototypeOf($_o.prototype, $_c.prototype);\n                            $global.customElements.define($_nm, $_o)\"\"\" >]\n                let defineWebComponent_ _nm _o _c = X<_>\n            \n                let defineWebComponent _nm _o _c = \n                    try defineWebComponent_ _nm _o _c\n                    with _ -> printfn \"Failed to define WebComponent. Not supported.\"\n            \n                module WcTabStrip =\n                    open WebSharper.UI.Html\n                    //open TabStrip\n                    open Hoverable\n                \n                    let css = @\"\n                .tab-panel {\n                 overflow  : hidden   ;\n                 display   : flex     ;\n                 flex-flow : column   ;\n                 background: lightgray;\n                 height    : 100%    ;\n                 width     : 100%    ;\n                }\n                .tab-content {\n                 flex      : 1 1     ;\n                 overflow  : auto    ;\n                 position  : relative;\n                }\n                .tab-children {\n                 height    : 100%    ;\n                 width     : 100%    ;\n                 position  : absolute;\n                 display   : grid    ;\n                }\n                .tab-strip {\n                 padding   : 0pt     ;\n                 flex      : 0 0     ;\n                }\n                .tab {\n                 border     : 0.2pt solid transparent;\n                 padding    : 0pt 4pt;\n                 display    : inline-block;\n                 font-family: sans-serif;\n                 font-weight: 200;\n                 font-size  : small;\n                 color      : #666;\n                 cursor     : pointer;\n                }\n                .top>.tab {\n                 border-radius: 2pt 2pt 0pt 0pt;\n                 border-bottom-width: 0pt;\n                 vertical-align: bottom;\n                }\n                .bottom>.tab {\n                 border-top-width: 0pt;\n                 border-radius: 0pt 0pt 2pt 2pt;\n                 vertical-align: top;\n                }\n                .horizontal>.tab:not(:first-child) {\n                 border-left-width: 0pt;\n                }\n                .tab.hovering {\n                 background: red;\n                }\n                .tab.selected {\n                 background: white;\n                 border-left-width: 0.2pt;\n                 color: black;\n                 font-weight: 500;\n                 border-color: black;\n                }\n                .horizontal>.tab.selected {\n                 border-left-width: 0.2pt;\n                }\n                ::slotted(*              ) { \n                 width : 100%;\n                 height: 100%;\n                }\n                        \"\n                \n                    let tabStrip (selected:Var<int>) top horizontal tabs content =\n                        let strip =\n                            div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\n                                                        (if top        then \"top\"        else \"bottom\"  ) \n                                                        (if horizontal then \"horizontal\" else \"vertical\")\n                                ]\n                                [ for i, (txt, _) in  tabs |> Seq.indexed  do\n                                      yield Hoverable.New().Content (\n                                          Elt.div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i + 1 then \" selected\" else \"\")) selected.View\n                                                    attr.draggable \"true\"\n                                                    on.click   (fun _  _  -> selected.Value <- i + 1 ) \n                                                  ]\n                                                  [ text txt ]) :> Doc\n                                ] \n                        div [ attr.``class`` \"tab-panel\" \n                                //on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n                                //on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n                            ]\n                            [   if     top then yield strip\n                                yield div [ attr.``class`` \"tab-content\" ] [ content ]\n                                if not top then yield strip\n                                yield Elt.Element \"style\" [] [ text css ] :> Doc\n                                yield Elt.Element \"style\" [] \n                                        [ Doc.TextView <| View.Map (sprintf \"\"\"\n                                              ::slotted(*              ) { display: none }\n                                              ::slotted(*:nth-child(%d)) { display: grid }\n                                           \"\"\") selected.View \n                                        ] \n                                    :> Doc\n                            ]\n                \n                    type WcTabStripT () =\n                        let mutable added = false\n                        let selected = Var.Create 1\n                        do printfn \"WcTabStripT initializer\"\n                        #if DLL \n                        [< Inline \"\"\"$global.FsRootDll.LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n                        #else\n                        [< Inline \"\"\"$global.FsRoot   .LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n                        #endif\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcTabStripT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot       = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh = JS.Document.CreateElement \"div\"\n                                shadowRoot.AppendChild elsh |> ignore\n                                let addTab () =\n                                    //printfn \"my-el modified %A %A\" added this?outerHTML\n                                    let top  = el.HasAttribute \"bottom\" |> not\n                                    let tabs = [ for i in 1..el.ChildNodes.Length do \n                                                    let node = el.ChildNodes.[i - 1]\n                                                    if node.NodeType = Dom.NodeType.Element then\n                                                        let elem = node :?> Dom.Element\n                                                        let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                                        yield (tabName, elem)\n                                                ]\n                                    while elsh.ChildNodes.Length > 0 do\n                                        elsh.RemoveChild elsh.LastChild |> ignore\n                                    Elt.Element \"slot\" [] []\n                                    |> tabStrip selected top true tabs\n                                    |> Doc.Run elsh\n                                addTab()\n                                el.AddEventListener(\"DOMSubtreeModified\", delayed 50 addTab)\n                                added <- true\n                    let init =\n                        lazy\n                            let x = WcTabStripT().connectedCallback\n                            if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n                    \n                module WcSplitter =    \n                    open ResizeObserver\n                    \n                    type Layout = View<string> -> (Dom.Element -> unit) -> (Dom.Element -> unit) -> (Dom.MouseEvent -> unit) -> View<string> -> Doc\n                    \n                    let mutable layoutHorizontal : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    let mutable layoutVertical   : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    \n                    type WcSplitterT () =\n                        let mutable added = false\n                        do printfn \"WcSplitterT initializer\"\n                        #if DLL \n                        [< Inline \"\"\"$global.FsRootDll.LibraryJS.WebComponent.WcSplitter.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n                        #else\n                        [< Inline \"\"\"$global.FsRoot   .LibraryJS.WebComponent.WcSplitter.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n                        #endif\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcSplitterT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh        = JS.Document.CreateElement \"div\"\n                                let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n                                let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n                                let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n                                let first       =    el.HasAttribute \"second\"   |> not\n                                let vertical    =    el.HasAttribute \"vertical\"\n                                let size        = ref        (0.0, 0.0)\n                                let padding     = ref         0.0\n                                let gap         = Var.Create  0.0\n                                let sizeCalc (sh:Dom.Element) : float * float =\n                                    let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                                                 else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                                    let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                                    let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                                    gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                                    padding := pt + pb\n                                    el.GetBoundingClientRect() \n                                    |> fun r -> \n                                         match vertical, first with\n                                         | true , true  ->  r.Width , r.Height \n                                         | true , false -> -r.Width , r.Height\n                                         | false, true  ->  r.Height, r.Width\n                                         | false, false -> -r.Height, r.Width\n                                let dragging : bool               ref = ref false   \n                                let startP   : float              ref = ref 0.0\n                                let start    : float              ref = ref 0.0\n                                let domElem  : Dom.Element option ref = ref None                 \n                                let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                                let drag       (ev: Dom.Event     ) =\n                                    ev :?> Dom.MouseEvent\n                                    |> mouseCoord\n                                    |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                                    |> fun v   -> value.Value <- min maxV (max minV v)\n                                   \n                                let rec finishDragging (_: Dom.Event) =\n                                    if !dragging then\n                                        dragging := false\n                                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                                let startDragging (ev: Dom.MouseEvent) =\n                                    if not !dragging then\n                                        dragging := true\n                                        startP   := value.Value\n                                        start    := mouseCoord ev\n                                        size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                                        ev.PreventDefault()\n                                    //div [\n                                    //    SomeAttr  <| on.mouseDown startDragging\n                                    //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                                    //    style     <| styleSplitter !gap\n                                    //    style        \"z-index: 10; background-color: #eef\"\n                                    //]\n                                let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                                             , (sz - gap - pad) * (100.0 - spl) / 100.0\n                                let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n                                let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n                                //div [ \n                                //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                                //    style <| Val.map styleSizes value\n                                //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                                //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                                //    slot [ name \"splitter\" ; splitter                                               ]\n                                //]\n                                let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n                                //addResizeObserver recalc el\n                                (if vertical then layoutVertical else layoutHorizontal)\n                                    <| View.Map styleSizes value.View\n                                    <| fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc()\n                                    <| fun  sp              -> domElem :=          Some sp ; recalc()\n                                    <| fun  me              -> startDragging me\n                                    <| View.Map (sprintf \"%Apx\") gap.View\n                                |> Doc.Run elsh\n                                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                                added <- true\n                    let init layoutH layoutV =\n                        let x = WcSplitterT().connectedCallback\n                        layoutHorizontal <- layoutH\n                        layoutVertical   <- layoutV\n                        if IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n                    \n            [< JavaScriptExport >]\n            module Monaco =\n                open WebSharper.JavaScript\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri    = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f) \" >] static member File(_f)       : Uri    = X<_>\n                    [< Inline \"$this.toString()             \" >] override this.ToString()     : string = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.uri                                           \" >] member mo.GetUri()                        : Uri            = X<_>\n                    [< Inline \"$mo.uri = $_v                                     \" >] member mo.SetUri(_v:Uri)                  : unit           = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.getPositionAt($_i)                            \" >] member mo.GetPositionAt(_i: int     )     : Position       = X<_>\n                    [< Inline \"$mo.getOffsetAt($_p)                              \" >] member mo.GetOffsetAt(  _p: Position)     : int            = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    [< Inline \"$mo.getValueInRange($_r)                          \" >] member mo.GetValueInRange(  _r: Range)    : string         = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8 \n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                open WebSharper.Core.Resources\n                type MonacoResources() =\n                    inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n            \n                [< Require(typeof<MonacoResources>) >]\n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    [< Inline \"$monc.getSelection()              \" >] member monc.GetSelection()                              : Range           = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (string -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        //do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             = \n                    async {\n                      do! loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> GenEditor.bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                          )    \n                        ] []\n                    } |> Doc.Async\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n            [< JavaScriptExport >]\n            module MonacoGenAdapter =\n                open Monaco\n                open GenEditor\n                open WebSharper.UI.Html\n            \n                type MonacoRT = {\n                    mutable editorO     : Monaco.Editor option\n                    mutable onChange    : obj -> unit\n                    options             : obj\n                    overrides           : obj\n                }\n            \n                let iterEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> ()\n                    | Some ed -> f ed\n            \n                let mapEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> None\n                    | Some ed -> Some (f ed)\n            \n                let bindEditor monRT f =\n                    match monRT.editorO with\n                    | None    -> None\n                    | Some ed -> f ed\n            \n                let posGen2Ed (p:GenEditor.Position) : Monaco.Position = \n                    {\n                        column     = p.col \n                        lineNumber = p.line\n                    }\n            \n                let posEd2Gen (p:Monaco.Position) : GenEditor.Position = \n                    {\n                        col  = p.column    \n                        line = p.lineNumber\n                    }\n            \n                let indexFromPos monRT p =\n                    mapEditor monRT <| fun ed ->\n                        ed.GetModel().GetOffsetAt(posGen2Ed p)            \n                    |> Option.defaultValue -1\n            \n                let posFromIndex monRT i =\n                    mapEditor monRT <| fun ed ->\n                        ed.GetModel().GetPositionAt i\n                        |> posEd2Gen\n                    |> Option.defaultValue { col = 1 ; line = 1 }\n            \n                let convertGlyphChar =\n                    function\n                    | \"C\" -> CompletionItemKind.Class\n                    | \"E\" -> CompletionItemKind.Enum\n                    | \"S\" -> CompletionItemKind.Value\n                    | \"I\" -> CompletionItemKind.Interface\n                    | \"N\" -> CompletionItemKind.Module\n                    | \"M\" -> CompletionItemKind.Method\n                    | \"P\" -> CompletionItemKind.Property\n                    | \"F\" -> CompletionItemKind.Field\n                    | \"T\" -> CompletionItemKind.Class\n                    | \"K\" -> CompletionItemKind.Keyword\n                    | _   -> 0 |> unbox\n            \n                type CompletionItemProvider(autoComplete: GenEditor.Position -> Async<Completion[]>) =\n                    do()\n                   with\n                      member __.provideCompletionItems(model:Model, pos:Monaco.Position, token:obj, context: obj) =\n                        asyncResultM {\n                            let! comps = autoComplete  { col = pos.column ; line = pos.lineNumber }\n                            return comps \n                                    |> Array.map(fun (comp:Completion) -> \n                                        { \n                                            kind   = convertGlyphChar comp.kind\n                                            label  = comp.label\n                                            detail = comp.detail\n                                        } )\n                        } |> PromiseM.ofAsyncResultM\n                      member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n            \n            \n                type HoverProvider(toolTip: GenEditor.Position -> Async<string option> ) =\n                    do()\n                   with\n                      member __.provideHover(model:Model, pos:Monaco.Position, token:obj) =\n                        asyncResultM {\n                            let! desc = toolTip { col = pos.column ; line = pos.lineNumber }\n                            match desc with\n                            | None      -> return (box null |> unbox)\n                            | Some desc ->\n                            return {\n                                    contents = [| { value = desc ; isTrusted = true } |]\n                                    range    = (box null |> unbox)\n                                }\n                        } |> PromiseM.ofAsyncResultM\n            \n                type DefinitionProvider(declaration: GenEditor.Position -> Async<(Position * string) option> ) =\n                    do()\n                   with\n                        member __.provideDefinition(model: Model, pos: Monaco.Position, token: obj) =\n                            asyncResultM {\n                                let! declO =  declaration { col = pos.column ; line = pos.lineNumber }\n                                match declO with\n                                | None             -> return box null |> unbox\n                                | Some (pos, file) ->\n                                return {\n                                    range = {\n                                                startColumn     = pos.col\n                                                endColumn       = pos.col\n                                                startLineNumber = pos.line\n                                                endLineNumber   = pos.line\n                                    }\n                                    uri   = Uri.Parse file\n                                }\n                            } |> PromiseM.ofAsyncResultM\n            \n                let generateDoc monRT genE onRender =\n                    async {\n                      do! Monaco.loader\n                      return\n                          div [ on.afterRender (fun elchild  ->\n                                    let editor        = Monaco.Editor.Create elchild.ParentElement monRT.options monRT.overrides\n                                    ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                    elchild.ParentNode.RemoveChild elchild |> ignore\n                                    monRT.editorO     <- Some editor\n                                    onRender                  editor\n                                    editor.OnDidChangeModelContent monRT.onChange\n                                    genE.toolTip        |> Option.iter (fun f -> Editor.RegisterHoverProvider         (\"fsharp\", new HoverProvider         (f genE) ) |> ignore )\n                                    genE.declaration    |> Option.iter (fun f -> Editor.RegisterDefinitionProvider    (\"fsharp\", new DefinitionProvider    (f genE) ) |> ignore )\n                                    genE.autoCompletion |> Option.iter (fun f -> Editor.RegisterCompletionItemProvider(\"fsharp\", new CompletionItemProvider(f genE) ) |> ignore )\n                          )    \n                        ] []\n                    } |> Doc.Async\n            \n                let getUri    monRT     = mapEditor  monRT    <| (fun ed -> ed.GetModel().GetUri().ToString() ) |> Option.defaultValue \"\" \n                let setUri    monRT uri = iterEditor monRT    <|  fun ed -> ed.GetModel().SetUri(Uri.Parse uri) \n                let getValue  monRT     = mapEditor  monRT    <| (fun ed -> ed.GetValue()   ) |> Option.defaultValue \"\" \n                let setValue  monRT txt = iterEditor monRT    <|  fun ed -> ed.SetValue txt \n                let getWordAt monRT pos = bindEditor monRT    <|  fun ed -> let word = ed.GetModel().GetWordAtPosition {    \n                                                                                column     = (pos:GenEditor.Position).col\n                                                                                lineNumber = pos.line }\n                                                                            if isUndefined word then None else \n                                                                            (word.word, {   col  = word.startColumn\n                                                                                            line = pos.line })\n                                                                            |> Some\n                let getSelect monRT     = mapEditor  monRT    <| (fun ed -> ed.GetSelection() |> ed.GetModel().GetValueInRange ) |> Option.defaultValue \"\" \n            \n                let showAnnotations monRT ans =\n                    iterEditor monRT <| fun ed ->\n                        let ms =\n                            ans\n                            |> Seq.map (fun (an:Annotation) ->\n                                {   message           = an.message\n                                    severity          = match an.severity with \n                                                        | Error   -> MarkerSeverity.Error \n                                                        | Warning -> MarkerSeverity.Warning  \n                                                        | Hint    -> MarkerSeverity.Hint \n                                                        | _       -> MarkerSeverity.Info\n                                    startColumn       = an.startP.col\n                                    startLineNumber   = an.startP.line\n                                    endColumn         = an.endP  .col\n                                    endLineNumber     = an.endP  .line\n                                }\n                            )\n                            |> Seq.toArray\n                        Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)\n            \n                let newHook monRT = {\n                    generateDoc      =            generateDoc  monRT \n                    getValue         = fun ()  -> getValue     monRT\n                    setValue         =            setValue     monRT\n                    getWordAt        =            getWordAt    monRT\n                    showAnnotations  = showAnnotations         monRT\n                    setDisabled      = ignore //  bool                              -> unit\n                    hookOnChange     = fun f   -> monRT.onChange <- f \n                    posFromIndex     =            posFromIndex monRT\n                    indexFromPos     =            indexFromPos monRT\n                    getUri           = fun ()  -> getUri       monRT\n                    setUri           =            setUri       monRT\n                    getSelectionText = fun ()  -> getSelect    monRT\n                }\n            \n                let newRT options overrides = {\n                    editorO     = None\n                    onChange    = ignore\n                    options     = options   \n                    overrides   = overrides \n                }\n            \n                let newVar options overrides v =\n                    newRT options overrides\n                    |> newHook\n                    |> GenEditor.newVar <| v\n            \n            module AppFrameworkTemplate =\n                let html = \"\"\"\n            <div style=\"display:none\" >\n                <div links>\n                    <link  href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" type=\"text/css\" rel=\"stylesheet\">\n                    <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   type=\"text/javascript\"></script>\n                </div>\n                <div ws-template=\"AppFramework\" style=\"height: calc(100vh - 4px); width: calc(100vw - 4px) \" class=\"relative\" >\n                    <div ws-hole=\"MainClient\"></div>\n                    <div class=\"AppFrameworkGo\"><button ws-onclick=\"GoClient\">${MainDoc}</button></div>\n                </div>\n                <div ws-template=\"VSplitter1\" class=\"versplitter\" ws-attr=\"Attrs\" vertical>\n                    <div style=\"min-width :Calc((100% - ${gap}) *        ${perc}  / 100);max-width :Calc((100% - ${gap}) *        ${perc}  / 100)\">${doc1}</div>\n                    <div style=\"min-width :             ${gap}\" ws-onmousedown=\"MouseDown\" ></div>\n                    <div style=\"min-width :Calc((100% - ${gap}) * (100 - ${perc}) / 100);max-width :Calc((100% - ${gap}) * (100 - ${perc}) / 100)\">${doc2}</div>\n                </div>\n                <div ws-template=\"HSplitter1\" class=\"horsplitter\" ws-attr=\"Attrs\">\n                    <div style=\"min-height:Calc((100% - ${gap}) *        ${perc}  / 100);max-height:Calc((100% - ${gap}) *        ${perc}  / 100)\">${doc1}</div>\n                    <div style=\"min-height:             ${gap}\" ws-onmousedown=\"MouseDown\" ></div>\n                    <div style=\"min-height:Calc((100% - ${gap}) * (100 - ${perc}) / 100);max-height:Calc((100% - ${gap}) * (100 - ${perc}) / 100)\">${doc2}</div>\n                </div>\n                <style>\n                    .horsplitter                    { display: flex; flex-direction:column              } \n                    .horsplitter > div:nth-child(2) { background: #eef; cursor: row-resize; z-index:400 }\n                    .horsplitter > div              { overflow: hidden                                  }\n                    .versplitter                    { display: flex; flex-direction:row                 } \n                    .versplitter > div:nth-child(2) { background: #eef; cursor: col-resize; z-index:400 }\n                    .versplitter > div              { overflow: hidden                                  }\n                </style>\n                <style>\n                    .AppFrameworkGo {\n                        max-width: 2px;\n                        max-height: 2px;\n                        z-index: 4000;\n                        overflow: hidden;\n                        position: fixed;\n                        top: 0px;\n                        left: 0px;\n                    }\n                </style>\n                <div ws-template=\"FixedSplitterVer\" \n                    style=\"display: grid; \n                           grid-gap: 0px; \n                           box-sizing: border-box; \n                           height: 100%;\n                           width : 100%;\n                           grid-template-areas: 'one two'; \n                           grid-template-rows   :100%; \n                           overflow: hidden; \n                           grid-template-columns: ${PartSizes}\"  >\n                   <div ws-hole=\"First\"  style=\"grid-area: one; \" class=\"relative\" ></div>\n                   <div ws-hole=\"Second\" style=\"grid-area: two; \" class=\"relative\" ></div>\n                </div>               \n                <div ws-template=\"FixedSplitterHor\" \n               style=\"display: grid; \n                      grid-gap: 0px; \n                      box-sizing: border-box; \n                      height: 100%;\n                      width : 100%;\n                      grid-template-areas: 'one' 'two'; \n                      grid-template-columns:100%; \n                      overflow: hidden; \n                      grid-template-rows   : ${PartSizes}\"  >\n              <div ws-hole=\"First\"  style=\"grid-area: one; \" class=\"relative\" ></div>\n              <div ws-hole=\"Second\" style=\"grid-area: two; \" class=\"relative\" ></div>\n                </div>               \n                <div ws-template=\"WCompSplitterHor\" \n                     ws-onafterrender=\"AfterRender\"\n                     style=\"display: grid;\n                            grid-gap: 5px; \n                            box-sizing: border-box; \n                            grid-template-areas: 'one' 'two'; \n                            grid-template-columns:100%; \n                            overflow: hidden; \n                            grid-template-rows   : ${PartSizes}\" \n                     >\n                     <slot></slot>\n                    <slot name=\"splitter\">  <div style=\"grid-row:2; grid-column:1 / 1 ; cursor: row-resize; z-index: 3; background-color: #eef ; height: ${Gap}; margin-top :-${Gap}\" ws-onmousedown=\"MouseDown\" ws-onafterrender=\"AfterRenderSp\" ></div> </slot>\n                    <style>\n                        ::slotted(*) {\n                            display: grid;\n                            height : 100%;\n                            width  : 100%;\n                            overflow: hidden;\n                        }\n                        ::slotted(*:nth-child(2)) {\n                            grid-area: two;\n                        }\n                        ::slotted(*[slot=\"splitter\"]) {\n                            grid-row:2; grid-column:1 / 1 ; \n                            cursor: row-resize; \n                            z-index: 3; \n                            background-color: #eef ; \n                            height: ${Gap}; \n                            margin-top :-${Gap}\n                        }\n                    </style>\n                </div>        \n                <div ws-template=\"WCompSplitterVer\" \n                     ws-onafterrender=\"AfterRender\"\n                     style=\"display: grid; \n                            grid-gap: 5px; \n                            box-sizing: border-box; \n                            grid-template-areas: 'one two'; \n                            grid-template-rows   :100%; \n                            overflow: hidden; \n                            grid-template-columns: ${PartSizes}\"  >\n                    <slot></slot>\n                    <slot name=\"splitter\"> <div style=\"grid-column:2; grid-row:1 / 1 ; cursor: col-resize; z-index: 3; background-color: #eef ; width: ${Gap}; margin-left :-${Gap}\" ws-onmousedown=\"MouseDown\" ws-onafterrender=\"AfterRenderSp\" ></div> </slot>\n                    <style>\n                        ::slotted(*) {\n                            display: grid;\n                            height : 100%;\n                            width  : 100%;\n                            overflow: hidden;\n                        }\n                        ::slotted(*:nth-child(2)) {\n                            grid-area: two;\n                        }\n                        ::slotted(*[slot=\"splitter\"]) {\n                            grid-column:2; grid-row:1 / 1\n                            cursor: column-resize; \n                            z-index: 3; \n                            background-color: #eef ; \n                            width: ${Gap}; \n                            margin-left:-${Gap}\n                        }\n                    </style>\n                </div>\n                <div ws-template=\"AppFwkClient\" >\n                    <ws-FixedSplitterHor>\n                        <PartSizes>55px calc(100% - 55px)</PartSizes>\n                        <First>\n                            <span style=\"display: grid;\n                                  grid-template-columns: 30% 20% 20% 10%;\n                                  grid-gap: 25px;\n                                \">\n                                <div class=\"mainTitle\">AppFramework</div>\n                            </span>\n                        </First>\n                        <Second>\n                                <ws-FixedSplitterVer>\n                                    <PartSizes>calc(100% - 2px) 2px</PartSizes>\n                                    <First>\n                                        <wcomp-splitter vertical value=\"18\" max=\"100\">\n                                            <div><div ws-hole=\"PlugIns\" style=\"overflow:auto\" >\n                                                <div ws-template=\"Tile\">\n                                                    <div draggable=\"true\" class=\"code-editor-list-tile ${Predecessor} ${Selected}\" \n                                                    ws-ondrag=\"Drag\"\n                                                    ws-ondragover=\"DragOver\"\n                                                    ws-ondrop=\"Drop\"\n                                                   >\n                                                   <span class=\"node ${Parent} ${ErrorMsg}\" title=\"expand\" ws-onclick=\"ToggleCollapse\"></span>\n                                                   <div  class=\"code-editor-list-text\" style=\"text-indent:${Indent}em; white-space: pre\" ws-onclick=\"Select\" ws-onafterrender=\"AfterRender\" >${Name}</div>\n                                                   <span class=\"predecessor\" title=\"toggle predecessor\" ws-onclick=\"TogglePred\">X</span>\n                                               </div>\n                                       \n                                                </div>\n                                            </div></div>\n                                            <wcomp-splitter vertical value=\"80\" min=\"30\" max=\"100\">\n                                                <ws-FixedSplitterHor>\n                                                    <PartSizes>32px calc(100% - 32px)</PartSizes>\n                                                    <First>\n                                                        <div>\n                                                            <div class=\"input-group\">\n                                                                <span class=\"input-group-addon\">${PlugInName}</span>\n                                                            </div>\n                                                        </div>\n                                                    </First>\n                                                    <Second>\n                                                        <div style=\"overflow:auto; display:flex; flex-direction:column\">\n                                                            <div>\n                                                                <h3>Vars:</h3>\n                                                                <table style=\"overflow:auto;width:100%\" class=\"table table-condensed table-striped\">\n                                                                    <thead>\n                                                                        <th style=\"width: 10%  \">Name</th>\n                                                                        <th style=\"width: 90% \">Value</th>\n                                                                    </thead>\n                                                                    <tbody ws-hole=\"Vars\">\n                                                                    <tr ws-template=\"NameValueInput\" >\n                                                                        <td >${Name}:</td>\n                                                                        <td>\n                                                                        <textarea placeholder=\"Value...\" ws-var=\"Value\" style=\"resize:vertical; width:100%\" spellcheck=\"false\"></textarea>\n                                                                        </td>\n                                                                    </tr>\n                                                                    </tbody>\n                                                                </table>\n                                                            </div>\n                                                            <div>\n                                                                <h3>Views:</h3>\n                                                                <table style=\"overflow:auto\" class=\"table table-condensed table-striped\" >\n                                                                    <thead>\n                                                                        <th style=\"width: 10%  \">Name</th>\n                                                                        <th style=\"width: 90% \">Value</th>\n                                                                    </thead>\n                                                                    <tbody ws-hole=\"Views\" >\n                                                                    <tr ws-template=\"NameValue\" class=\"\">\n                                                                        <td>${Name}:</td>\n                                                                        <td>${Value}</td>\n                                                                    </tr>\n                                                                    </tbody>\n                                                                </table>\n                                                            </div>\n                                                            <div>\n                                                                <h3>Docs:</h3>\n                                                                <div ws-hole=\"Docs\" style=\"overflow:auto\" ></div>\n                                                            </div>\n                                                            <div>\n                                                                <h3>Queries:</h3>\n                                                                <table style=\"overflow:auto\" >\n                                                                    <tbody ws-hole=\"Queries\" >\n                                                                    </tbody>\n                                                                </table>\n                                                            </div>\n                                                        </div>\n                                                    </Second>\n                                                </ws-FixedSplitterHor>\n                                        <div style=\"font-size:small; overflow: hidden; display: flex; flex-direction: column;\"  class=\"absolute\" ws-hole=\"Actions\" >\n                                            <button ws-template=\"Action\" style=\"font-size:small\" ws-onclick=\"Click\" class=\"btn\" type=\"button\" id=\"\" ws-attr=\"Attrs\" >${Name}</button>\n                                        </div>\n                                            </wcomp-splitter>\n                                        </wcomp-splitter>\n                                    </First>\n                                    <Second>\n                                                <wcomp-tabstrip >\n                                                    <div tabname=\"Properties\">\n                                                        <div>\n                                                            <table style=\"border-spacing:0px\">\n                                                                <thead>\n                                                                    <th style=\"width: 30%  \">Name</th>\n                                                                    <th style=\"width: 70% \">Value</th>\n                                                                </thead>\n                                                                <tbody ws-hole=\"Properties\" ws-children-template=\"Property\">\n                                                                    <tr ws-onclick=\"Select\" style=\"margin-bottom: 2px\" class=\"level  \">\n                                                                        <td class=\"level-item\">\n                                                                            <div>\n                                                                                <input ws-var=\"Name\" type=\"text\" class=\"form-control\" id=\"\" placeholder=\"Property...\">\n                                                                            </div>\n                                                                        </td>\n                                                                        <td class=\"level-item\">\n                                                                            <div>\n                                                                                <textarea ws-var=\"Value\" class=\"form-control\" id=\"\" placeholder=\"Value...\"></textarea>\n                                                                            </div>\n                                                                        </td>\n                                                                        <td class=\"level-item\">\n                                                                            <div style=\" cursor: pointer \" title=\"remove\">\n                                                                                <button ws-onclick=\"Remove\" class=\"delete is-small\">x</button>\n                                                                            </div>\n                                                                        </td>\n                                                                    </tr>\n                                                                </tbody>\n                                                            </table>\n                                                            <button ws-onclick=\"AddProperty\" class=\"add is-small\">add ...</button>\n                                                        </div>\n                                                    </div>\n                                                </wcomp-tabstrip>\n                                    </Second>\n                                </ws-FixedSplitterVer>\n                        </Second>\n                    </ws-FixedSplitterHor>\n                </div>\n                <style style=\"display: none\">\n                        .Hidden     { display   : none         }\n                        table th,table td { padding:0 5px 0 5px; text-overflow: ellipsis }\n                        td input.form-control { \n                            padding    : 0px; \n                            font-family: monospace;\n                            font-size  :   small;\n                            margin-top :   0px;\n                            margin-left: -2px;\n                            width      : 100%\n                        }\n                        td select {\n                            font-size : smaller;\n                            max-width : 8ch;\n                        }\n                        textarea {\n                           resize : vertical;\n                        }\n                        .tab-content {\n                            overflow: hidden\n                        }\n                        .tab-children {\n                            position:relative;\n                        }\n                        .tab-children>div>* {\n                            position:absolute;\n                            height: 100%;\n                            width:  100%;\n                            display: grid;\n                        }\n                        .relative {\n                            position:relative;\n                        }\n                        .relative>* {\n                            position:absolute;\n                            height: 100%;\n                            width:  100%;\n                            display: grid;\n                        }\n                        table.table-striped    tbody tr:nth-child(even) { background: #EEE  }\n                        table.table-striped    tbody tr:nth-child(odd ) { background: #FFF  }\n                        table.table-striped    tbody input              { background: transparent; border: none}\n                        table.table-striped    tbody select             { background: transparent; border: none}\n                        table.table-nonstriped tbody tr:nth-child(even) { background: inherit }\n                        table.table-nonstriped tbody tr:nth-child(odd ) { background: inherit }\n                        table.table            tbody tr.hover           { border    : solid thin transparent; } \n                        table.table            tbody tr.hover:hover     { border    : solid thin blue     ; } \n                        table.table            tbody th:hover           { background: gray; cursor: pointer }\n                        table.table            tbody tr.hover:hover>td  { border-top: solid thin blue     ; \n                                                                   border-bottom: solid thin blue     ; } \n                        table.table            tbody tr.selected { background   : #b9eeff             ; }\n                        table.table            tbody tr.formula.selected { background: #20f7f7             ; }\n                        thead { color: gray }\n                        h3 { \n                            color: gray;\n                            line-height: 1em;\n                        }\n                        button       { border: solid thin transparent ; border-radius: 3px; }\n                        button:hover { border: solid thin blue }\n                        .indenter { position  : absolute; \n                                    top:0px; bottom:0px; left:0px; \n                                    background: white; color:white;\n                                    border-right: gray thin dotted;\n                                    }\n                        body {\n                            color      : #333;\n                            font-size  : small;\n                            font-family: monospace;\n                            line-height: 1.2;\n                        }\n                        .mainTitle {  \n                            font-size: 48px;\n                            font-weight: 500;\n                            color: gray;\n                            margin-top: -12px;\n                        }\n                        .CodeMirror {\n                            height: 100%;\n                        }\n                        \n                      \n                        body { margin: 0px }     \n                             \n                        div textarea {\n                            font-family     : monospace;\n                        }\n                        .code-editor-list-tile {\n                            white-space     : nowrap; \n                            border-style    : solid none none;\n                            border-color    : white;\n                            border-width    : 1px;\n                            background-color: #D8D8D8;\n                            display         : flex;\n                        }\n                        .code-editor-list-text{\n                            padding         : 1px 10px 1px 5px;\n                            overflow        : hidden;\n                            text-overflow   : ellipsis;\n                            white-space     : nowrap;\n                            flex            : 1;\n                        }\n                        \n                        .code-editor-list-tile span.node.ErrorMsg {\n                            background-color: red\n                        }\n                        .code-editor-list-tile span.node.expanded::before {\n                            content: \"-\"\n                        }\n                        .code-editor-list-tile span.node.collapsed::before {\n                            content: \"+\"\n                        }\n                        .code-editor-list-tile.direct-predecessor {\n                            font-weight     : bold;\n                            color           : blue;\n                        }\n                        .code-editor-list-tile.indirect-predecessor {\n                            color           : blue;\n                        }\n                        .code-editor-list-tile.included-predecessor {\n                            color           : chocolate;\n                        }\n                        .code-editor-list-tile.selected {\n                            background-color: #77F;\n                            color           : white;\n                        }\n                        .code-editor-list-tile.codeSnippet {\n                            text-decoration: underline\n                        }\n                        .code-editor-list-tile:hover {\n                            background      : lightgray;\n                        }\n                        .code-editor-list-tile.selected:hover {\n                            background      : blue;\n                        }\n                        .code-editor-list-tile>.predecessor {\n                            font-weight     : bold;\n                            border-style    : inset;\n                            border-width    : 1px;\n                            text-align      : center;\n                            color           : transparent;\n                        }\n                        .code-editor-list-tile.direct-predecessor>.predecessor {\n                            color           : blue;\n                        }\n                        \n                        .CodeMirror { height: 100%; }\n                        \n                        .node {\n                            background-color: white; \n                            width           : 2ch; \n                            color           : #A03; \n                            font-weight     : bold; \n                            text-align      : center;\n                            font-family     : arial;\n                        }\n                        .Warning { text-decoration: underline lightblue } \n                        .Error   { text-decoration: underline red       } \n                        \n                    </style>\n            </div>\n            \"\"\"\n            [< JavaScriptExport >]\n            module AppFramework =\n                open WebSharper.JavaScript\n            \n                type PlgElemName = PlgElemName of string with member this.Id = match this with PlgElemName v -> v\n                type PlugInName  = PlugInName  of string with member this.Id = match this with PlugInName  v -> v\n            \n                type PlugInVar   = { \n                    varName      : PlgElemName\n                    varVar       : Var<string>\n                }\n            \n                type PlugInView  = {\n                    viwName      : PlgElemName\n                    viwView      : View<string>\n                }\n            \n                type DocFunction =\n                | JustDoc of                                                    Doc\n                | FunDoc0 of (                                        unit   -> Doc)\n                | FunDoc1 of (                                        string -> Doc) * string                                     \n                | FunDoc2 of (                              string -> string -> Doc) * string * string                            \n                | FunDoc3 of (                    string -> string -> string -> Doc) * string * string * string                   \n                | FunDoc4 of (          string -> string -> string -> string -> Doc) * string * string * string * string          \n                | FunDoc5 of (string -> string -> string -> string -> string -> Doc) * string * string * string * string * string  \n            \n                type PlugInDoc = {\n                    docName        : PlgElemName\n                    docDoc         : Lazy<DocFunction>\n                }\n            \n                type ActFunction =\n                | FunAct0 of (                                         unit -> unit)\n                | FunAct1 of (                                          obj -> unit) * string\n                | FunAct2 of (                                   obj -> obj -> unit) * string * string\n            \n                type PlugInAction = {\n                    actName        : PlgElemName\n                    actFunction    : ActFunction\n                    actEnabled     : View<bool>\n                }\n            \n                type PlugInQuery = {\n                    qryName        : PlgElemName\n                    qryFunction    : obj -> obj\n                }\n            \n                type PlugIn = {\n                    plgName        : PlugInName\n                    plgVars        : ListModel<PlgElemName, PlugInVar   >\n                    plgViews       : ListModel<PlgElemName, PlugInView  >\n                    plgDocs        : ListModel<PlgElemName, PlugInDoc   >\n                    plgActions     : ListModel<PlgElemName, PlugInAction>\n                    plgQueries     : ListModel<PlgElemName, PlugInQuery >\n                }\n             \n                let plugIns = ListModel (fun plg -> plg.plgName)\n            \n                let mainDocV = Var.Create \"AppFramework.AppFwkClient\"\n                //let titleV   = Var.Create \"AppFramework.mainDocV\"\n            \n                open WebSharper.UI.Templating\n            \n                let [< Literal >] TemplateFileName =  @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\website\\AppFramework.html\"\n                //let [< Literal >] TemplateFileName =  @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FSharpStation\\website\\Templates.html\"\n            \n                type AppFwkTemplate = Templating.Template<TemplateFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n                let defaultPlugIn() = {\n                        plgName    = PlugInName \"\"\n                        plgVars    = ListModel (fun (var:PlugInVar   ) -> var.varName)\n                        plgViews   = ListModel (fun (viw:PlugInView  ) -> viw.viwName)\n                        plgDocs    = ListModel (fun (doc:PlugInDoc   ) -> doc.docName)\n                        plgActions = ListModel (fun (act:PlugInAction) -> act.actName)\n                        plgQueries = ListModel (fun (qry:PlugInQuery ) -> qry.qryName)\n                    }\n            \n                let splitName (lytNm:PlugInName) : _ -> PlugInName * PlgElemName = String.splitByChar '.' >>  (fun a -> if a.Length = 1 then (lytNm, a.[0].Trim() |> PlgElemName ) else (a.[0].Trim() |> PlugInName, a.[1].Trim() |> PlgElemName) )\n            \n                let selectionPlugInO = Var.Create <| Some (PlugInName \"AppFramework\")\n                let currentPlugInW   = selectionPlugInO.View |>  View.Bind(function Some k -> plugIns.TryFindByKeyAsView k | None -> View.Const (Some <| defaultPlugIn())) |> View.Map (Option.defaultWith defaultPlugIn)\n                let currentPlugInV   = Var.Make currentPlugInW plugIns.Add\n            \n                let renderPlugIns() = plugIns.DocLens(fun name plug -> \n                    AppFwkTemplate.Tile()\n                        .Name(     name.Id                                                   )\n                        .Select(   fun _ -> selectionPlugInO.Set <| Some name                )\n                        .Selected( if selectionPlugInO.V = Some name then \"selected\" else \"\" )\n                        .Doc() \n                )\n            \n                let renderVars() = \n                    currentPlugInW\n                    |> View.Map (fun plg -> plg.plgVars |> Seq.map (fun v -> plg, v))\n                    |> Doc.BindSeqCachedBy (fun (plg, var) -> plg.plgName, var.varName) (fun (plg, var) -> \n                        AppFwkTemplate.NameValueInput()\n                            .Name(    var.varName.Id ) \n                            .Value(   var.varVar     )\n                            .Doc() \n                    ) \n            \n                let renderViews() = \n                    currentPlugInW\n                    |> View.Map (fun plg -> plg.plgViews |> Seq.map (fun v -> plg, v))\n                    |> Doc.BindSeqCachedBy (fun (plg, viw) -> plg.plgName, viw.viwName) (fun (plg, viw) -> \n                        AppFwkTemplate.NameValue()\n                            .Name(    viw.viwName.Id )\n                            .Value(   viw.viwView    )\n                            .Doc() \n                    ) \n            \n                let docParms (doc:PlugInDoc) = \n                    match doc.docDoc.Value with\n                    | JustDoc _                          -> \"\"\n                    | FunDoc0 __                         -> \"()\"\n                    | FunDoc1(_, p1                    ) -> [ p1                ] |> String.concat \", \" |> sprintf \"(%s)\"\n                    | FunDoc2(_, p1 , p2               ) -> [ p1; p2            ] |> String.concat \", \" |> sprintf \"(%s)\"\n                    | FunDoc3(_, p1 , p2 , p3          ) -> [ p1; p2; p3        ] |> String.concat \", \" |> sprintf \"(%s)\"\n                    | FunDoc4(_, p1 , p2 , p3 , p4     ) -> [ p1; p2; p3; p4    ] |> String.concat \", \" |> sprintf \"(%s)\"\n                    | FunDoc5(_, p1 , p2 , p3 , p4 , p5) -> [ p1; p2; p3; p4; p5] |> String.concat \", \" |> sprintf \"(%s)\"\n            \n                let renderDocs() =\n                    currentPlugInW\n                    |> View.Bind (fun plg -> plg.plgDocs.View |> View.Map (Seq.map (fun v -> plg, v)) )\n                    |> Doc.BindSeqCachedBy (fun (plg, doc) -> plg.plgName, doc.docName) (fun (plg, doc) -> \n                        AppFwkTemplate.Tile()\n                            .Name(     doc.docName.Id +  docParms doc)\n                            .Select(   fun _ -> currentPlugInW |> View.Get (fun plg ->  mainDocV.Set <| plg.plgName.Id + \".\" + doc.docName.Id ) )\n                            .Doc() \n                    ) \n            \n                let callFunction p1 p2 actF =\n                    match actF with\n                    | FunAct0(f      ) -> f    ()\n                    | FunAct1(f, _   ) -> f    p2\n                    | FunAct2(f, _, _) -> f p1 p2\n            \n                let renderActions() = \n                    currentPlugInW\n                    |> View.Map (fun plg -> plg.plgActions |> Seq.map (fun v -> plg, v))\n                    |> Doc.BindSeqCachedBy (fun (plg, act) -> plg.plgName, act.actName) (fun (plg, act) -> \n                        let parms = match act.actFunction with\n                                    | FunAct0(_        ) -> \"\"\n                                    | FunAct1(_, p1    ) -> [ p1      ] |> String.concat \", \" |> sprintf \"(%s)\"\n                                    | FunAct2(_, p1, p2) -> [ p1 ; p2 ] |> String.concat \", \" |> sprintf \"(%s)\"\n                        AppFwkTemplate.Action() \n                            .Name(     act.actName.Id + parms                             )\n                            .Click(    fun ev -> act.actFunction |> callFunction () ev )\n                            .Attrs(    Attr.DynamicPred \"disabled\" (V (not act.actEnabled.V)) (View.Const \"\") )\n                            .Doc()            \n                    ) \n            \n                let renderQueries() = \n                    currentPlugInW\n                    |> View.Map (fun plg -> plg.plgQueries |> Seq.map (fun v -> plg, v))\n                    |> Doc.BindSeqCachedBy (fun (plg, qry) -> plg.plgName, qry.qryName) (fun (plg, qry) -> \n                        AppFwkTemplate.Tile()\n                            .Name(     qry.qryName.Id  )\n                            .Select(   fun _ -> () |> box |> qry.qryFunction |> unbox |> JS.Alert )\n                            .Doc() \n                    ) \n            \n                let AppFwkClient = \n                    lazy\n                        AppFwkTemplate.AppFwkClient()\n                            .PlugIns(     renderPlugIns()           )\n                            .PlugInName(  currentPlugInW.V.plgName.Id )\n                            .Vars(        renderVars()              )\n                            .Views(       renderViews()             ) \n                            .Docs(        renderDocs()              )\n                            .Actions(     renderActions()           )\n                            .Queries(     renderQueries()           )\n                            .Doc()\n            \n                let getActualDoc doc =\n                    match doc.docDoc.Value with\n                    | JustDoc jdoc -> jdoc\n                    | FunDoc0 fdoc -> fdoc()\n                    | _ -> Html.div [] [ Html.text <| sprintf \"Doc with parameters not allowed here: %A\" doc ]\n            \n                let getMainClientDoc() =\n                    plugIns.View\n                    |> View.Map2(fun (mainDoc:string) plgs -> \n                        plgs |> Seq.tryPick(fun plg ->\n                            plg.plgDocs \n                            |> Seq.tryFind(fun doc -> plg.plgName.Id = mainDoc || plg.plgName.Id + \".\" + doc.docName.Id = mainDoc) \n                            |> Option.map getActualDoc\n                        )\n                        |> Option.defaultValue AppFwkClient.Value\n                    ) mainDocV.View\n                    |> Doc.EmbedView\n            \n                let mainDoc() = \n                        AppFwkTemplate.AppFramework()\n                            .MainDoc(     mainDocV.View                                     )\n                            .GoClient(    fun _ -> mainDocV.Set \"AppFramework.AppFwkClient\" )\n                            .MainClient(  getMainClientDoc()                                )\n                            .Doc()\n            \n                open WebComponent\n            \n                let horizontal : WcSplitter.Layout = fun partSizes afterRender afterRenderSp mouseDown gap ->\n                    AppFwkTemplate.WCompSplitterHor()\n                        .PartSizes(    partSizes)\n                        .AfterRender(  afterRender)\n                        .AfterRenderSp(afterRenderSp)\n                        .MouseDown(    fun te -> mouseDown te.Event)\n                        .Gap(          gap)\n                        .Doc()\n                let vertical   : WcSplitter.Layout = fun partSizes afterRender afterRenderSp mouseDown gap ->\n                    AppFwkTemplate.WCompSplitterVer()\n                        .PartSizes(    partSizes)\n                        .AfterRender(  afterRender)\n                        .AfterRenderSp(afterRenderSp)\n                        .MouseDown(    fun te -> mouseDown te.Event)\n                        .Gap(          gap)\n                        .Doc()\n            \n                let newVar  name var = { varName = name ; varVar      = var                                 }\n                let newViw  name viw = { viwName = name ; viwView     = viw                                 }\n                let newDoc  name doc = { docName = name ; docDoc      = lazy(JustDoc (doc:Lazy<Doc>).Value) }\n                let newDoc0 name f   = { docName = name ; docDoc      = lazy(FunDoc0 f                    ) }\n                let newQry  name qry = { qryName = name ; qryFunction = qry          }\n                let newAct  name fnc = {\n                    actName        = name\n                    actFunction    = FunAct0 fnc\n                    actEnabled     = View.Const true\n                }\n            \n                let newActF name fncF = {\n                    actName        = name\n                    actFunction    = fncF\n                    actEnabled     = View.Const true\n                }\n                \n                let newDocL name docL = { docName = name ; docDoc =      docL }\n                let newDocF name docF = { docName = name ; docDoc = lazy docF }\n            \n                type PlugInBuilder() =\n                    member __.Zero() = { defaultPlugIn() with plgName    = PlugInName \"Main\" }\n                    member this.Yield(()) = this.Zero()\n                    member __.For(coll:seq<_>, func) =\n                        let ie = coll.GetEnumerator()\n                        while ie.MoveNext() do\n                            func ie.Current\n                    [<CustomOperation(\"plgName\"   )>] member __.Name  ( plg:PlugIn, name:string               ) = { plg with plgName    =    PlugInName name }\n                    [<CustomOperation(\"plgVar\"    )>] member __.AddVar( plg:PlugIn, name:string, var          ) = plg.plgVars   .Add(newVar  (PlgElemName name)          var            )  ; plg\n                    [<CustomOperation(\"plgDoc\"    )>] member __.AddDoc( plg:PlugIn, name:string, doc          ) = plg.plgDocs   .Add(newDoc  (PlgElemName name)          doc            )  ; plg\n                    [<CustomOperation(\"plgDoc0\"   )>] member __.AddDoc0(plg:PlugIn, name:string, doc          ) = plg.plgDocs   .Add(newDoc0 (PlgElemName name)          doc            )  ; plg\n                    [<CustomOperation(\"plgDoc1\"   )>] member __.AddDoc1(plg:PlugIn, name:string, doc, p1      ) = plg.plgDocs   .Add(newDocF (PlgElemName name) (FunDoc1(doc,p1       )))  ; plg\n                    [<CustomOperation(\"plgDoc2\"   )>] member __.AddDoc2(plg:PlugIn, name:string, doc, p1, p2  ) = plg.plgDocs   .Add(newDocF (PlgElemName name) (FunDoc2(doc,p1,p2    )))  ; plg\n                    [<CustomOperation(\"plgDoc3\"   )>] member __.AddDoc3(plg:PlugIn, name:string, doc,a,b,c    ) = plg.plgDocs   .Add(newDocF (PlgElemName name) (FunDoc3(doc,a,b,c    )))  ; plg\n                    [<CustomOperation(\"plgDoc4\"   )>] member __.AddDoc4(plg:PlugIn, name:string, doc,a,b,c,d  ) = plg.plgDocs   .Add(newDocF (PlgElemName name) (FunDoc4(doc,a,b,c,d  )))  ; plg\n                    [<CustomOperation(\"plgDoc5\"   )>] member __.AddDoc5(plg:PlugIn, name:string, doc,a,b,c,d,e) = plg.plgDocs   .Add(newDocF (PlgElemName name) (FunDoc5(doc,a,b,c,d,e)))  ; plg\n                    //[<CustomOperation(\"plgDocDyn\" )>] member __.AddDocF(plg:PlugIn, name:string, docF)  = plg.plgDocs   .Add(newDoc name (lazy LayoutEngine.turnToView docF) ) ; plg\n                    [<CustomOperation(\"plgQuery\"  )>] member __.AddQry( plg:PlugIn, name:string, qry          ) = plg.plgQueries.Add(newQry  (PlgElemName name) qry) ; plg\n                    [<CustomOperation(\"plgAct\"    )>] member __.AddAct( plg:PlugIn, name:string, act          ) = plg.plgActions.Add(newAct  (PlgElemName name) act) ; plg\n                    [<CustomOperation(\"plgAct1\"   )>] member __.AddAct1(plg:PlugIn, name:string, act, p1      ) = plg.plgActions.Add(newActF (PlgElemName name) (FunAct1(act,p1   )) ) ; plg\n                    [<CustomOperation(\"plgAct2\"   )>] member __.AddAct2(plg:PlugIn, name:string, act, p1, p2  ) = plg.plgActions.Add(newActF (PlgElemName name) (FunAct2(act,p1,p2)) ) ; plg\n                    [<CustomOperation(\"plgActOpt\" )>] member __.AddActO(plg:PlugIn, name:string,         actO ) = \n                                                        match actO with \n                                                        | Some act -> plg.plgActions.Add(newAct (PlgElemName name) act)\n                                                        | None     -> ()\n                                                        plg\n                    //[<CustomOperation(\"mainDoc\")>] member __.InsDoc(plg:PlugIn, name:string, doc) = plg.plgDocs.    = [| newDoc (PlgElemName name) doc |] |> Array.append <| plg.plgDocs    }\n                    [<CustomOperation(\"plgView\"   )>] member __.AddViw( plg:PlugIn, name:string, viw )  = plg.plgViews.Add(newViw (PlgElemName name) viw) ; plg\n                    [<CustomOperation(\"plgMerge\"  )>] member __.Merge ( plg:PlugIn, prefix:string, p2:PlugIn) = \n                                                        plg.plgVars   .AppendMany(p2.plgVars    |> Seq.map (fun v -> { v with varName = PlgElemName (prefix + v.varName.Id) } ) ) \n                                                        plg.plgViews  .AppendMany(p2.plgViews   |> Seq.map (fun w -> { w with viwName = PlgElemName (prefix + w.viwName.Id) } ) ) \n                                                        plg.plgDocs   .AppendMany(p2.plgDocs    |> Seq.map (fun d -> { d with docName = PlgElemName (prefix + d.docName.Id) } ) ) \n                                                        plg.plgActions.AppendMany(p2.plgActions |> Seq.map (fun a -> { a with actName = PlgElemName (prefix + a.actName.Id) } ) ) \n                                                        plg.plgQueries.AppendMany(p2.plgQueries |> Seq.map (fun q -> { q with qryName = PlgElemName (prefix + q.qryName.Id) } ) ) \n                                                        plg\n            \n                let plugin = PlugInBuilder()\n            \n            \n                let tryGetPlugInW plgName = plugIns.TryFindByKeyAsView plgName\n            \n                let tryGetVarW plgName varName = tryGetPlugInW plgName |> View.Bind (function Some plg -> plg.plgVars   .TryFindByKeyAsView varName |_-> View.Const None ) //|> View.consistent\n                let tryGetViwW plgName viwName = tryGetPlugInW plgName |> View.Bind (function Some plg -> plg.plgViews  .TryFindByKeyAsView viwName |_-> View.Const None ) //|> View.consistent\n                let tryGetActW plgName actName = tryGetPlugInW plgName |> View.Bind (function Some plg -> plg.plgActions.TryFindByKeyAsView actName |_-> View.Const None )\n                let tryGetQryW plgName qryName = tryGetPlugInW plgName |> View.Bind (function Some plg -> plg.plgQueries.TryFindByKeyAsView qryName |_-> View.Const None )\n                let tryGetDocW plgName docName = tryGetPlugInW plgName |> View.Bind (function Some plg -> plg.plgDocs   .TryFindByKeyAsView docName |_-> View.Const None )\n                let tryGetVoVW plgName varName = \n                    tryGetVarW plgName varName\n                    |> View.Bind(function\n                        | Some var -> Some var.varVar |> View.Const\n                        | None -> \n                            tryGetViwW plgName varName\n                            |> View.Map(function\n                            | Some viw -> Var.Make viw.viwView ignore |> Some\n                            | None -> None\n                    ))\n                let tryGetWoWW plgName viwName =\n                    tryGetViwW plgName viwName\n                    |> View.Bind(function\n                        | Some viw -> viw.viwView |> View.Map Some\n                        | None -> \n                            tryGetVarW plgName viwName\n                            |> View.Bind(function\n                            | Some var -> var.varVar.View |> View.Map Some\n                            | None -> None |> View.Const\n                    ))\n            \n                let tryGetPlugIn plgName = plugIns.TryFindByKey plgName\n            \n                let tryGetVar plgName varName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgVars   .TryFindByKey varName)\n                let tryGetViw plgName viwName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgViews  .TryFindByKey viwName)\n                let tryGetAct plgName actName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgActions.TryFindByKey actName)\n                let tryGetQry plgName qryName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgQueries.TryFindByKey qryName)\n                let tryGetDoc plgName docName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgDocs   .TryFindByKey docName)\n                let tryGetVoV plgName varName = \n                    tryGetVar plgName varName \n                    |> Option.map (fun var -> Some var.varVar)\n                    |> Option.defaultWith (fun () -> \n                        tryGetViw plgName varName \n                        |> Option.map (fun viw -> Var.Make viw.viwView ignore)\n                    )\n                let tryGetWoW plgName viwName = \n                    tryGetViw plgName viwName \n                    |> Option.map (fun viw -> Some viw.viwView)\n                    |> Option.defaultWith (fun () -> \n                        tryGetVar plgName viwName \n                        |> Option.map (fun var -> var.varVar.View )\n                    )\n            \n                type TextData = \n                | TDText  of string\n                | TDAct   of PlugInAction\n            \n                let rec getOneTextData lytNm name bef aft =\n                    let plg, n = splitName lytNm name\n                    tryGetActW plg n\n                    |> View.Bind(function\n                    | Some act -> TDAct act |> View.Const\n                    | None     ->\n                    tryGetWoWW plg n\n                    |> View.Bind(function\n                        | Some txt ->\n                            getTextData lytNm aft\n                            |> View.Bind (function\n                                | TDText  b    -> View.Const <| (TDText  <|     bef + txt + b                             )\n                                | TDAct   act  -> View.Const <| (TDText  <| sprintf \"Unexpected Action @{%s}\" (act.actName.Id) )\n                            )\n                        | None                 -> View.Const <| (TDText  <| sprintf \"%s @{Missing %s}%s\" bef name aft     )  \n                        )\n                    )\n            \n                and getTextData lytNm (txt:string) =\n                    txt\n                    |> String.delimitedO \"@{\" \"}\"\n                    |> Option.map(fun (bef, name, aft) -> getOneTextData lytNm name bef aft )\n                    |> Option.defaultWith (fun () -> TDText  txt |> View.Const)\n            \n                let getAttrs lytNm (attrs: string) = [\n                    yield!  attrs\n                            |> String.splitByChar ';'\n                            |> Seq.map(String.splitByChar '=')\n                            |> Seq.choose(\n                                function \n                                | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" ->\n                                        value.Trim() \n                                        |> getTextData lytNm\n                                        |> Attr.DynamicCustom (fun el -> function\n                                            | TDText  v   -> try el.SetAttribute(name.Trim(), v.Trim())                                                                 with e -> printfn \"%A\" e\n                                            | TDAct   act -> try el.AddEventListener(name.Trim(), (fun (ev:Dom.Event) -> act.actFunction |> callFunction el ev), false) with e -> printfn \"%A\" e\n                                        )\n                                        |> Some\n                                |_      -> None )\n                    yield!  attrs\n                            |> String.splitByChar ';'\n                            |> Seq.map(String.splitByChar ':')\n                            |> Seq.choose(\n                                function \n                                | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" -> \n                                        value.Trim() \n                                        |> getTextData lytNm\n                                        |> View.Map(function\n                                            | TDText  v   -> v.Trim()\n                                            | TDAct   act -> sprintf \"@{%s}\" (act.actName.Id)\n                                        )\n                                        |> Attr.DynamicStyle (name.Trim())\n                                        |> Some\n                                |_      -> None )\n                ]\n            \n                type  Fun<'P, 'R> = { f : Val<'P -> 'R> ; p : Val<'P> }\n                and   Val<'P    > = VView of View<'P> | VConst of 'P\n                    with\n                    //[<Inline>] static member ( <* )(vf:Val<'a->'b> , a :    'a ) = VConst a\n                    [<Inline>] static member ( <* )(vf:Val<'a->'b> , aV:Var<'a>) = VView  aV.View\n            \n                type P<'T> = { r:Depend.Depend<'T> }\n            \n                type PFn<'P, 'R> = P<Fun<'P, 'R>>\n                type PVl<'P    > = P<Val<'P    >>\n            \n                open Depend.Operators\n            \n                let bindWrap       f  pv       : P<'b> = { r = pv   >>= fun v -> (f v).r }\n                let unwrapBindWrap f (pv:P<_>) : P<'b> = { r = pv.r |>> fun v ->  f v    }\n            \n                let add1 a = a + 1\n                let a11V = Var.Create 11\n            \n                let mainX = VConst add1 <* a11V\n            \n                let [<Inline>] callF f = \n                    match f with\n                    | { f = VConst f  ; p = VConst p  } -> VConst (                       f              p )\n                    | { f = VConst f  ; p = VView  pV } -> VView  (View.Apply (View.Const f)             pV)\n                    | { f = VView  fV ; p = VView  pV } -> VView  (View.Apply             fV             pV)\n                    | { f = VView  fV ; p = VConst p  } -> VView  (View.Apply             fV (View.Const p))\n            \n            \n                let baseView        = mainDocV.View\n                let makeAViewDoc  f = baseView |> Doc.BindView(fun _ -> f())\n                let makeAViewDocL f = lazy makeAViewDoc f\n                let makeAViewDoc0 f = f // fun () -> makeAViewDoc f\n            \n                let [<Inline>] callDoc f =\n                    makeAViewDoc(fun _ -> \n                        match callF f with\n                        | VConst d  -> d\n                        | VView  dW -> Doc.BindView id dW\n                    )\n            \n                let [<Inline>] callAtt f : Attr =\n                    match callF f with\n                    | VConst a  -> a\n                    | VView  aW -> failwithf \"View<Attr> not implemented\"\n            \n                let [<Inline>] ff f p = { f = f       ; p = p }\n                let [<Inline>] fc c p = { f = callF c ; p = p }\n            \n                let [<Inline>] pff pf p = { r = pf.r |>> fun f -> ff f p }\n                let [<Inline>] pfc pc p = { r = pc.r |>> fun c -> fc c p }\n            \n                module Val =\n            \n                    let map f = function\n                    | VConst p  -> VConst (         f p )\n                    | VView  pv -> VView  (View.Map f pv)\n            \n                    let rtn = VConst\n                    let apply (fv:Val<'a->'b>) (vv:Val<'a>) : Val<'b> = \n                        match fv, vv with\n                        | VConst f  , VConst p  -> VConst (                       f              p )\n                        | VConst f  , VView  pV -> VView  (View.Apply (View.Const f)             pV)\n                        | VView  fV , VView  pV -> VView  (View.Apply             fV             pV)\n                        | VView  fV , VConst p  -> VView  (View.Apply             fV (View.Const p))\n            \n                    let (<*>)                        =  apply\n                    let       traverseListApp f list =  let cons head tail = head :: tail\n                                                        let folder head tail = rtn cons <*> f head <*> tail\n                                                        List.foldBack folder list (rtn [])\n                    let inline sequenceListApp  list =  traverseListApp id list\n            \n            \n                    let toView = function\n                    | VConst p  -> View.Const p\n                    | VView  pv ->            pv\n            \n                    let addDoc d (docs:Val<seq<Doc>>) =\n                        match docs with\n                        | VConst ds  -> VConst (Seq.append ds [ d ] )\n                        | VView  dsW -> VConst (seq [ Doc.BindView Doc.Concat dsW ; d ])\n            \n                    let addAtt a (atts:Val<seq<Attr>>) =\n                        match atts with\n                        | VConst ats  -> VConst (Seq.append ats [ a ] )\n                        | VView  atsW -> failwithf \"addAtt for VView not implemented\"// VConst (seq [ Doc.BindView Doc.Concat atsW ; a ])\n            \n                    let textDoc = function\n                    | VConst txt  -> Html.text     txt\n                    | VView  txtW -> Html.textView txtW\n            \n                    let textAtt : Val<string> -> Attr = fun _ -> failwithf \"textAtt not implemented\"\n            \n                let choiceToString   = function Choice1Of2 v -> v | Choice2Of2 r -> sprintf \"@{%A}\" r\n                let valToStyle atn = function\n                | VConst s -> Attr.Style  atn s\n                | VView  w -> Attr.DynamicStyle atn w\n            \n                let valToAttr atn = function\n                | VConst s -> Attr.Create  atn s\n                | VView  w -> Attr.Dynamic atn w\n            \n                type AAttr = \n                | AStyle of string * string\n                | AAttr  of string * string\n                | AAttrX of string * string\n                | AEmpty\n            \n                module Extract0 =\n            \n                    type TextType =\n                    | TSimple    of string\n                    | TReference of string\n            \n                    let getDocFromReference         ref = sprintf \"getDocFromReference not implemented: @{%s}\"         ref |> Html.text\n                    let getTextActViewFromReference ref = sprintf \"getTextActViewFromReference not implemented: @{%s}\" ref |> Choice1Of2 |> View.Const : View<Choice<string, PlugInAction>>\n            \n                    let rec getOneTextData(bef, name, aft) =\n                        TReference name ::  match aft with\n                                            | \"\"  -> []\n                                            | aft -> getTextData aft\n                        |> \n                        match bef with\n                        | \"\"  -> id\n                        | bef -> fun ls -> TSimple bef :: ls\n                    and getTextData (txt:string) =\n                        txt\n                        |> String.delimitedO \"@{\" \"}\"\n                        |> Option.map getOneTextData\n                        |> Option.defaultWith (fun () -> [ TSimple txt ])\n            \n                    let getDocFromReferenceD         = Depend.dependByName \"getDocFromReference\"         getDocFromReference         id\n                    let getTextActViewFromReferenceD = Depend.dependByName \"getTextActViewFromReference\" getTextActViewFromReference id\n            \n                    let getDocFromTextTypesD = Depend.depend {\n                        let! getDoc = getDocFromReferenceD\n                        return\n                            List.map (function\n                                | TSimple    t -> Html.text   t\n                                | TReference r -> getDoc r\n                            ) \n                            >> Doc.Concat\n                    }\n            \n                    let extractDocD = Depend.depend {\n                        let! getDocFromTextTypes = getDocFromTextTypesD\n                        return getTextData >> getDocFromTextTypes\n                    }\n            \n                    let getTextValFromSeqD = Depend.depend {\n                        let! getTextActView = getTextActViewFromReferenceD\n                        return \n                            Val.traverseListApp (function\n                                | TSimple    v -> VConst     v\n                                | TReference r -> getTextActView r |> View.Map (function Choice1Of2 s -> s | Choice2Of2 _ -> sprintf \"@{%s}\" r) |> VView\n                            )\n                            >> Val.apply (VConst (String.concat \"\"))\n                    }\n            \n                    let getTextValD = getTextData >*> getTextValFromSeqD\n            \n                    let extractAtsD = Depend.depend {\n                        let! getTextVal     = getTextValD\n                        let! getTextActView = getTextActViewFromReferenceD\n                        return fun txt ->\n                            let parseAttr (t:string) =\n                                match t.Split ':' with\n                                | [| atn ; sty |] -> AStyle(atn, sty)\n                                | _ ->\n                                match t.Split '=' |> Array.map (fun t -> t.Trim()) with\n                                | [| atn; atv |] -> match getTextData atv with\n                                                    | [ TReference r ] -> AAttrX(atn, r  )\n                                                    |_                 -> AAttr (atn, atv)\n                                | [| at       |] -> AAttr(at, \"\")\n                                |_-> AEmpty\n                            let splitAttrs (txt:string) =\n                                txt.Split ';'\n                                |> Seq.map    (fun t -> t.Trim())\n                                |> Seq.filter ((<>) \"\")\n                            let addedListeners el : (string * (Dom.Event -> unit)) [] = el?addedListeners |> fun v -> if isUndefined v then [||] else v\n                            let setCustomAttr atn (el:Dom.Element) = function\n                                | Choice1Of2 s   -> try el.SetAttribute(atn, (s:string).Trim()) with e -> printfn \"%A\" e\n                                | Choice2Of2 act ->\n                                    let listener (ev:Dom.Event) = (act:PlugInAction).actFunction |> callFunction el ev\n                                    let same, others = addedListeners el |> Array.partition (fst >> (=) atn)\n                                    for (_,f) in same do\n                                        el.RemoveEventListener(atn, f)\n                                    el.AddEventListener(   atn, listener, false)\n                                    el?addedListeners <- Array.append others [| atn, listener |]\n                            let viewAttr atn = Attr.DynamicCustom (setCustomAttr atn)\n                            let constAttr = function\n                                | AStyle(n, v) -> getTextVal     v |> valToStyle n\n                                | AAttr (n, v) -> getTextVal     v |> valToAttr  n\n                                | AAttrX(n, v) -> getTextActView v |> viewAttr   n\n                                | AEmpty       -> Attr.Empty\n                            let viewAttrs = \n                                Attr.DynamicCustom(fun el sq ->\n                                    let styles = sq |> Seq.choose (function AStyle(n,v) -> Some (n + \":\" + v) |_-> None)\n                                    let atts = [|\n                                        if Seq.isEmpty styles |> not then\n                                            yield (\"style\", String.concat \";\" styles)\n                                        yield! sq\n                                            |> Seq.choose (function\n                                                | AStyle _     -> None\n                                                | AAttr (n, v) -> Some(n, v)\n                                                | AAttrX(n, v) -> Some(n, v)\n                                                | AEmpty       -> None\n                                            )\n                                    |]\n                                    let attsNow = seq [ for i in [0..el.Attributes.Length-1] -> el.Attributes.[i].Name, el.Attributes.[i].Value ]\n                                    let names   = Seq.map fst >> Set\n                                    for nm in names attsNow - names atts do \n                                        try el.Attributes.RemoveNamedItem nm |> ignore            with e -> printfn \"%A\" e\n                                    for (n,v) in Set atts - Set attsNow do\n                                        try el.SetAttribute(n, v)                                 with e -> printfn \"%A\" e\n                                    for (n,l) in addedListeners el do \n                                        try el.RemoveEventListener(n, (unbox l : System.Action) ) with e -> printfn \"%A\" e\n                                    for (n,v) in sq |> Seq.choose (function AAttrX(n, v) -> Some(n, v) |_-> None) do\n                                        getTextActView v |> View.Get (setCustomAttr n el)\n                                )\n                            let extract (txt:string) =\n                                splitAttrs txt\n                                |> Seq.toArray\n                                |> function\n                                    | [| v |] ->    \n                                        match getTextVal v with\n                                        | VConst v -> parseAttr v |> constAttr\n                                        | VView  w -> w |> View.Map (splitAttrs >> Seq.map parseAttr) |> viewAttrs\n                                        |> Seq.singleton\n                                    | vs -> vs |> Seq.map (parseAttr >> constAttr) \n                            extract txt\n                    }\n            \n                    let extractTextD = Depend.depend {\n                        let! getTextVal = getTextValD\n                        return getTextVal >> Val.toView \n                    }\n            \n                let currentPlugInNameDef : PlugInName = PlugInName \"NewLYx\"\n                let currentPlugInNameD                = Depend.dependByName \"currentPlugInName\" currentPlugInNameDef id\n            \n                let getDocwD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    return fun r -> \n                        let pName, oName = splitName currentPlugInName r\n                        tryGetDocW pName oName\n                        |> Doc.BindView (fun docO -> \n                            docO\n                            |> Option.map getActualDoc\n                            |> Option.defaultWith (fun () ->\n                                tryGetWoWW pName oName\n                                |> View.Map (Option.defaultWith (fun () -> sprintf \"Reference not found @{%s}\" r))\n                                |> Doc.TextView\n                            )\n                        )\n                }\n            \n                let getDocD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    return fun r -> \n                        let pName, oName = splitName currentPlugInName r\n                        tryGetDoc pName oName\n                        |> Option.map getActualDoc\n                        |> Option.defaultWith (fun () ->\n                            tryGetWoW pName oName\n                            |> Option.defaultWith (fun () -> sprintf \"Reference not found @{%s}\" r |> View.Const)\n                            |> Doc.TextView\n                        )\n                }\n            \n                let getTextActViewD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    return fun r ->\n                        let pName, oName = splitName currentPlugInName r\n                        tryGetActW pName oName\n                        |> View.Bind(function\n                            | Some act -> View.Const <| Choice2Of2 act\n                            | None     ->\n                            tryGetWoWW pName oName\n                            |> View.Map (Option.defaultWith (fun () -> sprintf \"Text Reference not found @{%s}\" r))\n                            |> View.Map Choice1Of2\n                        )\n                }\n            \n                let errDoc  txt = Html.div [] [ Html.text txt ]\n                let errDocf fmt = Printf.ksprintf errDoc fmt\n            \n                let run (pin:PlugInName) d =\n                    depend {\n                        let! getDoc            = getDocwD\n                        let! getTextActView    = getTextActViewD\n                        let! currentPlugInName = currentPlugInNameD\n                        return \n                            d\n                            |> Depend.resolver [\n                                \"getDocFromReference\"        , getDoc            :> obj\n                                \"getTextActViewFromReference\", getTextActView    :> obj\n                                \"currentPlugInName\"          , currentPlugInName :> obj\n                            ]\n                    } |> Depend.resolver [ \"currentPlugInName\", pin ]\n            \n                let extractTextD    = Extract0.extractTextD\n                let extractDocD     = Extract0.extractDocD\n                let extractAtsD     = Extract0.extractAtsD\n                let extractAttD     = depend { \n                    let! extractAts = extractAtsD\n                    return fun p -> extractAts p |> Attr.Concat \n                }\n            \n            \n                let defPlugInName = PlugInName \"AppFramework\"\n                let runDef d = run defPlugInName d\n            \n                let getParmRef var =\n                    var\n                    |> String.delimitedO \"@{\" \"}\"\n                    |> Option.map (fun (a,b,c) -> b)\n                    |> Option.defaultValue var\n                    |> splitName defPlugInName\n            \n                let depWithExtracts f =\n                    Depend.depend {\n                        let! extractAts  = extractAtsD\n                        let! extractDoc  = extractDocD\n                        let! extractText = extractTextD\n                        return f(extractAts, extractDoc, extractText)\n                    } |> runDef\n            \n                let docWithVar f var =\n                    getParmRef var\n                    ||> tryGetVoVW\n                    |> Doc.BindView (\n                        Option.map f\n                        >> Option.defaultWith(fun () ->  sprintf \"Var not found %s\" var |> errDoc )\n                    )\n            \n                let inputFile attrs labelName actName =\n                    splitName defPlugInName actName\n                    ||> tryGetAct\n                    |> Option.map(fun act -> \n                        Html.div (getAttrs defPlugInName attrs) [\n                            Html.div              [ attr.``class`` \"input-group\"       ] [\n                                Html.span         [ attr.``class`` \"input-group-btn\"   ] [ \n                                    Html.label    [ attr.``class`` \"btn\"               ] [ \n                                        Html.text labelName\n                                        Html.input[ attr.``class`` \"form-control\" \n                                                    attr.``type`` \"file\" \n                                                    Attr.Style \"display\" \"none\" \n                                                    Html.on.click (fun el ev -> el?value <- \"\")\n                                                    Html.on.change(fun el ev -> act.actFunction |> callFunction el ev )\n                                                    ] []\n                                    ]\n                                ]\n                                //(if doc <> \"\" then singleDoc lytNm [ UnQuoted doc ] else Doc.Empty)\n                            ]\n                        ]\n                    ) |> Option.defaultWith(fun () ->  sprintf \"Action not found %s\" actName |> errDoc )\n            \n                let inputLabel =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) attrs labelName ->\n                        docWithVar (fun var -> \n                            Html.div (extractAts attrs) [\n                                Html.div      [ attr.``class`` \"input-group\"       ] [\n                                    Html.span [ attr.``class`` \"input-group-addon\" ] [ extractDoc labelName ]\n                                    Doc.Input [ attr.``class`` \"form-control\"      ]   var\n                                ]\n                            ]\n                        )\n            \n                let input =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) attrs ->\n                        docWithVar (Doc.Input <| extractAts attrs )\n            \n                let textArea =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) attrs ->\n                        docWithVar (Doc.InputArea <| extractAts attrs)\n            \n                let htmlDoc =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) html ->\n                        extractText html\n                        |> Doc.BindView Doc.Verbatim\n            \n                //let docReference =\n                //    let mutable lastRun = Date.Now()\n                //    let refresh () =\n                //        if Date.Now() - lastRun > 1000 then\n                //            mainDocV.Set mainDocV.Value\n                //            lastRun <- Date.Now()\n                //    depWithExtracts <| fun (extractAts, extractDoc, extractText) docName ->\n                //        extractText docName\n                //        |> View.Map  (splitName defPlugInName)\n                //        |> View.Bind ( __ (||>) tryGetDocW   )\n                //        |> Doc.BindView (function\n                //            | Some { docDoc = LazyDoc d} -> refresh() ; d.Value\n                //            | Some { docDoc = FunDoc0 f} -> refresh() ; f()\n                //            | Some d -> errDocf \"Doc parameters not resolved: %A\" d\n                //            | None   -> errDocf \"Doc not found: %s\" docName\n                //        )\n            \n                let inline (|Lazy|) (l:Lazy<_>) = l.Value\n            \n                let docReference =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) docName ->\n                        extractText docName\n                        |> View.Map  (splitName defPlugInName)\n                        |> View.Bind ( __ (||>) tryGetDocW   )\n                        |> Doc.BindView (function\n                            | Some { docDoc = Lazy(JustDoc d)} -> d\n                            | Some { docDoc = Lazy(FunDoc0 f)} -> f()\n                            | Some d -> errDocf \"Doc parameters not resolved: %A\" d\n                            | None   -> errDocf \"Doc not found: %s\" docName\n                        )\n            \n                let setVar0 = \n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) (varN:obj, value:obj) ->\n                        unbox varN\n                        |>  getParmRef\n                        ||> tryGetVoV\n                        |>  Option.iter(fun var ->\n                                unbox value\n                                |> extractText\n                                |> View.Get var.Set\n                            )\n            \n                let setVar varN value = setVar0(varN, value)\n            \n                let setVarDirect0 = \n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) (varN:obj, text:obj) ->\n                        unbox varN\n                        |>  getParmRef\n                        ||> tryGetVoV\n                        |>  Option.iter(fun var -> \n                                unbox text\n                                |> var.Set\n                            )\n                let setVarDirect  varN value = setVarDirect0(varN, value)\n                let setVarDirectD varN value = delayed 100 (setVarDirect varN) value\n            \n                let getValDirect = \n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) (varN:string) ->\n                        varN\n                        |>  getParmRef\n                        ||> tryGetWoW\n                        |>  Option.bind View.TryGet\n                        |>  Option.defaultValue null\n            \n                let draggingEvent first (value: Var<string>) (ev: Dom.MouseEvent) =\n                    let el : Dom.Element = ev?toElement\n                    let vertical = el.ParentElement.HasAttribute \"vertical\"\n                    let getSize (el:Dom.Element) : float =\n                        el.GetBoundingClientRect() \n                        |> fun r ->\n                                match vertical, first with\n                                | true , true  ->  r.Width \n                                | true , false -> -r.Width \n                                | false, true  ->  r.Height\n                                | false, false -> -r.Height\n                    let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                    let startP   = value.Value |> ParseO.parseDoubleO |> Option.defaultValue 0.\n                    let start    = mouseCoord ev\n                    let gap      = getSize    el\n                    let size     = getSize    el.ParentElement\n                    let drag (ev: Dom.Event) =\n                        ev :?> Dom.MouseEvent\n                        |> mouseCoord\n                        |> fun m   -> (m - start) * 100.0 / (size - gap) + startP\n                        |> max 0. \n                        |> min 100.\n                        |> string\n                        |> String.left 5\n                        |> fun v -> if value.Value <> v then value.Set v\n                    let rec finishDragging (_: Dom.Event) =\n                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                    do  JS.Window.AddEventListener   (\"mousemove\", drag          , false) \n                    do  JS.Window.AddEventListener   (\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n            \n                let dragSplitter0 = \n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) (varN, eventD:Dom.MouseEvent) ->\n                        varN\n                        |>  getParmRef\n                        ||> tryGetVoV\n                        |>  Option.iter(fun var -> draggingEvent true var eventD )\n                let dragSplitter varN eventD = dragSplitter0(unbox varN, unbox eventD)\n            \n                let trigAct =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) trigger actN ->\n                        extractText trigger\n                        |> Doc.BindView(function\n                        | null -> ()\n                        |_     ->\n                            getParmRef actN\n                            ||> tryGetAct \n                            |>  Option.iter(fun a -> callFunction () () a.actFunction )\n                        >> fun _ -> Html.div [] []\n                        )\n            \n                let trigActChange =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) trigger actN ->\n                        extractText trigger\n                        |> View.consistent\n                        |> View.Map(function\n                        | null -> ()\n                        |_     ->\n                            getParmRef actN\n                            ||> tryGetAct \n                            |>  Option.iter(fun a -> callFunction () () a.actFunction )\n                        >> fun _ -> \"\"\n                        ) |>  Doc.TextView\n            \n                let callAction0 =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) actN (p1:obj) (p2:obj) ->\n                        getParmRef actN\n                        ||> tryGetAct \n                        |>  Option.iter(fun a -> callFunction p1 p2 a.actFunction )\n            \n                let callAction actN p1 p2 = callAction0 actN p1 p2\n            \n                let delayAction =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) delay actN ->\n                        getParmRef (unbox actN)\n                        ||> tryGetAct \n                        |> Option.iter(fun a -> \n                            async {\n                                let! d = extractText (unbox delay) |> View.GetAsync\n                                do! Async.Sleep (ParseO.parseIntO d |> Option.defaultValue 100)\n                                callFunction () () a.actFunction\n                            } |> Async.Start\n                        )\n            \n                let select =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) attrs none vals ->\n                        docWithVar (fun var ->\n                            let valsW = V ((extractText vals).V.Split ';' |> Seq.toList)\n                            let varO  = \n                                Var.Make \n                                    (V (match var.V with \n                                        | s when Seq.contains (s.Trim()) valsW.V -> Some(s.Trim()) \n                                        |_-> None )) \n                                    (function \n                                     | None   ->                                                        var.Set \"\" \n                                     | Some s -> valsW |> View.Get (fun vs -> if Seq.contains s vs then var.Set s ) )\n                            Doc.SelectDynOptional (extractAts attrs) none id valsW varO\n                        )\n            \n                let addPlugIn p =\n                    newViw (PlgElemName \"PlugInName\") (View.Const p.plgName.Id)\n                    |> p.plgViews.Append\n                    plugIns.Add p\n            \n                let splitterPerc =\n                    depWithExtracts <| fun (extractAts, extractDoc, extractText) template attrs doc1 doc2 ->\n                        docWithVar (fun var -> \n                            Html.div (extractAts attrs) [\n                                docReference doc1\n                                docReference doc2\n                            ]\n                        )\n                if IsClient then\n                    plugin { \n                        plgName  \"AppFramework\" \n                        plgVar   \"mainDocV\"     mainDocV\n                        plgDoc   \"AppFwkClient\" AppFwkClient\n                        plgAct   \"Hello\"        (fun () -> JS.Window.Alert \"Hello!\")\n                    } |> addPlugIn\n                    plugin { \n                        plgName  \"AF\"\n                        plgDoc1  \"DocReference\"  docReference  \"DocName\"\n                        plgDoc1  \"HtmlDoc\"       htmlDoc       \"Html\"\n                        plgDoc2  \"TrigAction\"    trigAct       \"Trigger\"  \"Action\"\n                        plgDoc2  \"TrigChange\"    trigActChange \"Trigger\"  \"Action\"\n                        plgDoc2  \"Input\"         input         \"Attrs\"                  \"Var\"\n                        plgDoc2  \"TextArea\"      textArea      \"Attrs\"                  \"Var\"\n                        plgDoc4  \"Select\"        select        \"Attrs\"    \"None\" \"Vals\" \"Var\"\n                        plgDoc3  \"InputFile\"     inputFile     \"Attrs\"    \"Label\" \"Action\"\n                        plgDoc3  \"InputLabel\"    inputLabel    \"Attrs\"    \"Label\"       \"Var\"\n                        plgDoc5  \"SplitterPerc\"  splitterPerc  \"Template\" \"Attrs\" \"doc1\" \"doc2\" \"Var\"\n                        plgAct2  \"SetVar\"        setVar        \"Var\"      \"Value\"\n                        plgAct2  \"SetVarDirect\"  setVarDirect  \"Var\"      \"from\"\n                        plgAct2  \"SetVarDirectD\" setVarDirectD \"Var\"      \"from\"\n                        plgAct2  \"DelayAction\"   delayAction   \"delay\"    \"Äction\"\n                        plgAct   \"Hello\"         (fun () -> JS.Window.Alert \"Hello!\")\n                        plgAct2  \"DragSplitter\"  dragSplitter  \"Var\"      \"dragEvent\"\n                        plgQuery \"getDocNames\"   (fun (_:obj) -> plugIns.Value |> Seq.collect (fun plg -> plg.plgDocs |> Seq.map (fun doc -> plg.plgName.Id + \".\" + doc.docName.Id)) |> Seq.toArray |> box)\n                        plgView  \"MouseX\"        (View.Map (fst >> string               ) UI.Input.Mouse   .Position     )\n                        plgView  \"MouseY\"        (View.Map (snd >> string               ) UI.Input.Mouse   .Position     )\n                        plgView  \"MouseLeft\"     (View.Map (function true -> \"1\" |_->\"0\") UI.Input.Mouse   .LeftPressed  )\n                        plgView  \"MouseRight\"    (View.Map (function true -> \"1\" |_->\"0\") UI.Input.Mouse   .RightPressed )\n                        plgView  \"MouseMiddle\"   (View.Map (function true -> \"1\" |_->\"0\") UI.Input.Mouse   .MiddlePressed)\n                        plgView  \"Keyboard\"      (View.Map (sprintf \"%A\"                ) UI.Input.Keyboard.KeysPressed  )\n                    } |> addPlugIn\n            \n                    //titleV.View\n                    //|> View.Bind(fun nm ->\n                    //    nm\n                    //    |> String.splitByChar '.'\n                    //    |> (function [| a ; b |] -> tryGetWoW a b |_-> None)\n                    //    |> Option.defaultWith (fun () -> mainDocV.View )\n                    //) |> View.Sink (fun v -> \n                    //    async {\n                    //        do! Async.Sleep 500\n                    //        JS.Window.Document.Title <- v \n                    //    } |> Async.Start\n                    //)\n            \n                let getMainDoc =\n                  lazy\n                    WcSplitter.init horizontal vertical\n                    WcTabStrip.init.Value\n                    mainDoc()\n            \n            \n            \n            /////////////////////////////////////////////////////////////////////////////////////////////\n            \n                type P<'P> with\n                    [<Inline>] static member (<*)(vf:PVl<    'a   ->'b> ,  a :      'a   )  =                                            pff vf (VConst  a                     )\n                    [<Inline>] static member (<!)(vf:PVl<    'a   ->'b> , pav:PVl<  'a  >) = pav.r       |> bindWrap (fun av         -> pff vf          av )\n                    [<Inline>] static member (<!)(vf:PVl<    'a   ->'b> ,  aW:View< 'a  >)  =                                            pff vf (VView   aW                    )\n                    [<Inline>] static member (<!)(vf:PVl<    'a   ->'b> ,  aV:Var<  'a  >)  =                                            pff vf (VView   aV.View               )\n                    [<Inline>] static member (<!)(vf:PVl<    'a   ->'b> , paF:PFn<_,'a  >) = paF.r       |> bindWrap (fun aF         -> pff vf (callF   aF                    ) )\n                    [<Inline>] static member (<&)(vf:PVl<seq<Doc >->'b> ,  a :   string  ) = extractDocD |> bindWrap (fun extractDoc -> pff vf (VConst (seq [extractDoc a  ]) ) )\n                    [<Inline>] static member (<&)(vf:PVl<seq<Doc >->'b> , paF:PFn<_,Doc >) = paF.r       |> bindWrap (fun aF         -> pff vf (VConst (seq [callDoc    aF ]) ) )\n                    [<Inline>] static member (<&)(vf:PVl<    Doc  ->'b> ,  a :   string  ) = extractDocD |> bindWrap (fun extractDoc -> pff vf (VConst (     extractDoc a   ) ) )\n                    [<Inline>] static member (<&)(vf:PVl<    Doc  ->'b> , paF:PFn<_,Doc >) = paF.r       |> bindWrap (fun aF         -> pff vf (VConst (     callDoc    aF  ) ) )\n            //        [<Inline>] static member (<&)(vf:Val<seq<Doc>->'b> , aF:Fun<_,Doc>) = ff vf (VConst (seq [callDoc aF ]) )\n            \n                    [<Inline>] static member (<&)(vf:PVl<seq<Attr>->'b> ,  a :   string  ) = extractAtsD |> bindWrap (fun extractAts -> pff vf (VConst (     extractAts a   ) ) )\n                    [<Inline>] static member (<&)(vf:PVl<seq<Attr>->'b> , paF:PFn<_,Attr>) = paF.r       |> bindWrap (fun aF         -> pff vf (VConst (seq [callAtt    aF ]) ) )\n                    [<Inline>] static member (<&)(vf:PVl<    Attr ->'b> ,  a :   string  ) = extractAttD |> bindWrap (fun extractAtt -> pff vf (VConst (     extractAtt a   ) ) )\n                    [<Inline>] static member (<&)(vf:PVl<    Attr ->'b> , paF:PFn<_,Attr>) = paF.r       |> bindWrap (fun aF         -> pff vf (VConst (     callAtt    aF  ) ) )\n            \n                type P<'P> with    \n                    [<Inline>] static member (<*)(vc , p         ) = pfc vc  (VConst p       )\n                    [<Inline>] static member (<!)(vc , p         ) = pfc vc          p\n                    [<Inline>] static member (<!)(vc , p         ) = pfc vc  (VView  p       )\n                    [<Inline>] static member (<!)(vc , pV:Var< _>) = pfc vc  (VView  pV.View )\n                    [<Inline>] static member (<!)(vc , p:Fun<_,_>) = pfc vc  (callF  p       )\n            \n                    [<Inline>] static member (<&)(c:PFn<_,     Attr  -> _> ,  p :      string ) = extractAttD |> bindWrap (fun extractAtt -> pfc c       (VConst (       extractAtt        p   ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Attr  -> _> ,  p :Val<  string>) =                                            pfc c       (VConst (      Val.textAtt        p   ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Attr  -> _> , paF:PFn<_,string>) = paF.r       |> bindWrap (fun aF         -> pfc c       (VConst (      Val.textAtt (callF aF) ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Attr  -> _> , paF:PFn<_,Attr  >) = paF.r       |> bindWrap (fun aF         -> pfc c       (VConst (          callAtt        aF  ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Attr  -> _> , p  :      Attr   ) =                                            pfc c       (VConst (                         p   ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Attr> -> _> , p  :      string ) = extractAtsD |> bindWrap (fun extractAts -> pfc c       (VConst (       extractAts        p   ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Attr> -> _> , p  :Val<  string>) =                                            pfc c       (VConst (seq [ Val.textAtt        p  ]) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Attr> -> _> , paF:PFn<_,string>) = paF.r       |> bindWrap (fun aF         -> pfc c       (VConst (seq [ Val.textAtt (callF aF)]) ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Attr> -> _> , paF:PFn<_,Attr  >) = paF.r       |> bindWrap (fun aF         -> pfc c       (VConst (seq [     callAtt        aF ]) ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Attr>,   _> , p  :      string ) = extractAttD |> bindWrap (fun extractAtt -> c |> unwrapBindWrap (fun c -> { c with p = Val.addAtt(  extractAtt        p  ) c.p } ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Attr>,   _> , p  :Val<  string>) =                                            c |> unwrapBindWrap (fun c -> { c with p = Val.addAtt( Val.textAtt        p  ) c.p } )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Attr>,   _> , paF:PFn<_,string>) = paF.r       |> bindWrap (fun aF         -> c |> unwrapBindWrap (fun c -> { c with p = Val.addAtt( Val.textAtt (callF aF)) c.p } ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Attr>,   _> , paF:PFn<_,Attr  >) = paF.r       |> bindWrap (fun aF         -> c |> unwrapBindWrap (fun c -> { c with p = Val.addAtt(     callAtt        aF ) c.p } ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Attr>,   _> , p  :      Attr   ) =                                          c |> unwrapBindWrap (fun c -> { c with p = Val.addAtt                     p    c.p } )\n            \n                    [<Inline>] static member (<&)(c:PFn<_,     Doc   -> _> , p  :      string ) = extractDocD |> bindWrap (fun extractDoc -> pfc c       (VConst (       extractDoc        p   ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Doc   -> _> , p  :Val<  string>) =                                            pfc c       (VConst (      Val.textDoc        p   ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Doc   -> _> , paF:PFn<_,string>) = paF.r     |> bindWrap (fun aF           -> pfc c       (VConst (      Val.textDoc (callF aF) ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Doc   -> _> , paF:PFn<_,Doc   >) = paF.r     |> bindWrap (fun aF           -> pfc c       (VConst (          callDoc        aF  ) ) )\n                    [<Inline>] static member (<&)(c:PFn<_,     Doc   -> _> , p  :      Doc    ) =                                            pfc c       (VConst (                         p   ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Doc > -> _> , p  :      string ) = extractDocD |> bindWrap (fun extractDoc -> pfc c       (VConst (seq [  extractDoc        p  ]) ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Doc > -> _> , p  :Val<  string>) =                                            pfc c       (VConst (seq [ Val.textDoc        p  ]) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Doc > -> _> , paF:PFn<_,string>) = paF.r     |> bindWrap (fun aF           -> pfc c       (VConst (seq [ Val.textDoc (callF aF)]) ) )\n                    [<Inline>] static member (<&)(c:PFn<_, seq<Doc > -> _> , paF:PFn<_,Doc   >) = paF.r     |> bindWrap (fun aF           -> pfc c       (VConst (seq [     callDoc        aF ]) ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Doc >,   _> , p  :      string ) = extractDocD |> bindWrap (fun extractDoc -> c |> unwrapBindWrap (fun c -> { c with p = Val.addDoc(  extractDoc        p  ) c.p }) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Doc >,   _> , p  :Val<  string>) =                                            c |> unwrapBindWrap (fun c -> { c with p = Val.addDoc( Val.textDoc        p  ) c.p } )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Doc >,   _> , paF:PFn<_,string>) = paF.r     |> bindWrap (fun aF           -> c |> unwrapBindWrap (fun c -> { c with p = Val.addDoc( Val.textDoc (callF aF)) c.p } ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Doc >,   _> , paF:PFn<_,Doc   >) = paF.r     |> bindWrap (fun aF           -> c |> unwrapBindWrap (fun c -> { c with p = Val.addDoc(     callDoc        aF ) c.p } ) )\n                    [<Inline>] static member (<!)(c:PFn<   seq<Doc >,   _> , p  :      Doc    ) =                                            c |> unwrapBindWrap (fun c -> { c with p = Val.addDoc                     p    c.p } )\n            \n                let inline (!) v = { r = VConst v |> rtn }\n            \n                let concatMainDocs plugins = \n                    plugins \n                    |> Seq.choose (fun plg -> Seq.tryHead plg.plgDocs) \n                    |> Seq.choose (function \n                                    | {docDoc = Lazy(JustDoc d)}-> Some d \n                                    | {docDoc = Lazy(FunDoc0 f)}-> Some(f()) \n                                    |_-> None) \n                    |> Doc.Concat\n            \n                let lensStrO (sel:Var<string option>) =\n                    Var.Make \n                        (V ( match sel.V with Some s -> s |_-> \"\" )) \n                        (fun s -> if s = \"\" then sel.Set None\n                                  else Some s |> sel.Set)\n                let mapVarO ofBO toB (sel:Var<_ option>) = \n                    Var.Make(V (sel.V |> Option.map toB)) \n                            (function Some s -> ofBO s |> Option.iter (Some >> sel.Set) |_-> sel.Set None) \n            \n                type ListModelData<'K, 'D when 'K : equality> = {\n                    elemsW : View<ListModel<'K, 'D>>\n                    doc    : unit -> Doc\n                    selV   : Var<'K option>\n                    add    : unit -> 'D  \n                    delCur : unit -> unit\n                    def    : 'D\n                } with \n                    member this.PlugIn ofStrO toStr = plugin {\n                        plgDoc0   \"list\" (this.doc         )\n                        //doc    \"cur\"  (lazy this.CurrentDoc  )\n                        plgVar    \"sel\"  (this.selV |> mapVarO ofStrO toStr |> lensStrO )\n                        plgAct    \"add\"  (this.add >> ignore    )\n                        plgAct    \"del\"  this.delCur\n                    }\n                    member this.CurrentW = View.Do {\n                            let! elems = this.elemsW\n                            let! selO  = this.selV.View\n                            match selO with\n                            | Some sel   -> let! elemO = elems.TryFindByKeyAsView sel\n                                            match elemO with\n                                            | Some elem -> return elem\n                                            | None      -> return this.def\n                            | None                      -> return this.def\n                        }\n                    member this.CurrentV =\n                        Var.Make this.CurrentW\n                                (fun v -> \n                                    match this.selV.Value with \n                                    | Some k -> this.elemsW |> View.Get (fun elems -> if elems.ContainsKey k then elems.Add v ) \n                                    | None -> ())\n            \n            //module LayoutEngine =\n            //    open LayoutEngine\n            //    module AF = AppFramework\n            //\n            //    let addLayout0 lyt = \n            //        addLayout  lyt\n            //        AF.mainDocV.Set <| UoM.Untag lyt.lytName\n            \n            //module ListModel =\n            //    let MapLens predO (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n            //        let get k v = f k (m.Lens k)\n            //        match predO with\n            //        | None       -> m.ViewState |> View.MapSeqCachedViewBy m.Key get \n            //        | Some predW ->\n            //            (m.ViewState, predW) \n            //            ||> View.Map2(fun vms pred -> vms.ToArray (System.Predicate pred)) \n            //            |> View.MapSeqCachedViewBy m.Key get \n            \n            module LM =\n                module AF = AppFramework\n            \n                let getDocForW (elementsW: View<ListModel<_,_>>) keyF def newF predWO elUI =\n                    let selected0 : Var<_ option>  = Var.Create None\n                    let selView = View.Do {\n                        let! elements = elementsW\n                        let! selO = selected0.View\n                        match selO with \n                        | None      -> return None\n                        | Some sel  ->\n                        let! exists = elements.ContainsKeyAsView sel\n                        if not exists then return None else\n                        return Some sel\n                        //match predWO with\n                        //| None       -> return Some sel\n                        //| Some predW ->\n                        //let! v    = elements.FindByKeyAsView sel\n                        //let! pred = predW\n                        //return if pred v then Some sel else None\n                    }\n                    let selectedV : Var<_ option>  = \n                        Var.Make\n                            selView\n                            (fun v -> elementsW |> View.Get(fun elements -> \n                                match v with \n                                | Some k when elements.ContainsKey k -> Some k \n                                |_-> None\n                                |> fun v -> if selected0.Value <> v then selected0.Set v )\n                            )\n                    let addNew () =\n                        let n = newF()\n                        elementsW |> View.Get (fun elements ->\n                            elements.Add n\n                            selectedV.Set (Some <| keyF n)\n                        )\n                        n\n                    let delete  k = fun () -> selectedV.Set None ; elementsW |> View.Get (fun elements -> elements.RemoveByKey k)\n                    let result = {\n                        AF.elemsW = elementsW\n                        AF.doc    = fun () -> Doc.Empty\n                        AF.selV   = selectedV\n                        AF.delCur = fun () -> selectedV.Value |> Option.iter (fun k -> delete k () )\n                        AF.add    = addNew\n                        //AF.getDoc = elUI selectedV ignore\n                        AF.def    = def\n                    }\n                    let elUIF     = elUI result\n                    let listW     = elementsW |> View.Bind ( fun elems -> elems |> ListModel.MapLens predWO (fun k v -> elUIF (View.Const (Some k)) v ) )\n                    { result with AF.doc = fun () -> listW |> Doc.BindSeqCached id }\n            \n                let getDocFor (elements: ListModel<_,_>) def newF predWO elUI = getDocForW (View.Const elements) elements.Key def newF predWO elUI\n            \n                let getDoc keyF def newF predWO elUI =\n                    let elements  : ListModel<_,_> = ListModel.Create keyF []\n                    getDocFor elements def newF predWO elUI\n            \n                //let setCurrentDoc docF li = { li with AF.getDoc = docF Util.unselectorV ignore }\n                let addElements (li:AF.ListModelData<_,_>) elems = li.elemsW |> View.Get (fun elements -> elements.AppendMany elems)\n            \n            //module LMX =\n            //    module AF = AppFramework\n            //    open System\n            //\n            //    let addNewO newF firstKey nextKey=\n            //        let mutable k = firstKey\n            //        fun () ->\n            //            let e = k, newF()\n            //            k <- nextKey k\n            //            e\n            //\n            //    let elemUI2 elemUI a b (v:Var<_>) = elemUI a b (v.Lens snd (fun (i, _) nv -> i, nv ) )\n            //\n            //    let getDocInt    def newElem elemUI = addNewO newElem 0                          ((+) 1)                             |> LM.getDoc fst (-1               , def) <| None <| elemUI2 elemUI\n            //    let getDocGuid   def newElem elemUI = addNewO newElem (Guid.NewGuid())           (fun _ -> Guid.NewGuid())           |> LM.getDoc fst (       Guid.Empty, def) <| None <| elemUI2 elemUI\n            //    let getDocGuidId def newElem elemUI = addNewO newElem (Guid.NewGuid() |> GuidId) (fun _ -> Guid.NewGuid() |> GuidId) |> LM.getDoc fst (GuidId Guid.Empty, def) <| None <| elemUI2 elemUI\n            //                                            : AF.ListModelData<GuidId<'C>, GuidId<'C> * 'C>\n            //\n            //    //let setCurrentDoc docF = elemUI2 docF |> LM.setCurrentDoc\n            //\n            //    let addElements (li:AF.ListModelData<_,_>) elems = elems |> Seq.iter (fun v -> (li.add() |> fst, v) |> li.elems.Add )\n            \n            [< JavaScript ; JavaScriptExport (typeof<WebComponent.WcSplitter.WcSplitterT>) >]\n            module StartAppFramework =\n                //open FsRoot\n                open WebSharper.JavaScript\n            \n                let htmlD = Depend.dependByName \"AppFrameworkTemplate.html\" AppFrameworkTemplate.html box\n            \n                let startWithHtmlD = Depend.depend {\n                    let! html = htmlD\n                    return fun () ->\n                        let d = JS.Window.Document.CreateElement \"div\"\n                        let _ = JS.Window.Document.Body.AppendChild d\n                        d?outerHTML <- html\n                        AppFramework.getMainDoc.Value \n                        |> Doc.RunAppend JS.Window.Document.Body \n                }\n            \n                let startWith html =\n                    (startWithHtmlD \n                    |> Depend.resolver [\n                        \"AppFrameworkTemplate.html\", AppFrameworkTemplate.html + html\n                    ]) ()\n            \n            \n            module AppFrameworkUI =\n            \n                module AF = AppFramework\n            \n                let showPlugIn (lmd:AF.ListModelData<_,AF.PlugIn    >) (k:View<_ option>) (plgV:Var<AF.PlugIn>) =\n                    AF.AppFwkTemplate.Tile()\n                        .Name(     plgV.V.plgName.Id                            )\n                        .Select(   fun _ -> View.Get lmd.selV.Set k             )\n                        .Selected( if lmd.selV.V = k.V then \"selected\" else \"\"  )\n                        .Doc() \n            \n                let showVar  (lmd:AF.ListModelData<_,AF.PlugInVar   >) (k:View<_ option>) (varV:Var<AF.PlugInVar>) =\n                    let nameW = View.Do {\n                        let! var = varV.View\n                        let! v   = var.varVar.View\n                        return var.varName.Id + \" = \" + v\n                    }\n                    AF.AppFwkTemplate.Tile()\n                        .Name(     nameW                                        )\n                        .Select(   fun _ -> View.Get lmd.selV.Set k             )\n                        .Selected( if lmd.selV.V = k.V then \"selected\" else \"\"  )\n                        .Doc() \n            \n                let showView (lmd:AF.ListModelData<_,AF.PlugInView  >) (k:View<_ option>) (viwV:Var<AF.PlugInView>) =\n                    let nameW = View.Do {\n                        let! viw = viwV  .View\n                        let! v   = viw.viwView\n                        return viw.viwName.Id + \" = \" + v\n                    }\n                    AF.AppFwkTemplate.Tile()\n                        .Name(     nameW                                        )\n                        .Select(   fun _ -> View.Get lmd.selV.Set k             )\n                        .Selected( if lmd.selV.V = k.V then \"selected\" else \"\"  )\n                        .Doc() \n            \n                let showAct  (lmd:AF.ListModelData<_,AF.PlugInAction>) (k:View<_ option>) (actV:Var<AF.PlugInAction>) =\n                    let parms (act:AF.PlugInAction) = \n                        match act.actFunction with\n                        | AF.FunAct0(_        ) -> \"\"\n                        | AF.FunAct1(_, p1    ) -> [ p1      ] |> String.concat \", \" |> sprintf \"(%s)\"\n                        | AF.FunAct2(_, p1, p2) -> [ p1 ; p2 ] |> String.concat \", \" |> sprintf \"(%s)\"\n                    AF.AppFwkTemplate.Tile()\n                        .Name(     actV.V.actName.Id + parms actV.V             )\n                        .Select(   fun _ -> View.Get lmd.selV.Set k             )\n                        .Selected( if lmd.selV.V = k.V then \"selected\" else \"\"  )\n                        .Doc() \n            \n                let showDoc  (lmd:AF.ListModelData<_,AF.PlugInDoc   >) (k:View<_ option>) (docV:Var<AF.PlugInDoc>) =\n                    AF.AppFwkTemplate.Tile()\n                        .Name(     docV.V.docName.Id + AF.docParms docV.V )\n                        .Select(   fun _ -> View.Get lmd.selV.Set k )\n                        .Selected( if lmd.selV.V = k.V then \"selected\" else \"\"  )\n                        .Doc() \n            \n                let defPlg = AF.defaultPlugIn()\n                let defDoc = AF.newDoc (AF.PlgElemName \"_\") (lazy Doc.Empty)\n                let defVar = AF.newVar (AF.PlgElemName \"_\") (Var.Create \"\" )\n                let defViw = AF.newViw (AF.PlgElemName \"_\") (View.Const \"\" )\n                let defAct = AF.newAct (AF.PlgElemName \"_\") (fun () -> ()  )\n            \n                let failCreate s = fun () -> failwithf \"Create %s not implemented\" s\n            \n                if IsClient then\n                    let pluginsList  = LM.getDocFor   AF.plugIns                                                          defPlg (failCreate \"plugin\" ) None showPlugIn\n                    let plgVarsList  = LM.getDocForW (V pluginsList.CurrentW.V.plgVars   ) (fun plgVar -> plgVar.varName) defVar (failCreate \"Var\"    ) None showVar\n                    let plgViewsList = LM.getDocForW (V pluginsList.CurrentW.V.plgViews  ) (fun plgViw -> plgViw.viwName) defViw (failCreate \"View\"   ) None showView\n                    let plgActsList  = LM.getDocForW (V pluginsList.CurrentW.V.plgActions) (fun plgAct -> plgAct.actName) defAct (failCreate \"Action\" ) None showAct\n                    let plgDocsList  = LM.getDocForW (V pluginsList.CurrentW.V.plgDocs   ) (fun plgDoc -> plgDoc.docName) defDoc (failCreate \"Doc\"    ) None showDoc\n            \n                    let plugInAdded =\n                        AF.plugin {\n                            plgName   \"AppFrmkUI\"\n                            plgMerge  \"plugIns_\"     (pluginsList .PlugIn (AF.PlugInName  >> Some) (fun n -> n.Id) )\n                            plgMerge  \"plgVars_\"     (plgVarsList .PlugIn (AF.PlgElemName >> Some) (fun n -> n.Id) )\n                            plgMerge  \"plgViews_\"    (plgViewsList.PlugIn (AF.PlgElemName >> Some) (fun n -> n.Id) )\n                            plgMerge  \"plgActs_\"     (plgActsList .PlugIn (AF.PlgElemName >> Some) (fun n -> n.Id) )\n                            plgMerge  \"plgDocs_\"     (plgDocsList .PlugIn (AF.PlgElemName >> Some) (fun n -> n.Id) )\n                        }\n                        |> AF.addPlugIn\n                    ()\n            \n            //#define DLL\n            \n            [< JavaScriptExport >]\n            type LayoutEngine = {\n                lytName       : AppFramework.PlugInName \n                lytDefinition : Var<string>\n            }\n            \n            [< JavaScriptExport >]\n            module LayoutEngine =\n                open WebSharper.UI\n                open WebSharper.JavaScript\n                module AF = AppFramework\n            \n                open WebSharper.UI.Client\n            \n                type LayoutEntry =\n                    | EntryVar    of AF.PlugInVar   \n                    | EntryView   of AF.PlugInView  \n                    | EntryDoc    of AF.PlugInDoc\n                    | EntryAction of AF.PlugInAction\n                    | EntryQuery  of AF.PlugInQuery\n            \n                type Token = Quoted of string | UnQuoted of string\n            \n                let (|S|) = function Quoted s | UnQuoted s -> s\n            \n                let (|Identifier|_|) =\n                    function\n                    | UnQuoted(REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] ) -> Some id\n                    | _                                                             -> None\n            \n                let (|I|_|) = function Identifier i -> Some i | _ -> None\n            \n                let (|Vertical|Horizontal|Layout|Grid|Template|Elem|Nothing|) =\n                    function\n                    | UnQuoted s when s = \"vertical\"   -> Vertical\n                    | UnQuoted s when s = \"horizontal\" -> Horizontal\n                    | UnQuoted s when s = \"layout\"     -> Layout\n                    | UnQuoted s when s = \"grid\"       -> Grid\n                    | UnQuoted s when s = \"template\"   -> Template\n                    | Identifier id                    -> Elem id\n                    |                                _ -> Nothing\n            \n                let (|PlugIn|Button|Input|TextArea|Select|Actions|Nothing|) =\n                    function\n                    | UnQuoted s when s = \"PlugIn\"     -> PlugIn\n                    | UnQuoted s when s = \"Button\"     -> Button\n                    | UnQuoted s when s = \"input\"      -> Input\n                    | UnQuoted s when s = \"textarea\"   -> TextArea\n                    | UnQuoted s when s = \"select\"     -> Select\n                    | UnQuoted s when s = \"Actions\"    -> Actions\n                    |                                _ -> Nothing\n            \n                let (|Var|Doc|View|ViewJS|Docs|Action|Nothing|) =\n                    function\n                    | UnQuoted s when s = \"Var\"        -> Var\n                    | UnQuoted s when s = \"Doc\"        -> Doc\n                    | UnQuoted s when s = \"View\"       -> View\n                    | UnQuoted s when s = \"ViewJS\"     -> ViewJS\n                    | UnQuoted s when s = \"Docs\"       -> Docs\n                    | UnQuoted s when s = \"Action\"     -> Action\n                    |                                _ -> Nothing\n            \n                type Measures = \n                | Fixed    of pixel: float * first: bool\n                | Variable of min:   float * value: float * max: float\n                    with override this.ToString() = \n                            match this with\n                            | Fixed(        v, f  ) -> string (int (if f then v else -v) )\n                            | Variable(min, v, max) -> sprintf \"%d-%d-%d\" (int min) (int v) (int max)\n            \n                let splitChar   ch = String.splitByChar ch >> Seq.map    String.trim\n                let splitSemiColon = splitChar         ';' >> Seq.filter ((<>) \"\")\n                let splitInTwo  ch = splitChar          ch >> Seq.toArray\n            \n                let (|Measures|_|) =\n                    function \n                    | Quoted _     -> None \n                    | UnQuoted txt ->\n                    String.splitByChar '-' txt\n                    |> function\n                       | [|                     ParseO.Double v                     |] -> Some <| Fixed    (     v, true )\n                       | [| \"\";                 ParseO.Double v                     |] -> Some <| Fixed    (     v, false)\n                       | [| ParseO.Double min ; ParseO.Double v ; ParseO.Double max |] -> Some <| Variable (min, v, max  )\n                       | _                                                             -> None\n            \n                let fixedSplitter vertical pixel first (doc1:Doc) (doc2:Doc) =\n                    let sizes = sprintf (if first then \"%fpx calc(100%% - %fpx)\" else \"calc(100%% - %fpx) %fpx\") pixel pixel\n                    if vertical then \n                        AF.AppFwkTemplate.FixedSplitterVer()\n                            .PartSizes( sizes)\n                            .First(     doc1 )\n                            .Second(    doc2 )\n                            .Doc()\n                    else \n                        AF.AppFwkTemplate.FixedSplitterHor()\n                            .PartSizes( sizes)\n                            .First(     doc1 )\n                            .Second(    doc2 )\n                            .Doc()\n            \n                let variableSplitter vertical min value max doc1 doc2 =\n                    Doc.Element \"wcomp-splitter\" [\n                        if vertical then yield Attr.Create \"vertical\"    \"\"\n                        yield                  Attr.Create \"min\"      <| string min\n                        yield                  Attr.Create \"value\"    <| string value\n                        yield                  Attr.Create \"max\"      <| string max\n                    ] [ doc1 ; doc2 ]\n                    :> Doc\n                    \n                //let getLDoc name =\n                //    splitName name\n                //    ||> AF.tryGetDoc \n                //    |>  Option.map         AF.getLazyDoc\n                //    |>  Option.defaultWith(fun ()  -> sprintf \"missing %s\" name |> AF.errDoc )                            \n            \n                //let xxhookOrText =\n                //    function\n                //    | Identifier id -> hookDoc id\n                //    | txt           -> Doc.TextNode txt\n            \n                //type Token = string * bool\n            \n                let rec doubleQuote = function\n                    | []                                            -> []\n                    | UnQuoted c :: _ when c.StartsWith \"//\"        -> []\n                    | Quoted t1 :: Quoted \"\\\"\" :: Quoted t2 :: rest -> (Quoted(t1 + \"\\\"\" + t2) :: rest) |> doubleQuote\n                    | Quoted t1 :: Quoted \"\\\"\" :: []                -> [Quoted t1 ]\n                    | h::rest                                       -> h :: doubleQuote rest\n            \n                let splitTokens line : Token list = // \"\"\"main h1 \"\" \"Hello World!\"\"\"\" |> printfn \"dd\"\n                    (if Seq.tryHead line = Some '\"' then \" \" + line else line)\n                    |> String.splitByChar '\"'\n                    |> Seq.mapi(fun i s -> \n                        if  i % 2 = 1  then [| Quoted s    |] else\n                        if  s     = \"\" then [| Quoted \"\\\"\" |] else\n                        let t     = s.Trim()\n                        if  t     = \"\" then [|             |] else\n                        t.Split([| ' ' |], System.StringSplitOptions.RemoveEmptyEntries)\n                        |> Array.map         UnQuoted\n                    )\n                    |> Seq.collect id\n                    |> Seq.toList\n                    |> doubleQuote\n            \n            //    type TextData = \n            //    | TDText  of string\n            //    | TDAct   of AF.PlugInAction\n            //\n            //    let splitName = AF.splitName\n            //\n            //    let rec getOneTextData lytNm name bef aft =\n            //        let plg, n = splitName lytNm name\n            //        AF.tryGetActW plg n\n            //        |> View.Bind(function\n            //        | Some act -> TDAct act |> View.Const\n            //        | None     ->\n            //        AF.tryGetWoWW plg n\n            //        |> View.Bind(function\n            //            | Some txt ->\n            //                getTextData lytNm aft\n            //                |> View.Bind (function\n            //                    | TDText  b    -> View.Const <| (TDText  <|     bef + txt + b                             )\n            //                    | TDAct   act  -> View.Const <| (TDText  <| sprintf \"Unexpected Action @{%s}\" (act.actName.Id) )\n            //                )\n            //            | None                 -> View.Const <| (TDText  <| sprintf \"%s @{Missing %s}%s\" bef name aft     )  \n            //            )\n            //        )\n            //\n            //    and getTextData lytNm (txt:string) =\n            //        txt\n            //        |> String.delimitedO \"@{\" \"}\"\n            //        |> Option.map(fun (bef, name, aft) -> getOneTextData lytNm name bef aft )\n            //        |> Option.defaultWith (fun () -> TDText  txt |> View.Const)\n            //\n            //    let getTextToken lytNm (token: Token) =\n            //        match token with\n            //        | UnQuoted name -> getOneTextData lytNm name \"\" \"\"\n            //        | Quoted   txt  -> getTextData    lytNm txt\n            //\n            //    let getAttrs lytNm (S attrs: Token) = \n            //        [\n            //            yield!  attrs\n            //                    |> String.splitByChar ';'\n            //                    |> Seq.map(String.splitByChar '=')\n            //                    |> Seq.choose(\n            //                        function \n            //                        | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" ->\n            //                                value.Trim() |> getTextData lytNm\n            //                                |> Attr.DynamicCustom (fun el -> function\n            //                                    | TDText  v   -> el.SetAttribute(name.Trim(), v.Trim())\n            //                                    | TDAct   act -> el.AddEventListener(name.Trim(), (fun (ev:Dom.Event) -> act.actFunction |> AF.callFunction el ev), false)\n            //                                )\n            //                                |> Some\n            //                        |_      -> None )\n            //            yield!  attrs\n            //                    |> String.splitByChar ';'\n            //                    |> Seq.map(String.splitByChar ':')\n            //                    |> Seq.choose(\n            //                        function \n            //                        | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" -> \n            //                                value.Trim() |> getTextData lytNm\n            //                                |> View.Map(function\n            //                                    | TDText  v   -> v.Trim()\n            //                                    | TDAct   act -> sprintf \"@{%s}\" (act.actName.Id)\n            //                                )\n            //                                |> Attr.DynamicStyle (name.Trim())\n            //                                |> Some\n            //                        |_      -> None )\n            //        ]\n            //\n            //    let getDocF (parms:Token list) (doc:AF.PlugInDoc) =\n            //        match doc.docDoc, parms with\n            //        | AF.LazyDoc ldoc                  ,                                                   rest -> ldoc.Value       , rest\n            //        | AF.FunDoc0 f0                    ,                                                   rest -> f0()             , rest\n            //        | AF.FunDoc1(f1, _                ), (S p1)                                         :: rest -> f1 p1            , rest\n            //        | AF.FunDoc2(f2, _ , _            ), (S p1) :: (S p2)                               :: rest -> f2 p1 p2         , rest\n            //        | AF.FunDoc3(f3, _ , _ , _        ), (S p1) :: (S p2) :: (S p3)                     :: rest -> f3 p1 p2 p3      , rest          \n            //        | AF.FunDoc4(f4, _ , _ , _ , _    ), (S p1) :: (S p2) :: (S p3) :: (S p4)           :: rest -> f4 p1 p2 p3 p4   , rest     \n            //        | AF.FunDoc5(f5, _ , _ , _ , _ , _), (S p1) :: (S p2) :: (S p3) :: (S p4) :: (S p5) :: rest -> f5 p1 p2 p3 p4 p5, rest\n            //        | _ -> Html.div [] [ Html.text <| sprintf \"Parameters do not coincide with definition %A - %A\" doc parms ], []\n            //\n            //    let getDocFinal parms doc = \n            //        match getDocF parms doc with\n            //        | res, [] -> res\n            //        | _ -> sprintf \"Too many parameters %A %A\" doc parms |> AF.errDoc\n            //\n            //    let mutable currentViewTriggger = AF.mainDocV.View\n            //\n            //    let turnToView f = currentViewTriggger |> View.Map f |> Doc.EmbedView\n            //\n            //    let getADoc lytNm token =\n            //        match token with\n            //        | Identifier di  -> let plg, nm = splitName lytNm di\n            //                            AF.tryGetDocW plg nm\n            //                            |>  Doc.BindView (function \n            //                                | Some pdc -> getDocF [] pdc |> fst\n            //                                | None     ->\n            //                                AF.tryGetWoWW plg nm\n            //                                |> Doc.BindView (function \n            //                                    | Some txt -> Doc.TextNode txt\n            //                                    | None     -> sprintf \"Missing doc: %s\" di |>! print |> AF.errDoc )\n            //                            )\n            //        | (S txt)        -> txt\n            //                            |> getTextData lytNm\n            //                            |> View.Map(function\n            //                                | TDText  v   ->  v \n            //                                | TDAct   act -> sprintf \"Unexpected action: %s\" (act.actName.Id)\n            //                            )\n            //                            |> Doc.TextView\n            //\n            //    let rec getAllDocs lytNm tokens =\n            //        match tokens with\n            //        | []            -> []\n            //        | token :: rest -> getADoc lytNm token :: getAllDocs lytNm rest\n            //\n            //    let getOneDoc lytNm docs =\n            //        match docs with\n            //        | Identifier id :: parms -> let plg, nm = splitName lytNm id\n            //                                    AF.tryGetDoc plg nm\n            //                                    |>  Option.map (getDocF parms)\n            //                                    |>  Option.defaultWith  (fun ()  ->\n            //                                        AF.tryGetWoW plg nm\n            //                                        |>  Option.map (fun txtW -> Doc.TextView txtW, parms)\n            //                                        |> fun vv -> vv\n            //                                        |>  Option.defaultWith  (fun () -> sprintf \"Missing doc: %s\" id |>! print |> AF.errDoc, parms) )\n            //        | (S txt)       :: rest  -> txt\n            //                                    |> getTextData lytNm\n            //                                    |> View.Map(function\n            //                                        | TDText  v   ->  v \n            //                                        | TDAct   act -> sprintf \"Unexpected action: %s\" (act.actName.Id)\n            //                                    )\n            //                                    |> Doc.TextView, rest\n            //        | []                     -> Doc.Empty, []\n            //\n            //    let rec getDocs_ lytNm docs =\n            //        match docs with\n            //        | [] -> []\n            //        | _  -> \n            //        match getOneDoc lytNm docs with\n            //        | res, rest -> res :: getDocs_ lytNm rest\n            //\n            //    let pairOfDocs lytNm docs =\n            //        currentViewTriggger \n            //        |> View.Map (fun _ -> getAllDocs lytNm docs )\n            //        |> View.Map (\n            //            function \n            //            | [ doc1 ; doc2 ] -> doc1, doc2\n            //            | _               -> sprintf \"splitter expects exactly 2 elements %A\" docs |> AF.errDoc, \"part 2\" |> AF.errDoc\n            //        ) |> (fun dsW -> View.Map fst dsW |> Doc.EmbedView, View.Map snd dsW |> Doc.EmbedView )\n            //\n            //    let singleDoc lytNm docs =\n            //        currentViewTriggger\n            //        |> View.Map (fun _ -> getAllDocs lytNm docs )\n            //        |> View.Map (\n            //            function \n            //            | [ doc1 ] -> doc1\n            //            | _        -> sprintf \"expected exactly 1 element %A\" docs |> AF.errDoc\n            //        ) |> Doc.EmbedView\n            //\n            //    let createSplitter(lytNm, name, vertical, measures, docs) =\n            //        let doc1, doc2 = pairOfDocs lytNm docs\n            //        match measures with\n            //        | Fixed    (pixel,    first) ->    fixedSplitter vertical pixel first   doc1 doc2\n            //        | Variable (min, value, max) -> variableSplitter vertical min value max doc1 doc2\n            //\n            //    let createElement(lytNm, name, element, attrs, docs) =\n            //        turnToView <| fun _ ->\n            //            getAllDocs lytNm docs \n            //            |> Doc.Concat\n            //            |> Seq.singleton\n            //            |> Doc.Element element (getAttrs lytNm attrs)\n            //\n            //    let createButton( lytNm, name, actName, attrs, S text) = \n            //        turnToView <| fun _ ->\n            //            splitName lytNm actName\n            //            ||> AF.tryGetAct\n            //            |>  Option.map          (fun act -> fun () -> act.actFunction |> AF.callFunction () ()  )\n            //            |>  Option.defaultValue ignore\n            //            |> Doc.Button text (getAttrs lytNm attrs)\n            //\n            //    let createInput( lytNm, name, varName, attrs ) = \n            //        turnToView <| fun _ ->\n            //            splitName lytNm varName\n            //            ||> AF.tryGetVoVW\n            //            |> Doc.BindView(function\n            //                | Some var -> Doc.Input     (getAttrs lytNm attrs) var\n            //                | None  -> sprintf \"Missing var: %s\" varName |> AF.errDoc )\n            //\n            //    let createTextArea( lytNm, name, varName, attrs ) = \n            //        turnToView <| fun _ ->\n            //                splitName lytNm varName\n            //                ||> AF.tryGetVoVW\n            //                |> Doc.BindView(function\n            //                    | Some var -> Doc.InputArea (getAttrs lytNm attrs) var\n            //                    | None  -> sprintf \"Missing var: %s\" varName |> AF.errDoc )\n            //\n            //    let createDoc( lytNm, name, docName, parms) =\n            //        turnToView <| fun _ ->\n            //            splitName lytNm docName\n            //            ||> AF.tryGetDoc\n            //            |>  Option.map (getDocFinal parms)\n            //            |>  Option.defaultWith  (fun ()  -> sprintf \"Missing doc: %s\" docName |> AF.errDoc )\n            //\n            //    let createTemplate( lytNm, name, tempName:string, attrs:Token, holes) =\n            //        turnToView <| fun _ ->\n            //            let attrs = getAttrs lytNm attrs\n            //            Client.Doc.LoadLocalTemplates \"local\"\n            //            try\n            //                holes \n            //                |> Seq.pairwise\n            //                |> Seq.indexed\n            //                |> Seq.filter(fun (i, _) -> i % 2 = 0)\n            //                |> Seq.map  snd\n            //                |> Seq.map( function\n            //                    | (S nm ), Identifier id -> splitName     lytNm id ||> AF.tryGetDoc |> Option.map (fun doc -> TemplateHole.Elt(   nm.ToLower(), getDocF [] doc |> fst) )\n            //                                                |> Option.orElseWith (fun () ->\n            //                                                    splitName lytNm id ||> AF.tryGetVar |> Option.map (fun var -> TemplateHole.VarStr(nm.ToLower(), var.varVar) )\n            //                                                )\n            //                                                |> Option.defaultWith(fun () -> TemplateHole.Elt(nm.ToLower(), sprintf \"Missing element: %s\" id |> AF.errDoc) )\n            //                    | (S nm ), (S txt )      -> //getTextData lytNm txt\n            //                                                //|> View.Map (function\n            //                                                //    | TDText  v   -> TemplateHole.Text(    nm.ToLower(), v )\n            //                                                //    | TDView  vw  -> TemplateHole.TextView(nm.ToLower(), vw)\n            //                                                //    | TDAct   act -> TemplateHole.Event(   nm.ToLower(), (fun el ev -> act.actFunction |> AF.callFunction el ev ))\n            //                                                //)\n            //                                                TemplateHole.Elt(nm.ToLower(), sprintf \"Not implemented: %s\" txt |> AF.errDoc) \n            //                )\n            //                |> (if Seq.isEmpty attrs then id else TemplateHole.Attribute(\"attrs\", Attr.Concat attrs) |> Seq.singleton |> Seq.append)\n            //                |> Client.Doc.NamedTemplate \"local\" (tempName.ToLower() |> Some)\n            //                |> Some\n            //            with _ -> None\n            //            |>  Option.defaultWith  (fun ()  -> sprintf \"Missing template: %s\" tempName |> AF.errDoc )\n            //\n            //    let getParamText lytNm token f = \n            //        getTextToken lytNm token\n            //        |> View.Get(function\n            //            | TDText  txt -> f (box txt)\n            //            | TDAct   act -> f (box act)\n            //        )\n            //\n            //    let createAction( lytNm, name, actName, (parms : Token list) ) = \n            //        splitName lytNm actName\n            //        ||> AF.tryGetAct\n            //        |>  Option.map          (fun act -> \n            //            if parms = [] then act.actFunction else\n            //            match act.actFunction, parms with\n            //            | AF.FunAct1(f,_    ), [ t1     ] -> AF.FunAct0( fun () -> getParamText lytNm t1                                   f              )\n            //            | AF.FunAct2(f,_, _ ), [ t1; t2 ] -> AF.FunAct0( fun () -> getParamText lytNm t1 (fun p1 -> getParamText lytNm t2 (f p1   ) )     )\n            //            | AF.FunAct2(f,_, n2), [ t1     ] -> AF.FunAct1((fun p2 -> getParamText lytNm t1 (fun p1 ->                        f p1 p2) ) , n2)\n            //            | _ -> AF.FunAct0 (fun () -> printfn \"Parameters do not coincide for Action %s %A %A\" actName parms act )\n            //        )\n            //        |>  Option.defaultWith  (fun ()  -> AF.FunAct0 (fun () -> printfn \"Action Not Found %s\" actName) )\n            //\n            //    let createConcat(lytNm, name, docs) =\n            //        turnToView (fun _ -> getAllDocs lytNm docs |> Doc.Concat)\n            //\n            //    let createVar( lytNm, varName, v           ) = Var.Create v\n            //    let findJSEntry fname =\n            //        fname \n            //        |> String.splitByChar '.'\n            //        |> Seq.fold(fun oO nm ->\n            //            oO |> Option.bind(fun o -> if (isUndefined o?(nm)) then None else Some o?(nm) ) \n            //            ) (Some (JS.Inline(\"window\") :> obj) )\n            //\n            //    let createView(lytNm, viwName, parms) = \n            //        currentViewTriggger |> View.Bind (fun _ ->\n            //            try\n            //                parms\n            //                |> View.traverseSeq (getTextToken lytNm)\n            //                |> View.Map (\n            //                    Seq.map \n            //                        (function\n            //                        | TDText  txt -> txt\n            //                        | TDAct   act -> sprintf \"%A\" act) \n            //                    >> Seq.toArray\n            //                )\n            //                |> View.Map (fun ar ->\n            //                    try match ar with\n            //                        | [|   |] -> \"No JS function specified\"\n            //                        | [| _ |] ->  JS.Eval ar.[0]                                              |> string\n            //                        | _       -> (JS.Eval ar.[0] |> unbox<FuncWithArgs<_,obj>>).Call ar.[1..] |> string\n            //                    with e -> e.Message\n            //                )\n            //            with e -> e.Message |> View.Const\n            //        )\n            //\n            //    let createSplitterM = Memoize.memoize createSplitter\n            //    let createButtonM   = Memoize.memoize createButton\n            //    let createInputM    = Memoize.memoize createInput\n            //    let createTextAreaM = Memoize.memoize createTextArea\n            //    let createElementM  = Memoize.memoize createElement\n            //    let createDocM      = Memoize.memoize createDoc\n            //    let createTemplateM = Memoize.memoize createTemplate\n            //    let createConcatM   = Memoize.memoize createConcat\n            //    let createVarM      = Memoize.memoize createVar\n            //    let createViewM     = Memoize.memoize createView\n            //    let createActionM   = Memoize.memoize createAction\n            //\n            //    let entryDoc  n doc = AF.newDoc  n (lazy doc    ) |> EntryDoc    |> Some\n            //    let entryVar  n v   = AF.newVar  n  v             |> EntryVar    |> Some\n            //    let entryView n w   = AF.newViw  n  w             |> EntryView   |> Some\n            //    let entryAct  n a   = AF.newActF n  a             |> EntryAction |> Some\n            //\n            //    let createEntryO lytNm (line:string) =\n            //        try\n            //            match splitTokens line with\n            //            |   Identifier name :: Vertical   :: Measures measures          :: docs    -> entryDoc  <| AF.PlgElemName name <| createSplitterM(lytNm, name, true , measures, docs ) \n            //            |   Identifier name :: Horizontal :: Measures measures          :: docs    -> entryDoc  <| AF.PlgElemName name <| createSplitterM(lytNm, name, false, measures, docs ) \n            //            | [ Identifier name ;  Button     ;  Identifier act    ;  attrs ;  text  ] -> entryDoc  <| AF.PlgElemName name <| createButtonM  (lytNm, name, act  , attrs   , text ) \n            //            | [ Identifier name ;  Input      ;  Identifier var    ;  attrs          ] -> entryDoc  <| AF.PlgElemName name <| createInputM   (lytNm, name, var  , attrs          ) \n            //            | [ Identifier name ;  TextArea   ;  Identifier var    ;  attrs          ] -> entryDoc  <| AF.PlgElemName name <| createTextAreaM(lytNm, name, var  , attrs          ) \n            //            | [ Identifier name ;  Var        ;                       (S v)          ] -> entryVar  <| AF.PlgElemName name <| createVarM     (lytNm, name, v                     ) \n            //            |   Identifier name :: Doc        :: (S doc  )                  :: parms   -> entryDoc  <| AF.PlgElemName name <| createDocM     (lytNm, name, doc  , parms          ) \n            //            |   Identifier name :: View       ::                               parms   -> entryView <| AF.PlgElemName name <| createViewM    (lytNm, name,        parms          )\n            //            |   Identifier name :: Template   :: (S temp )         :: attrs :: holes   -> entryDoc  <| AF.PlgElemName name <| createTemplateM(lytNm, name, temp , attrs   , holes)\n            //            |   Identifier name :: Docs                                     :: docs    -> entryDoc  <| AF.PlgElemName name <| createConcatM  (lytNm, name,                  docs )\n            //            |   Identifier name :: Action     :: Identifier act             :: parms   -> entryAct  <| AF.PlgElemName name <| createActionM  (lytNm, name, act  , parms          )\n            //            |   Identifier name :: Elem elem                       :: attrs :: docs    -> entryDoc  <| AF.PlgElemName name <| createElementM (lytNm, name, elem , attrs   , docs ) \n            //            | _                                                                        -> None\n            //        with e -> \n            //            None\n            \n                module Syntax =\n            \n                    type ItemRef =\n                    | LocalRef of string\n                    | FullRef  of string * string\n            \n                    type DocRef = DocRef of ItemRef\n                    type ActRef = ActRef of ItemRef\n                    type VarRef = VarRef of ItemRef\n                    type ViwRef = ViwRef of ItemRef\n            \n                    //let pairOfDocs lytNm docs =\n                    //    currentViewTriggger \n                    //    |> View.Map (fun _ -> getAllDocs lytNm docs )\n                    //    |> View.Map (\n                    //        function \n                    //        | [ doc1 ; doc2 ] -> doc1, doc2\n                    //        | _               -> sprintf \"splitter expects exactly 2 elements %A\" docs |> AF.errDoc, \"part 2\" |> AF.errDoc\n                    //    ) |> (fun dsW -> View.Map fst dsW |> Doc.EmbedView, View.Map snd dsW |> Doc.EmbedView )\n            \n                    type TextVal =\n                    | TvConst  of string\n                    | TvVarRef of VarRef\n                    | TvViwRef of ViwRef\n                    | TvActRef of ActRef\n                    | TvDocRef of DocRef\n            \n                    type TextValL = TextVal list\n            \n                    type AttrVal =\n                    | AtStyle of string * TextValL\n                    | AtAttr  of string * TextValL\n                    | AtAct   of string * ActRef\n            \n                    type NodeRef =\n                    | NdTextValL of TextValL\n                    | NdDocRef   of DocRef\n                    | NdVarRef   of VarRef\n                    | NdViwRef   of ViwRef\n            \n                    type ParmRef =\n                    | PrTextValL of TextValL\n                    | PrDocRef   of DocRef\n                    | PrVarRef   of VarRef\n                    | PrViwRef   of ViwRef\n                    | PrActRef   of ActRef\n            \n                    type RefType =\n                    | RDoc\n                    | RVar\n                    | RViw\n                    | RAct\n                    | RPlg\n            \n                    type ElemNames = Map<string, RefType>\n                    type ElemName  = string * RefType\n            \n                    type SplitterDef = SplitterDef of vertical:bool * Measures * DocRef * DocRef\n                    type ButtonDef   = ButtonDef   of ActRef * AttrVal[] * TextValL\n                    type InputDef    = InputDef    of VarRef * AttrVal[]\n                    type TextAreaDef = TextAreaDef of VarRef * AttrVal[]\n                    type DocFDef     = DocFDef     of DocRef * ParmRef list\n                    type ConcatDef   = ConcatDef   of NodeRef list\n                    type ElementDef  = ElementDef  of string * ParmRef * NodeRef list\n                    type TemplateDef = { \n                        tmpName : string \n                        vars    : (string * VarRef )[]\n                        views   : (string * ParmRef)[]\n                        docs    : (string * DocRef )[] \n                        actions : (string * ActRef )[]\n                        attrs   : ParmRef\n                    }\n            \n                    let templateDef nm ats vs ws ds acs = { \n                        tmpName = nm\n                        attrs   = ats\n                        vars    = vs\n                        views   = ws\n                        docs    = ds\n                        actions = acs\n                    }\n            \n                    type ActDef      = ActDef      of ActRef * ParmRef list\n                    type ActDefs     = ActDefs     of ActRef  list\n                    type VarDef      = VarDef      of string\n                    type ViwDef      = ViwDef      of ParmRef list\n                    type VJSDef      = VJSDef      of ParmRef list\n                    type PlgDef      = PlgDef      of ElemNames\n                    type DocDef      = \n                    | DcSplitter of SplitterDef\n                    | DcButton   of ButtonDef\n                    | DcInput    of InputDef\n                    | DcTextArea of TextAreaDef\n                    | DcDocF     of DocFDef\n                    | DcConcat   of ConcatDef\n                    | DcElement  of ElementDef\n                    | DcTemplate of TemplateDef\n            \n                    type Entry =\n                    | EnDocDef  of DocDef\n                    | EnActDef  of ActDef\n                    | EnActDefs of ActDefs\n                    | EnVarDef  of VarDef\n                    | EnViwDef  of ViwDef\n                    | EnVJSDef  of VJSDef\n                    | EnPlgDef  of PlgDef\n                    | EnPlgRef  of ElemName\n            \n                    type EntryDef = EntryDef of string * Entry\n            \n                    let entryDef  n e = EntryDef(n, e)\n                    let entryDoc  n d = EnDocDef  d |> entryDef n |> Some\n                    let entryAct  n a = EnActDef  a |> entryDef n |> Some\n                    let entryActs n a = EnActDefs a |> entryDef n |> Some\n                    let entryView n w = EnViwDef  w |> entryDef n |> Some\n                    let entryVJS  n w = EnVJSDef  w |> entryDef n |> Some\n                    let entryVar  n v = EnVarDef  v |> entryDef n |> Some\n                    let entryPlg  n p = EnPlgDef  p |> entryDef n |> Some\n                    let entryRef  n e = EnPlgRef  e |> entryDef n |> Some\n            \n                    let (|R|_|) = function\n                    | Identifier n ->\n                        match n.Split '.' with\n                        | [|     n |] -> LocalRef n    |> Some\n                        | [| l ; n |] -> FullRef(l, n) |> Some\n                        | _ -> None\n                    | _ -> None\n            \n                    let createEntryO (getType:ItemRef -> RefType * Entry option) lytNm (line:string) =\n                        let (|Rt|_|) = function\n                        | R itr -> Some (getType itr, itr)\n                        |_      -> None\n            \n                        let (|DocRf|_|) = function\n                        | Rt((RDoc, _), itr) -> Some(DocRef itr)\n                        |_-> None\n                        let (|VarRf|_|) = function\n                        | Rt((RVar, _), itr) -> Some(VarRef itr)\n                        |_-> None\n                        let (|ViwRf|_|) = function\n                        | Rt((RViw, _), itr) -> Some(ViwRef itr)\n                        |_-> None\n                        let (|ActRf|_|) = function\n                        | Rt((RAct, _), itr) -> Some(ActRef itr)\n                        |_-> None\n                        let (|PlgRf|_|) = function\n                        | Rt((RPlg, Some(EnPlgRef el)), itr) -> Some(el) \n                        |_-> None\n            \n                        let (|Name|_|) = function\n                        | R(LocalRef nm) -> Some nm\n                        |_               -> None\n            \n                        let (|NamU|_|) = function\n                        | Name nm when nm.StartsWith \"_\" -> Some nm\n                        |_                               -> None\n            \n                        let (|Tr|_|) = function\n                        | VarRf vr -> TvVarRef vr |> Some\n                        | ViwRf wr -> TvViwRef wr |> Some\n                        | ActRf wr -> TvActRef wr |> Some\n                        |_-> None\n            \n                        let (|Indi|_|) txt =\n                            match txt |> String.delimitedO \"@{\" \"}\" with\n                            | Some(bef, nm, aft) -> Some(bef, UnQuoted nm, aft)\n                            |_                   -> None\n            \n                        let rec (|Tx|_|) txt =\n                            match txt with\n                            | Indi(bef, Tr tv, aft) ->\n                                    let tl = if bef = \"\" then [ tv ] else [ TvConst bef ; tv ]\n                                    match aft with\n                                    | \"\"    -> Some tl\n                                    | Tx ta -> Some(tl @ ta)\n                                    |_      -> None\n                            | Indi(_, _, _) -> None\n                            |_              -> Some [ TvConst txt ]\n            \n                        let (|ActI|_|) txt =\n                            match txt with\n                            | Indi(bef, ActRf ar, aft) when bef.Trim() = \"\" && aft.Trim() = \"\" -> Some ar\n                            |_                                                                 -> None\n            \n                        let (|QTx|_|) = function\n                        | Quoted (Tx tv) -> tv |> Some\n                        |_-> None\n            \n                        let (|STx|_|) = function\n                        | QTx [TvConst v] -> v |> Some\n                        |_-> None\n            \n                        let (|At|_|) = function \n                        | Quoted s ->\n                            splitSemiColon s\n                            |> Seq.choose(fun a ->\n                                match splitInTwo '=' a with\n                                | [| nm ; ActI  ar |] -> AtAct  (nm.Trim(), ar)  |> Some\n                                | [| nm ; Tx    vl |] -> AtAttr (nm.Trim(), vl)  |> Some\n                                |_->\n                                match splitInTwo ':' a with\n                                | [| nm ; Tx vl |] -> AtStyle(nm.Trim(), vl) |> Some\n                                |_->    failwithf \"Attributes should be like: \\\"name=val\\\" or \\\"name:val\\\" and separated by ';' : %s\" a\n                            )\n                            |> Seq.toArray\n                            |> Some\n                        |_-> None\n            \n                        let (|Pr|_|) = function \n                        | QTx   v -> Some (PrTextValL v)\n                        | DocRf v -> Some (PrDocRef   v)\n                        | VarRf v -> Some (PrVarRef   v)\n                        | ViwRf v -> Some (PrViwRef   v)\n                        | ActRf v -> Some (PrActRef   v)\n                        |_        -> None\n            \n                        let (|Vs|_|) = function \n                        | Quoted s ->\n                            splitSemiColon s\n                            |> Seq.choose(fun a ->\n                                match splitInTwo ':' a |> Array.map UnQuoted with\n                                | [| Name nm ; VarRf v |] -> (nm, v) |> Some\n                                |_->    failwithf \"Expecting Vars \\\"name:var\\\" separated by ';' : %s\" a\n                            )\n                            |> Seq.toArray\n                            |> Some\n                        |_-> None\n            \n                        let (|Ws|_|) = function \n                        | Quoted s ->\n                            splitSemiColon s\n                            |> Seq.choose(fun a ->\n                                match splitInTwo ':' a |> Array.map splitTokens with\n                                | [| [ Name nm ] ; [ Pr v ] |] -> (nm, v) |> Some\n                                |_->    failwithf \"Expecting Views \\\"name:view\\\" separated by ';' : %s\" a\n                            )\n                            |> Seq.toArray\n                            |> Some\n                        |_-> None\n            \n                        let (|Ds|_|) = function \n                        | Quoted s ->\n                            splitSemiColon s\n                            |> Seq.choose(fun a ->\n                                match splitInTwo ':' a |> Array.map UnQuoted with\n                                | [| Name nm ; DocRf v |] -> (nm, v) |> Some\n                                |_->    failwithf \"Expecting Docs \\\"name:doc\\\" separated by ';' : %s\" a\n                            )\n                            |> Seq.toArray\n                            |> Some\n                        |_-> None\n            \n                        let rec (|Prs|_|) = function\n                        | []                -> Some []\n                        | Pr pr :: Prs rest -> Some( pr :: rest)\n                        |_                  -> None\n            \n                        let rec (|ActRfs|_|)       = function\n                        | []                      -> Some []\n                        | ActRf ar :: ActRfs rest -> Some( ar :: rest)\n                        |_                        -> None\n            \n                        let (|Acs|_|) = function \n                        | Quoted s ->\n                            splitSemiColon s\n                            |> Seq.choose(fun a ->\n                                match splitInTwo ':' a |> Array.map splitTokens with\n                                | [| [ Name nm ] ; [ ActRf v ] |] -> (nm, v) |> Some\n                                |_->    failwithf \"Expecting Actions \\\"name:action\\\" separated by ';' : %s\" a\n                            )\n                            |> Seq.toArray\n                            |> Some\n                        |_-> None\n            \n                        let (|Nd|_|) = function \n                        | QTx   v -> Some (NdTextValL v)\n                        | DocRf v -> Some (NdDocRef   v)\n                        | VarRf v -> Some (NdVarRef   v)\n                        | ViwRf v -> Some (NdViwRef   v)\n                        |_        -> None\n            \n                        let rec (|Nds|_|) = function\n                        | []                -> Some []\n                        | Nd nd :: Nds rest -> Some( nd :: rest)\n                        |_                  -> None\n            \n                        let rec (|Pgs|_|) = function\n                        | []                -> Some []\n                        | PlgRf el :: Pgs rest -> Some( el :: rest)\n                        |_                  -> None\n            \n                        match splitTokens line with\n                        |   Name name :: PlugIn     :: Pgs els                                   -> entryPlg  name <| PlgDef  (Map els )\n                        | [ NamU name ;  Doc        ;  Name nm                                 ] -> entryRef  name <| ElemName(nm, RDoc)\n                        | [ NamU name ;  Var        ;  Name nm                                 ] -> entryRef  name <| ElemName(nm, RVar)\n                        | [ NamU name ;  View       ;  Name nm                                 ] -> entryRef  name <| ElemName(nm, RViw)\n                        | [ NamU name ;  Action     ;  Name nm                                 ] -> entryRef  name <| ElemName(nm, RAct)\n                    (**)| [ Name name ;  Vertical   ;  Measures measures ;  DocRf l ; DocRf r  ] -> entryDoc  name <| DcSplitter(SplitterDef(true , measures, l, r) )\n                    (**)| [ Name name ;  Horizontal ;  Measures measures ;  DocRf l ; DocRf r  ] -> entryDoc  name <| DcSplitter(SplitterDef(false, measures, l, r) ) \n                    (**)| [ Name name ;  Button     ;  ActRf      act    ;  At att  ; QTx text ] -> entryDoc  name <| DcButton  (ButtonDef  (act  , att     , text) )\n                    (**)| [ Name name ;  Input      ;  VarRf      var    ;  At att             ] -> entryDoc  name <| DcInput   (InputDef   (var  , att           ) )\n                    (**)| [ Name name ;  TextArea   ;  VarRf      var    ;  At att             ] -> entryDoc  name <| DcTextArea(TextAreaDef(var  , att           ) )\n                        | [ Name name ;  Var        ;                       STx v              ] -> entryVar  name <| VarDef    (v.Trim())\n                        |   Name name :: Doc        :: DocRf      dr               :: Prs    ps  -> entryDoc  name <| DcDocF    (DocFDef    ( dr  , ps            ) )\n                        |   Name name :: View       ::                                Prs    ps  -> entryView name <| ViwDef           ps\n                        |   Name name :: ViewJS     ::                                Prs    ps  -> entryVJS  name <| VJSDef           ps\n                        |   Name name :: Docs                                      :: Nds    ns  -> entryDoc  name <| DcConcat  (ConcatDef                  ns      )\n                        |   Name name :: Actions    ::                                ActRfs acs -> entryActs name <| ActDefs  acs\n                        |   Name name :: Action     :: ActRf      act              :: Prs    ps  -> entryAct  name <| ActDef  ( act  , ps          )\n                        | [ Name name ;  Template   ;  Name tn; Pr att; Ws w; Ds d; Vs v; Acs a] -> entryDoc  name <| DcTemplate (templateDef tn att v w d a )\n                        |   Name name :: Elem elem  ::           Pr att            :: Nds    ns  -> entryDoc  name <| DcElement (ElementDef(elem , att   , ns ) )\n                        | _                                                                      -> None\n            \n                    let createEntryO2 (lytNm:AF.PlugInName) (refs:System.Collections.Generic.Dictionary<string, _>) =\n                        let addR nm en = if refs.ContainsKey nm then Result.errorf \"Already exists %s : %A \" nm en else refs.Add(nm, en) ; Ok()\n                        let ok   nm en = addR nm en |> Result.map (fun () -> nm, en)\n                        let ko msg (line:string) =\n                            let nm = line.Split([| ' ' ; '\\t' |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.head\n                            addR nm (ElementDef(\"div\", PrTextValL [], [NdTextValL [ TvConst msg ] ] ) |> DcElement |> EnDocDef )\n                            |> Result.bind (fun () -> Result.Error msg)\n                        let getRef nm =\n                            try refs.[nm]\n                            with e -> failwithf \"Could not find reference to %s\" nm\n                        let getType rf = \n                            match rf with\n                            | LocalRef      nm  -> \n                                let entry = getRef nm\n                                match entry with\n                                | EnDocDef  _ -> RDoc\n                                | EnActDef  _ -> RAct\n                                | EnActDefs _ -> RAct\n                                | EnVarDef  _ -> RVar\n                                | EnViwDef  _ -> RViw\n                                | EnVJSDef  _ -> RViw\n                                | EnPlgRef  _ -> RPlg\n                                | EnPlgDef  _ -> failwithf \"PlugIn should not be referenced by itself: %A\" rf\n                                , Some entry\n                            | FullRef  (ly, nm) ->\n                                try\n                                    getRef ly\n                                    |> function\n                                    | EnPlgDef(PlgDef ps) -> try ps.[nm] with e-> failwithf \"Could not find reference to %s.%s\" ly nm\n                                    | _                   -> failwithf \"PlugIn not registered: %A\" rf\n                                    , None\n                                with e ->\n                                    match AF.tryGetPlugIn (AF.PlugInName ly) with\n                                    | None    -> failwith e.Message\n                                    | Some pg ->\n                                    let nmm = AF.PlgElemName nm\n                                    if   pg.plgDocs   .ContainsKey nmm then RDoc\n                                    elif pg.plgActions.ContainsKey nmm then RAct\n                                    elif pg.plgVars   .ContainsKey nmm then RVar\n                                    elif pg.plgViews  .ContainsKey nmm then RViw\n                                    else failwithf \"Could not find reference to %s.%s\" ly nm\n                                    , None\n                        fun (line:string) ->\n                            try \n                                createEntryO getType lytNm line\n                                |> function\n                                | Some(EntryDef(nm, en)) ->         ok nm en\n                                | None                   -> line |> ko (sprintf \"Line not matched!: %s\" line)\n                            with e                       -> line |> ko e.Message\n                            |> Some\n            \n                module Layout =\n                    open ParseO\n            \n                    type Node = \n                        | Node        of string []\n                        | SubSplitter of Splitter\n            \n                    and Splitter =\n                        Splitter of bool * Measures * Node * Node\n            \n                    let extractMeasuresO (m:string) =\n                        match m.Split([| ' ' |], System.StringSplitOptions.RemoveEmptyEntries) with\n                        | [|           Int v          |] -> Some (Fixed   (           float (abs(v)), v >= 0   ) ) \n                        | [| Int min ; Int v; Int max |] -> Some (Variable(float min, float      v  , float max) )\n                        | _                              -> None\n            \n                    let horizontalSplit (lines:string[]) =\n                        lines\n                        |> Seq.indexed\n                        |> Seq.choose (fun (i, l) ->\n                            match l with\n                            | REGEX \"^ *--+([ ^v0-9]*)-* *$\" \"\" p -> \n                                let ms    = p \n                                            |> Seq.tryItem 1 \n                                            |> Option.bind ((fun s -> s.Replace(\"^\", \"\").Replace(\"v\", \"-\") ) >> extractMeasuresO) \n                                            |> Option.defaultValue (Variable(5., 50., 95.))\n                                Some((i, ms), l.IndexOf '-')\n                            | _ -> None\n                        )\n                        |> Seq.sortBy snd\n                        |> Seq.tryHead\n                        |> Option.map fst\n                        |> Option.map (fun (i, ms) ->\n                            lines.[.. i - 1]\n                          , lines.[i + 1.. ]\n                          , ms\n                        )\n            \n                    let transpose (lines:string[]) =\n                        let max   = lines |> Seq.map (fun l -> l.Length) |> Seq.max\n                        [|\n                            for i in 0..max-1 do\n                                yield \n                                    new System.String( [| for l in lines do yield if l.Length > i then l.[i] else ' ' |])\n                                    \n                        |]\n            \n                    let verticalSplit (lyt:string[]) =\n                        let lines = transpose lyt\n                        lines\n                        |> Seq.indexed\n                        |> Seq.choose (fun (i, l) -> \n                            match l with\n                            | REGEX @\"^ *\\|+ *$\" \"\" [| _ |] -> Some(i, l.IndexOf '|')\n                            | _ -> None\n                        )\n                        |> Seq.sortBy snd\n                        |> Seq.tryHead\n                        |> Option.map fst\n                        |> Option.map (fun i -> lines.[.. i - 1] |> transpose\n                                              , lines.[i + 1 ..] |> transpose )\n                        |> Option.map (fun (l,r) ->\n                            l |> Array.filter(extractMeasuresO >> (=) None),\n                            r |> Array.filter(extractMeasuresO >> (=) None),\n                            seq {\n                                yield! l |> Seq.choose(extractMeasuresO)\n                                yield! r |> Seq.choose(extractMeasuresO) |> Seq.map (function Fixed(v, true) -> Fixed(v, false) | m -> m)\n                            } \n                            |> Seq.tryHead\n                            |> Option.defaultValue (Variable(5., 50., 95.))\n                        )\n            \n                    let cleanSpaces (lyt:string[]) = \n                        lyt \n                        |> String.concat \" \"\n                        |> fun s -> s.Split([| \" \" |], System.StringSplitOptions.RemoveEmptyEntries)\n                        |> Array.filter(function Int _ -> false |_-> true)\n            \n                    let rec extractNodes lyt =\n                        let checkSplitter dir m one two =\n                            match extractNodes one, extractNodes two with\n                            | Node [||], other\n                            | other    , Node [||] -> other\n                            | nOne     , nTwo      -> Splitter(dir, m, nOne, nTwo) |> SubSplitter\n                        match horizontalSplit lyt with\n                        | None -> \n                            match verticalSplit lyt with\n                            | None              -> Node (cleanSpaces lyt)\n                            | Some(one, two, m) -> checkSplitter true  m one two\n                        |     Some(one, two, m) -> checkSplitter false m one two\n            \n                    let rec createLayoutDefinitions nameBase node =\n                        match node with\n                        | Node [|      |] -> \"___\"    , [||]\n                        | Node [| elem |] ->  elem    , [||]\n                        | Node    svrl    ->  nameBase, [| nameBase + \" div \\\"\\\" \" + String.concat \" \" svrl |]\n                        | SubSplitter(Splitter(dir, meas, one, two)) ->\n                            let name1, def1 = createLayoutDefinitions (nameBase + \"_1\") one\n                            let name2, def2 = createLayoutDefinitions (nameBase + \"_2\") two\n                            nameBase, [| yield [ nameBase  ; (if dir then \"vertical\" else \"horizontal\") ; meas.ToString() ; name1 ; name2 ] |> String.concat \" \" \n                                         yield! def1\n                                         yield! def2 |]\n            \n                let emptyLine (l:string) = \n                    let lt = l.Trim()\n                    lt = \"\" || lt.StartsWith \"//\"\n                let notEmpty = emptyLine >> not\n            \n                let getExtraLines pred (ls: string[]) =\n                    ls \n                    |> Seq.skip 1 \n                    |> Seq.tryFindIndex (fun l -> notEmpty l && not(pred l) )\n                    |> Option.map ((+) 1)\n                    |> Option.defaultValue ls.Length\n                    |> fun i -> \n                        ls.[1..i-1] |> Array.filter notEmpty, ls.[i..] \n            \n                let rec createLines baseName n (names: string[]) (lines: string[]) i (ls:string[]) =\n                    let prefix  = String.replicate n \":\"\n                    let prefix2 = \":\" + prefix\n                    match Seq.tryHead ls with\n                    | None   -> names, lines\n                    | Some l ->\n                    match l.Trim() with\n                    | String.StartsWith prefix l ->\n                        let children, rest = ls |> getExtraLines(fun (l:string) -> l.Trim().StartsWith prefix2)\n                        let name = sprintf \"_%s_%d\" baseName i\n                        let childNames, childrenLines = createLines name (n+1) [||] [||] 1 children\n                        let names2 = [| yield! names ; yield name |]\n                        let lines2 = [| yield! lines\n                                        yield! childrenLines\n                                        yield  name + \" \" + l + \" \" + String.concat \" \" childNames\n                                     |]\n                        createLines baseName n names2 lines2 (i+1) rest\n                    | _   -> names, lines\n            \n                let processLines f ls =\n                    let rec processLinesR (ls: string[]) =\n                        match Seq.tryHead ls with\n                        | None   -> [||]\n                        | Some l ->\n                        match splitTokens l with\n                        | [ Identifier name ;  Layout ] ->\n                            let lyt, rest = ls |> getExtraLines(fun (l:string) -> l.Trim().StartsWith \"|\")\n                            lyt\n                            |> Layout.extractNodes\n                            |> Layout.createLayoutDefinitions name\n                            |> snd\n                            |> Array.append <| rest\n                            |> processLinesR\n                        |[] -> processLinesR ls.[1..]\n                        | _ ->\n                            let docs, rest = ls |> getExtraLines(fun (l:string) -> l.Trim().StartsWith \":\")\n                            if docs.Length > 0 then\n                                let prefix = l.Split([|' '|], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.item 0\n                                let names, ls = createLines prefix 1 [||] [||] 1 docs\n                                [|  yield! ls\n                                    yield  l + \" \" + String.concat \" \" names\n                                    yield! rest\n                                |]\n                                |> processLinesR\n                            else\n                                [| \n                                    match f l with\n                                    | Some r -> yield r\n                                    | _ -> ()\n                                    yield! processLinesR rest\n                                |]\n                    processLinesR ls \n            \n                let processText f (txt:string) =\n                    txt.Split(  [|'\\n' ; '\\r' |], System.StringSplitOptions.RemoveEmptyEntries)\n                    |> processLines f\n            \n                let parseEntries (lytNm:AF.PlugInName) txt =\n                    let localRefs = System.Collections.Generic.Dictionary<_,_>()\n                    sprintf \"PlugInName View \\\"%s\\\"\\n%s\" lytNm.Id txt\n                    |> processText (Syntax.createEntryO2 lytNm localRefs)\n            \n                //let createEntries lytNm = processText (createEntryO lytNm)\n                                        //|> Seq.choose (createEntryO lytNm)\n                                        //|> Seq.toArray\n            \n                let getText lytNm txtName =\n                    match txtName with\n                    | Identifier id -> let plg, nm = AF.splitName lytNm id \n                                       AF.tryGetViw plg nm\n                                       |> Option.map (fun viw -> Doc.TextView viw.viwView    )\n                                       |> Option.defaultWith (fun () -> \n                                       AF.tryGetVar plg nm\n                                       |> Option.map (fun var -> Doc.TextView var.varVar.View)\n                                       |> Option.defaultWith (fun () -> Html.text id))\n                    | (S txt)       -> Html.text txt\n            \n                let getDocEntries entries =\n                    entries\n                    |> Seq.choose (function | EntryDoc doc -> Some doc |_-> None)\n                    |> Seq.groupBy (fun d -> d.docName) |> Seq.map (snd >> Seq.last)\n            \n                let getVarEntries entries =\n                    entries\n                    |> Seq.choose (function | EntryVar var -> Some var |_-> None)\n                    |> Seq.groupBy (fun v -> v.varName) |> Seq.map (snd >> Seq.last)\n            \n                let getViewEntries entries =\n                    entries\n                    |> Seq.choose (function | EntryView vw -> Some vw |_-> None)\n                    |> Seq.groupBy (fun v -> v.viwName) |> Seq.map (snd >> Seq.last)\n            \n                let getActionEntries entries =\n                    entries\n                    |> Seq.choose (function | EntryAction ac -> Some ac |_-> None)\n                    |> Seq.groupBy (fun v -> v.actName) |> Seq.map (snd >> Seq.last)\n            \n                let getQueryEntries entries =\n                    entries\n                    |> Seq.choose (function | EntryQuery qr -> Some qr |_-> None)\n                    |> Seq.groupBy (fun v -> v.qryName) |> Seq.map (snd >> Seq.last)\n            \n            //    let inputFile lytNm attrs labelName actName doc =\n            //        splitName lytNm actName\n            //        ||> AF.tryGetAct\n            //        |> Option.map(fun act -> \n            //            Html.div (getAttrs lytNm (Quoted attrs)) [\n            //                Html.div              [ attr.``class`` \"input-group\"       ] [\n            //                    Html.span         [ attr.``class`` \"input-group-btn\"   ] [ \n            //                        Html.label    [ attr.``class`` \"btn\"               ] [ \n            //                            getText lytNm (Quoted labelName)\n            //                            Html.input[ attr.``class`` \"form-control\" \n            //                                        attr.``type`` \"file\" \n            //                                        Attr.Style \"display\" \"none\" \n            //                                        Html.on.click (fun el ev -> el?value <- \"\")\n            //                                        Html.on.change(fun el ev -> act.actFunction |> AF.callFunction el () )\n            //                                        ] []\n            //                        ]\n            //                    ]\n            //                    (if doc <> \"\" then singleDoc lytNm [ UnQuoted doc ] else Doc.Empty)\n            //                ]\n            //            ]\n            //        ) |> Option.defaultWith(fun () ->  sprintf \"Action not found %s\" actName |> AF.errDoc )\n            //\n            //    let inputLabel lytNm attrs labelName varName =\n            //        splitName  lytNm varName\n            //        ||> AF.tryGetVar\n            //        |> Option.map(fun var -> \n            //            Html.div (getAttrs lytNm (Quoted attrs)) [\n            //                Html.div      [ attr.``class`` \"input-group\"       ] [\n            //                    Html.span [ attr.``class`` \"input-group-addon\" ] [ getText lytNm (Quoted labelName) ]\n            //                    Doc.Input [ attr.``class`` \"form-control\"      ]   var.varVar\n            //                ]\n            //            ]\n            //        ) |> Option.defaultWith(fun () ->  sprintf \"Var not found %s\" varName |> AF.errDoc )\n            \n                let none x = Html.span [][]\n            \n                let refreshEntries lytN entries =\n                    let plg =   match AF.tryGetPlugIn lytN with\n                                | Some plg -> plg\n                                | None     -> \n                                    let plg = { AF.defaultPlugIn() with plgName = lytN }\n                                    AF.addPlugIn plg\n                                    plg\n                    ListModel.refreshLM plg.plgVars    [| yield! getVarEntries    entries |]\n                    ListModel.refreshLM plg.plgViews   [| yield! getViewEntries   entries |]\n                    ListModel.refreshLM plg.plgActions [| yield! getActionEntries entries |]\n                    ListModel.refreshLM plg.plgQueries [| yield! getQueryEntries  entries |]\n                    ListModel.refreshLM plg.plgDocs    [| \n                        yield! getDocEntries    entries\n                        //yield  AF.newDocF <| AF.PlgElemName \"InputFile\"  <| AF.FunDoc4(inputFile  lytN, \"attrs\", \"Label\", \"Action\", \"[Doc]\")\n                        //yield  AF.newDocF <| AF.PlgElemName \"InputLabel\" <| AF.FunDoc3(inputLabel lytN, \"attrs\", \"Label\", \"Var\"            )\n                        //yield  AF.newDocF <| AF.PlgElemName \"none\"       <| AF.FunDoc1(none           , \"x\"                                )\n                    |]\n            \n            //    let addLayout (lyt:LayoutEngine) =\n            //        lyt.lytDefinition.View |> View.Sink(fun txt ->\n            //            currentViewTriggger <- V ( lyt.lytDefinition.V + AF.mainDocV.V)\n            //            createEntries lyt.lytName txt\n            //            |> Seq.append [ AF.newVar (AF.PlgElemName \"Layout\") lyt.lytDefinition |> EntryVar ]\n            //            |> refreshEntries lyt.lytName\n            //        )\n            \n                let newLyt name (lyt:string) = {\n                    lytName       = name\n                    lytDefinition = Var.Create lyt\n                }\n            \n            //    let addNewLayout (name:obj) (layout:obj) =\n            //        (if layout <> null then unbox layout else \"\"\"\n            //split horizontal 0-50-100 AppFramework.AppFwkClient Hello\n            //Hello h1 \"color:blue; class=btn-primary\" \"How are you today?\" Ask\n            //Ask Doc InputLabel \"placeholder=Type you answer here...\" \"Answer:\" AppFramework.mainDocV  \n            //\"\"\"     |> String.unindentStr)\n            //        |> newLyt (if layout <> null then unbox name else System.Guid.NewGuid() |> string |> fun s -> \"Lyt_\" + s.Replace(\"-\", \"\") |> AF.PlugInName )\n            //        |> addLayout\n            //\n            //    if IsClient then\n            //        AF.tryGetPlugIn AF.defPlugInName\n            //        |> Option.iter(fun plg ->\n            //            plg.plgActions.Add <| ( AF.newActF <| AF.PlgElemName  \"AddLayout\" <| AF.FunAct2(addNewLayout, \"[Name]\", \"[Layout]\") )\n            //        )\n            \n            module NewLY =\n                //open FsRoot\n                open WebSharper.UI\n                open WebSharper.UI.Client\n            \n                open AppFramework\n                module AF = AppFramework\n            \n                open Html\n            \n                open Depend.Operators\n            \n                let concat a b = sprintf \"Concat(%d, %f)\" a b \n                let aV = Var.Create 4\n                let pa = aV.View\n                let pb = 6.2\n            \n                let currentPlugInNameDef : PlugInName = PlugInName \"NewLYx\"\n                let currentPlugInNameD                = Depend.dependByName \"currentPlugInName\" currentPlugInNameDef id\n            \n                module P =\n                    let run pin (p:P<_>) = p.r |> run pin\n            \n                if IsClient then\n            \n                    let name       = Var.Create \"World\"\n            \n                    let checkName (n:string) = if n = \"World\".[0..n.Length-1] || n.Length <= 1 then \"<---- Please enter your name\" else \"\" \n            \n                    let enterName  = ! checkName             <! name\n                    let now        = ! (fun _ -> nowStamp()) <! name\n            \n                    let sayHello  =\n                        let sayHello_0 = ! Doc.Concat <& \"Hello @{name}!\" <! enterName\n                        let sayHello_1 = ! Doc.Concat <& \"How are you?\"\n                        ! Doc.Concat <& sayHello_0       <! sayHello_1\n            \n                    let aString = Var.Lens aV string (fun _ -> int)\n            \n                    let main0 = ! concat <! aV <* 3.2\n                    let main1 = !(sprintf \"result = %s %s\") <! main0 <* \"main0\"\n                    let main  = ! h3 <& \"color:@{name}; background:red; click=@{AppFramework.Hello}\" <& \"MAIN:\" <! main1 <! main1 <! \":\" <! sayHello <! \":\" <! \" Más >> \" <! sayHello <! \" <<\"\n            \n                    let main2 = makeAViewDoc <| fun () -> h4 [ attr.styleDyn <| V(\"color:\" + name.V) ] [ text \"MAIN2:\" ; Doc.TextView name.View] \n            \n                    let appFwk = ! div <& \"color:@{name}\" <& \"@{AppFramework.AppFwkClient}\"\n                    let split  = ! (LayoutEngine.variableSplitter false 0. 50. 100.) <& appFwk <& main\n                    let split2 = ! (LayoutEngine.variableSplitter false 0. 50. 100.) <& appFwk <& main2\n            \n                    let callDocPFn pin pf = pf |> P.run pin |> callDoc\n            \n                    ()\n                    \n                //let pName = PlugInName \"NewLY\" \n            //\n                //AF.plugin {\n                //    plgName pName.Id\n                //    plgVar  \"name\"      name\n                //    plgVar  \"a\"         aString\n                //    plgDoc  \"split\"     (lazy         (split      |> callDocPFn pName ) )\n                //    plgDoc  \"split2\"    (lazy         (split2     |> callDocPFn pName ) )\n                //    plgDoc  \"main\"      (lazy         (main       |> callDocPFn pName ) )\n                //    plgDoc  \"main2\"     (lazy          main2                            )\n                //    plgDoc  \"sayHello\"  (lazy         (sayHello   |> callDocPFn pName ) )\n                //    plgDoc  \"sayHello2\" (lazy         (sayHello   |> callDocPFn pName ) )\n                //}\n                //|> AF.addPlugIn\n            \n            \n                //[< SPAEntryPoint >]\n                //let mainProgram() =\n                //    do (StartAppFramework.startWithHtmlD \n                //        |> Depend.resolver [\n                //            \"AppFrameworkTemplate.html\", AppFrameworkTemplate.html + SnippetTemplates.html\n                //        ]) ()\n            \n                open LayoutEngine\n                open LayoutEngine.Syntax\n            \n                let itemRefToTextType = function\n                | LocalRef     t  -> Extract0.TReference t\n                | FullRef(pr, er) -> Extract0.TReference (sprintf \"%s.%s\" pr er)\n            \n                let itemRefToString = function\n                | LocalRef     t  -> t\n                | FullRef(pr, er) -> (sprintf \"%s.%s\" pr er)\n            \n                let textValToTextType = function\n                | TvConst  s          -> Extract0.TSimple  s\n                | TvActRef (ActRef v)  \n                | TvDocRef (DocRef v)  \n                | TvVarRef (VarRef v)  \n                | TvViwRef (ViwRef v) -> itemRefToTextType v\n            \n                let (|ActRVs|) = function | ActRef v -> [ TvVarRef (VarRef v)]\n            \n            //    let attrValToAttrD = Depend.depend {\n            //        let! getTextValFromTextTypes = Extract0.getTextValFromTextTypesD\n            //        let! getTextVal              = Extract0.getTextValD\n            //        return\n            //            function\n            //            | AtStyle (an,        vs) -> vs, valToStyle an\n            //            | AtAct   (an, ActRVs vs) \n            //            | AtAttr  (an,        vs) -> vs, valToAttr  an\n            //            >> fun (vs, f) -> \n            //                List.map textValToTextType vs\n            //                |> getTextValFromTextTypes\n            //                |> f\n            //    }\n            \n                let nodeRefToDocD = Depend.depend {\n                    let! getDocFromTextTypes = Extract0.getDocFromTextTypesD\n                    return function\n                        | NdTextValL       vs ->  vs |> List.map textValToTextType \n                        | NdDocRef (DocRef r)\n                        | NdVarRef (VarRef r)\n                        | NdViwRef (ViwRef r) -> [ itemRefToTextType r ]\n                        >> getDocFromTextTypes\n                }\n            \n                let varRefToVarD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    return fun (VarRef ref) ->\n                        let r = itemRefToString ref\n                        AF.splitName currentPlugInName r\n                        ||> AF.tryGetVar\n                        |>  Option.map (fun v -> v.varVar)\n                        |>  Option.defaultWith(fun () -> Var.Make (View.Const <| sprintf \"Could not find var %s\" r) ignore )\n                }\n            \n                let actRefToActD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    return fun (ActRef ref) ->\n                        let r = itemRefToString ref\n                        AF.splitName currentPlugInName r\n                        ||> AF.tryGetAct\n                        //|>  Option.map (fun v -> v.)\n                        |>  Option.defaultWith(fun () -> AF.newAct (PlgElemName r) (fun () -> printfn \"Could not find action %s\" r) ) \n                }\n            \n                let getParamD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    let! getTextValFromSeq = Extract0.getTextValFromSeqD\n                    return fun (p:ParmRef) ->\n                        let refToSplit = itemRefToString >> AF.splitName currentPlugInName\n                        match p with\n                        | PrTextValL       ts -> ts|> List.map textValToTextType   |> getTextValFromSeq |> Val.toView |> View.Map box\n                        | PrDocRef (DocRef r) -> r |> refToSplit ||> AF.tryGetDocW |> View.Map  (Option.map ((fun d -> d.docDoc     ) >>          box ) >> Option.defaultWith (fun () -> sprintf \"missing ref Doc %A\"    r :> obj              ) )\n                        | PrVarRef (VarRef r) -> r |> refToSplit ||> AF.tryGetVarW |> View.Bind (Option.map ((fun v -> v.varVar.View) >> View.Map box ) >> Option.defaultWith (fun () -> sprintf \"missing ref Var %A\"    r :> obj |> View.Const) )\n                        | PrViwRef (ViwRef r) -> r |> refToSplit ||> AF.tryGetViwW |> View.Bind (Option.map ((fun v -> v.viwView    ) >> View.Map box ) >> Option.defaultWith (fun () -> sprintf \"missing ref View %A\"   r :> obj |> View.Const) )\n                        | PrActRef (ActRef r) -> r |> refToSplit ||> AF.tryGetActW |> View.Map  (Option.map ((fun v -> v.actFunction) >>          box ) >> Option.defaultWith (fun () -> sprintf \"missing ref Action %A\" r :> obj              ) )\n                }\n            \n                let itemRefToAbsolute lyt = \n                    function\n                    | LocalRef     t  -> lyt, t\n                    | FullRef(pr, er) -> pr , er\n                    >> fun (a,b) -> sprintf \"%s.%s\" a b\n            \n                let getParam2D = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    let! getTextValFromSeq = Extract0.getTextValFromSeqD\n                    return fun (p:ParmRef) ->\n                        let toAbs = itemRefToAbsolute currentPlugInName.Id >> sprintf \"@{%s}\"\n                        let toAbsRef = function \n                        | TvConst s-> s \n                        | TvVarRef (VarRef r) \n                        | TvActRef (ActRef r) \n                        | TvDocRef (DocRef r) \n                        | TvViwRef (ViwRef r) -> toAbs r\n                        match p with\n                        | PrTextValL       ts -> ts|> Seq.map toAbsRef |> String.concat \"\"\n                        | PrViwRef (ViwRef r) \n                        | PrDocRef (DocRef r) \n                        | PrVarRef (VarRef r) \n                        | PrActRef (ActRef r) -> toAbs r\n                }\n            \n                let getParamTextD = Depend.depend {\n                    let! currentPlugInName = currentPlugInNameD\n                    let! getTextValFromSeq = Extract0.getTextValFromSeqD\n                    return fun (p:ParmRef) f ->\n                        let refToSplit = itemRefToString >> AF.splitName currentPlugInName\n                        match p with\n                        | PrTextValL       ts -> ts|> List.map textValToTextType  |> getTextValFromSeq |> Val.toView       |> View.Get (box >> f)\n                        | PrDocRef (DocRef r) -> r |> refToSplit ||> AF.tryGetDoc |> Option.iter ((fun d -> d.docDoc     ) >>           box >> f  )\n                        | PrVarRef (VarRef r) -> r |> refToSplit ||> AF.tryGetVar |> Option.iter ((fun v -> v.varVar.View) >> View.Get (box >> f) )\n                        | PrViwRef (ViwRef r) -> r |> refToSplit ||> AF.tryGetViw |> Option.iter ((fun v -> v.viwView    ) >> View.Get (box >> f) )\n                        | PrActRef (ActRef r) -> r |> refToSplit ||> AF.tryGetAct |> Option.iter ((fun v -> v.actFunction) >>           box >> f  )\n                }\n            \n                let defVar(    lytN, n:string, v) = Var.Create v\n                let defAction( lytN, n:string, ActRef ac:ActRef, ps:ParmRef list) =\n                    Depend.depend {\n                        let! currentPlugInName = currentPlugInNameD\n                        let! getParamText      = getParamTextD\n                        return (\n                            let r     = itemRefToString ac\n                            AF.splitName currentPlugInName r\n                            ||> AF.tryGetAct\n                            |>  Option.map          (fun act -> \n                                if ps = [] then act.actFunction else\n                                match act.actFunction, ps with\n                                | AF.FunAct1(f,_    ), [ t1     ] -> AF.FunAct0( fun () -> getParamText t1                             f              )\n                                | AF.FunAct2(f,_, _ ), [ t1; t2 ] -> AF.FunAct0( fun () -> getParamText t1 (fun p1 -> getParamText t2 (f p1   ) )     )\n                                | AF.FunAct2(f,_, n2), [ t1     ] -> AF.FunAct1((fun p2 -> getParamText t1 (fun p1 ->                  f p1 p2) ) , n2)\n                                | _ -> AF.FunAct0 (fun () -> printfn \"Parameters do not coincide for Action %s %A %A\" r ps act )\n                            )\n                            |>  Option.defaultWith  (fun ()  -> AF.FunAct0 (fun () -> printfn \"Action Not Found %s\" r) )\n                        )\n                    } |> run lytN\n                let defActions( lytN, n:string, acs:ActRef list) =\n                    Depend.depend {\n                        let! currentPlugInName = currentPlugInNameD\n                        let! getParamText      = getParamTextD\n                        return (fun () ->\n                            acs\n                            |> Seq.iter (fun (ActRef ac) -> \n                                let r     = itemRefToString ac\n                                AF.splitName currentPlugInName r\n                                ||> AF.tryGetAct\n                                |>  Option.map(fun act -> act.actFunction)\n                                |>  Option.defaultWith  (fun ()  -> AF.FunAct0 (fun () -> printfn \"Action Not Found %s\" r) )\n                                |>  callFunction () ()\n                            )\n                        ) |> AF.FunAct0\n                    } |> run lytN\n                let defView( lytN, n:string, ps:ParmRef list) =\n                    Depend.depend {\n                        let! currentPlugInName = currentPlugInNameD\n                        let! getParam2         = getParam2D\n                        let! extractText       = extractTextD\n                        return baseView |> View.Bind(fun _ ->\n                            ps\n                            |> View.traverseSeq (getParam2   >> extractText     )\n                            |> View.Map         (Seq.toArray >> String.concat \"\")\n                        )\n                    } |> run lytN\n                let defViewJS( lytN, n:string, ps:ParmRef list) =\n                    Depend.depend {\n                        let! currentPlugInName = currentPlugInNameD\n                        let! getParam          = getParamD\n                        return baseView |> View.Bind(fun _ ->\n                            try\n                                ps\n                                |> View.traverseSeq getParam\n                                |> View.Map Seq.toArray\n                                |> View.Map (fun ar ->\n                                    try match ar with\n                                        | [|   |] -> \"No JS function specified\"\n                                        | [| _ |] ->  JavaScript.JS.Eval (unbox ar.[0])                                                         |> string\n                                        | _       -> (JavaScript.JS.Eval (unbox ar.[0]) |> unbox<JavaScript.FuncWithArgs<_,obj>>).Call ar.[1..] |> string\n                                    with e -> e.Message\n                                )\n                            with e -> e.Message |> View.Const\n                        )\n                    } |> run lytN\n                let defInput(   lytN, n:string, v   , attrs : AttrVal seq) = makeAViewDoc0 <| fun () -> (AF.errDocf \"input deprecated use AF.Input\"       )\n                let defTextArea(lytN, n:string, v   , attrs : AttrVal seq) = makeAViewDoc0 <| fun () -> (AF.errDocf \"TextArea deprecated use AF.TextArea\" )\n                let defElement( lytN, n:string, elem, attrs : ParmRef, docs:NodeRef list) = \n                    Depend.depend {\n                        let! nodeRefToDoc  = nodeRefToDocD\n                        let! extractAts    = extractAtsD\n                        let! getParam2     = getParam2D\n                        return\n                            makeAViewDoc0 <| fun () ->\n                                try\n                                    Doc.Element elem\n                                        <| extractAts (getParam2 attrs)\n                                        <| (docs |> Seq.map nodeRefToDoc )\n                                    :> Doc\n                                with e -> text e.Message\n                    } |> run   lytN\n                let defConcat( lytN, n:string, docs:NodeRef list) = \n                    Depend.depend {\n                        let! nodeRefToDoc  = nodeRefToDocD\n                        return\n                            makeAViewDoc0 <| fun () ->\n                                docs |> Seq.map nodeRefToDoc |> Doc.Concat\n                    } |> run   lytN\n                let defDocF(   lytN, n:string, DocRef dc, ds:ParmRef list) =\n                    Depend.depend {\n                        let! currentPlugInName    = currentPlugInNameD\n                        let! getParam2            = getParam2D\n                        let  getP                 = getParam2\n                        let rec passParm          = function\n                            | AF.DocFunction.FunDoc0 f0           , _    ->  AF.DocFunction.JustDoc( f0()                )\n                            | df                                  , []   ->                          df\n                            | AF.DocFunction.JustDoc ld           , _    ->  AF.DocFunction.JustDoc  ld\n                            | AF.DocFunction.FunDoc1(f1,_        ), a::r ->  AF.DocFunction.FunDoc0(fun () ->  getP a  |> f1 )\n                            | AF.DocFunction.FunDoc2(f2,_,b      ), a::r -> (AF.DocFunction.FunDoc1(     f2 <| getP a,b      ),r) |> passParm\n                            | AF.DocFunction.FunDoc3(f3,_,b,c    ), a::r -> (AF.DocFunction.FunDoc2(     f3 <| getP a,b,c    ),r) |> passParm\n                            | AF.DocFunction.FunDoc4(f4,_,b,c,d  ), a::r -> (AF.DocFunction.FunDoc3(     f4 <| getP a,b,c,d  ),r) |> passParm\n                            | AF.DocFunction.FunDoc5(f5,_,b,c,d,e), a::r -> (AF.DocFunction.FunDoc4(     f5 <| getP a,b,c,d,e),r) |> passParm\n                        let lyt, elem = itemRefToString dc |> splitName currentPlugInName\n                        return\n                            lazy (\n                                AF.tryGetDoc lyt elem\n                                |> Option.map (fun d -> passParm(d.docDoc.Value, ds) )\n                                |> Option.defaultWith  (fun ()  -> sprintf \"Missing doc: %A\" dc |> AF.errDoc |> AF.DocFunction.JustDoc)\n                            )\n                    } |> run   lytN\n                let defButton( lytN, n:string, ac, attrs : AttrVal seq, tx:TextVal list) = makeAViewDoc0 <| fun () -> (AF.errDocf \"Button deprecated use button \\\"click=@{Action}\\\"\" )\n            \n                let defSplitter(lytN, n, v , m, DocRef l, DocRef r) =\n                    Depend.depend {\n                        let! getDocFromTextTypes = Extract0.getDocFromTextTypesD\n                        return fun () -> \n                            let getDoc d = makeAViewDoc (fun () -> itemRefToTextType d |> List.singleton |> getDocFromTextTypes)\n                            match m with\n                            | Fixed    (pixel,    first) ->    fixedSplitter v pixel first   (getDoc l) (getDoc r)\n                            | Variable (min, value, max) -> variableSplitter v min value max (getDoc l) (getDoc r)\n                        \n                    } |> run lytN\n            \n                let defTemplate(lytN, n, tmpDef : TemplateDef) =\n                    Depend.depend {\n                        let! nodeRefToDoc  = nodeRefToDocD\n                        let! varRefToVar   = varRefToVarD\n                        let! extractText   = extractTextD\n                        let! extractAts    = extractAtsD\n                        let! actRefToAct   = actRefToActD\n                        let! getParam2     = getParam2D\n                        return\n                            makeAViewDoc0 <| fun () ->\n                                let eventAct act = fun (el:JavaScript.Dom.Element) (ev:JavaScript.Dom.Event) -> act.actFunction |> AF.callFunction el ev\n                                try\n                                    let attrs = extractAts (getParam2 tmpDef.attrs)\n                                    Client.Doc.LoadLocalTemplates \"local\"\n                                    seq {\n                                        yield!  tmpDef.vars    |> Seq.map (fun (nm, vr) -> TemplateHole.VarStr(  nm.ToLower(), varRefToVar               vr  ) )\n                                        yield!  tmpDef.views   |> Seq.map (fun (nm, wr) -> TemplateHole.TextView(nm.ToLower(), extractText  (getParam2   wr) ) )\n                                        yield!  tmpDef.docs    |> Seq.map (fun (nm, nr) -> TemplateHole.Elt(     nm.ToLower(), nodeRefToDoc (NdDocRef    nr) ) )\n                                        yield!  tmpDef.actions |> Seq.map (fun (nm, ar) -> TemplateHole.Event(   nm.ToLower(), eventAct     (actRefToAct ar) ) )\n                                    }\n                                    |> (if Seq.isEmpty attrs then id else TemplateHole.Attribute(\"attrs\", Attr.Concat attrs) |> Seq.singleton |> Seq.append)\n                                    |> Client.Doc.NamedTemplate \"local\" (tmpDef.tmpName.ToLower() |> Some)\n                                    ///                                //    | TDText  v   -> TemplateHole.Text(    nm.ToLower(), v )\n                                    ///                                //    | TDView  vw  -> TemplateHole.TextView(nm.ToLower(), vw)\n                                    ///                                //    | TDAct   act -> TemplateHole.Event(   nm.ToLower(), (fun el ev -> act.actFunction |> AF.callFunction el ev ))\n                                    ///                                TemplateHole.Elt(nm.ToLower(), sprintf \"Not implemented: %s\" txt |> AF.errDoc) \n                                with e -> text e.Message\n                    } |> run   lytN\n            \n                let initVal = \"-<InitValue>-\"\n            \n                let defVarM0      = Memoize.memoize defVar\n                let defVarM(l,n,i)= defVarM0(l,n,initVal) |>! fun v -> if v.Value = initVal then v.Set i\n                let defDocFM      = Memoize.memoize defDocF\n                let defActionM    = Memoize.memoize defAction\n                let defActionsM   = Memoize.memoize defActions\n                let defButtonM    = Memoize.memoize defButton\n                let defInputM     = Memoize.memoize defInput\n                let defTextAreaM  = Memoize.memoize defTextArea\n                let defElementM   = Memoize.memoize defElement\n                let defConcatM    = Memoize.memoize defConcat\n                let defViewM      = Memoize.memoize defView\n                let defViewJSM    = Memoize.memoize defViewJS\n                let defSplitterM  = Memoize.memoize defSplitter\n                let defTemplateM  = Memoize.memoize defTemplate\n            \n                let generateEntries lytN =\n                    Seq.choose(function\n                        | n, EnVarDef ( VarDef      v                         ) -> defVarM(     lytN, n, v          ) |> AF.newVar  (AF.PlgElemName n) |> EntryVar    |> Some\n                    (**)| n, EnDocDef ( DcSplitter (SplitterDef(v , m, l, r) )) -> defSplitterM(lytN, n, v , m, l, r) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                    (**)| n, EnDocDef ( DcButton   (ButtonDef(  ac, ats, tx) )) -> defButtonM(  lytN, n, ac, ats, tx) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                    (**)| n, EnDocDef ( DcInput    (InputDef(   v , ats    ) )) -> defInputM(   lytN, n, v , ats    ) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                    (**)| n, EnDocDef ( DcTextArea (TextAreaDef(v , ats    ) )) -> defTextAreaM(lytN, n, v , ats    ) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                        | n, EnDocDef ( DcConcat   (ConcatDef            ds  )) -> defConcatM(  lytN, n,          ds) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                        | n, EnDocDef ( DcElement  (ElementDef( el, ats, ds) )) -> defElementM( lytN, n, el, ats, ds) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                        | n, EnDocDef ( DcDocF     (DocFDef(    dc,      ds) )) -> defDocFM(    lytN, n, dc,      ds) |> AF.newDocL (AF.PlgElemName n) |> EntryDoc    |> Some\n                        | n, EnActDef ( ActDef               (  ac, parms  )  ) -> defActionM(  lytN, n, ac, parms  ) |> AF.newActF (AF.PlgElemName n) |> EntryAction |> Some\n                        | n, EnActDefs( ActDefs                 acs           ) -> defActionsM( lytN, n, acs        ) |> AF.newActF (AF.PlgElemName n) |> EntryAction |> Some\n                        | n, EnViwDef ( ViwDef                      parms     ) -> defViewM(    lytN, n,     parms  ) |> AF.newViw  (AF.PlgElemName n) |> EntryView   |> Some\n                        | n, EnVJSDef ( VJSDef                      parms     ) -> defViewJSM(  lytN, n,     parms  ) |> AF.newViw  (AF.PlgElemName n) |> EntryView   |> Some\n                        | n, EnDocDef ( DcTemplate tmpDef                     ) -> defTemplateM(lytN, n,     tmpDef ) |> AF.newDoc0 (AF.PlgElemName n) |> EntryDoc    |> Some\n                        | n, EnPlgRef  _ -> None\n                        | n, EnPlgDef  _ -> None\n                    )\n            \n                //let parseNewLayout lytN =\n                //    LayoutEngine.parseEntries lytN\n                //    >> Seq.choose(function Ok p  -> Some p | Error m -> print m ; None)\n                //    >> generateEntries lytN\n            \n                let addNewLayout (lyt:LayoutEngine) =\n                    let parseW      = lyt.lytDefinition.View |> View.Map (LayoutEngine.parseEntries lyt.lytName)\n                    let errorsW     = parseW |> View.Map(Seq.choose(function Error msg -> Some msg |_-> None) >> String.concat \"\\n\")\n                    let defsW       = parseW |> View.Map(Seq.choose(function Ok    def -> Some def |_-> None) >> generateEntries lyt.lytName)\n                    let entries     = [ AF.newVar (AF.PlgElemName \"Layout\"   ) lyt.lytDefinition |> EntryVar\n                                        AF.newViw (AF.PlgElemName \"ParseMsgs\") errorsW           |> EntryView ]\n                    defsW |> View.Sink( Seq.append entries >> refreshEntries lyt.lytName )\n            \n                let addLayout name content =\n                    newLyt (AF.PlugInName name) content\n                    |> addNewLayout\n            \n                let addNewLayoutAct (name:obj) (layout:obj) =\n                    let name'   = if name   <> null                 then unbox name   else System.Guid.NewGuid() |> string |> fun s -> \"Lyt_\" + s.Replace(\"-\", \"\")\n                    let layout' = if layout <> null && name <> null then unbox layout else \"\"\"\n                                        perc  Var \"50\"\n                                        perc2 Var \"50\"\n                                        gap  Var \"5px\"\n            \n                                        Ask1 div \"background:lightblue; height:100%\"\n                                        : Doc AF.InputLabel \"placeholder=Type percentage here...\" \"Percentage (%):\" perc\n            \n                                        Ask2a div \"background:pink; height:100%\"\n                                        : Doc AF.InputLabel \"placeholder=Type percentage here...\" \"Percentage (%):\" perc2\n            \n                                        Ask2b div \"background:lightgreen; height:100%\"\n                                        : Doc AF.InputLabel \"placeholder=Type gap here...\" \"Gap:\" gap\n            \n                                        dragSplitter  Action AF.DragSplitter \"@{PlugInName}.perc\"\n                                        dragSplitter2 Action AF.DragSplitter \"@{PlugInName}.perc2\"\n            \n                                        Ask2 template HSplitter1 \"height:100%\" \"gap:gap\" \"doc1: Ask2a; doc2:Ask2b\" \"perc:perc2\" \"MouseDown:dragSplitter2\"\n            \n                                        main div \"\"\n                                        :    template VSplitter1  \"height:100%\" \"gap:gap\" \"doc1: Ask1 ; doc2:Ask2 \" \"perc:perc \" \"MouseDown:dragSplitter \"\n            \n                                        split horizontal 0-50-100 AppFramework.AppFwkClient main\n                                    \"\"\" |> String.unindentStr\n                    addLayout name' layout'\n            \n                if IsClient then\n                    AF.tryGetPlugIn AF.defPlugInName\n                    |> Option.iter(fun plg ->\n                        plg.plgActions.Add <| ( AF.newActF <| AF.PlgElemName  \"AddLayout\" <| AF.FunAct2(addNewLayoutAct, \"[Name]\", \"[Layout]\") )\n                    )\n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            module FsiAgent =\n                open FusionAsyncM\n                open FsiEvaluator\n                open FsiCodePresence\n                open Operators\n            \n                [< JavaScript >]\n                type Config = Config of workDir:string * parms:Set<string>\n            \n                let fuseConfigs workDir a b =\n                    match a, b with\n                    | Config(dirA, parmsA), Config(dirB, parmsB) ->\n                    Config((if dirB <> workDir then dirB else dirA), Set.union parmsA parmsB)\n            \n                let queueOutput send =\n                    let output        = new System.Text.StringBuilder()\n                    let append    txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n                    let consume   ()  = let v = output.ToString()\n                                        output.Clear() |> ignore\n                                        v\n                    let queue         = Mailbox.iter print (fun msg -> \n                                            match msg with\n                                            | Some txt -> append txt\n                                            | None     -> let txt2send =  consume()\n                                                          if  txt2send <> \"\" then send txt2send\n                                        )\n                    fun          txt -> txt |> Some |> queue.Post\n                                        async { do! Async.Sleep 100\n                                                queue.Post None } |> Async.Start\n            \n                let mutable outHndl      = ignore\n                let mutable errHndl      = ignore\n            \n                let setQueueHandlers send =\n                    let queue = queueOutput send \n                    outHndl <-                  queue\n                    errHndl <- ((+) \"Err: \") >> queue\n            \n                let ctor, aborter, disposer, getIdO, sendInput =\n                    let mutable fsiO = None\n                    let ctor (Config (workDir, config)) =\n                        let fsi = new FsiExe(config |> String.concat \" \", workDir, outHndl, errHndl)\n                        fsiO <- Some fsi\n                        fsi\n                    ctor\n                  , (fun ()  -> fsiO |> Option.iter (fun fsi ->  fsi                       .Abort      () ) )\n                  , (fun ()  -> fsiO |> Option.iter (fun fsi -> (fsi :> System.IDisposable).Dispose    () ) )\n                  , (fun ()  -> fsiO |> Option.map  (fun fsi ->  fsi                       .Process.Id    ) )\n                  , (fun txt -> fsiO |> Option.iter (fun fsi ->  fsi                       .Shell.Send txt) )\n            \n                let fsiExeL = lazy new ResourceAgent<_, _>( 70\n                                                         , ctor\n                                                         , Config (\".\", Set [\"--nologo\" ; \"--quiet\"])\n                                                         , (fun fsi    -> fsi.Abort()               ) \n                                                         , (fun fsi    -> fsi.IsAlive               )\n                                                         )\n            \n                [< JavaScript >]\n                let extractConfig workDir (FsCode fsCode) = \n                    Config(\n                        FsCode.getSourceDir workDir <| String.splitByChar '\\n' fsCode\n                      , FsCode.extractDefines (FsCode fsCode)\n                        |> String.splitByChar ' '\n                        |> Set\n                        |> Set.union  (Set[\" --nologo\" ; \"--quiet \"])\n                    )\n            \n                [< Rpc >]\n                let evalCode workDir code = \n                    evaluateRm code\n                    |> AgentReaderM.ofResourceRm\n                    |> AgentReaderM.run fsiExeL.Value (extractConfig workDir code)\n            \n                [< Rpc >]\n                let evalCodeSameConfig code = \n                    evaluateRm code\n                    |> AgentReaderM.ofResourceRm |> id\n                    |> AgentReaderM.runSameConfig fsiExeL.Value\n                \n                [< Rpc >]\n                let evalCodeWithPresence  workDir presenceKey presenceValue presenceCode code = \n                    let config = \n                        fuseConfigs       workDir\n                        <| extractConfig  workDir presenceCode\n                        <| extractConfig  workDir         code\n                    fusion {    \n                        let! currentValueO  = getPresenceRm presenceKey\n                        if   currentValueO <> Some presenceValue then\n                            do!  addPresenceRm presenceKey presenceValue\n                            do!  evaluateRm    presenceCode |>> ignore\n                        return! evaluateRm code\n                    }\n                    |> AgentReaderM.ofResourceRm\n                    |> AgentReaderM.run fsiExeL.Value config\n             \n                [<Rpc>]    \n                let abortFsiExe  () = aborter()\n                \n                [<Rpc>]    \n                /// like abortFsiExe but prevents respawning until next command\n                let disposeFsiExe() = disposer()\n            \n                [<Rpc>]\n                let sendFsiInput txt = async { sendInput txt }\n            \n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                //#define WEBSHARPER\n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                \n                type SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n                \n                [< JavaScript false >]\n                module Broker =\n                    open WebSharper\n                    open WebSharper.Owin.WebSocket.Server\n                    open System.Collections.Generic\n                    \n                    type SomeState = {\n                        info       : string\n                    }\n                    \n                    type IClient =\n                        abstract member Post : MessageGeneric -> unit\n                        abstract member Ip   : unit           -> string\n                        abstract member Id   : unit           -> string\n                        abstract member Close: unit           -> unit\n                \n                    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n                #if FSS_SERVER                          \n                        static let mutable fssWebSocketO : BrokerAgent option = None\n                #endif\n                        do printfn \"WebSocket server start\"\n                        let addConnection, removeConnection, getConnections =\n                            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n                            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n                           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n                           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n                        let processBrokerRequest req = \n                            match req with\n                            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n                            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n                            \n                        let respondFromBroker pyld msg =\n                            msg\n                            |> respond     pyld\n                            |> msgType     MsgFromBroker\n                            |> subtype     \"FromBroker\"\n                \n                        let post reply msg =\n                            match getConnections() |> Map.tryFind msg.destination with\n                            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n                            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n                            \n                        let clientConnect (client: IClient) = async {\n                            let clientId = client.Id()\n                            printfn \"clientConnect: %A\" clientId\n                            let uniqueId = System.Guid.NewGuid()\n                            printfn \"New Connection from %s\" clientId                           \n                            let clientAddress = Address clientId\n                            getConnections()\n                            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n                            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                                printfn \"Closing old connection from %s\" clientId\n                                kp.Value \n                                |> fun (_, conn) -> conn.Close()\n                            )\n                            addConnection clientAddress uniqueId client\n                            \n                            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n                            let checkReply msg = if msg.replier = Broker then\n                                                        msg |> respondFromBroker BMOk |> reply\n                            let forward msg = msg |> from clientAddress |> post reply\n                                              checkReply msg\n                            let respondMsg (msg:MessageGeneric) =\n                                checkReply msg\n                                printfn \"%A\" msg\n                                match msg.msgType with\n                                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                                | MsgFromBroker     -> ()\n                            let clientIp = client.Ip()\n                            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                                match wsmsg with\n                                | Message msg ->\n                                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                                    else                                             forward    msg     \n                                    return state\n                                | Error exn -> \n                                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                                    return state\n                                | Close ->\n                                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                                    removeConnection uniqueId\n                                    return state\n                            }\n                        }\n                        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n                        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n                            let inline tryGetValue key (dict) =\n                                dict \n                                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n                            clientConnect { new IClient with\n                                                member this.Post v  = client.Post v\n                                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                                member this.Id()    = client.Connection.Context.Request.Query \n                                                                      |> tryGetValue  \"ClientId\" \n                                                                      |> Option.bind         Array.tryHead \n                                                                      |> Option.defaultValue \"\"\n                                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                                          }\n                #if FSS_SERVER\n                        static member FssWebSocketO                = fssWebSocketO\n                        static member FssWebSocketO with set value = fssWebSocketO <- value\n                        member this.ConnectLocal clientId receiver = \n                            clientConnect { new IClient with\n                                                member this.Post v  = receiver v \n                                                member this.Ip()    = \"(server)\"\n                                                member this.Id()    = clientId\n                                                member this.Close() = () // probably shouldn't be called at all\n                                          }\n                \n                    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n                        async {\n                            match BrokerAgent.FssWebSocketO with \n                            | None -> raise (exn \"FssWebSocketO is not set\")\n                            | Some serverP ->\n                            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n                            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n                            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n                            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n                            let! clientInitState, clientFunc = f { new IServer with\n                                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                                       member this.Close()  = ()\n                                                                 }\n                            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n                            clientBoxO <- Some clientBox\n                            clientBox.Post CMessage.Open\n                        }\n                #endif        \n                        \n                        \n                \n                open System\n                open System.Threading\n                open System.Net.WebSockets\n                \n                [< JavaScript false >]\n                module Client =\n                    let startStateFull receive initAndfolder =\n                        async {\n                            let! initState, folder = initAndfolder\n                            let agentBox = Mailbox.foldA (fun ex st -> print ex; st) folder initState\n                            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n                            let error  a = agentBox.Post CMessage.Error ; finish a\n                            Async.StartWithContinuations(receive agentBox, finish, error, error)\n                        }\n                \n                    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n                        let conn = new ClientWebSocket()\n                        let chunkSize = 8192\n                        let send (txt:string)  =\n                            async {\n                                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                                let chunks = buffer.Length / chunkSize\n                                for i = 0 to chunks do\n                                    let last = i = chunks\n                                    let size = if last then buffer.Length % chunkSize else chunkSize\n                                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n                            }\n                        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n                            let buffer : byte[] = Array.create chunkSize 0uy\n                            let builder         = System.Text.StringBuilder()\n                            let keepgo          = ref true\n                            async {\n                                receiverBox.Post CMessage.Open\n                                while conn.State = WebSocketState.Open && !keepgo do\n                                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                                    match result.MessageType with\n                                    | WebSocketMessageType.Close -> keepgo := false\n                                    | WebSocketMessageType.Text ->\n                                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                                        builder.Append txt |> ignore\n                                        if result.EndOfMessage then\n                                            let txt = builder.ToString()\n                                            builder.Clear() |> ignore\n                                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                                    | _ -> ()\n                                return \"WebSocketServer receive Closed.\"\n                            }\n                        let brokerBox = Mailbox.iterA print (Json.Serialize >> send)\n                        let connect initAndfolder =\n                            async {\n                                printfn \"Connecting %s\" uri\n                                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                                printfn \"Connected %A\" WebSocketState.Open\n                                do! startStateFull receive initAndfolder\n                            }\n                        member this.WebSocket        = conn\n                        member this.Post (msg: 'C2S) = brokerBox.Post msg\n                        member this.Connect          = connect\n                \n                    let ConnectStateful<'S2C, 'C2S> uri getInitAndfolder =\n                        async {\n                            let  server          = WebSocketServer uri\n                            do!  server.Connect (getInitAndfolder server)\n                            return server\n                        }\n                \n                    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n                        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =\n                            f { new IServer with\n                                  member this.Post  v = serverP.Post v\n                                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                                        |> Async.AwaitTask |> Async.RunSynchronously            \n                               }\n                        ConnectStateful uri2 func\n                        |> Async.map ignore\n                        \n                //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open System\n                open WebSharper.Owin.WebSocket\n                open WebSharper.Owin.WebSocket.Client\n                \n                //#define FSS_SERVER\n                //#define WEBSHARPER\n                \n                type  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n                \n                type ClientTypeFSharp    = FSharp\n                #if WEBSHARPER\n                type ClientTypeFSStation = FSStation\n                type ClientTypeJScript   = JScript\n                \n                [< Inline >]\n                let ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n                    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n                        f { new IServer with\n                              member this.Post  v = serverP.Post v\n                              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n                           }\n                    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n                    ConnectStateful endPoint func\n                    |> Async.map ignore\n                #endif\n                \n                module ReplyHandler =\n                    type WaitForReplyMsg =\n                        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n                        | Reply  of Guid *   MessageGeneric\n                        | Excpn  of Guid *   exn\n                        | Cancel of Guid *   OperationCanceledException\n                        \n                    type Handler (defProc) =\n                        let waitingAgent =    \n                            Mailbox.fold Mailbox.defHandler (fun waitingForReply action ->\n                                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def\n                                                      Map.remove  key     waitingForReply\n                                match action with\n                                | Add   (key, fns) -> Map.add     key fns waitingForReply\n                                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)\n                                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore\n                                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore\n                            ) Map.empty\n                        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post\n                        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post\n                        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post\n                        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post\n                \n                [< Inline \"window.location.href\" >]\n                let getEndPoint() = \n                #if FSS_SERVER\n                    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n                #else\n                    \"http://localhost:9005/#/Snippet/9882ea9a-2dc3-4459-8605-9b2dd0c89bdc\"\n                #endif\n                \n                let extractEndPoint() = \n                    let ep : string = getEndPoint()\n                    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n                    ep2.Split('/').[0]\n                \n                type WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n                        , clientId:string, ?timeout:int, ?endPoint:string) =    \n                    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n                    let clientAddress = Address clientId\n                    let wsTimeout     = defaultArg timeout 60000\n                \n                    let mutable out = printfn \"%s\"\n                    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n                    let mutable serverO : IServer option = None\n                    let mutable payloadProcessorO : (string -> Async<string>) option = None\n                    let waiting = ReplyHandler.Handler (fun msg -> printfn \"Reply from '%s': %s\" msg.from.txt msg.payload)\n                \n                    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n                    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n                \n                    let processReply      msg = waiting.Reply msg.id msg\n                    let mapPayloadWrap (fW: _ -> Async<_> ) msg =\n                        async {\n                            let! r  = fW msg.payload\n                            return msg |> mapPayload (fun _ -> r)\n                        }\n                    let processMessage msg =\n                        //printfn \"%A\" msg\n                        match msg.msgType with\n                        | MsgFromBroker     \n                        | MsgReply           -> processReply msg\n                        | MsgInformation     -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                        | MsgRequest         -> match payloadProcessorO with \n                                                | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                                                | Some processor ->\n                                                msg |> mapPayloadWrap processor |> Async.iterA (makeReply >> reply) \n                        | MsgRequestForEcho  -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n                        | MsgRequestForId    -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n                    \n                    let connectToWebSocketServer() =\n                        printfn \"in connectToWebSocketServer\"\n                        async {\n                            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                                return 0, fun state wsmsg -> async {\n                                    try match wsmsg with\n                                        | CMessage.Message msg -> processMessage msg\n                                        | CMessage.Open        -> printfn \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                                        | CMessage.Close       -> printfn \"WebSocket %s connection closed.\" clientId ; close()\n                                        | CMessage.Error       -> printfn \"WebSocket %s connection error!\"  clientId\n                                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                                    return state\n                                }\n                            }\n                            printfn \"connectToWebSocketServer with server\"\n                            \n                        }\n                \n                    let checkServer = Mailbox.callA print ( fun () -> async {\n                        //printfn \"getServer\"\n                        if serverO.IsNone then\n                            printfn \"getServer Connecting\"\n                            do! connectToWebSocketServer()\n                            do! Async.Sleep 200\n                        return serverO |> Result.ofOption (fun () -> ErrorMsg \"could not connect to Server\")\n                    })        \n                \n                    let getServer() : AsyncResult<IServer, _> = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n                        \n                    let postR (server: IServer) rpl msg = \n                        let m = msg |> from clientAddress |> replier rpl \n                        try       server.Post m\n                        with e -> serverO <- None\n                                  raise e\n                \n                    let sendAndForget msg = asyncResult {\n                        let! server = getServer()\n                        msg |> postR server NoReply\n                    }\n                        \n                    let sendAndReply rpl msg = asyncResult {\n                        let! server  = getServer()\n                        let  replyA  = Async.FromContinuations(fun fns -> \n                            waiting.Add msg.id fns\n                            msg |> postR server rpl\n                            if wsTimeout > 0 then\n                                async {\n                                    do! Async.Sleep wsTimeout\n                                    waiting.Raise msg.id (TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn)\n                                } |> Async.Start\n                        )\n                        return! replyA\n                    }\n                        \n                    let sendAndVerify msg = asyncResult {\n                        let! reply   = sendAndReply Broker msg \n                        do!  match reply.msgType with\n                             | MsgFromBroker  -> let  bm = msgPayload reply\n                                                 if   bm = BMOk \n                                                 then Result.Ok    () \n                                                 else Result.Error <| ResultMessage.Message bm\n                             | _              ->      Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                    }\n                    \n                    let sendGetReply msg =\n                        asyncResult {\n                            let! reply   = sendAndReply Receiver msg \n                            let! result =\n                                match reply.msgType with\n                                | MsgReply      -> Result.Ok     reply.payload\n                                | MsgFromBroker -> let bm = msgPayload reply\n                                                   Result.Error <| ResultMessage.Message bm\n                                | _             -> Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                            return result\n                        }\n                \n                    let getListeners() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRConnections listeners -> return listeners\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let getProcessId() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetProcessId\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRPid pid -> return pid\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let sendMsg msg =\n                        asyncResult {\n                            if msg.replier = NoReply\n                            then do!     sendAndForget msg\n                                 return  \"\"\n                            else return! sendGetReply  msg\n                        }\n                    member this.MBListeners            = getListeners()\n                    member this.MBProcessId            = getProcessId()\n                    member this.EndPoint               = wsEndPoint\n                    member this.ClientId               = clientId\n                    member this.SendMsg           msg  = sendMsg msg\n                    [<  Inline >]\n                    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n                    [<  Inline >]\n                    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n                    [<  Inline >]\n                    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> AsyncResult.map Json.Deserialize\n                    member this.Out with set fout      = out <- fout\n                    [<  Inline >]\n                    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Async.map Json.Serialize))\n                                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                                         |> msgType MsgInformation\n                                                         |> sendAndForget |> AsyncResult.iterA (string >> failwith) id\n                    interface IDisposable with\n                        member this.Dispose() = close()\n                \n                #if FSS_SERVER   \n                    [< JavaScript false >]\n                    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                    [< JavaScript false >]\n                    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #if WEBSHARPER\n                    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                \n                \n            [< JavaScript >]\n            type FSMessage =\n            | MsgGetId\n            | MsgGetSnippets     of SnippetReference[]\n            | MsgGetCode         of SnippetReference\n            | MsgGetPredecessors of SnippetReference\n            | MsgAction          of string[]\n            | MsgGetUrl\n            | MsgGetValue        of string\n            | MsgSetValue        of string * string\n            | MsgGetModified     of SnippetReference\n            \n            [< JavaScript >]\n            type FSResponse =\n            | RespString         of string\n            | RespSnippets       of Snippet[]\n            | RespDateTime       of System.DateTime\n            \n            module FSharpStationClient =\n                open WebSockets\n            \n                let mutable fsharpStationAddress = Address \"FSharpStation1593197096670\"\n            \n                let [< Rpc >] setAddress address = async { \n                    fsharpStationAddress <- address \n                    printfn \"set %A\" fsharpStationAddress\n                }\n            \n                let fsharpStationClient, sendMessage : WSMessagingClient * (FSMessage -> AsyncResult<FSResponse, _>) = \n                    let client =\n            #if WEBSHARPER \n                        if IsClient then \n                            new WSMessagingClient(\"FSharpStationClientJS\"       )\n                        else\n            #endif            \n            #if FSS_SERVER            \n                            new WSMessagingClient(\"FSharpStationClientFSStation\", FSStation)\n            #else\n                            new WSMessagingClient(\"FSharpStationClientFSharp\"   , FSharp)\n            #endif\n                    client, fun m -> client.SendGetReply fsharpStationAddress m |> AsyncResult.absorbR\n            \n                let respString response = asyncResult { \n                    match response with\n                    | RespString code -> return code\n                    | _               -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let respDateTime response = asyncResult { \n                    match response with\n                    | RespDateTime time -> return time\n                    | _                 -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let respSnippet response = asyncResult { \n                    match response with\n                    | RespSnippets [| snp |] -> return snp\n                    | _                      -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let getCode path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> MsgGetCode\n                    |> sendMessage\n                    |> AsyncResult.bind respString\n            \n                let getModified path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> MsgGetModified\n                    |> sendMessage\n                    |> AsyncResult.bind respDateTime\n            \n                let getSnippet path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> Array.singleton\n                    |> MsgGetSnippets\n                    |> sendMessage\n                    |> AsyncResult.bind respSnippet\n            \n                let getUrl      () = MsgGetUrl            |> sendMessage |> AsyncResult.bind respString\n                let getValue vrw   = MsgGetValue vrw      |> sendMessage |> AsyncResult.bind respString\n                let setValue var v = MsgSetValue (var, v) |> sendMessage |> AsyncResult.bind respString\n            \n                let execJS      js          = sendMessage (MsgAction [| \"ExecJS\"      ; js              |]) |> AsyncResult.bind respString\n                let setProperty path prop v = sendMessage (MsgAction [| \"SetProperty\" ; path ; prop ; v |]) |> AsyncResult.bind respString\n                let sendOutput  txt         = sendMessage (MsgAction [| \"AddOutput\"   ; txt             |])\n                let actionCall0 act         = sendMessage (MsgAction [|  act                            |])\n                let actionCall1 act p1      = sendMessage (MsgAction [|  act          ; p1              |])\n                let actionCall2 act p1 p2   = sendMessage (MsgAction [|  act          ; p1   ; p2       |])\n                                        \n                let getBrokerProcessId() = fsharpStationClient.MBProcessId\n            module FsAutoComplete =\n                [<JavaScript ; AutoOpen >]\n                module CommTypes =\n                    type ResponseError =\n                        {\n                          Code: int\n                          Message: string\n                          //AdditionalData: 'T\n                        }\n                    type Location =\n                      {\n                        File: string\n                        Line: int\n                        Column: int\n                      }\n                    type CompletionResponse =\n                      {\n                        Name: string\n                        ReplacementText: string\n                        Glyph: string\n                        GlyphChar: string\n                      }\n                    //type ProjectResponse =\n                    //  {\n                    //    Project: ProjectFilePath\n                    //    Files: List<SourceFilePath>\n                    //    Output: string\n                    //    References: List<ProjectFilePath>\n                    //    Logs: Map<string, string>\n                    //  }\n                    type OverloadDescription =\n                      {\n                        Signature: string\n                        Comment  : string\n                        Footer   : string\n                      }\n                    type OverloadParameter =\n                      {\n                        Name : string\n                        CanonicalTypeTextForSorting : string\n                        Display : string\n                        Description : string\n                      }\n                    type Overload =\n                      {\n                        Tip : OverloadDescription list list\n                        TypeText : string\n                        Parameters : OverloadParameter list\n                        IsStaticArguments : bool\n                      }\n                    type Parameter = {\n                        Name : string\n                        Type : string\n                      }\n                    type SignatureData = {\n                        OutputType : string\n                        Parameters : Parameter list list\n                      }\n                    type MethodResponse =\n                      {\n                        Name : string\n                        CurrentParameter : int\n                        Overloads : Overload list\n                      }\n                    type SymbolUseRange =\n                      {\n                        FileName: string\n                        StartLine: int\n                        StartColumn: int\n                        EndLine: int\n                        EndColumn: int\n                        IsFromDefinition: bool\n                        IsFromAttribute : bool\n                        IsFromComputationExpression : bool\n                        IsFromDispatchSlotImplementation : bool\n                        IsFromPattern : bool\n                        IsFromType : bool\n                      }\n                    type SymbolUseResponse =\n                      {\n                        Name: string\n                        Uses: SymbolUseRange list\n                      }\n                    type HelpTextResponse =\n                      {\n                        Name: string\n                        Overloads: OverloadDescription list list\n                      }\n                    type CompilerLocationResponse =\n                      {\n                        Fsc: string\n                        Fsi: string\n                        MSBuild: string\n                      }\n                    type FSharpErrorInfo =\n                      {\n                        FileName    : string\n                        StartLine   : int\n                        EndLine     : int\n                        StartColumn : int\n                        EndColumn   : int\n                        Severity    : string\n                        Message     : string\n                        Subcategory : string\n                      }\n                    type ErrorResponse =\n                      {\n                        File: string\n                        Errors: FSharpErrorInfo []\n                      }\n                    type Colorization =\n                      {\n                    //    Range: Range\n                        Kind: string\n                      }\n                    type Declaration =\n                      {\n                        UniqueName: string\n                        Name: string\n                        Glyph: string\n                        GlyphChar: string\n                        IsTopLevel: bool\n                    //  Range     : Utils.Range\n                    //    BodyRange : Utils.Range\n                        File : string\n                        EnclosingEntity: string\n                        IsAbstract: bool\n                      }\n                    type DeclarationResponse = {\n                        Declaration : Declaration;\n                        Nested : Declaration []\n                    }\n                    type OpenNamespace = {\n                      Namespace : string\n                      Name : string\n                      Type : string\n                      Line : int\n                      Column : int\n                      MultipleNames : bool\n                    }\n                    type QualifySymbol = {\n                      Name : string\n                      Qualifier : string\n                    }\n                    type ResolveNamespaceResponse = {\n                      Opens : OpenNamespace []\n                      Qualifies: QualifySymbol []\n                      Word : string\n                    }\n                    type UnionCaseResponse = {\n                      Text : string\n                    //  Position : Pos\n                    }\n                    type Kind = \n                    | KInfo             of string\n                    | KError            of ResponseError\n                    | KHelpText         of HelpTextResponse\n                    | KCompletion       of CompletionResponse  []\n                    | KSymbolUse        of SymbolUseResponse\n                    | KHelp             of string\n                    | KMethod           of MethodResponse\n                    | KErrors           of ErrorResponse\n                    | KColorizations    of Colorization list\n                    | KFindDecl         of Location\n                    | KDeclarations     of DeclarationResponse []\n                    | KToolTip          of OverloadDescription [][]\n                    | KTypeSig          of string\n                    | KSignatureData    of SignatureData\n                    | KCompilerLocation of CompilerLocationResponse\n                    | KNamespaces       of ResolveNamespaceResponse\n                    | KUnionCase        of UnionCaseResponse\n                    | KMultiple         of Kind                []\n                    \n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n                //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n                \n                open System.Net\n                open System.Text\n                open System.IO\n                open FSharp.Data\n                open FSharp.Data.JsonExtensions\n                open Newtonsoft.Json\n                \n                open Utils\n                \n                [<JavaScript ; AutoOpen >]\n                module MsgTypes =\n                \n                    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n                    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n                    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n                    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n                    type ProjectRequest       = { FileName  : string                                                                                                               }\n                    type LintRequest          = { FileName  : string                                                                                                               }\n                    type HelptextRequest      = { Symbol    : string                                                                                                               }\n                    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n                \n                    type FARequest =\n                        | FarParse         of ParseRequest         \n                        | FarDeclarations  of DeclarationsRequest  \n                        | FarCompletion    of CompletionRequest    \n                        | FarPosition      of PositionRequest      \n                        | FarProject       of ProjectRequest       \n                        | FarLint          of LintRequest          \n                        | FarHelptext      of HelptextRequest      \n                        | FarWorkspacePeek of WorkspacePeekRequest    \n                \n                let toJson =\n                    function\n                    | FarParse         data -> JsonConvert.SerializeObject data \n                    | FarDeclarations  data -> JsonConvert.SerializeObject data \n                    | FarCompletion    data -> JsonConvert.SerializeObject data \n                    | FarPosition      data -> JsonConvert.SerializeObject data \n                    | FarProject       data -> JsonConvert.SerializeObject data \n                    | FarLint          data -> JsonConvert.SerializeObject data \n                    | FarHelptext      data -> JsonConvert.SerializeObject data \n                    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n                \n                let fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\n                let jsonData2Obj item = item?Data.ToString() |> fromJson\n                \n                let HttpRequestCall (url:string) (data:string) =\n                    async {\n                        //printfn \"RpcCall %s\" (extract 100 data)\n                        let req = WebRequest.Create(url) :?> HttpWebRequest \n                        req.Timeout         <- 300_000\n                        req.ProtocolVersion <- HttpVersion.Version10\n                        req.Method          <- \"POST\"\n                        req.ContentType     <- \"application/json\"\n                        let postBytes = Encoding.ASCII.GetBytes(data)\n                        //printfn \"<---\\n%s\\n\" data\n                        req.ContentLength <- int64 postBytes.Length\n                        let reqStream = req.GetRequestStream() \n                        reqStream.Write(postBytes, 0, postBytes.Length);\n                        reqStream.Close()\n                        use resp   = req.GetResponse() \n                        use stream = resp.GetResponseStream() \n                        use reader = new StreamReader(stream)\n                        let msg    = reader.ReadToEnd()\n                        //print msg\n                        //printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n                        let jsonV  = JsonValue.Parse msg\n                        return       jsonV\n                    }\n                \n                let KindError msg = KError { Code = 0 ; Message = msg }\n                \n                let json2Kind (v:JsonValue) = \n                    let item =JsonValue.Parse <| v.AsString()\n                    match item?Kind.AsString() with\n                    | \"info\"             -> jsonData2Obj item |> KInfo\n                    | \"error\"            -> jsonData2Obj item |> KError\n                    | \"errors\"           -> jsonData2Obj item |> KErrors\n                    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n                    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n                    | \"completion\"       -> jsonData2Obj item |> KCompletion\n                    | \"signature\"        -> jsonData2Obj item |> KTypeSig\n                    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n                    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n                    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n                    | \"helptext\"         -> jsonData2Obj item |> KHelpText\n                    | \"declarations\"     -> jsonData2Obj item |> KDeclarations\n                    | \"symboluse\"        -> jsonData2Obj item |> KSymbolUse\n                    | _                  -> KindError <| v.ToString()\n                \n                let UrlAddress = \"http://localhost:9001/\"\n                \n                [< Rpc >]\n                let FSAutocompleteCall0 cmd (req: FARequest) : Async<Result<Kind [],ResultMessage<Kind[]>>> = asyncResult {\n                        let  data          = req |> toJson\n                        let! jsonV         = HttpRequestCall (UrlAddress + cmd) data\n                        return               jsonV.AsArray() |> Array.map json2Kind\n                    } \n                \n                [<JavaScript ; AutoOpen>]\n                module Calls =\n                    let FSAutocompleteCall cmd f req = asyncResult {\n                            let! several       = FSAutocompleteCall0 cmd req\n                            let  goods, others = several |> Array.partition (f >> Option.isSome)\n                            let! good          = goods   |> Seq.choose f |> Seq.tryHead |> Result.ofOption (fun () -> others |> Message)\n                            return               good, others\n                        } \n                    \n                    let parseCode        file code asy ver   = FSAutocompleteCall \"parse\"               (function KErrors        v -> Some v |_-> None)\n                                                                     <| FarParse       { FileName        = file\n                                                                                         IsAsync         = asy   \n                                                                                         Lines           = code           \n                                                                                         Version         = ver\n                                                                                       }\n                    let toolTip          file lin col filter = FSAutocompleteCall \"tooltip\"             (function KToolTip       v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signature        file lin col filter = FSAutocompleteCall \"signature\"           (function KTypeSig v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signatureData    file lin col filter = FSAutocompleteCall \"signatureData\"       (function KSignatureData v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let completion  tx kw file ln col filter = FSAutocompleteCall \"completion\"          (function KCompletion    v -> Some v |_-> None)\n                                                                      <| FarCompletion { FileName        = file\n                                                                                         Line            = ln         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                         SourceLine      = tx\n                                                                                         IncludeKeywords = kw\n                                                                                        }\n                    \n                    let findTypeDecl     file lin col filter = FSAutocompleteCall \"findtypedeclaration\" (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let findDeclaration  file lin col filter = FSAutocompleteCall \"finddeclaration\"     (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let declarations    file code ver        = FSAutocompleteCall \"declarations\"       (function KDeclarations v -> Some v |_-> None)\n                                                                      <| FarDeclarations{ FileName       = file\n                                                                                          Lines          = code         \n                                                                                          Version        = ver\n                                                                                        }\n                    let helpText               symbol        = FSAutocompleteCall \"helptext\"            (function KHelpText     v -> Some v |_-> None)\n                                                                      <| FarHelptext    { Symbol         = symbol\n                                                                                        }\n                    let symbolUse       file lin col filter  = FSAutocompleteCall \"symboluse\"           (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let symbolUseProject file lin col filter = FSAutocompleteCall \"symboluseproject\"    (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    \n                    \n    \n    //#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FSharpStation\\src\"\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    \n    //#define WEBSHARPER\n    [< JavaScript >]\n    module FSharpStation =\n        //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        //#nowarn \"1178\" \"1182\" \"3180\" \"52\"\n        module FStation =\n        \n            let [< Rpc >] getRootDirs() = async {\n                //let res = let dir = System.Environment.CurrentDirectory\n                          //if dir.EndsWith @\"\\bin\" |> not then dir else\n                          //dir.[0..dir.Length - 5] |>! fun set -> System.Environment.CurrentDirectory <- set\n                let dir = System.Environment.CurrentDirectory\n                return dir, System.IO.Path.GetFullPath(dir +/+ \"..\"     ), System.IO.Path.GetFullPath(dir +/+ \"..\\\\src\")\n            }\n        \n            [< Inline \"(Date.now())\" >]\n            let now() = 0\n            let id = \"FSharpStation\" + (now() |> string)\n        \n            let mutable rootDir  = \".\"\n            let mutable srcDir   = \".\"\n            async {\n                let! dir, root, src = getRootDirs()\n                rootDir   <- root\n                srcDir    <- src\n                printfn \"fileName = %s\\\\%s.fsx\" srcDir id\n            } |> Async.Start\n            \n            let annotationsV = Var.Create \"\"\n            let outputMsgs   = Var.Create \"\"\n        \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let inline appendMsgs   msg = appendText outputMsgs msg\n        \n        \n        module Snippets =\n            open TreeReader\n            open FusionM\n            open Operators\n            open WebSharper.JavaScript\n            \n            let private snippets               = ListModel<SnippetId, Snippet> (fun s -> s.snpId)\n            let private hierarchy              = Var.Create [||]\n            let private generation             = Var.Create System.DateTime.MinValue\n            let         currentSnippetIdOV     = Var.Create (None:SnippetId option)\n            let private codeSnippetIdOV        = Var.Create (None:SnippetId option)\n            let private collapsedV             = Var.Create Set.empty\n            \n            let predsCache , clearPreds        = Memoize.getStore()\n            let reducCache , clearReduc        = Memoize.getStore()\n            let parentCache, clearParent       = Memoize.getStore()\n            let clearPredsCache ()             = clearPreds ()\n                                                 clearReduc ()\n                                                 clearParent()\n            let prepAnyCode       (cod:string) = cod.Replace(\"##\" + \"FSHARPSTATION_ID\"       + \"##\", FStation.id            )\n                                                    .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href)\n                                                    .Replace(\"##\" + \"FSHOME\"                 + \"##\" , FStation.rootDir)\n            let prepCode                   snp = prepAnyCode snp.snpContent                                         \n            let snippetsColl                () = { generation       = generation.Value\n                                                   ordered          = Seq.delay(fun () -> snippets.Value)\n                                                   fetcher          = snippets.TryFindByKey\n                                                   predecesorsCache = fun _ -> predsCache\n                                                   reducedCache     = fun _ -> reducCache\n                                                   prepCode         = prepCode\n                                                   }\n            let handleError                 er = (er:ResultMessage<string>) |> string |> exn |> raise\n            let iterReader                  rm = rm |> iterReader  handleError id (snippetsColl())\n            let runReaderResult             rm = rm |> runReader                  (snippetsColl()) |> Result.map fst\n            let runReader            handle rm = rm |> runReaderResult |> Result.defaultWith handle\n               \n            let expandParents            snpId = Snippet.pathRm snpId \n                                                 |>> (fun path -> collapsedV.Value - Set path |> collapsedV.Set)\n                                                 |> iterReader\n            \n            let setCurrentSnippetIdO snpIdO    = snpIdO |> Option.iter expandParents \n                                                 currentSnippetIdOV.Set snpIdO\n            let setSnippet                 snp = if snp.snpId.Id <> System.Guid.Empty then snippets.Add { snp with snpModified = System.DateTime.Now }\n            let getSnippetsGen              () = snippets.Value, generation.Value, collapsedV.Value\n        \n            let getParentIdONotMemo      snpId = snippets.TryFindByKey snpId |> Option.bind(fun s -> s.snpParentIdO)\n            let getParentIdO                   = getParentIdONotMemo |> Memoize.memoizeStore (snd parentCache) \n            let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                                 getParentIdO snpId\n                                                 |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                                 |> Option.defaultValue false\n        \n            if IsClient then\n                currentSnippetIdOV.View |> View.Sink (\n                    function\n                    | None       -> ()\n                    | Some curId ->\n                    match codeSnippetIdOV.Value with\n                    | None       -> codeSnippetIdOV.Set (Some curId)\n                    | Some codId ->\n                    codId\n                    |>  Snippet.snippetORm\n                    |>> Option.map Snippet.uniquePredsRm \n                    >>= insertO\n                    |>> Option.toList\n                    |>> List.collect  id\n                    |>> List.contains curId\n                    |>> function false -> codeSnippetIdOV.Set (Some curId) |_->()\n                    |>  iterReader\n                    clearPredsCache()\n                )\n        \n            if IsClient then\n                hierarchy.View |> View.Map (Array.map (fun n -> n.id()) ) |> View.consistent |> View.Sink (fun ids ->\n                    clearPredsCache()\n                    [| for sid in ids do\n                        yield  snippets.FindByKey sid\n                        yield! snippets.Value |> Seq.filter(fun snp -> isDescendantOf sid snp.snpId)\n                    |]\n                    |> snippets.Set\n                )\n        \n            let CurrentSnippetIdW              = currentSnippetIdOV.View |> View.Map  (fun sidO -> sidO |> Option.defaultValue Snippet.defaultSnippet.snpId)\n            let currentSnippetW                = currentSnippetIdOV.View |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let    codeSnippetW                =    codeSnippetIdOV.View |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let currentSnippetV                = Var.Make currentSnippetW setSnippet\n            let selectedClassW           snpId = V (if Some snpId = currentSnippetIdOV.V then \"selected\"    else \"\")\n            let codeSnippetClassW        snpId = V (if Some snpId =    codeSnippetIdOV.V then \"codeSnippet\" else \"\")\n            let findSnippetW             snpId = snippets.TryFindByKeyAsView snpId |> View.Map (Option.defaultValue Snippet.defaultSnippet)\n            let findSnippetV             snpId = Var.Make (findSnippetW snpId) setSnippet\n            let getHierarchyW                  = hierarchy.View \n                                                 |> View.Map2(fun _ -> TreeReader.listNodes 0 >> runReader  handleError) collapsedV.View\n                                                 |> View.Map (Seq.map (fun (tn,l) -> tn.id(), l) ) \n                                                 |> View.Map  Seq.toArray\n            //let codeAndStartsRm            snp =  >>= Snippet.codeAndStartsRm \n            let codeAndStartsW                 = (codeSnippetW, snippets.View) \n                                                 ||> View.MapAsync2 (fun _ _ -> async {\n                                                    do! Async.Sleep 350\n                                                    return\n                                                       Snippet.fastCodeRm currentSnippetIdOV.Value codeSnippetIdOV.Value\n                                                       |> runReader handleError\n                                                 }) \n            let FsCodeW                        = codeAndStartsW |> View.Map fst\n            let codeStartsW                    = codeAndStartsW |> View.Map snd\n            let hasChangedW                snp = V (generation.V < snp.snpModified )\n            let SaveAsClassW                   = View.Map2 (fun snps gen -> if Seq.exists (fun snp -> snp.snpModified > gen) snps then \"btn-primary\" else \"\") \n                                                    snippets  .View \n                                                    generation.View\n            let currentPathW                   = currentSnippetW\n                                                 |> View.Map (fun snp -> \n                                                        fusion { \n                                                            let! path  = Snippet.pathRm snp.snpId\n                                                            let! names = snp.snpId :: path |> traverseSeq Snippet.snippetNameRm\n                                                            return names |> Seq.rev |> String.concat \"/\"\n                                                        } |> runReader (fun _ -> \"\") )\n        \n            let currentLayoutDW                =  \n                currentSnippetW\n                |> View.Map (fun snp -> \n                    fusion {\n                        let! btnsO = Snippet.propertyHierORm \"Buttons\" snp\n                                        |>> Option.map(fun(snB, (txB, _)) ->\n                                        let ls, ats = txB.Trim().Split('\\n')\n                                                      |> fun ls ->  if ls.[0].StartsWith \"\\\"\"\n                                                                    then ls.[1..], ls.[0] \n                                                                    else ls      , \"\\\"\\\"\"\n                                        let ss      = ls\n                                                      |> Seq.filter(fun s -> s.Trim() <> \"\")\n                                                      |> Seq.mapi (fun i btn -> \n                                                            if btn.StartsWith \":\" \n                                                            then btn.[1..]\n                                                            else sprintf \"button \\\"click=@{FSharpStation.ButtonClick}\\\" %A\" btn\n                                                            |> sprintf \"btn%d %s\" i\n                                                        )\n                                        \"Snp_\" + (string snB.snpId.Id).Replace(\"-\", \"\")\n                                        , [ \n                                            yield! ss\n                                            yield [ 0.. Seq.length ss - 1 ] \n                                                    |> Seq.map (sprintf \"btn%d\") \n                                                    |> String.concat \" \" \n                                                    |> sprintf \"buttons div %s %s \" ats\n                                            yield \"editorButtons vertical 0-85-100 FStationLyt.menuEditor buttons\"\n                                        ] |> String.concat \"\\n\"\n                                    )\n                        return!      Snippet.propertyHierORm \"Layout\"  snp \n                                        |>> Option.map (fun (snL, (txL, _)) ->\n                                        \"Snp_\" + (string snL.snpId.Id).Replace(\"-\", \"\")\n                                        , btnsO |> Option.map (fun (snB, lyB) -> \n                                            [ txL ; lyB ] |> String.concat \"\\n\")\n                                        |> Option.defaultValue txL)\n                                        |>> Option.bindNone (fun () -> btnsO)\n                    } |> runReader (fun _ -> None)\n                ) \n            let currentLayoutJSDW                =  \n                currentSnippetW\n                |> View.Map (fun snp -> \n                    Snippet.propertyHierORm \"LayoutJS\"  snp \n                    |>> Option.map (fun (snL, (txL, _)) -> snL.snpId, txL)\n                    |> runReader (fun _ -> None)\n                )\n                                                    \n            let setChildrenRm snpId ch = fusion {\n                let chIds = ch |> Array.map (fun s -> s.id())\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n                |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n                |> Seq.iter    setSnippet\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n                |> Seq.map    (fun s -> { s with snpParentIdO = None })\n                |> Seq.iter    setSnippet\n                clearPredsCache()\n                let descendants, others = snippets.Value |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n                let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n                [| yield! others.[0..index]\n                   for chid in chIds do\n                       yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n                       yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n                   yield! others.[index+1..]\n                |]\n                |> snippets.Set\n            }\n        \n            let rec treenode (snpId:SnippetId) =\n                {\n                    id                 = fun () -> snpId\n                    isExpandedRm       = fun () -> rtn (not <| Set.contains snpId collapsedV.Value)\n                    canHaveChildrenRm  = fun () -> rtn true\n                    childrenRm         = fun () -> Snippet.childrenRm snpId |>> Seq.map (fun snp -> treenode snp.snpId)\n                    newChildrenRm      = fun ch -> setChildrenRm snpId ch   |>> fun () -> \n                                                   treenode      snpId\n                    parentORm          = fun _ns-> Snippet.snippetORm snpId |>> Option.bind (fun x -> x.snpParentIdO) |>> Option.map treenode\n                    pathRm             = fun () -> Snippet.pathRm snpId\n                }\n                \n            let isIndirectPredecessorW snpId = \n                currentSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let isIncludedPredecessorW snpId = \n                codeSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let togglePredecessor predId =\n                let preds = Lens currentSnippetV.V.snpPredIds\n                preds.Value\n                |> (if Set.contains predId preds.Value then Set.remove else Set.add) predId\n                |> preds.Set\n                clearPredsCache()\n                \n            let expandClassRm snpId =\n                Snippet.childrenRm snpId        >>= fun chs -> \n                if Seq.isEmpty chs then rtn \"\" else\n                (treenode snpId).isExpandedRm() |>> fun exp -> \n                if exp then \"expanded\" else \"collapsed\"\n            \n            let expandClassW snpId = snippets.View |> View.Map2 (fun _ _ -> expandClassRm snpId |> runReader handleError) collapsedV.View\n            \n            let deleteCurrentSnippet () =\n                currentSnippetIdOV.Value\n                |> Option.iter (fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.removeNodeOutdentChildren (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>> fun () -> snippets.RemoveByKey snpId\n                    |>  iterReader\n                )\n                \n            let indentIn () =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.indentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let indentOut () =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.outdentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let moveNode fnid tnid =\n                hierarchy.Value\n                |>  TreeReader.moveToSibling2 false fnid tnid\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let updateGeneration() =\n                fusion {\n                    let! max = Snippet.maxGenerationRm()\n                    generation.Set max\n                } |> iterReader\n        \n            let setSnippetsGen snps coll =\n                collapsedV.Set coll\n                snippets  .Set snps\n                updateGeneration()\n                snps \n                |>  Seq.map(fun snp -> Snippet.parentORm snp |>> function None -> Some snp |_-> None )\n                |>  sequenceSeq\n                |>> Seq.choose id\n                |>> Seq.map (fun snp -> treenode snp.snpId)\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let addSnippetRm snp = \n                snippets.Add snp\n                let hier = hierarchy.Value |> Seq.append [| treenode snp.snpId |]\n                currentSnippetIdOV.Value\n                |>  Option.map Snippet.snippetORm |> insertO |>> Option.bind id\n                >>= function\n                | None     -> hier |> rtn\n                | Some sbl -> hier |> TreeReader.moveToSibling2 true snp.snpId sbl.snpId\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                \n            let newSnippet () =\n                let snp = Snippet.New \"\" \"\" None\n                addSnippetRm snp\n                |>> fun () -> currentSnippetIdOV.Set (Some snp.snpId)\n                |>  iterReader\n                \n            let toggleCollapse snpId =\n                if Set.contains snpId collapsedV.Value then Set.remove else Set.add\n                <| snpId\n                <| collapsedV.Value\n                |> collapsedV.Set\n        \n            let setProperty snp prop v =\n                if Seq.contains (prop, v) snp.snpProperties then () else\n                { snp with snpProperties =  snp.snpProperties\n                                            |> Seq.filter(fst >> (<>) prop)\n                                            |> Seq.append <| [ prop, v ]\n                                            |> Seq.toArray\n                }\n                |> setSnippet\n        module DragDrop =\n        \n            type DragInfo = \n                | DragNone\n                | DragNode of SnippetId\n            \n            let mutable drag        = DragNone\n            let setDragNone ()      = drag <- DragNone\n            let setDragNode tnid    = drag <- DragNode tnid\n            \n            let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n            \n            let [< Inline >] inline moveItem dropId elems getId item =\n                elems\n                |> Seq.filter (getId >> ((<>) (getId item)) )\n                |> Seq.toArray\n                |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                             [fst ; [| item |] ; snd])\n                |> Seq.collect id\n                |> Seq.toArray\n            \n            let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n            let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n            \n            let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n            \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n        \n        module RenderSnippets =\n            open Snippets\n            open WebSharper.JavaScript\n            \n            let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then try e?scrollIntoViewIfNeeded() with e -> printfn \"%A\" e) \n            \n            let snippets () = \n                Snippets.getHierarchyW\n                |> Doc.BindSeqCached (fun (snpId, l) ->\n                    let snpW     = findSnippetW snpId\n                    let nameW    = View.Do {\n                                        let! snp     = snpW\n                                        let! changed = Snippets.hasChangedW snp\n                                        let  name    = Snippet.snippetName snp.snpName snp.snpContent\n                                        return (if changed then \"*\" else \"\") + name\n                                    }\n                    //let pathW = V( Snippets.getHierarchyW |> (fun _ -> (Snippets.treenode snpId).path () |> Seq.map (fun n -> string n.Id) |> String.concat \" - \") )\n                    let predW    = V(if currentSnippetV.V.snpPredIds |> Set.contains snpId then \"direct-predecessor\"   else\n                                     if (isIndirectPredecessorW snpId).V                   then \"indirect-predecessor\" else \n                                     if (isIncludedPredecessorW  snpId).V                  then \"included-predecessor\" else \"\" )\n                    let errorW   = FStation.annotationsV.View |> View.Map (String.contains <| snpId.Id.ToString() >> function true -> \"ErrorMsg\" |_-> \"\" )\n                    TemplateLib.Snippet()\n                        .Name(          nameW                                                                                        )\n                        .Indent(        string l                                                                                     )\n                        .Parent(        expandClassW snpId                                                                           )\n                        .Predecessor(   predW                                                                                        )\n                        .Selected(    [ (selectedClassW snpId).V ; (codeSnippetClassW snpId).V ] |> String.concat \" \"                )\n                        .ErrorMsg(      errorW                                                                                       )\n                        .Select(        fun _  -> setCurrentSnippetIdO <| Some snpId                                                 )\n                        .AfterRender(   scrollIntoView <| View.Map ((<>) \"\") (Snippets.selectedClassW snpId)                         )\n                        .TogglePred(    fun ev -> togglePredecessor snpId                                                            )\n                        .ToggleCollapse(fun ev -> Snippets.toggleCollapse snpId                                                      )\n                        .Drag(          fun ev ->     DragDrop.setDragNode snpId            ; ev.Event.StopPropagation()             )\n                        .DragOver(      fun ev -> if (DragDrop.getDragNIdO snpId).IsSome then ev.Event.PreventDefault ()             )\n                        .Drop(          fun ev -> do                                          ev.Event.PreventDefault () \n                                                  DragDrop.getDragNIdO snpId |> Option.iter(fun fr -> moveNode fr snpId)             )\n                      .Doc()\n                )\n            \n            let render() = TemplateLib.SnippetList().Snippets( snippets() ).Doc()\n        module RenderProperties =\n            open Snippets\n            \n            let addProperty () = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties \n                                                                                                       [| \"\",\"\" |]                                              }\n            let remProperty i = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties.[0  .. i-1] \n                                                                                                       Snippets.currentSnippetV.Value.snpProperties.[i+1..    ] }\n            let properties() =\n                let propsV = Lens Snippets.currentSnippetV.V.snpProperties\n                let setName  i newName = propsV.Value.[i] <- (newName, snd propsV.Value.[i]) \n                                         propsV.Value |> propsV.Set\n                let setValue i newVal  = if (snd propsV.Value.[i]).Length > 1000 then () else\n                                         propsV.Value.[i] <- (fst propsV.Value.[i], newVal) \n                                         propsV.Value |> propsV.Set\n                V([| 0.. propsV.V.Length - 1|])\n                |> Doc.BindSeqCached (fun i ->\n                    let nameV  = Var.Make <| V( fst propsV.V.[i])\n                                          <| setName  i\n                    let valueV = Var.Make <| V( let v = snd propsV.V.[i]\n                                                if v.Length > 1000 then sprintf \"%s...<%d chars>\" v.[0..100] v.Length else v)\n                                          <| setValue i\n                    TemplateLib.Property()\n                        .Name(   nameV                   )\n                        .Value(  valueV                  )\n                        .Remove( fun ev -> remProperty i )\n                      .Doc()\n                )\n        \n            let render() = \n                TemplateLib.PropertyTable()\n                    .Properties(  properties()           )\n                    .AddProperty( fun _ -> addProperty() )\n                    .Doc()    \n        [< JavaScript false >]\n        module Markdown =\n            open System.Text.RegularExpressions\n        \n            let private stringReplacePatterns =\n                [ \"&lt;\"      , \"<\"\n                  \"&gt;\"      , \">\"\n                  \"&quot;\"    , \"\\\"\"\n                  \"&apos;\"    , \"'\"\n                  \"&amp;\"     , \"&\"\n                  \"<summary>\" , \"**Description**\\n\\n\"\n                  \"</summary>\", \"\\n\"\n                  \"<para>\"    , \"\\n\"\n                  \"</para>\"   , \"\\n\"\n                  \"<remarks>\" , \"\"\n                  \"</remarks>\", \"\\n\" ]\n            let private regexReplacePatterns =\n                let r               pat = Regex(pat, RegexOptions.Compiled ||| RegexOptions.IgnoreCase)\n                let unquote  (s:string) = s.Substring(1, s.Length - 2)\n                let returns     strings = Array.item 0 strings |>                     sprintf \"\\n**Returns**\\n\\n%s\"\n                let param       strings = Array.item 0 strings |> unquote |> fun s -> sprintf \"* `%s`: %s\" s strings.[1]\n                let link        strings = Array.item 0 strings |> unquote\n                let code        strings = Array.item 0 strings |> fun s -> if String.contains \"\\n\" s then \"```forceNoHighlight\" + s + \"```\" else \"`\" + s + \"`\"\n                [ r \"<c>((?:(?!<c>)(?!<\\/c>)[\\s\\S])*)<\\/c>\"                                              , code\n                  r \"\"\"<see\\s+cref=(?:'[^']*'|\"[^\"]*\")>((?:(?!<\\/see>)[\\s\\S])*)<\\/see>\"\"\"                , code\n                  r \"\"\"<param\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/param>)[\\s\\S])*)<\\/param>\"\"\"            , param\n                  r \"\"\"<typeparam\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/typeparam>)[\\s\\S])*)<\\/typeparam>\"\"\", param\n                  r \"\"\"<exception\\s+cref=('[^']*'|\"[^\"]*\")>((?:(?!<\\/exception>)[\\s\\S])*)<\\/exception>\"\"\", param\n                  r \"\"\"<a\\s+href=('[^']*'|\"[^\"]*\")>((?:(?!<\\/a>)[\\s\\S])*)<\\/a>\"\"\"                        , link\n                  r \"\"\"<returns>((?:(?!<\\/returns>)[\\s\\S])*)<\\/returns>\"\"\"                               , returns\n                ] // \"\n        \n            /// Helpers to create a new section in the markdown comment\n            let private suffixXmlKey (tag : string) (value : string) (str : string) = \n                match str.IndexOf(tag) with\n                | x when x <> -1 -> let insertAt = if str.Chars(x - 1) = ' ' \n                                                   then x - 1\n                                                   else x\n                                    str.[0..insertAt] + value + str.[insertAt + 1..]\n                | _              -> str\n        \n            let private suffixTypeparam = suffixXmlKey \"<typeparam\" \"\\n**Type parameters**\\n\\n\"\n            let private suffixException = suffixXmlKey \"<exception\" \"\\n**Exceptions**\\n\\n\"\n            let private suffixParam = suffixXmlKey \"<param\" \"\\n**Parameters**\\n\\n\"\n        \n            /// Replaces XML tags with Markdown equivalents.\n            /// List of standard tags: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/xml-documentation\n            let private replaceXml (str: string) : string =\n                let str =\n                    str\n                    |> suffixTypeparam\n                    |> suffixException\n                    |> suffixParam\n        \n                let res = regexReplacePatterns\n                          |> List.fold (fun res (regex: Regex, formatter: string[] -> string) ->\n                              // repeat replacing with same pattern to handle nested tags, like `<c>..<c>..</c>..</c>`\n                              let rec loop res : string =\n                                  match regex.Match res with\n                                  | m when m.Success -> m.Groups\n                                                        |> Seq.cast<Group>\n                                                        |> Seq.map (fun g -> g.Value)\n                                                        |> Seq.toArray\n                                                        |> Array.splitAt 1\n                                                        |> function \n                                                           | [| firstGroup |], otherGroups -> loop <| res.Replace(firstGroup, formatter otherGroups)\n                                                           |                              _-> res\n                                  |                                                       _-> res\n                              loop res\n                          ) str\n                stringReplacePatterns\n                |> List.fold (fun (res: string) (oldValue, newValue) ->\n                    res.Replace(oldValue, newValue)\n                ) res\n        \n            [< Rpc >]\n            let createCommentBlock (comment: string) = async {\n                return\n                    comment\n                    |> replaceXml\n            }\n        module Monaco =\n            open WebSharper.UI\n            open WebSharper.UI.Html\n            open WebSharper.JavaScript\n            open FsAutoComplete\n            open Monaco\n            \n            let startsV  = Var.Create [||]\n            \n            let defaultStart = Option.defaultValue((SnippetId.Empty, \"\"), (0, 1, 0))\n            let getIndentAndFirst () =\n                let currId = Snippets.currentSnippetV.Value.snpId\n                let _, (indent, first, _) = startsV.Value |> Seq.tryFind (fst >> fst >> (=) currId) |> defaultStart\n                indent, first\n        \n            let getSnipIdIndentAndFirst line =\n                let (snpId, _), (indent, first, _) = startsV.Value |> Seq.tryFind (fun (_, (_, first, last)) -> line >= first && line <= last) |> defaultStart\n                snpId, indent, first\n        \n            let getModelUri txt uri =\n                let model = Editor.GetModel uri \n                            |> fun model -> if isUndefined model then None else Some model\n                            |> Option.defaultWith (fun () -> Editor.CreateModel(\"\", \"fsharp\", uri) )\n                if model.GetValue() <> txt then\n                    model.SetValue txt\n                model\n        \n            let getSnippetModel (sid:SnippetId) =\n                Uri.Parse(\"snpId:\" + sid.Id.ToString())\n                |> getModelUri (Snippet.snippetRm sid |> Snippets.runReader (string >> failwith)).snpContent\n        \n            let fixMarkDown v =\n                v\n                |> String.splitByChar '\\n'\n                |> Seq.map (fun l -> l.Replace(\"\\t\", \"- \"))\n                |> Seq.map (fun l -> let i = l |> Seq.takeWhile ((=) ' ') |> Seq.length\n                                     String.replicate i \"&nbsp;\" + l.[i..] )\n                |> String.concat \"\\n\\n\"\n                \n            let overDescriptions descs =\n                descs \n                |> Seq.collect id \n                |> Seq.collect (fun (d:CommTypes.OverloadDescription) ->\n                    [ if d.Signature |> isUndefined |> not then yield \"```\\n\" + d.Signature + \"\\n```\" |> Async.rtn\n                      if d.Comment   |> isUndefined |> not then yield Markdown.createCommentBlock d.Comment |> Async.map fixMarkDown\n                      if d.Footer    |> isUndefined |> not then yield d.Footer |> fixMarkDown |> Async.rtn] )\n                |> Async.sequenceSeq\n            \n            let mutable fileName = \"none.fsx\"\n        \n            type HoverProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideHover(model:Model, pos:Position, token:obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! descs, other = toolTip fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let! desc = overDescriptions descs \n                      return\n                          {\n                              contents = desc |> Seq.map (fun d -> { value = d |>! print ; isTrusted = true }) |> Seq.toArray\n                              range    = (box null |> unbox)\n                          }\n                    } |> Promise.ofAsyncResult\n        \n            let convertGlyphChar =\n                function\n                | \"C\" -> CompletionItemKind.Class\n                | \"E\" -> CompletionItemKind.Enum\n                | \"S\" -> CompletionItemKind.Value\n                | \"I\" -> CompletionItemKind.Interface\n                | \"N\" -> CompletionItemKind.Module\n                | \"M\" -> CompletionItemKind.Method\n                | \"P\" -> CompletionItemKind.Property\n                | \"F\" -> CompletionItemKind.Field\n                | \"T\" -> CompletionItemKind.Class\n                | \"K\" -> CompletionItemKind.Keyword\n                | _   -> 0 |> unbox\n        \n            type CompletionItemProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let txt = String.replicate indent \" \" + model.GetLineContent(pos.lineNumber)\n                      let! comps, other = completion txt true fileName (pos.lineNumber + first) (pos.column + indent) \"Contains\"\n                      return comps \n                             |> Array.map(fun (comp:CommTypes.CompletionResponse) -> \n                                 { kind   = convertGlyphChar comp.GlyphChar\n                                   label  = comp.Name\n                                   detail = \"\"\n                                 } )\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n                  member __.resolveCompletionItem(item: CompletionItem, token: obj) =\n                    asyncResult {\n                      let! comp, other = helpText item.label\n                      let  desc =  (comp:CommTypes.HelpTextResponse).Overloads \n                                   |> Seq.collect id\n                                   |> Seq.collect (fun d -> \n                                         [ if d.Signature |> isUndefined |> not then yield d.Signature\n                                           if d.Comment   |> isUndefined |> not then yield d.Comment\n                                           if d.Footer    |> isUndefined |> not then yield d.Footer ]\n                                   )\n                                   |> String.concat \"\\n\" \n                      return  { item with detail = desc}\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            type DefinitionProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideDefinition(model: Model, pos: Position, token: obj): Promise<Location> =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! decl, others = findDeclaration fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let  decl : CommTypes.Location = decl\n                      let snpId, indent2, first2 = getSnipIdIndentAndFirst decl.Line\n                      let uri           = Monaco.Uri.Parse <| \"snpId:\" + snpId.Id.ToString()\n                      getSnippetModel snpId |> ignore\n                      return \n                          { range = { startColumn     = decl.Column - indent2\n                                      endColumn       = decl.Column - indent2\n                                      startLineNumber = decl.Line   - first2\n                                      endLineNumber   = decl.Line   - first2\n                                    }\n                            uri   = uri\n                          }\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            let transformAnnotations snp msgs =\n                let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*\\(\"\"\" + rexGuid + \"\"\"\\) \"([^\"]+?)\"\\.\"\"\" //\"\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex \"\" [| _; ty;     fl;     fc;     tl;     tc; guid; msg |] \n                                -> Some (ty, int fl, int fc, int tl, int tc, guid, msg)\n                    | _      -> None\n                )\n                |> Array.choose (fun (ty, fl, fc, tl, tc, guid, msg) ->\n                    if ParseO.parseGuidO guid |> Option.map SnippetId <> Some snp.snpId then None else\n                        Some {  message  = msg\n                                severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                                startColumn     = fc\n                                endColumn       = tc\n                                startLineNumber = fl\n                                endLineNumber   = tl\n                        }\n                  )        \n                    \n            type MonacoOptions  = {\n                fontSize   : int\n                lineHeight : int\n            }\n            \n            let gotoEditor (ed:Editor) codeId line col = async {\n                Snippets.setCurrentSnippetIdO <| Some codeId\n                do! Async.Sleep 200\n                ed.Focus()\n                ed.SetPosition            { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n                ed?revealPositionInCenter { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n            }\n        \n            let openCodeEditor (input:obj, ed:Editor, sideBySide) =\n                async {\n                    match input?resource?path with\n                    | ParseO.Guid guid -> \n                         do! gotoEditor ed (SnippetId guid) input?options?selection?startLineNumber input?options?selection?startColumn\n                         return  ed  \n                    |_-> return (null |> unbox<Editor>)\n                } |> Promise.OfAsync\n        \n            [< Inline \"var m = require('vs/editor/standalone/browser/standaloneServices');\n                       var n = new m.StaticServices.codeEditorService._factory();\n                       n.openCodeEditor = FsRoot.FSharpStation.Monaco.openCodeEditor;\n                       return n;\" >]\n            let getCodeEditorServiceImpl () = X<_>\n                \n            type ITextModelService  = {\n                setEditor                        : Editor -> unit\n                //registerTextModelContentProvider : obj\n                createModelReference             : obj\n            }\n            \n            let textModelResolverService() =\n                let mutable editorO = None\n                {\n                    setEditor            = fun e   -> editorO <- Some e\n                    createModelReference = fun uri -> \n                        async {\n                            let model = getSnippetModel uri\n                            return Monaco.newImmortalReference(model)\n                        } |> Promise.OfAsync\n                }\n        \n            let monacoNew        (var           : Var<string>                         ) \n                                 (annotationsWO : View<MarkerData []>           option) \n                                 (showToolTipO  :(string -> int -> int -> unit) option) \n                                 (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                               -> string -> int -> int -> unit) option) =\n            \n                let setDirtyCond() = ()\n                let getHints    _  = ()\n        \n                async {\n                    return\n                        Monaco.newVar var\n                        |> fun config -> \n                            { config with   options   = \n                                                Pojo.newPojo [   \n                                                    \"fontSize\"   => 12\n                                                    \"lineHeight\" => 14 \n                                                ] \n                                        //overrides = 0 \n                                            overrides = \n                                                Pojo.newPojo [ \n                                                    \"codeEditorService\"        => getCodeEditorServiceImpl()\n                                                    \"textModelResolverService\" => textModelResolverService()\n                                                ]\n                            }\n                        |> onRender(fun ed -> \n                            Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                            Editor.SetTheme(\"vs\")\n                            //ed.UpdateOptions { fontSize   = 12 ; lineHeight = 14 }        \n                            let hp = new HoverProvider         (ed)\n                            let cp = new CompletionItemProvider(ed)\n                            let dp = new DefinitionProvider    (ed)\n                            hp.provideHover |> print\n                            cp.provideCompletionItems |> print\n                            cp.resolveCompletionItem  |> print\n                            dp.provideDefinition      |> print\n                            Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                            Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                            Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                            annotationsWO\n                            |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) )\n                        )\n                }\n        \n            let parse (code: string, starts: ((SnippetId * string) * (int * int * int)) []) =\n              asyncResult {\n                FStation.annotationsV.Value\n                |> String.skipFirstLine\n                |> (+) \"Parsing...\\n\"\n                |> FStation.annotationsV.Set\n                startsV.Set starts\n                let lines         = String.splitByChar '\\n' code\n                fileName         <- FsCode.getSourceDir FStation.srcDir lines +/+ FStation.id + \".fsx\"\n                let! errs, others = parseCode fileName lines true 0\n                (errs:CommTypes.ErrorResponse).Errors\n                |> Seq.map (fun v ->\n                   let (sid, name), (indent, first, _) = starts |> Seq.tryFind(fun (_, (indent, first, last)) -> v.StartLine > first && v.StartLine <= last) |> defaultStart\n                   sprintf \"%s (%d, %d) - (%d, %d) %s(%s) \\\"%s: %s\\\".\"\n                    <| match v.Severity with \"Error\" -> \"Err\" |_-> \"Warn\"\n                    <|  v.StartLine    - first\n                    <|  v.StartColumn  - indent\n                    <|  v.EndLine      - first\n                    <|  v.EndColumn    - indent\n                    <|    name\n                    <|    sid.Id.ToString()\n                    <|  v.Subcategory\n                    <|  v.Message\n                )\n                |> Seq.append [ \"Parsed!\" ]\n                |> String.concat \"\\n\"\n                |> FStation.annotationsV.Set\n                others |> Seq.iter print \n                ()\n              } |> AsyncResult.iterA print print\n        \n            let mutable editorConfigO : MonacoConfig option = None\n            \n            let editorDoc() = \n                async {\n                    do! Monaco.loader\n                    let! cfg = monacoNew <| Lens Snippets.currentSnippetV.V.snpContent\n                            <| Some ( (Snippets.currentSnippetW, FStation.annotationsV.View) ||> View.Map2 transformAnnotations )\n                            <| None\n                            <| None\n                    editorConfigO <- Some cfg\n                    return Monaco.render  cfg\n                } |> Doc.Async\n                \n         \n            if IsClient then\n                Snippets.CurrentSnippetIdW |> View.Sink(fun sid ->\n                    try\n                        editorConfigO\n                        |> Option.bind(fun config -> config.editorO                         )\n                        |> Option.iter(fun editor -> getSnippetModel sid |> editor.SetModel \n                                                     FStation.annotationsV.Set FStation.annotationsV.Value\n                        )\n                    with _ -> ()\n                )\n        \n            let goto codeId line col = async {\n                match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n                | Some ed -> do! gotoEditor ed codeId line col\n                | _       -> ()\n            }\n        \n            let getSelection () =\n                match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n                | Some ed -> ed.GetSelection() |> ed.GetModel().GetValueInRange\n                | _       -> \"\"\n               \n        \n        \n        module JumpTo =\n            open WebSharper.JavaScript\n        \n            let rexGuid = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let jumpToLine = \n                function\n                | REGEX rexGuid \"\" [| _ ; line ; col ; _ ; _ ; guid |] -> Monaco.goto <| SnippetId (System.Guid guid) <| int line <| int col \n                                                                          |> Async.Start\n                | _                                                    -> ()\n                \n            let jumpToRef (e:Dom.Element) =\n                let v : string = e?value |> unbox\n                let s : int    = e?selectionStart |> unbox\n                let lines = v.Split '\\n'\n                lines \n                |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n                |> fst\n                |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n                |> jumpToLine        \n        module CustomAction =\n            open WebSharper.JavaScript\n            open FusionAsyncM\n            open Operators\n            open FStation\n        \n            let propO snp p = snp |> Snippet.propertyHierORm p |> ofFusionM |>> Option.map (function (_, (v, _)) -> v)\n        //    let [< Inline \"Object.constructor('return function(button) { return `' + $template + '`}')()($p)\" >] translateTemplate (template: string) p = \"\"\n        \n            let translateString f (code: string) =\n                let rec translate acc (s: string) =\n                    String.delimitedO \"${\" \"}\" s\n                    |> function\n                    | None -> acc + s\n                    | Some (bef, var, aft) ->\n                    translate (acc + bef) (f var + aft)\n                translate \"\" code\n        \n            let getBaseSnippet() = fusion {\n                let     snp     = Snippets.currentSnippetV.Value\n                let!    snpRefO = propO snp \"BaseSnippet\"\n                return! snpRefO\n                        |>  Option.map(fun ref -> \n                                SnippetReference.RefSnippetPath (ref.Split '/') \n                                |> Snippet.snippetFromRefORm\n                                |> ofFusionM)\n                        |>  insertO\n                        |>> Option.flatten\n                        |>> Option.defaultValue snp\n            }\n        \n            let codeModule snp code = fusion {\n                let! openPropO = propO snp \"Open\"\n                match openPropO with\n                | None    -> return code\n                | Some op ->\n                return\n                    op  + \"\\n\" + code \n                    |> String.indentStr 4 \n                    |> sprintf \"module Call%s =\\n%s\" (string <| FStation.now())\n            }\n        \n            let getCode snp name = fusion {\n                let! code        = fusion {\n                    let!  namecodeO = propO snp name\n                    match namecodeO with\n                    | Some code -> return code\n                    | None      ->\n                    if name.StartsWith \":\" then return name.[1..] else \n                    let!   template  = propO snp \"action-template\"\n                    return template |> Option.defaultValue \"${button}() |> printfn \\\"%A\\\"\"\n                }\n                let! code2 = codeModule snp code\n                return Snippets.prepAnyCode code2\n            }\n        \n            module AF = AppFramework // FsRootDll.LibraryJS.AppFramework\n        \n            let fetchValue button v =\n                if v = \"button\" then button else\n                \"Snp_\" + (string Snippets.currentSnippetV.Value.snpId.Id).Replace(\"-\", \"\")\n                |> AF.PlugInName\n                |> swap AF.splitName v\n                ||> AF.tryGetWoW\n                |> Option.bind View.TryGet\n                |> Option.defaultWith (fun () -> sprintf \"$[not found:%s]\" v)\n        \n            let actionClickRm name = fusion {\n                outputMsgs.Set  <| sprintf \"Action %s ...\" name\n                let! snp         = getBaseSnippet()\n                let! code        = getCode snp name |>> translateString (fetchValue name)\n                do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                let! preCode     = Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst\n                let! gen         = ofFusionM <| Snippet.predsGenerationRm snp\n                return! ofAsync <| FsiAgent.evalCodeWithPresence FStation.srcDir (sprintf \"%A\" snp.snpId) (string gen) (FsCode preCode) (FsCode code)\n            }\n        \n            let setSnippetContent (snpPath:string) content     = \n                fusion {\n                    let!  snpO  = snpPath.Split '/' |> SnippetReference.RefSnippetPath |> Snippet.snippetFromRefORm |> ofFusionM\n                    match snpO with\n                    | None     -> return! ofResultRM <| Result.Error (ErrorMsg (sprintf \"Snippet %s not found\" snpPath) )\n                    | Some snp ->\n                    { snp with snpContent = content }\n                    |> Snippets.setSnippet\n                } |> iterReaderA  print print (Snippets.snippetsColl())\n        \n        \n            let actionSnpRm (snpPath:string) name = fusion {\n                let! snpO        = snpPath.Split '/' |> SnippetReference.RefSnippetPath |> Snippet.snippetFromRefORm |> ofFusionM\n                match snpO with\n                | None     -> return! ofResultRM <| Result.Error (ErrorMsg (sprintf \"Snippet %s not found\" snpPath) )\n                | Some snp ->\n                let! code        = getCode snp name |>> translateString (fetchValue name)\n                do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                let! preCode     = Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst\n                let! gen         = ofFusionM <| Snippet.predsGenerationRm snp\n                return! ofAsync <| FsiAgent.evalCodeWithPresence FStation.srcDir (sprintf \"%A\" snp.snpId) (string gen) (FsCode preCode) (FsCode code)\n            }\n            \n            let actionSnp  path name        = actionSnpRm    path  name              |> iterReaderA  print print (Snippets.snippetsColl())\n            let actionClick name            = actionClickRm        name              |> iterReaderA  print print (Snippets.snippetsColl())\n            let buttonClick (e:Dom.Element) = e.TextContent.Trim()                   |> actionClick\n            let getCurrentProperty        p = propO Snippets.currentSnippetV.Value p |> runReader                (Snippets.snippetsColl()) \n                                                                                     |> AsyncResult.map fst\n                                                                                     |> AsyncResult.absorbO (fun () -> errorMsgf \"Property %s not found\" p)\n            let setCurrentProperty      p v = Snippets.setProperty Snippets.currentSnippetV.Value p v\n            let scrollToBottom (el:Dom.Element) = \n                async { \n                    do! Async.Sleep 100\n                    do  el.ScrollTop <- el.ScrollHeight\n                } |> Async.Start\n        \n            let setScrollToBottom =\n                let mutable elO :Dom.Element option = None\n                outputMsgs.View |> View.Sink(fun _s -> elO |> Option.iter scrollToBottom )\n                fun (el:Dom.Element) -> elO <- Some el ; printfn \"setScrollToBottom\"\n        \n        module Serializer =\n            open Serializer\n        \n            let serSnippetId      = serId (fun (SnippetId      v) -> v) SnippetId      (sprintf \"%A\")     \n        \n            let serSnippet   : Ser<Snippet  > = \n                [|\n                    serSnippetId                                         |> serField  \"snpId\"         (fun s -> s.snpId        ) (fun v  s -> { s with snpId         = v } )\n                    serString                                            |> serField  \"snpName\"       (fun s -> s.snpName      ) (fun v  s -> { s with snpName       = v } )\n                    serString                                            |> serField  \"snpContent\"    (fun s -> s.snpContent   ) (fun v  s -> { s with snpContent    = v } )\n                    serSnippetId                     |> serOpt           |> serField  \"snpParentIdO\"  (fun s -> s.snpParentIdO ) (fun v  s -> { s with snpParentIdO  = v } )\n                    serSnippetId                     |> serSet           |> serField  \"snpPredIds\"    (fun s -> s.snpPredIds   ) (fun v  s -> { s with snpPredIds    = v } )\n                    serString              |> serDup serString |> serArr |> serField  \"snpProperties\" (fun s -> s.snpProperties) (fun v  s -> { s with snpProperties = v } )\n                    serInt                                               |> serFieldO \"snpGeneration\" (fun s -> None           ) (fun vO s -> match vO with None->s |  Some v -> { s with snpModified = Utc1970_01_01.AddHours (float v) } )\n                    serDate                                              |> serField  \"snpModified\"   (fun s -> s.snpModified  ) (fun v  s -> { s with snpModified   = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            type Model = {\n                snippets   : Snippet []\n                modified   : System.DateTime\n                collapsed  : SnippetId Set\n            }\n        \n            let getModel(snippets, gen, coll) =  { snippets = snippets |> Seq.toArray ;  modified = gen ; collapsed = coll}\n        \n            let serModel : Ser<Model> =\n                [|\n                    serSnippet                       |> serArr           |> serField  \"snippets\"   (fun m -> m.snippets  ) (fun v  m -> { m with snippets   = v } )\n                    serInt                                               |> serFieldO \"generation\" (fun m -> None        ) (fun vO m -> match vO with None -> m | Some v -> { m with modified = Utc1970_01_01.AddHours (float v) } )\n                    serDate                                              |> serField  \"modified\"   (fun m -> m.modified  ) (fun v  m -> { m with modified   = v } )\n                    serSnippetId                     |> serSet           |> serField  \"collapsed\"  (fun m -> m.collapsed ) (fun v  m -> { m with collapsed  = v } )\n                |] |> serRecord { snippets = [||] ; modified = Utc1970_01_01 ; collapsed = Set.empty}\n                \n        \n        module LoadSave =\n            open WebSharper.JavaScript\n        \n            let fileName  = Var.Create \"\"\n            let canLoad() = Snippets.SaveAsClassW |> View.TryGet = Some \"\" || JS.Confirm \"Changes have not been saved, do you really want to load?\"\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd Serializer.serModel \n                          |> fun mdl -> Snippets.setSnippetsGen mdl.snippets mdl.collapsed\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let loadTextFile element  =\n                if canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            fileName.Set files.[0].Name\n                            files.[0] |> reader.ReadAsText\n        \n            [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n            let saveAsJavaScript (_name:string) (_txt:string) = ()\n        \n            let saveAs() = \n                let name = match fileName.Value.Split [| '/' ; '\\\\' |] |> Seq.last with \n                           | \"\"    -> \"noname.snippets\" \n                           | fname -> fname\n                Snippets.getSnippetsGen()\n                |> Serializer.getModel\n                |> fst Serializer.serModel\n                |> saveAsJavaScript name\n                Snippets.updateGeneration()\n        \n        module Importer =\n            open WebSharper.JavaScript\n            open Serializer\n        \n            let serSnippetId2 : Ser<SnippetId> = sprintU, fun (x: obj) -> x?Item |> deserGuid |> SnippetId\n        \n            let serSnippet2   : Ser<Snippet  > = \n                [|\n                    serSnippetId2                                        |> serField \"id\"           (fun s -> s.snpId                     ) (fun v s -> { s with snpId         = if v = SnippetId.Empty then SnippetId <| System.Guid.NewGuid() else v } )\n                    serString                                            |> serField \"name\"         (fun s -> s.snpName                   ) (fun v s -> { s with snpName       = v } )\n                    serString                                            |> serField \"content\"      (fun s -> s.snpContent                ) (fun v s -> { s with snpContent    = v } )\n                    serSnippetId2                    |> serOpt           |> serField \"parent\"       (fun s -> s.snpParentIdO              ) (fun v s -> { s with snpParentIdO  = if v = Some SnippetId.Empty then None else v } )\n                    serSnippetId2                    |> serArr           |> serField \"predecessors\" (fun s -> s.snpPredIds |> Seq.toArray ) (fun v s -> { s with snpPredIds    = Set v } )\n                    //serString                        |> serMap serString |> serField \"properties\"   (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            let serSnippets = serSnippet2 |> serArr\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd serSnippets\n                          |> fun snps -> Snippets.setSnippetsGen snps Set.empty\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let importFile element  =\n                if LoadSave.canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            files.[0] |> reader.ReadAsText\n        \n        module MainProgram =\n            open WebSharper.JavaScript\n            open WebComponent\n            open FusionAsyncM\n            open Operators\n            open FStation\n        \n            type EndPoint =\n            |                   Snippet   of System.Guid\n            | [< Wildcard    >] Path      of string[]\n            | [< EndPoint \"\" >] NoSnippet\n        \n            open Sitelets.InferRouter\n            let endPointV = if IsClient then Router.Infer() |> Router.InstallHash NoSnippet else Var.Create NoSnippet\n        \n            if IsClient then\n                endPointV.View |> View.Sink (\n                    function\n                    | NoSnippet      -> View.rtn None\n                    | Snippet guid   -> View.rtn (SnippetId guid |> Some)\n                    | Path    pth    -> Snippets.currentPathW \n                                        |> View.Map (fun p -> \n                                            if p = String.concat \"/\" pth then Snippets.currentSnippetIdOV.Value else\n                                            Snippet.snippetFromPathORm pth\n                                            |> FusionM.map (Option.map (fun s -> s.snpId))\n                                            |> Snippets.runReader Snippets.handleError\n                                        )\n                    >> View.Get (fun sidO -> \n                       if  Snippets.currentSnippetIdOV.Value <> sidO then\n                           Snippets.setCurrentSnippetIdO sidO\n                   ))\n        \n                Snippets.currentSnippetIdOV.View |> View.Sink (\n                    function\n                    | None                 -> View.rtn NoSnippet\n                    | Some(SnippetId guid) -> Snippets.currentPathW\n                                              |> View.Map (fun p ->\n                                                if Path (p.Split '/') = endPointV.Value then endPointV.Value else\n                                                Snippet guid\n                                              )\n                    >> View.Get (fun ep -> \n                       if  endPointV.Value <> ep then\n                           endPointV.Value <- ep\n                   ))\n        \n            let runFsCode () = \n                let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n                Snippets.FsCodeW \n                |> View.TryGet \n                |> Option.iter (fun code ->\n                    fusion {\n                        outputMsgs.Set \"Running F#...\"\n                        do!     ofAsync <| FSharpStationClient.setAddress (WebSockets.Address FStation.id)\n                        return! ofAsync <| FsiAgent.evalCode FStation.srcDir (FsCode code)\n                    } |> iterResultA (sprintf \"Error:\\n%A\" >> out) ignore\n                )\n        \n            let selectionToFsi () = \n                let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n                fusion {\n                    do! FSharpStationClient.setAddress (WebSockets.Address FStation.id)  |> ofAsync\n                    do! Monaco.getSelection() |> fun s -> s + \";;\" |> FsiAgent.sendFsiInput |> ofAsync \n                } |> iterResultA (sprintf \"Error:\\n%A\" >> out) ignore\n        \n            let deleteSnippet() =\n                let snp = Snippets.currentSnippetV.Value\n                if  snp.snpId <> SnippetId.Empty \n                && JS.Confirm (sprintf \"Do you want to delete %s?\" <| Snippet.snippetName snp.snpName snp.snpContent) then \n                    Snippets.deleteCurrentSnippet()\n        \n            module AF = AppFramework // FsRootDll.LibraryJS.AppFramework\n            module LE = LayoutEngine // FsRootDll.LibraryJS.LayoutEngine\n        \n            let FStationLyt = AF.PlugInName \"FStationLyt\"\n        \n            let hookVar plug name func obj =\n                AF.tryGetVar (AF.PlugInName plug) (AF.PlgElemName name)\n                |> Option.map        (fun var -> printfn \"Var    %s.%s hooked\"    plug name ;  func obj var.varVar                  )\n                |> Option.defaultWith(fun ()  -> printfn \"Var    %s.%s not found\" plug name ;       obj                             )\n        \n            let hookViw plug name func obj =\n                AF.tryGetViw (AF.PlugInName plug) (AF.PlgElemName name)\n                |> Option.map        (fun viw -> printfn \"View   %s.%s hooked\"    plug name ;  func obj viw.viwView                 )\n                |> Option.defaultWith(fun ()  -> printfn \"View   %s.%s not found\" plug name ;       obj                             )\n        \n            let hookAct plug name func obj =\n                AF.tryGetAct (AF.PlugInName plug) (AF.PlgElemName name)\n                |> Option.map        (fun act -> printfn \"Action %s.%s hooked\"    plug name ;  func obj (fun _-> act.actFunction |> AF.callFunction () () ) )\n                |> Option.defaultWith(fun ()  -> printfn \"Action %s.%s not found\" plug name ;       obj                             )\n        \n            let hookDoc plug name func obj =\n                AF.tryGetDoc (AF.PlugInName plug) (AF.PlgElemName name)\n                |> Option.map        (fun doc -> printfn \"Doc    %s.%s hooked\"    plug name ;  func obj (AF.mainDocV.View |> View.Map (fun _ -> AF.getActualDoc doc) |> Doc.EmbedView) )\n                |> Option.defaultWith(fun ()  -> printfn \"Doc    %s.%s not found\" plug name ;       obj                             )\n        \n            let buttonsRight() =\n                TemplateLib.ButtonsRight()\n                |> hookAct \"FSharpStation\" \"AddSnippet\"    (fun tmp    -> tmp.AddSnippet                  )\n                |> hookAct \"FSharpStation\" \"RemoveSnippet\" (fun tmp    -> tmp.RemoveSnippet               )\n                |> hookAct \"FSharpStation\" \"IndentIn\"      (fun tmp    -> tmp.IndentIn                    )\n                |> hookAct \"FSharpStation\" \"IndentOut\"     (fun tmp    -> tmp.IndentOut                   )\n                |> hookAct \"FSharpStation\" \"RunFS\"         (fun tmp    -> tmp.RunFS                       )\n                |> (fun tmp -> tmp.Doc())\n        \n            if IsClient then\n                Snippets.codeAndStartsW |> View.Sink (delayed 300 Monaco.parse)\n        \n                View.Sink (fun m -> \n                    JS.Window.Onbeforeunload <- \n                        if m <> \"\" then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n                        else null\n                ) Snippets.SaveAsClassW \n        \n            let mainDoc() =\n                TemplateLib.Layout()\n                    .LoadFileChanged(  fun ev -> LoadSave.loadTextFile ev.Target                  )\n                    .LoadFileClear(    fun ev -> ev.Target?value <- \"\"                            )\n                    .ImportFileChanged(fun ev -> Importer.importFile ev.Target                    )\n                    .ImportFileClear(  fun ev -> ev.Target?value <- \"\"                            )\n                    .JumpRef(          fun ev -> JumpTo.jumpToRef ev.Target                       )\n                    //.OutputAfterRender(fun ev -> outputMsgs.View |> View.Sink (scrollToBottom ev) )\n                    //|> hookVar \"FSharpStation\" \"Content\"     (fun tmp -> tmp.Content     )\n                    |> hookVar \"FSharpStation\" \"fileName\"      (fun tmp    -> tmp.Filename                    )\n                    |> hookVar \"FSharpStation\" \"SnippetName\"   (fun tmp    -> tmp.Name                        )\n                    |> hookVar \"FSharpStation\" \"Output\"        (fun tmp    -> tmp.Output                      )\n                    |> hookVar \"FSharpStation\" \"Parser\"        (fun tmp    -> tmp.Parser                      )\n                    |> hookViw \"FSharpStation\" \"FSCode\"        (fun tmp vw -> tmp.FSCode (Var.Make vw ignore) )\n                    |> hookViw \"FSharpStation\" \"SaveNeeded\"    (fun tmp    -> tmp.SaveAsClass                 )\n                    |> hookAct \"FSharpStation\" \"SaveAs\"        (fun tmp    -> tmp.SaveAs                      )\n                    |> hookDoc \"FSharpStation\" \"editor\"        (fun tmp    -> tmp.CodeEditor                  )\n                    |> hookDoc \"FSharpStation\" \"Snippets\"      (fun tmp    -> tmp.Snippets                    )            \n                    |> hookDoc \"FSharpStation\" \"Properties\"    (fun tmp    -> tmp.Properties                  )            \n                    |> hookDoc \"FSharpStation\" \"ButtonsRight\"  (fun tmp    -> tmp.ButtonsRight                )            \n                    |> (fun tmp -> tmp.Doc())\n        \n            let snippetNameV = Lens Snippets.currentSnippetV.V.snpName\n            let contentV     = Lens Snippets.currentSnippetV.V.snpContent\n        \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.addPlugIn {\n                    AF.plgName    = AF.PlugInName \"FSharpStation\"\n                    AF.plgVars    = [| AF.newVar  (AF.PlgElemName \"fileName\"          ) LoadSave.fileName\n                                       AF.newVar  (AF.PlgElemName \"SnippetName\"       ) snippetNameV\n                                       AF.newVar  (AF.PlgElemName \"Content\"           ) contentV    \n                                       AF.newVar  (AF.PlgElemName \"Output\"            ) outputMsgs\n                                       AF.newVar  (AF.PlgElemName \"Parser\"            ) FStation.annotationsV\n                                    |] |> ListModel.Create (fun v -> v.varName)\n                    AF.plgViews   = [| AF.newViw  (AF.PlgElemName \"FsCode\"            ) Snippets.FsCodeW\n                                       AF.newViw  (AF.PlgElemName \"SaveNeeded\"        ) Snippets.SaveAsClassW\n                                       AF.newViw  (AF.PlgElemName \"CurrentPath\"       ) Snippets.currentPathW\n                                       AF.newViw  (AF.PlgElemName \"FStationId\"        ) (View.Const FStation.id)\n                                       AF.newViw  (AF.PlgElemName \"CurrentSid\"        ) (Snippets.CurrentSnippetIdW |> View.Map (fun sid -> sid.Id |> string))\n                                    |] |> ListModel.Create (fun w -> w.viwName)\n                    AF.plgDocs    = [| AF.newDoc  (AF.PlgElemName \"mainDoc\"           ) (lazy mainDoc()                 )\n                                       AF.newDoc  (AF.PlgElemName \"editor\"            ) (lazy (WebSharper.UI.Html.div [] [ Monaco.editorDoc() ]) )\n                                       AF.newDoc  (AF.PlgElemName \"Snippets\"          ) (lazy RenderSnippets  .render() )\n                                       AF.newDoc  (AF.PlgElemName \"Properties\"        ) (lazy RenderProperties.render() )\n                                       AF.newDoc  (AF.PlgElemName \"ButtonsRight\"      ) (lazy buttonsRight           () )\n                                    |] |> ListModel.Create (fun w -> w.docName)\n                    AF.plgActions = [| AF.newAct  (AF.PlgElemName \"AddSnippet\"        ) Snippets.newSnippet\n                                       AF.newAct  (AF.PlgElemName \"RemoveSnippet\"     ) deleteSnippet       \n                                       AF.newAct  (AF.PlgElemName \"IndentIn\"          ) Snippets.indentIn       \n                                       AF.newAct  (AF.PlgElemName \"IndentOut\"         ) Snippets.indentOut\n                                       AF.newAct  (AF.PlgElemName \"AddProperty\"       ) RenderProperties.addProperty\n                                       AF.newAct  (AF.PlgElemName \"SaveAs\"            ) LoadSave.saveAs\n                                       AF.newAct  (AF.PlgElemName \"RunFS\"             ) runFsCode\n                                       AF.newAct  (AF.PlgElemName \"SelectionToFsi\"    ) selectionToFsi\n                                       AF.newAct  (AF.PlgElemName \"AbortFsi\"          ) FsiAgent.abortFsiExe\n                                       AF.newAct  (AF.PlgElemName \"DisposeFsi\"        ) FsiAgent.disposeFsiExe\n                                       AF.newActF (AF.PlgElemName \"LoadFile\"          ) <| AF.FunAct1 ((fun o     -> unbox o  |> LoadSave.loadTextFile              ), \"FileElement\")\n                                       AF.newActF (AF.PlgElemName \"Import\"            ) <| AF.FunAct1 ((fun o     -> unbox o  |> Importer.importFile                ), \"FileElement\")\n                                       AF.newActF (AF.PlgElemName \"JumpTo\"            ) <| AF.FunAct1 ((fun o     -> unbox o  |> JumpTo.jumpToRef                   ), \"textarea\"   )\n                                       AF.newActF (AF.PlgElemName \"ButtonClick\"       ) <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.buttonClick           ), \"button\"     )\n                                       AF.newActF (AF.PlgElemName \"ActionClick\"       ) <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.actionClick           ), \"name\"       )\n                                       AF.newActF (AF.PlgElemName \"SetScrollToBottom\" ) <| AF.FunAct1 ((fun o     -> unbox o  |> CustomAction.setScrollToBottom     ), \"textarea\"   )\n                                       AF.newActF (AF.PlgElemName \"ActionSnp\"         ) <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.actionSnp (unbox o1)  ), \"snpPath\", \"name\" )\n                                       AF.newActF (AF.PlgElemName \"setCurrentProperty\") <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.setCurrentProperty (unbox o1)  ), \"name\", \"value\" )\n                                       AF.newActF (AF.PlgElemName \"setSnippetContent\" ) <| AF.FunAct2 ((fun o1 o2 -> unbox o2 |> CustomAction.setSnippetContent  (unbox o1)  ), \"path\", \"value\" )\n                                    |] |> ListModel.Create (fun w -> w.actName)\n                    AF.plgQueries = [| AF.newQry  (AF.PlgElemName \"PropertyRA\"        ) <| (fun p -> unbox<string> p |> CustomAction.getCurrentProperty |> box)\n                                    |] |> ListModel.Create (fun w -> w.qryName)\n                }\n        \n                match JS.Document.GetElementById(\"GlobalLayout\") with\n                | null ->\n                  \"\"\"\n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -120 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS btnInputFsi btnAbortFsi\n                    snippetsSnippet  vertical   0-20-100  snippets                  editorProperties\n                    snippets         horizontal 20        \"${FSharpStation.CurrentPath}\" FSharpStation.Snippets\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n        \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddSnippet    button FSharpStation.AddSnippet     \"\"                  \"Add Snippet   \"\n                    btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                    btnInputFsi      button FSharpStation.selectionToFsi   \"\"                  \"selection |> Fsi\"\n                    btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n        \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n        \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                  \"\"\"\n                | e -> e.TextContent\n                |> LE.newLyt FStationLyt\n                |> NewLY.addNewLayout   // LE.addLayout\n        \n                Snippets.currentLayoutJSDW\n                |> View.consistent\n                |> View.Sink(fun lytO ->\n                    lytO\n                    |> Option.iter (fun (sid, js) ->\n                        try\n                            JavaScript.JS.Apply JavaScript.JS.Window \"eval\" [| \"CIPHERSpaceLoadFilesDoAfter(function(){IntelliFactory.Runtime.Start()})\" |]\n                            JavaScript.JS.Apply JavaScript.JS.Window \"eval\" [| js                                                          |]\n                        with e -> print e\n                    )\n                )\n        \n                Snippets.currentLayoutDW\n                |> View.consistent\n                |> View.Sink(fun lytO ->\n                    lytO\n                    |> Option.bind (fun (name, txt) ->\n                        txt \n                        |> LE.newLyt    (AF.PlugInName name)\n                        |> NewLY.addNewLayout  //|> LE.addLayout \n                        if txt = \"\" then None else \n                        Some name\n                    )\n                    |> Option.defaultValue FStationLyt.Id\n                    |> AF.mainDocV.Set\n                )\n        \n                Snippets.currentPathW\n                |> View.Sink (fun v -> \n                    async {\n                        do! Async.Sleep 500\n                        JS.Window.Document.Title <- v \n                    } |> Async.Start\n                )        \n        \n                //async {\n                //  do! Monaco.loader\n                //  //WcSplitter.init horizontal vertical\n                //  //WcTabStrip.init()\n                //  let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n        \n                //} |> Doc.Async\n                TemplateLib()\n                    .MainContent( AF.getMainDoc.Value )\n                    .Bind()\n        \n        \n        //#define FSS_SERVER\n        module Messaging =\n            open WebSharper.JavaScript \n            open FStation\n            open FusionAsyncM\n            open Operators\n            open MainProgram\n        \n            module AF = AppFramework // FsRootDll.LibraryJS.AppFramework \n            module Fusion = FusionAsyncM\n        \n            let wsStationClient = if IsClient then new WebSockets.WSMessagingClient(FStation.id) else new WebSockets.WSMessagingClient(\"FStation.id\", WebSockets.FSStation)\n        \n            let actionCall actN p1 p2 = fusion {\n                match actN |> AF.splitName FStationLyt ||> AF.tryGetAct with\n                | None     -> return! ofResultRM <| Result.Error (ErrorMsg (sprintf \"Action %s not found\" actN) )\n                | Some act -> AF.callFunction p1 p2 act.actFunction\n                              return FSResponse.RespString \"Ok\"\n            }\n        \n            let getValue vname = fusion {\n                match vname |> AF.splitName FStationLyt ||> AF.tryGetWoW with\n                | None     -> return! ofResultRM <| Result.Error (ErrorMsg (sprintf \"Var or View %s not found\" vname) )\n                | Some  vw -> let! v = vw |> View.GetAsync |> ofAsync\n                              return FSResponse.RespString v\n            }\n        \n            let setValue vname v = fusion {\n                match vname |> AF.splitName FStationLyt ||> AF.tryGetVar with\n                | None     -> return! ofResultRM <| Result.Error (ErrorMsg (sprintf \"Var %s not found\" vname) )\n                | Some var -> var.varVar.Set v\n                              return FSResponse.RespString \"Ok\"\n            }\n        \n            let processMessage (msg: FSMessage) : Async<Result<FSResponse,ResultMessage<string>>>= \n                fusion {\n                    match msg with\n                    | MsgGetId                          -> return  RespString FStation.id\n                    | MsgGetSnippets               snrs -> let!    snps = snrs |> Fusion.traverseSeq (Snippet.snippetFromRefORm >> ofFusionM)\n                                                           return  snps |> Seq.choose id |> Seq.toArray |> RespSnippets\n                    | MsgGetCode                   snr  -> Snippets.clearPredsCache ()\n                                                           let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           return! Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |> ofFusionM |>> fst |>> RespString\n                    | MsgGetModified               snr  -> let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           let!    ids  = Snippet.predsLRm snp.snpId |> ofFusionM\n                                                           let!    prds = ids |> Fusion.traverseSeq (Snippet.snippetORm >> ofFusionM)\n                                                           return  prds |> Seq.choose (Option.map (fun s -> s.snpModified)) |> Seq.max |> RespDateTime\n                    | MsgGetPredecessors           snr  -> let!    snp  = Snippet.snippetFromRefORm snr |> ofFusionM |> absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                           let!    ids  = Snippet.predsLRm snp.snpId |> ofFusionM\n                                                           let!    prds = ids |> Fusion.traverseSeq (Snippet.snippetORm >> ofFusionM)\n                                                           return  prds |> Seq.choose id |> Seq.toArray |> RespSnippets\n                    | MsgAction [| \"AddOutput\" ; txt |] -> appendMsgs txt\n                                                           return  FSResponse.RespString \"Ok\"\n                    | MsgAction [| \"ExecJS\"    ; js  |] -> let! v = try  JS.Apply JS.Window \"eval\" [| js |] |> (function null -> \"\" | s -> sprintf \"%A\" s) |> Ok\n                                                                    with e -> ExceptMsg(e.Message, e.StackTrace) |> Result.Error\n                                                                    |> FusionAsyncM.ofResultRM\n                                                           return  FSResponse.RespString v\n                    | MsgAction [| \"SetProperty\"; path ; prop ; v  |] -> \n                                                           let! res  = Snippet.snippetFromRefORm (RefSnippetPath <| path.Split '/')\n                                                                       |>  ofFusionM  \n                                                                       |>> Option.map (fun snp -> Snippets.setProperty snp prop v ; \"Ok\")\n                                                                       |>  absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found: %s\" path)\n                                                           return  FSResponse.RespString res\n                    | MsgAction [| actN              |] -> return! actionCall actN () ()\n                    | MsgAction [| actN ; p1         |] -> return! actionCall actN p1 ()\n                    | MsgAction [| actN ; p1 ; p2    |] -> return! actionCall actN p1 p2\n                    | MsgGetValue               vrw     -> return! getValue vrw\n                    | MsgSetValue              (var, v) -> return! setValue var v\n                    | MsgGetUrl                         -> return  FSResponse.RespString JS.Document.BaseURI\n                    | _                                 -> return  Hole ?(sprintf \"TODO message: %A\" msg)\n                } |> runReader (Snippets.snippetsColl()) |> AsyncResult.map fst\n            \n            if IsClient then\n                async {\n                    do! Async.Sleep 1000\n                    while true do\n                        try         wsStationClient.ProcessIncoming processMessage\n                                    do! Async.Sleep 60000\n                        with   e -> printfn \"%s\" e.Message\n                                    do! Async.Sleep 1000\n                } |> Async.Start\n                \n        \n            if not IsClient then\n                FsiAgent.setQueueHandlers (fun (txt:string)  -> txt.Replace(FsiEvaluator.endToken, \"Done!\") \n                                                                |> FSharpStationClient.sendOutput \n                                                                |> AsyncResult.iterS print print)\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Owin\\lib\\net40\\Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\CommonServiceLocator\\lib\\portable-net4+sl5+netcore45+wpa81+wp8\\Microsoft.Practices.ServiceLocation.dll\"\n        \n        [< JavaScript false >]\n        module Server =\n            open global.Owin\n            open Microsoft.Owin.Hosting\n            open Microsoft.Owin.StaticFiles\n            open Microsoft.Owin.FileSystems\n            open WebSharper.Owin\n            open WebSharper.Sitelets\n            open WebSharper.UI.Server\n            open WebSharper.UI.Templating\n            open WebSharper.UI.Html\n            open WebSharper.Owin.WebSocket\n            open WebSharper.Owin.WebSocket.Client\n            open WebSharper.Owin.WebSocket.Server\n            open WebSockets\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n        //        Content.Page(Title = \"Main Page\" \n        //                   , Body  = [\n        //                        Html.client <@ MainProgram.mainProgram() @>\n        //                        Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n        //                     ])\n                Content.Page( \n                    TemplateLib()\n                        .Initializer( Html.client <@  MainProgram.mainProgram(); Doc.TextNode \"Initialized\" @> )\n                        .Elt(keepUnfilled = true) \n                )\n        \n            [< EntryPoint >]\n            let Main args =\n                printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n                let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n                let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n                let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n                let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n                let broker = Broker.BrokerAgent epWebSocket\n                Broker.BrokerAgent.FssWebSocketO <- Some broker\n                let staticFileOptions = StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory))\n                staticFileOptions.ServeUnknownFileTypes <- true\n                (staticFileOptions.ContentTypeProvider |> unbox<ContentTypes.FileExtensionContentTypeProvider>).Mappings.Add(\".wasm\", \"application/wasm\")\n                use server = WebApp.Start(url, fun appB ->\n                    appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                                       , Sitelet             = (Some <| Application.MultiPage content)\n                                                       , BinDirectory        = \".\"\n                                                       , Debug               = true))\n                        .UseStaticFiles(staticFileOptions)\n                        .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n                    |> ignore)\n                stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n                stdin.ReadLine() |> ignore\n                0\n        \n        "],
"names": [],
"mappings": "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"
}
