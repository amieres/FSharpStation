{
"version": 3,
"sourceRoot": "Source",
"sources": ["testing/testing.fs"],
"sourcesContent": ["////-d:WEBSHARPER\n////#cd @\"..\\projects\\FSharpStation\\src\"\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#I @\"..\\packages\\Owin\\lib\\net40\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n//#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n//#r @\"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n/// Root namespace for all code\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let print v = printfn \"%A\" v\n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> = \n                | ErrorMsg  of string\n                | Warning   of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                with \n                override msg.ToString() =\n                    match msg with\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n            \n            module Memoize =\n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO: ('p->'v option) \n                ///    store : ('p->'v->'v)\n                ///    clear : (unit->unit)\n                [<Inline>]\n                let checkStore() =\n                    let cache        = System.Collections.Generic.Dictionary<_, _>()\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    (checkO, store), cache.Clear\n            \n            \n                /// Memoizes function f using the provided data store\n                /// getStore() returns 2 functions:\n                ///     checkO: ('p->'v option)\n                ///     store : ('p->'v->'v)\n                [< Inline >]\n                let memoizeStore getStore f =\n                    let (checkO:'p->'v option), (store:'p->'v->'v) = getStore()\n                    fun p -> checkO p |> Option.defaultWith (fun () -> f p |> store p )\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let store, clear = checkStore()\n                    memoizeStore (fun () -> store) f\n                  , clear\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            /// returns a function that delays its execution\n            /// runs only once even if multiple calls happen before the delay\n            let delayed delay doF =\n                let cancellationTokenSourceO = ref None\n                fun parm -> \n                    let asy = async {\n                        do! Async.Sleep delay\n                        doF parm\n                    } \n                    !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n                    cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n                    Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq      f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let rtn                          = Ok\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                       | Ok    v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                       | Error e ->       e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = bindP  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = mapP  f v\n                        let inline (>>=) v f   = bindP f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResult =\n                    let rtn        v   = async.Return(Ok v  )\n                    let rtnR       vR  = async.Return    vR\n                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n                    let bind  fRA  vRA = async { \n                        let! vR       = vRA\n                        return! match   vR with\n                                | Ok    v -> fRA v\n                                | Error m -> async { return Error m }\n                    }\n                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | Ok    v -> return! fRA   v\n                            | Error m -> return  Error m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n                    }\n                    let inline map  f m = bind  (f >> rtn) m            \n                    let inline mapP f m = bindP (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map (Result.bindP   id)\n                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n                \n                type AsyncResultBuilder() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                            = fRA\n                    member __.Run              fRA                            = fRA ()\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                    th.While(enum.MoveNext,\n                                                                                      th.Delay(fun () -> fRA enum.Current)))\n                let asyncResult = AsyncResultBuilder()\n                \n                type AsyncResultBuilderP() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                                          = fRA\n                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                              th.While(enum.MoveNext,\n                                                                                                th.Delay(fun () -> fRA enum.Current)))\n                let asyncResultP = AsyncResultBuilderP()\n                \n                [<AutoOpen>]\n                module Extensions =      \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultBuilder with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                \n                    type AsyncResultBuilderP with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n                \n                \n                \n                [< AutoOpen >]\n                module ReaderMonads =\n                \n                \n                    \n                    type ReaderMBasic<'T, 'R, 'M> = ReaderMB of ('R -> 'T)\n                    \n                    /// There are several versions of the Reader Monads\n                    /// All have at least 2 type parameters: \n                    /// - the monad type \n                    /// - the Resource type that is passed when run\n                    /// - the Message or Error type for those that involve Result\n                    /// For ReaderMBasic and ReaderMAsync the third is a dummy type so that all have 3 parameters\n                    /// The purpose of this is to be able to develop generic code that can use any of the 4 Reader types:\n                    /// ReaderMBasic, ReaderMAsync, ReaderMResult, ReaderMAsyncResult.\n                    /// just by referencing the corresponding module\n                    \n                    module ReaderMBasic =\n                        let inline wrap                         f  = ReaderMB f\n                        let inline getFun                       f  =  f |> function ReaderMB g -> g\n                        let inline ofFun                        f  =  f                                           |> wrap\n                        let inline rtn                          a  = (fun _ -> a                                ) |> wrap\n                        let inline bind                       f a  = (fun m -> getFun a m |> f   |> getFun <| m ) |> wrap\n                        let inline delayRun        f               = (fun m ->               f() |> getFun <| m ) |> wrap\n                        let inline map             f            m  = bind (f >> rtn) m                             : ReaderMBasic<_,_,_>\n                        let inline apply           fR           vR = fR |> bind (swap map  vR)                     : ReaderMBasic<_,_,_>\n                        let inline run          rsrc             a = getFun a (rsrc: 'R)                           :             'T\n                        let (>>=)                              v f = bind f v\n                        let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                     Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                        let inline sequenceSeq                  sq = traverseSeq id sq\n                        let insertO  vvO                           = vvO  |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                        let insertR (vvR:Result<_,_>)              = vvR  |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                        let insertFst (fst, vRm)                   = vRm  |> map (fun v -> fst, v)\n                        let insertSnd (vRm, snd)                   = vRm  |> map (fun v -> v, snd)\n                        let absorbR (vvRm)                         = vvRm |> map  Result.get\n                        let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n                        let inline iter                f t         = run t >> (f: _ -> unit)\n                        let memoizeRm               getCache fRm p = (fun r -> \n                                                                         let checkO, store = getCache r\n                                                                         checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                                                                     ) |> wrap\n                    \n                        type Builder() =\n                            member inline this.Return      x                  = rtn  x\n                            member inline this.ReturnFrom  x                  =     (x:ReaderMBasic<_,_,_>)\n                            member        this.Bind       (w , r )            = bind   r w\n                            member inline this.Zero       ()                  = rtn ()\n                            member inline this.Delay       f                  = f\n                            member inline this.Combine    (a, b)              = bind b a\n                            member inline this.Run         f                  = delayRun f\n                            member this.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = (fun r -> try body() |> run r with e -> handler     e            ) |> wrap\n                            member this.TryFinally(body, compensation) = (fun r -> try body() |> run r finally   compensation()           ) |> wrap \n                            member this.Using     (disposable, body  ) = (fun r -> using (disposable:#System.IDisposable) (body >> run r) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                        let reader = Builder()\n                        \n                        module Operators =\n                            let inline (<*>) f v   = apply f v\n                            let inline (|>>) v f   = map   f v\n                            let inline (>>=) v f   = bind  f v\n                            let inline (>>>) f g v = f v |>> g\n                            let inline (>=>) f g v = f v >>= g\n                            let inline rtn   v     = rtn    v\n                            let reader = reader\n                            type ReaderM<'T, 'R, 'M> = ReaderMBasic<'T, 'R, 'M>\n                    \n                    type ReaderMResult<'T, 'R, 'M> = ReaderMR of ('R -> Result<'T, 'M>)\n                    \n                    module ReaderMResult =\n                        let inline wrap                         f  = ReaderMR f\n                        let inline getFun                       f  =  f |> function ReaderMR g -> g\n                        let inline ofFun                        f  = (f >> Result.rtn                                              ) |> wrap\n                        let inline rtn                          a  = (fun _ -> a |> Result.rtn                                     ) |> wrap\n                        let inline rtnR                         r  = (fun _ -> r                                                   ) |> wrap\n                        let inline bind            f            a  = (fun m -> getFun a m |> Result.bind (fun v -> getFun (f v) m) ) |> wrap\n                        let inline bindR           f            a  = rtnR a |> bind f                                                 : ReaderMResult<_,_,_>\n                        let inline delayRun        f               = (fun m ->  f() |> getFun <| m                                 ) |> wrap\n                        let inline map             f            m  = bind (f >> rtn) m                                                : ReaderMResult<_,_,_>\n                        let inline apply           fR           vR = fR |> bind (swap map  vR)                                        : ReaderMResult<_,_,_>\n                        let inline getResult                    a  = (fun m -> getFun a m |> Result.Ok )                 |> ReaderMR  : ReaderMResult<Result<_,'m>,_,'m>\n                        let inline getResult2                   a  = map Result.Ok a                                                  : ReaderMResult<Result<_,'m>,_,'m>\n                        let inline run          rsrc             a = getFun a rsrc                                                    :        Result<_,_>\n                        let (>>=)                              v f = bind f v\n                        let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                     Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                        let inline sequenceSeq                  sq = traverseSeq id sq\n                        let insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                        let insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                        let insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n                        let insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n                        let absorbR (vvRm)                         = vvRm  |> bind rtnR\n                        let absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n                        let inline iter             fE f t       a = a     |> run t |> Result.iter fE f\n                        //let memoizeRm               getCache fRm p = (fun r -> \n                        //                                                 let (checkO:'p->'v option), (store:'p->'v->'v), (clear:unit->unit) = getCache r\n                        //                                                 checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                        //                                             ) |> wrap\n                        let memoizeRm               getStore fRm p = (fun (r:'r) ->\n                                                                         let (checkO:'p->'v option), (store:'p->'v->'v) = getStore r\n                                                                         checkO p |> Option.map rtn |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                                         |> run r\n                                                                     ) |> wrap \n                    \n                        type Builder() =\n                            member inline this.Return      x                  = rtn   x\n                            member inline this.ReturnFrom  x                  =      (x:ReaderMResult<_,_,_>)\n                            member inline this.ReturnFrom  x                  = rtnR  x\n                            member        this.Bind       (w , r )            = bind   r w\n                            //member        this.Bind       (w , r )            = bindR  r w\n                            member inline this.Zero       ()                  = rtn ()\n                            member inline this.Delay       f                  = f\n                            member inline this.Combine    (a, b)              = bind b a\n                            member inline this.Run         f                  = delayRun f\n                            member this.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = (fun r -> try body() |> run r with e -> handler     e            ) |> wrap\n                            member this.TryFinally(body, compensation) = (fun r -> try body() |> run r finally   compensation()           ) |> wrap\n                            member this.Using     (disposable, body  ) = (fun r -> using (disposable:#System.IDisposable) (body >> run r) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                        let reader = Builder()\n                        \n                        module Operators =\n                            let inline (<*>) f v   = apply f v\n                            let inline (|>>) v f   = map   f v\n                            let inline (>>=) v f   = bind  f v\n                            let inline (>>>) f g v = f v |>> g\n                            let inline (>=>) f g v = f v >>= g\n                            let inline rtn   v     = rtn    v\n                            let reader = reader\n                            type ReaderM<'T, 'R, 'M> = ReaderMResult<'T, 'R, 'M>\n                    \n                    type ReaderMAsyncResult<'T, 'R, 'M> = ReaderMAR of ('R -> AsyncResult<'T, 'M>)\n                    \n                    module ReaderMAsyncResult =\n                        let inline wrap                         f  = ReaderMAR f\n                        let inline getFun                       f  =  f |> function ReaderMAR g -> g\n                        let inline ofFun                        f  = (f >> AsyncResult.rtn                                              )  |> wrap \n                        let inline rtn                          a  = (fun _ -> a |> AsyncResult.rtn                                     )  |> wrap\n                        let inline rtnR                         r  = (fun _ -> r |> Async.rtn                                           )  |> wrap \n                        let inline rtnA                         r  = (fun _ -> r |> Async.map Ok                                        )  |> wrap \n                        let inline rtnRA                        r  = (fun _ -> r                                                        )  |> wrap \n                        let inline rtnRmr                       r  = (fun m -> ReaderMResult.getFun r m |> Async.rtn                    )  |> wrap \n                        let inline bind            f            a  = (fun m -> getFun a m |> AsyncResult.bindP(fun v -> getFun (f v) m) )  |> wrap \n                        let inline bindR           f            a  = rtnR   a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n                        let inline bindA           f            a  = rtnA   a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n                        let inline bindRA          f            a  = rtnRA  a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n                        let inline bindRmr         f            a  = rtnRmr a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n                        let inline delayRun        f               = (fun m -> f() |> getFun <|m                                        )  |> wrap \n                        let inline map             f            m  = bind (f >> rtn) m                                                      : ReaderMAsyncResult<_,_,_>\n                        let inline apply           fR           vR = fR |> bind (swap map  vR)                                              : ReaderMAsyncResult<_,_,_>\n                        let inline getResult                    a  = (fun m -> getFun a m |> Async      .map  Result     .Ok ) |> ReaderMAR : ReaderMAsyncResult<Result<_,_>     ,_,_>\n                        let inline getAsync                     a  = (fun m -> getFun a m |> AsyncResult.mapP Async.rtn      ) |> ReaderMAR : ReaderMAsyncResult<Async<_>        ,_,_>\n                        let inline getAsyncResult               a  = (fun m -> getFun a m |> AsyncResult.mapP AsyncResult.rtn) |> ReaderMAR : ReaderMAsyncResult<AsyncResult<_,_>,_,_>\n                        let inline run          rsrc            a  = getFun a rsrc                                                          :        AsyncResult<_,_>\n                        let (>>=)                              v f = bind f v\n                        let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                     Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                        let inline sequenceSeq                  sq = traverseSeq id sq\n                        let insertO  vvO                           = vvO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                        let insertR (vvR:Result<_,_>)              = vvR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                        let insertFst (fst, vRm)                   = vRm |> map (fun v -> fst, v)\n                        let insertSnd (vRm, snd)                   = vRm |> map (fun v -> v, snd)\n                        let absorbR (vvRm)                         = vvRm |> bind rtnR\n                        let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n                        let inline iterA            fE f t         = run t >> AsyncResult.iterA fE f\n                        let inline iterS            fE f t         = run t >> AsyncResult.iterS fE f\n                        let memoizeRm               getCache fRm p = (fun r -> \n                                                                         let checkO, store = getCache r\n                                                                         checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                                                                     ) |> wrap\n                    \n                        type Builder() =\n                            member inline this.Return      x                  = rtn     x\n                            member inline this.ReturnFrom  x                  =        (x:ReaderMAsyncResult<_,_,_>)\n                            member inline this.ReturnFrom  x                  = rtnR    x\n                            member inline this.ReturnFrom  x                  = rtnA    x\n                            member inline this.ReturnFrom  x                  = rtnRA   x\n                            member inline this.ReturnFrom  x                  = rtnRmr  x\n                            member        this.Bind       (w , r )            = bind    r w\n                            member        this.Bind       (w , r )            = bindR   r w\n                            member        this.Bind       (w , r )            = bindA   r w\n                            member        this.Bind       (w , r )            = bindRA  r w\n                            member        this.Bind       (w , r )            = bindRmr r w\n                            member inline this.Zero       ()                  = rtn ()\n                            member inline this.Delay       f                  = f\n                            member inline this.Combine    (a, b)              = bind b a\n                            member inline this.Run         f                  = delayRun f\n                            member this.While(guard, body) =\n                                let rec whileLoop guard body =\n                                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                    else rtn   ()\n                                whileLoop guard body\n                            member this.TryWith   (body, handler     ) = (fun r -> async.TryWith   (body() |> run r,   handler                ) ) |> wrap\n                            member this.TryFinally(body, compensation) = (fun r -> async.TryFinally(body() |> run r,   compensation           ) ) |> wrap\n                            member this.Using     (disposable, body  ) = (fun r -> async.Using((disposable:#System.IDisposable), body >> run r) ) |> wrap\n                            member this.For(sequence:seq<_>, body) =\n                                this.Using(sequence.GetEnumerator(),fun enum -> \n                                    this.While(enum.MoveNext, \n                                        this.Delay(fun () -> body enum.Current)))\n                    \n                        let reader = Builder()\n                        \n                        module Operators =\n                            let inline (<*>) f v   = apply f v\n                            let inline (|>>) v f   = map   f v\n                            let inline (>>=) v f   = bind  f v\n                            let inline (>>>) f g v = f v |>> g\n                            let inline (>=>) f g v = f v >>= g\n                            let inline rtn   v     = rtn    v\n                            let reader = reader\n                            type ReaderM<'T, 'R, 'M> = ReaderMAsyncResult<'T, 'R, 'M>\n                    \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = this.Substring2(0, n)\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) start (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) ends  (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n            \n            [< Inline \"$a + '/' + $b\" >]\n            let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n                \n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            [<System.Runtime.CompilerServices.Extension >]\n            type MailboxProcessorExt =\n                [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n                [<System.Runtime.CompilerServices.Extension>]\n                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n            //    [<System.Runtime.CompilerServices.Extension>]\n            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n            \n            module Mailbox =\n            \n                /// A simple Mailbox processor to serially process Async tasks\n                /// use:\n                ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n                ///      logThisMsgA.Post \"message Async\"\n                ///      \n                let iterA hndl f =\n                    MailboxProcessor.Start(fun inbox ->\n                        async {\n                            while true do\n                                try       let!   msg = inbox.Receive()\n                                          do!  f msg\n                                with e -> hndl e\n                        }\n                    )\n                    \n                /// A simple Mailbox processor to serially process tasks\n                /// use:\n                ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n                ///      logThisMsg.Post \"message\"\n                ///      \n                let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n                ///                                async { return msg.ToUpper() } )\n                ///\n                ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///\n                ///      toUpperCaseA.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n                ///                                                        reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///\n                ///      async {\n                ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously    \n                ///      \n                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n                    let! r = f msg\n                    replyChannel.Reply r\n                })\n                \n                /// A simple Mailbox processor to serially and synchronously process tasks\n                /// use:\n                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n                ///      \n                ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n                ///      |> printfn \"%s\"\n                ///      \n                ///      toUpperCase.PostAndReply \"message\"\n                ///      |> printfn \"%s\"\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n                ///                                                       reply, \"message\")\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                ///      async {\n                ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n                ///          printfn \"Async: %s\" res\n                ///      } |> Async.RunSynchronously\n                ///      \n                let call hndl f = callA hndl (fun (msg:string) -> async { return f msg } )\n                \n                /// A Mailbox processor that maintains a state\n                let foldA hndl f initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! msg      = inbox.Receive()\n                                      let! newState = f state msg\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n            \n                /// A Mailbox processor that maintains a state\n                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n                \n                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n                /// use: \n                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n                ///      agent |> Mailbox.StateFull.getState\n                let stateFull hndl initState =\n                    MailboxProcessor.Start(fun inbox ->\n                        let rec loop state : Async<unit> = async {\n                            try       let! f        = inbox.Receive()\n                                      let! newState = f state\n                                      return! loop newState\n                            with e -> return! loop (hndl e state)\n                        }\n                        loop initState\n                    )\n                    \n                let defHandler ex st = print ex ; st\n                    \n                module StateFull =\n                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let! st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n                    [< Inline \"throw 'getState not available in JavaScript'\" >]\n                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n                    /// synchronous version pf applyReply\n                    [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                                fun v -> async {\n                                                                                                    let st, r = f v\n                                                                                                    reply.Reply r\n                                                                                                    return st \n                                                                                                })\n            \n            type ResourceAgentState<'R, 'C> = {\n                useCount      : int\n                limitCount    : int\n                resource      : 'R\n                configuration : 'C\n            }\n            \n            type ResourceAgent<'R, 'C when 'C : equality>(maxUseCount, ctor: 'C -> 'R, configuration, ?cleanup, ?isAlive, ?respawnAfter) =\n                let clean                          = defaultArg cleanup ignore\n                let alive                          = defaultArg isAlive (fun _ -> true)\n                let initConfig                     = configuration\n                let respawnRightAfter              = defaultArg respawnAfter true\n                let respawn                  state = clean state.resource\n                                                     { state with useCount = 0 ; resource = ctor state.configuration }\n                let check                cfg state = if state.useCount < state.limitCount && alive state.resource && cfg = state.configuration\n                                                     then state \n                                                     else respawn { state with configuration = cfg }\n                let increment                state = { state with useCount = state.useCount + 1 }\n                                                     |> if respawnRightAfter then (check state.configuration) else id\n                let agent                          = Mailbox.stateFull (fun ex st -> print ex ; respawn st)  \n                                                        {   useCount      = 0\n                                                            limitCount    = maxUseCount\n                                                            configuration = initConfig\n                                                            resource      = ctor initConfig\n                                                        }\n                [< Inline \"throw 'Process not available in JavaScript'\" >]\n                member oo.Process      (work,?cfg) = oo.ProcessA(work, ?cfg=cfg) |> Async.RunSynchronously\n                member oo.ProcessA     (work,?cfg) = oo.AsyncProcessA((fun v -> async { return work v }), ?cfg=cfg)\n                member __.AsyncProcessA(work,?cfg) = agent \n                                                    |> Mailbox.StateFull.applyReplyA(fun st -> async { \n                                                         let  st2 = st |> check (defaultArg cfg st.configuration) \n                                                         let! res = work st2.resource\n                                                         return increment st2, res \n                                                     })\n                member __.State                    = agent |> Mailbox.StateFull.getState\n                member oo.LimitCount    with get() = oo.State.limitCount\n                member oo.Configuration with get() = oo.State.configuration\n                member __.LimitCount    with set n = agent |> Mailbox.StateFull.apply(fun s -> { s with limitCount    = n })\n                member oo.Configuration with set c = if c <> oo.Configuration then agent |> Mailbox.StateFull.apply(fun s -> respawn { s with configuration = c})\n                member __.Respawn               () = agent |> Mailbox.StateFull.apply respawn\n                interface System.IDisposable with\n                    member this.Dispose () = try clean this.State.resource with _ -> ()\n            \n            \n            module AgentReaderM =\n                module ReaderM = ReaderMAsyncResult\n                open ReaderM.Operators\n            \n                let createAgentRm           f  v = ReaderM.ofFun(fun (agent:ResourceAgent<_,_>, cfg) -> agent.AsyncProcessA((fun resource -> f resource v), cfg) )\n                let fromResourceRm          f    = ReaderM.wrap (fun (agent:ResourceAgent<_,_>, cfg) -> agent.AsyncProcessA( ReaderM.getFun f             , cfg) ) : ReaderM<_,_,_>\n                let run            agent cfg                 m = ReaderM.run (agent,       cfg          ) m\n                let runSameConfig (agent:ResourceAgent<_,_>) m = ReaderM.run (agent, agent.Configuration) m\n            \n            [< AutoOpen >]\n            module CommArgRoot =\n                module ReaderM = ReaderMResult\n            \n                open ReaderM.Operators\n            \n                type CommArgId = CommArgId of System.Guid\n                \n                type CommArgBuild =\n                    | TInt    of (int    -> string)\n                    | TString of (string -> string)\n                    | TBool   of (bool   -> string)\n                    | TFloat  of (float  -> string)\n                \n                type CommArg = {\n                    cargId : CommArgId\n                    name   : string\n                    unique : bool\n                    build  : CommArgBuild\n                }\n                type CommArgValue<'T,  'M> = ReaderM<'T, CommArgCollection<     'M>, ResultMessage<'M>> \n                and  ArgValueTuple<    'M> = CommArg *   CommArgValue<obj,      'M>\n                and  CommArgCollection<'M> = CommArgCollection of ArgValueTuple<'M> seq\n                    with \n                        member oo.CommArgs = match oo with CommArgCollection v -> v\n                \n                type TypedCommArg<'T> = TypedCommArg of CommArg\n                    with\n                    member oo.CommArg = match oo with TypedCommArg v -> v\n                    static member (/=) (arg: TypedCommArg<'T>, v:                        'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, ReaderM.rtn v                     |> ReaderM.map box)\n                    static member (/=) (arg: TypedCommArg<'T>, v: CommArgValue<          'T, _>) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg,             v                     |> ReaderM.map box)\n                    static member (/=) (arg: TypedCommArg<'T>, f: CommArgCollection<'M>->'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, ReaderM.ofFun(fun coll -> f coll) |> ReaderM.map box)\n                \n                module CommArg  =\n                    let New0 (name, unique, build) = {\n                        cargId = CommArgId <| System.Guid.NewGuid()\n                        name   = name\n                        unique = unique\n                        build  = build\n                    }\n                    let NewInt   (name, unique, build): TypedCommArg<int   > = New0(name, unique, build |> TInt   ) |> TypedCommArg\n                    let NewString(name, unique, build): TypedCommArg<string> = New0(name, unique, build |> TString) |> TypedCommArg\n                    let NewBool  (name, unique, build): TypedCommArg<bool  > = New0(name, unique, build |> TBool  ) |> TypedCommArg\n                    let NewFloat (name, unique, build): TypedCommArg<float > = New0(name, unique, build |> TFloat ) |> TypedCommArg\n                    let argumentRm (a:CommArg) (vRm:CommArgValue<obj,_>) = reader {\n                        let! v = vRm\n                        return\n                            match a.build with\n                            | TInt    f -> unbox<int   > v |> f\n                            | TString f -> unbox<string> v |> f\n                            | TBool   f -> unbox<bool  > v |> f\n                            | TFloat  f -> unbox<float > v |> f\n                    }\n                    let argumentTRm(a,v) = argumentRm a v\n                    let getIntR    (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TInt    _ -> unbox<int   > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TInt\"\n                    let getStringR (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TString _ -> unbox<string> o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TString\"\n                    let getBoolR   (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TBool   _ -> unbox<bool  > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TBool\"\n                    let getFloatR  (TypedCommArg a) (o:obj) = \n                        match a.build with\n                        | TFloat  _ -> unbox<float > o |> Ok\n                        | _         -> Error <| ErrorMsg \"expecting TFloat\"\n                \n                module CommArgCollection =\n                    open ReaderM.Operators\n                \n                    let trueForAll                        _ = true\n                    let contains      (TypedCommArg arg) (CommArgCollection args) = args |> Seq.map (fun (a,_) -> a.cargId) |> Seq.contains arg.cargId\n                    let argsRm                           () = ReaderM.ofFun(fun (CommArgCollection args) -> args                 )\n                    let existsRm                          f = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.exists f )\n                    let filterRm                          p = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.filter p )\n                    let argumentsRm                  filter = filterRm filter >>= ReaderM.traverseSeq CommArg.argumentTRm\n                    let containsAnyOfRm (ids:CommArgId Set) = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.exists (fun (a,_) -> Set.contains a.cargId ids) )\n                    let argumentNotFound  targ = fun () -> match targ with | TypedCommArg arg -> sprintf \"argument not found: %s\" arg.name |> ErrorMsg\n                    let tryFindArgO   (TypedCommArg arg) (CommArgCollection args) = Seq.tryFind (fun (a,_) -> a.cargId = arg.cargId) args \n                    let tryFindArgORm     targ = ReaderM.ofFun(fun coll -> tryFindArgO targ coll |> Option.map ReaderM.insertFst |> ReaderM.insertO)|> ReaderM.bind id\n                    let tryGetIntORm      targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getIntR    targ o)) |>> Result.insertO |> ReaderM.absorbR\n                    let tryGetStringORm   targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getStringR targ o)) |>> Result.insertO |> ReaderM.absorbR\n                    let tryGetBoolORm     targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getBoolR   targ o)) |>> Result.insertO |> ReaderM.absorbR\n                    let tryGetFloatORm    targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getFloatR  targ o)) |>> Result.insertO |> ReaderM.absorbR\n                    let findArgRm         targ = tryFindArgORm   targ |>  ReaderM.absorbO (argumentNotFound targ)\n                    let getIntRm          targ = tryGetIntORm    targ |>  ReaderM.absorbO (argumentNotFound targ)\n                    let getStringRm       targ = tryGetStringORm targ |>  ReaderM.absorbO (argumentNotFound targ)\n                    let getFloatRm        targ = tryGetFloatORm  targ |>  ReaderM.absorbO (argumentNotFound targ)\n                    let getBoolRm   def   targ = tryGetBoolORm   targ |>> Option.defaultValue def\n                    [< Inline \"throw 'getBoolR not available in JavaScript'\" >]\n                    let getBoolR def targ args = getBoolRm def targ |> ReaderM.run args //|> Async.RunSynchronously //|> Result. Option.defaultValue false\n                \n                    let addPair(commArg:CommArg, vRm:ReaderM<obj, CommArgCollection<_>, _>) (CommArgCollection args) =\n                        args\n                        |> if commArg.unique then Seq.filter (fun (a,_) -> a.cargId <> commArg.cargId) else id\n                        |> Seq.append <| [ commArg, vRm ]\n                        |> Seq.toArray\n                        |> Seq.ofArray\n                        |> CommArgCollection\n                    let append (args1: CommArgCollection<'M>) (args2: CommArgCollection<'M> ) = args2.CommArgs |> Seq.fold (swap (unbox >> addPair)) args1\n                    let addPairs pairs collection = append collection (CommArgCollection pairs)\n                        \n                //    let produceRm = ReaderM(fun (CommArgCollection args) ->\n                //        args\n                //        |> ReaderM.traverseSeq (fun (a, vRm) -> CommArg.produceRm a vRm |> ReaderM.map (fun v -> a, v))\n                //        |> ReaderM.map Seq.toArray\n                //        |> ReaderM.run (CommArgCollection args)\n                //    )\n                \n                type  CommArgCollection<'M> with\n                    static member (+) (args: CommArgCollection<_>, args2                    ) = args |> CommArgCollection.addPairs args2\n                    static member (+) (args: CommArgCollection<_>, arg                      ) = args |> CommArgCollection.addPair  arg  \n                    static member (+) (args: CommArgCollection<_>, (CommArgCollection args2)) = args |> CommArgCollection.addPairs args2\n                \n                \n            type FsCode = FsCode of string\n            \n            module FsCode =\n            \n                type PreproDirective =\n                | PrepoCd     of string\n                | PrepoR      of string\n                | PrepoDefine of string\n                | PrepoLoad   of string\n                | PrepoLine   of string //* int\n                | PrepoNoWarn of string\n                | PrepoI      of string\n                | PrepoIf     of string\n                | PrepoElse   \n                | PrepoEndIf\n                | PrepoLight  of bool\n                | PrepoOther  of string\n                | NoPrepo\n                \n                let extractDefines(FsCode code) = \n                    if code.StartsWith \"////-d:\" \n                    then code.[4..code.IndexOf '\\n' - 1]\n                    else \"\"\n            \n                let separatePrepros (code:string[]) =\n                    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n                    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n                    let  comment = ((+)\"//\") \n                    let  prepro (line:string) = match true with \n                                                | true when line.StartsWith(\"#define\"       ) -> (comment line, line |> define |> PrepoDefine)\n                                                | true when line.StartsWith(\"#cd\"           ) -> (comment line, line |> quoted |> PrepoCd    )\n                                                | true when line.StartsWith(\"#r\"            ) -> (comment line, line |> quoted |> PrepoR     )\n                                                | true when line.StartsWith(\"#load\"         ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                                | true when line.StartsWith(\"#nowarn\"       ) -> (comment line, line |> quoted |> PrepoNoWarn)\n                                                | true when line.Trim().StartsWith(\"# \"     ) -> (comment line, line |> quoted |> PrepoLine  )\n                                                | true when line.Trim().StartsWith(\"#line\"  ) -> (comment line, line |> quoted |> PrepoLine  )\n                                                | true when line.StartsWith(\"#I\"            ) -> (comment line, line |> quoted |> PrepoI     )\n                                                | true when line.StartsWith(\"#if\"           ) -> (        line, line           |> PrepoIf    )\n                                                | true when line.StartsWith(\"#else\"         ) -> (        line,                   PrepoElse  )\n                                                | true when line.StartsWith(\"#endif\"        ) -> (        line,                   PrepoEndIf )\n                                                | true when line.StartsWith(\"#light\"        ) -> (        line, false          |> PrepoLight )\n                                                | true when line.StartsWith(\"#\"             ) -> (comment line, line           |> PrepoOther )\n                                                | _                                           -> (        line,                   NoPrepo    ) \n                    code |> Array.map prepro\n                    \n                let separateDirectives (fsNass:(string * PreproDirective) seq) =\n                    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n                    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n                    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n                    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n                    let  cd       = fsNass |> Seq.choose (snd >> (function | PrepoCd   dir -> Some dir    | _ -> None)) |> Seq.tryHead\n                    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n                    code, assembs, defines, prepoIs, nowarns, cd\n                    \n                let getSourceDir srcDir (lines:string[]) =\n                    match lines.[0], Array.tryItem 1 lines with\n                    |         String.StartsWith \"////#cd @\\\"\" dirq, _ \n                    | _, Some(String.StartsWith \"////#cd @\\\"\" dirq) ->  dirq.Trim()\n                                                                        |> function\n                                                                        | String.EndsWith \"\\\"\" dir\n                                                                        |                      dir ->\n                                                                        match dir with\n                                                                        | String.StartsWith \"\\\\\" _\n                                                                        | String.StartsWith \"/\"  _            -> dir\n                                                                        | _ when Seq.tryItem 1 dir = Some ':' -> dir\n                                                                        | _ -> srcDir  +/+                       dir\n                    | _                                                     -> srcDir\n            \n            \n            type SnippetId = SnippetId of System.Guid with member x.Id = match x with SnippetId id -> id\n                                                           static member Empty = SnippetId System.Guid.Empty\n            \n            type Snippet = {\n                snpId           : SnippetId    \n                snpName         : string\n                snpContent      : string\n                snpParentIdO    : SnippetId option\n                snpPredIds      : SnippetId Set\n                snpProperties   : (string* string) []\n                snpGeneration   : int\n            }\n            \n            type SnippetReference =\n            | RefSnippetId   of SnippetId\n            | RefSnippetPath of string[]\n            \n            type Reduced = ((SnippetId * string * int * int) [] * string [] * string [] * string [] * string [] * string [] * string option) option\n            \n            type SnippetCollection = {\n                generation       : int\n                ordered          : Snippet seq\n                fetcher          : SnippetId -> Snippet Option\n                predecesorsCache : unit -> (SnippetId -> SnippetId list option) \n                                         * (SnippetId -> SnippetId list -> SnippetId list)\n                reducedCache     : unit -> ((bool * SnippetId * Set<SnippetId>) -> Reduced option) \n                                         * ((bool * SnippetId * Set<SnippetId>) -> Reduced -> Reduced)\n                prepCode         : Snippet -> string                             \n            }\n            \n            module Snippet =\n                open System\n                module ReaderM = ReaderMResult\n                open ReaderM.Operators\n            \n                let getNextGeneration, setGeneration = \n                    let mutable generation  = 1\n                    (fun () -> generation <- generation + 1 ; generation)\n                  , (fun n  -> generation <- n                          )  \n                let New name content parentO = \n                    {\n                        snpId           = SnippetId <| System.Guid.NewGuid()   \n                        snpName         = name\n                        snpContent      = content\n                        snpParentIdO    = parentO\n                        snpPredIds      = Set.empty\n                        snpProperties   = Array.empty\n                        snpGeneration   = getNextGeneration()\n                    }\n                let defaultSnippet              = {\n                    snpId           = SnippetId <| System.Guid.Empty\n                    snpName         = \"\"\n                    snpContent      = \"\"\n                    snpParentIdO    = None\n                    snpPredIds      = Set.empty\n                    snpProperties   = Array.empty\n                    snpGeneration   = 0\n                }    \n                let snippetName name (content: string) =\n                    if name <> \"\" then name else \n                    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n                    |> Seq.map    (fun l -> l.Trim())\n                    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n                    |> Seq.tryHead\n                    |> Option.defaultValue \"<empty>\"    \n                let nameSanitized snp =\n                    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                                    '\\\\'  ; '/'|] //\"\n                    snp.snpName \n                    |> String.filter (fun c -> not <| Array.contains c illegal)\n                    |> fun c -> c + \" \" + snp.snpId.Id.ToString()\n                let propertyO       n snp = snp.snpProperties |> Array.tryPick (fun (name, value) -> if name = n then Some value else None)\n                let propertyPairO   n snp = propertyO n snp |> Option.map(fun v -> v.Split([| @\"|-|\" |], StringSplitOptions.RemoveEmptyEntries) |> fun vs -> vs.[0], vs |> Array.tryItem 1 |> Option.defaultValue vs.[0])\n                let snippetORm        sid = ReaderM.ofFun (fun { fetcher    = ftch } -> ftch sid                                               )\n                let parentORm         snp = ReaderM.ofFun (fun { fetcher    = ftch } -> snp.snpParentIdO |> Option.bind ftch                   )\n                let predecessorsRm    snp = ReaderM.ofFun (fun { fetcher    = ftch } -> snp.snpPredIds   |> Seq.choose  ftch                   )\n                let maxGenerationRm   ()  = ReaderM.ofFun (fun { ordered    = snps } -> snps |> Seq.map (fun s -> s.snpGeneration) |> Seq.max  )\n                let modifiedRm        snp = ReaderM.ofFun (fun { generation = gen  } -> snp.snpGeneration > gen                                )\n                let childrenRm        sid = ReaderM.ofFun (fun { ordered    = snps } -> snps |> Seq.filter(fun s -> s.snpParentIdO = Some sid) )\n                let orderedRm         ()  = ReaderM.ofFun (fun { ordered    = snps } -> snps                                                   )\n                let prepareCodeRm     snp = ReaderM.ofFun (fun { prepCode   = prep } -> prep snp                                               )\n                let snippetRm         sid = snippetORm sid |> ReaderM.absorbO (fun () -> sprintf \"Snippet not found %A\" sid |> ErrorMsg)\n                let rec pathRm        sid = snippetORm sid \n                                            |>> Option.map parentORm \n                                            >>= ReaderM.insertO \n                                            |>> Option.bind id\n                                            |>> Option.map (fun prn -> pathRm prn.snpId |>> fun rest -> prn.snpId :: rest ) \n                                            >>= ReaderM.insertO \n                                            |>> Option.defaultValue []\n                let snippetFromPathORm pth = reader {\n                    let! snps = orderedRm()\n                    return\n                        snps\n                        |> Seq.mapFold (fun (path, prntO) snp -> \n                                           if path |> Array.length = 0                       then None    , ([||]      , prntO         ) else\n                                           let name = snippetName snp.snpName snp.snpContent\n                                           if  name <> path.[0] || snp.snpParentIdO <> prntO then None    , (path      , prntO         ) else\n                                           if path |> Array.length > 1                       then None    , (path.[1..], Some snp.snpId) else\n                                                                                                  Some snp, ([||]      , prntO         )                               \n                                       ) \n                                       (pth, None)\n                        |> fst\n                        |> Seq.choose id\n                        |> Seq.tryHead\n                }\n                let snippetFromRefORm     = function\n                                            | RefSnippetId   sid -> snippetORm         sid\n                                            | RefSnippetPath pth -> snippetFromPathORm pth\n                let predsLRm (sid : SnippetId) = reader {\n                        let mutable ins  = [sid]  \n                        let mutable outs = [   ]\n                        while not ins.IsEmpty do\n                            match ins with\n                            | []         -> ()\n                            | hd :: rest -> if outs |> List.contains hd then\n                                                ins  <- rest\n                                            else\n                                                let! snpO  = snippetORm hd\n                                                let  preds = snpO \n                                                             |> Option.map(fun snp -> Seq.toList snp.snpPredIds @ Option.toList snp.snpParentIdO ) \n                                                             |> Option.defaultValue []\n                                                ins  <- rest @ preds\n                                                outs <- hd::outs\n                        return outs\n                    }\n                let predsLRmMemo          = ReaderM.memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n            #if FIX_GENERIC\n                (predsLRmMemo : (SnippetId -> Monads.ReaderMonads.ReaderMResult<SnippetId list,SnippetCollection,string>) )\n            #endif    \n                let uniquePredsRm     snp = predsLRmMemo snp.snpId\n                let rec modifiedRecRm snp = reader {\n                    let! modified         = modifiedRm     snp\n                    if modified then return true else\n                    let! predIds          = uniquePredsRm  snp\n                    let! predOs           = predIds |> Seq.map snippetORm                  |> ReaderM.sequenceSeq\n                    let! mods             = predOs  |> Seq.choose id |> Seq.map modifiedRm |> ReaderM.sequenceSeq\n                    return Seq.contains true mods\n                }\n                let rec propertyHierORm n snp = reader {\n                    match propertyO n snp with\n                    | Some v -> return Some (v.Split([| @\"|-|\" |], StringSplitOptions.RemoveEmptyEntries) |> fun vs -> vs.[0], if vs.Length > 0 then vs.[1] else vs.[0])\n                    | None   -> let! parentO = parentORm   snp\n                                match parentO with\n                                | Some p -> let!   propO = propertyHierORm n p\n                                            return propO |> Option.map(fun (_, next) -> next, next) \n                                | None   -> return None\n                }\n                let indentRm          snp =\n                    let rec indentMeChildNextRm          snp = reader {\n                        let  propIndentChildren = \"IndentChildren\"\n                        let  currO, nextO       = propertyPairO propIndentChildren snp |> function Some (curr, next) ->  ParseO.parseIntO curr, ParseO.parseIntO next | _-> None, None \n                        let! parentO            = parentORm   snp\n                        match parentO with\n                        | Some p -> let! _, (me, next) = indentMeChildNextRm p\n                                    return me, (me + (currO |> Option.defaultValue next), nextO |> Option.defaultValue next)\n                        | None   -> return 0 , (      currO |> Option.defaultValue 4    , nextO |> Option.defaultValue 4   )\n                    }\n                    indentMeChildNextRm snp |> ReaderM.map fst\n                let levelRm           snp = \n                    let rec levelRm2 snp lv = reader {\n                        let!  parentO = parentORm snp\n                        match parentO with\n                        | None   -> return  lv\n                        | Some p -> return! levelRm2 p (lv + 1)\n                    }\n                    levelRm2 snp 0\n                let ancestorsRm   snp = \n                    let rec  ancestorsRm2 snp lst = reader {\n                        let! parentO = parentORm snp\n                        match parentO with\n                        | Some p -> return! ancestorsRm2 p <| p::lst\n                        | None   -> return  lst\n                    }\n                    ancestorsRm2 snp []\n                let separateCodeRm snp = reader {\n                    let! indent        = indentRm snp\n                    let  indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n                    let! code          = prepareCodeRm snp\n                    //let  name          = nameSanitized snp\n                    let  code, assembs, defines, prepIs, nowarns, cdO =\n                        code.Split('\\n')\n                        |> FsCode.separatePrepros\n                        |> indentF\n                        |> FsCode.separateDirectives\n                    return\n                        [| snp.snpId, snippetName snp.snpName snp.snpContent, code.Length, indent |] , code, assembs, defines, prepIs, nowarns,cdO\n                }\n                let addSeps (lines1:(SnippetId*string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[], cdO1:string option)\n                            (lines2:(SnippetId*string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[], cdO2:string option) =\n                    Array.append lines1   lines2\n                  , Array.append code1    code2\n                  , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n                  , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n                  , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n                  , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n                  , cdO1 |> function None -> cdO2 |_-> cdO1\n                let reducedCodeRm  snippets = reader {\n                    let! parts    = snippets |> ReaderM.traverseSeq separateCodeRm\n                    let  reduced  = parts\n                                    |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||], None ] else snps\n                                    |> Seq.reduce addSeps\n                                    |> fun (lines, code                                         , assembs, defines, prepIs, nowarns, cdO) ->\n                                           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns, cdO)\n                    return reduced\n                }\n                let finishCode (lines:(SnippetId*string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[], cdO: string option) =\n                    let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n                    let part1  =\n                      [ if config <> \"\" then yield \"////\" + config\n                        if cdO.IsSome   then yield sprintf \"////#cd @\\\"%s\\\"\" cdO.Value\n                        yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n                        yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n                        yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\" )\n                      ]\n                    Seq.append part1 code |> String.concat \"\\n\"\n                  , lines \n                    |> Seq.mapFold (fun firstLine (id, name, len, ind) -> ((id, name), (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n                    |> fst\n                    |> Seq.toArray\n                //let codeAndStartsRm   snpIds = reader {\n                //    let! snippets = orderedRm() |>> Seq.filter(fun snp -> snpIds |> Seq.contains snp.snpId)\n                //    let! reduced  = reducedCodeRm snippets\n                //    return finishCode reduced\n                //}\n                //let codeFsxRm         snippets = codeAndStartsRm snippets |> ReaderM.map fst\n                let reducedOthersORm (before, snpId, snpIds) = reader {\n                    let  skipTake = if before then Seq.takeWhile else Seq.skipWhile\n                    let! snippets = orderedRm() |>> skipTake (fun snp -> snp.snpId <> snpId) |>> Seq.filter(fun snp -> snp.snpId <> snpId && snpIds |> Set.contains snp.snpId) \n                    if snippets |> Seq.isEmpty then return None else\n                    let! reduced = reducedCodeRm snippets\n                    return Some reduced\n                }\n                let reducedOthersORmMemo = ReaderM.memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n                let fastReducedRm  curIdO lastIdO = reader {\n                    let!  curSnippetO  = curIdO  |> Option.map snippetORm |> ReaderM.insertO\n                    let! lastSnippetO  = lastIdO |> Option.map snippetORm |> ReaderM.insertO\n                    match (Option.bind id curSnippetO, Option.bind id lastSnippetO) with\n                    | _              , None\n                    | None           , _                -> return! reducedCodeRm Seq.empty\n                    | Some curSnippet, Some lastSnippet ->\n                    let! preds = uniquePredsRm lastSnippet\n                    let  preds = Set preds\n                    let! reducedBeforeO = reducedOthersORmMemo (true , curSnippet.snpId, preds)\n                    let! reducedAfterO  = reducedOthersORmMemo (false, curSnippet.snpId, preds)\n                    let! currentCode    = separateCodeRm           curSnippet\n                    let part1 = reducedBeforeO |> Option.map (swap addSeps currentCode) |> Option.defaultValue currentCode\n                    return      reducedAfterO  |> Option.map (     addSeps part1      ) |> Option.defaultValue part1\n                }\n                let fastCodeRm  curIdO lastIdO = reader {\n                    let! reduced  = fastReducedRm curIdO lastIdO\n                    return finishCode reduced\n                }\n                let codeFsxRm    curId = fastCodeRm  (Some curId) (Some curId) |> ReaderM.map fst\n                \n            /// Tree structure to implement a hierarchical user interface but using readerMonad\n            module TreeReader =\n                module ReaderM = ReaderMResult    \n                open ReaderM.Operators\n            \n                type Node<'I, 'R, 'T> = {\n                    id                : unit                 -> 'I\n                    isExpandedRm      : unit                 -> ReaderM<bool                   , 'R, 'T>\n                    canHaveChildrenRm : unit                 -> ReaderM<bool                   , 'R, 'T>\n                    childrenRm        : unit                 -> ReaderM<Node<'I, 'R, 'T> seq   , 'R, 'T>\n                    pathRm            : unit                 -> ReaderM<'I list                , 'R, 'T>  // list of parents excluding itself\n                    parentORm         : Node<'I, 'R, 'T> seq -> ReaderM<Node<'I, 'R, 'T> option, 'R, 'T>\n                    newChildrenRm     : Node<'I, 'R, 'T> []  -> ReaderM<Node<'I, 'R, 'T>       , 'R, 'T>  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n                }\n            \n                let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n                let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n            \n                let rec listNodes level (nodes: Node<_,_,_> seq) =\n                    nodes\n                    |> Seq.map(fun node -> \n                        node.isExpandedRm() \n                        >>= (fun exp -> if exp then node.childrenRm() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n                        |>> (fun nodes -> Seq.append [ node, level ] nodes)\n                    ) \n                    |> ReaderM.sequenceSeq\n                    |>> Seq.collect id\n            \n                let removeNode (node:Node<_,_,_>) nodes = reader { // better use version removeNode2\n                    let! path = node.pathRm()\n                    let rec chRemove (n:Node<_,_,_>) = reader {\n                        if                  n.id() = node.id() then return  None\n                        elif List.contains (n.id())  path      then return! n.childrenRm()\n                                                                            |>> Seq.toArray\n                                                                            |>> Seq.map chRemove \n                                                                            >>= ReaderM.sequenceSeq \n                                                                            |>> Seq.choose id \n                                                                            |>> Seq.toArray\n                                                                            >>= n.newChildrenRm  \n                                                                            |>> Some\n                        else                                        return  Some n\n                    }\n                    return! nodes |> Seq.map chRemove |> ReaderM.sequenceSeq |>> Seq.choose id\n                }\n            \n                let removeNodes p nodes = reader {\n                    let rec folder pair (n:Node<_,_,_>) = reader {\n                        let! children, noparent = pair\n                        let! children2 = n.childrenRm() |>> Seq.toArray\n                        let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n                        if p n then return (        children, ch @ np)\n                               else let! xxx = n.newChildrenRm (ch |> Seq.rev |> Seq.toArray)\n                                    return ( xxx :: children,      np)\n                    }\n                    let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n                    return noparent @ res |> List.rev\n                }\n            \n                let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n                    seq [ for n in nodes do\n                            if p n then\n                                if after then yield n    ; yield node\n                                else          yield node ; yield n\n                            else              yield n\n                    ]\n                    \n                let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenRm\n            \n                let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n                    sibling.pathRm() >>= function\n                    | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n                    | parent :: path -> \n                    let rec mapAdd (n:Node<_,_,_>) =\n                        if                  n.id() = parent then     n.childrenRm() |>> Seq.toArray >>= addToParent after theSibling node n\n                        elif List.contains (n.id()) path    then     n.childrenRm() |>> Seq.toArray |>> Seq.map mapAdd >>= ReaderM.sequenceSeq |>> Seq.toArray >>= n.newChildrenRm \n                        else                                     rtn n\n                    nodes |> Seq.map mapAdd |> ReaderM.sequenceSeq\n            \n                let tryFind p (nodes:Node<_,_,_> seq) = \n                    let rec folder resRm (node:Node<_,_,_>) =\n                        resRm >>= function\n                        | Some v -> rtn (Some v)\n                        | None   ->\n                        if p node then rtn <| Some node else \n                        node.childrenRm() >>= Seq.fold folder (rtn None)\n                    nodes                 |>  Seq.fold folder (rtn None)\n                    \n                let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n            \n                let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    nodes\n                    |>  removeNode node\n                    >>= addSibling after node sibling\n            \n                let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = reader {\n                    let!  nodeO = nodes |> tryFindId nodeId\n                    match nodeO with\n                    | None         -> return nodes\n                    | Some node    ->\n                    let!  siblingO = nodes |> tryFindId siblingId\n                    match siblingO with\n                    | None         -> return nodes\n                    | Some sibling -> return! moveToSibling after node sibling nodes\n                }\n            \n                let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = reader {\n                    let! path = parentN.pathRm()\n                    let rec mapAppend (n:Node<_,_,_>) =\n                        if   n.id() = parentN.id()       then \n                            if append                    then n.childrenRm() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                            else                              n.childrenRm() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                        elif List.contains (n.id()) path then n.childrenRm() |>> Seq.toArray |>>      Seq.map mapAppend   >>= ReaderM.sequenceSeq |>> Seq.toArray >>= n.newChildrenRm\n                        else                                  rtn n\n                    return! nodes |> Seq.map mapAppend |> ReaderM.sequenceSeq\n                }\n            \n                let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n                    node.parentORm nodes >>= function\n                    | None        -> rtn nodes\n                    | Some parent -> parent.childrenRm() |>> (Seq.toArray >> Seq.ofArray)\n                    |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n                    >>= Seq.fold      (fun newParentORm n -> n.canHaveChildrenRm() >>= (fun can -> if can then rtn(Some n) else newParentORm)) (rtn None)\n                    >>= function\n                    | None           -> rtn nodes\n                    | Some newParent ->\n                    nodes\n                    |>  removeNode node \n                    >>= addChild true node newParent\n            \n                let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.parentORm nodes\n                    |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n                    >>= Option.defaultValue (rtn nodes)\n                    \n                let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n                    node.childrenRm()\n                    |>> Seq.toArray\n                    >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n                    >>= removeNode node\n                    \n                \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            module RunProcess =\n                open System.Diagnostics\n                open System.Text\n            \n                let startProcess p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let proc        = new Process()\n                    proc.StartInfo <- procStart\n                    proc.Start() \n                \n                let startProcessDir p ops dir =\n                    let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n                    let proc        = new Process()\n                    proc.StartInfo <- procStart\n                    proc.Start() \n                \n                type ShellResponse =\n                    | ShellDidNotStart \n                    | ShellExit                  of int * stdout: string * stderr:string\n                    | ShellNoExit                of       stdout: string * stderr:string\n                    | ShellCrashed               of       stdout: string * stderr:string\n                    with \n                    override msg.ToString() = \n                        match msg with\n                        | ShellDidNotStart                 -> [ \"Shell did not start\" ]\n                        | ShellExit        (cod, out, err) -> [ if cod <> 0 then yield sprintf \"exit(%d)\" cod\n                                                                yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellCrashed     (     out, err) -> [ yield \"Shell crashed!\" ; yield out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        | ShellNoExit      (     out, err) -> [ yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n                        |> String.concat \"\\n\"\n                \n                type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl, ?priorityClass) =\n                    let proc                              = new Process()\n                    let bufferOutput                      = new StringBuilder()\n                    let bufferError                       = new StringBuilder()\n                    let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\")                  |> ignore\n                    let consume (sb: StringBuilder)       = sb.ToString() |>! (fun _ -> sb.Clear() |> ignore)\n                    let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n                    let outputHandler                     = append bufferOutput |> dataHandler\n                    let errorHandler                      = append bufferError  |> dataHandler\n                    do  startInfo.RedirectStandardInput  <- true\n                        startInfo.RedirectStandardOutput <- true\n                        startInfo.RedirectStandardError  <- true\n                        startInfo.UseShellExecute        <- false\n                        proc.StartInfo                   <- startInfo\n                        proc.EnableRaisingEvents         <- true\n                        outputHandler                    |>             proc.OutputDataReceived.AddHandler\n                        errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n                        Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n                        Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n                //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n                      \n                    new          (program, args, ?priorityClass) = let startInfo                     = new ProcessStartInfo()\n                                                                   do  startInfo.FileName           <- program\n                                                                       startInfo.Arguments          <- args\n                                                                   new ShellEx(startInfo, ?priorityClass = priorityClass)\n                    member ____.Start                         () = let r = proc.Start() \n                                                                   priorityClass |> Option.iter (fun p -> proc.PriorityClass <- p)\n                                                                   proc.BeginOutputReadLine()\n                                                                   proc.BeginErrorReadLine ()\n                                                                   r\n                    member ____.WaitToFinish                  () = proc.WaitForExit()\n                                                                   let    output  = (consume bufferOutput).Trim()\n                                                                   let    error   = (consume bufferError ).Trim()\n                                                                   ((if proc.HasExited then proc.ExitCode else -99999), output, error)\n                    member ____.WaitForInputIdle              () = proc.WaitForInputIdle()\n                    member this.StartAndWait                  () = let _started = this.Start()\n                                                                   this.WaitToFinish()\n                    member this.StartAndWaitS                 () = this.StartAndWait()\n                                                                   |>! fun _ -> (this :> System.IDisposable).Dispose()\n                                                                   |> ShellExit\n                    member this.stdOutErr2Result exit out errs   = if exit <> 0\n                                                                   then Result.Error <| ErrorMsg(\n                                                                           [| if out  <> \"\"              then yield \"stdout: \" + out           \n                                                                              if errs <> \"\"              then yield errs                       \n                                                                              if errs  = \"\" || exit <> 1 then yield sprintf \"ExitCode: %d\" exit\n                                                                           |] |> String.concat \"\\n\")\n                                                                   else Result.Ok (out, errs)\n                    member this.StartAndWaitR                 () = let r = this.StartAndWait()\n                                                                   (this :> System.IDisposable).Dispose()\n                                                                   r |||> this.stdOutErr2Result\n                    member this.RunToFinish                   () = this.StartAndWaitS().ToString()\n                    member this.RunOutputToFileR            file = proc.OutputDataReceived.RemoveHandler outputHandler\n                                                                   use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n                                                                   let _started = proc.Start() \n                                                                   proc.BeginErrorReadLine ()\n                                                                   proc.StandardOutput.BaseStream.CopyTo stream\n                                                                   this.WaitToFinish()\n                                                                   |> ShellExit\n                    member this.RunOutputToFile             file = this.RunOutputToFileR file\n                                                                   |> fun v -> v.ToString() \n                    member ____.Send                (txt:string) = proc.StandardInput.WriteLine txt\n                    member ____.Output                        () = consume bufferOutput\n                    member ____.Error                         () = consume bufferError\n                    member ____.Response(out:string, err:string) = match out.Trim(), err.Trim() with\n                                                                   | good, \"\"  -> Result.Ok    <| good               \n                                                                   | good, bad -> Result.Error <| Message(ShellNoExit(good, bad))\n                    member this.Response                      () = this.Response(this.Output(), this.Error())\n                    member this.SendAndWait (send, wait, ?onErr) =\n                        let waitOnError = defaultArg onErr false\n                        let eventWait   = if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                                          |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.Ok v else None) with _ -> None)\n                        let eventAll    = Event.merge eventWait  (Event.map (fun _ -> Result.Error <| Message (ShellCrashed(this.Output(), this.Error()))) proc.Exited)\n                        asyncResult {\n                            //do! Result.tryProtection()\n                            async { \n                                do!    Async.Sleep 20 \n                                this.Send send        } |> Async.Start\n                            let! (waited:string) = Async.AwaitEvent eventAll\n                            do!   Async.Sleep 200\n                            return! if waitOnError\n                                    then this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                                    else this.Response()\n                        }\n                    member ____.HasExited = try proc.HasExited with _ -> true\n                    member ____.Abort()   = try proc.Kill   () with _ -> ()\n                    interface System.IDisposable with\n                        member ____.Dispose () =\n                            try proc.Kill   () with _ -> ()\n                            try proc.Close  () with _ -> ()\n                            try proc.Dispose() with _ -> ()\n                \n                \n                let runAndWaitS p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.StartAndWaitS() \n                \n                let runToFinish p ops =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n                    shell.RunToFinish() \n                \n                let runOutputToFile p ops file =\n                    let procStart   = ProcessStartInfo(p, ops)\n                    let shell       = new ShellEx(procStart)\n                    shell.RunOutputToFile file \n                \n                \n            module CopyIfMust =\n                open System.IO\n                \n                let copyIfNotExistsToFile from dest =\n                    let fit = FileInfo dest\n                    if not fit.Exists then\n                        File.Copy(from, dest, true )\n                \n                let toFile from dest =\n                    let fit = FileInfo dest\n                    let must = \n                        match fit.Exists with \n                        | false -> true\n                        | true  ->\n                            let fif = FileInfo dest\n                            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n                    if must then\n                        File.Copy(from, dest, true )\n                \n                let toDir from destDir =\n                    let dest = Path.Combine(destDir, Path.GetFileName(from))\n                    toFile from dest\n                \n            module FsCode =\n                open CommArg\n                open CommArgCollection\n                open FsCode\n                open System.IO\n                    \n                let flag t f p = function true -> p + t |_-> p + f\n                let flagpm   p = flag \"+\" \"-\" p\n            \n                let intRootDir       = NewString(\"RootDir\"      , true , sprintf  \"++root:%s\"        )\n                let intSnippet       = NewString(\"Snippet\"      , true , sprintf  \"++snippet:%s\"     )\n                let intCreateDir     = NewBool  (\"CreateDir\"    , true , fun v ->  if v then \"++createdirectory\" else \"\")\n                let intDirectory     = NewString(\"Directory\"    , true , sprintf  \"++directory:%s\"   )\n                let intName          = NewString(\"Name\"         , true , sprintf  \"++name:%s\"        )\n                let intExtension     = NewString(\"Extension\"    , true , sprintf  \"++extension:%s\"   )\n                let intFileName      = NewString(\"Filename\"     , true , sprintf  \"++filename:%s\"    )\n                let intOutputFile    = NewString(\"OutputFile\"   , true , sprintf  \"++fileout:%s\"     )\n                let intConfig        = NewString(\"Config\"       , true , sprintf  \"++config:%s\"      )\n                let intCopyConfig    = NewBool  (\"CopyConfig\"   , true , flagpm   \"++copyconfig\"     )\n                let intWebSharper    = NewBool  (\"WebSharper\"   , true , flagpm   \"++websharper\"     )\n                let intStaticLinkAll = NewBool  (\"StaticLinkAll\", true , flagpm   \"++staticlinkall\"  )\n                let intCopyAssem     = NewBool  (\"CopyAssem\"    , true , flagpm   \"++copyassemblies\" )\n                let intShowArgs      = NewBool  (\"ShowArgs\"     , true , flagpm   \"++showargs\"       )\n                let intRemLineDir    = NewBool  (\"RemLineDir\"   , true , flagpm   \"++remlinedir\"     )\n                \n                let internalArgs = \n                    Set [\n                        intSnippet      .CommArg.cargId\n                        intDirectory    .CommArg.cargId\n                        intName         .CommArg.cargId\n                        intExtension    .CommArg.cargId\n                        intFileName     .CommArg.cargId\n                        intOutputFile   .CommArg.cargId\n                        intConfig       .CommArg.cargId\n                        intWebSharper   .CommArg.cargId\n                        intStaticLinkAll.CommArg.cargId\n                        intCopyAssem    .CommArg.cargId\n                        intShowArgs     .CommArg.cargId\n                    ]\n            \n                let fscIOption     = NewString(\"IOption\"   , false, sprintf \"-I:%A\"          )\n                let fscReference   = NewString(\"Reference\" , false, sprintf \"-r:%A\"          )\n                let fscSource      = NewString(\"Source\"    , false, sprintf \"%A\"             )\n                let fscTarget      = NewString(\"Target\"    , true , sprintf \"--target:%s\"    )\n                let fscPlatform    = NewString(\"Platform\"  , true , sprintf \"--platform:%s\"  )\n                let fscOutput      = NewString(\"Output\"    , true , sprintf \"-o:%A\"          )\n                let fscDebug       = NewString(\"Debug\"     , true , sprintf \"--debug:%s\"     )\n                let fscDefine      = NewString(\"Define\"    , false, sprintf \"--define:%s\"    )\n                let fscStaticLink  = NewString(\"StaticLink\", false, sprintf \"--staticlink:%s\")\n                let fscGenFSharp1  = NewString(\"GenFSharp1\", false, sprintf \"-%s\"            )\n                let fscGenFSharp2  = NewString(\"GenFSharp2\", false, sprintf \"--%s\"           )\n                \n                let FSharpArgs = \n                    Set [\n                          fscIOption   .CommArg.cargId\n                          fscReference .CommArg.cargId\n                          fscSource    .CommArg.cargId\n                          fscTarget    .CommArg.cargId\n                          fscPlatform  .CommArg.cargId\n                          fscOutput    .CommArg.cargId\n                          fscDebug     .CommArg.cargId\n                          fscDefine    .CommArg.cargId\n                          fscStaticLink.CommArg.cargId\n                          fscGenFSharp1.CommArg.cargId\n                          fscGenFSharp2.CommArg.cargId\n                ] \n                \n                let wscWebSite      = NewString(\"Website\"     , true , sprintf \"--wsoutput:%A\"              )\n                let wscProjectPath  = NewString(\"WsProject\"   , true , sprintf \"--project:%A\"               )\n                let wscProjectType  = NewString(\"ProjectType\" , true , sprintf \"--ws:%s\"                    )\n                let wscGenWSharper  = NewString(\"GenWSharper\" , false, sprintf \"--%s\"                       )\n                let wscJSMap        = NewBool  (\"JSMap\"       , false, flagpm  \"--jsmap\"                    )\n                let wscDeadCodeElim = NewBool  (\"DeadCodeElim\", false, flagpm  \"--dce\"                      )\n                let wscWarnOnly     = NewBool  (\"WarnOnly\"    , false, flagpm  \"--wswarnonly\"               )\n                let wscDownloadResc = NewBool  (\"DownloadResc\", false, flagpm  \"--dlres\"                    )\n                let wscPrintJS      = NewBool  (\"PrintJS\"     , false, flagpm  \"--printjs\"                  )\n                let wscClosures     = NewBool  (\"Closures\"    , false, flagpm  \"--closures\"                 )\n                let wscClosrMoveTop = NewBool  (\"ClosrMoveTop\", false, flag    \"--closures:movetotop\" \"\" \"\" )\n                let wscJsOutput     = NewString(\"JsOutput\"    , true , sprintf \"--jsoutput:%A\"              )\n            \n                let WebSharpArgs = \n                    Set [\n                          wscWebSite     .CommArg.cargId\n                          wscProjectPath .CommArg.cargId\n                          wscProjectType .CommArg.cargId\n                          wscGenWSharper .CommArg.cargId\n                          wscJSMap       .CommArg.cargId\n                          wscDeadCodeElim.CommArg.cargId\n                          wscWarnOnly    .CommArg.cargId\n                          wscDownloadResc.CommArg.cargId\n                          wscPrintJS     .CommArg.cargId\n                          wscClosures    .CommArg.cargId\n                          wscClosrMoveTop.CommArg.cargId\n                          wscJsOutput    .CommArg.cargId\n                    ] \n                \n                let dllOptions   () = CommArgCollection [ fscTarget      /= \"library\"                                                                     ] \n                let exeOptions   () = CommArgCollection [ fscTarget      /= \"exe\"     ; intCopyAssem /= true ; intCopyConfig /= true ]\n                let winExeOptions() = CommArgCollection [ fscTarget      /= \"winexe\"  ; intCopyAssem /= true ; intCopyConfig /= true ]\n                \n                module ReaderM = ReaderMResult\n                open ReaderM.Operators\n                \n                let gS v = getStringRm     v\n                let gB v = getBoolRm false v\n            \n                let genericOptions () = \n                  CommArgCollection\n                    [\n            //           intSnippet     /= \"Test\"\n                        intRootDir     /= \"..\"\n                        intName        /= (rtn (fun s     -> String.splitByChar '/' s |> Array.last ) <*> gS intSnippet                                       )\n                        intDirectory   /= (rtn (fun r     -> r                                      ) <*> gS intRootDir                                       )\n                        intFileName    /= (rtn (fun d n   -> d +/+ \"src\" +/+ n + \".fs\"              ) <*> gS intDirectory  <*> gS intName                     )\n                        fscOutput      /= (rtn (fun d n e -> d +/+ \"bin\" +/+ n + \".\" + e            ) <*> gS intDirectory  <*> gS intName <*> gS intExtension )\n                        intExtension   /= (rtn (function \"library\" -> \"dll\" |_-> \"exe\"              ) <*> gS fscTarget                                        )\n                        intOutputFile  /= (rtn               Path.GetFileName                         <*> gS fscOutput                                        )\n                        intConfig      /= (rtn (fun o     -> o + \".config\"                          ) <*> gS intOutputFile                                    )\n                        intWebSharper  /=       containsAnyOfRm WebSharpArgs\n                        fscSource      /=       gS intFileName\n                    ]\n                    \n                let siteOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectType /=       \"Site\"\n                       wscWebSite     /= (rtn (fun d -> d +/+ \"website\" ) <*> gS intDirectory )\n                       wscProjectPath /=       gS intName\n                       wscJSMap       /=       true\n                       wscJsOutput    /= (rtn (fun d n   -> d +/+ n + \"0.js\" ) <*> gS wscWebSite    <*> gS intName                     )\n                    |] \n                 \n                let wsProjectOptions ()=\n                  CommArgCollection\n                    [|\n                       wscProjectPath /= gS intName\n                    |] \n                 \n                let debugOptions() = \n                  CommArgCollection\n                    [|\n                       fscGenFSharp1  /= \"g\"\n                       fscDebug       /= \"full\"\n                       fscDefine      /= \"DEBUG\"\n                       fscDefine      /= \"TRACE\"\n                       fscGenFSharp2  /= \"optimize-\"\n                       fscGenFSharp2  /= \"tailcalls-\"\n                    |]\n                \n                let otherOptions () =\n                  CommArgCollection\n                    [|\n                       //@\"--noframework\"\n                       fscGenFSharp2  /= \"warn:3\"\n                       fscGenFSharp2  /= \"warnaserror:76\"\n                       fscGenFSharp2  /= \"vserrors\"\n                       fscGenFSharp2  /= \"utf8output\"\n                       fscGenFSharp2  /= \"fullpaths\"\n                       fscGenFSharp2  /= \"flaterrors\"\n                       fscGenFSharp2  /= \"subsystemversion:6.00\"\n                       fscGenFSharp2  /= \"highentropyva+\"\n                       intRemLineDir  /= true\n                    |]\n                \n                let compileOptionsDll (snp:string) = \n                    genericOptions()\n                    + dllOptions  ()\n                    + otherOptions()\n                    + intSnippet     /= snp\n                    \n                let compileOptionsDllDebug   (snp:string) = compileOptionsDll      snp + debugOptions ()       \n                let compileOptionsExeDebug    snp         = compileOptionsDllDebug snp + exeOptions   ()\n                let compileOptionsWinExeDebug snp         = compileOptionsDllDebug snp + winExeOptions()\n                    \n                let prepOptions (args:CommArgCollection<_>) (assembs : string [], defines : string [], prepoIs : string []) =\n                    let staticLinksAll = CommArgCollection.getBoolR false intStaticLinkAll args\n                    args + [\n                        yield! prepoIs |> Array.map ((/=) fscIOption  ) \n                        yield! assembs |> Array.map ((/=) fscReference)\n                        yield! defines |> Array.map ((/=) fscDefine   )\n                        if staticLinksAll = Ok true then \n                            yield! assembs |> Array.map (fun f -> fscStaticLink /= System.IO.Path.GetFileNameWithoutExtension f)\n                    ]\n                    \n                let processArgs code assembs nowarns = reader {        \n                    let! show      = gB intShowArgs\n                    if show      then let! args = argumentsRm (fun _ -> true)\n                                      args |> Seq.iter (printfn \"%s\")\n                    let! workDir   = getStringRm intDirectory\n                    let! fileName  = gS intFileName\n                    let! output    = gS fscOutput\n                    let! copyAssem = gB intCopyAssem\n                    let! createDir = gB intCreateDir\n                    let  srcDir    = Path.GetDirectoryName fileName\n                    let  outDir    = Path.GetDirectoryName output\n                    if createDir then \n                                     Directory.CreateDirectory workDir |> ignore\n                                     Directory.CreateDirectory  srcDir |> ignore\n                                     Directory.CreateDirectory  outDir |> ignore\n                    let  code2     = [\n                                        yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n                                        yield! code \n                                     ] |> String.concat \"\\n\"\n                    do               File.WriteAllText(fileName, code2)\n                    if copyAssem then assembs |> Array.iter (fun f -> outDir |> CopyIfMust.toDir f)      \n                }\n                \n            module FsiEvaluator =\n                open System.Diagnostics\n                open RunProcess\n                \n                \n                let inline (+/+) a b = System.IO.Path.Combine(a, b)\n            \n                [< Literal >]\n                let endToken = \"xXxY\" + \"yYyhH\"\n                type FsiExe(config:string, workingDir, ?outHndl, ?errHndl) =\n                    let mutable silent             = false\n                    let fsiexe                     = @\"..\\packages\\FSharp.Compiler.Tools\\tools\" +/+ if config.Contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n                    let startInfo                  = ProcessStartInfo(fsiexe, config, WorkingDirectory= workingDir)\n                    let outHndlS                   = outHndl |> Option.map(fun outh v -> if silent then () else outh v)\n                    let errHndlS                   = errHndl |> Option.map(fun errh v -> if silent then () else errh v)\n                    let shell                      = new ShellEx(startInfo, ?outHndl = outHndlS, ?errHndl = errHndlS)  // --noninteractive\n                    do  startInfo.CreateNoWindow  <- false\n                        shell.Start() |> ignore\n                    member __.Eval (FsCode code)   = asyncResult {\n                                                         shell.Send code\n                                                         shell.Send \";;\"\n                                                         return! shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                                                     }\n                    member oo.IsAlive              = not shell.HasExited\n                    member oo.Abort()              = shell.Abort()\n                    member oo.EvalSilent code      = asyncResult {\n                                                        try     silent <- true\n                                                                return! oo.Eval code\n                                                        finally silent <- false\n                                                     }\n                    interface System.IDisposable with\n                        member this.Dispose ()     = (shell :> System.IDisposable).Dispose()\n            \n                module ReaderM = ReaderMAsyncResult\n                open ReaderM.Operators\n            \n                let evaluateRm   code = (fun (fsi:FsiExe) -> fsi.Eval       code) |> ReaderM.wrap : ReaderM<_,_,_>\n                let evalSilentRm code = (fun (fsi:FsiExe) -> fsi.EvalSilent code) |> ReaderM.wrap : ReaderM<_,_,_>\n            \n            module FsiCodePresence =\n                module ReaderM = ReaderMAsyncResult\n                open FsiEvaluator\n                open ReaderM.Operators\n            \n                let installPresenceRm() = \n                    \"\"\"\n                    module CodePresence =\n                        let mutable present : Map<string, string>  = Map.empty\n                        let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n                        let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n                    \"\"\"\n                    |>  String.unindentStr\n                    |>  FsCode\n                    |>  evalSilentRm \n                    |>> ignore\n            \n                let addPresenceRm (name:string) (v:string) = reader {\n                    let  code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v |> FsCode\n                    let! res  = evalSilentRm code\n                    match res with\n                    | \"ok\" -> ()\n                    | _    -> do! installPresenceRm()\n                              do! evalSilentRm code |>> ignore\n                }\n                        \n                let getPresenceRm (name:string)   = reader {\n                    let! res = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n                               |> FsCode\n                               |> evalSilentRm\n                               |> ReaderM.getResult\n                    match res with\n                    | Error v                -> do! installPresenceRm()\n                                                return None\n                    | Ok v when v = endToken -> do! installPresenceRm()\n                                                return None\n                    | Ok \"--\"                -> return None\n                    | Ok v                   -> return Some v\n                }\n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            module View =\n                let insertWO = \n                    function\n                    | Some v -> View.Map Some v\n                    | None   -> View.Const None\n                let [<Inline>] inline consistent   (vl:View<_>)  = \n                    let prior      = ref <| Var.Create Unchecked.defaultof<_>\n                    let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n                    View.Sink setPrior vl\n                    !prior |> View.FromVar\n            \n                let bind = View.Bind\n                let map  = View.Map\n                let rtn  = View.Const\n            \n                let (>>=)                              v f = bind f v\n                let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                             Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                let inline sequenceSeq                  sq = traverseSeq id sq\n            \n            /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n            /// onChange gets called when the editor changes but not when the var changes\n            let bindVarEditor setEvent getVal setVal onChange (var:Var<string>) =\n                let editorChanged = ref 0L\n                let varChanged    = ref 0L\n                setEvent(fun _ ->\n                    let v = getVal() \n                    if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange() \n                )\n                var.View |> View.Sink (fun _ ->\n                    if  !editorChanged > !varChanged then varChanged := !editorChanged\n                    elif getVal() <> var.Value then setVal var.Value\n                )\n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module Serializer =\n                \n                type SerS<'T> = ('T  -> string)        //      Serialization function\n                type SerD<'T> = (obj -> 'T    )        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>    // both Serialization functions\n                \n                let inline ifUndef  def v   = if isUndefined v then def   else   v\n                let inline ifUndefF def f v = if isUndefined v then def v else f v\n                \n                let (|Exists|_|) field o = if isUndefined o?(field) then None else Some o?(field)\n                \n                let deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n                \n                let serFloat  : Ser<float > = sprintU        , (unbox >> ifUndef 0.0   )\n                let serInt    : Ser<int   > = sprintU        , (unbox >> ifUndef 0     )\n                let serBool   : Ser<bool  > = sprintU        , (unbox >> ifUndef false )\n                let serString : Ser<string> = Json.Serialize , (unbox >> ifUndef \"\"    )\n            \n                let [< Inline >] inline serId  (get: 'a->System.Guid) (set:System.Guid->'a) (print: 'a->string) : Ser<'a> =\n                    let s           = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ          = sprintf \"%A\" s\n                    let serialize   = fun id       -> get id |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize = fun (x: obj) -> x?(s) |> deserGuid |> set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc o -> set (deser o) rc) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n                    let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, _ser,  deser) ->  deser dim (o?(n)) )   init\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser))               )\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toArray)\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\") , (unbox<obj  > >> ifUndefF (fun _ -> None     ) (         snd ser   >> Some      ))\n                let serDup serFst serSnd : Ser<'a * 'b    > = (fun (f,s) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s)), (unbox<obj[]> >> ifUndefF (fun _ -> snd serFst null, snd serSnd null ) (fun os -> snd serFst os.[0], snd serSnd os.[1] ) )\n                let serMap serKey serElm : Ser<Map<'k, 'e>> = serDup serKey serElm |> serSeq |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Map)       )\n            \n                let serVarField (name:string) (var:'D->Var<'e>) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, (var >> Var.Get >> ser), (fun rc o -> var rc |> Var.Set <| deser o ; rc)\n            \n                let serLMdField (name:string) (lmd:'D->ListModel<_,'e>) serE  : string * SerS<'D> * ('D -> SerD<'D>) = \n                    let serS              = serSeq serE\n                    let serializer   rc   = lmd rc |> (fun lm -> lm.Value) |> fst serS\n                    let deserializer rc b = lmd rc |> (fun lm -> lm.Set  ) <| snd serS b ; rc\n                    name, serializer, deserializer\n            \n            module LoadFiles =\n            \n                let createScript fn =\n                    let fileRef = JS.Document.CreateElement(\"script\")\n                    fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n                    fileRef.SetAttribute(\"src\" , fn                 )\n                    fileRef\n                \n                let createCss fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n                    fileRef.SetAttribute(\"type\", \"text/css\"       )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let createHtml fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"import\"         )\n                    fileRef.SetAttribute(\"type\", \"text/html\"      )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let LoadFile(file: string) =\n                    let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n                    match file with\n                    | EndsWith \".js\"   ()\n                    | EndsWith \".fsx\"  ()\n                    | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                            createScript file |> Some\n                    | EndsWith \".css\"  ()-> createCss    file |> Some\n                    | EndsWith \".html\" ()-> createHtml   file |> Some\n                    | _                  -> None\n                    |> Option.map         (fun ref -> \n                        Async.FromContinuations <| \n                            fun (cont, econt, _ccont) -> \n                                try \n                                    ref?onload <- cont\n                                    JS.Document.Head.AppendChild ref |> ignore\n                                with e -> econt e\n                    )\n                    |> Option.defaultWith (fun ()  -> async { return () })\n                \n                let LoadFilesAsync(files: string []) =\n                    async {\n                        if IsClient then\n                            for file in files do\n                                do! LoadFile file\n                    }\n                \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                try \n                    match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                    | null         -> None\n                    | [| |]        -> None\n                    | m            -> Some m\n                with e -> None\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            [< JavaScript >]\n            module Hoverable =\n                open WebSharper.UI.Html\n            \n                [<NoComparison ; NoEquality>]\n                type Hoverable         = { hover : Var<bool>        } with\n                    static member  New() = { hover = Var.Create false }\n                    member inline this.Attributes = [ attr.classDynPred (View.Const \"hovering\") this.hover.View\n                                                      on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n                                                      on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n                                                    ]   \n                    member inline this.Content    (ds: Doc seq) = div this.Attributes ds\n                    member inline this.Content    ( e: Elt    ) = e.OnMouseEnter(fun _ _ -> e.AddClass    \"hovering\") // THIS ONE ADDS ONE EXTRA SPACE\n                                                                   .OnMouseLeave(fun _ _ -> e.RemoveClass \"hovering\") // THAT THIS ONE DOES NOT REMOVE      \n                    //member inline this.Content    ( e: Elt    ) = e.WithAttrs this.Attributes\n                    static member  Demo  = Hoverable.New().Content(Elt.div [ attr.style \"flex-flow: column;\" ] [ text \"Hover over me!\" ])\n            \n                let hoverable (e:Elt) = Hoverable.New().Content e\n                \n            [< JavaScript >]\n            module ResizeObserver =\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module WebComponent =\n            \n                [< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\n                let ReflectConstruct () = X<_>\n                \n                [< Inline \"\"\"console.log('defineWebComponent: ' + $_nm);\n                            Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n                            Object.setPrototypeOf($_c, $global.HTMLElement);\n                            Object.setPrototypeOf($_o.prototype, $_c.prototype);\n                            $global.customElements.define($_nm, $_o)\"\"\" >]\n                let defineWebComponent _nm _o _c = X<_>\n            \n                module WcTabStrip =\n                    open WebSharper.UI.Html\n                    //open TabStrip\n                    open Hoverable\n                \n                    let css = @\"\n                .tab-panel {\n                 overflow  : hidden   ;\n                 display   : flex     ;\n                 flex-flow : column   ;\n                 background: lightgray;\n                 height    : 100%    ;\n                 width     : 100%    ;\n                }\n                .tab-content {\n                 flex      : 1 1     ;\n                 overflow  : auto    ;\n                 position  : relative;\n                }\n                .tab-children {\n                 height    : 100%    ;\n                 width     : 100%    ;\n                 position  : absolute;\n                 display   : grid    ;\n                }\n                .tab-strip {\n                 padding   : 0pt     ;\n                 flex      : 0 0     ;\n                }\n                .tab {\n                 border     : 0.2pt solid transparent;\n                 padding    : 0pt 4pt;\n                 display    : inline-block;\n                 font-family: sans-serif;\n                 font-weight: 200;\n                 font-size  : small;\n                 color      : #666;\n                 cursor     : pointer;\n                }\n                .top>.tab {\n                 border-radius: 2pt 2pt 0pt 0pt;\n                 border-bottom-width: 0pt;\n                 vertical-align: bottom;\n                }\n                .bottom>.tab {\n                 border-top-width: 0pt;\n                 border-radius: 0pt 0pt 2pt 2pt;\n                 vertical-align: top;\n                }\n                .horizontal>.tab:not(:first-child) {\n                 border-left-width: 0pt;\n                }\n                .tab.hovering {\n                 background: red;\n                }\n                .tab.selected {\n                 background: white;\n                 border-left-width: 0.2pt;\n                 color: black;\n                 font-weight: 500;\n                 border-color: black;\n                }\n                .horizontal>.tab.selected {\n                 border-left-width: 0.2pt;\n                }\n                ::slotted(*              ) { \n                 width : 100%;\n                 height: 100%;\n                }\n                        \"\n                \n                    let tabStrip (selected:Var<int>) top horizontal tabs content =\n                        let strip =\n                            div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\n                                                        (if top        then \"top\"        else \"bottom\"  ) \n                                                        (if horizontal then \"horizontal\" else \"vertical\")\n                                ]\n                                [ for i, (txt, _) in  tabs |> Seq.indexed  do\n                                      yield Hoverable.New().Content (\n                                          Elt.div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i + 1 then \" selected\" else \"\")) selected.View\n                                                    attr.draggable \"true\"\n                                                    on.click   (fun _  _  -> selected.Value <- i + 1 ) \n                                                  ]\n                                                  [ text txt ]) :> Doc\n                                ] \n                        div [ attr.``class`` \"tab-panel\" \n                                //on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n                                //on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n                            ]\n                            [   if     top then yield strip\n                                yield div [ attr.``class`` \"tab-content\" ] [ content ]\n                                if not top then yield strip\n                                yield Elt.Element \"style\" [] [ text css ] :> Doc\n                                yield Elt.Element \"style\" [] \n                                        [ Doc.TextView <| View.Map (sprintf \"\"\"\n                                              ::slotted(*              ) { display: none }\n                                              ::slotted(*:nth-child(%d)) { display: grid }\n                                           \"\"\") selected.View \n                                        ] \n                                    :> Doc\n                            ]\n                \n                    type WcTabStripT () =\n                        let mutable added = false\n                        let selected = Var.Create 1\n                        do printfn \"WcTabStripT initializer\"\n                        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcTabStripT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot       = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh = JS.Document.CreateElement \"div\"\n                                shadowRoot.AppendChild elsh |> ignore\n                                let addTab () =\n                                    //printfn \"my-el modified %A %A\" added this?outerHTML\n                                    let top  = el.HasAttribute \"bottom\" |> not\n                                    let tabs = [ for i in 1..el.ChildNodes.Length do \n                                                    let node = el.ChildNodes.[i - 1]\n                                                    if node.NodeType = Dom.NodeType.Element then\n                                                        let elem = node :?> Dom.Element\n                                                        let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                                        yield (tabName, elem)\n                                                ]\n                                    while elsh.ChildNodes.Length > 0 do\n                                        elsh.RemoveChild elsh.LastChild |> ignore\n                                    Elt.Element \"slot\" [] []\n                                    |> tabStrip selected top true tabs\n                                    |> Doc.Run elsh\n                                addTab()\n                                el.AddEventListener(\"DOMSubtreeModified\", delayed 50 addTab)\n                                added <- true\n                    let init =\n                        lazy\n                            let x = WcTabStripT().connectedCallback\n                            if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n                    \n                module WcSplitter =    \n                    open ResizeObserver\n                    \n                    type Layout = View<string> -> (Dom.Element -> unit) -> (Dom.Element -> unit) -> (Dom.MouseEvent -> unit) -> View<string> -> Doc\n                    \n                    let mutable layoutHorizontal : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    let mutable layoutVertical   : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n                    \n                    type WcSplitterT () =\n                        let mutable added = false\n                        do printfn \"WcSplitterT initializer\"\n                        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcSplitter.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n                        static member Constructor() = \n                            let this = ReflectConstruct()\n                            WcSplitterT.NewPointer?call this\n                            this\n                        member this.connectedCallback() = \n                            //printfn \"my-el connected %A %A\" added this?outerHTML\n                            if not added then\n                                let el : Dom.Element = this |> box |> unbox\n                                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                                let elsh        = JS.Document.CreateElement \"div\"\n                                let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n                                let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n                                let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n                                let first       =    el.HasAttribute \"second\"   |> not\n                                let vertical    =    el.HasAttribute \"vertical\"\n                                let size        = ref        (0.0, 0.0)\n                                let padding     = ref         0.0\n                                let gap         = Var.Create  0.0\n                                let sizeCalc (sh:Dom.Element) : float * float =\n                                    let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                                                 else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                                    let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                                    let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                                    gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                                    padding := pt + pb\n                                    el.GetBoundingClientRect() \n                                    |> fun r -> \n                                         match vertical, first with\n                                         | true , true  ->  r.Width , r.Height \n                                         | true , false -> -r.Width , r.Height\n                                         | false, true  ->  r.Height, r.Width\n                                         | false, false -> -r.Height, r.Width\n                                let dragging : bool               ref = ref false   \n                                let startP   : float              ref = ref 0.0\n                                let start    : float              ref = ref 0.0\n                                let domElem  : Dom.Element option ref = ref None                 \n                                let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                                let drag (ev: Dom.Event) =\n                                    ev :?> Dom.MouseEvent\n                                    |> mouseCoord\n                                    |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                                    |> fun v   -> value.Value <- min maxV (max minV v)\n                                   \n                                let rec finishDragging (_: Dom.Event) =\n                                    if !dragging then\n                                        dragging := false\n                                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                                let startDragging (ev: Dom.MouseEvent) =\n                                    if not !dragging then\n                                        dragging := true\n                                        startP   := value.Value\n                                        start    := mouseCoord ev\n                                        size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                                        ev.PreventDefault()\n                                    //div [\n                                    //    SomeAttr  <| on.mouseDown startDragging\n                                    //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                                    //    style     <| styleSplitter !gap\n                                    //    style        \"z-index: 10; background-color: #eef\"\n                                    //]\n                                let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                                             , (sz - gap - pad) * (100.0 - spl) / 100.0\n                                let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n                                let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n                                //div [ \n                                //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                                //    style <| Val.map styleSizes value\n                                //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                                //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                                //    slot [ name \"splitter\" ; splitter                                               ]\n                                //]\n                                let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n                                //addResizeObserver recalc el\n                                (if vertical then layoutVertical else layoutHorizontal)\n                                    <| View.Map styleSizes value.View\n                                    <| fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc()\n                                    <| fun  sp              -> domElem :=          Some sp ; recalc()\n                                    <| fun  me              -> startDragging me\n                                    <| View.Map (sprintf \"%Apx\") gap.View\n                                |> Doc.Run elsh\n                                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                                added <- true\n                    let init layoutH layoutV =\n                        let x = WcSplitterT().connectedCallback\n                        layoutHorizontal <- layoutH\n                        layoutVertical   <- layoutV\n                        if IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n                    \n            module Monaco =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri   = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f)\"  >] static member File(_f)       : Uri   = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8\n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (unit   -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             =\n                    div [ on.afterRender (fun elchild ->\n                             async {\n                                 do! loader\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                             } |> Async.Start\n                          )    \n                        ] []\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n        /// Essentials that part runs in Javascript and part runs in the server\n        [< AutoOpen >]\n        module Library2 =\n            module FsiAgent =\n                module ReaderM = ReaderMAsyncResult\n                open FsiEvaluator\n                open FsiCodePresence\n                open ReaderM.Operators\n            \n                [< JavaScript >]\n                type Config = Config of workDir:string * parms:string\n            \n                let queueOutput send =\n                    let output        = new System.Text.StringBuilder()\n                    let append    txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n                    let consume   ()  = let v = output.ToString()\n                                        output.Clear() |> ignore\n                                        v\n                    let queue         = Mailbox.iter print (fun msg -> \n                                            match msg with\n                                            | Some txt -> append txt\n                                            | None     -> let txt2send =  consume()\n                                                          if  txt2send <> \"\" then send txt2send\n                                        )\n                    fun          txt -> txt |> Some |> queue.Post\n                                        async { do! Async.Sleep 100\n                                                queue.Post None } |> Async.Start\n            \n                let mutable outHndl      = ignore\n                let mutable errHndl      = ignore\n            \n                let setQueueHandlers send =\n                    let queue = queueOutput send \n                    outHndl <-                  queue\n                    errHndl <- ((+) \"Err: \") >> queue\n            \n                let ctor (Config (workDir, config)) = \n                    new FsiExe(config, workDir, outHndl, errHndl) \n            \n                let fsiExeL = lazy new ResourceAgent<_, _>( 70\n                                                         , ctor\n                                                         , Config (\".\", \"--nologo --quiet\")\n                                                         , (fun fsi    -> (fsi :> System.IDisposable).Dispose())\n                                                         , (fun fsi    ->  fsi.IsAlive                         )\n                                                         )\n            \n                [< JavaScript >]\n                let extractConfig workDir (FsCode fsCode) = \n                    Config(\n                        FsCode.getSourceDir workDir <| String.splitByChar '\\n' fsCode\n                      , FsCode.extractDefines (FsCode fsCode)\n                        |> ((+) \" --nologo --quiet \")\n                    )\n            \n                [< Rpc >]\n                let evalCode workDir code = asyncResult {\n                    let config = extractConfig workDir code\n                    return!\n                        evaluateRm code\n                        //|> (fun vv -> vv)\n                        |> AgentReaderM.fromResourceRm\n                        //|> (fun vv -> vv)\n                        |> AgentReaderM.run fsiExeL.Value config\n                }\n            \n                [< Rpc >]\n                let evalCodeSameConfig code = asyncResult {\n                    return!\n                        evaluateRm code\n                        |> AgentReaderM.fromResourceRm\n                        |> AgentReaderM.runSameConfig fsiExeL.Value\n                }\n            \n                [< Rpc >]\n                let evalCodeWithPresence workDir presenceKey presenceValue presenceCodeF code = asyncResult {\n                    let config = extractConfig workDir code\n                    return!\n                        reader {        \n                            let! currentValueO = getPresenceRm presenceKey\n                            if   currentValueO <> Some presenceValue then\n                                let presenceCode   = presenceCodeF()\n                                let presenceConfig = extractConfig workDir presenceCode\n                                if  presenceConfig <> config then\n                                    do! Result.Error (ErrorMsg <| sprintf \"Presence and code configs are different: %A <--> %A\" presenceConfig config)\n                                do! evaluateRm    presenceCode |>> ignore\n                                do! addPresenceRm presenceKey presenceValue\n                            return! evaluateRm code\n                        }\n                        |> AgentReaderM.fromResourceRm\n                        |> AgentReaderM.run fsiExeL.Value config\n                }\n             \n                [<Rpc>]    \n                let abortFsiExe  () = fsiExeL.Value.Process(fun fsi -> fsi.Abort() )\n                \n                [<Rpc>]    \n                /// like abortFsiExe but prevents respawning until next command\n                let disposeFsiExe() = ((fsiExeL.Value.State.resource) :> System.IDisposable).Dispose()\n            \n            \n            [<WebSharper.JavaScript>]\n            module WebSockets =\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open WebSharper\n                \n                let MessageBrokerId  = \"<MessageBroker>\"\n                \n                type Address = Address of address:string\n                with member this.txt = match this with Address txt -> txt\n                \n                let MessageBrokerAddress = Address MessageBrokerId\n                \n                /// Requests made to Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerRequest = \n                    | BRGetConnections  /// request for list of connections\n                    | BRGetProcessId    /// request PID of broker process\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerReply = \n                    | BRConnections  of string[]\n                    | BRPid          of int\n                    | BRString       of string\n                  //  | BRPleaseClose  \n                \n                [< NamedUnionCases \"type\" >]\n                type MessageType = \n                    | MsgInformation             // does not expect a reply, payload may or may not be structured\n                    | MsgRequest                 // expects a reply, structured payload\n                    | MsgReply                   // structured payload.\n                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n                    | MsgRequestForId            // expects reply as Information with id\n                    | MsgRequestForEcho          // expects reply as Information with same payload\n                \n                /// Replies from Message Broker\n                [< NamedUnionCases \"type\" >]\n                type BrokerMessage = \n                    | BMOk\n                    | BMOnlyBrokerShouldUse\n                    | BMDestinationNotFound of Address  \n                    | BMWebSocketError      of string\n                    | BMReceiverCantReply\n                    | BMUnexpectedMsgType   of MessageType\n                    | BMUnexpectedResponse  of string\n                \n                [< NamedUnionCases \"type\" >]\n                type Replier = \n                    | NoReply\n                    | Broker\n                    | Receiver\n                \n                [< NamedUnionCases \"type\" >]\n                type MessageGeneric = {\n                    from          : Address\n                    destination   : Address\n                    msgType       : MessageType\n                    subtype       : string      // free short string that provides information to deserialize payload\n                    id            : System.Guid\n                    payload       : string\n                    replier       : Replier\n                }\n                \n                [< Inline >]\n                let inline processPayload f (payload:string) : string =\n                    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n                    |> f\n                    |> Json.Serialize\n                            \n                [<  Inline >]\n                let newMsgSerialized dst payload = {\n                    from          = Address \"\"\n                    destination   = dst\n                    msgType       = MsgRequest\n                    subtype       = \"\"\n                    id            = System.Guid.NewGuid()\n                    payload       = payload\n                    replier       = NoReply\n                }\n                \n                [< Inline >]\n                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\n                let inline from           frm msg = { msg with from          = frm               }\n                let inline destination    dst msg = { msg with destination   = dst               }\n                let inline msgType        typ msg = { msg with msgType       = typ               }\n                let inline subtype        sub msg = { msg with subtype       = sub               }\n                let inline replier        rpl msg = { msg with replier       = rpl               }\n                let inline msgId          id  msg = { msg with id            = id                }\n                \n                [<  Inline >]\n                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n                \n                [<  Inline >]\n                let inline msgPayload msg = Json.Deserialize msg.payload\n                \n                let mapPayload f msg = { msg with payload = f msg.payload }\n                \n                let inline makeReply msg =\n                    msg\n                    |> msgType MsgReply\n                    |> replier NoReply\n                \n                [<  Inline >]\n                let inline respond pyld msg =\n                    msg\n                    |> makeReply\n                    |> payload  pyld\n                \n                type IServer =\n                    abstract member Post  : MessageGeneric -> unit\n                    abstract member Close : unit           -> unit\n                \n                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n                \n                open System\n                open System.Threading\n                open System.Net.WebSockets\n                \n                [< JavaScript false >]\n                module Client =\n                    let startStateFull receive initAndfolder =\n                        async {\n                            let! initState, folder = initAndfolder\n                            let agentBox = Mailbox.foldA (fun ex st -> print ex; st) folder initState\n                            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n                            let error  a = agentBox.Post CMessage.Error ; finish a\n                            Async.StartWithContinuations(receive agentBox, finish, error, error)\n                        }\n                \n                    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n                        let conn = new ClientWebSocket()\n                        let chunkSize = 8192\n                        let send (txt:string)  =\n                            async {\n                                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                                let chunks = buffer.Length / chunkSize\n                                for i = 0 to chunks do\n                                    let last = i = chunks\n                                    let size = if last then buffer.Length % chunkSize else chunkSize\n                                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n                            }\n                        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n                            let buffer : byte[] = Array.create chunkSize 0uy\n                            let builder         = System.Text.StringBuilder()\n                            let keepgo          = ref true\n                            async {\n                                receiverBox.Post CMessage.Open\n                                while conn.State = WebSocketState.Open && !keepgo do\n                                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                                    match result.MessageType with\n                                    | WebSocketMessageType.Close -> keepgo := false\n                                    | WebSocketMessageType.Text ->\n                                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                                        builder.Append txt |> ignore\n                                        if result.EndOfMessage then\n                                            let txt = builder.ToString()\n                                            builder.Clear() |> ignore\n                                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                                    | _ -> ()\n                                return \"WebSocketServer receive Closed.\"\n                            }\n                        let brokerBox = Mailbox.iterA print (Json.Serialize >> send)\n                        let connect initAndfolder =\n                            async {\n                                printfn \"Connecting %s\" uri\n                                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                                printfn \"Connected %A\" WebSocketState.Open\n                                do! startStateFull receive initAndfolder\n                            }\n                        member this.WebSocket        = conn\n                        member this.Post (msg: 'C2S) = brokerBox.Post msg\n                        member this.Connect          = connect\n                \n                    let ConnectStateful<'S2C, 'C2S> uri getInitAndfolder =\n                        async {\n                            let  server          = WebSocketServer uri\n                            do!  server.Connect (getInitAndfolder server)\n                            return server\n                        }\n                \n                    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n                        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =\n                            f { new IServer with\n                                  member this.Post  v = serverP.Post v\n                                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                                        |> Async.AwaitTask |> Async.RunSynchronously            \n                               }\n                        ConnectStateful uri2 func\n                        |> Async.map ignore\n                        \n                //#I @\"..\\packages\\Owin\\lib\\net40\"\n                //#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n                //#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n                //#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n                \n                open System\n                open WebSharper.Owin.WebSocket\n                open WebSharper.Owin.WebSocket.Client\n                \n                //#define FSS_SERVER\n                //#define WEBSHARPER\n                \n                type  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n                \n                type ClientTypeFSharp    = FSharp\n                #if WEBSHARPER\n                type ClientTypeFSStation = FSStation\n                type ClientTypeJScript   = JScript\n                \n                [< Inline >]\n                let ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n                    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n                    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n                        f { new IServer with\n                              member this.Post  v = serverP.Post v\n                              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n                           }\n                    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n                    ConnectStateful endPoint func\n                    |> Async.map ignore\n                #endif\n                \n                module ReplyHandler =\n                    type WaitForReplyMsg =\n                        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n                        | Reply  of Guid *   MessageGeneric\n                        | Excpn  of Guid *   exn\n                        | Cancel of Guid *   OperationCanceledException\n                        \n                    type Handler (defProc) =\n                        let waitingAgent =    \n                            Mailbox.fold Mailbox.defHandler (fun waitingForReply action ->\n                                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def\n                                                      Map.remove  key     waitingForReply\n                                match action with\n                                | Add   (key, fns) -> Map.add     key fns waitingForReply\n                                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)\n                                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore\n                                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore\n                            ) Map.empty\n                        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post\n                        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post\n                        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post\n                        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post\n                \n                [< Inline \"window.location.href\" >]\n                let getEndPoint() = \n                #if FSS_SERVER\n                    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n                #else\n                    \"http://localhost:9005/\"\n                #endif\n                \n                let extractEndPoint() = \n                    let ep : string = getEndPoint()\n                    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n                    ep2.Split('/').[0]\n                \n                type WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n                        , clientId:string, ?timeout:int, ?endPoint:string) =    \n                    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n                    let clientAddress = Address clientId\n                    let wsTimeout     = defaultArg timeout 60000\n                \n                    let mutable out = printfn \"%s\"\n                    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n                    let mutable serverO : IServer option = None\n                    let mutable payloadProcessorO : (string -> Async<string>) option = None\n                    let waiting = ReplyHandler.Handler (fun msg -> printfn \"Reply from '%s': %s\" msg.from.txt msg.payload)\n                \n                    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n                    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n                \n                    let processReply      msg = waiting.Reply msg.id msg\n                    let mapPayloadWrap (fW: _ -> Async<_> ) msg =\n                        async {\n                            let! r  = fW msg.payload\n                            return msg |> mapPayload (fun _ -> r)\n                        }\n                    let processMessage msg =\n                        //printfn \"%A\" msg\n                        match msg.msgType with\n                        | MsgFromBroker     \n                        | MsgReply           -> processReply msg\n                        | MsgInformation     -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                        | MsgRequest         -> match payloadProcessorO with \n                                                | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                                                | Some processor ->\n                                                msg |> mapPayloadWrap processor |> Async.iterA (makeReply >> reply) \n                        | MsgRequestForEcho  -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n                        | MsgRequestForId    -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n                    \n                    let connectToWebSocketServer() =\n                        printfn \"in connectToWebSocketServer\"\n                        async {\n                            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                                return 0, fun state wsmsg -> async {\n                                    try match wsmsg with\n                                        | CMessage.Message msg -> processMessage msg\n                                        | CMessage.Open        -> printfn \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                                        | CMessage.Close       -> printfn \"WebSocket %s connection closed.\" clientId ; close()\n                                        | CMessage.Error       -> printfn \"WebSocket %s connection error!\"  clientId\n                                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                                    return state\n                                }\n                            }\n                            printfn \"connectToWebSocketServer with server\"\n                            \n                        }\n                \n                    let checkServer = Mailbox.callA print ( fun () -> async {\n                        printfn \"getServer\"\n                        if serverO.IsNone then\n                            printfn \"getServer Connecting\"\n                            do! connectToWebSocketServer()\n                            do! Async.Sleep 200\n                        return serverO |> Result.ofOption (fun () -> ErrorMsg \"could not connect to Server\")\n                    })        \n                \n                    let getServer() : AsyncResult<IServer, _> = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n                        \n                    let postR (server: IServer) rpl msg = \n                        let m = msg |> from clientAddress |> replier rpl \n                        try       server.Post m\n                        with e -> serverO <- None\n                                  raise e\n                \n                    let sendAndForget msg = asyncResult {\n                        let! server = getServer()\n                        msg |> postR server NoReply\n                    }\n                        \n                    let sendAndReply rpl msg = asyncResult {\n                        let! server  = getServer()\n                        let  replyA  = Async.FromContinuations(fun fns -> \n                            waiting.Add msg.id fns\n                            msg |> postR server rpl\n                            if wsTimeout > 0 then\n                                async {\n                                    do! Async.Sleep wsTimeout\n                                    waiting.Raise msg.id (TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn)\n                                } |> Async.Start\n                        )\n                        return! replyA\n                    }\n                        \n                    let sendAndVerify msg = asyncResult {\n                        let! reply   = sendAndReply Broker msg \n                        do!  match reply.msgType with\n                             | MsgFromBroker  -> let  bm = msgPayload reply\n                                                 if   bm = BMOk \n                                                 then Result.Ok    () \n                                                 else Result.Error <| ResultMessage.Message bm\n                             | _              ->      Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                    }\n                    \n                    let sendGetReply msg =\n                        asyncResult {\n                            let! reply   = sendAndReply Receiver msg \n                            let! result =\n                                match reply.msgType with\n                                | MsgReply      -> Result.Ok     reply.payload\n                                | MsgFromBroker -> let bm = msgPayload reply\n                                                   Result.Error <| ResultMessage.Message bm\n                                | _             -> Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n                            return result\n                        }\n                \n                    let getListeners() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRConnections listeners -> return listeners\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let getProcessId() =\n                        asyncResult {\n                            let  msg    = newMsg MessageBrokerAddress BRGetProcessId\n                            let! reply  = sendGetReply msg\n                            match Json.Deserialize<BrokerReply> reply with\n                            | BRPid pid -> return pid\n                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n                        } \n                        \n                    let sendMsg msg =\n                        asyncResult {\n                            if msg.replier = NoReply\n                            then do!     sendAndForget msg\n                                 return  \"\"\n                            else return! sendGetReply  msg\n                        }\n                    member this.MBListeners            = getListeners()\n                    member this.MBProcessId            = getProcessId()\n                    member this.EndPoint               = wsEndPoint\n                    member this.ClientId               = clientId\n                    member this.SendMsg           msg  = sendMsg msg\n                    [<  Inline >]\n                    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n                    [<  Inline >]\n                    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n                    [<  Inline >]\n                    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> AsyncResult.map Json.Deserialize\n                    member this.Out with set fout      = out <- fout\n                    [<  Inline >]\n                    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Async.map Json.Serialize))\n                                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                                         |> msgType MsgInformation\n                                                         |> sendAndForget |> AsyncResult.iterA (string >> failwith) id\n                    interface IDisposable with\n                        member this.Dispose() = close()\n                \n                #if FSS_SERVER   \n                    [< JavaScript false >]\n                    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                    [< JavaScript false >]\n                    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #if WEBSHARPER\n                    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n                #endif\n                \n                \n            type FSMessage =\n            | MsgGetId\n            | MsgGetSnippets     of SnippetReference[]\n            | MsgGetCode         of SnippetReference\n            | MsgGetPredecessors of SnippetReference\n            | MsgAction          of string[]\n            | MsgGetUrl\n            \n            type FSResponse =\n            | RespString         of string\n            | RespSnippets       of Snippet[]\n            \n            module FSharpStationClient =\n                open WebSockets\n            \n                let mutable fsharpStationAddress = Address \"FSharpStation1538598585997\"\n            \n                let [< Rpc >] setAddress address = async { \n                    fsharpStationAddress <- address \n                    printfn \"set %A\" fsharpStationAddress\n                }\n            \n                let fsharpStationClient, sendMessage : WSMessagingClient * (FSMessage -> AsyncResult<FSResponse, _>) = \n                    let client =\n            #if WEBSHARPER \n                        if IsClient then \n                            new WSMessagingClient(\"FSharpStationClientJS\"       )\n                        else\n            #endif            \n            #if FSS_SERVER            \n                            new WSMessagingClient(\"FSharpStationClientFSStation\", FSStation)\n            #else\n                            new WSMessagingClient(\"FSharpStationClientFSharp\"   , FSharp)\n            #endif\n                    client, fun m -> client.SendGetReply fsharpStationAddress m |> AsyncResult.absorbR\n            \n                let respString response = asyncResult { \n                    match response with\n                    | RespString code -> return code\n                    | _               -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n                }\n            \n                let getCode path = \n                    path\n                    |> String.splitByChar '/'\n                    |> RefSnippetPath\n                    |> MsgGetCode\n                    |> sendMessage\n                    |> AsyncResult.bind respString\n            \n                let getUrl () = sendMessage MsgGetUrl |> AsyncResult.bind respString\n            \n                let sendOutput    txt = [| \"AddOutput\" ; txt |]\n                                        |> MsgAction\n                                        |> sendMessage\n                                        \n                let getBrokerProcessId() = fsharpStationClient.MBProcessId\n            module FsAutoComplete =\n                [<JavaScript>]\n                module CommTypes =\n                    type ResponseError =\n                        {\n                          Code: int\n                          Message: string\n                          //AdditionalData: 'T\n                        }\n                    type Location =\n                      {\n                        File: string\n                        Line: int\n                        Column: int\n                      }\n                    type CompletionResponse =\n                      {\n                        Name: string\n                        ReplacementText: string\n                        Glyph: string\n                        GlyphChar: string\n                      }\n                    //type ProjectResponse =\n                    //  {\n                    //    Project: ProjectFilePath\n                    //    Files: List<SourceFilePath>\n                    //    Output: string\n                    //    References: List<ProjectFilePath>\n                    //    Logs: Map<string, string>\n                    //  }\n                    type OverloadDescription =\n                      {\n                        Signature: string\n                        Comment  : string\n                        Footer   : string\n                      }\n                    type OverloadParameter =\n                      {\n                        Name : string\n                        CanonicalTypeTextForSorting : string\n                        Display : string\n                        Description : string\n                      }\n                    type Overload =\n                      {\n                        Tip : OverloadDescription list list\n                        TypeText : string\n                        Parameters : OverloadParameter list\n                        IsStaticArguments : bool\n                      }\n                    type Parameter = {\n                        Name : string\n                        Type : string\n                      }\n                    type SignatureData = {\n                        OutputType : string\n                        Parameters : Parameter list list\n                      }\n                    type MethodResponse =\n                      {\n                        Name : string\n                        CurrentParameter : int\n                        Overloads : Overload list\n                      }\n                    type SymbolUseRange =\n                      {\n                        FileName: string\n                        StartLine: int\n                        StartColumn: int\n                        EndLine: int\n                        EndColumn: int\n                        IsFromDefinition: bool\n                        IsFromAttribute : bool\n                        IsFromComputationExpression : bool\n                        IsFromDispatchSlotImplementation : bool\n                        IsFromPattern : bool\n                        IsFromType : bool\n                      }\n                    type SymbolUseResponse =\n                      {\n                        Name: string\n                        Uses: SymbolUseRange list\n                      }\n                    type HelpTextResponse =\n                      {\n                        Name: string\n                        Overloads: OverloadDescription list list\n                      }\n                    type CompilerLocationResponse =\n                      {\n                        Fsc: string\n                        Fsi: string\n                        MSBuild: string\n                      }\n                    type FSharpErrorInfo =\n                      {\n                        FileName    : string\n                        StartLine   : int\n                        EndLine     : int\n                        StartColumn : int\n                        EndColumn   : int\n                        Severity    : string\n                        Message     : string\n                        Subcategory : string\n                      }\n                    type ErrorResponse =\n                      {\n                        File: string\n                        Errors: FSharpErrorInfo []\n                      }\n                    type Colorization =\n                      {\n                    //    Range: Range\n                        Kind: string\n                      }\n                    type Declaration =\n                      {\n                        UniqueName: string\n                        Name: string\n                        Glyph: string\n                        GlyphChar: string\n                        IsTopLevel: bool\n                    //  Range     : Utils.Range\n                    //    BodyRange : Utils.Range\n                        File : string\n                        EnclosingEntity: string\n                        IsAbstract: bool\n                      }\n                    type DeclarationResponse = {\n                        Declaration : Declaration;\n                        Nested : Declaration []\n                    }\n                    type OpenNamespace = {\n                      Namespace : string\n                      Name : string\n                      Type : string\n                      Line : int\n                      Column : int\n                      MultipleNames : bool\n                    }\n                    type QualifySymbol = {\n                      Name : string\n                      Qualifier : string\n                    }\n                    type ResolveNamespaceResponse = {\n                      Opens : OpenNamespace []\n                      Qualifies: QualifySymbol []\n                      Word : string\n                    }\n                    type UnionCaseResponse = {\n                      Text : string\n                    //  Position : Pos\n                    }\n                    type Kind = \n                    | KInfo             of string\n                    | KError            of ResponseError\n                    | KHelpText         of HelpTextResponse\n                    | KCompletion       of CompletionResponse  []\n                    | KSymbolUse        of SymbolUseResponse\n                    | KHelp             of string\n                    | KMethod           of MethodResponse\n                    | KErrors           of ErrorResponse\n                    | KColorizations    of Colorization list\n                    | KFindDecl         of Location\n                    | KDeclarations     of DeclarationResponse []\n                    | KToolTip          of OverloadDescription [][]\n                    | KTypeSig          of string\n                    | KSignatureData    of SignatureData\n                    | KCompilerLocation of CompilerLocationResponse\n                    | KNamespaces       of ResolveNamespaceResponse\n                    | KUnionCase        of UnionCaseResponse\n                    | KMultiple         of Kind                []\n                    \n                //#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n                //#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n                //#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n                \n                open System.Net\n                open System.Text\n                open System.IO\n                open FSharp.Data\n                open FSharp.Data.JsonExtensions\n                open Newtonsoft.Json\n                \n                open Utils\n                \n                open CommTypes\n                \n                type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n                type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n                type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n                type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n                type ProjectRequest       = { FileName  : string                                                                                                               }\n                type LintRequest          = { FileName  : string                                                                                                               }\n                type HelptextRequest      = { Symbol    : string                                                                                                               }\n                type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n                \n                type FARequest =\n                    | FarParse         of ParseRequest         \n                    | FarDeclarations  of DeclarationsRequest  \n                    | FarCompletion    of CompletionRequest    \n                    | FarPosition      of PositionRequest      \n                    | FarProject       of ProjectRequest       \n                    | FarLint          of LintRequest          \n                    | FarHelptext      of HelptextRequest      \n                    | FarWorkspacePeek of WorkspacePeekRequest    \n                \n                let toJson =\n                    function\n                    | FarParse         data -> JsonConvert.SerializeObject data \n                    | FarDeclarations  data -> JsonConvert.SerializeObject data \n                    | FarCompletion    data -> JsonConvert.SerializeObject data \n                    | FarPosition      data -> JsonConvert.SerializeObject data \n                    | FarProject       data -> JsonConvert.SerializeObject data \n                    | FarLint          data -> JsonConvert.SerializeObject data \n                    | FarHelptext      data -> JsonConvert.SerializeObject data \n                    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n                \n                let fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\n                let jsonData2Obj item = item?Data.ToString() |> fromJson\n                \n                let HttpRequestCall (url:string) (data:string) =\n                    async {\n                        //printfn \"RpcCall %s\" (extract 100 data)\n                        let req = WebRequest.Create(url) :?> HttpWebRequest \n                        req.Timeout         <- 300_000\n                        req.ProtocolVersion <- HttpVersion.Version10\n                        req.Method          <- \"POST\"\n                        req.ContentType     <- \"application/json\"\n                        let postBytes = Encoding.ASCII.GetBytes(data)\n                        //printfn \"<---\\n%s\\n\" data\n                        req.ContentLength <- int64 postBytes.Length\n                        let reqStream = req.GetRequestStream() \n                        reqStream.Write(postBytes, 0, postBytes.Length);\n                        reqStream.Close()\n                        use resp   = req.GetResponse() \n                        use stream = resp.GetResponseStream() \n                        use reader = new StreamReader(stream)\n                        let msg    = reader.ReadToEnd()\n                        //print msg\n                        //printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n                        let jsonV  = JsonValue.Parse msg\n                        return       jsonV\n                    }\n                \n                let KindError msg = KError { Code = 0 ; Message = msg }\n                \n                let json2Kind (v:JsonValue) = \n                    let item =JsonValue.Parse <| v.AsString()\n                    match item?Kind.AsString() with\n                    | \"info\"             -> jsonData2Obj item |> KInfo\n                    | \"error\"            -> jsonData2Obj item |> KError\n                    | \"errors\"           -> jsonData2Obj item |> KErrors\n                    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n                    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n                    | \"completion\"       -> jsonData2Obj item |> KCompletion\n                    | \"signature\"        -> jsonData2Obj item |> KTypeSig\n                    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n                    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n                    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n                    | \"helptext\"         -> jsonData2Obj item |> KHelpText\n                    | \"declarations\"     -> jsonData2Obj item |> KDeclarations\n                    | \"symboluse\"        -> jsonData2Obj item |> KSymbolUse\n                    | _                  -> KindError <| v.ToString()\n                \n                let UrlAddress = \"http://localhost:9001/\"\n                \n                [< Rpc >]\n                let FSAutocompleteCall0 cmd (req: FARequest) : Async<Result<Kind [],ResultMessage<Kind[]>>> = asyncResult {\n                        let  data          = req |> toJson\n                        let! jsonV         = HttpRequestCall (UrlAddress + cmd) data\n                        return               jsonV.AsArray() |> Array.map json2Kind\n                    } \n                \n                [<JavaScript ; AutoOpen>]\n                module Calls =\n                    let FSAutocompleteCall cmd f req = asyncResult {\n                            let! several       = FSAutocompleteCall0 cmd req\n                            let  goods, others = several |> Array.partition (f >> Option.isSome)\n                            let! good          = goods   |> Seq.choose f |> Seq.tryHead |> Result.ofOption (fun () -> others |> Message)\n                            return               good, others\n                        } \n                    \n                    let parseCode        file code asy ver   = FSAutocompleteCall \"parse\"               (function KErrors        v -> Some v |_-> None)\n                                                                     <| FarParse       { FileName        = file\n                                                                                         IsAsync         = asy   \n                                                                                         Lines           = code           \n                                                                                         Version         = ver\n                                                                                       }\n                    let toolTip          file lin col filter = FSAutocompleteCall \"tooltip\"             (function KToolTip       v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signature        file lin col filter = FSAutocompleteCall \"signature\"           (function KTypeSig v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let signatureData    file lin col filter = FSAutocompleteCall \"signatureData\"       (function KSignatureData v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let completion  tx kw file ln col filter = FSAutocompleteCall \"completion\"          (function KCompletion    v -> Some v |_-> None)\n                                                                      <| FarCompletion { FileName        = file\n                                                                                         Line            = ln         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                         SourceLine      = tx\n                                                                                         IncludeKeywords = kw\n                                                                                        }\n                    \n                    let findTypeDecl     file lin col filter = FSAutocompleteCall \"findtypedeclaration\" (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let findDeclaration  file lin col filter = FSAutocompleteCall \"finddeclaration\"     (function KFindDecl    v -> Some v |_-> None)\n                                                                      <| FarPosition    { FileName       = file\n                                                                                          Line           = lin         \n                                                                                          Column         = col\n                                                                                          Filter         = filter\n                                                                                        }\n                    let declarations    file code ver        = FSAutocompleteCall \"declarations\"       (function KDeclarations v -> Some v |_-> None)\n                                                                      <| FarDeclarations{ FileName       = file\n                                                                                          Lines          = code         \n                                                                                          Version        = ver\n                                                                                        }\n                    let helpText               symbol        = FSAutocompleteCall \"helptext\"            (function KHelpText     v -> Some v |_-> None)\n                                                                      <| FarHelptext    { Symbol         = symbol\n                                                                                        }\n                    let symbolUse       file lin col filter  = FSAutocompleteCall \"symboluse\"           (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    let symbolUseProject file lin col filter = FSAutocompleteCall \"symboluseproject\"    (function KSymbolUse     v -> Some v |_-> None)\n                                                                     <| FarPosition    { FileName        = file\n                                                                                         Line            = lin         \n                                                                                         Column          = col\n                                                                                         Filter          = filter\n                                                                                       }\n                    \n                    \n    \n    //#cd @\"..\\projects\\FSharpStation\\src\"\n    //#define WEBSHARPER\n    [< JavaScript >]\n    module FSharpStation =\n        module FStation =\n        \n            let [< Rpc >] getRootDir() = async {\n                //let res = let dir = System.Environment.CurrentDirectory\n                          //if dir.EndsWith @\"\\bin\" |> not then dir else\n                          //dir.[0..dir.Length - 5] |>! fun set -> System.Environment.CurrentDirectory <- set\n                return System.Environment.CurrentDirectory //res\n            }\n        \n            [< Inline \"(Date.now())\" >]\n            let now() = 0\n            let id = \"FSharpStation\" + (now() |> string)\n        \n            let mutable rootDir  = \".\"\n            let mutable srcDir   = \".\"\n            async {\n                let! dir = getRootDir()\n                rootDir   <- dir +/+ \"..\"\n                srcDir    <- dir +/+ \"..\\\\src\"\n                printfn \"fileName = %s\\\\%s.fsx\" srcDir id\n            } |> Async.Start\n            \n            let annotationsV = Var.Create \"\"\n        \n        module Snippets =\n            open TreeReader\n            module ReaderM = ReaderMResult\n            open ReaderM.Operators\n            \n            let private snippets               = ListModel<SnippetId, Snippet> (fun s -> s.snpId)\n            let private hierarchy              = Var.Create [||]\n            let private generation             = Var.Create 5\n            let private currentSnippetIdOV     = Var.Create (None:SnippetId option)\n            let private codeSnippetIdOV        = Var.Create (None:SnippetId option)\n            let private collapsedV             = Var.Create Set.empty\n            \n            let predsCache , clearPreds        = Memoize.checkStore()\n            let reducCache , clearReduc        = Memoize.checkStore()\n            let parentCache, clearParent       = Memoize.checkStore()\n            let clearPredsCache ()             = clearPreds ()\n                                                 clearReduc ()\n                                                 clearParent()\n            let prepCode                   snp = snp.snpContent\n                                                    .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , FStation.id            )\n                                                    .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href)\n            let snippetsColl                () = { generation       = generation.Value\n                                                   ordered          = snippets.Value\n                                                   fetcher          = snippets.TryFindByKey\n                                                   predecesorsCache = fun _ -> predsCache\n                                                   reducedCache     = fun _ -> reducCache\n                                                   prepCode         = prepCode\n                                                   }\n            let handleError                 er = (er:ResultMessage<string>) |> string |> exn |> raise\n            let iterReader                  rm = rm |> ReaderM.iter  handleError id (snippetsColl())\n            let runReaderResult             rm = rm |> ReaderM.run                  (snippetsColl()) \n            let runReader            handle rm = rm |> runReaderResult |> Result.defaultWith handle \n               \n            let setCurrentSnippetIdO snpIdO    = currentSnippetIdOV.Set snpIdO\n            let setSnippet                 snp = if snp.snpId.Id <> System.Guid.Empty then snippets.Add { snp with snpGeneration = generation.Value + 1 }\n            let getSnippetsGen              () = snippets.Value, generation.Value, collapsedV.Value\n        \n            let getParentIdONotMemo      snpId = snippets.TryFindByKey snpId |> Option.bind(fun s -> s.snpParentIdO)\n            let getParentIdO                   = getParentIdONotMemo |> Memoize.memoizeStore (fun () -> parentCache) \n            let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                                 getParentIdO snpId\n                                                 |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                                 |> Option.defaultValue false\n        \n            if IsClient then\n                currentSnippetIdOV.View |> View.Sink (\n                    function\n                    | None       -> ()\n                    | Some curId ->\n                    match codeSnippetIdOV.Value with\n                    | None       -> codeSnippetIdOV.Set (Some curId)\n                    | Some codId ->\n                    codId\n                    |>  Snippet.snippetORm\n                    |>> Option.map Snippet.uniquePredsRm \n                    >>= ReaderM.insertO\n                    |>> Option.toList\n                    |>> List.collect  id\n                    |>> List.contains curId\n                    |>> function false -> codeSnippetIdOV.Set (Some curId) |_->()\n                    |>  iterReader\n                    clearPredsCache()\n                )\n        \n            if IsClient then\n                hierarchy.View |> View.Map (Array.map (fun n -> n.id()) ) |> View.consistent |> View.Sink (fun ids ->\n                    clearPredsCache()\n                    [| for sid in ids do\n                        yield  snippets.FindByKey sid\n                        yield! snippets.Value |> Seq.filter(fun snp -> isDescendantOf sid snp.snpId)\n                    |]\n                    |> snippets.Set\n                )\n        \n            let CurrentSnippetIdW              = currentSnippetIdOV.View |> View.Map (fun sidO -> sidO |> Option.defaultValue Snippet.defaultSnippet.snpId)\n            let currentSnippetW                = currentSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let    codeSnippetW                =    codeSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n            let currentSnippetV                = Var.Make currentSnippetW setSnippet\n            let selectedClassW           snpId = V (if Some snpId = currentSnippetIdOV.V then \"selected\"    else \"\")\n            let codeSnippetClassW        snpId = V (if Some snpId =    codeSnippetIdOV.V then \"codeSnippet\" else \"\")\n            let findSnippetW             snpId = snippets.TryFindByKeyAsView snpId |> View.Map (Option.defaultValue Snippet.defaultSnippet)\n            let findSnippetV             snpId = Var.Make (findSnippetW snpId) setSnippet\n            let getHierarchyW                  = hierarchy.View \n                                                 |> View.Map2(fun _ -> TreeReader.listNodes 0 >> runReader  handleError) collapsedV.View\n                                                 |> View.Map (Seq.map (fun (tn,l) -> tn.id(), l) ) \n                                                 |> View.Map  Seq.toArray\n            //let codeAndStartsRm            snp =  >>= Snippet.codeAndStartsRm \n            let codeAndStartsW                 = (codeSnippetW, snippets.View) \n                                                 ||> View.MapAsync2 (fun _ _ -> async {\n                                                    do! Async.Sleep 350\n                                                    return\n                                                       Snippet.fastCodeRm currentSnippetIdOV.Value codeSnippetIdOV.Value\n                                                       |> runReader handleError\n                                                 }) \n            let FsCodeW                        = codeAndStartsW |> View.Map fst\n            let codeStartsW                    = codeAndStartsW |> View.Map snd\n            let hasChangedW                snp = V (generation.V < snp.snpGeneration )\n            let SaveAsClassW                   = View.Map2 (fun snps gen -> if Seq.exists (fun snp -> snp.snpGeneration > gen) snps then \"btn-primary\" else \"\") \n                                                    snippets  .View \n                                                    generation.View\n                                                    \n            let setChildrenRm snpId ch = reader {\n                let chIds = ch |> Array.map (fun s -> s.id())\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n                |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n                |> Seq.iter    setSnippet\n                snippets\n                |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n                |> Seq.map    (fun s -> { s with snpParentIdO = None })\n                |> Seq.iter    setSnippet\n                clearPredsCache()\n                let descendants, others = snippets.Value |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n                let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n                [| yield! others.[0..index]\n                   for chid in chIds do\n                       yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n                       yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n                   yield! others.[index+1..]\n                |]\n                |> snippets.Set\n            }\n        \n            let rec treenode (snpId:SnippetId) =\n                {\n                    id                 = fun () -> snpId\n                    isExpandedRm       = fun () -> rtn (not <| Set.contains snpId collapsedV.Value)\n                    canHaveChildrenRm  = fun () -> rtn true\n                    childrenRm         = fun () -> Snippet.childrenRm snpId |>> Seq.map (fun snp -> treenode snp.snpId)\n                    newChildrenRm      = fun ch -> setChildrenRm snpId ch   |>> fun () -> \n                                                   treenode      snpId\n                    parentORm          = fun _ns-> Snippet.snippetORm snpId |>> Option.bind (fun x -> x.snpParentIdO) |>> Option.map treenode\n                    pathRm             = fun () -> Snippet.pathRm snpId\n                }\n                \n            let isIndirectPredecessorW snpId = \n                currentSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let isIncludedPredecessorW snpId = \n                codeSnippetW \n                |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                        |>> Seq.contains snpId\n                                        |>  runReader (fun _ -> false))\n            \n            let togglePredecessor predId =\n                let preds = Lens currentSnippetV.V.snpPredIds\n                preds.Value\n                |> (if Set.contains predId preds.Value then Set.remove else Set.add) predId\n                |> preds.Set\n                clearPredsCache()\n                \n            let expandClassRm snpId =\n                Snippet.childrenRm snpId        >>= fun chs -> \n                if Seq.isEmpty chs then rtn \"\" else\n                (treenode snpId).isExpandedRm() |>> fun exp -> \n                if exp then \"expanded\" else \"collapsed\"\n            \n            let expandClassW snpId = snippets.View |> View.Map2 (fun _ _ -> expandClassRm snpId |> runReader handleError) collapsedV.View\n            \n            let deleteCurrentSnippet _ =\n                currentSnippetIdOV.Value\n                |> Option.iter (fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.removeNodeOutdentChildren (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>> fun () -> snippets.RemoveByKey snpId\n                    |>  iterReader\n                )\n                \n            let indentIn _ =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.indentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let indentOut _ =\n                currentSnippetIdOV.Value\n                |> Option.iter(fun snpId ->\n                    hierarchy.Value\n                    |>  TreeReader.outdentNode (treenode snpId)\n                    |>> Seq.toArray\n                    |>> hierarchy.Set\n                    |>  iterReader\n                )\n                   \n            let moveNode fnid tnid =\n                hierarchy.Value\n                |>  TreeReader.moveToSibling2 false fnid tnid\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let updateGeneration() =\n                reader {\n                    let! max = Snippet.maxGenerationRm()\n                    generation.Set max\n                } |> iterReader\n        \n            let setSnippetsGen snps coll =\n                collapsedV.Set coll\n                snippets  .Set snps\n                updateGeneration()\n                snps \n                |>  Seq.map(fun snp -> Snippet.parentORm snp |>> function None -> Some snp |_-> None )\n                |>  ReaderM.sequenceSeq\n                |>> Seq.choose id\n                |>> Seq.map (fun snp -> treenode snp.snpId)\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                |>  iterReader\n        \n            let addSnippetRm snp = \n                snippets.Add snp\n                let hier = hierarchy.Value |> Seq.append [| treenode snp.snpId |]\n                currentSnippetIdOV.Value\n                |>  Option.map Snippet.snippetORm |> ReaderM.insertO |>> Option.bind id\n                >>= function\n                | None     -> hier |> rtn\n                | Some sbl -> hier |> TreeReader.moveToSibling2 true snp.snpId sbl.snpId\n                |>> Seq.toArray\n                |>> hierarchy.Set\n                \n            let newSnippet _ =\n                let snp = Snippet.New \"\" \"\" None\n                addSnippetRm snp\n                |>> fun () -> currentSnippetIdOV.Set (Some snp.snpId)\n                |>  iterReader\n                \n            let toggleCollapse snpId =\n                if Set.contains snpId collapsedV.Value then Set.remove else Set.add\n                <| snpId\n                <| collapsedV.Value\n                |> collapsedV.Set\n        \n            let expandParents snpId =\n                Snippet.pathRm snpId\n                |>> (fun path -> collapsedV.Value - Set path |> collapsedV.Set)\n                |> iterReader\n            \n        module DragDrop =\n        \n            type DragInfo = \n                | DragNone\n                | DragNode of SnippetId\n            \n            let mutable drag        = DragNone\n            let setDragNone ()      = drag <- DragNone\n            let setDragNode tnid    = drag <- DragNode tnid\n            \n            let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n            \n            let [< Inline >] inline moveItem dropId elems getId item =\n                elems\n                |> Seq.filter (getId >> ((<>) (getId item)) )\n                |> Seq.toArray\n                |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                             [fst ; [| item |] ; snd])\n                |> Seq.collect id\n                |> Seq.toArray\n            \n            let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n            let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n            \n            let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n            \n        [< AutoOpen >]\n        module Templating =\n            open WebSharper.UI.Templating\n            let [< Literal >] rootdir = @\"..\\website\"\n        \n            let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n            type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n            if IsClient then printfn \"%s\" TemplatesFileName\n        \n        module RenderSnippets =\n            open Snippets\n            \n            let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then e?scrollIntoViewIfNeeded()) \n            \n            let snippets () = \n                Snippets.getHierarchyW\n                |> Doc.BindSeqCached (fun (snpId, l) ->\n                    let snpW     = findSnippetW snpId\n                    let nameW    = View.Do {\n                                        let! snp     = snpW\n                                        let! changed = Snippets.hasChangedW snp\n                                        let  name    = Snippet.snippetName snp.snpName snp.snpContent\n                                        return (if changed then \"*\" else \"\") + name\n                                    }\n                    //let pathW = V( Snippets.getHierarchyW |> (fun _ -> (Snippets.treenode snpId).path () |> Seq.map (fun n -> string n.Id) |> String.concat \" - \") )\n                    let predW    = V(if currentSnippetV.V.snpPredIds |> Set.contains snpId then \"direct-predecessor\"   else\n                                     if (isIndirectPredecessorW snpId).V                   then \"indirect-predecessor\" else \n                                     if (isIncludedPredecessorW  snpId).V                  then \"included-predecessor\" else \"\" )\n                    let errorW   = FStation.annotationsV.View |> View.Map (String.contains <| snpId.Id.ToString() >> function true -> \"ErrorMsg\" |_-> \"\" )\n                    TemplateLib.Snippet()\n                        .Name(          nameW                                                                                        )\n                        .Indent(        string l                                                                                     )\n                        .Parent(        expandClassW snpId                                                                           )\n                        .Predecessor(   predW                                                                                        )\n                        .Selected(    [ (selectedClassW snpId).V ; (codeSnippetClassW snpId).V ] |> String.concat \" \"                )\n                        .ErrorMsg(      errorW                                                                                       )\n                        .Select(        fun _  -> setCurrentSnippetIdO <| Some snpId                                                 )\n                        .AfterRender(   scrollIntoView <| View.Map ((<>) \"\") (Snippets.selectedClassW snpId)                         )\n                        .TogglePred(    fun ev -> togglePredecessor snpId                                                            )\n                        .ToggleCollapse(fun ev -> Snippets.toggleCollapse snpId                                                      )\n                        .Drag(          fun ev ->     DragDrop.setDragNode snpId            ; ev.Event.StopPropagation()             )\n                        .DragOver(      fun ev -> if (DragDrop.getDragNIdO snpId).IsSome then ev.Event.PreventDefault ()             )\n                        .Drop(          fun ev -> do                                          ev.Event.PreventDefault () \n                                                  DragDrop.getDragNIdO snpId |> Option.iter(fun fr -> moveNode fr snpId)             )\n                      .Doc()\n                )\n            \n            let render() = TemplateLib.SnippetList().Snippets( snippets() ).Doc()\n        module RenderProperties =\n            open Snippets\n            \n            let addProperty () = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties \n                                                                                                       [| \"\",\"\" |]                                              }\n            let remProperty i = Snippets.currentSnippetV.Set \n                                    { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties.[0  .. i-1] \n                                                                                                       Snippets.currentSnippetV.Value.snpProperties.[i+1..    ] }\n            let properties() =\n                let propsV = Lens Snippets.currentSnippetV.V.snpProperties\n                let setName  i newName = propsV.Value.[i] <- (newName, snd propsV.Value.[i]) \n                                         propsV.Value |> propsV.Set\n                let setValue i newVal  = propsV.Value.[i] <- (fst propsV.Value.[i], newVal) \n                                         propsV.Value |> propsV.Set\n                V([| 0.. propsV.V.Length - 1|])\n                |> Doc.BindSeqCached (fun i ->\n                    let nameV  = Var.Make <| V( fst propsV.V.[i])\n                                          <| setName  i\n                    let valueV = Var.Make <| V( snd propsV.V.[i])\n                                          <| setValue i\n                    TemplateLib.Property()\n                        .Name(   nameV                   )\n                        .Value(  valueV                  )\n                        .Remove( fun ev -> remProperty i )\n                      .Doc()\n                )\n        \n            let render() = \n                TemplateLib.PropertyTable()\n                    .Properties(  properties()           )\n                    .AddProperty( fun _ -> addProperty() )\n                    .Doc()    \n        [< JavaScript false >]\n        module Markdown =\n            open System.Text.RegularExpressions\n        \n            let private stringReplacePatterns =\n                [ \"&lt;\"      , \"<\"\n                  \"&gt;\"      , \">\"\n                  \"&quot;\"    , \"\\\"\"\n                  \"&apos;\"    , \"'\"\n                  \"&amp;\"     , \"&\"\n                  \"<summary>\" , \"**Description**\\n\\n\"\n                  \"</summary>\", \"\\n\"\n                  \"<para>\"    , \"\\n\"\n                  \"</para>\"   , \"\\n\"\n                  \"<remarks>\" , \"\"\n                  \"</remarks>\", \"\\n\" ]\n            let private regexReplacePatterns =\n                let r               pat = Regex(pat, RegexOptions.Compiled ||| RegexOptions.IgnoreCase)\n                let unquote  (s:string) = s.Substring(1, s.Length - 2)\n                let returns     strings = Array.item 0 strings |>                     sprintf \"\\n**Returns**\\n\\n%s\"\n                let param       strings = Array.item 0 strings |> unquote |> fun s -> sprintf \"* `%s`: %s\" s strings.[1]\n                let link        strings = Array.item 0 strings |> unquote\n                let code        strings = Array.item 0 strings |> fun s -> if String.contains \"\\n\" s then \"```forceNoHighlight\" + s + \"```\" else \"`\" + s + \"`\"\n                [ r \"<c>((?:(?!<c>)(?!<\\/c>)[\\s\\S])*)<\\/c>\"                                              , code\n                  r \"\"\"<see\\s+cref=(?:'[^']*'|\"[^\"]*\")>((?:(?!<\\/see>)[\\s\\S])*)<\\/see>\"\"\"                , code\n                  r \"\"\"<param\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/param>)[\\s\\S])*)<\\/param>\"\"\"            , param\n                  r \"\"\"<typeparam\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/typeparam>)[\\s\\S])*)<\\/typeparam>\"\"\", param\n                  r \"\"\"<exception\\s+cref=('[^']*'|\"[^\"]*\")>((?:(?!<\\/exception>)[\\s\\S])*)<\\/exception>\"\"\", param\n                  r \"\"\"<a\\s+href=('[^']*'|\"[^\"]*\")>((?:(?!<\\/a>)[\\s\\S])*)<\\/a>\"\"\"                        , link\n                  r \"\"\"<returns>((?:(?!<\\/returns>)[\\s\\S])*)<\\/returns>\"\"\"                               , returns\n                ] // \"\n        \n            /// Helpers to create a new section in the markdown comment\n            let private suffixXmlKey (tag : string) (value : string) (str : string) = \n                match str.IndexOf(tag) with\n                | x when x <> -1 -> let insertAt = if str.Chars(x - 1) = ' ' \n                                                   then x - 1\n                                                   else x\n                                    str.[0..insertAt] + value + str.[insertAt + 1..]\n                | _              -> str\n        \n            let private suffixTypeparam = suffixXmlKey \"<typeparam\" \"\\n**Type parameters**\\n\\n\"\n            let private suffixException = suffixXmlKey \"<exception\" \"\\n**Exceptions**\\n\\n\"\n            let private suffixParam = suffixXmlKey \"<param\" \"\\n**Parameters**\\n\\n\"\n        \n            /// Replaces XML tags with Markdown equivalents.\n            /// List of standard tags: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/xml-documentation\n            let private replaceXml (str: string) : string =\n                let str =\n                    str\n                    |> suffixTypeparam\n                    |> suffixException\n                    |> suffixParam\n        \n                let res = regexReplacePatterns\n                          |> List.fold (fun res (regex: Regex, formatter: string[] -> string) ->\n                              // repeat replacing with same pattern to handle nested tags, like `<c>..<c>..</c>..</c>`\n                              let rec loop res : string =\n                                  match regex.Match res with\n                                  | m when m.Success -> m.Groups\n                                                        |> Seq.cast<Group>\n                                                        |> Seq.map (fun g -> g.Value)\n                                                        |> Seq.toArray\n                                                        |> Array.splitAt 1\n                                                        |> function \n                                                           | [| firstGroup |], otherGroups -> loop <| res.Replace(firstGroup, formatter otherGroups)\n                                                           |                              _-> res\n                                  |                                                       _-> res\n                              loop res\n                          ) str\n                stringReplacePatterns\n                |> List.fold (fun (res: string) (oldValue, newValue) ->\n                    res.Replace(oldValue, newValue)\n                ) res\n        \n            [< Rpc >]\n            let createCommentBlock (comment: string) = async {\n                return\n                    comment\n                    |> replaceXml\n            }\n        module Monaco =\n            open WebSharper.UI\n            open WebSharper.UI.Html\n            open Monaco\n            open FsAutoComplete\n            \n            let startsV  = Var.Create [||]\n            \n            let defaultStart = Option.defaultValue((SnippetId.Empty, \"\"), (0, 1, 0))\n            let getIndentAndFirst () =\n                let currId = Snippets.currentSnippetV.Value.snpId\n                let _, (indent, first, _) = startsV.Value |> Seq.tryFind (fst >> fst >> (=) currId) |> defaultStart\n                indent, first\n        \n            let getSnipIdIndentAndFirst line =\n                let (snpId, _), (indent, first, _) = startsV.Value |> Seq.tryFind (fun (_, (_, first, last)) -> line >= first && line <= last) |> defaultStart\n                snpId, indent, first\n        \n            let getModelUri txt uri =\n                let model = Editor.GetModel uri \n                            |> fun model -> if isUndefined model then None else Some model\n                            |> Option.defaultWith (fun () -> Editor.CreateModel(\"\", \"fsharp\", uri) )\n                if model.GetValue() <> txt then\n                    model.SetValue txt\n                model\n        \n            let getSnippetModel (sid:SnippetId) =\n                Uri.Parse(\"snpId:\" + sid.Id.ToString())\n                |> getModelUri (Snippet.snippetRm sid |> Snippets.runReader (string >> failwith)).snpContent\n        \n            let fixMarkDown v =\n                v\n                |> String.splitByChar '\\n'\n                |> Seq.map (fun l -> l.Replace(\"\\t\", \"- \"))\n                |> Seq.map (fun l -> let i = l |> Seq.takeWhile ((=) ' ') |> Seq.length\n                                     String.replicate i \"&nbsp;\" + l.[i..] )\n                |> String.concat \"\\n\\n\"\n                \n            let overDescriptions descs =\n                                  descs \n                                  |> Seq.collect id \n                                  |> Seq.collect (fun (d:CommTypes.OverloadDescription) ->\n                                      [ if d.Signature |> isUndefined |> not then yield \"```\\n\" + d.Signature + \"\\n```\" |> Async.rtn\n                                        if d.Comment   |> isUndefined |> not then yield Markdown.createCommentBlock d.Comment |> Async.map fixMarkDown\n                                        if d.Footer    |> isUndefined |> not then yield d.Footer |> fixMarkDown |> Async.rtn] )\n                                  |> Async.sequenceSeq\n            \n            let mutable fileName = \"none.fsx\"\n        \n            type HoverProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideHover(model:Model, pos:Position, token:obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! descs, other = toolTip fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let! desc = overDescriptions descs \n                      return\n                          {\n                              contents = desc |> Seq.map (fun d -> { value = d |>! print ; isTrusted = true }) |> Seq.toArray\n                              range    = (box null |> unbox)\n                          }\n                    } |> Promise.ofAsyncResult\n        \n            let convertGlyphChar =\n                function\n                | \"C\" -> CompletionItemKind.Class\n                | \"E\" -> CompletionItemKind.Enum\n                | \"S\" -> CompletionItemKind.Value\n                | \"I\" -> CompletionItemKind.Interface\n                | \"N\" -> CompletionItemKind.Module\n                | \"M\" -> CompletionItemKind.Method\n                | \"P\" -> CompletionItemKind.Property\n                | \"F\" -> CompletionItemKind.Field\n                | \"T\" -> CompletionItemKind.Class\n                | \"K\" -> CompletionItemKind.Keyword\n                | _   -> 0 |> unbox\n        \n            type CompletionItemProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj) =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let txt = String.replicate indent \" \" + model.GetLineContent(pos.lineNumber)\n                      let! comps, other = completion txt true fileName (pos.lineNumber + first) (pos.column + indent) \"Contains\"\n                      return comps \n                             |> Array.map(fun (comp:CommTypes.CompletionResponse) -> \n                                 { kind   = convertGlyphChar comp.GlyphChar\n                                   label  = comp.Name\n                                   detail = \"\"\n                                 } )\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n                  member __.resolveCompletionItem(item: CompletionItem, token: obj) =\n                    asyncResult {\n                      let! comp, other = helpText item.label\n                      let  desc =  (comp:CommTypes.HelpTextResponse).Overloads \n                                   |> Seq.collect id\n                                   |> Seq.collect (fun d -> \n                                         [ if d.Signature |> isUndefined |> not then yield d.Signature\n                                           if d.Comment   |> isUndefined |> not then yield d.Comment\n                                           if d.Footer    |> isUndefined |> not then yield d.Footer ]\n                                   )\n                                   |> String.concat \"\\n\" \n                      return  { item with detail = desc}\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            type DefinitionProvider(ed:Editor) =\n                do()\n               with\n                  member __.provideDefinition(model: Model, pos: Position, token: obj): Promise<Location> =\n                    asyncResult {\n                      let indent, first = getIndentAndFirst()\n                      let! decl, others = findDeclaration fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n                      let  decl : CommTypes.Location = decl\n                      let snpId, indent2, first2 = getSnipIdIndentAndFirst decl.Line\n                      let uri           = Monaco.Uri.Parse <| \"snpId:\" + snpId.Id.ToString()\n                      getSnippetModel snpId |> ignore\n                      return \n                          { range = { startColumn     = decl.Column - indent2\n                                      endColumn       = decl.Column - indent2\n                                      startLineNumber = decl.Line   - first2\n                                      endLineNumber   = decl.Line   - first2\n                                    }\n                            uri   = uri\n                          }\n                    } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n        \n            let transformAnnotations snp msgs =\n                let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*\\(\"\"\" + rexGuid + \"\"\"\\) \"([^\"]+?)\"\\.\"\"\" //\"\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex \"\" [| _; ty;     fl;     fc;     tl;     tc; guid; msg |] \n                                -> Some (ty, int fl, int fc, int tl, int tc, guid, msg)\n                    | _      -> None\n                )\n                |> Array.choose (fun (ty, fl, fc, tl, tc, guid, msg) ->\n                    if ParseO.parseGuidO guid |> Option.map SnippetId <> Some snp.snpId then None else\n                        Some {  message  = msg\n                                severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                                startColumn     = fc\n                                endColumn       = tc\n                                startLineNumber = fl\n                                endLineNumber   = tl\n                        }\n                  )        \n                    \n            type MonacoOptions  = {\n                fontSize   : int\n                lineHeight : int\n            }\n            \n            let addProp prop (pojo:JSObject) = pojo.Add prop ; pojo\n            \n            let newPojo props =\n                let pojo = JSObject()\n                if IsClient then\n                    props |> Seq.iter (swap addProp pojo >> ignore)\n                pojo\n        \n            let gotoEditor (ed:Editor) codeId line col = async {\n                Snippets.expandParents codeId\n                Snippets.setCurrentSnippetIdO <| Some codeId\n                do! Async.Sleep 200\n                ed.Focus()\n                ed.SetPosition            { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n                ed?revealPositionInCenter { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n            }\n        \n            let openCodeEditor (input:obj, ed:Editor, sideBySide) =\n                async {\n                    match input?resource?path with\n                    | ParseO.Guid guid -> \n                         do! gotoEditor ed (SnippetId guid) input?options?selection?startLineNumber input?options?selection?startColumn\n                         return  ed  \n                    |_-> return (null |> unbox<Editor>)\n                } |> Promise.OfAsync\n        \n            [< Inline \"var m = require('vs/editor/standalone/browser/standaloneServices');\n                       var n = new m.StaticServices.codeEditorService._factory();\n                       n.openCodeEditor = FsRoot.FSharpStation.Monaco.openCodeEditor;\n                       return n;\" >]\n            let getCodeEditorServiceImpl () = X<_>\n                \n            type ITextModelService  = {\n                setEditor                        : Editor -> unit\n                //registerTextModelContentProvider : obj\n                createModelReference             : obj\n            }\n            \n            let textModelResolverService() =\n                let mutable editorO = None\n                {\n                    setEditor            = fun e   -> editorO <- Some e\n                    createModelReference = fun uri -> \n                        async {\n                            let model = getSnippetModel uri\n                            return Monaco.newImmortalReference(model)\n                        } |> Promise.OfAsync\n                }\n        \n            let monacoNew        (var           : Var<string>                         ) \n                                 (annotationsWO : View<MarkerData []>           option) \n                                 (showToolTipO  :(string -> int -> int -> unit) option) \n                                 (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                               -> string -> int -> int -> unit) option) =\n            \n                let setDirtyCond() = ()\n                let getHints    _  = ()\n                \n                Monaco.newVar var\n                |> fun config -> \n                    { config with options   = \n                                      newPojo [   \"fontSize\"   => 12\n                                                  \"lineHeight\" => 14 \n                                              ] \n                                  //overrides = 0 \n                                  overrides = \n                                      newPojo [ \n                                          \"codeEditorService\"        => getCodeEditorServiceImpl()\n                                          \"textModelResolverService\" => textModelResolverService()\n                                          ]\n                    }\n                |> onRender(fun ed -> \n                    Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                    Editor.SetTheme(\"vs\")\n                    //ed.UpdateOptions { fontSize   = 12 ; lineHeight = 14 }        \n                    let hp = new HoverProvider         (ed)\n                    let cp = new CompletionItemProvider(ed)\n                    let dp = new DefinitionProvider    (ed)\n                    hp.provideHover |> print\n                    cp.provideCompletionItems |> print\n                    cp.resolveCompletionItem  |> print\n                    dp.provideDefinition      |> print\n                    Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                    Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                    Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                    annotationsWO\n                    |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) )\n                )\n        \n            let parse (code: string, starts: ((SnippetId * string) * (int * int * int)) []) =\n              asyncResult {\n                FStation.annotationsV.Value\n                |> String.skipFirstLine\n                |> (+) \"Parsing...\\n\"\n                |> FStation.annotationsV.Set\n                startsV.Set starts\n                let lines         = String.splitByChar '\\n' code\n                fileName         <- FsCode.getSourceDir FStation.srcDir lines +/+ FStation.id + \".fsx\"\n                let! errs, others = parseCode fileName lines true 0\n                (errs:CommTypes.ErrorResponse).Errors\n                |> Seq.map (fun v ->\n                   let (sid, name), (indent, first, _) = starts |> Seq.tryFind(fun (_, (indent, first, last)) -> v.StartLine > first && v.StartLine <= last) |> defaultStart\n                   sprintf \"%s (%d, %d) - (%d, %d) %s(%s) \\\"%s: %s\\\".\"\n                    <| match v.Severity with \"Error\" -> \"Err\" |_-> \"Warn\"\n                    <|  v.StartLine    - first\n                    <|  v.StartColumn  - indent\n                    <|  v.EndLine      - first\n                    <|  v.EndColumn    - indent\n                    <|    name\n                    <|    sid.Id.ToString()\n                    <|  v.Subcategory\n                    <|  v.Message\n                )\n                |> Seq.append [ \"Parsed!\" ]\n                |> String.concat \"\\n\"\n                |> FStation.annotationsV.Set\n                others |> Seq.iter print \n                ()\n              } |> AsyncResult.iterA print print\n        \n            let mutable editorConfigO : MonacoConfig option = None\n            \n            let getEditorConfigO () =\n                if IsClient \n                then monacoNew <| Lens Snippets.currentSnippetV.V.snpContent\n                               <| Some ( (Snippets.currentSnippetW, FStation.annotationsV.View) ||> View.Map2 transformAnnotations )\n                               <| None\n                               <| None\n                     |> Some\n                else None\n                |>! fun edO -> editorConfigO <- edO\n        \n            if IsClient then\n                Snippets.CurrentSnippetIdW |> View.Sink(fun sid ->\n                    try\n                        editorConfigO\n                        |> Option.bind(fun config -> config.editorO                         )\n                        |> Option.iter(fun editor -> getSnippetModel sid |> editor.SetModel \n                                                     FStation.annotationsV.Set FStation.annotationsV.Value\n                        )\n                    with _ -> ()\n                )\n        \n            let goto codeId line col = async {\n                match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n                | Some ed -> do! gotoEditor ed codeId line col\n                | _       -> ()\n            }\n        \n                \n        \n        \n        module JumpTo =\n        \n            let rexGuid = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let jumpToLine = \n                function\n                | REGEX rexGuid \"\" [| _ ; line ; col ; _ ; _ ; guid |] -> Monaco.goto <| SnippetId (System.Guid guid) <| int line <| int col \n                                                                          |> Async.Start\n                | _                                                    -> ()\n                \n            let jumpToRef (e:Dom.Element) =\n                let v : string = e?value |> unbox\n                let s : int    = e?selectionStart |> unbox\n                let lines = v.Split '\\n'\n                lines \n                |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n                |> fst\n                |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n                |> jumpToLine        \n        module Serializer =\n            open Serializer\n        \n            let serSnippetId      = serId (fun (SnippetId      v) -> v) SnippetId      (sprintf \"%A\")     \n        \n            let serSnippet   : Ser<Snippet  > = \n                [|\n                    serSnippetId                                         |> serField \"snpId\"         (fun s -> s.snpId        ) (fun v s -> { s with snpId         = v } )\n                    serString                                            |> serField \"snpName\"       (fun s -> s.snpName      ) (fun v s -> { s with snpName       = v } )\n                    serString                                            |> serField \"snpContent\"    (fun s -> s.snpContent   ) (fun v s -> { s with snpContent    = v } )\n                    serSnippetId                     |> serOpt           |> serField \"snpParentIdO\"  (fun s -> s.snpParentIdO ) (fun v s -> { s with snpParentIdO  = v } )\n                    serSnippetId                     |> serSet           |> serField \"snpPredIds\"    (fun s -> s.snpPredIds   ) (fun v s -> { s with snpPredIds    = v } )\n                    serString              |> serDup serString |> serArr |> serField \"snpProperties\" (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n                    serInt                                               |> serField \"snpGeneration\" (fun s -> s.snpGeneration) (fun v s -> { s with snpGeneration = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            type Model = {\n                snippets   : Snippet []\n                generation : int\n                collapsed  : SnippetId Set\n            }\n        \n            let getModel(snippets, gen, coll) =  { snippets = snippets |> Seq.toArray ;  generation = gen ; collapsed = coll}\n        \n            let serModel : Ser<Model> =\n                [|\n                    serSnippet                       |> serArr           |> serField \"snippets\"   (fun m -> m.snippets  ) (fun v m -> { m with snippets   = v } )\n                    serInt                                               |> serField \"generation\" (fun m -> m.generation) (fun v m -> { m with generation = v } )\n                    serSnippetId                     |> serSet           |> serField \"collapsed\"  (fun m -> m.collapsed ) (fun v m -> { m with collapsed  = v } )\n                |] |> serRecord { snippets = [||] ; generation = 0 ; collapsed = Set.empty}\n                \n        \n        module LoadSave =\n        \n            let fileName  = Var.Create \"\"\n            let canLoad() = Snippets.SaveAsClassW |> View.TryGet = Some \"\" || JS.Confirm \"Changes have not been saved, do you really want to load?\"\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd Serializer.serModel \n                          |> fun mdl -> Snippets.setSnippetsGen mdl.snippets mdl.collapsed\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let loadTextFile element  =\n                if canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            fileName.Set files.[0].Name\n                            files.[0] |> reader.ReadAsText\n        \n            [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n            let saveAsJavaScript (_name:string) (_txt:string) = ()\n        \n            let saveAs() = \n                let name = match fileName.Value.Split [| '/' ; '\\\\' |] |> Seq.last with \n                           | \"\"    -> \"noname.snippets\" \n                           | fname -> fname\n                Snippets.getSnippetsGen()\n                |> Serializer.getModel\n                |> fst Serializer.serModel\n                |> saveAsJavaScript name\n                Snippets.updateGeneration()\n        \n        module Importer =\n            open Serializer\n        \n            let serSnippetId2 : Ser<SnippetId> = sprintU, fun (x: obj) -> x?Item |> deserGuid |> SnippetId\n        \n            let serSnippet2   : Ser<Snippet  > = \n                [|\n                    serSnippetId2                                        |> serField \"id\"           (fun s -> s.snpId                     ) (fun v s -> { s with snpId         = if v = SnippetId.Empty then SnippetId <| System.Guid.NewGuid() else v } )\n                    serString                                            |> serField \"name\"         (fun s -> s.snpName                   ) (fun v s -> { s with snpName       = v } )\n                    serString                                            |> serField \"content\"      (fun s -> s.snpContent                ) (fun v s -> { s with snpContent    = v } )\n                    serSnippetId2                    |> serOpt           |> serField \"parent\"       (fun s -> s.snpParentIdO              ) (fun v s -> { s with snpParentIdO  = if v = Some SnippetId.Empty then None else v } )\n                    serSnippetId2                    |> serArr           |> serField \"predecessors\" (fun s -> s.snpPredIds |> Seq.toArray ) (fun v s -> { s with snpPredIds    = Set v } )\n                    //serString                        |> serMap serString |> serField \"properties\"   (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n                |] |> serRecord (Snippet.New \"\" \"\" None)\n            \n            let serSnippets = serSnippet2 |> serArr\n        \n            let parseText txt =\n                try       txt\n                          |> Json.Parse\n                          |> snd serSnippets\n                          |> fun snps -> Snippets.setSnippetsGen snps Set.empty\n                with e -> JS.Alert <| e.ToString()\n                          printfn \"%A\" e\n        \n            let importFile element  =\n                if LoadSave.canLoad() then\n                    FileList.OfElement element\n                    |> fun files ->\n                        if files.Length > 0 then\n                            let reader = TextFileReader()\n                            reader.Onload <- fun e -> e.Target?result |> parseText\n                            files.[0] |> reader.ReadAsText\n        \n        //#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        module MainProgram =\n            open FsRoot\n            open WebComponent\n            \n            let appendText (var:Var<string>) msg = \n                match var.Value, msg with\n                | \"\", m \n                | m , \"\" -> m\n                | v , m  -> v + \"\\n\" + m\n                |> var.Set\n                \n            let outputMsgs = Var.Create \"\"\n            let inline appendMsgs   msg = appendText outputMsgs msg\n        \n            let runFsCode () = \n                let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n                Snippets.FsCodeW \n                |> View.TryGet \n                |> Option.iter (fun code ->\n                    asyncResultP {\n                        outputMsgs.Set \"Running F#...\"\n                        do!     FSharpStationClient.setAddress <| WebSockets.Address FStation.id\n                        return! FsCode code |> FsiAgent.evalCode FStation.srcDir\n                    } |> AsyncResult.iterA (sprintf \"Error:\\n%A\" >> out) ignore\n                )\n        \n            let deleteSnippet() =\n                let snp = Snippets.currentSnippetV.Value\n                if  snp.snpId <> SnippetId.Empty \n                && JS.Confirm (sprintf \"Do you want to delete %s?\" <| Snippet.snippetName snp.snpName snp.snpContent) then \n                    Snippets.deleteCurrentSnippet()\n        \n            module AF = AppFramework\n        \n            let hookVar plug name func obj =\n                AF.tryGetVar plug name\n                |> Option.map        (fun var -> printfn \"Var    %s.%s hooked\"    plug name ;  func obj var.varVar                  )\n                |> Option.defaultWith(fun ()  -> printfn \"Var    %s.%s not found\" plug name ;       obj                             )\n        \n            let hookViw plug name func obj =\n                AF.tryGetViw plug name\n                |> Option.map        (fun viw -> printfn \"View   %s.%s hooked\"    plug name ;  func obj viw.viwView                 )\n                |> Option.defaultWith(fun ()  -> printfn \"View   %s.%s not found\" plug name ;       obj                             )\n        \n            let hookAct plug name func obj =\n                AF.tryGetAct plug name\n                |> Option.map        (fun act -> printfn \"Action %s.%s hooked\"    plug name ;  func obj (fun _-> act.actFunction |> AF.callFunction () () ) )\n                |> Option.defaultWith(fun ()  -> printfn \"Action %s.%s not found\" plug name ;       obj                             )\n        \n            let hookDoc plug name func obj =\n                AF.tryGetDoc plug name\n                |> Option.map        (fun doc -> printfn \"Doc    %s.%s hooked\"    plug name ;  func obj (AF.mainDocV.View |> View.Map (fun _ -> AF.getLazyDoc doc) |> Doc.EmbedView) )\n                |> Option.defaultWith(fun ()  -> printfn \"Doc    %s.%s not found\" plug name ;       obj                             )\n        \n            let buttonsRight() =\n                TemplateLib.ButtonsRight()\n                |> hookAct \"FSharpStation\" \"AddSnippet\"    (fun tmp    -> tmp.AddSnippet                  )\n                |> hookAct \"FSharpStation\" \"RemoveSnippet\" (fun tmp    -> tmp.RemoveSnippet               )\n                |> hookAct \"FSharpStation\" \"IndentIn\"      (fun tmp    -> tmp.IndentIn                    )\n                |> hookAct \"FSharpStation\" \"IndentOut\"     (fun tmp    -> tmp.IndentOut                   )\n                |> hookAct \"FSharpStation\" \"RunFS\"         (fun tmp    -> tmp.RunFS                       )\n                |> (fun tmp -> tmp.Doc())\n        \n            if IsClient then\n                Snippets.codeAndStartsW |> View.Sink (delayed 300 Monaco.parse)\n        \n                View.Sink (fun m -> \n                    JS.Window.Onbeforeunload <- \n                        if m <> \"\" then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n                        else null\n                ) Snippets.SaveAsClassW \n        \n            let mainDoc() =\n                TemplateLib.Layout()\n                    .LoadFileChanged(  fun ev -> LoadSave.loadTextFile ev.Target)\n                    .LoadFileClear(    fun ev -> ev.Target?value <- \"\"          )\n                    .ImportFileChanged(fun ev -> Importer.importFile ev.Target  )\n                    .ImportFileClear(  fun ev -> ev.Target?value <- \"\"          )\n                    .JumpRef(          fun ev -> JumpTo.jumpToRef ev.Target     )\n                    //|> hookVar \"FSharpStation\" \"Content\"     (fun tmp -> tmp.Content     )\n                    |> hookVar \"FSharpStation\" \"fileName\"      (fun tmp    -> tmp.Filename                    )\n                    |> hookVar \"FSharpStation\" \"SnippetName\"   (fun tmp    -> tmp.Name                        )\n                    |> hookVar \"FSharpStation\" \"Output\"        (fun tmp    -> tmp.Output                      )\n                    |> hookVar \"FSharpStation\" \"Parser\"        (fun tmp    -> tmp.Parser                      )\n                    |> hookViw \"FSharpStation\" \"FSCode\"        (fun tmp vw -> tmp.FSCode (Var.Make vw ignore) )\n                    |> hookViw \"FSharpStation\" \"SaveNeeded\"    (fun tmp    -> tmp.SaveAsClass                 )\n                    |> hookAct \"FSharpStation\" \"SaveAs\"        (fun tmp    -> tmp.SaveAs                      )\n                    |> hookDoc \"FSharpStation\" \"editor\"        (fun tmp    -> tmp.CodeEditor                  )\n                    |> hookDoc \"FSharpStation\" \"Snippets\"      (fun tmp    -> tmp.Snippets                    )            \n                    |> hookDoc \"FSharpStation\" \"Properties\"    (fun tmp    -> tmp.Properties                  )            \n                    |> hookDoc \"FSharpStation\" \"ButtonsRight\"  (fun tmp    -> tmp.ButtonsRight                )            \n                    |> (fun tmp -> tmp.Doc())\n        \n            \n            [< WebSharper.Sitelets.Website >]    \n            let mainProgram() =\n                AF.plugIns.Add {\n                    AF.plgName    = \"FSharpStation\"\n                    AF.plgVars    = [| AF.newVar  \"fileName\"        LoadSave.fileName\n                                       AF.newVar  \"SnippetName\"     (Lens Snippets.currentSnippetV.V.snpName)\n                                       AF.newVar  \"Content\"         (Lens Snippets.currentSnippetV.V.snpContent)\n                                       AF.newVar  \"Output\"          outputMsgs\n                                       AF.newVar  \"Parser\"          FStation.annotationsV\n                                    |]  \n                    AF.plgViews   = [| AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                                       AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                                    |]  \n                    AF.plgDocs    = [| AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                                       AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                                       AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                                       AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                                       AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                                    |]  \n                    AF.plgActions = [| AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                                       AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                                       AF.newAct  \"IndentIn\"        Snippets.indentIn       \n                                       AF.newAct  \"IndentOut\"       Snippets.indentOut\n                                       AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                                       AF.newAct  \"SaveAs\"          LoadSave.saveAs\n                                       AF.newAct  \"RunFS\"           runFsCode\n                                       AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadSave.loadTextFile), \"FileElement\")\n                                       AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile  ), \"FileElement\")\n                                       AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef     ), \"textarea\"   )\n                                    |]\n                    AF.plgQueries = [|                                               \n                                    |]\n                }\n                \"\"\"\n                    double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n        \n                    menuEditor       horizontal  65       menuLogo                  editorMessages\n                    menuLogo         vertical    350      logo                      menu\n                    logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n                    editorMessages   horizontal 10-83-100 editorButtons             messages\n                    messages         vertical   0-50-100  messagesLeft              messagesRight\n                    editorButtons    vertical -200 snippetsSnippet buttons\n                    buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS\n                    snippetsSnippet  vertical   0-20-100  FSharpStation.Snippets    editorProperties\n                    editorProperties vertical   0-100-100 snippet                   properties\n                    properties       div        \"\"        FSharpStation.Properties\n                    snippet          horizontal 35        Name                      FSharpStation.editor\n                    menu             span  \"\" btnLoad btnImport\n                    \n                    btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n                    btnAddSnippet    button FSharpStation.AddSnippet     \"\"                  \"Add Snippet   \"\n                    btnDeleteSnippet button FSharpStation.DeleteSnippet  \"\"                  \"Delete Snippet\"\n                    btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                    btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                    btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n         \n                    messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                    messagesRight    wcomp-tabstrip                      \"\"                  Parser\n         \n                    Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                    FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                    Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n                    Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                    btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n                    btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                    FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n                \"\"\"\n                |> String.unindentStr\n                |> LayoutEngine.newLyt \"FStationLyt\"\n                |> LayoutEngine.addLayout\n                AF.mainDocV.Set \"FStationLyt.menuEditor\"\n        \n                async {\n                  do! Monaco.loader\n                  //WcSplitter.init horizontal vertical\n                  //WcTabStrip.init()\n                  let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n                  return AF.getMainDoc.Value\n                } |> Doc.Async\n        \n        \n        [< JavaScript false >]\n        module Sitelet =\n            open WebSharper\n            open WebSharper.Sitelets\n            open WebSharper.UI\n            open WebSharper.UI.Server\n        \n            type EndPointServer = | [< EndPoint \"/\" >] EP\n        \n            let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n                Content.Page(Title = \"Main Page\" \n                           , Body  = [\n                                Html.client <@ MainProgram.mainProgram() @>\n                                Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                             ])\n        \n            [< Website >]\n            let MySampleWebsite : Sitelet<EndPointServer> = Sitelet.Content \"/\" EP (fun ctx -> content ctx EP)\n        \n            [<Sealed>]\n            type Website() =\n                interface IWebsite<EndPointServer> with\n                    member this.Sitelet = MySampleWebsite\n                    member this.Actions = [ EP ]\n        \n            [<assembly: Website(typeof<Website>)>]\n            do ()"],
"names": [],
"mappings": "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"
}

//# sourceMappingURL=testing.min.map