{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Collections/BalancedTree.fs", "WebSharper.Collections/Pair.fs", "WebSharper.Collections/Map.fs", "WebSharper.Collections/MapModule.fs", "WebSharper.Collections/Set.fs", "WebSharper.Collections/SetModule.fs", "WebSharper.Collections/ResizeArray.fs", "WebSharper.Collections/LinkedList.fs", "WebSharper.Collections/Linq.fs", "WebSharper.Collections/Query.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Provides balanced binary search tree operations.\n[<JavaScript>]\nmodule internal BalancedTree =\n\n    /// Represents a binary balanced search tree, preserving the balance\n    /// invariant: the heights of the branches differ by at most 1.\n    type Tree<'T when 'T : comparison> =\n        private {\n            Node    : 'T\n            Left    : Tree<'T>\n            Right   : Tree<'T>\n            Height  : int\n            Count   : int\n        }\n\n    [<Inline \"null\">]\n    let Empty<'T when 'T : comparison> = X<Tree<'T>>\n\n    [<Inline \"$tree == null\">]\n    let IsEmpty (tree: Tree<'T>) = X<bool>\n\n    [<Inline \"$tree == null ? 0 : $tree.Height\">]\n    let Height (tree: Tree<'T>) = X<int>\n            \n    [<Inline \"$tree == null ? 0 : $tree.Count\">]\n    let Count (tree: Tree<'T>) = X<int>\n\n    [<Inline \"$t.Left\">]\n    let Left (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Right\">]\n    let Right (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Node\">]\n    let Node (t: Tree<'T>) = X<'T>\n\n    let Branch node left right =\n        {\n            Node    = node\n            Left    = left\n            Right   = right\n            Height  = 1 + max (Height left) (Height right)\n            Count   = 1 + Count left + Count right\n        }\n\n    let Enumerate flip (t: Tree<'T>) : seq<'T> =\n        let rec gen (t, spine: list<'T * Tree<'T>>) =\n            if IsEmpty t then\n                match spine with\n                | []                    -> None\n                | (t, other) :: spine   -> Some (t, (other, spine))\n            else\n                if flip\n                then gen (Right t, (Node t, Left t) :: spine)\n                else gen (Left t, (Node t, Right t) :: spine)\n        Seq.unfold gen (t, [])\n\n    /// Traverses the tree in ascending order.\n    [<Inline>]\n    let Ascend t = Enumerate false t\n\n    /// Traverses the tree in descending order.\n    [<Inline>]\n    let Descend t = Enumerate true t\n\n    /// Builds a tree from sorted input and the indices of the\n    /// first and the last elements to include.\n    let rec private Build (data: 'T []) min max : Tree<'T> =\n        let sz = max - min + 1\n        if sz <= 0 then\n            Empty\n        else\n            let center = (min + max) / 2\n            let left   = Build data min (center - 1)\n            let right  = Build data (center + 1) max\n            Branch data.[center] left right\n\n    /// Quickly constructs a tree from a sorted, distinct array.\n    [<Inline>]\n    let OfSorted (data: 'T []) : Tree<'T> =\n        Build data 0 (Array.length data - 1)\n\n    let OfSeq (data: seq<'T>) : Tree<'T> =\n        let a = Seq.toArray (Seq.distinct data)\n        Array.sortInPlace a\n        OfSorted a\n\n    [<Inline \"$x.unshift($y)\">]\n    let private unshift (x: 'T) y = X<unit>\n\n    /// Unzips a tree into a matching node and a spine.\n    let Lookup (k: 'T) (t: Tree<'T>) =\n        let mutable spine = [||]\n        let mutable t = t\n        let mutable loop = true\n        while loop do\n            if IsEmpty t then loop <- false else\n                match compare k t.Node with\n                | 0 -> loop <- false\n                | 1 ->\n                    unshift spine (true, t.Node, t.Left)\n                    t <- t.Right\n                | _ ->\n                    unshift spine (false, t.Node, t.Right)\n                    t <- t.Left\n        (t, spine)\n\n    /// Rebuilds an unzipped tree by going up the spine and performing\n    /// rotations where necessary for balance.\n    let private Rebuild<'T when 'T : comparison>\n            (spine: (bool * 'T * Tree<'T>) []) (t: Tree<'T>) : Tree<'T> =\n        let h (x: Tree<'T>) = Height x\n        let mutable t = t\n        for i = 0 to spine.Length - 1 do\n            t <- (\n                match spine.[i] with\n                | false, x, r ->\n                    if h t > h r + 1 then\n                        if h t.Right = h t.Left + 1 then\n                            // Double rotation:\n                            let m = t.Right\n                            Branch  m.Node\n                                    (Branch t.Node t.Left m.Left)\n                                    (Branch x m.Right r)\n                        else\n                            // Single rotation:\n                            Branch  t.Node\n                                    t.Left\n                                    (Branch x t.Right r)\n                    else\n                        // No rotation:\n                        Branch x t r\n                | true, x, l ->\n                    if h t > h l + 1 then\n                        if h t.Left = h t.Right + 1 then\n                            // Double rotation:\n                            let m = t.Left\n                            Branch m.Node\n                                    (Branch x l m.Left)\n                                    (Branch t.Node m.Right t.Right)\n                        else\n                            // Single rotation:\n                            Branch t.Node\n                                    (Branch x l t.Left)\n                                    t.Right\n                    else\n                        // No rotation:\n                        Branch x l t\n            )\n        t\n\n    /// Inserts or updates a node in the tree. If a matching node is found,\n    /// it is replaced with the value of \"combine old new\".\n    let Put<'T when 'T : comparison> combine k (t: Tree<'T>) : Tree<'T> =\n        let (t, spine) = Lookup k t\n        if IsEmpty t then\n            Rebuild spine (Branch k Empty Empty)\n        else\n            Rebuild spine (Branch (combine t.Node k) t.Left t.Right)\n\n    /// Removes a node from the tree.\n    let Remove k (src: Tree<'T>) =\n        let (t, spine) = Lookup k src\n        if IsEmpty t then\n            src\n        else\n            if IsEmpty t.Right then\n                Rebuild spine t.Left\n            elif IsEmpty t.Left then\n                Rebuild spine t.Right\n            else\n                Seq.append (Ascend t.Left) (Ascend t.Right)\n                |> Seq.toArray\n                |> OfSorted\n                |> Rebuild spine\n\n    /// Adds a node into the tree, replacing an existing one if found.\n    let Add<'T when 'T : comparison> (x: 'T) (t: Tree<'T>) : Tree<'T> =\n        Put (fun _ x -> x) x t\n\n    /// Checks if a tree contains a given key.\n    let rec Contains (v: 'T) (t: Tree<'T>) : bool =\n        not (IsEmpty (fst (Lookup v t)))\n\n    /// Looks up a node by key.\n    let TryFind (v: 'T) (t: Tree<'T>) =\n        let x = fst (Lookup v t)\n        if IsEmpty x then None else Some x.Node\n\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\n\n/// Represents a key-value pair with comparison and equality\n/// ignoring the value and using only the key.\n[<CustomComparison>]\n[<CustomEquality>]\n[<JavaScript>]\ntype internal Pair<'K,'V when 'K : comparison> =\n    {\n        Key     : 'K\n        Value   : 'V\n    }\n\n    override this.GetHashCode() = hash this.Key\n\n    override this.Equals(other: obj) =\n        this.Key = (other :?> Pair<'K,'V>).Key\n\n    interface System.IComparable with\n        member this.CompareTo(other: obj) =\n            compare this.Key (other :?> Pair<'K,'V>).Key\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Collections\nmodule T = BalancedTree\n\n[<JavaScript>]\n[<AutoOpen>]\nmodule private MapUtil =\n\n    let fromSeq(s: seq<_>) =\n        let a : Pair<_,_> [] =\n            [| for (k, v) in Seq.distinctBy fst s ->\n                { Key = k; Value = v } |]\n        Array.sortInPlace a\n        T.OfSorted a\n\n/// Implements a proxy for the F# Map type.\n[<Name \"FSharpMap\">]\n[<Proxy(typeof<Map<_,_>>)>]\ntype internal FSharpMap<'K,'V when 'K : comparison>\n\n    (tree: T.Tree<Pair<'K,'V>>) =\n\n        new (s: seq<_>) = new FSharpMap<_,_>(fromSeq s)\n\n        member this.Tree = tree\n\n        member this.Add(k: 'K, v: 'V) : Map<'K,'V> =\n            As (FSharpMap<'K,'V>(tree |> T.Add {Key=k; Value=v}))\n\n        member this.ContainsKey k = \n            tree |> T.Contains {Key=k; Value = JS.Undefined}\n\n        member this.TryGetValue (k: 'K, r: byref<'V>) = \n            match this.TryFind k with\n            | Some v ->\n                r <- v\n                true\n            | _ ->\n                false\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member this.Item \n            with get (k: 'K) : 'V =\n                match this.TryFind k with\n                | Some v    ->v\n                | None      ->\n                    failwith \"The given key was not present in the dictionary.\"\n\n        member this.Remove(k: 'K) : Map<'K,'V> =\n            As (FSharpMap(tree |> T.Remove {Key=k; Value=JS.Undefined}))\n\n        member this.TryFind(k: 'K) =\n            tree\n            |> T.TryFind {Key=k; Value=JS.Undefined}\n            |> Option.map (fun kv -> kv.Value)\n\n        member this.GetEnumerator() =\n            let s =\n                T.Ascend tree\n                |> Seq.map (fun kv ->\n                    new KeyValuePair<_,_>(kv.Key, kv.Value))\n            s.GetEnumerator()\n\n        override this.GetHashCode() =\n            hash (Seq.toArray this)\n\n        override this.Equals(other) =\n            let other = As<FSharpMap<'K,'V>> other\n            this.Count = other.Count\n            && Seq.forall2 ( = ) this other\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith (fun x y ->\n                    compare (As<Pair<'K,'V>> x) (As<Pair<'K,'V>> y))\n                    this\n                    (As<Map<'K,'V>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Map module.\n[<Proxy \"Microsoft.FSharp.Collections.MapModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Map\">]\nmodule internal MapModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (m: Map<'K,'V>) =\n        (As<FSharpMap<'K,'V>> m).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<_>) : Map<'K,'V> =\n        As (new FSharpMap<'K,'V>(t))\n\n    [<Inline>]\n    let Add k v (m: Map<'K,'V>) : Map<'K,'V> = m.Add(k, v)\n\n    [<Inline>]\n    let ContainsKey k (m: Map<'K,'V>) : bool = m.ContainsKey k\n\n    [<Inline>]\n    let Empty<'K,'V when 'K : comparison> : Map<'K,'V> = new Map<_,_>([||])\n\n    let Exists (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : bool =\n        m |> Seq.exists (fun kv -> f kv.Key kv.Value)\n\n    let Filter (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> =\n        T.Ascend (ToTree m)\n        |> Seq.filter (fun kv -> f kv.Key kv.Value)\n        |> Seq.toArray\n        |> T.OfSorted\n        |> OfTree\n\n    [<Inline>]\n    let Find (k: 'K) (m: Map<'K,'V>) : 'V = m.[k]\n\n    let FindKey (f: 'K -> 'T -> bool) (m: Map<'K,'T>) : 'K =\n        m \n        |> Seq.pick (fun kv -> \n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec Fold<'K,'V,'S when 'K : comparison>\n        (f: 'S -> 'K -> 'V -> 'S) (s: 'S) (m: Map<'K,'V>) : 'S =\n            T.Ascend (ToTree m)\n            |> Seq.fold (fun s kv -> f s kv.Key kv.Value) s\n\n    let rec FoldBack (f: 'K -> 'V -> 'S -> 'S) (m: Map<'K,'V>) (s: 'S) : 'S =\n        T.Descend (ToTree m)\n        |> Seq.fold (fun s kv -> f kv.Key kv.Value s) s\n\n    let rec ForAll (f: 'K -> 'V -> bool) (m: Map<'K, 'V>) : bool =\n        m |> Seq.forall (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let IsEmpty (m: Map<'K, 'V>) : bool = m.IsEmpty\n\n    let rec Iterate (f: 'K -> 'V -> unit) (m: Map<'K, 'V>) : unit =\n        m |> Seq.iter (fun kv -> f kv.Key kv.Value)\n\n    let OfArray (a: ('K * 'V) []) : Map<'K,'V> =\n        a\n        |> Seq.map (fun (k, v) -> {Key = k; Value = v} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n    [<Inline>]\n    let OfList (kvs: list<'K * 'V>) : Map<'K,'V> = Map.ofSeq kvs\n\n    [<Inline>]\n    let OfSeq (s: seq<'K * 'V>) : Map<'K, 'V> =\n        Map.ofArray (Seq.toArray s)\n\n    let Partition (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> * Map<'K,'V> =\n        let (x, y) =\n            Seq.toArray (T.Ascend (ToTree m))\n            |> Array.partition (fun kv -> f kv.Key kv.Value)\n        (OfTree (T.OfSorted x), OfTree (T.OfSorted y))\n\n    let Pick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : 'T =\n        m |> Seq.pick (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let Remove (k: 'K) (m: Map<'K, 'V>) : Map<'K, 'V> = m.Remove k\n\n    [<Inline>]\n    let ToArray (m: Map<'K, 'V>) : array<'K * 'V> = Seq.toArray (Map.toSeq m)\n\n    [<Inline>]\n    let ToList (m: Map<'K, 'V>) : list<'K * 'V> = Seq.toList (Map.toSeq m)\n\n    let ToSeq (m: Map<'K, 'V>) : seq<'K * 'V> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> (kv.Key, kv.Value))\n\n    let TryFind (k: 'K) (m: Map<'K, 'V>) : option<'V> = m.TryFind k\n\n    let TryFindKey (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : option<'K> =\n        m |> Seq.tryPick (fun kv ->\n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec TryPick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : option<'T> =\n        m |> Seq.tryPick (fun kv -> f kv.Key kv.Value)\n         \n    let rec Map (f: 'K -> 'V -> 'T) (m: Map<'K,'V>) : Map<'K,'T> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> \n            {Key = kv.Key; Value = f kv.Key kv.Value} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nmodule T = BalancedTree\n\n/// Implements a proxy for the F# Set type.\n[<Name \"FSharpSet\">]\n[<Proxy(typeof<Set<_>>)>]\ntype private FSharpSet<'T when 'T : comparison>\n\n    internal (tree: T.Tree<'T>) =\n\n        new (s: seq<'T>) = new FSharpSet<'T>(T.OfSeq s)\n\n        member this.add(x: Set<'T>) =\n            Set.union (As this) x\n\n        member this.sub(x: Set<'T>) =\n            Set.difference (As this) x\n\n        member this.Add x : Set<'T> =\n            As (FSharpSet<'T>(T.Add x tree))\n\n        member this.Contains v = T.Contains v tree\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member internal this.Tree = tree\n\n        member this.IsProperSubsetOf(s: Set<'T>) =\n            this.IsSubsetOf s && this.Count < s.Count\n\n        member this.IsProperSupersetOf(s: Set<'T>) =\n            this.IsSupersetOf s && this.Count > s.Count\n\n        member this.IsSubsetOf(s: Set<'T>) =\n            Seq.forall s.Contains this\n\n        member this.IsSupersetOf(s: Set<'T>) =\n            Seq.forall this.Contains s\n\n        member this.MaximumElement = Seq.head (T.Descend tree)\n\n        member this.MinimumElement = Seq.head (T.Ascend tree)\n\n        member this.Remove v : Set<'T> =\n            As (FSharpSet<'T>(T.Remove v tree))\n\n        member this.GetEnumerator() =\n            (T.Ascend tree).GetEnumerator()\n\n        static member (+) (x, y) : Set<'T> =\n            Set.union x y        \n\n        static member (-) (x, y) : Set<'T> =\n            Set.difference x y        \n\n        override this.GetHashCode() =\n            -1741749453 + ((Seq.toArray this).GetHashCode())\n\n        override this.Equals(other: obj) =\n            this.Count = (As<FSharpSet<'T>> other).Count\n            && Seq.forall2 ( = ) this (As<FSharpSet<'T>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith compare this (As<FSharpSet<'T>> other)\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Set module.\n[<Proxy \"Microsoft.FSharp.Collections.SetModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Set\">]\nmodule internal SetModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (s: Set<'T>) =\n        (As<FSharpSet<'T>> s).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<'T>) =\n        As<Set<'T>> (new FSharpSet<'T>(t))\n\n    [<Inline>]\n    let Add v (s: Set<_>) = s.Add v\n\n    [<Inline>]\n    let Contains v (s: Set<_>) = s.Contains v\n\n    [<Inline>]\n    let Count (s: Set<_>) = s.Count\n\n    [<Inline>]\n    let Difference (s1: Set<_>) (s2: Set<_>) =\n        Set.filter (fun x -> not (s2.Contains x)) s1\n\n    [<Inline>]\n    let Empty<'T when 'T : comparison> : Set<'T> = OfTree T.Empty\n\n    [<Inline>]\n    let Exists f (s: Set<'T>) = Seq.exists f s\n\n    let Filter f (s: Set<'T>) =\n        OfTree (T.OfSorted (Seq.toArray (Seq.filter f s)))\n\n    [<Inline>]\n    let Fold<'T,'S when 'T : comparison>\n        (f: 'S -> 'T -> 'S) (x: 'S) (a: Set<'T>) =\n            Seq.fold f x a\n\n    let FoldBack (f: 'T -> 'S -> 'S) (a: Set<'T>) (s: 'S) : 'S =\n        Seq.fold (fun s x -> f x s) s (T.Descend (ToTree a))\n\n    [<Inline>]\n    let ForAll f (a: Set<_>) = Seq.forall f a\n\n    [<Inline>]\n    let Intersect (s1: Set<'T>) (s2: Set<'T>) = Set.filter s2.Contains s1\n\n    [<Inline>]\n    let IntersectMany (s: seq<Set<_>>) = Seq.reduce Set.intersect s\n\n    [<Inline>]\n    let IsEmpty (a: Set<_>) = a.IsEmpty\n\n    [<Inline>]\n    let IsProperSubset (a: Set<_>) b = a.IsProperSubsetOf b\n\n    [<Inline>]\n    let IsProperSuperset (a: Set<_>) b = a.IsProperSupersetOf b\n\n    [<Inline>]\n    let IsSubset (a: Set<_>) b = a.IsSubsetOf b\n\n    [<Inline>]\n    let IsSuperset (a: Set<_>) b = a.IsSupersetOf b\n\n    [<Inline>]\n    let Iterate f (s: Set<_>) = Seq.iter f s\n\n    [<Inline>]\n    let Map f (s: Set<_>) = Set.ofSeq (Seq.map f s)\n\n    [<Inline>]\n    let MaxElement (s: Set<_>) = s.MaximumElement\n\n    [<Inline>]\n    let MinElement (s: Set<_>) = s.MinimumElement\n\n    [<Inline>]\n    let OfArray (a: 'T []) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfList (a: list<'T>) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfSeq (a: seq<'T>) = OfTree (T.OfSeq a)\n\n    let Partition f (a: Set<_>) =\n        let (x, y) = Array.partition f (Seq.toArray a)\n        (Set.ofArray x, Set.ofArray y)\n\n    [<Inline>]\n    let Remove v (a: Set<_>) = a.Remove v\n\n    [<Inline>]\n    let Singleton x = Set.add x Set.empty\n\n    [<Inline>]\n    let ToArray (a: Set<_>) = Seq.toArray a\n\n    [<Inline>]\n    let ToList (a: Set<_>) = Seq.toList a\n\n    [<Inline>]\n    let ToSeq (a: Set<_>) : seq<_> = a :> _\n\n    [<Inline>]\n    let Union (s1: Set<_>) (s2: Set<_>) =\n        Set.ofSeq (Seq.append s1 s2)\n\n    [<Inline>]\n    let UnionMany (sets: seq<Set<_>>) =\n        Set.ofSeq (Seq.concat sets)\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.ResizeArray\n\nopen WebSharper\nopen WebSharper.JavaScript\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\n\n[<Name \"WebSharper.Collections.ListEnumerator\">]\n[<Proxy(typeof<System.Collections.Generic.List.Enumerator<_>>)>]\ntype ResizeArrayEnumeratorProxy<'T> [<JavaScript>] (arr: 'T[]) =\n    let mutable i = -1\n\n    [<JavaScript>] \n    member this.MoveNext() =\n        i <- i + 1\n        i < arr.Length\n\n    [<JavaScript>] \n    member this.Current with get() = arr.[i]\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = this.MoveNext()\n        [<JavaScript>]\n        member this.Current with get() = box (arr.[i])\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = arr.[i]\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = ()\n\n[<Proxy(typeof<System.Collections.Generic.List<_>>)>]\n[<Name \"WebSharper.Collections.List\">]\n[<Prototype false>]\ntype ResizeArrayProxy<'T> [<Inline \"$_arr\">] (_arr: 'T []) =\n\n    [<Inline \"[]\">]\n    new () =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline \"[]\">]\n    new (size: int) =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline>]\n    new (el: seq<'T>) =\n        new ResizeArrayProxy<'T>(Seq.toArray el)\n\n    [<Inline>]\n    member this.GetEnumerator() =\n        As<System.Collections.Generic.List.Enumerator<'T>>(new ResizeArrayEnumeratorProxy<'T>(As<'T[]> this))\n\n    interface 'T seq with\n        member this.GetEnumerator() = (As<System.Collections.IEnumerable> this).GetEnumerator()\n        member this.GetEnumerator() = (As<seq<'T>> this).GetEnumerator()\n\n    [<Inline>]\n    member this.Add(x: 'T) : unit =\n        As<'T[]>(this).JS.Push(x) |> ignore\n\n    [<Inline>]\n    member this.AddRange(x: seq<'T>) : unit =\n        Seq.iter this.Add x\n\n    [<Inline>]\n    member this.AsReadOnly() : System.Collections.ObjectModel.ReadOnlyCollection<'T> =\n        System.Array.AsReadOnly(As<'T[]> this)\n\n    [<Inline>]\n    member this.BinarySearch(start: int, length: int, item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, start, length, item, comparer)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T) : int =\n        System.Array.BinarySearch(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, item, comparer)\n\n    [<Inline>]\n    member this.Clear() : unit =\n        (As<'T[]> this).JS.Splice(0, this.Count) |> ignore\n\n    [<Inline>]\n    member this.Contains(item: 'T) : bool =\n        System.Array.Exists(As<'T[]> this, fun x -> System.Collections.Generic.EqualityComparer.Default.Equals(item, x))\n\n    [<Inline>]\n    member this.ConvertAll<'U>(conv: System.Converter<'T, 'U>) : ResizeArray<'U> =\n        ResizeArray<'U>(System.Array.ConvertAll(As<'T[]> this, conv))\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[]) : unit =\n        this.CopyTo(arr, 0)\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[], offset: int) : unit =\n        this.CopyTo(0, arr, offset, this.Count)\n\n    [<Inline>]\n    member this.CopyTo(index: int, target: 'T[], offset: int, count: int) : unit =\n        Array.blit (As<'T[]> this) index target offset count\n\n    [<Inline>]\n    member this.Count : int = (As<'T[]> this).Length\n\n    [<Inline>]\n    member this.Exists(pred: System.Predicate<'T>) : bool =\n        System.Array.Exists(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.Find(pred: System.Predicate<'T>) : 'T =\n        System.Array.Find(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindAll(pred: System.Predicate<'T>) : ResizeArray<'T> =\n        ResizeArray<'T>(System.Array.FindAll(As<'T[]> this, pred))\n\n    [<Inline>]\n    member this.FindIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.FindLast(pred: System.Predicate<'T>) : 'T =\n        System.Array.FindLast(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.ForEach(action: System.Action<'T>) : unit =\n        System.Array.ForEach(As<'T[]> this, action)\n\n    [<Inline>]\n    member this.GetRange(index: int, count: int) : ResizeArray<'T> =\n        As (ResizeArrayProxy<'T>(Array.sub (As<'T[]> this) index count))\n\n    [<Inline>]\n    member this.IndexOf(item: 'T) : int =\n        System.Array.IndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start, count)\n\n    [<Inline>]\n    member this.Insert(index: int, item: 'T) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, item) |> ignore\n\n    [<Inline>]\n    member this.InsertRange(index: int, items: seq<'T>) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, Array.ofSeq items) |> ignore\n\n    member this.Item\n        with [<Inline>] get (x: int) : 'T = (As<'T[]> this).[x]\n        and [<Inline>] set (x: int) (v: 'T) = (As<'T[]> this).[x] <- v\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start, count)\n\n    member this.Remove(item: 'T) : bool =\n        match this.IndexOf(item) with\n        | -1 -> false\n        | n -> this.RemoveAt(n); true\n\n    member this.RemoveAll(pred: System.Predicate<'T>) : int =\n        let mutable removed = 0\n        let mutable i = 0\n        while i < this.Count do\n            if pred.Invoke((As<'T[]> this).JS.[i]) then\n                let mutable j = i + 1\n                while j < this.Count && pred.Invoke((As<'T[]> this).JS.[j]) do\n                    j <- j + 1\n                removed <- removed + j - i\n                (As<'T[]> this).JS.Splice(i, j - i) |> ignore\n            else\n                i <- i + 1\n        removed\n\n    [<Inline>]\n    member this.RemoveAt(x: int) : unit =\n        (As<'T[]> this).JS.Splice(x, 1) |> ignore\n\n    [<Inline>]\n    member this.RemoveRange(index: int, count: int) : unit =\n        (As<'T[]> this).JS.Splice(index, count) |> ignore\n\n    [<Inline>]\n    member this.Reverse() : unit =\n        System.Array.Reverse(As<'T[]> this)\n\n    [<Inline>]\n    member this.Reverse(index: int, count: int) : unit =\n        System.Array.Reverse(As<'T[]> this, index, count)\n\n    [<Inline>]\n    member this.Sort() : unit =\n        System.Array.Sort(As<'T[]> this)\n\n    [<Inline>]\n    member this.Sort(comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.Sort(start: int, length: int, comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, start, length, comp)\n\n    [<Inline>]\n    member this.Sort(comp: System.Comparison<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.ToArray() : 'T [] =\n        Array.copy (As<'T[]> this)\n\n    [<Inline>]\n    member this.TrimExcess() = ()\n\n    [<Inline>]\n    member this.TrueForAll(pred: System.Predicate<'T>) : bool =\n        System.Array.TrueForAll(As<'T[]> this, pred)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.LinkedList\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype LL<'T> = LinkedList<'T>\ntype LLN<'T> = LinkedListNode<'T>\ntype LLE<'T> = LinkedList<'T>.Enumerator\n\n[<Proxy(typeof<LLN<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListNode\">]\ntype NodeProxy<'T> =\n    member this.Previous with [<Inline \"$this.p\">] get () = X<LLN<'T>>\n    member this.Next     with [<Inline \"$this.n\">] get () = X<LLN<'T>>\n    member this.Value    with [<Inline \"$this.v\">] get () = X<'T>\n\n[<Inline \"{p: $p, n: $n, v: $v}\">]\nlet newNode<'T> (p: LLN<'T>) (n: LLN<'T>) (v: 'T) = X<LLN<'T>>\n\n[<Inline \"$node.p = $p\" >]\nlet setPrev (node: LLN<'T>) (p: LLN<'T>) = ()\n\n[<Inline \"$node.n = $n\" >]\nlet setNext (node: LLN<'T>) (n: LLN<'T>) = ()\n\n[<Proxy(typeof<LLE<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListEnumerator\">]\ntype EnumeratorProxy<'T> [<JavaScript>] (l: LLN<'T>) =\n    let mutable c = l\n\n    interface IEnumerator<'T> with\n        member this.Current = c.Value\n        \n        member this.Current = c.Value |> box\n\n        member this.MoveNext() =\n            c <- c.Next\n            c <> null\n\n        member this.Dispose() = ()\n\n        member this.Reset() = ()\n\n[<Proxy(typeof<LL<_>>)>]\n[<Name \"WebSharper.Collections.LinkedList\">]\ntype ListProxy<'T> [<JavaScript>] (coll: 'T seq) =\n    let mutable c = 0\n    let mutable n = null\n    let mutable p = null\n\n    do  let ie = coll.GetEnumerator()\n        if ie.MoveNext() then\n            n <- newNode null null ie.Current\n            p <- n\n            c <- 1\n        while ie.MoveNext() do\n            let node = newNode p null ie.Current\n            setNext p node\n            p <- node\n            c <- c + 1\n            \n    new () = ListProxy(Seq.empty)          \n\n    [<Inline>]\n    member this.Count = c\n\n    [<Inline>]\n    member this.First = n\n\n    [<Inline>]\n    member this.Last = p\n\n    member this.AddAfter(after: LLN<'T>, value) =\n        let before = after.Next\n        let node = newNode after before value\n        if after.Next = null then p <- node\n        setNext after node\n        if before <> null then setPrev before node\n        c <- c + 1\n        node\n\n    member this.AddBefore(before: LLN<'T>, value) =\n        let after = before.Previous\n        let node = newNode after before value\n        if before.Previous = null then n <- node \n        setPrev before node\n        if after <> null then setNext after node\n        c <- c + 1\n        node\n\n    member this.AddFirst(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddBefore(n, value)\n\n    member this.AddLast(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddAfter(p, value)\n\n    member this.Clear() =\n        c <- 0\n        n <- null\n        p <- null\n\n    member this.Contains(value: 'T) =\n        let mutable found = false\n        let mutable node = n\n        while node <> null && not found do\n            if node.Value ==. value then found <- true \n            else node <- node.Next\n        found\n            \n    member this.Find(value: 'T) =\n        let mutable node = n\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Next\n        if notFound then null else node\n\n    member this.FindLast(value: 'T) = \n        let mutable node = p\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Previous\n        if notFound then null else node\n                \n    member this.GetEnumerator(): LinkedList<'T>.Enumerator =\n        As (new EnumeratorProxy<_>(As this))\n\n    interface IEnumerable with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    interface IEnumerable<'T> with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    member this.Remove(node: LLN<'T>) =\n        let before = node.Previous\n        let after = node.Next\n        if before = null then n <- after else setNext before after\n        if after = null then p <- before else setPrev after before\n        c <- c - 1\n        \n    member this.Remove(value) = \n        let node = this.Find(value)\n        if node = null then false\n        else\n            this.Remove(node)\n            true\n\n    member this.RemoveFirst() = this.Remove(n)\n\n    member this.RemoveLast() = this.Remove(p)\n               \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<IGrouping<_, _>>)>]\ntype internal IGroupingProxy<'K, 'T> =\n    abstract Key : 'K\n\n[<JavaScript>]\ntype internal Grouping<'K, 'T> (k: 'K, v: seq<'T>) =\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            v.GetEnumerator()\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() =\n            (v :> System.Collections.IEnumerable).GetEnumerator()\n\n    interface System.Linq.IGrouping<'K, 'T> with\n        member this.Key = k\n\n[<Proxy(typeof<IOrderedEnumerable<_>>)>]\ntype internal IOrderedEnumerableProxy<'T> =\n    inherit seq<'T>\n    abstract CreateOrderedEnumerable<'K>\n        : keySelector: Func<'T, 'K>\n        * comparer: IComparer<'K>\n        * descending: bool\n        -> IOrderedEnumerable<'T>\n\n[<JavaScript>]\ntype internal FsComparer<'T when 'T : comparison>() =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            compare x y\n\n[<JavaScript>]\ntype internal ProjectionComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke x, projection.Invoke y)\n\n[<JavaScript>]\ntype internal CompoundComparer<'T>(primary: IComparer<'T>, secondary: IComparer<'T>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            match primary.Compare(x, y) with\n            | 0 -> secondary.Compare(x, y)\n            | n -> n\n\n[<JavaScript>]\ntype internal ReverseComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke y, projection.Invoke x)\n\n[<JavaScript>]\ntype internal OrderedEnumerable<'T>(source: seq<'T>, primary: IComparer<'T>) =\n    interface IOrderedEnumerable<'T> with\n        member this.CreateOrderedEnumerable(keySelector, secondary, descending) =\n            let secondary =\n                if descending then\n                    ReverseComparer(secondary, keySelector) :> IComparer<'T>\n                else\n                    ProjectionComparer(secondary, keySelector) :> IComparer<'T>\n            OrderedEnumerable<'T>(source, CompoundComparer(primary, secondary)) :> _\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let a = Array.ofSeq source\n            Array.sortInPlaceWith (fun x y -> primary.Compare(x, y)) a\n            (a :> seq<'T>).GetEnumerator()\n    interface IEnumerable with\n        member this.GetEnumerator() =\n            (this :> IEnumerable<'T>).GetEnumerator() :> _\n\n//[<Proxy(typeof<ILookup<_, _>>)>]\n//type internal ILookupProxy<'K, 'E> =\n//    inherit seq<IGrouping<'K, 'E>>\n//    inherit IEnumerable\n//    abstract Item : 'K -> 'E with get\n//    abstract Count : int with get\n//    abstract Contains : 'K -> bool\n//\n//[<JavaScript>]\n//type internal Lookup<'K, 'T, 'E>(source: seq<'T>, key: Func<'T, 'K>, elt: Func<'T, 'E>, comparer: IEqualityComparer<'K>) =\n//\n//    let dc = lazy (\n//        let d = Dictionary<'K, ResizeArray<'E>>(comparer)\n//        let count = ref 0\n//        source |> Seq.iter (fun e ->\n//            incr count\n//            let k = key.Invoke e\n//            let v = elt.Invoke e\n//            if d.ContainsKey k then\n//                d.[k].Add(v)\n//            else\n//                d.Add(k, ResizeArray([|v|]))\n//        )\n//        d, !count\n//    )\n//\n//    let s = lazy (\n//        fst dc.Value |> Seq.map (fun (KeyValue(k, v)) ->\n//            Grouping(k, v) :> IGrouping<_,_>)\n//    )\n//\n//    interface seq<IGrouping<'K, 'E>> with\n//        member this.GetEnumerator() = s.Value.GetEnumerator()\n//    interface IEnumerable with\n//        member this.GetEnumerator() = (s.Value :> IEnumerable).GetEnumerator()\n//    interface ILookup<'K, 'E> with\n//        member this.Item with get k = (fst dc.Value).[k] :> seq<_>\n//        member this.Count = snd dc.Value\n//        member this.Contains(k) = (fst dc.Value).ContainsKey(k)\n\ntype private LinqMacro() =\n    inherit Macro()\n\n    override this.TranslateCall(c) = //e, t, m, a, _) =\n        let targ = c.Method.Generics.[0]\n        WebSharper.Core.Macros.EqualityComparer.GetDefault(c.Compilation, targ)\n        |> MacroResult.Map (fun ec ->\n            let m' =\n                let t =\n                    AST.Type.ConcreteType {\n                        Generics = [targ]\n                        Entity =\n                            typedefof<IEqualityComparer<int>>\n                            |> AST.Reflection.ReadTypeDefinition\n                    }\n                let m = c.Method.Entity.Value\n                { m with Parameters = m.Parameters @ [t] }\n            let m = { c.Method with Entity = Hashed m' }\n            AST.Call(c.This, c.DefiningType, c.Method, c.Arguments @ [ec]))\n\n[<Name \"WebSharper.Linq\">]\n[<Proxy(typeof<System.Linq.Enumerable>)>]\n[<JavaScript>]\ntype private LinqProxy =\n\n    [<Inline>]\n    static member Aggregate<'T>(this: seq<'T>, func: Func<'T, 'T, 'T>) : 'T =\n        Seq.reduce (fun x y -> func.Invoke(x, y)) this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>) : 'U =\n        Seq.fold (fun x y -> func.Invoke(x, y)) seed this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U, 'R>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>, resultSelector: Func<'U, 'R>) : 'R =\n        resultSelector.Invoke(Seq.fold (fun x y -> func.Invoke(x, y)) seed this)\n\n    [<Inline>]\n    static member All<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.forall predicate.Invoke this\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>) : bool =\n        not (Seq.isEmpty this)\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.exists predicate.Invoke this\n\n    [<Inline>]\n    static member AsEnumerable<'T>(this: seq<'T>) : seq<'T> =\n        this\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    static member Average(this: seq<Nullable<float>>) : Nullable<float> =\n        let mutable x = [||]\n        use e = this.GetEnumerator()\n        while e.MoveNext() do\n            if e.Current.HasValue then\n                x.JS.Push e.Current.Value |> ignore\n        if x.Length = 0 then\n            Nullable()\n        else\n            Nullable(Seq.sum x / float x.Length)\n\n    [<Inline>]\n    static member Average(this: seq<float>) : float =\n        Seq.average this\n\n    [<Inline>]\n    static member Average(this: seq<int64>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average(this: seq<int>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int64>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        Seq.average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Cast<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast this\n\n    [<Inline>]\n    static member Concat<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        Seq.append this second\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T) : bool =\n        LinqProxy.Contains(this, value, EqualityComparer.Default)\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T, comparer: IEqualityComparer<'T>) : bool =\n        Seq.exists (fun x -> comparer.Equals(value, x)) this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>) : int =\n        Seq.length this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int =\n        Seq.length (Seq.filter predicate.Invoke this)\n\n    [<Inline>]\n    static member DefaultIfEmpty<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.DefaultIfEmpty(this, Unchecked.defaultof<'T>)\n\n    static member DefaultIfEmpty<'T>(this: seq<'T>, defaultValue: 'T) : seq<'T> =\n        if Seq.isEmpty this then\n            Seq.singleton defaultValue\n        else this\n\n    [<Inline>]\n    static member Distinct<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.Distinct(this, EqualityComparer.Default)\n\n    static member Distinct<'T>(this: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let tbl = HashSet(comparer)\n            while e.MoveNext() do\n                if tbl.Add(e.Current) then\n                    yield e.Current\n        }\n\n    [<Inline>]\n    static member ElementAt<'T>(this: seq<'T>, index: int): 'T =\n        Seq.item index this\n\n    [<Inline>]\n    static member ElementAtOrDefault<'T>(this: seq<'T>, index: int) =\n        LinqProxy.JSElementAtOrDefault(this, index, Unchecked.defaultof<'T>)\n\n    [<Name \"ElementAtOrDefault\">]\n    static member JSElementAtOrDefault<'T>(this: seq<'T>, index: int, defaultValue: 'T) : 'T =\n        try Seq.item index this\n        with _ -> defaultValue\n\n    [<Inline>]\n    static member Empty<'T>() : seq<'T> =\n        Seq.empty\n\n    [<Inline>]\n    static member Except<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Except(this, second, EqualityComparer.Default)\n\n    static member Except<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for x in second do tbl.Remove(x) |> ignore\n        tbl :> _\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>) : 'T =\n        Seq.head this\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        Seq.find predicate.Invoke this\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        if e.MoveNext() then e.Current else defaultValue\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault$1\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match Seq.tryFind predicate.Invoke this with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, resultSelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : seq<IGrouping<'K, 'E>> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'E>> =\n        Seq.delay (fun () ->\n            // Using an array instead of a seq is important here: the returned groupings\n            // use a ResizeArray that is filled here, so this enumeration must be finished\n            // before the user can enumerate any of the groupings.\n            [|\n                let t = Dictionary<'K, ResizeArray<'E>>(comparer)\n                for x in this do\n                    let k = keySelector.Invoke x\n                    let e = elementSelector.Invoke x\n                    match t.TryGetValue k with\n                    | true, a -> a.Add(e)\n                    | false, _ ->\n                        let a = ResizeArray<'E>()\n                        a.Add(e)\n                        t.[k] <- a\n                        yield Grouping(k, a) :> IGrouping<_,_>\n            |] :> _\n        )\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), resultSelector, comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, comparer)\n        |> Seq.map (fun g -> resultSelector.Invoke(g.Key, g))\n\n    [<Inline>]\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>) : seq<'R> =\n        LinqProxy.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            a |> Array.iteri (fun i (o, is) ->\n                a.[i] <- As (resultSelector.Invoke(o, is)))\n            As a\n        )\n\n    [<Inline>]\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Intersect(this, second, EqualityComparer.Default)\n\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let t1 = HashSet(this, comparer)\n        seq {\n            let t2 = HashSet(comparer)\n            for x in second do\n                if t1.Contains(x) && t2.Add(x) then\n                    yield x\n        }\n\n    [<Inline>]\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>) : IEnumerable<'R> =\n        LinqProxy.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>, comparer: IEqualityComparer<'K>) : IEnumerable<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            [|\n                for (o, is) in a do\n                    for i in is do\n                        yield resultSelector.Invoke(o, i)\n            |] :> _\n        )\n\n    [<Inline>]\n    static member Last<'T>(this: seq<'T>) : 'T =\n        Seq.last this\n\n    static member LastPred(this: seq<'T>, predicate: Func<'T, bool>) : option<'T> =\n        (None, this)\n        ||> Seq.fold (fun acc elt ->\n            if predicate.Invoke elt then Some elt else acc)\n\n    static member Last<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> invalidOp \"Sequence contains no matching element\"\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>) : 'T =\n        Enumerable.LastOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSLastOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"LastOrDefault\">]\n    static member JSLastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>) : int64 =\n        As(Enumerable.Count(this))\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int64 =\n        As(Enumerable.Count(this, predicate))\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<float>) : float =\n        Seq.max this\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<int64>) : int64 =\n        Seq.max this\n\n    static member Max(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.max s)\n\n    [<Inline>]\n    static member Max(this: seq<int>) : int =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<float>) : float =\n        Seq.min this\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<int64>) : int64 =\n        Seq.min this\n\n    static member Min(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.min s)\n\n    [<Inline>]\n    static member Min(this: seq<int>) : int =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member OfType<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast<'T> this\n\n    [<Inline>]\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderBy(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ProjectionComparer(comparer, keySelector)) :> _\n\n    [<Inline>]\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderByDescending(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ReverseComparer(comparer, keySelector)) :> _\n\n    static member Range(start: int, count: int) : seq<int> =\n        Seq.init count ((+) start)\n\n    static member Repeat<'T>(element: 'T, count: int) : seq<'T> =\n        Seq.init count (fun _ -> element)\n\n    static member Reverse<'T>(this: seq<'T>) : seq<'T> =\n        Array.rev (Array.ofSeq this) :> _\n\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, int, 'R>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this\n\n    [<Inline>]\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, 'R>) : seq<'R> =\n        Seq.map selector.Invoke this\n\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'R>>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this |> Seq.concat\n\n    [<Inline>]\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, seq<'R>>) : seq<'R> =\n        Seq.collect selector.Invoke this\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.map (fun t -> t, selector.Invoke t)\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.mapi (fun i t -> t, selector.Invoke(t, i))\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    [<Inline>]\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>) : bool =\n        LinqProxy.SequenceEqual(this, second, EqualityComparer.Default)\n\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : bool =\n        use e1 = this.GetEnumerator()\n        use e2 = this.GetEnumerator()\n        let rec go() =\n            if e1.MoveNext() then\n                e2.MoveNext() && comparer.Equals(e1.Current, e2.Current) && go()\n            else\n                not (e2.MoveNext())\n        go()\n\n    [<Inline>]\n    static member Single<'T>(this: seq<'T>) : 'T =\n        Seq.exactlyOne this\n\n    static member Single<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        let x =\n            (None, this)\n            ||> Seq.fold (fun state cur ->\n                if predicate.Invoke cur then\n                    if state.IsSome then\n                        invalidOp \"Sequence contains more than one matching element\"\n                    else Some cur\n                else state\n            )\n        match x with\n        | None -> invalidOp \"Sequence contains no elements\"\n        | Some x -> x\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.SingleOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSSingleOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"SingleOrDefault\">]\n    static member JSSingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        let mutable found = None\n        while e.MoveNext() do\n            if predicate.Invoke e.Current then\n                match found with\n                | None -> found <- Some e.Current\n                | Some _ -> invalidOp \"Sequence contains more than one element\"\n        match found with\n        | Some x -> x\n        | None -> defaultValue\n\n    static member Skip<'T>(this: seq<'T>, count: int) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do i <- i + 1\n            while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    i <- i + 1\n                else\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if not (predicate.Invoke e.Current) then\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    [<Inline>]\n    static member Sum(this: seq<int64>) : int64 =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<float>) : float =\n        Seq.sum this\n\n    static member Sum(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.sum s)\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<int>) : int =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    static member Take<'T>(this: seq<'T>, count: int) =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() && predicate.Invoke(e.Current, i) do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            while e.MoveNext() && predicate.Invoke(e.Current) do\n                yield e.Current\n        }\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, false)\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, false)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, true)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, true)\n\n    [<Inline>]\n    static member ToArray<'T>(this: seq<'T>) : 'T[] =\n        Seq.toArray this\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>) : Dictionary<'K, 'T> =\n        LinqProxy.ToDictionary(this, keySelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'T> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, x)) this\n        d\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : Dictionary<'K, 'E> =\n        LinqProxy.ToDictionary(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'E> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, elementSelector.Invoke x)) this\n        d\n\n    [<Inline>]\n    static member ToList<'T>(this: seq<'T>) : List<'T> =\n        List<'T>(this)\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), comparer) :> _\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, comparer) :> _\n\n    [<Inline>]\n    static member Union<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Union(this, second, EqualityComparer<'T>.Default)\n\n    static member Union<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for e in second do tbl.Add(e) |> ignore\n        tbl :> _\n\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    yield e.Current\n                i <- i + 1\n        }\n\n    [<Inline>]\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        Seq.filter predicate.Invoke this\n\n    [<Inline>]\n    static member Zip<'T, 'U, 'R>(this: seq<'T>, second: seq<'U>, resultSelector: Func<'T, 'U, 'R>) : seq<'R> =\n        Seq.map2 (fun x y -> resultSelector.Invoke(x, y)) this second\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\nopen FSharp.Quotations\n\nopen FSharp.Linq\n\n[<Proxy(typeof<QuerySource<_,_>>)>]\ntype internal QuerySourceProxy<'T, 'Q> [<Inline \"$source\">] (source: IEnumerable<'T>) =\n\n    [<Inline \"$this\">]\n    member this.Source = source\n                                \n[<Proxy(typeof<QueryBuilder>)>]\n[<Name \"WebSharper.Query\">]\ntype internal QueryBuilderProxy() =\n    [<Inline>]\n    member this.All(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.forall predicate source.Source\n\n    [<Inline>]\n    member inline this.AverageBy\n            (source: QuerySource<'T, 'Q>, projection: 'T -> ^Value) =\n        Seq.averageBy projection source.Source\n\n    [<Name \"averageByNullable\">]\n    static member inline AverageByNullableImpl \n            (source: QuerySource<'T, 'Q>, projection: 'T -> Nullable< ^TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        if filtered.Length = 0 then Nullable() else Nullable(Array.average filtered) \n\n    [<Inline>]\n    member inline this.AverageByNullable (source, projection) = QueryBuilderProxy.AverageByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Contains(source: QuerySource<'T, 'Q>, key: 'T) =\n        Seq.contains key source.Source\n\n    [<Inline>]\n    member this.Count(source: QuerySource<'T, 'Q>) =\n        Seq.length source.Source\n\n    [<Inline>]\n    member this.Distinct(source: QuerySource<'T, 'Q>) =\n        Seq.distinct source.Source |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ExactlyOne(source: QuerySource<'T, 'Q>) =\n        Seq.exactlyOne source.Source\n     \n    [<Inline>]\n    member this.ExactlyOneOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.SingleOrDefault()\n\n    [<Inline>]\n    member this.Exists(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.exists predicate source.Source\n     \n    [<Inline>]\n    member this.Find(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.find predicate source.Source\n\n    [<Inline>]\n    member this.For(source: QuerySource<'T, 'Q>, body: 'T -> QuerySource<'TResult, 'Q2>) =\n        Seq.collect (fun x -> (body x).Source) source.Source |> QuerySource<'TResult, 'Q>\n     \n    [<Inline>]\n    member this.GroupBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy(fun x -> keySelector x) |> QuerySource<IGrouping<'TKey, 'T>, 'Q>\n\n    [<Inline>]\n    member this.GroupJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.GroupValBy<'T, 'TKey, 'TValue, 'Q>(source: QuerySource<'T, 'Q>, resultSelector: 'T -> 'TValue, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy((fun x -> keySelector x), (fun x -> resultSelector x)) |> QuerySource<IGrouping<'TKey, 'TValue>, 'Q>\n\n    [<Inline>]\n    member this.Head(source: QuerySource<'T, 'Q>) =\n        Seq.head source.Source\n\n    [<Inline>]\n    member this.HeadOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.FirstOrDefault()\n    \n    [<Inline>]\n    member this.Join\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> 'TInner -> 'TResult\n      ) =\n        outerSource.Source.Join(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Last(source: QuerySource<'T, 'Q>) =\n        Seq.last source.Source\n \n    [<Inline>]\n    member this.LastOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.LastOrDefault()\n\n    [<Inline>]\n    member this.LeftOuterJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x (y.DefaultIfEmpty()))\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.MaxBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Max(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MaxByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Max(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.MinBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Min(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MinByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Min(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.Nth(source: QuerySource<'T, 'Q>, index: int) =\n        Seq.item index source.Source\n\n    [<Inline>]\n    member this.Quote(q: Expr<'T>) = q\n\n    [<Inline>]\n    member this.Run(q: Expr<QuerySource<'T, IQueryable>>) =\n        (As<QuerySource<'T, obj>> q).Source |> As<IQueryable<'T>>      \n           \n    [<Inline>]\n    member this.Select(source: QuerySource<'T, 'Q>, projection: 'T -> 'TResult) =\n        source.Source |> Seq.map projection |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Skip(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Skip(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SkipWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.SkipWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    [<Inline>]\n    member this.SortBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Source(source: seq<'T>) = \n        QuerySource<'T,  System.Collections.IEnumerable>(source)\n\n    [<Inline>]\n    member this.Source(source: IQueryable<'T>) = \n        QuerySource<'T, 'Q>(source)\n\n    [<Inline>]                                                              \n    member inline this.SumBy(source: QuerySource<'T, 'Q>, projection: 'T -> ^TValue) =\n        Seq.sumBy projection source.Source\n\n    [<Name \"sumByNullable\">]                                                              \n    static member inline SumByNullableImpl(source: QuerySource<'T, 'Q>, projection: 'T -> Nullable<'TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        Nullable(Array.sum filtered) \n\n    [<Inline>]\n    member inline this.SumByNullable(source, projection) = QueryBuilderProxy.SumByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Take(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Take(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.TakeWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.TakeWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    static member CheckThenBySource(source: IEnumerable<'T>) =\n        match source with\n        | :? IOrderedEnumerable<'T> as e ->\n            e\n        | _ ->\n            failwith \"'thenBy' and 'thenByDescending' may only be used with an ordered input\"\n\n    [<Inline>]\n    member this.ThenBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Where(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.Where(fun x -> predicate x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Yield(value: 'T) =\n        Seq.singleton value |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.YieldFrom(computation: QuerySource<'T, 'Q>) =\n        computation\n    \n    [<Inline>]\n    member this.Zero() =\n        Seq.empty |> QuerySource<'T, 'Q>\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Core.ExtraTopLevelOperators, FSharp.Core\">]\nmodule internal ExtraTopLevelOperatorsQueryProxy =\n    \n    [<Inline \"null\">]\n    let query = query\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority, FSharp.Core\">]\nmodule internal HighPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsEnumerable (this: QueryBuilder) (q: Expr<QuerySource<'T, IEnumerable>>) =\n        (As<QuerySource<'T, IEnumerable>> q).Source   \n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority, FSharp.Core\">]\nmodule internal LowPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsValue (this: QueryBuilder) (q: Expr<'T>) =\n        As<'T> q\n"],
"names": [],
"mappings": "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"
}

//# sourceMappingURL=WebSharper.Collections.min.map