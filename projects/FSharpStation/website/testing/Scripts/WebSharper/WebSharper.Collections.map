{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Collections/BalancedTree.fs", "WebSharper.Collections/Pair.fs", "WebSharper.Collections/Map.fs", "WebSharper.Collections/MapModule.fs", "WebSharper.Collections/Set.fs", "WebSharper.Collections/SetModule.fs", "WebSharper.Collections/ResizeArray.fs", "WebSharper.Collections/LinkedList.fs", "WebSharper.Collections/Linq.fs", "WebSharper.Collections/Query.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Provides balanced binary search tree operations.\n[<JavaScript>]\nmodule internal BalancedTree =\n\n    /// Represents a binary balanced search tree, preserving the balance\n    /// invariant: the heights of the branches differ by at most 1.\n    type Tree<'T when 'T : comparison> =\n        private {\n            Node    : 'T\n            Left    : Tree<'T>\n            Right   : Tree<'T>\n            Height  : int\n            Count   : int\n        }\n\n    [<Inline \"null\">]\n    let Empty<'T when 'T : comparison> = X<Tree<'T>>\n\n    [<Inline \"$tree == null\">]\n    let IsEmpty (tree: Tree<'T>) = X<bool>\n\n    [<Inline \"$tree == null ? 0 : $tree.Height\">]\n    let Height (tree: Tree<'T>) = X<int>\n            \n    [<Inline \"$tree == null ? 0 : $tree.Count\">]\n    let Count (tree: Tree<'T>) = X<int>\n\n    [<Inline \"$t.Left\">]\n    let Left (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Right\">]\n    let Right (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Node\">]\n    let Node (t: Tree<'T>) = X<'T>\n\n    let Branch node left right =\n        {\n            Node    = node\n            Left    = left\n            Right   = right\n            Height  = 1 + max (Height left) (Height right)\n            Count   = 1 + Count left + Count right\n        }\n\n    let Enumerate flip (t: Tree<'T>) : seq<'T> =\n        let rec gen (t, spine: list<'T * Tree<'T>>) =\n            if IsEmpty t then\n                match spine with\n                | []                    -> None\n                | (t, other) :: spine   -> Some (t, (other, spine))\n            else\n                if flip\n                then gen (Right t, (Node t, Left t) :: spine)\n                else gen (Left t, (Node t, Right t) :: spine)\n        Seq.unfold gen (t, [])\n\n    /// Traverses the tree in ascending order.\n    [<Inline>]\n    let Ascend t = Enumerate false t\n\n    /// Traverses the tree in descending order.\n    [<Inline>]\n    let Descend t = Enumerate true t\n\n    /// Builds a tree from sorted input and the indices of the\n    /// first and the last elements to include.\n    let rec private Build (data: 'T []) min max : Tree<'T> =\n        let sz = max - min + 1\n        if sz <= 0 then\n            Empty\n        else\n            let center = (min + max) / 2\n            let left   = Build data min (center - 1)\n            let right  = Build data (center + 1) max\n            Branch data.[center] left right\n\n    /// Quickly constructs a tree from a sorted, distinct array.\n    [<Inline>]\n    let OfSorted (data: 'T []) : Tree<'T> =\n        Build data 0 (Array.length data - 1)\n\n    let OfSeq (data: seq<'T>) : Tree<'T> =\n        let a = Seq.toArray (Seq.distinct data)\n        Array.sortInPlace a\n        OfSorted a\n\n    [<Inline \"$x.unshift($y)\">]\n    let private unshift (x: 'T) y = X<unit>\n\n    /// Unzips a tree into a matching node and a spine.\n    let Lookup (k: 'T) (t: Tree<'T>) =\n        let mutable spine = [||]\n        let mutable t = t\n        let mutable loop = true\n        while loop do\n            if IsEmpty t then loop <- false else\n                match compare k t.Node with\n                | 0 -> loop <- false\n                | 1 ->\n                    unshift spine (true, t.Node, t.Left)\n                    t <- t.Right\n                | _ ->\n                    unshift spine (false, t.Node, t.Right)\n                    t <- t.Left\n        (t, spine)\n\n    /// Rebuilds an unzipped tree by going up the spine and performing\n    /// rotations where necessary for balance.\n    let private Rebuild<'T when 'T : comparison>\n            (spine: (bool * 'T * Tree<'T>) []) (t: Tree<'T>) : Tree<'T> =\n        let h (x: Tree<'T>) = Height x\n        let mutable t = t\n        for i = 0 to spine.Length - 1 do\n            t <- (\n                match spine.[i] with\n                | false, x, r ->\n                    if h t > h r + 1 then\n                        if h t.Right = h t.Left + 1 then\n                            // Double rotation:\n                            let m = t.Right\n                            Branch  m.Node\n                                    (Branch t.Node t.Left m.Left)\n                                    (Branch x m.Right r)\n                        else\n                            // Single rotation:\n                            Branch  t.Node\n                                    t.Left\n                                    (Branch x t.Right r)\n                    else\n                        // No rotation:\n                        Branch x t r\n                | true, x, l ->\n                    if h t > h l + 1 then\n                        if h t.Left = h t.Right + 1 then\n                            // Double rotation:\n                            let m = t.Left\n                            Branch m.Node\n                                    (Branch x l m.Left)\n                                    (Branch t.Node m.Right t.Right)\n                        else\n                            // Single rotation:\n                            Branch t.Node\n                                    (Branch x l t.Left)\n                                    t.Right\n                    else\n                        // No rotation:\n                        Branch x l t\n            )\n        t\n\n    /// Inserts or updates a node in the tree. If a matching node is found,\n    /// it is replaced with the value of \"combine old new\".\n    let Put<'T when 'T : comparison> combine k (t: Tree<'T>) : Tree<'T> =\n        let (t, spine) = Lookup k t\n        if IsEmpty t then\n            Rebuild spine (Branch k Empty Empty)\n        else\n            Rebuild spine (Branch (combine t.Node k) t.Left t.Right)\n\n    /// Removes a node from the tree.\n    let Remove k (src: Tree<'T>) =\n        let (t, spine) = Lookup k src\n        if IsEmpty t then\n            src\n        else\n            if IsEmpty t.Right then\n                Rebuild spine t.Left\n            elif IsEmpty t.Left then\n                Rebuild spine t.Right\n            else\n                Seq.append (Ascend t.Left) (Ascend t.Right)\n                |> Seq.toArray\n                |> OfSorted\n                |> Rebuild spine\n\n    /// Adds a node into the tree, replacing an existing one if found.\n    let Add<'T when 'T : comparison> (x: 'T) (t: Tree<'T>) : Tree<'T> =\n        Put (fun _ x -> x) x t\n\n    /// Checks if a tree contains a given key.\n    let rec Contains (v: 'T) (t: Tree<'T>) : bool =\n        not (IsEmpty (fst (Lookup v t)))\n\n    /// Looks up a node by key.\n    let TryFind (v: 'T) (t: Tree<'T>) =\n        let x = fst (Lookup v t)\n        if IsEmpty x then None else Some x.Node\n\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\n\n/// Represents a key-value pair with comparison and equality\n/// ignoring the value and using only the key.\n[<CustomComparison>]\n[<CustomEquality>]\n[<JavaScript>]\ntype internal Pair<'K,'V when 'K : comparison> =\n    {\n        Key     : 'K\n        Value   : 'V\n    }\n\n    override this.GetHashCode() = hash this.Key\n\n    override this.Equals(other: obj) =\n        this.Key = (other :?> Pair<'K,'V>).Key\n\n    interface System.IComparable with\n        member this.CompareTo(other: obj) =\n            compare this.Key (other :?> Pair<'K,'V>).Key\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Collections\nmodule T = BalancedTree\n\n[<JavaScript>]\n[<AutoOpen>]\nmodule private MapUtil =\n\n    let fromSeq(s: seq<_>) =\n        let a : Pair<_,_> [] =\n            [| for (k, v) in Seq.distinctBy fst s ->\n                { Key = k; Value = v } |]\n        Array.sortInPlace a\n        T.OfSorted a\n\n/// Implements a proxy for the F# Map type.\n[<Name \"FSharpMap\">]\n[<Proxy(typeof<Map<_,_>>)>]\ntype internal FSharpMap<'K,'V when 'K : comparison>\n\n    (tree: T.Tree<Pair<'K,'V>>) =\n\n        new (s: seq<_>) = new FSharpMap<_,_>(fromSeq s)\n\n        member this.Tree = tree\n\n        member this.Add(k: 'K, v: 'V) : Map<'K,'V> =\n            As (FSharpMap<'K,'V>(tree |> T.Add {Key=k; Value=v}))\n\n        member this.ContainsKey k = \n            tree |> T.Contains {Key=k; Value = JS.Undefined}\n\n        member this.TryGetValue (k: 'K, r: byref<'V>) = \n            match this.TryFind k with\n            | Some v ->\n                r <- v\n                true\n            | _ ->\n                false\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member this.Item \n            with get (k: 'K) : 'V =\n                match this.TryFind k with\n                | Some v    ->v\n                | None      ->\n                    failwith \"The given key was not present in the dictionary.\"\n\n        member this.Remove(k: 'K) : Map<'K,'V> =\n            As (FSharpMap(tree |> T.Remove {Key=k; Value=JS.Undefined}))\n\n        member this.TryFind(k: 'K) =\n            tree\n            |> T.TryFind {Key=k; Value=JS.Undefined}\n            |> Option.map (fun kv -> kv.Value)\n\n        member this.GetEnumerator() =\n            let s =\n                T.Ascend tree\n                |> Seq.map (fun kv ->\n                    new KeyValuePair<_,_>(kv.Key, kv.Value))\n            s.GetEnumerator()\n\n        override this.GetHashCode() =\n            hash (Seq.toArray this)\n\n        override this.Equals(other) =\n            let other = As<FSharpMap<'K,'V>> other\n            this.Count = other.Count\n            && Seq.forall2 ( = ) this other\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith (fun x y ->\n                    compare (As<Pair<'K,'V>> x) (As<Pair<'K,'V>> y))\n                    this\n                    (As<Map<'K,'V>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Map module.\n[<Proxy \"Microsoft.FSharp.Collections.MapModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Map\">]\nmodule internal MapModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (m: Map<'K,'V>) =\n        (As<FSharpMap<'K,'V>> m).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<_>) : Map<'K,'V> =\n        As (new FSharpMap<'K,'V>(t))\n\n    [<Inline>]\n    let Add k v (m: Map<'K,'V>) : Map<'K,'V> = m.Add(k, v)\n\n    [<Inline>]\n    let ContainsKey k (m: Map<'K,'V>) : bool = m.ContainsKey k\n\n    [<Inline>]\n    let Empty<'K,'V when 'K : comparison> : Map<'K,'V> = new Map<_,_>([||])\n\n    let Exists (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : bool =\n        m |> Seq.exists (fun kv -> f kv.Key kv.Value)\n\n    let Filter (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> =\n        T.Ascend (ToTree m)\n        |> Seq.filter (fun kv -> f kv.Key kv.Value)\n        |> Seq.toArray\n        |> T.OfSorted\n        |> OfTree\n\n    [<Inline>]\n    let Find (k: 'K) (m: Map<'K,'V>) : 'V = m.[k]\n\n    let FindKey (f: 'K -> 'T -> bool) (m: Map<'K,'T>) : 'K =\n        m \n        |> Seq.pick (fun kv -> \n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec Fold<'K,'V,'S when 'K : comparison>\n        (f: 'S -> 'K -> 'V -> 'S) (s: 'S) (m: Map<'K,'V>) : 'S =\n            T.Ascend (ToTree m)\n            |> Seq.fold (fun s kv -> f s kv.Key kv.Value) s\n\n    let rec FoldBack (f: 'K -> 'V -> 'S -> 'S) (m: Map<'K,'V>) (s: 'S) : 'S =\n        T.Descend (ToTree m)\n        |> Seq.fold (fun s kv -> f kv.Key kv.Value s) s\n\n    let rec ForAll (f: 'K -> 'V -> bool) (m: Map<'K, 'V>) : bool =\n        m |> Seq.forall (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let IsEmpty (m: Map<'K, 'V>) : bool = m.IsEmpty\n\n    let rec Iterate (f: 'K -> 'V -> unit) (m: Map<'K, 'V>) : unit =\n        m |> Seq.iter (fun kv -> f kv.Key kv.Value)\n\n    let OfArray (a: ('K * 'V) []) : Map<'K,'V> =\n        a\n        |> Seq.map (fun (k, v) -> {Key = k; Value = v} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n    [<Inline>]\n    let OfList (kvs: list<'K * 'V>) : Map<'K,'V> = Map.ofSeq kvs\n\n    [<Inline>]\n    let OfSeq (s: seq<'K * 'V>) : Map<'K, 'V> =\n        Map.ofArray (Seq.toArray s)\n\n    let Partition (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> * Map<'K,'V> =\n        let (x, y) =\n            Seq.toArray (T.Ascend (ToTree m))\n            |> Array.partition (fun kv -> f kv.Key kv.Value)\n        (OfTree (T.OfSorted x), OfTree (T.OfSorted y))\n\n    let Pick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : 'T =\n        m |> Seq.pick (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let Remove (k: 'K) (m: Map<'K, 'V>) : Map<'K, 'V> = m.Remove k\n\n    [<Inline>]\n    let ToArray (m: Map<'K, 'V>) : array<'K * 'V> = Seq.toArray (Map.toSeq m)\n\n    [<Inline>]\n    let ToList (m: Map<'K, 'V>) : list<'K * 'V> = Seq.toList (Map.toSeq m)\n\n    let ToSeq (m: Map<'K, 'V>) : seq<'K * 'V> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> (kv.Key, kv.Value))\n\n    let TryFind (k: 'K) (m: Map<'K, 'V>) : option<'V> = m.TryFind k\n\n    let TryFindKey (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : option<'K> =\n        m |> Seq.tryPick (fun kv ->\n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec TryPick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : option<'T> =\n        m |> Seq.tryPick (fun kv -> f kv.Key kv.Value)\n         \n    let rec Map (f: 'K -> 'V -> 'T) (m: Map<'K,'V>) : Map<'K,'T> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> \n            {Key = kv.Key; Value = f kv.Key kv.Value} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nmodule T = BalancedTree\n\n/// Implements a proxy for the F# Set type.\n[<Name \"FSharpSet\">]\n[<Proxy(typeof<Set<_>>)>]\ntype private FSharpSet<'T when 'T : comparison>\n\n    internal (tree: T.Tree<'T>) =\n\n        new (s: seq<'T>) = new FSharpSet<'T>(T.OfSeq s)\n\n        member this.add(x: Set<'T>) =\n            Set.union (As this) x\n\n        member this.sub(x: Set<'T>) =\n            Set.difference (As this) x\n\n        member this.Add x : Set<'T> =\n            As (FSharpSet<'T>(T.Add x tree))\n\n        member this.Contains v = T.Contains v tree\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member internal this.Tree = tree\n\n        member this.IsProperSubsetOf(s: Set<'T>) =\n            this.IsSubsetOf s && this.Count < s.Count\n\n        member this.IsProperSupersetOf(s: Set<'T>) =\n            this.IsSupersetOf s && this.Count > s.Count\n\n        member this.IsSubsetOf(s: Set<'T>) =\n            Seq.forall s.Contains this\n\n        member this.IsSupersetOf(s: Set<'T>) =\n            Seq.forall this.Contains s\n\n        member this.MaximumElement = Seq.head (T.Descend tree)\n\n        member this.MinimumElement = Seq.head (T.Ascend tree)\n\n        member this.Remove v : Set<'T> =\n            As (FSharpSet<'T>(T.Remove v tree))\n\n        member this.GetEnumerator() =\n            (T.Ascend tree).GetEnumerator()\n\n        static member (+) (x, y) : Set<'T> =\n            Set.union x y        \n\n        static member (-) (x, y) : Set<'T> =\n            Set.difference x y        \n\n        override this.GetHashCode() =\n            -1741749453 + ((Seq.toArray this).GetHashCode())\n\n        override this.Equals(other: obj) =\n            this.Count = (As<FSharpSet<'T>> other).Count\n            && Seq.forall2 ( = ) this (As<FSharpSet<'T>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith compare this (As<FSharpSet<'T>> other)\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Set module.\n[<Proxy \"Microsoft.FSharp.Collections.SetModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Set\">]\nmodule internal SetModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (s: Set<'T>) =\n        (As<FSharpSet<'T>> s).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<'T>) =\n        As<Set<'T>> (new FSharpSet<'T>(t))\n\n    [<Inline>]\n    let Add v (s: Set<_>) = s.Add v\n\n    [<Inline>]\n    let Contains v (s: Set<_>) = s.Contains v\n\n    [<Inline>]\n    let Count (s: Set<_>) = s.Count\n\n    [<Inline>]\n    let Difference (s1: Set<_>) (s2: Set<_>) =\n        Set.filter (fun x -> not (s2.Contains x)) s1\n\n    [<Inline>]\n    let Empty<'T when 'T : comparison> : Set<'T> = OfTree T.Empty\n\n    [<Inline>]\n    let Exists f (s: Set<'T>) = Seq.exists f s\n\n    let Filter f (s: Set<'T>) =\n        OfTree (T.OfSorted (Seq.toArray (Seq.filter f s)))\n\n    [<Inline>]\n    let Fold<'T,'S when 'T : comparison>\n        (f: 'S -> 'T -> 'S) (x: 'S) (a: Set<'T>) =\n            Seq.fold f x a\n\n    let FoldBack (f: 'T -> 'S -> 'S) (a: Set<'T>) (s: 'S) : 'S =\n        Seq.fold (fun s x -> f x s) s (T.Descend (ToTree a))\n\n    [<Inline>]\n    let ForAll f (a: Set<_>) = Seq.forall f a\n\n    [<Inline>]\n    let Intersect (s1: Set<'T>) (s2: Set<'T>) = Set.filter s2.Contains s1\n\n    [<Inline>]\n    let IntersectMany (s: seq<Set<_>>) = Seq.reduce Set.intersect s\n\n    [<Inline>]\n    let IsEmpty (a: Set<_>) = a.IsEmpty\n\n    [<Inline>]\n    let IsProperSubset (a: Set<_>) b = a.IsProperSubsetOf b\n\n    [<Inline>]\n    let IsProperSuperset (a: Set<_>) b = a.IsProperSupersetOf b\n\n    [<Inline>]\n    let IsSubset (a: Set<_>) b = a.IsSubsetOf b\n\n    [<Inline>]\n    let IsSuperset (a: Set<_>) b = a.IsSupersetOf b\n\n    [<Inline>]\n    let Iterate f (s: Set<_>) = Seq.iter f s\n\n    [<Inline>]\n    let Map f (s: Set<_>) = Set.ofSeq (Seq.map f s)\n\n    [<Inline>]\n    let MaxElement (s: Set<_>) = s.MaximumElement\n\n    [<Inline>]\n    let MinElement (s: Set<_>) = s.MinimumElement\n\n    [<Inline>]\n    let OfArray (a: 'T []) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfList (a: list<'T>) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfSeq (a: seq<'T>) = OfTree (T.OfSeq a)\n\n    let Partition f (a: Set<_>) =\n        let (x, y) = Array.partition f (Seq.toArray a)\n        (Set.ofArray x, Set.ofArray y)\n\n    [<Inline>]\n    let Remove v (a: Set<_>) = a.Remove v\n\n    [<Inline>]\n    let Singleton x = Set.add x Set.empty\n\n    [<Inline>]\n    let ToArray (a: Set<_>) = Seq.toArray a\n\n    [<Inline>]\n    let ToList (a: Set<_>) = Seq.toList a\n\n    [<Inline>]\n    let ToSeq (a: Set<_>) : seq<_> = a :> _\n\n    [<Inline>]\n    let Union (s1: Set<_>) (s2: Set<_>) =\n        Set.ofSeq (Seq.append s1 s2)\n\n    [<Inline>]\n    let UnionMany (sets: seq<Set<_>>) =\n        Set.ofSeq (Seq.concat sets)\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.ResizeArray\n\nopen WebSharper\nopen WebSharper.JavaScript\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\n\n[<Name \"WebSharper.Collections.ListEnumerator\">]\n[<Proxy(typeof<System.Collections.Generic.List.Enumerator<_>>)>]\ntype ResizeArrayEnumeratorProxy<'T> [<JavaScript>] (arr: 'T[]) =\n    let mutable i = -1\n\n    [<JavaScript>] \n    member this.MoveNext() =\n        i <- i + 1\n        i < arr.Length\n\n    [<JavaScript>] \n    member this.Current with get() = arr.[i]\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = this.MoveNext()\n        [<JavaScript>]\n        member this.Current with get() = box (arr.[i])\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = arr.[i]\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = ()\n\n[<Proxy(typeof<System.Collections.Generic.List<_>>)>]\n[<Name \"WebSharper.Collections.List\">]\n[<Prototype false>]\ntype ResizeArrayProxy<'T> [<Inline \"$_arr\">] (_arr: 'T []) =\n\n    [<Inline \"[]\">]\n    new () =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline \"[]\">]\n    new (size: int) =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline>]\n    new (el: seq<'T>) =\n        new ResizeArrayProxy<'T>(Seq.toArray el)\n\n    [<Inline>]\n    member this.GetEnumerator() =\n        As<System.Collections.Generic.List.Enumerator<'T>>(new ResizeArrayEnumeratorProxy<'T>(As<'T[]> this))\n\n    interface 'T seq with\n        member this.GetEnumerator() = (As<System.Collections.IEnumerable> this).GetEnumerator()\n        member this.GetEnumerator() = (As<seq<'T>> this).GetEnumerator()\n\n    [<Inline>]\n    member this.Add(x: 'T) : unit =\n        As<'T[]>(this).JS.Push(x) |> ignore\n\n    [<Inline>]\n    member this.AddRange(x: seq<'T>) : unit =\n        Seq.iter this.Add x\n\n    [<Inline>]\n    member this.AsReadOnly() : System.Collections.ObjectModel.ReadOnlyCollection<'T> =\n        System.Array.AsReadOnly(As<'T[]> this)\n\n    [<Inline>]\n    member this.BinarySearch(start: int, length: int, item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, start, length, item, comparer)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T) : int =\n        System.Array.BinarySearch(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, item, comparer)\n\n    [<Inline>]\n    member this.Clear() : unit =\n        (As<'T[]> this).JS.Splice(0, this.Count) |> ignore\n\n    [<Inline>]\n    member this.Contains(item: 'T) : bool =\n        System.Array.Exists(As<'T[]> this, fun x -> System.Collections.Generic.EqualityComparer.Default.Equals(item, x))\n\n    [<Inline>]\n    member this.ConvertAll<'U>(conv: System.Converter<'T, 'U>) : ResizeArray<'U> =\n        ResizeArray<'U>(System.Array.ConvertAll(As<'T[]> this, conv))\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[]) : unit =\n        this.CopyTo(arr, 0)\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[], offset: int) : unit =\n        this.CopyTo(0, arr, offset, this.Count)\n\n    [<Inline>]\n    member this.CopyTo(index: int, target: 'T[], offset: int, count: int) : unit =\n        Array.blit (As<'T[]> this) index target offset count\n\n    [<Inline>]\n    member this.Count : int = (As<'T[]> this).Length\n\n    [<Inline>]\n    member this.Exists(pred: System.Predicate<'T>) : bool =\n        System.Array.Exists(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.Find(pred: System.Predicate<'T>) : 'T =\n        System.Array.Find(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindAll(pred: System.Predicate<'T>) : ResizeArray<'T> =\n        ResizeArray<'T>(System.Array.FindAll(As<'T[]> this, pred))\n\n    [<Inline>]\n    member this.FindIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.FindLast(pred: System.Predicate<'T>) : 'T =\n        System.Array.FindLast(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.ForEach(action: System.Action<'T>) : unit =\n        System.Array.ForEach(As<'T[]> this, action)\n\n    [<Inline>]\n    member this.GetRange(index: int, count: int) : ResizeArray<'T> =\n        As (ResizeArrayProxy<'T>(Array.sub (As<'T[]> this) index count))\n\n    [<Inline>]\n    member this.IndexOf(item: 'T) : int =\n        System.Array.IndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start, count)\n\n    [<Inline>]\n    member this.Insert(index: int, item: 'T) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, item) |> ignore\n\n    [<Inline>]\n    member this.InsertRange(index: int, items: seq<'T>) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, Array.ofSeq items) |> ignore\n\n    member this.Item\n        with [<Inline>] get (x: int) : 'T = (As<'T[]> this).[x]\n        and [<Inline>] set (x: int) (v: 'T) = (As<'T[]> this).[x] <- v\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start, count)\n\n    member this.Remove(item: 'T) : bool =\n        match this.IndexOf(item) with\n        | -1 -> false\n        | n -> this.RemoveAt(n); true\n\n    member this.RemoveAll(pred: System.Predicate<'T>) : int =\n        let mutable removed = 0\n        let mutable i = 0\n        while i < this.Count do\n            if pred.Invoke((As<'T[]> this).JS.[i]) then\n                let mutable j = i + 1\n                while j < this.Count && pred.Invoke((As<'T[]> this).JS.[j]) do\n                    j <- j + 1\n                removed <- removed + j - i\n                (As<'T[]> this).JS.Splice(i, j - i) |> ignore\n            else\n                i <- i + 1\n        removed\n\n    [<Inline>]\n    member this.RemoveAt(x: int) : unit =\n        (As<'T[]> this).JS.Splice(x, 1) |> ignore\n\n    [<Inline>]\n    member this.RemoveRange(index: int, count: int) : unit =\n        (As<'T[]> this).JS.Splice(index, count) |> ignore\n\n    [<Inline>]\n    member this.Reverse() : unit =\n        System.Array.Reverse(As<'T[]> this)\n\n    [<Inline>]\n    member this.Reverse(index: int, count: int) : unit =\n        System.Array.Reverse(As<'T[]> this, index, count)\n\n    [<Inline>]\n    member this.Sort() : unit =\n        System.Array.Sort(As<'T[]> this)\n\n    [<Inline>]\n    member this.Sort(comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.Sort(start: int, length: int, comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, start, length, comp)\n\n    [<Inline>]\n    member this.Sort(comp: System.Comparison<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.ToArray() : 'T [] =\n        Array.copy (As<'T[]> this)\n\n    [<Inline>]\n    member this.TrimExcess() = ()\n\n    [<Inline>]\n    member this.TrueForAll(pred: System.Predicate<'T>) : bool =\n        System.Array.TrueForAll(As<'T[]> this, pred)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.LinkedList\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype LL<'T> = LinkedList<'T>\ntype LLN<'T> = LinkedListNode<'T>\ntype LLE<'T> = LinkedList<'T>.Enumerator\n\n[<Proxy(typeof<LLN<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListNode\">]\ntype NodeProxy<'T> =\n    member this.Previous with [<Inline \"$this.p\">] get () = X<LLN<'T>>\n    member this.Next     with [<Inline \"$this.n\">] get () = X<LLN<'T>>\n    member this.Value    with [<Inline \"$this.v\">] get () = X<'T>\n\n[<Inline \"{p: $p, n: $n, v: $v}\">]\nlet newNode<'T> (p: LLN<'T>) (n: LLN<'T>) (v: 'T) = X<LLN<'T>>\n\n[<Inline \"$node.p = $p\" >]\nlet setPrev (node: LLN<'T>) (p: LLN<'T>) = ()\n\n[<Inline \"$node.n = $n\" >]\nlet setNext (node: LLN<'T>) (n: LLN<'T>) = ()\n\n[<Proxy(typeof<LLE<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListEnumerator\">]\ntype EnumeratorProxy<'T> [<JavaScript>] (l: LLN<'T>) =\n    let mutable c = l\n\n    interface IEnumerator<'T> with\n        member this.Current = c.Value\n        \n        member this.Current = c.Value |> box\n\n        member this.MoveNext() =\n            c <- c.Next\n            c <> null\n\n        member this.Dispose() = ()\n\n        member this.Reset() = ()\n\n[<Proxy(typeof<LL<_>>)>]\n[<Name \"WebSharper.Collections.LinkedList\">]\ntype ListProxy<'T> [<JavaScript>] (coll: 'T seq) =\n    let mutable c = 0\n    let mutable n = null\n    let mutable p = null\n\n    do  let ie = coll.GetEnumerator()\n        if ie.MoveNext() then\n            n <- newNode null null ie.Current\n            p <- n\n            c <- 1\n        while ie.MoveNext() do\n            let node = newNode p null ie.Current\n            setNext p node\n            p <- node\n            c <- c + 1\n            \n    new () = ListProxy(Seq.empty)          \n\n    [<Inline>]\n    member this.Count = c\n\n    [<Inline>]\n    member this.First = n\n\n    [<Inline>]\n    member this.Last = p\n\n    member this.AddAfter(after: LLN<'T>, value) =\n        let before = after.Next\n        let node = newNode after before value\n        if after.Next = null then p <- node\n        setNext after node\n        if before <> null then setPrev before node\n        c <- c + 1\n        node\n\n    member this.AddBefore(before: LLN<'T>, value) =\n        let after = before.Previous\n        let node = newNode after before value\n        if before.Previous = null then n <- node \n        setPrev before node\n        if after <> null then setNext after node\n        c <- c + 1\n        node\n\n    member this.AddFirst(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddBefore(n, value)\n\n    member this.AddLast(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddAfter(p, value)\n\n    member this.Clear() =\n        c <- 0\n        n <- null\n        p <- null\n\n    member this.Contains(value: 'T) =\n        let mutable found = false\n        let mutable node = n\n        while node <> null && not found do\n            if node.Value ==. value then found <- true \n            else node <- node.Next\n        found\n            \n    member this.Find(value: 'T) =\n        let mutable node = n\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Next\n        if notFound then null else node\n\n    member this.FindLast(value: 'T) = \n        let mutable node = p\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Previous\n        if notFound then null else node\n                \n    member this.GetEnumerator(): LinkedList<'T>.Enumerator =\n        As (new EnumeratorProxy<_>(As this))\n\n    interface IEnumerable with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    interface IEnumerable<'T> with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    member this.Remove(node: LLN<'T>) =\n        let before = node.Previous\n        let after = node.Next\n        if before = null then n <- after else setNext before after\n        if after = null then p <- before else setPrev after before\n        c <- c - 1\n        \n    member this.Remove(value) = \n        let node = this.Find(value)\n        if node = null then false\n        else\n            this.Remove(node)\n            true\n\n    member this.RemoveFirst() = this.Remove(n)\n\n    member this.RemoveLast() = this.Remove(p)\n               \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<IGrouping<_, _>>)>]\ntype internal IGroupingProxy<'K, 'T> =\n    abstract Key : 'K\n\n[<JavaScript>]\ntype internal Grouping<'K, 'T> (k: 'K, v: seq<'T>) =\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            v.GetEnumerator()\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() =\n            (v :> System.Collections.IEnumerable).GetEnumerator()\n\n    interface System.Linq.IGrouping<'K, 'T> with\n        member this.Key = k\n\n[<Proxy(typeof<IOrderedEnumerable<_>>)>]\ntype internal IOrderedEnumerableProxy<'T> =\n    inherit seq<'T>\n    abstract CreateOrderedEnumerable<'K>\n        : keySelector: Func<'T, 'K>\n        * comparer: IComparer<'K>\n        * descending: bool\n        -> IOrderedEnumerable<'T>\n\n[<JavaScript>]\ntype internal FsComparer<'T when 'T : comparison>() =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            compare x y\n\n[<JavaScript>]\ntype internal ProjectionComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke x, projection.Invoke y)\n\n[<JavaScript>]\ntype internal CompoundComparer<'T>(primary: IComparer<'T>, secondary: IComparer<'T>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            match primary.Compare(x, y) with\n            | 0 -> secondary.Compare(x, y)\n            | n -> n\n\n[<JavaScript>]\ntype internal ReverseComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke y, projection.Invoke x)\n\n[<JavaScript>]\ntype internal OrderedEnumerable<'T>(source: seq<'T>, primary: IComparer<'T>) =\n    interface IOrderedEnumerable<'T> with\n        member this.CreateOrderedEnumerable(keySelector, secondary, descending) =\n            let secondary =\n                if descending then\n                    ReverseComparer(secondary, keySelector) :> IComparer<'T>\n                else\n                    ProjectionComparer(secondary, keySelector) :> IComparer<'T>\n            OrderedEnumerable<'T>(source, CompoundComparer(primary, secondary)) :> _\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let a = Array.ofSeq source\n            Array.sortInPlaceWith (fun x y -> primary.Compare(x, y)) a\n            (a :> seq<'T>).GetEnumerator()\n    interface IEnumerable with\n        member this.GetEnumerator() =\n            (this :> IEnumerable<'T>).GetEnumerator() :> _\n\n//[<Proxy(typeof<ILookup<_, _>>)>]\n//type internal ILookupProxy<'K, 'E> =\n//    inherit seq<IGrouping<'K, 'E>>\n//    inherit IEnumerable\n//    abstract Item : 'K -> 'E with get\n//    abstract Count : int with get\n//    abstract Contains : 'K -> bool\n//\n//[<JavaScript>]\n//type internal Lookup<'K, 'T, 'E>(source: seq<'T>, key: Func<'T, 'K>, elt: Func<'T, 'E>, comparer: IEqualityComparer<'K>) =\n//\n//    let dc = lazy (\n//        let d = Dictionary<'K, ResizeArray<'E>>(comparer)\n//        let count = ref 0\n//        source |> Seq.iter (fun e ->\n//            incr count\n//            let k = key.Invoke e\n//            let v = elt.Invoke e\n//            if d.ContainsKey k then\n//                d.[k].Add(v)\n//            else\n//                d.Add(k, ResizeArray([|v|]))\n//        )\n//        d, !count\n//    )\n//\n//    let s = lazy (\n//        fst dc.Value |> Seq.map (fun (KeyValue(k, v)) ->\n//            Grouping(k, v) :> IGrouping<_,_>)\n//    )\n//\n//    interface seq<IGrouping<'K, 'E>> with\n//        member this.GetEnumerator() = s.Value.GetEnumerator()\n//    interface IEnumerable with\n//        member this.GetEnumerator() = (s.Value :> IEnumerable).GetEnumerator()\n//    interface ILookup<'K, 'E> with\n//        member this.Item with get k = (fst dc.Value).[k] :> seq<_>\n//        member this.Count = snd dc.Value\n//        member this.Contains(k) = (fst dc.Value).ContainsKey(k)\n\ntype private LinqMacro() =\n    inherit Macro()\n\n    override this.TranslateCall(c) = //e, t, m, a, _) =\n        let targ = c.Method.Generics.[0]\n        WebSharper.Core.Macros.EqualityComparer.GetDefault(c.Compilation, targ)\n        |> MacroResult.Map (fun ec ->\n            let m' =\n                let t =\n                    AST.Type.ConcreteType {\n                        Generics = [targ]\n                        Entity =\n                            typedefof<IEqualityComparer<int>>\n                            |> AST.Reflection.ReadTypeDefinition\n                    }\n                let m = c.Method.Entity.Value\n                { m with Parameters = m.Parameters @ [t] }\n            let m = { c.Method with Entity = Hashed m' }\n            AST.Call(c.This, c.DefiningType, c.Method, c.Arguments @ [ec]))\n\n[<Name \"WebSharper.Linq\">]\n[<Proxy(typeof<System.Linq.Enumerable>)>]\n[<JavaScript>]\ntype private LinqProxy =\n\n    [<Inline>]\n    static member Aggregate<'T>(this: seq<'T>, func: Func<'T, 'T, 'T>) : 'T =\n        Seq.reduce (fun x y -> func.Invoke(x, y)) this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>) : 'U =\n        Seq.fold (fun x y -> func.Invoke(x, y)) seed this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U, 'R>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>, resultSelector: Func<'U, 'R>) : 'R =\n        resultSelector.Invoke(Seq.fold (fun x y -> func.Invoke(x, y)) seed this)\n\n    [<Inline>]\n    static member All<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.forall predicate.Invoke this\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>) : bool =\n        not (Seq.isEmpty this)\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.exists predicate.Invoke this\n\n    [<Inline>]\n    static member AsEnumerable<'T>(this: seq<'T>) : seq<'T> =\n        this\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    static member Average(this: seq<Nullable<float>>) : Nullable<float> =\n        let mutable x = [||]\n        use e = this.GetEnumerator()\n        while e.MoveNext() do\n            if e.Current.HasValue then\n                x.JS.Push e.Current.Value |> ignore\n        if x.Length = 0 then\n            Nullable()\n        else\n            Nullable(Seq.sum x / float x.Length)\n\n    [<Inline>]\n    static member Average(this: seq<float>) : float =\n        Seq.average this\n\n    [<Inline>]\n    static member Average(this: seq<int64>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average(this: seq<int>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int64>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        Seq.average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Cast<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast this\n\n    [<Inline>]\n    static member Concat<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        Seq.append this second\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T) : bool =\n        LinqProxy.Contains(this, value, EqualityComparer.Default)\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T, comparer: IEqualityComparer<'T>) : bool =\n        Seq.exists (fun x -> comparer.Equals(value, x)) this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>) : int =\n        Seq.length this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int =\n        Seq.length (Seq.filter predicate.Invoke this)\n\n    [<Inline>]\n    static member DefaultIfEmpty<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.DefaultIfEmpty(this, Unchecked.defaultof<'T>)\n\n    static member DefaultIfEmpty<'T>(this: seq<'T>, defaultValue: 'T) : seq<'T> =\n        if Seq.isEmpty this then\n            Seq.singleton defaultValue\n        else this\n\n    [<Inline>]\n    static member Distinct<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.Distinct(this, EqualityComparer.Default)\n\n    static member Distinct<'T>(this: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let tbl = HashSet(comparer)\n            while e.MoveNext() do\n                if tbl.Add(e.Current) then\n                    yield e.Current\n        }\n\n    [<Inline>]\n    static member ElementAt<'T>(this: seq<'T>, index: int): 'T =\n        Seq.item index this\n\n    [<Inline>]\n    static member ElementAtOrDefault<'T>(this: seq<'T>, index: int) =\n        LinqProxy.JSElementAtOrDefault(this, index, Unchecked.defaultof<'T>)\n\n    [<Name \"ElementAtOrDefault\">]\n    static member JSElementAtOrDefault<'T>(this: seq<'T>, index: int, defaultValue: 'T) : 'T =\n        try Seq.item index this\n        with _ -> defaultValue\n\n    [<Inline>]\n    static member Empty<'T>() : seq<'T> =\n        Seq.empty\n\n    [<Inline>]\n    static member Except<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Except(this, second, EqualityComparer.Default)\n\n    static member Except<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for x in second do tbl.Remove(x) |> ignore\n        tbl :> _\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>) : 'T =\n        Seq.head this\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        Seq.find predicate.Invoke this\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        if e.MoveNext() then e.Current else defaultValue\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault$1\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match Seq.tryFind predicate.Invoke this with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, resultSelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : seq<IGrouping<'K, 'E>> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'E>> =\n        Seq.delay (fun () ->\n            // Using an array instead of a seq is important here: the returned groupings\n            // use a ResizeArray that is filled here, so this enumeration must be finished\n            // before the user can enumerate any of the groupings.\n            [|\n                let t = Dictionary<'K, ResizeArray<'E>>(comparer)\n                for x in this do\n                    let k = keySelector.Invoke x\n                    let e = elementSelector.Invoke x\n                    match t.TryGetValue k with\n                    | true, a -> a.Add(e)\n                    | false, _ ->\n                        let a = ResizeArray<'E>()\n                        a.Add(e)\n                        t.[k] <- a\n                        yield Grouping(k, a) :> IGrouping<_,_>\n            |] :> _\n        )\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), resultSelector, comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, comparer)\n        |> Seq.map (fun g -> resultSelector.Invoke(g.Key, g))\n\n    [<Inline>]\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>) : seq<'R> =\n        LinqProxy.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            a |> Array.iteri (fun i (o, is) ->\n                a.[i] <- As (resultSelector.Invoke(o, is)))\n            As a\n        )\n\n    [<Inline>]\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Intersect(this, second, EqualityComparer.Default)\n\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let t1 = HashSet(this, comparer)\n        seq {\n            let t2 = HashSet(comparer)\n            for x in second do\n                if t1.Contains(x) && t2.Add(x) then\n                    yield x\n        }\n\n    [<Inline>]\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>) : IEnumerable<'R> =\n        LinqProxy.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>, comparer: IEqualityComparer<'K>) : IEnumerable<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            [|\n                for (o, is) in a do\n                    for i in is do\n                        yield resultSelector.Invoke(o, i)\n            |] :> _\n        )\n\n    [<Inline>]\n    static member Last<'T>(this: seq<'T>) : 'T =\n        Seq.last this\n\n    static member LastPred(this: seq<'T>, predicate: Func<'T, bool>) : option<'T> =\n        (None, this)\n        ||> Seq.fold (fun acc elt ->\n            if predicate.Invoke elt then Some elt else acc)\n\n    static member Last<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> invalidOp \"Sequence contains no matching element\"\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>) : 'T =\n        Enumerable.LastOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSLastOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"LastOrDefault\">]\n    static member JSLastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>) : int64 =\n        As(Enumerable.Count(this))\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int64 =\n        As(Enumerable.Count(this, predicate))\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<float>) : float =\n        Seq.max this\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<int64>) : int64 =\n        Seq.max this\n\n    static member Max(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.max s)\n\n    [<Inline>]\n    static member Max(this: seq<int>) : int =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<float>) : float =\n        Seq.min this\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<int64>) : int64 =\n        Seq.min this\n\n    static member Min(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.min s)\n\n    [<Inline>]\n    static member Min(this: seq<int>) : int =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member OfType<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast<'T> this\n\n    [<Inline>]\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderBy(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ProjectionComparer(comparer, keySelector)) :> _\n\n    [<Inline>]\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderByDescending(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ReverseComparer(comparer, keySelector)) :> _\n\n    static member Range(start: int, count: int) : seq<int> =\n        Seq.init count ((+) start)\n\n    static member Repeat<'T>(element: 'T, count: int) : seq<'T> =\n        Seq.init count (fun _ -> element)\n\n    static member Reverse<'T>(this: seq<'T>) : seq<'T> =\n        Array.rev (Array.ofSeq this) :> _\n\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, int, 'R>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this\n\n    [<Inline>]\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, 'R>) : seq<'R> =\n        Seq.map selector.Invoke this\n\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'R>>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this |> Seq.concat\n\n    [<Inline>]\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, seq<'R>>) : seq<'R> =\n        Seq.collect selector.Invoke this\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.map (fun t -> t, selector.Invoke t)\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.mapi (fun i t -> t, selector.Invoke(t, i))\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    [<Inline>]\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>) : bool =\n        LinqProxy.SequenceEqual(this, second, EqualityComparer.Default)\n\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : bool =\n        use e1 = this.GetEnumerator()\n        use e2 = this.GetEnumerator()\n        let rec go() =\n            if e1.MoveNext() then\n                e2.MoveNext() && comparer.Equals(e1.Current, e2.Current) && go()\n            else\n                not (e2.MoveNext())\n        go()\n\n    [<Inline>]\n    static member Single<'T>(this: seq<'T>) : 'T =\n        Seq.exactlyOne this\n\n    static member Single<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        let x =\n            (None, this)\n            ||> Seq.fold (fun state cur ->\n                if predicate.Invoke cur then\n                    if state.IsSome then\n                        invalidOp \"Sequence contains more than one matching element\"\n                    else Some cur\n                else state\n            )\n        match x with\n        | None -> invalidOp \"Sequence contains no elements\"\n        | Some x -> x\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.SingleOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSSingleOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"SingleOrDefault\">]\n    static member JSSingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        let mutable found = None\n        while e.MoveNext() do\n            if predicate.Invoke e.Current then\n                match found with\n                | None -> found <- Some e.Current\n                | Some _ -> invalidOp \"Sequence contains more than one element\"\n        match found with\n        | Some x -> x\n        | None -> defaultValue\n\n    static member Skip<'T>(this: seq<'T>, count: int) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do i <- i + 1\n            while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    i <- i + 1\n                else\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if not (predicate.Invoke e.Current) then\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    [<Inline>]\n    static member Sum(this: seq<int64>) : int64 =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<float>) : float =\n        Seq.sum this\n\n    static member Sum(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.sum s)\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<int>) : int =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    static member Take<'T>(this: seq<'T>, count: int) =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() && predicate.Invoke(e.Current, i) do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            while e.MoveNext() && predicate.Invoke(e.Current) do\n                yield e.Current\n        }\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, false)\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, false)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, true)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, true)\n\n    [<Inline>]\n    static member ToArray<'T>(this: seq<'T>) : 'T[] =\n        Seq.toArray this\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>) : Dictionary<'K, 'T> =\n        LinqProxy.ToDictionary(this, keySelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'T> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, x)) this\n        d\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : Dictionary<'K, 'E> =\n        LinqProxy.ToDictionary(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'E> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, elementSelector.Invoke x)) this\n        d\n\n    [<Inline>]\n    static member ToList<'T>(this: seq<'T>) : List<'T> =\n        List<'T>(this)\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), comparer) :> _\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, comparer) :> _\n\n    [<Inline>]\n    static member Union<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Union(this, second, EqualityComparer<'T>.Default)\n\n    static member Union<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for e in second do tbl.Add(e) |> ignore\n        tbl :> _\n\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    yield e.Current\n                i <- i + 1\n        }\n\n    [<Inline>]\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        Seq.filter predicate.Invoke this\n\n    [<Inline>]\n    static member Zip<'T, 'U, 'R>(this: seq<'T>, second: seq<'U>, resultSelector: Func<'T, 'U, 'R>) : seq<'R> =\n        Seq.map2 (fun x y -> resultSelector.Invoke(x, y)) this second\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\nopen FSharp.Quotations\n\nopen FSharp.Linq\n\n[<Proxy(typeof<QuerySource<_,_>>)>]\ntype internal QuerySourceProxy<'T, 'Q> [<Inline \"$source\">] (source: IEnumerable<'T>) =\n\n    [<Inline \"$this\">]\n    member this.Source = source\n                                \n[<Proxy(typeof<QueryBuilder>)>]\n[<Name \"WebSharper.Query\">]\ntype internal QueryBuilderProxy() =\n    [<Inline>]\n    member this.All(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.forall predicate source.Source\n\n    [<Inline>]\n    member inline this.AverageBy\n            (source: QuerySource<'T, 'Q>, projection: 'T -> ^Value) =\n        Seq.averageBy projection source.Source\n\n    [<Name \"averageByNullable\">]\n    static member inline AverageByNullableImpl \n            (source: QuerySource<'T, 'Q>, projection: 'T -> Nullable< ^TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        if filtered.Length = 0 then Nullable() else Nullable(Array.average filtered) \n\n    [<Inline>]\n    member inline this.AverageByNullable (source, projection) = QueryBuilderProxy.AverageByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Contains(source: QuerySource<'T, 'Q>, key: 'T) =\n        Seq.contains key source.Source\n\n    [<Inline>]\n    member this.Count(source: QuerySource<'T, 'Q>) =\n        Seq.length source.Source\n\n    [<Inline>]\n    member this.Distinct(source: QuerySource<'T, 'Q>) =\n        Seq.distinct source.Source |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ExactlyOne(source: QuerySource<'T, 'Q>) =\n        Seq.exactlyOne source.Source\n     \n    [<Inline>]\n    member this.ExactlyOneOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.SingleOrDefault()\n\n    [<Inline>]\n    member this.Exists(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.exists predicate source.Source\n     \n    [<Inline>]\n    member this.Find(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.find predicate source.Source\n\n    [<Inline>]\n    member this.For(source: QuerySource<'T, 'Q>, body: 'T -> QuerySource<'TResult, 'Q2>) =\n        Seq.collect (fun x -> (body x).Source) source.Source |> QuerySource<'TResult, 'Q>\n     \n    [<Inline>]\n    member this.GroupBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy(fun x -> keySelector x) |> QuerySource<IGrouping<'TKey, 'T>, 'Q>\n\n    [<Inline>]\n    member this.GroupJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.GroupValBy<'T, 'TKey, 'TValue, 'Q>(source: QuerySource<'T, 'Q>, resultSelector: 'T -> 'TValue, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy((fun x -> keySelector x), (fun x -> resultSelector x)) |> QuerySource<IGrouping<'TKey, 'TValue>, 'Q>\n\n    [<Inline>]\n    member this.Head(source: QuerySource<'T, 'Q>) =\n        Seq.head source.Source\n\n    [<Inline>]\n    member this.HeadOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.FirstOrDefault()\n    \n    [<Inline>]\n    member this.Join\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> 'TInner -> 'TResult\n      ) =\n        outerSource.Source.Join(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Last(source: QuerySource<'T, 'Q>) =\n        Seq.last source.Source\n \n    [<Inline>]\n    member this.LastOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.LastOrDefault()\n\n    [<Inline>]\n    member this.LeftOuterJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x (y.DefaultIfEmpty()))\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.MaxBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Max(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MaxByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Max(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.MinBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Min(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MinByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Min(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.Nth(source: QuerySource<'T, 'Q>, index: int) =\n        Seq.item index source.Source\n\n    [<Inline>]\n    member this.Quote(q: Expr<'T>) = q\n\n    [<Inline>]\n    member this.Run(q: Expr<QuerySource<'T, IQueryable>>) =\n        (As<QuerySource<'T, obj>> q).Source |> As<IQueryable<'T>>      \n           \n    [<Inline>]\n    member this.Select(source: QuerySource<'T, 'Q>, projection: 'T -> 'TResult) =\n        source.Source |> Seq.map projection |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Skip(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Skip(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SkipWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.SkipWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    [<Inline>]\n    member this.SortBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Source(source: seq<'T>) = \n        QuerySource<'T,  System.Collections.IEnumerable>(source)\n\n    [<Inline>]\n    member this.Source(source: IQueryable<'T>) = \n        QuerySource<'T, 'Q>(source)\n\n    [<Inline>]                                                              \n    member inline this.SumBy(source: QuerySource<'T, 'Q>, projection: 'T -> ^TValue) =\n        Seq.sumBy projection source.Source\n\n    [<Name \"sumByNullable\">]                                                              \n    static member inline SumByNullableImpl(source: QuerySource<'T, 'Q>, projection: 'T -> Nullable<'TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        Nullable(Array.sum filtered) \n\n    [<Inline>]\n    member inline this.SumByNullable(source, projection) = QueryBuilderProxy.SumByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Take(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Take(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.TakeWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.TakeWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    static member CheckThenBySource(source: IEnumerable<'T>) =\n        match source with\n        | :? IOrderedEnumerable<'T> as e ->\n            e\n        | _ ->\n            failwith \"'thenBy' and 'thenByDescending' may only be used with an ordered input\"\n\n    [<Inline>]\n    member this.ThenBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Where(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.Where(fun x -> predicate x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Yield(value: 'T) =\n        Seq.singleton value |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.YieldFrom(computation: QuerySource<'T, 'Q>) =\n        computation\n    \n    [<Inline>]\n    member this.Zero() =\n        Seq.empty |> QuerySource<'T, 'Q>\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Core.ExtraTopLevelOperators, FSharp.Core\">]\nmodule internal ExtraTopLevelOperatorsQueryProxy =\n    \n    [<Inline \"null\">]\n    let query = query\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority, FSharp.Core\">]\nmodule internal HighPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsEnumerable (this: QueryBuilder) (q: Expr<QuerySource<'T, IEnumerable>>) =\n        (As<QuerySource<'T, IEnumerable>> q).Source   \n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority, FSharp.Core\">]\nmodule internal LowPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsValue (this: QueryBuilder) (q: Expr<'T>) =\n        As<'T> q\n"],
"names": [],
"mappings": "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"
}
