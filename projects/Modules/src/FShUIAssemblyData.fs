#nowarn "3242"
////-d:FSharpStation1612100328464 -d:WEBSHARPER
//#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1"
//#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\Facades"
//#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461"
//#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461"
//#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Core.dll"
//#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.dll"
//#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Web.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.JavaScript.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Collections.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.InterfaceGenerator.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Main.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JQuery.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JavaScript.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Web.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Sitelets.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Control.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\HtmlAgilityPack.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Runtime.dll"
//#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Common.dll"
//#nowarn "3242"
/// Root namespace for all code
//#define FSharpStation1612100328464
#if !NOFSROOT
#if INTERACTIVE
module FsRoot   =
#else
#if DLL
namespace FsRootDll
#else
namespace FsRoot
#endif
#endif
#endif
    #if !NETSTANDARD20
    
    //#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1"
    //#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\Facades"
    ////#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\mscorlib.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Core.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Web.dll"
    
    #if WEBSHARPER
    #if WEBSHARPER47
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461"
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461"
    
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Core.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Core.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Collections.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.InterfaceGenerator.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Main.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.JQuery.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Web.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Sitelets.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper\lib\net461\WebSharper.Control.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461\HtmlAgilityPack.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461\WebSharper.UI.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461\WebSharper.UI.Templating.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Runtime.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp47\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Common.dll"
    #else
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461"
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461"
    
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Collections.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.InterfaceGenerator.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Main.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JQuery.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Web.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Sitelets.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Control.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\HtmlAgilityPack.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Runtime.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Common.dll"
    #endif
    #endif
    #endif
    #if WEBSHARPER
    //#nowarn "3242" 
    
    open WebSharper
    //open WebSharper.JavaScript
    open WebSharper.UI
    open WebSharper.UI.Client
    type on   = WebSharper.UI.Html.on
    type attr = WebSharper.UI.Html.attr
    #else
    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time
    module WebSharper =
        type RpcAttribute() =
            inherit System.Attribute()
            let a = 1
        type JavaScriptAttribute(translate:bool) =
            inherit System.Attribute()
            let a = 1
            new() = JavaScriptAttribute true
        type JavaScriptExportAttribute(translate:bool) =
            inherit System.Attribute()
            let a = 1
            new() = JavaScriptExportAttribute true
        type InlineAttribute(code:string) =
            inherit System.Attribute()
            let a = 1
            new() = InlineAttribute ""
        type DirectAttribute(code:string) =
            inherit System.Attribute()
            let a = 1
    
    open WebSharper
    
    #endif
    
        /// Essentials that cannot run in Javascript (WebSharper)
        [< AutoOpen >]
        module LibraryNoJS =
            [< AutoOpen >]
            module Regex =
                open System.Text.RegularExpressions
            
                let (|Regex|_|) pattern input =
                    if input = null then None else
                    try 
                        let m = Regex.Match(input, pattern)
                        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])
                        else None
                    with e -> None
            
                let (|Regexs|) pattern input =
                    if input = null then [| |] else
                    try 
                        let ms = Regex.Matches(input, pattern)
                        [| for m in ms do yield (List.tail [ for g in m.Groups -> g.Value ]) |] 
                    with e -> [| |]
            
                module p =
            
                    let lit(v:string) = 
                        v 
                        |> Seq.collect (
                            function
                            | '_'                                -> [       '_' ]
                            | c when System.Char.IsSymbol      c -> [ '\\' ; c  ]  
                            | c when System.Char.IsPunctuation c -> [ '\\' ; c  ] 
                            | c                                  -> [        c  ]
                        ) 
                        |> Seq.toArray 
                        |> fun ar ->  new System.String(ar)
                    let cr            = @"\r"
                    let nl            = @"\n"
                    let anychar       =  "."
                    let tab           = @"\t"
                    let blank         = @"\s"
                    let noblank       = @"\S"
                    let capt          = sprintf "(%s)"
                    let nocapt        = sprintf "(?:%s)"
                    let opt           = nocapt >> sprintf "%s?"
                    module g =
                        let inline anything mny        = mny anychar
                        let inline blanks   mny        = mny blank
                        let inline noblanks mny        = mny noblank
                        let inline spaceaft mny  x     = x + blanks mny
                        let inline listof1  mny0 x sep = x + mny0(sep + x)
            
                    module e =
                        let inline many0 a = nocapt a + "*"
                        let inline many1 a = nocapt a + "+"
            
                    module e1 =
                        let many                = e.many1
                        let anything            = g.anything  many
                        let blanks              = g.blanks    many
                        let noblanks            = g.noblanks  many
                        let spaceaft            = g.spaceaft  many
                        let inline listof x sep = g.listof1 e.many0 x sep
            
                    module e0 =
                        let many                = e.many0
                        let anything            = g.anything many
                        let blanks              = g.blanks   many
                        let noblanks            = g.noblanks many
                        let spaceaft            = g.spaceaft many
                        let inline listof x sep = e1.listof x sep |> opt
            
                    module l =
                        let many0 a   = e.many0 a + "?"
                        let many1 a   = e.many1 a + "?"
            
                    module l1 =
                        let many                = l.many1
                        let anything            = g.anything  many
                        let blanks              = g.blanks    many
                        let noblanks            = g.noblanks  many
                        let spaceaft            = g.spaceaft  many
                        let inline listof x sep = g.listof1 l.many0 x sep
            
                    module l0 =
                        let many                = l.many0
                        let anything            = g.anything many
                        let blanks              = g.blanks   many
                        let noblanks            = g.noblanks many
                        let spaceaft            = g.spaceaft many
                        let inline listof x sep = l1.listof x sep |> opt
            
                    let repl    n = Seq.replicate n >> String.concat ""
                    let either patterns = patterns |> String.concat "|" |> nocapt
                    let word      = sprintf "\\b%s\\b"
                    let oneof     = sprintf "[%s]"
                    let noneof    = sprintf "[^%s]"
                    let caseins   = sprintf "(?i)%s(?-i)"
            
                    let multiline  = either [ cr ; nl ; anychar ] |> l.many0
                    let letter     = oneof "_a-zA-Z"
                    let digit      = oneof "0-9"
                    let letters    = e.many1 letter
                    let digits     = e.many1 digit
                    let ident      = letter + (either [letter ; digit] |> l.many0) |> word
                    let dottedid   = e1.listof ident (e0.spaceaft "\.")
                    let typename   = dottedid + opt (@"<" + e1.listof dottedid (e0.spaceaft ",") + "\>")
                    /// match whole string
                    let full       = sprintf "^%s$"
            
                    let regmatch regex = function Regex regex ms -> Some ms |_-> None
            
                module r =
                    open p
            
                    let remove patterns = p.either patterns, ""
            
                    let tabs     = p.tab                , "    "
                    let comments = @"\/\/" + e1.anything, "\n"
            
                    let regexReplaceFunc f (regex:string) (input:string) =
                        System.Text.RegularExpressions
                            .Regex(regex)
                            .Replace(input, MatchEvaluator(fun m -> f m.Value))
            
                    let regexReplaceGroups f (regex:string) (input:string) =
                        System.Text.RegularExpressions
                            .Regex(regex)
                            .Replace(input, MatchEvaluator(fun m -> [ for g in m.Groups -> g.Value ] |> f))
            
                    let regexReplace (regex:string) (repl:string) (input:string) = 
                        System.Text.RegularExpressions
                            .Regex(regex)
                            .Replace(input, repl)
            
                    let replaceToF (regex, repl) = regexReplace regex repl
                    let replacesToFs rs = rs |> Seq.map replaceToF
                    /// a replace function for multiple replacements applied in sequence
                    let replace0 repls inp = repls |> Seq.fold (fun txt (regex, repl) -> regexReplace txt regex repl) inp
                    /// same as replace0: a function for multiple replacements
                    let replace1 v = replacesToFs v |> Seq.reduce (>>)
            
                    /// find a section (like: module XXX = ..) and capture its name, make replacements using that sections name
                    let byLine init st f (inp:string) =
                        inp.Split '\n'
                        |> Array.mapFold (fun md ln -> 
                            match st ln with
                            | Some nm -> ln     , nm
                            |_        -> f md ln, md
                        ) init
                        |> fst
                        |> String.concat "\n"
            
            
        /// Essentials that run in Javascript (WebSharper)
        //#define WEBSHARPER 
        [< JavaScript ; AutoOpen >]
        module LibraryJS =
            //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.dll"
            
            // Should be compiled using: WsCompile dll
            
            //#define WEBSHARPER
            [< JavaScriptExport >]
            module FShUI_AssemblyData =
            
                type ModuleName   = ModuleName   of string with member this.Id = match this with ModuleName   v -> v
                                                                member this.Id2= this.Id.Replace("+", ".")
                type TypeName     = TypeName     of string with member this.Id = match this with TypeName     v -> v
                type MethodName   = MethodName   of string with member this.Id = match this with MethodName   v -> v
                type AssemblyName = AssemblyName of string with member this.Id = match this with AssemblyName v -> v
                type AssemblyRef  = AssemblyRef  of string with member this.Id = match this with AssemblyRef  v -> v
                type JSCode       = JSCode       of string with member this.Id = match this with JSCode       v -> v
                type Resource     = Resource     of string with member this.Id = match this with Resource     v -> v
            
                type ModuleRef    = {
                    name          : ModuleName
                    asmName       : AssemblyName
                }
            
                type MethodRef    = {
                    name          : MethodName
                    modRef        : ModuleRef
                }
            
                type TypeRef      = {
                    name          : TypeName
                    asm           : AssemblyName
                }
            
                type MethodDef    = {
                    name          : MethodName
                    retType       : TypeRef
                    parms         : TypeRef[]
                    isField       : bool
                }
            
                type ModuleDef    = {
                    name          : ModuleName
                    methods       : MethodDef []
                } 
            
                type AssemblyDef  = {
                    name          : AssemblyName
                    self          : AssemblyRef
                    modules       : ModuleDef         []
                    dependencies  : AssemblyRef       []
                    resources     : Resource          []
                    javaScripts   : (string * JSCode) []
                }
            
            (*    module LoadAsm =
                    open FSharp.Data
            
                    type AsmJson = JsonProvider<"""
                        { "asName"            : "ss"
                        , "dependencies"      : ["ref1"]
                        , "resources"         : ["res"]
                        , "modules"           : 
                           [{ "moName"        : "mm"
                            , "methods"       : 
                               [{ "meName"    : "me"
                                , "isField"   : 1
                                , "type"      : 
                                    { "tName" : "tn"
                                    , "asm"   : "asm"
                                    }
                                , "parms" :
                                   [{ "tName" : "tn"
                                    , "asm"   : "asm"
                                   }]
                               }]
                           }]
                        , "jsModules" :
                                   [{ "jsName" : "jn"
                                    , "code"   : "code"
                                   }]
                        }""", RootName="asm">
                        *)
            
                [< JavaScript false >]
                module CreateAsm =
                    open WebSharper.Core
            
                    let getInfo fname =
                        use stream = new System.IO.FileStream(fname, System.IO.FileMode.Open)
                        Metadata.IO.Decode stream
            
                    module Desc = 
                        open WebSharper.Core.AST
                        open Metadata
            
                        let replcs = [
                            "`1"                                   , ""      
                            "`2"                                   , ""      
                            "`3"                                   , ""      
                            "`4"                                   , ""      
                        ]
            
                        let doReplaces (str:string) =
                            replcs
                            |> Seq.map (fun (a,b) -> fun (str:string) -> str.Replace(a,b))
                            |> Seq.reduce (>>)
                            <| str
            
                        let primitiveTypes t =
                            [   "System.String"                               , "string"
                                "System.Int32"                                , "int"
                                "System.Boolean"                              , "bool"
                                "Microsoft.FSharp.Collections.FSharpList`1"   , "List"
                                "Microsoft.FSharp.Collections.FSharpMap`2"    , "Map"
                                "Microsoft.FSharp.Collections.FSharpSet`1"    , "Set"
                                "Microsoft.FSharp.Control.FSharpAsync`1"      , "Async"
                                "Microsoft.FSharp.Core.FSharpOption`1"        , "Option"
                                "Microsoft.FSharp.Core.FSharpResult`2"        , "Result"
                                "Microsoft.FSharp.Core.Unit"                  , "unit"
                            ] 
                            |> Seq.tryPick(fun (p, r) -> if t = p then Some r else None)
            
                        let removeOpens opens (t:string) =
                            [|  "FSharp.Core"
                                "netstandard"
                                "System.Collections.Generic"
                                "System"
                                "WebSharper.UI"
                                "Microsoft.FSharp.Collections"
                                "Microsoft.FSharp.Control"
                                "Microsoft.FSharp.Core"
                            |] 
                            |> Seq.append opens
                            |> Seq.tryPick(fun o -> if t.StartsWith (o + ".") || t.StartsWith (o + "+") then Some (t.Substring(o.Length + 1)) else None)
                            |> Option.defaultValue t
            
                        let simplify opens t =
                            primitiveTypes t
                            |> Option.defaultWith (fun () -> 
                                removeOpens opens t
                                |> doReplaces
                            )
            
                        let rec getNameAsmMod opens ty =
                            let getTN = getTypeName opens
                            match ty with
                            | StaticTypeParameter i
                            | TypeParameter       i      -> sprintf "'%c" (System.Convert.ToChar(97 + i)), "", ""
                            | FSharpFuncType (a, r)      -> sprintf "(%s -> %s)" (getTN a) (getTN r), "FSharp.Core", ""
                            | ByRefType       t          -> getNameAsmMod opens t
                            | VoidType                   -> "unit", "FSharp.Core", ""
                            | LocalTypeParameter         -> "_", "", ""
                            | ArrayType (t, i)           -> let tn, ta, tm = getNameAsmMod opens t
                                                            String.replicate (i - 1) "," |> sprintf "%s[%s]" tn, ta, tm
                            | ConcreteType t             -> let e = t.Entity.Value
                                                            simplify opens e.FullName +
                                                                match t.Generics with
                                                                | [] -> ""
                                                                | gs -> gs |> Seq.map getTN |> String.concat ", " |> sprintf "<%s>"
                                                            , e.Assembly
                                                            , ""
                            | TupleType (ts, v)          -> if not v then ts |> Seq.map getTN |> String.concat " * " |> sprintf "(%s)", "netstandard", ""  else 
                                                            let name = "System.ValueTuple`"
                                                            let rec getName l (ts: List<Type>) =
                                                                if l <= 7 then
                                                                    name + (string l) + "[[" + String.concat "],[" (ts |> Seq.map getTN) + "]]"
                                                                else
                                                                    name + "8[[" + 
                                                                        String.concat "],[" (ts |> Seq.take 7 |> Seq.map getTN) + 
                                                                        getName (l - 7) (ts |> Seq.skip 7 |> List.ofSeq) + "]]"
                                                            getName (List.length ts) ts, "netstandard", ""
            
                        and getTypeName (opens: string seq) (this:Type) =
                            let a, b, c = getNameAsmMod opens this
                            a
            
            
                        let getTypeRef asm mdl (typ:Type) = {
                            name = getTypeName [ mdl ] typ |> TypeName
                            asm  = AssemblyName (
                                            try 
                                                typ.TypeDefinition.Value.Assembly
                                            with _ -> ""
                                        )
                        }
            
                        let descMethod asm mdl (key:MethodInfo) (mbr: CompiledMember, opt: Optimizations, exp: Expression) =
                            match mbr with 
                            | CompiledMember.Static _ ->  
                                let getType (p:Type) = getTypeRef asm mdl p
                                let isField = 
                                    match exp with
                                    | Function([], Return(Sequential [Application (GlobalAccess address1,[],NonPure, Some 0); GlobalAccess address2])) -> true
                                    | _ -> false
                                let parms =
                                    if isField then [||] else
                                    key.Parameters 
                                    |> Seq.map getType
                                    |> Seq.toArray
                                {
                                    name    = MethodName key.MethodName
                                    isField = isField
                                    retType = (getType key.ReturnType)
                                    parms   = parms
                                }
                                |> Some
                            |_-> None
            
                    open Desc
            
                    open WebSharper.Core.Resources
            
                    let getResource (assem:System.Reflection.Assembly) (tp:AST.TypeDefinition) =
                        let ctx =     {
                            DebuggingEnabled        = true
                            DefaultToHttp           = true
                            ScriptBaseUrl           = None
                            GetAssemblyRendering    = fun   s -> RenderInline s
                            GetSetting              = fun   s -> None
                            GetWebResourceRendering = fun t s -> RenderInline s
                            WebRoot                 = "/"
                            RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary<IResource, (RenderLocation -> HtmlTextWriter) -> unit>()
                            ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary<Metadata.Node Set, IResource list>()
                        }
                        let typ         = assem.GetType(tp.Value.FullName)
                        if  typ         = null then None else
                        use strW        = new System.IO.StringWriter() 
                        use htmlW       = new HtmlTextWriter(strW)
                        let ires        = System.Activator.CreateInstance(typ) |> unbox<IResource>
                        do                ires.Render ctx (fun loc -> htmlW)
                        let patScript   = p.lit "<script" + p.multiline + p.lit "</script>"
                        let patLink     = p.lit "<link"   + p.multiline + p.lit ">"
                        let pattern     = p.either [ patScript ;  patLink ] |> p.capt // |>! printfn "pattern = %A"
                        match strW.ToString() with
                        | Regexs pattern rs -> rs // |>! printfn "rs = %A"
                        |> Array.map (Seq.head >> (fun s -> s.Replace("\n", "").Replace("\r", "")) >> Resource)
                        |> Some
            
                    let asmFromMeta (assem:System.Reflection.Assembly) asm path (info:Core.Metadata.Info) jss =
                        let rsDp =  info.Dependencies.Nodes
                                    |> Seq.choose (function 
                                        | Metadata.AssemblyNode(nm, true) when nm <> asm-> AssemblyRef <| nm + ".asm" |> Choice1Of2 |> Some
                                        | Metadata.ResourceNode(tp, _) -> getResource assem tp |> Option.map Choice2Of2
                                        | _ -> None)
                                    |> Seq.cache
                        let deps  = rsDp |> Seq.choose (function Choice1Of2 dep -> Some dep |_-> None) |> Seq.toArray
                        let ress  = rsDp |> Seq.choose (function Choice2Of2 r   -> Some r   |_-> None) |> Seq.toArray
                        let modules =
                            info.Classes
                            |> Seq.map(fun kvp ->
                                let mdl = kvp.Key.Value.FullName
                                {
                                    name    = ModuleName mdl
                                    methods = kvp.Value.Methods |> Seq.choose(fun mtd -> descMethod asm mdl mtd.Key.Value mtd.Value) |> Seq.toArray
                                } 
                            ) 
                            |> Seq.toArray
                        {
                            name          = AssemblyName         asm
                            self          = AssemblyRef  (path + asm + ".asm")
                            modules       = modules
                            dependencies  = deps
                            resources     = ress |> Array.collect id
                            javaScripts   = jss
                        }
            
                    open System
                    open System.Reflection
            
                    type ReferenceLoader() =
            
                        let LoadReflected(a: System.Reflection.Assembly) =
                            if a.FullName.StartsWith "System" then None else
                                let n = "WebSharper.meta"
                                if Array.exists ((=) n) (a.GetManifestResourceNames()) then
                                    try
                                        use s = a.GetManifestResourceStream n
                                        Metadata.IO.MetadataEncoding.Decode(s) :?> Metadata.Info 
                                        |> Some
                                    with e ->
                                        use s = a.GetManifestResourceStream n
                                        Metadata.IO.MetadataEncoding.Decode(s, "4.7") :?> Metadata.Info 
                                        |> Some
            //                            failwithf "Failed to load metadata for: %s. Error: %s" a.FullName e.Message
                                else
                                    None
                        //inherit System.MarshalByRefObject()
                        member this.MetaFromAsm(asmRef:string) =
                            let asmR  = System.IO.File.ReadAllBytes asmRef |> System.Reflection.Assembly.Load //ReflectionOnlyLoad
                            let jss   = asmR.GetManifestResourceNames() 
                                        |> Seq.choose(fun nm ->
                                            printfn "%s" nm
                                            if nm.EndsWith ".js" |> not || nm.EndsWith ".min.js" then None else
                                            use str = asmR.GetManifestResourceStream nm
                                            use rdr = new System.IO.StreamReader(str)
                                            (nm, JSCode <| rdr.ReadToEnd())
                                            |> Some
                                        ) |> Seq.toArray
                            let asm   = System.IO.Path.GetFileNameWithoutExtension asmRef
                            let path  = System.IO.Path.GetDirectoryName asmRef
                            let info  = LoadReflected asmR |> Option.defaultWith(fun () -> failwithf "Assembly not compiled with WebSharper: %s" asmRef)
                            asmFromMeta asmR asm path info jss
            
                    let readDll asmRef  =
                        //let settings    = AppDomainSetup(ApplicationBase = AppDomain.CurrentDomain.BaseDirectory)
                        //let childDomain = AppDomain.CreateDomain(Guid.NewGuid().ToString(), null, settings);
                        //let handle      = Activator.CreateInstanceFrom(childDomain
                        //                    , typedefof<ReferenceLoader>.Assembly.Location
                        //                    , typedefof<ReferenceLoader>.FullName
                        //                    , false, (BindingFlags.NonPublic + BindingFlags.Public + BindingFlags.Instance)
                        //                    , null, null
                        //                    , Globalization.CultureInfo.CurrentCulture
                        //                    , [||])
                        let loader      = //handle.Unwrap() :?> ReferenceLoader
                            ReferenceLoader()
                        let res         = loader.MetaFromAsm asmRef
                        //AppDomain.Unload childDomain
                        res
            (*
            
            FsRoot.LibraryJS.FShUI_AssemblyData.CreateAsm.readDll @"D:\Abe\CIPHERWorkspace\FSharpStation\projects/FSharpStation/bin/FSharpStation.exe"
            FsRoot.LibraryJS.FShUI_AssemblyData.CreateAsm.readDll @"D:\Abe\CIPHERWorkspace\FSharpStation\projects/LayoutEngine/bin/MonacoPlugIn.dll"
            
            FsRoot.LibraryJS.FShUI_AssemblyData.CreateAsm.readDll @"D:\Abe\CIPHERWorkspace\FSharpStation\projects/LayoutEngine/bin/LayoutEngine.dll"
            
            open FsRoot.LibraryNoJS
            open System.Text.RegularExpressions
            Regex.Matches("""<script src="/EPFileX/monaco/package/min/vs/loader.js" type="text/javascript" charset="UTF-8">
            </script>""", "(?:\<script(?:(?:\r|\n|.))*?\<\/script\>|\<link(?:(?:\r|\n|.))*?\>)")
            |> printfn "%A"
            
            // *)