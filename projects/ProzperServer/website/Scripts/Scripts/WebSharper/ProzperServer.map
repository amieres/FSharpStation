{
"version": 3,
"sourceRoot": "Source",
"sources": ["ProzperServer/ProzperServer.fs"],
"sourcesContent": ["#nowarn \"3242\"\n#nowarn \"52\"\n#nowarn \"1182\"\n#nowarn \"1178\"\n////-d:FSharpStation1559368300303 -d:NOFRAMEWORK --noframework -d:WEBSHARPER\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n//#nowarn \"3242\"\n//#nowarn \"52\"\n//#nowarn \"1182\"\n//#nowarn \"1178\"\n/// Root namespace for all code\n//#define FSharpStation1559368300303\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#nowarn \"3242\" \n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    //#define NOFRAMEWORK --noframework\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"  \n    \n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n    \n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library = \n            let Error = Result.Error\n        \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            (* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\n            module IDict =\n            #if WEBSHARPER\n                [< Inline >]\n            #endif\n                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            *)\n            module Dict =\n                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            \n            module LDict =\n                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n                let [<Inline>] inline tryGetValue fitem key  dict =\n                    if containsKey key dict then Some (fitem key)\n                    else None\n            \n            \n            module Memoize =\n            \n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )\n                    (checkO, getOrAdd), cache.Clear\n            \n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )\n            \n                /// Memoizes function f using the provided cache\n                /// getCache() returns 1 function:\n                ///    getOrAdd: ('p->('p->'v)->'v) \n                [< Inline >]\n                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =\n                    fun p -> getOrAdd p f\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let (check, getOrAdd), clear = getStore()\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, clear\n            \n                /// Memoizes the function f using the provided Dictionary\n                [<Inline>]\n                let memoizeWithDict dict f =\n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF\n            \n                /// Memoizes the function f and returns Dictionary\n                [<Inline>]\n                let memoizeDict f =\n                    let dict = System.Collections.Generic.Dictionary<_, _>() \n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, dict\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    let ofOption vO = \n                        match vO with\n                        | Some v -> Seq.singleton v\n                        | None   -> Seq.empty\n                \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let errorf fmt = Printf.ksprintf Error fmt\n                \n                    let rtn                          = Ok\n                    let join                       r = Result.bind id r\n                    let flatten                    r = Result.bind id r\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bind (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bind f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                /// Based on Nick Palladino's https://github.com/palladin/Eff\n                \n                [< AutoOpen >]\n                module Eff =\n                    type Effect  = abstract Extend : (Effect -> Effect) -> Effect\n                \n                    type Eff<'H, 'a> = Eff of (('a -> Effect) -> Effect) \n                        with  member this.Create = match this with Eff create -> create\n                \n                    let inline rtn  v : Eff<'H, 'a> = Eff (fun k -> k v)\n                    let bind  (f: 'a -> Eff<'H, 'b>) (effA: Eff<'H, 'a>) : Eff<'H, 'b> = \n                                        Eff (fun kb -> \n                                                let (Eff effKa) = effA\n                                                effKa (fun a -> \n                                                    let (Eff effKb) = f a\n                                                    effKb kb\n                                                )\n                                            )\n                    let inline map   f  m  = bind (f >> rtn) m\n                    let inline apply fR vR = fR |> bind (fun f -> map f vR)\n                \n                    type Done<'a>(v : 'a) =\n                        member self.Value = v\n                        interface Effect with member self.Extend(_) : Effect = self :> _\n                \n                    let done'  (v : 'a) : Effect = new Done<'a>(v) :> _ \n                    //let return'(v : 'a) : Eff<'H, 'c> = Eff( fun _ -> done' v )\n                    let return' v = Eff( fun _ -> done' v )\n                \n                    let run<'H, 'a> (eff: Eff<'H, 'a>) : 'a =\n                        match eff.Create done' with\n                        | :? Done<'a> as done' -> done'.Value\n                        | v                    -> failwithf \"Unhandled effect %A\" v\n                \n                    let inline runResult<'H, 'a> eff = \n                        try run<'H, 'a> eff |> Ok\n                        with e -> Error(e.ToString())\n                \n                \n                    let inline (<*>) f v   = apply f v\n                    let inline (|>>) v f   = map   f v\n                    let inline (>>=) v f   = bind  f v\n                    let inline (>->) f g v = f v |>> g\n                    let inline (>=>) f g v = f v >>= g\n                    \n                    let inline join m = m |> bind id\n                    \n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |>> Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)\n                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)\n                    \n                    let inline bindO (f:'a->Eff<'H,'b>) (ef:Eff<'H,'a option>) = bind (Option.map f >> insertO) ef\n                    let rec whileLoop cond fEf =\n                        if   cond () \n                        then fEf  () |> bind (fun () -> whileLoop cond fEf)\n                        else rtn  ()\n                    \n                    \n                    type EffBuilder<'H>() =\n                        member __.ReturnFrom            vEf        : Eff<'H, _   > =           vEf\n                        member __.Return                v          : Eff<'H, _   > = rtn       v  \n                        member __.Zero                  ()         : Eff<'H, unit> = rtn       () \n                        member __.Bind                 (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Combine              (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Delay                       fEf                  = fEf\n                        member __.Run                         fEf  : Eff<'H, _   > = rtn () |> bind fEf\n                        member this.TryWith   (body, handler     ) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                        member this.TryFinally(body, compensation) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                        member this.Using     (disposable, body  ) : Eff<'H,_> = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                    let body' = fun () -> body disposable\n                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                        member __.While   (guard , fEf) : Eff<'H, unit> = whileLoop guard fEf \n                        member th.For  (s: 'a seq, fEf) : Eff<'H, unit> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fEf enum.Current)))\n                    \n                    let eff<'H> = EffBuilder<'H>()\n                    \n                    //type EffBuilder<'H>() =\n                    //    member self.Zero      (                 ) = rtn ()\n                    //    member self.Return    (v   :         'A ) = rtn v\n                    //    member self.ReturnFrom eff                = eff\n                    //    member self.Bind      (eff, f           ) = bind f eff\n                    //    member self.Combine   (first, second    ) = bind (fun () -> second) first\n                    //    member __.Combine   (vEf,  fEf) : Eff<'H  , 'm> = bind fEf  vEf\n                    //    member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)\n                    ////    member inline __.Delay       f                  = f\n                    //    member __.While(guard, body) =\n                    //        let rec whileLoop guard body =\n                    //            if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    //            else rtn   ()\n                    //        whileLoop guard body\n                    //    member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                    //    member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                    //    member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                    //                let body' = fun () -> body disposable\n                    //                this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                    //    member this.For(sequence:seq<_>, body) =\n                    //        this.Using(sequence.GetEnumerator(),fun enum -> \n                    //            this.While(enum.MoveNext, \n                    //                fun () -> this.Delay(fun () -> body enum.Current)))\n                    //\n                    //\n                    //let eff<'H> = new EffBuilder<'H>()\n                    \n                    //type EA<'H, 'a, 'b> = 'a -> Eff<'H, 'b>\n                    /// Equal to (|>) \n                    //let (>|>) (ea:EA<_,_,_>) f : EA<_,_,_> = ea |> f\n                    /// Equal to (>>)\n                    //let (>>>) = (>>)\n                    \n                    module EA =\n                        let tee (f: 'a -> Eff<'H, unit>) : 'a -> Eff<'H, 'a> = (fun v -> f v |> map (fun () -> v) )\n                    \n                    //    let mapOutput  f (ea: EA<_,_, _>) : EA<_,_,          _   > = ea >> (bind (f >> rtn) )\n                    //    let bindOutput(f: EA<_,_, _>) (ea: EA<_,_, _>) : EA<_,_, _> = ea >> (bind  f  )\n                    //    let mapBoth    f (ea: EA<_,_, _>) : EA<_,_,          _   > = fun i -> i |> mapOutput (f i) ea\n                    //    let bindBoth   f (ea: EA<_,_, _>) : EA<_,_,          _   > = mapBoth f  ea |> bindOutput id\n                    //\n                    //    let mapO         (ea: EA<_,_, _>) : EA<_,_,          _   > = Option.map ea >> insertO\n                    //\n                    //    let mapFst     f (a, b) = (f a,   b)\n                    //    let mapSnd     f (a, b) = (  a, f b)\n                    //\n                    //    let bindFst    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fa = f a\n                    //        return (fa, b)\n                    //    }\n                    //\n                    //    let bindSnd    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fb = f b\n                    //        return (a, fb)\n                    //    }\n                    //\n                    //    let lift    f : EA<_,_,_> = f >> rtn\n                    //    let pairWith v ea : EA<_,_,_> =\n                    //        ea\n                    //        >-> fun fst -> fst, v\n                    //\n                    //    let getResult ea:EA<_,_,_> = ea >-> Ok\n                    \n                    \n                    module Reader =\n                        type Reader<'E> = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type Ask<'E>(k : 'E -> Effect) =\n                            member self.K = k\n                            interface Effect with\n                                member self.Extend extension : Effect = new Ask<'E>(k >> extension) :> _\n                    \n                        let ask() : Eff<'H, 'E> when 'H :> Reader<'E> = Eff (fun k -> Ask(k) :> _ )\n                    \n                        let readerHandler<'E, 'H, 'a when 'H :> Reader<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = \n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? Ask<'E>  as ask   -> ask.K env          |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        let readerFun f = ask() |> map f \n                    module Log = \n                        type Log< 'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log1<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log2<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                    \n                        type LogEntry<'L>(v : 'L, k : unit -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect with\n                                member self.Extend extension  : Effect = new LogEntry<'L>(v, k >> extension) :> _\n                    \n                        let log (s:'L)  : Eff<'H, unit> when 'H :> #Log< 'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let logf fmt = Printf.ksprintf log fmt\n                        let log1 (s:'L) : Eff<'H, unit> when 'H :> #Log1<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let log2 (s:'L) : Eff<'H, unit> when 'H :> #Log2<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                    \n                        let pureLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = \n                            let rec loop (exitK:('a * list<'L>) -> Effect) (ls: list<'L>) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> (done'.Value, ls)  |>       exitK\n                                | :? LogEntry<'L> as log   -> log.K ()           |>  loop exitK (log.Value :: ls)  \n                                | effect                   -> effect.Extend         (loop exitK ls               )\n                            Eff (fun exitK                 -> eff.Create done'   |>  loop exitK []               )\n                    \n                    \n                        let consoleLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let loggerLogHandler<'L, 'H, 'a when 'H :> Log<'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> logger log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let consoleLogHandler1<'L, 'H, 'a when 'H :> Log1<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log1: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                    module Rsl = \n                    \n                    \n                        type Rsl<'M> = interface end\n                        \n                        type IRsl<'M> = abstract Value : 'M\n                    \n                        type Fail<'a,'M>(v : 'M, k : 'a -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect   with member __.Extend extension : Effect = new Fail<'a,'M>(v, k >> extension) :> _\n                            interface IRsl<'M> with member __.Value = v\n                    \n                        let fail (s:'M) : Eff<'H, _> when 'H :> #Rsl<'M> = Eff (fun k -> new Fail<_,_>(s, k) :> _)\n                        let failf fmt = Printf.ksprintf fail fmt\n                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {\n                            match res with\n                            | Ok    v   ->  return v\n                            | Error msg ->  let! m = fail msg\n                                            return failwith \"this code should be unreachable\"\n                        }\n                        \n                        let rslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = \n                            let rec loop (exitK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function\n                                | :? Done<    'A> as done' -> Ok    done'.Value |>       exitK\n                                | :? IRsl<    'M> as fail  -> Error fail .Value |>       exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'  |>  loop exitK)\n                    \n                        let inline getResult   v                = map Ok v\n                        let inline absorbR     vvEf             = vvEf  |> bind ofResult\n                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Asy = \n                        type Asy = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type AsynG =\n                            abstract RunSync      : unit               -> Effect\n                            abstract RunAsync<'a> : (Effect -> Effect) -> Effect\n                    \n                        [< Inline \"console.log('RunSynch Not implemented in JavaSacript')\" >]\n                        let runSynch v = Async.RunSynchronously v\n                    \n                        type Asyn<'v>(v : Async<'v>, k : ('v -> Effect) ) =\n                            member __.Value = v\n                            member __.K     = k\n                            interface Effect with member __.Extend   extension = new Asyn<_>(v, k >> extension) :> _\n                            interface AsynG  with \n                                member __.RunSync  ()        = runSynch v |> k\n                                member __.RunAsync<'a> exitK = done' (v |> Async.bind (fun v -> k v |> exitK :?> Done<Async<'a>> |> fun don -> don.Value ) )\n                    \n                        let inline ofAsync (v:Async<'a>) : Eff<'H, 'a> when 'H :> Asy= Eff (fun k -> new Asyn<'a>(v, k) :> _)\n                    \n                        /// This handler uses RunSynchronously to resolve Asyncs\n                        let syncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK:'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? AsynG    as asy   -> asy.RunSync()      |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        /// this should be the last handler before Eff.run\n                        let asyncHandler0<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            let rec loop (exitK:(Async<'a>) -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value |> async.Return |>      exitK\n                                | :? AsynG    as asy   -> asy.RunAsync<'a>              (loop exitK)\n                                | effect               -> effect.Extend                 (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'            |> loop exitK)\n                    \n                        let asyncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            Async.rtn () \n                            |>  ofAsync \n                            >>= fun () -> eff \n                            |>  asyncHandler0\n                    \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = if n < 0 \n                                                  then this.Substring2(0, this.Length + n)\n                                                  else this.Substring2(0, n              )\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n                member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n            \n            let mapFst     (f: 'a->'c) (a:'a, b:'b) = (f a,   b)\n            let mapSnd     (f: 'b->'c) (a:'a, b:'b) = (  a, f b)\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n            \n            \n                /// Javascript adds time zone information when parsing a date and that can change the result\n                let parseDateO2  = (fun s -> s + \"T00:00:00\") >> tryParseWith System.DateTime.TryParse\n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseInt64O  = tryParseWith System.Int64   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Int64 |_|) = parseInt64O\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            module Serializer =\n                open System\n            \n                type JsonIntermediate = {\n                    tryFloat    : unit   ->  float                option\n                    tryInt      : unit   ->  int64                option\n                    tryString   : unit   ->  string               option\n                    tryBool     : unit   ->  bool                 option\n                    tryArray    : unit   -> (JsonIntermediate []) option\n                    tryField    : string ->  JsonIntermediate     option\n                    isObject    : unit   ->  bool\n                    isNull      : unit   ->  bool\n                }\n            \n                type SerS<'T> = ('T                 -> string   )        //      Serialization function\n                type SerD<'T> = (JsonIntermediate   -> 'T option)        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>                      // both Serialization functions\n            \n                let serialize (ser: Ser<_>) v = fst ser v\n                let (|Field|_|) field j = j.tryField field\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n            \n                let toJsonString (v:string) =\n                    seq {\n                        yield '\"'\n                        if String.IsNullOrEmpty v |> not then\n                            for i = 0 to v.Length - 1 do\n                                let c = v.[i]\n                                let ci = int c\n                                if ci >= 0 && ci <= 7 || ci = 11 || ci >= 14 && ci <= 31 then\n                                    yield! sprintf \"\\\\u%04x\" ci\n                                else \n                                match c with\n                                | '\\b' -> yield! \"\\\\b\"\n                                | '\\t' -> yield! \"\\\\t\"\n                                | '\\n' -> yield! \"\\\\n\"\n                                | '\\f' -> yield! \"\\\\f\"\n                                | '\\r' -> yield! \"\\\\r\"\n                                | '\"'  -> yield! \"\\\\\\\"\"\n                                | '\\\\' -> yield! \"\\\\\\\\\"\n                                | _    -> yield c\n                        yield '\"'\n                    } |> Seq.toArray|> String\n            \n                let serString : Ser<string> = toJsonString , (fun j -> j.tryString() )\n                let serFloat  : Ser<float > = sprintU      , (fun j -> j.tryFloat () )\n                let serInt    : Ser<int   > = sprintU      , (fun j -> j.tryInt   () |> Option.map int)\n                let serInt64  : Ser<int64 > = sprintf \"%d\" , (fun j -> j.tryInt   () )\n                let serBool   : Ser<bool  > = sprintU      , (fun j -> j.tryBool  () )\n            \n                let [< Inline >] inline serId  (get: 'a -> System.Guid) (set:System.Guid -> 'a) (print: 'a->string) : Ser<'a> =\n                    let s               = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ              = sprintf \"%A\" s\n                    let serialize   gid = get gid |> string |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize j   = j.tryField s \n                                          |> Option.bind (fun jf -> jf.tryString() ) \n                                          |> Option.bind ParseO.parseGuidO \n                                          |> Option.map  set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc j -> deser j |> Option.map (fun v -> set v rc) ) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n                    if isNull (init :> obj) then failwith \"Initial record is null\"\n                    let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize j   = fields |> Seq.fold (fun dim (n, _ser,  deser) -> j.tryField n |> Option.bind (deser dim) |> Option.defaultValue dim)   init |> Some\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.ofArray)\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser))                          )\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\"              ), (fun j -> (if j.isNull() then None else              snd ser j)|> Some                  )\n                let serDup(serFst,serSnd): Ser<'a * 'b    > = (fun (f,s  ) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s) ), (fun j -> j.tryArray () \n                                                                                                                                            |> function \n                                                                                                                                                | Some [| j1 ; j2 |] -> match snd serFst j1, snd serSnd j2 with\n                                                                                                                                                                        | Some f, Some s -> Some(f, s) |_->None\n                                                                                                                                                | _ -> None )\n                let serTrp(sF,sS,sT)      : Ser<'a *'b*'c > = (fun (f,s,t) -> sprintf \"[%s, %s, %s]\" (fst sF f) (fst sS s)  (fst sT t)) , (fun j -> j.tryArray () \n                                                                                                                                                    |> function \n                                                                                                                                                        | Some [| j1 ;j2; j3|]   -> match snd sF j1, snd sS j2, snd sT j3 with\n                                                                                                                                                                                    | Some f, Some s, Some t -> Some(f, s, t) |_-> None\n                                                                                                                                                        | _ -> None ) \n                let serMap serKey serElm : Ser<Map<'k, 'e>> =   serDup(serKey, serElm)\n                                                                |> serSeq \n                                                                |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Option.map Map) )\n            \n            \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            let rec getNamespace (t:System.Type) =\n                match t.DeclaringType with\n                | null -> match t.Namespace with null -> \"\" | ns -> ns + \".\"\n                | dt   -> getNamespace dt + dt.Name + \".\"\n            \n            let rec getTypeName (t:System.Type) =\n                if t.IsArray then getTypeName (t.GetElementType()) + \"[]\" else\n                let ns    = getNamespace t\n                let name  = if   t.Name = \"FSharpOption`1\"                then \"Option\"\n                            elif t.Name = \"FSharpList`1\"                  then \"List\"\n                            elif ns     = \"Microsoft.FSharp.Core.\"\n                              || ns     = \"Microsoft.FSharp.Collections.\" then t.Name   \n                            else  ns + t.Name\n                let name2 = name.Split('`').[0]\n                let parms = t.GenericTypeArguments |> Seq.map getTypeName |> String.concat \",\"\n                if parms = \"\" then name2 else sprintf \"%s<%s>\" name2 parms\n            \n            module DiscUnion =\n                open FSharp.Reflection\n            \n                let simple<'U> =\n                    FSharpType.GetUnionCases typeof<'U>\n                    |> Seq.filter (fun c -> c.GetFields() |> Seq.isEmpty )\n                    |> Seq.map (fun c -> c.Name)\n                    |> Seq.toArray\n            \n                let caseTuple (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType)\n                    if types.Length = 1 then c.Name, types.[0], vs.[0] else\n                    let ttype = FSharpType.MakeTupleType(types)\n                    c.Name, ttype, FSharpValue.MakeTuple(vs, ttype)\n            \n                let caseArray (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType.FullName)\n                    c.Name, Array.zip types vs\n            \n                let caseInfos<'T>            = FSharpType.GetUnionCases typeof<'T>\n                let caseInfo< 'T> (s:string) = caseInfos<'T> |> Seq.find (fun c -> c.Name = s)\n            \n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n            module Serializer =\n                open Serializer\n                open FSharp.Data\n            \n                let rec getJsonIntermediate df di ds db da (j:JsonValue) : JsonIntermediate =\n                    let jsonInt = getJsonIntermediate df di ds db da\n                    {\n                        tryFloat    = fun () -> (match j with JsonValue.Float   v ->       v |> Some | JsonValue.Number v -> float v |> Some    |_-> None) |> Option.orElseWith df\n                        tryInt      = fun () -> (match j with JsonValue.Float   v -> int64 v |> Some | JsonValue.Number v -> int64 v |> Some    |_-> None) |> Option.orElseWith di\n                        tryString   = fun () -> (match j with JsonValue.String  v ->       v |> Some                                            |_-> None) |> Option.orElseWith ds\n                        tryBool     = fun () -> (match j with JsonValue.Boolean v ->       v |> Some                                            |_-> None) |> Option.orElseWith db\n                        tryArray    = fun () -> (match j with JsonValue.Array   v ->       v |> Array.map jsonInt |> Some                       |_-> None) |> Option.orElseWith (fun () -> da  jsonInt   )\n                        tryField    = fun fl -> j.TryGetProperty fl |> Option.map jsonInt                                                                 \n                        isObject    = fun () -> (match j with JsonValue.Record  _ ->       true |_-> false)\n                        isNull      = fun () -> (match j with JsonValue.Null      ->       true |_-> false)\n                    }\n            \n            \n                let deserialize df di ds db da (ser: Serializer.Ser<_>) js = \n                    JsonValue.TryParse js //|>! print\n                    |> Option.map  (getJsonIntermediate df di ds db da)\n                    |> Option.bind (snd ser)\n            \n                let tryDeserialize ser = \n                    deserialize\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        ser\n            \n                let deserializeWithDefs ser = \n                    deserialize\n                        (fun _   -> Some 0.0                          )\n                        (fun _   -> Some 0L                           )\n                        (fun _   -> Some \"\"                           )\n                        (fun _   -> Some false                        )\n                        (fun _   -> Some [||]                         )\n                        ser\n            \n                let deserializeWithFail ser = \n                    deserialize\n                        (fun _   -> failwith  \"Error expecting float\"    )\n                        (fun _   -> failwith  \"Error expecting int\"      )\n                        (fun _   -> failwith  \"Error expecting string\"   )\n                        (fun _   -> failwith  \"Error expecting bool\"     )\n                        (fun _   -> failwith  \"Error expecting array\"    )\n                        ser\n            \n                open FSharp.Reflection\n            \n                let inline serObj ((ser, deser):Ser<'T>) : string * Ser<obj> = typeof<'T> |> getTypeName, (unbox >> ser, deser >> Option.map box)\n            \n                let serDU<'DU when 'DU : equality> (sers : (string * Ser<obj>) seq) =\n                    let cases  = FSharpType.GetUnionCases             typeof<'DU>\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType  |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (typeof<'DU> |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = box<'DU> >> FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case >> unbox<'DU>\n                                let serC (v:'DU) =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = box<'DU> >> FSharpValue.PreComputeUnionTagReader typeof<'DU> >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.tryPick(fun case -> match j with Field case.Name _ -> Some case |_-> None) |> Option.defaultWith (fun () -> failwithf \"Could not find DU element %A\" j)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n            \n                let serDUt (sers : (string * Ser<obj>) seq) (ttype:System.Type) =\n                    let cases  = FSharpType.GetUnionCases ttype\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (ttype |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case\n                                let serC v =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = FSharpValue.PreComputeUnionTagReader ttype >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.pick(fun case -> match j with Field case.Name _ -> Some case |_-> None)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n                    \n            module Default =\n                open FSharp.Reflection\n            \n                let defaults vs = vs |> Seq.map (fun v -> v.GetType().FullName, v ) |> dict\n            \n                let defs = \n                    defaults [\n                        box 0\n                        box 0L\n                        box 0.\n                        box 0.F\n                        box \"\"\n                        box false\n                        box System.Guid.Empty\n                        box System.DateTime.MinValue\n                    ]\n            \n                let rec defaultValue defs (t:System.Type) : obj =\n                    match (defs:System.Collections.Generic.IDictionary<string, obj>).TryGetValue t.FullName with\n                    | true , v -> v\n                    | false, _ ->\n                    if t.IsArray then \n                        System.Array.CreateInstance(t.GetElementType(), 0) |> box\n                    elif t.IsEnum then\n                        (System.Enum.GetValues t).GetValue [| 0 |] |> box\n                    else\n                    let c = t.GetConstructor System.Type.EmptyTypes\n                    if  isNull c |> not then\n                        c.Invoke [||]\n                    elif FSharpType.IsRecord t then\n                        FSharpType.GetRecordFields t\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeRecord(t, os)\n                    elif FSharpType.IsTuple t then\n                        FSharpType.GetTupleElements t\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeTuple(os, t)\n                    elif FSharpType.IsUnion t then\n                        let case = FSharpType.GetUnionCases t |> Seq.head\n                        case.GetFields()\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeUnion(case, os)\n                    else failwithf \"Could no create default for %s\" t.FullName\n            \n                and createArray defs (ts : System.Type []) = ts |> Array.map defs\n            \n                let inline value<'T> : 'T = typeof<'T> |> defaultValue defs |> unbox\n            \n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n    \n    module ProzperServer =\n        [< AutoOpen ; JavaScript >]\n        module Basico =\n            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id\n            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id\n            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id\n            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id\n        \n            type VariableAmbienteI   = \n                    abstract getVar  : string -> string\n                    abstract member CarpetaRaiz          : unit     -> string\n        \n            let variableAmbienteE v  = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.getVar     v \n            let carpetaRaiz       () = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.CarpetaRaiz()\n        \n        \n        [< AutoOpen ; JavaScript >]\n        module TypesV0 =\n            type LatestType = TypeV0\n        \n            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id\n            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id\n            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id\n            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id\n        \n            type StatusAliado =\n            | CuentaCreada\n            | DatosBancariosIngresados\n            | Activo\n            | Inactivo\n            | Cancelado\n                with\n                    override this.ToString() = sprintf \"%A\" this\n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"CUENTACREADA\"             -> CuentaCreada\n                        | \"DATOSBANCARIOSINGRESADOS\" -> DatosBancariosIngresados\n                        | \"ACTIVO\"                   -> Activo\n                        | \"CANCELADO\"                -> Cancelado\n                        | _                          -> Inactivo\n        \n            type TipoAliado =\n            | Master\n            | Regular\n                with\n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Pais =\n            | USA\n            | Venezuela \n            | Argentina\n            | OtroP of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"EEUU\" | \"UNITED STATES\"  | \"UNITED STATES OF AMERICA\" | \"US\" | \"E.E.U.U.\" | \"AMERICA\"\n                        | \"USA\"            -> Some <| USA\n                        | \"VENEZUELA\"      -> Some <| Venezuela\n                        | \"ARGENTINA\"      -> Some <| Argentina\n                        | _                -> Some <| (OtroP <| s.Trim() )\n                    override this.ToString() = match this with OtroP s -> s | v -> sprintf \"%A\" v\n        \n            type Estado =\n            | Texas\n            | Florida\n            | OtroS of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"TX\"\n                        | \"TEXAS\"          -> Some <| Texas\n                        | \"FL\"\n                        | \"FLORIDA\"        -> Some <| Florida\n                        | _                -> Some <| (OtroS <| s.Trim() )\n                    override this.ToString() = match this with OtroS s -> s | v -> sprintf \"%A\" v\n        \n            type Territorio =\n            | Estado of Estado\n        \n            type Emisor =\n            | Pais       of Pais\n            | Territorio of Territorio\n        \n            type Documento =\n            | Pasaporte        of string\n            | Cedula           of string\n            | LicenciaConducir of string\n        \n            type Identificacion = {\n                emisor    : Emisor\n                documento : Documento\n                emision   : System.DateTime\n                vence     : System.DateTime\n            }\n        \n            type Mes =\n            | Enero      =  1\n            | Febrero    =  2\n            | Marzo      =  3\n            | Abril      =  4\n            | Mayo       =  5\n            | Junio      =  6\n            | Julio      =  7\n            | Agosto     =  8\n            | Septiembre =  9\n            | Octubre    = 10\n            | Noviembre  = 11\n            | Diciembre  = 12\n        \n            type Expiracion = {\n                anio : int\n                mes  : Mes\n            } with\n                member this.Id = sprintf \"%04d-%02d\" this.anio (int this.mes)\n                static member TryParse (txt:string) =\n                    let create century (anio:string) (mes:string) =\n                        {\n                            anio = century   + int anio\n                            mes  = enum<Mes>  (int mes )\n                        } |> Some\n                    if txt.Length = 4 || txt.Length = 5 then \n                        create 2000 (txt.Right 2) (txt.Left  2)\n                    elif txt.Length = 7 then\n                        txt.Split[| '-' ; '/' |]\n                        |> function \n                            | [| py ; pm |] when py.Length = 4 -> create 0 py pm\n                            | [| pm ; py |] when py.Length = 4 -> create 0 py pm\n                            |_-> None\n                    else None\n        \n        \n            type NumeroCuenta   = NumeroCuenta  of string       with member this.Id = match this with NumeroCuenta  id -> id\n            type NumeroTarjeta  = NumeroTarjeta of string       with member this.Id = match this with NumeroTarjeta id -> id\n            type RoutingNumber  = RoutingNumber of string       with member this.Id = match this with RoutingNumber id -> id \n        \n            type TipoTarjeta     = \n            | Visa\n            | MasterCard\n            | Amex\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"                 -> None    \n                        | \"VISA\"             -> Some <| Visa\n                        | \"MASTERCARD\"       -> Some <| MasterCard\n                        | \"AMEX\"\n                        | \"AMERICAN EXPRESS\" -> Some <| Amex\n                        | _                  -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type TipoCuenta     = \n            | Ahorro\n            | Corriente\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"SAVINGS\"\n                        | \"AHORRO\"         -> Some <| Ahorro\n                        | \"CHECKING\"\n                        | \"CORRIENTE\"      -> Some <| Corriente\n                        | _                -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type CuentaBancaria = {\n                titular     : string\n                banco       : string\n                tipo        : TipoCuenta\n                numero      : NumeroCuenta\n                routing     : RoutingNumber\n            }\n        \n            type TarjetaCredito = {\n                titular     : string\n                tipoTarjeta : TipoTarjeta\n                numero      : NumeroTarjeta\n                expiracion  : Expiracion\n            }\n        \n            type ConceptoPago =\n            | PagoAfiliacion\n            | PagoComision\n            | Otro of string\n                with\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type Transaccion = {\n                fechaPago      : System.DateTime\n                ano            : int\n                periodo        : int\n                monto          : int\n                idAliado       : IdAliado\n                concepto       : ConceptoPago\n                transaccion    : string\n            }\n        \n            type TipoDireccion = \n            | Habitacion\n            | Oficina\n            | ServicioPostal\n            | Otro of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"\"               -> None    \n                        | \"Habitacion\"     -> Some <| Habitacion\n                        | \"Oficina\"        -> Some <| Oficina\n                        | \"ServicioPostal\" -> Some <| ServicioPostal\n                        | s                -> Some <| Otro s\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type ZonaPostal = ZonaPostal of string\n                with \n                    static member tryParse (s:string) = if s.Trim() <> \"\" then Some (ZonaPostal <| s.Trim()) else None\n                    override this.ToString() = match this with ZonaPostal s -> s\n        \n            type Direccion = {\n                authorizeIdR  : Result<IdAddress, string>\n                tipoDireccion : TipoDireccion\n                linea1        : string\n                linea2        : string\n                ciudad        : string\n                estado        : Estado\n                pais          : Pais\n                zonaPostal    : ZonaPostal\n            }\n        \n            type TipoTelefono =\n            | Movil\n            | Oficina\n            | Habitacion\n            | Voip\n                with \n                    static member tryParse = function\n                        | \"Movil\"      -> Some Movil\n                        | \"Oficina\"    -> Some Oficina\n                        | \"Habitacion\" -> Some Habitacion\n                        | _            -> None    \n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Telefono          = {\n                tipoTelefono : TipoTelefono\n                codigoPais   : string\n                codigoArea   : string\n                numero       : string\n                extension    : string\n                mensajes     : bool\n            }\n        \n            type CorreoElectronico = {\n                email       : string\n                enviado     : System.DateTime option\n                recibido    : System.DateTime option\n            }\n                with override this.ToString() = this.email\n        \n            type Contacto =\n            | Direccion         of Direccion\n            | CorreoElectronico of CorreoElectronico\n            | Telefono          of Telefono\n            | Mensajeria        of string\n            | PaginaWeb         of string\n            | SocialMedia       of string\n        \n            type Genero =\n            | Masculino\n            | Femenino\n            | Empresa\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"Masculino\"      -> Some <| Masculino\n                        | \"Femenino\"       -> Some <| Femenino\n                        | \"Empresa\"        -> Some <| Empresa\n                        | _                -> None    \n        \n            type DatosPersonales = {\n                titulo          : string option\n                nombre1         : string\n                nombre2         : string\n                apellido1       : string\n                apellido2       : string\n                nacionalidad    : Pais\n                genero          : Genero\n                fechaNacimiento : System.DateTime\n            }\n        \n            type CuentaPago =\n            | CuentaBancaria            of CuentaBancaria\n            | TarjetaCredito            of TarjetaCredito\n            | TransferenciaElectronica  of string\n        \n            type StatusFormaPago =\n            | NuevaFormaPago\n            | Registrada      of          System.DateTime option\n            | RegistroFallido of string * System.DateTime option\n        \n            type FormaPago = {\n                nombre          : string\n                authorizeIdR    : Result<IdPayment, string>\n                cuentaPago      : CuentaPago\n            }\n        \n            type TipoMensaje = \n            | Alerta\n            | Informacion\n            | Saludo\n        \n            type Remitente =\n            | Prozper\n            | Aliado of IdAliado\n            | OtroR  of string\n        \n            type Mensaje = {\n                tipo      : TipoMensaje\n                leido     : System.DateTime option\n                fecha     : System.DateTime\n                texto     : string\n                remitente : Remitente\n            }\n        \n            type PremisasCalculo = {\n                comisionReferidosRegular     : int\n                comisionReferidosMaster      : int\n                comisionDescendientesMaster  : int\n                comisionDescendientesRegular : int\n                montoAfiliacion              : int\n                numeroReferidosMaster        : int\n                diaCorte1                    : int\n                diaCorte2                    : int\n            }\n        \n            let premisasCalculo = {\n                comisionReferidosRegular     = 15\n                comisionReferidosMaster      = 25\n                comisionDescendientesMaster  = 25\n                comisionDescendientesRegular =  0\n                montoAfiliacion              = 75\n                numeroReferidosMaster        = 31\n                diaCorte1                    = 26\n                diaCorte2                    = 28\n            }\n        \n            let telVacio = {            \n                tipoTelefono = Movil\n                codigoPais   = \"\"\n                codigoArea   = \"\"\n                numero       = \"\"\n                extension    = \"\"\n                mensajes     = false\n            }\n        \n            let dirVacio = {\n                authorizeIdR  = Error \"\"\n                tipoDireccion = TipoDireccion.Habitacion\n                linea1        = \"\"\n                linea2        = \"\"\n                ciudad        = \"\"\n                estado        = OtroS \"\"\n                pais          = OtroP \"\"\n                zonaPostal    = ZonaPostal \"\"\n            }\n        \n            let tarVacio = {            \n                tipoTarjeta  = Visa\n                numero       = NumeroTarjeta \"\"\n                expiracion   = { anio = 2000 ; mes = Mes.Enero }\n                titular      = \"\"\n            }\n        \n            let ctaVacio = {            \n                banco        = \"\"\n                numero       = NumeroCuenta \"\"\n                tipo         = Ahorro\n                titular      = \"\"\n                routing      = RoutingNumber \"\"\n            }\n        \n            type DiaPago =\n            |   Dia01\n            |   Dia05\n            |   Dia10\n            |   Dia15\n            |   Dia20\n            |   Dia25\n        \n            type IdForAuthorize = IdForAuthorize of string  with member this.Id = match this with IdForAuthorize id -> id\n        \n            type Aliado = {\n                id              :      IdAliado\n                idPadreO        :      IdAliado       option\n                idForAuthorize  :      IdForAuthorize option\n                influyente      :      string         option\n                datosPersonales :      DatosPersonales\n                contactos       :      Contacto       []\n                identificacion  :      Identificacion []\n                isInternal      :      bool\n                status          :      StatusAliado\n                diaPago         :      DiaPago\n                tipo            :      TipoAliado\n                fechaRegistro   :      System.DateTime\n                fechaStatus     :      System.DateTime\n                nReferidos      :      int\n                nRefActivos     :      int\n                nDescendientes  :      int\n                nDescActivos    :      int\n                comision        :      int\n                nivel           :      int\n            }\n        \n            type Modelo = {\n                idAliado      : IdAliado\n                aliados       : Aliado []\n                anoActual     : int\n                periodoActual : int\n                premisas      : PremisasCalculo\n                nevento       : int64\n            }\n        \n            let modeloVacio = {\n                idAliado      = IdAliado \"\"\n                aliados       = [||]\n                anoActual     = System.DateTime.Now.Year\n                periodoActual = System.DateTime.Now.Month\n                premisas      = premisasCalculo\n                nevento       = 0L\n            }\n        \n            let correoVacio = {\n                email       = \"\"\n                enviado     = None\n                recibido    = None\n            }\n        \n        [< JavaScript >]\n        module Aliado =\n            open Operators\n        \n            //let statusActual ano mes al  =\n            //    al.transacciones.Value\n            //    |> Array.tryFind (fun t -> t.idAliado = al.id \n            //                            && t.ano      = ano\n            //                            && t.periodo  = mes\n            //                            && t.concepto = PagoAfiliacion)\n            //    |> Option.map    (fun _ ->  Activo )\n            //    |> Option.defaultValue    Inactivo\n        \n            open System.Collections.Generic\n        \n            let premisas pre al =\n                let comRef, comDes = match al.tipo  with\n                                     | Regular -> pre.comisionReferidosRegular, pre.comisionDescendientesRegular\n                                     | Master  -> pre.comisionReferidosMaster , pre.comisionDescendientesMaster\n                match al.status with\n                | Activo -> comRef, comDes\n                | _      -> 0     , 0\n        \n            let comision pre al = \n                let comRef, comDes = premisas pre al\n                al.nRefActivos * comRef, al.nDescActivos * comDes\n        \n            type Buscar = {\n                hijosDe        : (IdAliado -> IdAliado [])\n                nivelDe        : (IdAliado option -> int)\n                aliado         : (IdAliado -> Aliado)\n                aliadoO        : (IdAliado -> Aliado option)\n                hijos          : (Aliado -> Aliado [])\n                descendientes  : (Aliado -> Aliado [])\n            }\n        \n            let busqueda aliados =\n                let padres               = aliados \n                                           |> Seq.map(fun al -> al.idPadreO, al.id) \n                                           |> Seq.groupBy fst \n                                           |> Seq.map(fun (pO, ch) -> pO, ch |> Seq.map snd |> Seq.toArray) |> Map\n                let aliadosMap           = aliados |> Seq.map (fun al -> al.id, al) |> Map\n                let aliadoO          id  = match aliadosMap.TryGetValue id with\n                                           | true, al -> Some al\n                                           | _        -> None\n                let aliado           id  = try aliadosMap.[id] with e -> failwithf \"buscarAliado failed: %A\" id\n                let hijosDe          idO = match padres.TryGetValue (Some idO) with\n                                           | true, hijos -> hijos\n                                           | _           -> [||]\n                let rec nivelDe      idO = idO |> Option.bind aliadoO |> Option.map (fun al -> 1 + nivelDe al.idPadreO) |> Option.defaultValue 0\n                let hijos             al = hijosDe al.id |> Array.choose aliadoO\n                let rec descendientes al =\n                    [|\n                        for h in hijos al do\n                            yield                h\n                            yield! descendientes h\n                    |]\n                {\n                    hijosDe       = hijosDe       \n                    nivelDe       = nivelDe       \n                    aliado        = aliado        \n                    aliadoO       = aliadoO       \n                    hijos         = hijos         \n                    descendientes = descendientes \n                }\n        \n            let diaPago (registro:System.DateTime) =\n                let  diaMes = registro.Day\n                if   diaMes  =  1 then Dia01\n                elif diaMes <=  5 then Dia05\n                elif diaMes <= 10 then Dia10\n                elif diaMes <= 15 then Dia15\n                elif diaMes <= 20 then Dia20\n                elif diaMes <= 25 then Dia25\n                else                   Dia01\n        \n            let dia = function\n            | Dia01 ->  1\n            | Dia05 ->  5\n            | Dia10 -> 10\n            | Dia15 -> 15\n            | Dia20 -> 20\n            | Dia25 -> 25\n        \n            let actualizarAliados modelo =\n                let  buscar            = busqueda modelo.aliados\n                let pre                = modelo.premisas\n                let rec aliadoActualizado alid =\n                    let al             = buscar.aliado alid\n                    let hijos          = buscar.hijosDe al.id |> Seq.map aliadoActualizadoM |> Seq.cache\n                    let status         = al.status //statusActual modelo.anoActual modelo.periodoActual al\n                    let nReferidos     = hijos |> Seq.length\n                    let nRefActivos    = hijos |> Seq.filter (fun al -> al.status = Activo && al.tipo = Regular) |> Seq.length\n                    let nDescendientes = hijos |> Seq.sumBy  (fun al -> al.nDescendientes + al.nReferidos )\n                    let nDescActivos   = hijos |> Seq.sumBy  (fun al -> al.nDescActivos   + al.nRefActivos)\n                    let tipo           = if nRefActivos >= pre.numeroReferidosMaster then Master else Regular\n                    let nivel          = 1 + buscar.nivelDe al.idPadreO\n                    let al' =\n                        { al with\n                            status         = status\n                            tipo           = tipo\n                            nReferidos     = nReferidos    \n                            nRefActivos    = nRefActivos   \n                            nDescendientes = nDescendientes\n                            nDescActivos   = nDescActivos  \n                            diaPago        = diaPago al.fechaRegistro\n                            //fechaStatus    = System.DateTime()\n                            nivel          = nivel\n                        }\n                    let comRef, comDes = comision pre al'\n                    { al' with comision = comRef + comDes}\n                and aliadoActualizadoM = Memoize.memoize aliadoActualizado\n        \n                modelo.aliados \n                |> Seq.map (fun al -> al.id)\n                |> Seq.map aliadoActualizadoM\n                |> Seq.toArray\n        \n            //let actualizarModelEf () = eff {\n            //    let! modelo     = State.get()\n            //    do! State.put { modelo with aliados = actualizarAliados modelo }\n            //    ()\n            //}\n        \n            let empty = {\n                datosPersonales = {\n                                        titulo          = None\n                                        nombre1         = \"\"\n                                        nombre2         = \"\"\n                                        apellido1       = \"\"\n                                        apellido2       = \"\"\n                                        nacionalidad    = USA\n                                        genero          = Masculino\n                                        fechaNacimiento = System.DateTime(2000, 1, 1)\n                                    }\n                id              =  IdAliado \"\"\n                idPadreO        =  None\n                idForAuthorize  =  None\n                influyente      =  None\n                contactos       =  [||]\n                identificacion  =  [||]\n                isInternal      =  false\n                status          =  Inactivo\n                tipo            =  Regular\n                fechaRegistro   =  System.DateTime(2000, 1, 1)\n                fechaStatus     =  System.DateTime(2000, 1, 1)\n                diaPago         =  Dia01\n                nReferidos      =  0\n                nRefActivos     =  0\n                nDescendientes  =  0\n                nDescActivos    =  0\n                comision        =  0\n                nivel           =  0\n            }\n        \n            let nombre dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                let apellido = if dp.apellido1 = \"\" then \"\" else (dp.apellido1 + \" \" + dp.apellido2).Trim() + \", \"\n                titulo + apellido + dp.nombre1 + \" \" + dp.nombre2\n        \n            let nombre2 dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                titulo + (dp.nombre1 + \" \" + dp.nombre2).Trim() + \" \" + (dp.apellido1 + \" \" + dp.apellido2).Trim()\n        \n        module Serializador =\n            open Serializer\n            open System\n        \n            [< AutoOpen >]\n            module TypesV0 =\n                open TypesV0\n            \n                let serDate : Ser<System.DateTime> = \n                    (  fun (d:System.DateTime ) -> d.ToString(\"u\") |> sprintf \"%A\"                )\n                    , (fun (j:JsonIntermediate) -> j.tryString() |> Option.bind ParseO.parseDateO )\n        \n                let serIdAliado          = serDU<IdAliado         > [   serObj serString            ]    \n                let serIdAuthorized      = serDU<IdAuthorize      > [   serObj serString            ]    \n                let serIdForAuthorize    = serDU<IdForAuthorize   > [   serObj serString            ]    \n                let serIdPayment         = serDU<IdPayment        > [   serObj serString            ]    \n                let serIdAddress         = serDU<IdAddress        > [   serObj serString            ]    \n                let serTipoAliado        = serDU<TipoAliado       > [   serObj serString            ]\n                let serPais              = serDU<Pais             > [   serObj serString            ]    \n                let serEstado            = serDU<Estado           > [   serObj serString            ]    \n                let serTerritorio        = serDU<Territorio       > [   serObj serEstado            ]   \n                let serEmisor            = serDU<Emisor           > [   serObj serPais\n                                                                        serObj serTerritorio        ]\n                let serDocumento         = serDU<Documento        > [   serObj serString            ]    \n                let serNumeroCuenta      = serDU<NumeroCuenta     > [   serObj serString            ]    \n                let serNumeroTarjeta     = serDU<NumeroTarjeta    > [   serObj serString            ]\n                let serRoutingNumber     = serDU<RoutingNumber    > [   serObj serString            ]    \n                let serTipoCuenta        = serDU<TipoCuenta       > [   serObj serString            ]    \n                let serStatusAliado      = serDU<StatusAliado     > [   serObj serString            ]    \n                let serConceptoPago      = serDU<ConceptoPago     > [   serObj serString            ]    \n                let serTipoDireccion     = serDU<TipoDireccion    > [   serObj serString            ]    \n                let serZonaPostal        = serDU<ZonaPostal       > [   serObj serString            ]    \n                let serTipoTelefono      = serDU<TipoTelefono     > [   serObj serString            ]    \n                let serGenero            = serDU<Genero           > [   serObj serString            ]    \n                let serTipoMensaje       = serDU<TipoMensaje      > [   serObj serString            ]\n                let serDiaPago           = serDU<DiaPago          > [                               ]\n        \n                let serMes : Ser<Mes>    = (int >> fst serInt), (snd serInt >> Option.map enum<_> )\n        \n                let serIdAuthorizedR     = serDU<Result<IdAuthorize, string>> [   serObj serString ; serObj serIdAuthorized ]    \n                let serIdPaymentR        = serDU<Result<IdPayment  , string>> [   serObj serString ; serObj serIdPayment    ]    \n                let serIdAddressR        = serDU<Result<IdAddress  , string>> [   serObj serString ; serObj serIdAddress    ]    \n        \n                let serExpiracion: Ser<Expiracion> =\n                    [|\n                        serInt        |> serField \"anio\"    (fun s -> s.anio   ) (fun v s -> { s with anio    = v } )   \n                        serMes        |> serField \"mes\"     (fun s -> s.mes    ) (fun v s -> { s with mes     = v } )          \n                    |] |> serRecord tarVacio.expiracion\n        \n        \n                let serIdentificacion : Ser<Identificacion> = \n                    [|\n                        serEmisor    |> serField \"emisor\"    (fun s -> s.emisor    ) (fun v s -> { s with emisor    = v } )\n                        serDocumento |> serField \"documento\" (fun s -> s.documento ) (fun v s -> { s with documento = v } )\n                        serDate      |> serField \"emision\"   (fun s -> s.emision   ) (fun v s -> { s with emision   = v } )\n                        serDate      |> serField \"vence\"     (fun s -> s.vence     ) (fun v s -> { s with vence     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaBancaria : Ser<CuentaBancaria> =\n                    [|\n                        serString        |> serField \"titular\" (fun (s:CuentaBancaria) -> s.titular) (fun v s -> { s with titular = v } )   \n                        serString        |> serField \"banco\"   (fun  s                 -> s.banco  ) (fun v s -> { s with banco   = v } )   \n                        serTipoCuenta    |> serField \"tipo\"    (fun  s                 -> s.tipo   ) (fun v s -> { s with tipo    = v } )        \n                        serNumeroCuenta  |> serField \"numero\"  (fun  s                 -> s.numero ) (fun v s -> { s with numero  = v } )          \n                        serRoutingNumber |> serField \"routing\" (fun  s                 -> s.routing) (fun v s -> { s with routing = v } )           \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTarjetaCredito : Ser<TarjetaCredito> =\n                    [|\n                        serExpiracion    |> serField \"expiracion\" (fun s -> s.expiracion) (fun v s -> { s with expiracion = v } )   \n                        serString        |> serField \"titular\"    (fun s -> s.titular   ) (fun v s -> { s with titular    = v } )   \n                        serNumeroTarjeta |> serField \"numero\"     (fun s -> s.numero    ) (fun v s -> { s with numero     = v } )          \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTransaccion : Ser<Transaccion> = \n                    [|\n                        serDate          |> serField \"fechaPago\"   (fun s -> s.fechaPago  ) (fun v s -> { s with fechaPago   = v } ) \n                        serInt           |> serField \"ano\"         (fun s -> s.ano        ) (fun v s -> { s with ano         = v } )\n                        serInt           |> serField \"periodo\"     (fun s -> s.periodo    ) (fun v s -> { s with periodo     = v } )\n                        serInt           |> serField \"monto\"       (fun s -> s.monto      ) (fun v s -> { s with monto       = v } )\n                        serIdAliado      |> serField \"idAliado\"    (fun s -> s.idAliado   ) (fun v s -> { s with idAliado    = v } )     \n                        serConceptoPago  |> serField \"concepto\"    (fun s -> s.concepto   ) (fun v s -> { s with concepto    = v } )         \n                        serString        |> serField \"transaccion\" (fun s -> s.transaccion) (fun v s -> { s with transaccion = v } )   \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDireccion : Ser<Direccion> = \n                    [|\n                        serTipoDireccion |> serField \"tipoDireccion\" (fun s -> s.tipoDireccion) (fun v s -> { s with tipoDireccion = v } )\n                        serString        |> serField \"linea1\"        (fun s -> s.linea1       ) (fun v s -> { s with linea1        = v } )\n                        serString        |> serField \"linea2\"        (fun s -> s.linea2       ) (fun v s -> { s with linea2        = v } )\n                        serString        |> serField \"ciudad\"        (fun s -> s.ciudad       ) (fun v s -> { s with ciudad        = v } )\n                        serPais          |> serField \"pais\"          (fun s -> s.pais         ) (fun v s -> { s with pais          = v } )\n                        serZonaPostal    |> serField \"zonaPostal\"    (fun s -> s.zonaPostal   ) (fun v s -> { s with zonaPostal    = v } )\n                        serEstado        |> serField \"estado\"        (fun s -> s.estado       ) (fun v s -> { s with estado        = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTelefono : Ser<Telefono> =\n                    [|\n                        serTipoTelefono |> serField \"tipoTelefono\" (fun s -> s.tipoTelefono) (fun v s -> { s with tipoTelefono = v } )\n                        serString       |> serField \"codigoPais\"   (fun s -> s.codigoPais  ) (fun v s -> { s with codigoPais   = v } )\n                        serString       |> serField \"codigoArea\"   (fun s -> s.codigoArea  ) (fun v s -> { s with codigoArea   = v } )\n                        serString       |> serField \"numero\"       (fun s -> s.numero      ) (fun v s -> { s with numero       = v } )\n                        serString       |> serField \"extension\"    (fun s -> s.extension   ) (fun v s -> { s with extension    = v } )\n                        serBool         |> serField \"mensajes\"     (fun s -> s.mensajes    ) (fun v s -> { s with mensajes     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaPago        = serDU<CuentaPago       > [   serObj serString              \n                                                                        serObj serTarjetaCredito\n                                                                        serObj serCuentaBancaria    ]\n                let serRemitente         = serDU<Remitente        > [   serObj serIdAliado\n                                                                        serObj serString            ]\n        \n                let serFormaPago : Ser<FormaPago> =\n                    [|\n                        serCuentaPago            |> serField \"cuentaPago\"  (fun s -> s.cuentaPago   ) (fun v s -> { s with cuentaPago   = v } )\n                        serString                |> serField \"nombre\"      (fun s -> s.nombre       ) (fun v s -> { s with nombre       = v } )\n                        serIdPaymentR            |> serField \"authorizeId\" (fun s -> s.authorizeIdR ) (fun v s -> { s with authorizeIdR = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDatosPersonales : Ser<DatosPersonales> =\n                    [|\n                        serString        |> serOpt  |> serField \"titulo\"          (fun s -> s.titulo         ) (fun v s -> { s with titulo          = v } )\n                        serString                   |> serField \"nombre1\"         (fun s -> s.nombre1        ) (fun v s -> { s with nombre1         = v } )\n                        serString                   |> serField \"nombre2\"         (fun s -> s.nombre2        ) (fun v s -> { s with nombre2         = v } )\n                        serString                   |> serField \"apellido1\"       (fun s -> s.apellido1      ) (fun v s -> { s with apellido1       = v } )\n                        serString                   |> serField \"apellido2\"       (fun s -> s.apellido2      ) (fun v s -> { s with apellido2       = v } )\n                        serPais                     |> serField \"nacionalidad\"    (fun s -> s.nacionalidad   ) (fun v s -> { s with nacionalidad    = v } )\n                        serGenero                   |> serField \"genero\"          (fun s -> s.genero         ) (fun v s -> { s with genero          = v } )\n                        serDate                     |> serField \"fechaNacimiento\" (fun s -> s.fechaNacimiento) (fun v s -> { s with fechaNacimiento = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serMensaje : Ser<Mensaje> =\n                    [|\n                        serTipoMensaje           |> serField \"tipo\"      (fun (s:Mensaje) -> s.tipo     ) (fun v s -> { s with tipo      = v } )\n                        serDate        |> serOpt |> serField \"leido\"     (fun (s:Mensaje) -> s.leido    ) (fun v s -> { s with leido     = v } )\n                        serDate                  |> serField \"fecha\"     (fun (s:Mensaje) -> s.fecha    ) (fun v s -> { s with fecha     = v } )\n                        serString                |> serField \"texto\"     (fun (s:Mensaje) -> s.texto    ) (fun v s -> { s with texto     = v } )\n                        serRemitente             |> serField \"remitente\" (fun (s:Mensaje) -> s.remitente) (fun v s -> { s with remitente = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serPremisasCalculo : Ser<PremisasCalculo> =\n                    [|\n                        serInt  |> serField \"comisionReferidosRegular\"     (fun s -> s.comisionReferidosRegular    ) (fun v s -> { s with comisionReferidosRegular     = v } )\n                        serInt  |> serField \"comisionReferidosMaster\"      (fun s -> s.comisionReferidosMaster     ) (fun v s -> { s with comisionReferidosMaster      = v } )\n                        serInt  |> serField \"comisionDescendientesMaster\"  (fun s -> s.comisionDescendientesMaster ) (fun v s -> { s with comisionDescendientesMaster  = v } )\n                        serInt  |> serField \"comisionDescendientesRegular\" (fun s -> s.comisionDescendientesRegular) (fun v s -> { s with comisionDescendientesRegular = v } )\n                        serInt  |> serField \"montoAfiliacion\"              (fun s -> s.montoAfiliacion             ) (fun v s -> { s with montoAfiliacion              = v } )\n                        serInt  |> serField \"numeroReferidosMaster\"        (fun s -> s.numeroReferidosMaster       ) (fun v s -> { s with numeroReferidosMaster        = v } )\n                        serInt  |> serField \"diaCorte1\"                    (fun s -> s.diaCorte1                   ) (fun v s -> { s with diaCorte1                    = v } )\n                        serInt  |> serField \"diaCorte2\"                    (fun s -> s.diaCorte2                   ) (fun v s -> { s with diaCorte2                    = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCorreoElectronico : Ser<CorreoElectronico> = \n                    [|\n                        serString         |> serField \"email\"    (fun s -> s.email    ) (fun v s -> { s with email    = v } )\n                        serDate |> serOpt |> serField \"enviado\"  (fun s -> s.enviado  ) (fun v s -> { s with enviado  = v } )\n                        serDate |> serOpt |> serField \"recibido\" (fun s -> s.recibido ) (fun v s -> { s with recibido = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serContacto          = serDU<Contacto         > [   serObj serString     \n                                                                        serObj serTelefono\n                                                                        serObj serCorreoElectronico\n                                                                        serObj serDireccion         ] \n        \n                let serAliado : Ser<Aliado> =\n                    [|\n                        serIdAliado                    |> serField \"id\"              (fun s -> s.id             ) (fun v s -> { s with id              = v } )\n                        serIdForAuthorize   |> serOpt  |> serField \"idForAuthorize\"  (fun s -> s.idForAuthorize ) (fun v s -> { s with idForAuthorize  = v } )\n                        serIdAliado         |> serOpt  |> serField \"idPadreO\"        (fun s -> s.idPadreO       ) (fun v s -> { s with idPadreO        = v } )\n                        serIdentificacion   |> serArr  |> serField \"identificacion\"  (fun s -> s.identificacion ) (fun v s -> { s with identificacion  = v } )\n                        serString           |> serOpt  |> serField \"influyente\"      (fun s -> s.influyente     ) (fun v s -> { s with influyente      = v } )\n                        serDatosPersonales             |> serField \"datosPersonales\" (fun s -> s.datosPersonales) (fun v s -> { s with datosPersonales = v } )\n                        serContacto         |> serArr  |> serField \"contactos\"       (fun s -> s.contactos      ) (fun v s -> { s with contactos       = v } )\n                        //serFormaPago        |> serArr  |> serField \"formasPago\"      (fun s -> s.formasPago     ) (fun v s -> { s with formasPago      = v } )\n                        //serTransaccion      |> serArr  |> serField \"transacciones\"   (fun s -> s.transacciones  ) (fun v s -> { s with transacciones   = v } )\n                        //serMensaje          |> serArr  |> serField \"mensajes\"        (fun s -> s.mensajes       ) (fun v s -> { s with mensajes        = v } )\n                        serBool                        |> serField \"isInternal\"      (fun s -> s.isInternal     ) (fun v s -> { s with isInternal      = v } )\n                        serStatusAliado                |> serField \"status\"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )\n                        serTipoAliado                  |> serField \"tipo\"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )\n                        serDate                        |> serField \"fechaRegistro\"   (fun s -> s.fechaRegistro  ) (fun v s -> { s with fechaRegistro   = v } )\n                        serDate                        |> serField \"fechaStatus\"     (fun s -> s.fechaStatus    ) (fun v s -> { s with fechaStatus     = v } )\n                        serDiaPago                     |> serField \"diaPago\"         (fun s -> s.diaPago        ) (fun v s -> { s with diaPago         = v } )\n                        serInt                         |> serField \"nReferidos\"      (fun s -> s.nReferidos     ) (fun v s -> { s with nReferidos      = v } )\n                        serInt                         |> serField \"nRefActivos\"     (fun s -> s.nRefActivos    ) (fun v s -> { s with nRefActivos     = v } )\n                        serInt                         |> serField \"nDescendientes\"  (fun s -> s.nDescendientes ) (fun v s -> { s with nDescendientes  = v } )\n                        serInt                         |> serField \"nDescActivos\"    (fun s -> s.nDescActivos   ) (fun v s -> { s with nDescActivos    = v } )\n                        serInt                         |> serField \"comision\"        (fun s -> s.comision       ) (fun v s -> { s with comision        = v } )\n                        serInt                         |> serField \"nivel\"           (fun s -> s.nivel          ) (fun v s -> { s with nivel           = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serModelo : Ser<Modelo> = \n                    [|\n                        serInt64                      |> serField \"nevento\"       (fun s -> s.nevento       ) (fun v s -> { s with nevento       = v } )\n                        serIdAliado                   |> serField \"idAliado\"      (fun s -> s.idAliado      ) (fun v s -> { s with idAliado      = v } )\n                        //serAliado           |> serArr |> serField \"aliados\"       (fun s -> s.aliados       ) (fun v s -> { s with aliados       = v } )\n                        serInt                        |> serField \"anoActual\"     (fun s -> s.anoActual     ) (fun v s -> { s with anoActual     = v } )\n                        serInt                        |> serField \"periodoActual\" (fun s -> s.periodoActual ) (fun v s -> { s with periodoActual = v } )\n                        serPremisasCalculo            |> serField \"premisas\"      (fun s -> s.premisas      ) (fun v s -> { s with premisas      = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n        \n        module ObtenerEstado =\n            open Serializador\n        \n            type EstadoI<'H> =\n                    abstract member UltimoEstado     : unit     ->  Eff<'H, int64 option>\n        //            abstract member LeerEventos          : int64    ->  Eff<'H, (int64 * string * string * string * string * System.DateTime) []>\n        //            abstract member LeerTipos            : unit     ->  string           []\n        //            abstract member LeerEventosTipos     : unit     -> (string * string) []\n                    abstract member GuardarEstado    : int64    ->  string ->  Eff<'H, unit>\n                    abstract member GuardarAliado    : string   ->  string ->  Eff<'H, unit>\n                    abstract member ObtenerEstado    : unit     ->  Eff<'H, (int64 * string) option>\n                    abstract member ObtenerAliados   : unit     ->  Eff<'H, string []>\n        \n            let guardarEstadoE  (nevento, serialModelo) = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarEstado nevento serialModelo\n            let obtenerEstado0E ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerEstado ()                  \n            let obtenerAliadosE ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerAliados()                  \n            let guardarAliadoE  id json                 = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarAliado id json             \n            let ultimoEstadoE   ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.UltimoEstado  ()                  \n        \n            let aliadosPrevio = System.Collections.Generic.Dictionary<_,_>()\n        \n            let guardarAliados aliados = eff {\n                let mutable first = true\n                for (aliado:Aliado) in aliados do\n                    let previoO = Dict.tryGetValue aliado.id aliadosPrevio\n                    if previoO <> Some aliado then\n                        if first then \n                            first <- false\n                            printfn \"previo = %A\" previoO \n                            printfn \"nuevo  = %A\" aliado\n                        do! aliado |> Serializer.serialize serAliado |> guardarAliadoE aliado.id.Id\n                    if previoO.IsSome then aliadosPrevio.Remove aliado.id |> ignore\n                    aliadosPrevio.Add(aliado.id, aliado)\n                    ()\n            }\n        \n            let actualizarAliadosPrevio modelo = eff {\n                aliadosPrevio.Clear()\n                for aliado in modelo.aliados do\n                    aliadosPrevio.Add(aliado.id, aliado)\n            }\n        \n            let guardarEstado nevento modelo =\n                { modelo with nevento = nevento ; aliados = Aliado.actualizarAliados modelo } \n                |> EA.tee (fun e -> guardarAliados e.aliados)\n                |>> fun (modelo:Modelo) -> nevento, modelo |> Serializer.serialize serModelo\n                >>= guardarEstadoE\n        \n            let obtenerAliados (modelo:Modelo) = eff {\n                let! aliadoss = obtenerAliadosE()\n                let  aliados  = aliadoss |> Array.choose (Serializer.deserializeWithDefs serAliado)\n                return { modelo with aliados = aliados}\n            }\n        \n            let salvarEstadoEnMemoria (aa: _ -> Eff<_,Modelo>) : _ -> Eff<_,Modelo> = \n                let mutable estadoActual : Modelo option = None        \n                fun ()   -> eff{\n                    let! estado = ultimoEstadoE()\n                    match estado, estadoActual with\n                    | Some n, Some e when n = e.nevento -> return e\n                    |_-> return! aa >-> tee (fun e -> estadoActual <- Some e) <| ()\n                }\n        \n            let obtenerEstado00E() =\n                obtenerEstado0E()\n                |>> Option.map snd                                       \n                |>> Option.map (Serializer.deserializeWithDefs serModelo)\n                |>> Option.defaultValue  (Some modeloVacio)              \n                |>  Rsl.absorbO   (fun () -> \"Modelo no fue deserializado\")\n                >>= obtenerAliados\n                >>= EA.tee actualizarAliadosPrevio\n        \n            let obtenerEstado() = obtenerEstado00E |> salvarEstadoEnMemoria <| ()\n        \n            let pairEstado ev =\n                obtenerEstado()\n                |>> fun modelo -> modelo, ev\n        \n            //let obtenerUsuario (aid: (_*_) []) : string =  aid \n                //|>  Seq.tryFind(fun (n,v) -> n = \"http://schemas.microsoft.com/identity/aid/objectidentifier\") \n                //|>  Option.map snd\n                //|>  Option.defaultWith (fun () -> failwith \"Usuario no autenticado\")\n        \n            let obtenerAliadoEstado (aid:IdAliado) =\n                obtenerEstado()\n                |>> fun modelo -> \n                        modelo.aliados \n                        |> Array.tryFind (fun al -> al.id = aid ) \n                        |> Option.map (fun v -> v, modelo) \n                |> Rsl.absorbO (fun () -> \"Aliado no fue encontrado\")\n        \n            //let obtenerAliadoEstado    aid       = obtenerUsuario       aid |>  obtenerAliadoEstado0\n            let obtenerAliado          aid       = obtenerAliadoEstado  aid |>> fst\n            //let obtenerAliadoEstadoId (IdAliado id) = obtenerAliadoEstado id\n            //let pairAliadoEstado       aid   ev  = obtenerAliadoEstado  aid |>> fun s -> s, ev\n            //let pairAliado             aid   ev  = obtenerAliado        aid |>> fun a -> a, ev\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n        \n        module Authorize =\n            open System\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n        \n            type AuthorizeI<'H>     = abstract execute : IApiOperation<'A, 'B> -> 'B\n                                      abstract prepare : unit                  -> Eff<'H, unit>\n        \n            let authorizeMerchantId (aliado:Aliado) =\n                match aliado.idForAuthorize with\n                | Some v ->        v .Id                .Left(20)\n                | None   -> aliado.id.Id.Replace(\"-\",\"\").Left(20)\n        \n            let executeE (controller: IApiOperation<_,_> ) = Reader.ask() |>> fun (h:#AuthorizeI<_>) -> h.execute controller\n            let prepareE (                               ) = Reader.ask() >>= fun (h:#AuthorizeI<_>) -> h.prepare ()\n            let inline executeGetResponse controller : Eff<_, 'b> = eff {\n                let! response = executeE controller\n                if response = null then \n                    return! Rsl.failf \"%s Failed, Response = null\" ( controller.GetType().Name )\n                elif response.messages.resultCode = messageTypeEnum.Ok then\n                    return response\n                elif response.messages.message <> null then\n                    return! Rsl.failf \"%s Error: %s %s\"  ( controller.GetType().Name ) response.messages.message.[0].code response.messages.message.[0].text\n                else\n                    return! Rsl.failf \"%s Error: resultCode = %A, no messages\" ( controller.GetType().Name ) response.messages.resultCode\n            }\n        \n            let ( |*> ) request controllerF =\n                prepareE()\n                |>> fun () -> controllerF request\n                >>= executeGetResponse \n        \n            let ( >*> ) requestEf controllerF = requestEf |>> controllerF >>= executeGetResponse\n        \n            let buscarPerfil aliado =\n                getCustomerProfileRequest( merchantCustomerId  = authorizeMerchantId aliado ) \n                |*> getCustomerProfileController\n                |>> fun response -> response.profile, match response.subscriptionIds with null -> [||] | v -> v\n                \n        \n            let buscarIdAuthorize aliado =\n                buscarPerfil aliado\n                |>> fun (p,_) -> IdAuthorize p.customerProfileId\n        \n            let registrarAliadoNuevo (aliado:Aliado, paymentProfile : customerPaymentProfileType) =\n                let email = aliado.contactos \n                            |> Seq.choose(function CorreoElectronico cor -> Some cor.email |_-> None) \n                            |> Seq.tryHead |> Option.defaultValue \"\"\n                let customerProfile = \n                    customerProfileType(        merchantCustomerId  = authorizeMerchantId aliado\n                                            ,   email               = email \n                                            ,   paymentProfiles     = [| paymentProfile |] )\n                createCustomerProfileRequest(   profile             = customerProfile\n                                            ,   validationMode      = validationModeEnum.liveMode )\n                |*> createCustomerProfileController \n                |>> fun response -> response.customerPaymentProfileIdList.[0]\n        \n            let registrarPagoNuevo (IdAuthorize id, pp : customerPaymentProfileType) =\n                createCustomerPaymentProfileRequest(customerProfileId = id\n                                                ,   paymentProfile    = pp\n                                                ,   validationMode    = validationModeEnum.liveMode)\n                |*> createCustomerPaymentProfileController\n                |>> fun response -> response.customerPaymentProfileId\n        \n            let pagoTipoTarjeta (tar:TarjetaCredito) =\n                let creditCard = creditCardType(cardNumber      = tar.numero.Id\n                                            ,   expirationDate  = tar.expiracion.Id               )\n                paymentType( Item = creditCard ), tar.titular\n        \n            let pagoTipoCuenta  (cta:CuentaBancaria) =\n                let  bankAccount = bankAccountType(  accountNumber   = cta.numero .Id\n                                                ,   routingNumber   = cta.routing.Id\n                                            //,   accountType     = bankAccountTypeEnum.checking\n                                            //,   echeckType      = echeckTypeEnum.WEB\n                                                ,   nameOnAccount   = cta.titular\n                                                ,   bankName        = cta.banco)\n                paymentType( Item = bankAccount  ), cta.titular\n        \n            let datosTitularO (aliado:Aliado) (titular:string) =\n                aliado.contactos \n                |> Seq.tryPick(function | Direccion dir -> Some dir |_-> None)\n                |> Option.map (fun direccion -> \n                    customerAddressType(firstName = (titular.Split ' ').[0]\n                                    ,   lastName  = (titular.Split ' ' |> Seq.skip 1 |> String.concat \" \")\n                                    ,   address   = direccion.linea1\n                                    ,   city      = direccion.ciudad\n                                    ,   state     = direccion.estado    .ToString()\n                                    ,   zip       = direccion.zonaPostal.ToString()\n                                    ,   country   = direccion.pais      .ToString()\n                                    )\n                )\n        \n            let perfilPago (tipoPago: paymentType, titular: string) (aliado:Aliado) =\n                datosTitularO aliado titular\n                |> Option.map (fun datosTitular ->\n                    aliado,\n                    customerPaymentProfileType( payment = tipoPago\n                                            ,   billTo  = datosTitular )\n                )\n        \n            let obtenerFormasDePagoId aid =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarPerfil\n                |>> fun (perfil,_) ->\n                        perfil.paymentProfiles\n                        |> Array.choose (fun pago ->\n                            match pago.payment.Item with\n                            | :? AuthorizeNet.Api.Contracts.V1.creditCardMaskedType as cc -> \n                                TarjetaCredito {\n                                    titular       = pago.billTo.firstName + \" \" + pago.billTo.lastName\n                                    tipoTarjeta   = TipoTarjeta.tryParse cc.cardType |> Option.defaultValue Visa\n                                    numero        = NumeroTarjeta cc.cardNumber\n                                    expiracion    = { anio = 0 ; mes = Mes.Enero}\n                                } |> Some\n                            | :? AuthorizeNet.Api.Contracts.V1.bankAccountMaskedType as ba -> \n                                CuentaBancaria {\n                                    titular     = ba.nameOnAccount\n                                    banco       = ba.bankName\n                                    tipo        = match ba.accountType with\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.businessChecking\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.checking          -> Corriente\n                                                    |_-> Ahorro\n                                    numero      = NumeroCuenta  ba.accountNumber\n                                    routing     = RoutingNumber ba.routingNumber\n                                } |> Some\n                            |_-> None\n                            |> Option.map (fun cta ->\n                                {\n                                    nombre       = \"\"\n                                    authorizeIdR = pago.customerPaymentProfileId |> IdPayment |> Ok\n                                    cuentaPago   = cta\n                                }\n                            )\n                        )\n                |>  Rsl.getResult\n                |>> Result.defaultValue [||]\n        \n        //    let obtenerFormasDePago aid =\n        //        fun () -> ObtenerEstado.obtenerAliado aid\n        //        >=> obtenerFormasDePagoId\n        \n            let obtenerFormasDePagoPara (alIds:_[]) = eff {\n                let! fps =\n                    alIds \n                    |> traverseSeq (fun id -> eff {\n                        let! fp = obtenerFormasDePagoId id\n                        return id, fp\n                    })\n                return fps |> Seq.toArray \n            }\n        \n            let registrarFormaPago (al, pp) =\n                buscarIdAuthorize al\n                |> Rsl.getResult\n                >>= function\n                    | Ok p -> registrarPagoNuevo   (p , pp)\n                    |_     -> registrarAliadoNuevo (al, pp)\n        \n            let crearFormaPago aid (tipoPago: paymentType, titular : string) =\n                ObtenerEstado.obtenerAliado aid\n                |>> perfilPago (tipoPago, titular)\n                |>  Rsl.absorbO (fun () -> \"No se encontro direccion\")\n                >>= registrarFormaPago\n        \n            let registrarTarjeta         aid (tc:TarjetaCredito) =\n                pagoTipoTarjeta tc\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Tarjeta registrada.\"\n        \n            let registrarCuenta          aid (cta: CuentaBancaria) =\n                pagoTipoCuenta cta\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Cuenta registrada.\"\n        \n            let validarFormaPago         aid (IdPayment idp) =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        validateCustomerPaymentProfileRequest(  customerProfileId        = idm\n                                                            ,   customerPaymentProfileId = idp\n                                                            ,   validationMode           = validationModeEnum.liveMode\n                        )\n                >*> validateCustomerPaymentProfileController\n                |>> fun response -> response.directResponse\n        \n            let borrarFormaPago aid (IdPayment idp) =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        deleteCustomerPaymentProfileRequest(customerProfileId        = idm\n                                                        ,   customerPaymentProfileId = idp\n                        )\n                >*> deleteCustomerPaymentProfileController\n                |>> fun response -> \"Forma de pago borrada.\"\n        \n            let obtenerAliadoEstadoPerfilSubIds idAl =\n                ObtenerEstado.obtenerAliadoEstado idAl\n                >>= fun (al,md) ->\n                        buscarPerfil al\n                        |>> fun (pe,subs) -> al, md, pe, subs\n        \n            let crearSubscripcion aid (IdPayment idp) =\n                obtenerAliadoEstadoPerfilSubIds aid \n                >>= fun  (al : Aliado, md : Modelo, pe, subs)  -> eff {\n                        let start = DateTime(DateTime.Today.Year, DateTime.Today.Month, Aliado.dia al.diaPago)\n                                    |> fun start -> if start < DateTime.Today               then start.AddMonths 1 else start\n                                    |> fun start -> if start < al.fechaRegistro.AddMonths 1 then start.AddMonths 1 else start\n                        let sub   = if subs.Length = 0 then \n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   paymentSchedule         = paymentScheduleType(  interval                    = paymentScheduleTypeInterval(length = int16 1, unit = ARBSubscriptionUnitEnum.months) \n                                                                                            ,   totalOccurrences            = int16 240\n                                                                                            ,   startDate                   = start)\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                                    else\n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                        return sub |>! print, if (subs |>! print).Length = 0 then None else Some subs.[0]\n                    }\n        \n            let createSubscription sub =\n                ARBCreateSubscriptionRequest(subscription = sub)\n                |*> ARBCreateSubscriptionController\n                |>> fun response -> response.subscriptionId\n        \n            let updateSubscription subId sub =\n                ARBUpdateSubscriptionRequest(subscription = sub, subscriptionId = subId)\n                |*> ARBUpdateSubscriptionController\n                |>> fun _response -> subId\n        \n            let actualizarSubscripcion aid idp =\n                crearSubscripcion aid idp\n                >>= function\n                    | sub, None       -> createSubscription       sub\n                    | sub, Some subId -> updateSubscription subId sub\n        \n            let getBatchDetalles bid = \n                getTransactionListRequest(  batchId = bid )\n                |*> getTransactionListController\n                |>> fun response -> response.transactions\n        \n            let buscarPerfilPorProfileId pid =\n                getCustomerProfileRequest(  customerProfileId = string pid )\n                |*> getCustomerProfileController\n                |>> fun response -> response.profile\n        \n            let getSubscriptions active =\n                ARBGetSubscriptionListRequest(searchType = (if active then ARBGetSubscriptionListSearchTypeEnum.subscriptionActive else ARBGetSubscriptionListSearchTypeEnum.subscriptionInactive) )\n                |*> ARBGetSubscriptionListController\n                |>> fun response -> response.subscriptionDetails\n                >>= traverseSeq (fun s -> buscarPerfilPorProfileId s.customerProfileId |>> (fun p -> s, p) )\n        \n            let getSubscriptionTransactions () =\n                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths -1 \n                                         ,   lastSettlementDate = System.DateTime.Now)\n                |*> getSettledBatchListController\n                |>> fun response -> response.batchList\n                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )\n                |>>(Seq.map   (fun (b,ts) -> b, ts |> Seq.filter(fun t -> t.subscription <> null) )\n                 >> Seq.filter(fun (b,ts) ->    ts |> Seq.isEmpty |> not )\n                   )\n        \n            let SubsYTransacciones () =\n                getSubscriptionTransactions()\n                |>> Seq.collect (fun (b, ts) -> ts |> Seq.map (fun t -> b, t))\n                >>= fun ts -> eff {\n                        let! subs = getSubscriptions true\n                        return ts, subs \n                    }\n                >>= EA.tee (fun (ts, subs) -> eff {\n                        let orphans = ts |> Seq.filter(fun (b,t) -> subs |> Seq.exists (fun (s,p) -> s.id = t.subscription.id) |> not) |> Seq.toArray\n                        for b, t in orphans do\n                            do! Log.logf \"Huerfano: %A\" (\n                                        b.batchId\n                                        , t.accountNumber\n                                        , t.accountType\n                                        , t.firstName\n                                        , t.lastName\n                                        , t.settleAmount\n                                        , t.subscription.id\n                                        , t.subscription.payNum\n                                        , t.transactionStatus\n                                        , t.transId )\n                    })\n                |>> fun (ts, subs) ->  subs |> Seq.map(fun (sub,p) -> sub,p, ts |> Seq.filter (fun (b,t) -> t.subscription.id = sub.id) )\n        \n            //type H() =\n            //    interface Rsl.Rsl<string>\n            //    interface Log.Log<string>\n            //    interface VariableAmbienteI with member __.getVar  v  = failwith \"VariableAmbienteI.getVar not implemented\"\n            //    interface AuthorizeI<H>     with member __.execute c  = failwith \"AuthorizeI<H>.Execute not implemented\"\n            //                                     member __.prepare () = failwith \"AuthorizeI<H>.Prepare not implemented\"\n            //    interface EstadoI with\n            //            member __.UltimoEvento      ()  = failwith \"EstadoI.UltimoEvento not implemented\"\n            //            member __.UltimoEstado      ()  = failwith \"EstadoI.UltimoEstado not implemented\"\n            //            member __.LeerEventos       p   = failwith \"EstadoI.LeerEventos not implemented\"\n            //            member __.LeerTipos         ()  = failwith \"EstadoI.LeerTipos not implemented\"\n            //            member __.LeerEventosTipos  ()  = failwith \"EstadoI.LeerEventosTipos not implemented\"\n            //            member __.GuardarEstado     p q = failwith \"EstadoI.GuardarEstado not implemented\"\n            //            member __.GuardarAliado     p q = failwith \"EstadoI.GuardarAliado not implemented\"\n            //            member __.ObtenerEstado     ()  = failwith \"EstadoI.ObtenerEstado not implemented\"\n            //            member __.ObtenerAliados    ()  = failwith \"EstadoI.ObtenerAliados not implemented\"\n        \n            let cancelSubscription sid =\n                ARBCancelSubscriptionRequest(subscriptionId = sid)\n                |*> ARBCancelSubscriptionController\n        \n            let voidTransaction tid =\n                transactionRequestType(transactionType = \"voidTransaction\", refTransId = tid)\n                |>  fun trt -> createTransactionRequest(transactionRequest = trt)\n                |*> createTransactionController\n        \n         [< JavaScript >]\n        type DataEvento =\n        | AgregarAliados            of (Aliado[]                                                   )\n        | AgregarAliado             of (Aliado                                                     )\n        | InvitarPotencialesAliados of (IdAliado * string []                                       )\n        | RegistroNuevo             of (IdAliado * DatosPersonales * IdAliado option * Contacto [] )\n        | ActualizarDatosPersonales of (IdAliado * DatosPersonales                                 )\n        | ActualizarContactos       of (IdAliado * Contacto  []                                    )\n        //| ActualizarFormasPago      of (IdAliado * FormaPago []                                    )\n        | CorreoVerificacionEnviado of (IdAliado * string                                          )\n        | CorreoVerificado          of (IdAliado * string                                          )\n        //| ActualizarAuthorizeId     of (IdAliado * Result<IdAuthorize, string>                     )\n        //| ActualizarPagoAuthorizeId of (IdAliado * CuentaPago * Result<IdPayment, string>          )\n        | ActualizarStatusPadre     of (IdAliado * StatusAliado * (IdAliado option) * string option)\n        \n        [< JavaScript >]\n        type Evento = {\n            nevento : int64\n            aliadoO : IdAliado option\n            data    : DataEvento\n        }\n        \n        [< JavaScript >]\n        type Respuesta =\n        | ROk\n        | NuevoRegistro        of string\n        | Mensaje              of string\n        \n        \n        module Eventos =\n        \n            type TipoDatos = TipoDatos of nombre:string * tipos:string\n        \n            type ResultadoManejador<'H> = Modelo -> Eff<'H,Modelo * Respuesta>\n        \n            type ObjetoDatos<'T> = {\n                tipoDatos : TipoDatos\n                datos     : 'T\n            }\n        \n            type ManejadorDatos<'T, 'H> = {\n                tipoDatos  : TipoDatos\n                manejadorF : ObjetoDatos<'T> -> ResultadoManejador<'H>\n            }\n        \n            let Manejadores<'H> = System.Collections.Generic.Dictionary<TipoDatos, ManejadorDatos<obj,'H>>()\n        \n            let deDatosGen (msg: ObjetoDatos<obj>) : ObjetoDatos<_> = {\n                tipoDatos = msg.tipoDatos\n                datos     = unbox msg.datos\n            }    \n        \n            let registrarManejador nombre (manejadorF:ObjetoDatos<'T> -> ResultadoManejador<_>) =\n                let manejador  = {\n                    tipoDatos  = TipoDatos (nombre, typeof<'T> |> getTypeName) |>! print\n                    manejadorF = deDatosGen >> manejadorF\n                }\n                Manejadores.Add(manejador.tipoDatos, manejador )\n        \n            let registrarManejadorf nombre (manejadorF:'T -> ResultadoManejador<_>) =\n                registrarManejador  nombre (fun oDatos -> manejadorF oDatos.datos)\n        \n            let manejadorGenerico (msg:ObjetoDatos<obj>) : ResultadoManejador<_> =\n                match Manejadores.TryGetValue msg.tipoDatos with\n                | false, _         -> failwithf \"No Handler for message: %A\" msg\n                | true , manejador -> manejador.manejadorF msg\n        \n            let addNewAliados (als1: Aliado []) (als2: Aliado []) : Aliado [] =\n                als1 |> Seq.filter(fun a -> als2 |> Seq.exists (fun b -> a.id = b.id ) |> not ) |> Seq.append als2 |> Seq.toArray\n        \n            let registroNuevo (idA, datos:DatosPersonales, padre, contactos) (modelo: Modelo) : Eff<'H,Modelo * Respuesta> = eff {\n                match   contactos\n                        |> Seq.tryPick(function CorreoElectronico email -> Some email |_-> None ) with\n                | None        -> return! sprintf \"No se encontro Correo Electronico: %A\" datos |> Error |> Rsl.ofResult\n                | Some correo ->\n                if  modelo.aliados\n                    |> Seq.exists(fun al ->\n                        al.contactos\n                        |> Seq.exists(function CorreoElectronico correo2 -> correo = correo2 |_-> false ) \n                    )\n                    then return! sprintf \"Correo Electronico ya esta registrado: %A\" correo |> Error |> Rsl.ofResult\n                else\n                if modelo.aliados |> Seq.exists (fun al -> al.id = idA) \n                    then return! sprintf \"Id ya esta en uso: %A\" idA                        |> Error |> Rsl.ofResult\n                else\n                let now = System.DateTime.Now\n                let aliado = {\n                    datosPersonales =  datos\n                    id              =  idA\n                    idPadreO        =  padre\n                    idForAuthorize  =  None\n                    influyente      =  None\n                    contactos       =  contactos\n                    identificacion  =  [||]\n                    isInternal      =  false\n                    status          =  CuentaCreada\n                    tipo            =  Regular\n                    fechaRegistro   =  now\n                    fechaStatus     =  now\n                    diaPago         =  Dia01\n                    nReferidos      =  0\n                    nRefActivos     =  0\n                    nDescendientes  =  0\n                    nDescActivos    =  0\n                    comision        =  0\n                    nivel           =  0\n                }\n                return\n                    { modelo with aliados = Array.append modelo.aliados [| aliado |] }\n                ,   [ datos.nombre1 ; datos.nombre2 ; datos.apellido1 ; datos.apellido2 ] \n                    |> String.concat \" \"\n                    |> NuevoRegistro  \n            }\n        \n            let cambiaAliado ida   f (modelo:Modelo) = { modelo with aliados    = modelo.aliados          |> Array.map (fun al -> if al.id = ida then f al else al )}\n            let cambiaCorreo email f (aliado:Aliado) = { aliado with contactos  = aliado.contactos        |> Array.map (function CorreoElectronico c when c.email = email -> f c |> CorreoElectronico | co -> co )}\n            //let cambiaFormaPago cp f (aliado:Aliado) = { aliado with formasPago = aliado.formasPago.Value |> Array.map (fun fp -> if fp.cuentaPago = cp then f fp else fp ) }\n            let cambiaStatusCorreo ida email f = cambiaAliado ida (cambiaCorreo email  f)\n        \n            let actualizarDatosPersonales (idA, datos:DatosPersonales) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with datosPersonales = datos }) modelo\n                ,   Mensaje <| \"Datos personales actualizados!\" \n            }\n        \n            //let actualizarAuthorizeId   (idA, authorizeIdR) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with authorizeIdR = authorizeIdR }) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            //let actualizarPagoAuthorizeId (idA, cuenta, paymentIdR : Result<IdPayment, string> )  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (cambiaFormaPago cuenta (fun fp -> { fp with authorizeIdR = paymentIdR }) ) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            let actualizarContactos (idA, contactos:Contacto[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with contactos = contactos }) modelo\n                ,   Mensaje <| \"Contactos actualizados!\" \n            }\n        \n            let actualizarStatusPadre (idA, status:StatusAliado, padreO:IdAliado option, inflO :  string option) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with status = status ; idPadreO = padreO ; influyente = inflO }) modelo\n                ,   Mensaje <| \"status actualizados!\" \n            }\n        \n            //let actualizarFormasPago (idA, formasPago:FormaPago[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with formasPago = formasPago }) modelo\n            //    ,  Mensaje <| \"Formas de pago actualizadas!\" \n            //}\n        \n            let agregarAliado  aliado  modelo = eff { return { modelo with Modelo.aliados = addNewAliados [| aliado  |] modelo.aliados }, ROk }\n            let agregarAliados aliados modelo = eff { return { modelo with Modelo.aliados = addNewAliados    aliados    modelo.aliados }, ROk }\n        \n            let correoVerificacionEnviado (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with enviado = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let correoVerificado          (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with recibido = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let actualizarEstado (modelo: Modelo, evento: Evento) = eff {\n                if modelo.nevento <> -1L && modelo.nevento + 1L <> evento.nevento then \n                    failwithf \"Evento fuera de secuencia: %d %d\" modelo.nevento evento.nevento\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                let objData           = {\n                    tipoDatos         = TipoDatos(case, tuple |> getTypeName)\n                    datos             = data\n                }\n                return! manejadorGenerico objData modelo\n            }\n        \n            let eventoNoImplementado ev (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return! sprintf \"Evento no Implementado: %A\" ev |> Error |> Rsl.ofResult\n            } \n        \n            let invitarPotencialesAliados ev = eventoNoImplementado ev\n        module SerializadorEventos =\n            open Serializador\n            open Serializer\n            open System\n        \n            open FSharp.Reflection\n        \n            let serObject : Ser<obj> = (fun o -> o.GetType().ToString() |> sprintf \"%A\"), (fun _ -> None)\n        \n            let serSerializadoresEventos =\n                let sers = System.Collections.Generic.Dictionary<_,_>()\n                [\n                    serObj         serObject\n                    serObj         serString\n                    serObj         serAliado\n                    serObj         serIdAliado\n                    serObj         serIdAuthorized\n                    serObj (serOpt serIdAliado )\n                    serObj (serArr serContacto )\n                    serObj (serArr serFormaPago)\n                    serObj (serArr serAliado   )\n                    serObj (serArr serString   )\n                    serObj         serDatosPersonales\n                    serObj         serIdAuthorizedR\n                    serObj         serCuentaPago\n                    serObj         serIdPaymentR\n                ] |> Seq.iter sers.Add\n                sers\n        \n            let rec registrarSerializadorParaTipos (ts:System.Type []) =\n                if Seq.length ts <= 1 then () else\n                let tupleType = FSharpType.MakeTupleType ts\n                let tname     = getTypeName tupleType\n                if serSerializadoresEventos.ContainsKey tname then () else\n                let sers      = ts |> Array.map (fun t ->   let tname = getTypeName  t\n                                                            serSerializadoresEventos \n                                                            |> Dict.tryGetValue tname \n                                                            |> Option.defaultWith (fun () -> failwithf \"Serializador no encontrado: %s\" tname) )\n                let getValues = FSharpValue.PreComputeTupleReader      tupleType\n                let setValues = FSharpValue.PreComputeTupleConstructor tupleType\n                let serC    v = Seq.zip (getValues v) sers\n                                |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                |> String.concat \", \"\n                                |> sprintf \"[%s]\"\n                let deserC (j:JsonIntermediate) = \n                                match j.tryArray () with\n                                | None -> None\n                                | Some js -> \n                                Array.zip js sers\n                                |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                |> setValues\n                                |> Some\n                serSerializadoresEventos.Add(tname, (serC, deserC))\n        \n            and registrarSerializadoresParaDU (ttype:System.Type) =\n                FSharpType.GetUnionCases ttype\n                |> Seq.iter(fun case ->\n                    let ts = case.GetFields() |> Array.map(fun p -> p.PropertyType) \n                    ts |> Seq.iter registrarSerializadorPara \n                    ts |> registrarSerializadorParaTipos\n                )\n        \n            and registrarSerializadorPara (ttype:System.Type) =\n                let tname = getTypeName ttype\n                if serSerializadoresEventos.ContainsKey tname then () else\n                if   FSharpType.IsUnion ttype then \n                    registrarSerializadoresParaDU ttype\n                    if serSerializadoresEventos.ContainsKey tname then () else\n                    let ser = Serializer.serDUt (Seq.zip serSerializadoresEventos.Keys serSerializadoresEventos.Values) ttype\n                    serSerializadoresEventos.Add(tname, ser)\n                elif FSharpType.IsTuple ttype then\n                    let ts = FSharpType.GetTupleElements ttype\n                    ts |> Seq.iter registrarSerializadorPara\n                    registrarSerializadorParaTipos ts\n                else\n                    failwithf \"Could not register serializer for: %s\" tname\n        \n            registrarSerializadorPara typeof<DataEvento>\n        \n            let obtenerSerializador tipoEvento = \n                serSerializadoresEventos \n                |> Dict.tryGetValue tipoEvento\n                |> Option.defaultWith (fun () -> failwithf \"Could not find deserializer for %s\" tipoEvento)\n        \n        \n            let registrarF evento (f : 'T -> Eventos.ResultadoManejador<_>) =\n                Eventos.registrarManejadorf evento f\n                registrarSerializadorPara typeof<'T>\n        \n            print \"serializers:\"\n            serSerializadoresEventos.Keys |> Seq.iter print\n        \n            //open CodigoGenerado\n        \n        //    let chequearEventosEnBD et =\n        //        match et with\n        //        | ActualizarDatosPersonales_V0  v -> Eventos.actualizarDatosPersonales  v\n                //| ActualizarFormasPago_V0       v -> Eventos.actualizarFormasPago       v\n                //| AgregarAliado_V1              v -> Eventos.agregarAliado              v\n                //| RegistroNuevo_V1              v -> Eventos.registroNuevo              v\n                //| CorreoVerificacionEnviado_V0  v -> Eventos.correoVerificacionEnviado  v\n        \n            let chequearEventos ev =\n                match ev with\n                | AgregarAliado                 v -> Eventos.agregarAliado              v\n                | AgregarAliados                v -> Eventos.agregarAliados             v\n                | RegistroNuevo                 v -> Eventos.registroNuevo              v\n                | ActualizarDatosPersonales     v -> Eventos.actualizarDatosPersonales  v\n                | ActualizarContactos           v -> Eventos.actualizarContactos        v\n                //| ActualizarFormasPago          v -> Eventos.actualizarFormasPago       v\n                | CorreoVerificacionEnviado     v -> Eventos.correoVerificacionEnviado  v\n                | CorreoVerificado              v -> Eventos.correoVerificado           v\n                | InvitarPotencialesAliados     v -> Eventos.invitarPotencialesAliados  v\n                //| ActualizarAuthorizeId         v -> Eventos.actualizarAuthorizeId      v\n                //| ActualizarPagoAuthorizeId     v -> Eventos.actualizarPagoAuthorizeId  v\n                | ActualizarStatusPadre         v -> Eventos.actualizarStatusPadre      v\n        \n            registrarF \"AgregarAliado\"             Eventos.agregarAliado\n            registrarF \"AgregarAliados\"            Eventos.agregarAliados\n            registrarF \"RegistroNuevo\"             Eventos.registroNuevo\n            registrarF \"ActualizarDatosPersonales\" Eventos.actualizarDatosPersonales\n            registrarF \"ActualizarContactos\"       Eventos.actualizarContactos\n            //registrarF \"ActualizarFormasPago\"      Eventos.actualizarFormasPago\n            registrarF \"CorreoVerificacionEnviado\" Eventos.correoVerificacionEnviado\n            registrarF \"CorreoVerificado\"          Eventos.correoVerificado\n            registrarF \"InvitarPotencialesAliados\" Eventos.invitarPotencialesAliados\n            //registrarF \"ActualizarAuthorizeId\"     Eventos.actualizarAuthorizeId\n            //registrarF \"ActualizarPagoAuthorizeId\" Eventos.actualizarPagoAuthorizeId\n            registrarF \"ActualizarStatusPadre\"     Eventos.actualizarStatusPadre\n        \n            //SQLServer.leerTipos()\n            //|> Seq.iter (fun t ->\n            //    if serSerializadoresEventos.ContainsKey t |> not then\n            //        failwithf \"Serializador no encontrado para tipo %s\" t\n            //)\n        //\n            //SQLServer.leerEventosTipos()\n            //    |> Seq.iter (fun t ->\n            //    if Eventos.TipoDatos t |> Eventos.Manejadores.ContainsKey |> not then\n            //        failwithf \"Manejador no encontrado para evento %A\" t\n            //)\n        \n        \n        module Correo =\n            open System.IO\n            open WebSharper.UI.Server\n        \n            type EmailI<'H> = abstract member SendEmail : string -> string -> string -> Eff<'H, unit>\n            let sendEmail (recipiente:string) (tema:string) (contenido:string)  = Reader.ask() >>= fun (h:#EmailI<'H>) -> h.SendEmail recipiente tema contenido\n        \n            let dummyCtxE() =\n                carpetaRaiz()\n                |>> fun raiz ->\n                        { new WebSharper.Web.Context() with\n                            member this.RootFolder      = raiz\n                            member this.RequestUri      = failwith \"Unsupported\"\n                            member this.UserSession     = failwith \"Unsupported\"\n                            member this.Environment     = failwith \"Unsupported\"\n                            member this.Json            = failwith \"Unsupported\"\n                            member this.Metadata        = failwith \"Unsupported\"\n                            member this.Dependencies    = failwith \"Unsupported\"\n                            member this.ApplicationPath = failwith \"Unsupported\"\n                            member this.ResourceContext = failwith \"Unsupported\" }\n        \n            let prepareHtml (doc:Doc) =\n                dummyCtxE()\n                |>> fun dummyCtx ->\n                        use tw  = new StringWriter()\n                        use w   = new Core.Resources.HtmlTextWriter(tw, \" \")        \n                        doc.Write(dummyCtx, w, false)\n                        tw.ToString()\n        \n            open WebSharper.UI.Templating\n        \n            let [< Literal >] TemplatesCorreos = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\src\\Correos.html\"\n            type TemplateCorreo = Template<TemplatesCorreos, serverLoad = ServerLoad.WhenChanged>\n        \n            let hostE() = variableAmbienteE \"Website\" |>> sprintf \"https://%s\"\n        \n            let SendGridAPIKey = \"\"\n         \n            let enviarCorreoInvitacion tema (IdAliado idPadre) (email:string)= \n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Invitacion() \n                            .Logo(   TemplateCorreo.Logo().Doc())\n                            .Enlace( sprintf \"%s/Register/%s\" host idPadre )\n                            .Doc()\n                >>= prepareHtml\n                >>= sendEmail email tema\n        \n            let enviarCorreosInvitacion (tema, padre, emails:string[]) = eff {\n                for email in emails do\n                    do! enviarCorreoInvitacion tema padre email\n            }\n        \n            let enviarBienvenida (aliado:Aliado) (correo:CorreoElectronico) =\n                let sufijo = match aliado.datosPersonales.genero with Femenino -> \"a\" |_-> \"o\"\n                let nombre = Aliado.nombre2 aliado.datosPersonales\n                let tema   = sprintf \"Prozper le da la bienvenida\"\n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Bienvenida()\n                                .Logo(   TemplateCorreo.Logo().Doc())\n                                .Enlace(        sprintf \"%s/#/Content/ProzperLyt.cntFormaFormasPago\" host )\n                                .Sufijo(        sufijo                                                    )\n                                .NombreAfiliado(nombre                                                    )\n                                .Doc()\n                >>= prepareHtml\n                >>= sendEmail correo.email tema\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n            let enviarVerificacionCorreo (aliado:Aliado) (correo:CorreoElectronico) =\n                WebSharper.UI.Html.div [] [ WebSharper.UI.Html.text \"CORREO CONTENIDO\" ]\n                |>  prepareHtml\n                >>= sendEmail correo.email \"Verificacion de Correo\"\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n        \n        \n        module ManejadorEventos =\n            //open ObtenerEstado\n        \n            type EventoI<'H> =\n                    abstract member NuevoEvento<     'H> : string   -> string -> string -> string -> Eff<'H, int64         >\n                    abstract member UltimoEvento<    'H> : unit     ->                               Eff<'H, int64 option  >\n                    abstract member EnviarMensaje<   'H> : string   -> string -> string -> string -> Eff<'H, unit          >\n                    abstract member ObtenerListaDocs<'H> : IdAliado ->                               Eff<'H, string      []>\n        \n            let nuevoEvento   (usuario:string) (nombre:string) (evento:string) (tipo:string) = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.NuevoEvento usuario nombre evento tipo\n            let enviarMensaje (d:string) (r:string) (t:string) (c:string)                    = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.EnviarMensaje d r t c                 \n            let obtenerListaDocs0 alid                                                       = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.ObtenerListaDocs alid                 \n        \n            type SerialEvento = {\n                nombre  : string\n                tipo    : string\n                json    : string\n                data    : obj\n            }\n        \n            type SerialEventoU = {\n                usuario   : string\n                serEvento : SerialEvento\n            }\n        \n            type SerialEventoN = {\n                nevento    : int64\n                serEventoU : SerialEventoU\n            }\n        \n            let deserializarEvento (serEvento : SerialEvento) =\n                let ser = SerializadorEventos.obtenerSerializador serEvento.tipo\n                match Serializer.deserializeWithDefs ser serEvento.json with\n                | Some data -> data\n                | None      -> failwithf \"No se pudo deserializar el Evento: %A\" serEvento\n        \n            let manejadorGenerico msg = \n                ObtenerEstado.obtenerEstado()\n                >>= fun estadoO -> \n                        Eventos.manejadorGenerico msg estadoO\n                        |>  Rsl.getResult\n                        |>> function \n                            | Ok (estadoN, r) -> estadoN, Ok    r\n                            | Error m         -> estadoO, Error m\n        \n            let serialN2serialU (serEventoN: SerialEventoN) = serEventoN.serEventoU\n        \n            let serialU2TipoDatos (serEventoU: SerialEventoU) =\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(serEventoU.serEvento.nombre, serEventoU.serEvento.tipo)\n                    Eventos.datos     = serEventoU.serEvento.data\n                }\n        \n            let evento2TipoDatos (evento:Evento) =\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(case, tuple |> getTypeName)\n                    Eventos.datos     = data\n                }\n        \n            let separarEstado (modeloI:Modelo, eventoSerialN : SerialEventoN) oR =  \n                let modelo = oR |> Result.map fst |> Result.defaultValue modeloI\n                let resp   = oR |> Result.map snd\n                { modelo with nevento = eventoSerialN.nevento }, resp\n        \n            let ejecutarEventoSerial ev =\n                ev\n                |> serialN2serialU \n                |> serialU2TipoDatos\n                |> manejadorGenerico\n                >>= EA.tee (fst >> ObtenerEstado.guardarEstado ev.nevento)\n                |>> snd\n                |>  Rsl.absorbR\n        \n            let guardarEventoSerialU (serEventoU :  SerialEventoU) = \n                nuevoEvento\n                    serEventoU.usuario\n                    serEventoU.serEvento.nombre\n                    serEventoU.serEvento.json\n                    serEventoU.serEvento.tipo\n        \n            let serializarDataEvento (evento : DataEvento) =\n                let  name, ttype, obj = DiscUnion.caseTuple evento\n                let  tname            = ttype |> getTypeName\n                let  ser              = SerializadorEventos.obtenerSerializador tname\n                {   nombre            = name\n                    tipo              = tname\n                    json              = fst ser obj\n                    data              = obj\n                }\n        \n            let guardarEventoSerial  serEventoU =\n                guardarEventoSerialU serEventoU\n                |>> fun nevento  -> { nevento = nevento ; serEventoU = serEventoU }\n        \n            let serializarEvento (evento:Evento) =\n                evento.aliadoO \n                |> Option.map(fun (IdAliado usuario) -> { usuario = usuario ; serEvento  = serializarDataEvento evento.data })\n                |> Result.ofOption (fun () -> sprintf \"Aliado es Nulo para evento %A\" evento)\n                |> Rsl.ofResult\n        \n            let intentarEventoSerial ev =\n                serialU2TipoDatos ev\n                |>  manejadorGenerico\n                |>> snd\n                |>  Rsl.absorbR\n                |>> ignore\n        \n            let ejecutarEventoNuevo ev =\n                serializarEvento ev\n                >>= EA.tee intentarEventoSerial\n                >>= guardarEventoSerial\n                >>= fun inp ->\n                        ejecutarEventoSerial inp\n                        >>= EA.tee (fun out ->  enviarMensaje \"\" inp.serEventoU.usuario (sprintf \"%A\" out) \"\")\n        \n            let ejecutarDataEventoNuevo  claims de =\n                ObtenerEstado.obtenerAliado claims\n                |>> fun al ->\n                        {\n                            Evento.nevento = 0L\n                            Evento.aliadoO = Some al.id\n                            data           = de\n                        }\n                >>= ejecutarEventoNuevo\n        \n            let obtenerSubModelo (aliado:Aliado, modelo:Modelo) = \n                let buscar = Aliado.busqueda modelo.aliados\n                if aliado.datosPersonales.nombre1 = \"Administrador\" && aliado.datosPersonales.apellido1 = \"Supremo\" then modelo else\n                let subAliados = (if aliado.tipo = Master then buscar.descendientes else buscar.hijos) aliado\n                { modelo with \n                    idAliado = aliado.id\n                    aliados  = Array.append [| aliado |] subAliados \n                }\n        \n            let obtenerEstadoParaUsuario aid =\n                ObtenerEstado.obtenerAliadoEstado aid\n                |>> obtenerSubModelo\n        \n            let obtenerClaim claim claims =\n                claims \n                |>  Array.tryFind(fun (n,v) -> n = claim) \n                |>  Option.map snd\n        \n            let enviarBienvenida aid = \n                ObtenerEstado.obtenerAliado aid\n                >>= fun (aliado:Aliado) -> eff {\n                    for contacto in aliado.contactos do\n                        match contacto with\n                        | CorreoElectronico correo -> \n                            match correo.enviado with\n                            | None -> do! Correo.enviarBienvenida aliado correo\n                            |_-> ()\n                        | _ -> ()\n                }\n                \n            let crearRegistroNuevo (aid:IdAliado) claims (modelo:Modelo) = eff {\n                if  aid.Id    = \"admin\" || (modelo.aliados |> Array.exists (fun al -> al.id = aid)) then return None else\n                let datos     = \n                    { Default.value<DatosPersonales> with \n                        nombre1         = claims |> obtenerClaim \"given_name\"                                              |> Option.defaultValue \"\"\n                        apellido1       = claims |> obtenerClaim \"family_name\"                                             |> Option.defaultValue \"\"\n                        fechaNacimiento = claims |> obtenerClaim \"extension_DateOfBirth\" |> Option.bind ParseO.parseDateO2 |> Option.defaultValue System.DateTime.MinValue\n                    }\n                let correo    = \n                    { Default.value<CorreoElectronico> with \n                        email           = claims |> obtenerClaim \"emails\" |> Option.defaultValue \"\"\n                    }\n                let direccion    = \n                    { Default.value<Direccion> with \n                        linea1          = claims |> obtenerClaim \"streetAddress\" |> Option.defaultValue \"\"\n                        ciudad          = claims |> obtenerClaim \"city\"          |> Option.defaultValue \"\"\n                        estado          = claims |> obtenerClaim \"state\"         |> Option.bind Estado    .tryParse |> Option.defaultValue (OtroS      \"\")\n                        zonaPostal      = claims |> obtenerClaim \"postalCode\"    |> Option.bind ZonaPostal.tryParse |> Option.defaultValue (ZonaPostal \"\")\n                        pais            = claims |> obtenerClaim \"country\"       |> Option.bind Pais      .tryParse |> Option.defaultValue (OtroP      \"\")\n                        authorizeIdR    = Error \"\"\n                    }\n                let contactos = [| CorreoElectronico correo ; Direccion direccion |]\n                let referidoPor = \n                    claims \n                    |> obtenerClaim \"referidoPor\" \n                    |> Option.bind (function \"\" -> None | s -> Some s)\n                    |> Option.bind (fun ref -> modelo.aliados |> Seq.tryFind(fun padre -> padre.id.Id = ref))\n                    |> Option.map  (fun padre -> padre.id)\n                do! Log.logf \"referidoPor = %A\" referidoPor\n                //Correo.enviarBienvenida aliado // (**) mover afuera\n                return Some\n                    {\n                        Evento.nevento = 0L\n                        Evento.aliadoO = Some aid\n                        data           = DataEvento.RegistroNuevo(aid, datos, referidoPor, contactos)\n                    }\n            }\n        \n            let agregarUsuarioSiEsNuevo claims1 claims =\n                ObtenerEstado.obtenerEstado()\n                >>= crearRegistroNuevo claims1 claims        \n                |>  bindO ejecutarEventoNuevo                \n                |>  bindO (fun _ -> enviarBienvenida claims1)\n                |>> Option.iter             print\n        \n            let obtenerListaDocs claims =\n                ObtenerEstado.obtenerAliado claims\n                |>> fun al -> al.id\n                >>= obtenerListaDocs0\n        \n            let obtenerInfluyente (inf:string) =\n                ObtenerEstado.obtenerEstado()\n                |>> fun es -> \n                        let infO = Some (inf.Trim().ToLower())\n                        es.aliados \n                        |> Seq.tryFind (fun al -> al.influyente = infO )\n                        |> Result.ofOption (fun () -> sprintf \"Influyente no encontrado : %s\" inf)\n                |>  Rsl.absorbR\n        \n            let obtenerIdInfluyente inf =\n                obtenerInfluyente   inf\n                |>> fun al -> al.id.Id\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n        module Azure =\n            open System\n            open System.IO\n        //    open Microsoft.Azure\n        //    open Microsoft.Azure.Storage\n        //    //open Microsoft.Azure.Storage.Table\n        //    open Microsoft.Azure.Storage.Queue\n        //    open Microsoft.Azure.Storage.Blob\n        //    open Microsoft.Azure.Storage.Core\n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n            open Microsoft.WindowsAzure.Storage.Table\n        \n            let storageSetting      =  \"APPSETTING_AzureWebJobsStorage\"\n            let aliadosTableName    =  \"Aliados\"\n            let eventosTableName    =  \"Eventos\"\n            let mensajesTableName   =  \"Mensajes\"\n            let estadoTableName     =  \"Modelo\"\n            let transacTableName    =  \"Transacciones\"\n            let correosQueueName    =  \"correos\"\n            let mensajesQueueName   =  \"mensajes\"\n            let storageAccountE()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let storageAccountC()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let tableClientE   ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudTableClient()\n            let queueClientE   ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudQueueClient()\n            let blobClientE    ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudBlobClient ()\n            let fileClientE    ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudFileClient ()\n            let aliadosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(aliadosTableName )\n            let mensajesTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(mensajesTableName)\n            let eventosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(eventosTableName )\n            let estadoTableE   ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(estadoTableName  )\n            let transacTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(transacTableName )\n            let queueCorreosE  ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(correosQueueName )\n            let queueMensajesE ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(mensajesQueueName)\n        \n            type Correo = {\n                Subject       : string\n                Content       : string\n                CustomerEmail : string\n            }\n        \n            type Mensaje = {\n                remitente     : string\n                destinatario  : string\n                tema          : string\n                contenido     : string\n            }\n        \n            let enviarCorreoAzure (recipiente:string) (tema:string) (contenido:string)  = \n                {   Subject       = tema\n                    Content       = contenido \n                    CustomerEmail = recipiente\n                }\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage\n                |> (fun m -> queueCorreosE() >>= fun queueCorreos -> queueCorreos.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            let enviarMensaje (mensaje:Mensaje) = \n                mensaje\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage \n                |> (fun m -> queueMensajesE() >>= fun queueMensajes -> queueMensajes.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            type AliadoE(id, aliado: string) =\n                inherit TableEntity(partitionKey=\"Aliado\", rowKey=id)\n                new() = AliadoE(null, null)\n                member val Aliado = aliado with get, set\n        \n            type MensajeE(mensaje: Mensaje, id) =\n                inherit TableEntity(partitionKey= mensaje.destinatario, rowKey=id)\n                new(mensaje) = MensajeE(mensaje, System.Guid.NewGuid().ToString())\n                new() = MensajeE(  {    remitente     = \"\"\n                                        destinatario  = \"\"\n                                        tema          = \"\"\n                                        contenido     = \"\"\n                                    }  )\n                member val id           = id                    with get, set\n                member val Remitente    = mensaje.remitente     with get, set\n                member val Destinatario = mensaje.destinatario  with get, set\n                member val Tema         = mensaje.tema          with get, set\n                member val Contenido    = mensaje.contenido     with get, set\n        \n            type Transac = {\n                aid      : string\n                tid      : string\n                tipo     : string\n                fecha    : System.DateTime\n                monto100 : int\n                detalles : string\n            }\n        \n            type TransacE(transac: Transac) =\n                inherit TableEntity(partitionKey= transac.aid, rowKey=transac.tid)\n                new() = TransacE(  {    monto100 = 0\n                                        fecha    = System.DateTime.MinValue\n                                        aid      = \"\"\n                                        tid      = \"\"\n                                        tipo     = \"\"\n                                        detalles = \"\"\n                                    }  )\n                //member val aid      = transac.aid      with get, set\n                //member val tid      = transac.tid      with get, set\n                member val monto100 = transac.monto100 with get, set\n                member val fecha    = transac.fecha    with get, set\n                member val tipo     = transac.tipo     with get, set\n                member val detalles = transac.detalles with get, set\n        \n            type EstadoE(n:int64, estado: string) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"Estado\")\n                new() = EstadoE(0L, \"\")\n                member val nevento      = n      with get, set\n                member val estado       = estado with get, set\n        \n            type EstadoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"EstadoActual\")\n                new() = EstadoNE(0L)\n                member val nevento      = n      with get, set\n        \n            type EventoE(n:int64, usuario:string, nombre:string, evento:string, tipo:string) =\n                inherit TableEntity(partitionKey= \"Evento\", rowKey= sprintf \"%08d\" n)\n                new() = EventoE(0L, \"\", \"\", \"\", \"\")\n                member val nevento      = n       with get, set\n                member val usuario      = usuario with get, set\n                member val nombre       = nombre  with get, set\n                member val tipo         = tipo    with get, set\n                member val evento       = evento  with get, set\n        \n            type EventoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"Actual\", rowKey= \"Actual\")\n                new() = EventoNE(0L)\n                member val nevento      = n      with get, set\n        \n            let executeE      tbE  op = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteAsync      op |> Async.AwaitTask |> Asy.ofAsync\n            let executeQueryE tbE (op:TableQuery<_>) = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteQuerySegmentedAsync(op, null) |> Async.AwaitTask |> Asy.ofAsync\n        \n            let guardarAliado id contenido = \n                TableOperation.InsertOrReplace <| AliadoE(id, contenido)\n                |> executeE aliadosTableE\n        \n            let guardarMensaje mensaje =\n                TableOperation.InsertOrReplace <| MensajeE(mensaje)\n                |> executeE mensajesTableE\n        \n            let guardarTransac transac =\n                TableOperation.InsertOrReplace <| TransacE(transac)\n                |> executeE transacTableE\n        \n            let obtenerAliados() = \n                TableQuery<AliadoE>()\n                |>  executeQueryE aliadosTableE\n                |>> (Seq.map (fun al -> al.Aliado) >> Seq.toArray)\n        \n            let guardarEstado (n:int64) s =\n                let op1 = TableOperation.InsertOrReplace <| EstadoE( n, s)\n                let op2 = TableOperation.InsertOrReplace <| EstadoNE(n   )\n                executeE estadoTableE op1\n                >>= fun _ -> executeE estadoTableE op2\n        \n            let ultimoEstado() =\n                TableQuery<EstadoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"EstadoActual\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let obtenerEstado() =\n                TableQuery<EstadoE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Estado\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento, e.estado) )\n        \n            let ultimoEvento() = //obtenerTextoArchivo archivoUltimoEvento |> Option.bind ParseO.parseInt64O \n                TableQuery<EventoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"Actual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Actual\")\n                  ))\n                |> executeQueryE eventosTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let nuevoEvento (usuario:string) (nombre:string) (evento:string) (tipo:string) =\n                ultimoEvento()\n                |>> Option.defaultValue 0L\n                |>> (+) 1L\n                >>= fun nextEvento ->\n                    EventoE( nextEvento, usuario, nombre, evento, tipo)\n                    |>  TableOperation.InsertOrReplace\n                    |>  executeE eventosTableE\n                    |>> fun _ -> EventoNE(nextEvento   )\n                    |>> TableOperation.InsertOrReplace\n                    >>= executeE eventosTableE\n                    |>> fun _ -> nextEvento\n        \n            let getMimeO (name :string)=\n                match name.ToLower() with\n                | String.EndsWith \".pdf\"  _ -> Some \"application/pdf\"\n                | String.EndsWith \".rtf\"  _ -> Some \"application/rtf\"\n                | String.EndsWith \".pbm\"  _ -> Some \"image/x-portable-bitmap\"\n                | String.EndsWith \".bmp\"  _ -> Some \"image/bmp\"\n                | String.EndsWith \".gif\"  _ -> Some \"image/gif\"\n                | String.EndsWith \".tif\"  _\n                | String.EndsWith \".tiff\" _ -> Some \"image/tiff\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".jpe\"  _ \n                | String.EndsWith \".jpeg\" _ \n                | String.EndsWith \".jpg\"  _ -> Some \"image/jpeg\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".html\" _ -> Some \"text/html\"\n                | _-> None\n        \n            let obtenerListaDocs (IdAliado alid) =\n                blobClientE()\n                >>= fun bcli      -> \n                        bcli.GetContainerReference \"documentos\"\n                        |> fun container -> container.GetDirectoryReference  alid\n                        |> fun dir       -> dir      .ListBlobsSegmentedAsync   null |> Async.AwaitTask |> Asy.ofAsync\n                        |>> fun blobs     -> blobs.Results \n                        |>> Seq.choose (fun blob -> \n                            blob.Uri.GetComponents(UriComponents.Path, UriFormat.Unescaped) \n                            |> String.splitInTwoO (alid + \"/\")\n                            |> Option.map snd\n                            )\n                        |>> Seq.toArray\n        \n            let subirBlob fromFile toContainerName toFile =\n                blobClientE()\n                >>= fun bcli ->\n                        bcli                          .GetContainerReference toContainerName\n                        |>  fun container -> container.GetBlockBlobReference toFile\n                        |>  fun blob      -> blob     .UploadFromFileAsync   fromFile |> Async.AwaitTask |> Asy.ofAsync |>> fun () -> blob\n                        >>= fun blob      -> eff { \n                                match getMimeO toFile with\n                                | None -> ()\n                                |   Some mime ->    blob.Properties.ContentType <- mime\n                                                    do! blob.SetPropertiesAsync() |> Async.AwaitTask |> Asy.ofAsync\n                            }\n        \n            let obtenerPropiedadesBlob toContainerName toFile = eff {\n                let! bcli = blobClientE()\n                let  blob =\n                        bcli                         .GetContainerReference toContainerName\n                        |> fun container -> container.GetBlockBlobReference toFile\n                let! exists = blob.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some blob.Properties else None\n            }\n        \n            let obtenerPropiedadesArchivo shareName toFile = eff {\n                let! fcli = fileClientE   () \n                let  file =\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                let! exists = file.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some file.Properties else None\n            }\n        \n            let subirArchivo fromFile shareName toFile =\n                fileClientE   () \n                >>= fun fcli ->\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                        |> fun file  -> file .UploadFromFileAsync    fromFile |> Async.AwaitTask |> Asy.ofAsync\n        \n        \n        //    let setAmbiente() =\n        //        {\n        //            new IAmbiente with \n        //                member __.UltimoEvento      ()  = ultimoEvento()\n        //                member __.UltimoEstado      ()  = ultimoEstado()\n        //                member __.LeerTipos         ()  = [||]   \n        //                member __.LeerEventosTipos  ()  = [||]   \n        //                member __.NuevoEvento       (usuario:string) (nombre:string) (evento:string) (tipo:string) = nuevoEvento usuario nombre evento tipo\n        //                member __.LeerEventos       n   = AsyncResultM.errorMsgf \"ambienteAzure.LeerEventos not implemented\"\n        //                member __.GuardarEstado     n s = guardarEstado n s\n        //                member __.ObtenerEstado     ()  = obtenerEstado\n        //                member __.GuardarAliado     i s = guardarAliado i s\n        //                member __.ObtenerAliados    ()  = obtenerAliados\n        //                member __.NombreAmbiente    ()  = \"azure\"\n        //                member __.CarpetaRaiz       ()  = carpeta\n        //                member __.EnviarCorreo    r t c = enviarCorreoAzure r t c\n        //                member __.EnviarMensaje d r t c = enviarMensaje  { \n        //                                                        remitente     = d \n        //                                                        destinatario  = r \n        //                                                        tema          = t \n        //                                                        contenido     = c \n        //                                                    }\n        //                member __.ObtenerTransacciones      id = AsyncResultM.errorMsgf \"Ambiente.ObtenerTransacciones: not implemented\"\n        //                member __.ObtenerMensajes           id = AsyncResultM.errorMsgf \"Ambiente.ObtenerMensajes: not implemented\"\n        //                member __.ObtenerListaDocs          id = obtenerListaDocs id\n        //                member __.VariableAmbiente           v = System.Environment.GetEnvironmentVariable v\n        //                member __.Prepare                   () = Authorize.prepareAuthorizeNetEnvironment()\n        //        }\n        //\n        \n            let invokeE nameF (f:'a->Eff<'H, 'b>) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n                |> join\n        \n            let invokeR nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n        \n            let invokeVerboseR nameF (f:'a->'b) (p:'a) = eff {\n                try \n                    do! Log.logf \"invokeVerboseR: %s\" (nameF p)\n                    let r = f p \n                    do! Log.logf \"%s %A\" (nameF p) r\n                    return r\n                with e ->\n                    return!\n                        Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                        |> Rsl.ofResult\n            }\n        \n            let invokeL nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Log.logf \"%s %A\" (nameF p) |>> ignore \n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                    |> Rsl.ofResult\n        \n        [< AutoOpen >]\n        module AzureHandler =\n            open Authorize\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n            open Azure\n        \n            type AR<'V> = Eff<AzureReader,'V>\n            and  AzureReader(?environment : string) =\n                let prepareEnvironment env id transactionKey =\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.RunEnvironment         <- env\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.MerchantAuthentication <- \n                        new merchantAuthenticationType( name            = id\n                                                    ,   ItemElementName = ItemChoiceType.transactionKey\n                                                    ,   Item            = transactionKey )\n                let mutable environmentNameO = None\n                let prepararE = eff {\n                    let! env =  eff {\n                                    match environment with\n                                    | Some v -> return v.ToUpper()\n                                    |_       -> return! variableAmbienteE \"Authorize_Environment\"\n                                }\n                    let  environment, environmentName, idV, tranKeyV =\n                        match env with\n                        | \"P\" ->(   AuthorizeNet.Environment.PRODUCTION\n                                ,   \"PRODUCTION\"\n                                ,   \"Authorize_Id_Production\"          \n                                ,   \"Authorize_Transaction_Production\" \n                                )\n                        |_->    (   AuthorizeNet.Environment.SANDBOX\n                                ,   \"SANDBOX\"\n                                ,   \"Authorize_Id_Sandbox\"          \n                                ,   \"Authorize_Transaction_Sandbox\" \n                                )\n                    let! id      = variableAmbienteE idV\n                    let! tranKey = variableAmbienteE tranKeyV\n                    environmentNameO <- Some environmentName\n                    prepareEnvironment environment id tranKey\n                }\n                interface Reader.Reader<AzureReader> \n                interface Log.Log<string> \n                interface Rsl.Rsl<string>\n                interface Asy.Asy\n                interface VariableAmbienteI with \n                    member __.getVar          v  = System.Environment.GetEnvironmentVariable v\n                    member __.CarpetaRaiz     () = \".\"\n                interface Correo          .EmailI<AzureReader> with\n                    member __.SendEmail                        r t c = invokeE (fun _ -> \"SendEmail\"     ) (Azure.enviarCorreoAzure r t      ) c\n                interface ObtenerEstado   .EstadoI<AzureReader> with\n                    member __.UltimoEstado                        () = invokeE (fun _ -> \"UltimoEstado\"  )  Azure.ultimoEstado                 ()\n                    member __.GuardarAliado                     id s = invokeL (fun _ -> \"GuardarAliado\" ) (Azure.guardarAliado id  :_->AR<_>) s\n                    member __.GuardarEstado                      n s = invokeL (fun _ -> \"GuardarEstado\" ) (Azure.guardarEstado  n  :_->AR<_>) s\n                    member __.ObtenerEstado                       () = invokeE (fun _ -> \"ObtenerEstado\" )  Azure.obtenerEstado                ()\n                    member __.ObtenerAliados                      () = invokeE (fun _ -> \"ObtenerAliados\")  Azure.obtenerAliados               ()\n                interface ManejadorEventos.EventoI<AzureReader> with\n                    member __.NuevoEvento usuario nombre evento tipo = invokeE (fun _ -> \"NuevoEvento\"   ) (Azure.nuevoEvento   usuario nombre evento) tipo\n                    member __.UltimoEvento                        () = invokeE (fun _ -> \"UltimoEvento\"  )  Azure.ultimoEvento                 ()\n                    member __.EnviarMensaje                  d r t c = invokeE (fun _ -> \"EnviarMensaje\" )  Azure.enviarMensaje { \n                                                                                                                            remitente     = d \n                                                                                                                            destinatario  = r \n                                                                                                                            tema          = t \n                                                                                                                            contenido     = c \n                                                                                                                        }\n                    member __.ObtenerListaDocs                   ida = invokeE (fun _ -> \"ObtenerListaDocs\")  Azure.obtenerListaDocs ida\n                interface AuthorizeI<AzureReader> with\n                    member __.execute controller =  controller.Execute()\n                                                    controller.GetApiResponse()\n                    member __.prepare         () = if environmentNameO.IsNone then prepararE else rtn ()\n        \n            let reader = AzureReader()\n            let mutable logger : string -> unit = print\n        \n            let run   (eff:Eff<_,_>) = \n                eff\n                |> Reader.readerHandler reader\n                |> Log.loggerLogHandler logger\n                |> Rsl.rslHandler \n                |> Asy.asyncHandler\n                |> Eff.run<AzureReader,_>\n            let print eff = \n                run (eff |>> print)\n                |> Async.map \n                   (function\n                    | Ok ()   -> ()\n                    | Error m -> print m)\n        \n        \n        \n        module Rpc =\n            open WebSharper\n            open WebSharper.JavaScript\n        \n            [< JavaScript >]\n            let serverEndPoint = \n                lazy \n                    if IsClient then \n                        if JS.Window.Location.Protocol = \"http:\" \n                        then \"http://localhost:7071/api/\"\n                        else sprintf \"https://%s/api/\" JS.Window.Location.Host\n                    else     \n                        variableAmbienteE \"Website\" \n                        |>> sprintf \"https://%s/api/\"\n                        |>  AzureHandler.run\n                        |>  Async.RunSynchronously\n                        |>  Result.defaultValue \"https://aliados.prozper.com/api\"\n        \n            let obtenerUnions0 () =\n                ( DiscUnion.simple<Pais          >\n                , DiscUnion.simple<Estado        >\n                , DiscUnion.simple<TipoDireccion >\n                , DiscUnion.simple<TipoTelefono  >\n                , DiscUnion.simple<Genero        >\n                , DiscUnion.simple<TipoCuenta    >\n                , DiscUnion.simple<TipoTarjeta   >\n                , DiscUnion.simple<StatusAliado  >\n                , [| for m in System.Enum.GetValues(typeof<Mes>)                       do yield string m |]\n                , [| for i in System.DateTime.Now.Year..System.DateTime.Now.Year + 15  do yield        i |])\n        \n            open Azure\n            open AzureHandler\n        \n            type AR<'T> = Async<Result<'T, string>>\n        \n            let [< Rpc >] obtenerUnions                       () : AR<_> = invokeVerboseR(fun _ -> \"obtenerUnions\") obtenerUnions0 ()      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerIdInfluyente             codigo : AR<_> = ManejadorEventos.obtenerIdInfluyente      codigo         |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerEstadoParaUsuario aid           : AR<_> = ManejadorEventos.obtenerEstadoParaUsuario aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] actualizarSubscripcion   aid    idp    : AR<_> = Authorize.actualizarSubscripcion          aid     idp    |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] ejecutarDataEventoNuevo  aid    de     : AR<_> = ManejadorEventos.ejecutarDataEventoNuevo  aid     de     |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] agregarUsuarioSiEsNuevo  aid    claims : AR<_> = ManejadorEventos.agregarUsuarioSiEsNuevo  aid     claims |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerFormasDePagoId    aid           : AR<_> = Authorize.obtenerFormasDePagoId           aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] registrarTarjeta         aid    p      : AR<_> = Authorize.registrarTarjeta                aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] registrarCuenta          aid    p      : AR<_> = Authorize.registrarCuenta                 aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] validarFormaPago         aid    p      : AR<_> = Authorize.validarFormaPago                aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] borrarFormaPago          aid    p      : AR<_> = Authorize.borrarFormaPago                 aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerListaDocs         aid           : AR<_> = ManejadorEventos.obtenerListaDocs         aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] enviarCorreosInvitacion  aid (tm, ems) : AR<_> = Correo.enviarCorreosInvitacion          (tm, aid, ems)   |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerFormasDePagoPara         aids   : AR<_> = Authorize.obtenerFormasDePagoPara                 aids   |> AzureHandler.run// |> Async.rtn\n        \n        [<JavaScript>]\n        module Remoting =\n            open WebSharper.JavaScript\n        \n            let private originalProvider = WebSharper.Remoting.AjaxProvider\n        \n            let mutable getTokenOA = fun () -> async { return None } // ... get token from storage ...\n        \n            type CustomXhrProvider () =\n                interface WebSharper.Remoting.IAjaxProvider with\n                    member this.Async url headers data ok err = \n                        async {\n                            let! tokenO = getTokenOA()\n                            tokenO |> Option.iter (fun token -> JS.Set headers \"Authorization\" <| sprintf \"Bearer %s\" token)\n                            originalProvider.Async url headers data ok err\n                        } |> Async.Start\n                    member this.Sync url headers data =\n                            originalProvider.Sync url headers data\n                    \n            let installBearer getTokenOAF =\n                getTokenOA <-  getTokenOAF\n                WebSharper.Remoting.AjaxProvider <- CustomXhrProvider()\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n        \n        module AzureFunctions =\n            open Microsoft.Azure.WebJobs\n            open Microsoft.Azure.WebJobs.Extensions\n            open Microsoft.Azure.WebJobs.Extensions.Storage\n            open Microsoft.Azure.WebJobs.Extensions.Http\n            open Microsoft.Extensions.Logging\n            open Microsoft.AspNetCore.Http\n            open Microsoft.AspNetCore.Mvc\n            open Newtonsoft.Json\n            open System\n            open System.IO \n        \n            module RM = WebSharper.Core.Remoting\n        \n            [<FunctionName(\"keepAlive\")>]\n            let keepAlive([< TimerTrigger(\"0 */5 * * * *\") >] myTimer : TimerInfo, log : ILogger ) =\n                ()\n        \n            type MaxDepthJsonTextWriter(writer : TextWriter, maxDepth : int ) =\n                inherit JsonTextWriter(writer) \n                let mutable maxObservedDepth = 0\n                member this.CheckDepth() =\n                    maxObservedDepth <- Math.Max(maxObservedDepth, this.Top)\n                    if this.Top > int maxDepth then\n                        failwithf \"Depth %d Exceeds MaxDepth %A at path %A\" this.Top maxDepth this.Path\n                override this.WriteStartArray          () = base.WriteStartArray()           ; this.CheckDepth()\n                override this.WriteStartConstructor  name = base.WriteStartConstructor(name) ; this.CheckDepth()\n                override this.WriteStartObject         () = base.WriteStartObject()          ; this.CheckDepth()\n        \n            let splitAndSend n f name (txt:string) =\n                let rec loop (txt:string) =\n                    if txt.Length <= n then f txt else\n                    f txt.[0..n]\n                    loop txt.[n + 1..]\n                loop (name + \"<<<:\" + txt + \":>>>\")\n        \n            let serializeMaxDepth depth obj = \n                let settings = JsonSerializerSettings(ReferenceLoopHandling  = ReferenceLoopHandling.Ignore\n                                                    , MissingMemberHandling  = MissingMemberHandling.Ignore\n                                                    , Error                  = EventHandler<Serialization.ErrorEventArgs>(fun s a -> a.ErrorContext.Handled <- true)\n                                                    )\n                use writer      = new StringWriter()\n                use jsonWriter  = new MaxDepthJsonTextWriter(writer, depth)\n                JsonSerializer.Create(settings).Serialize(jsonWriter, obj)\n                writer.ToString()\n            \n        \n            [<FunctionName(\"rpc\")>]\n            let runRpc( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"rpc/rpc\")>] \n                        request     : HttpRequest\n                      , principal   : System.Security.Claims.ClaimsPrincipal \n                      , log         : ILogger  ) = \n                async {\n                    log.LogInformation \"runRpc: ENTERING v.014\"\n                    //serializeMaxDepth 13 request   |> splitAndSend 9999 log.LogInformation \"request\"\n                    //serializeMaxDepth 13 principal |> splitAndSend 9999 log.LogInformation \"principal\"\n                    //log.LogInformation(sprintf \"%d Headers:\" <| Seq.length request.Headers)\n                    //request.Headers |> Seq.collect (fun kvp -> kvp.Value |> Seq.map (fun v -> kvp.Key, v)) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    //log.LogInformation(sprintf \"%d real Claims:\" <| Seq.length principal.Claims)\n                    //principal.Claims |> Seq.map (fun kvp -> kvp.Type, kvp.Value) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    log.LogInformation \"runRpc: before Server.Create\"\n                    let  wsServer = RM.Server.Create WebSharper.Web.Shared.Metadata WebSharper.Web.Shared.Json\n                    log.LogInformation \"runRpc: after Server.Create\"\n                    let! body     = request.ReadAsStringAsync() |> Async.AwaitTask\n                    let  wsReq    = {\n                        RM.Request.Body    = body\n                        RM.Request.Headers = ParseO.tryParseWith request.Headers.TryGetValue >> Option.bind Seq.tryHead\n                    }\n                    log.LogInformation \"runRpc: before logger <-\"\n                    logger <- fun s -> log.LogInformation s\n                    log.LogInformation \"runRpc: before try\"\n                    try\n                        log.LogInformation \"runRpc: before HandleRequest v001\"\n                        let! wsResp   = wsServer.HandleRequest wsReq\n                        log.LogInformation (sprintf \"runRpc: after HandleRequest %s %s\" wsResp.ContentType wsResp.Content)\n                        return ContentResult(Content = wsResp.Content, ContentType = wsResp.ContentType)\n                    with e ->\n                        log.LogError (sprintf \"Exception: %A\" e)\n                        return failwithf \"Exception %A\" e\n                } |> Async.StartAsTask\n        \n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n        \n            //open Microsoft.Azure.Cosmos.Table\n            open Microsoft.AspNetCore.Http\n            open System.IO\n            open Microsoft.AspNetCore.Mvc\n        \n            [<FunctionName(\"subir\")>]\n            let subirDocumentos([<HttpTrigger(AuthorizationLevel.Anonymous, \"post\"   , Route      = \"subir/{id}/{filename}\")>] req   : HttpRequest\n                              , [<Blob(\"documentos/{id}/{filename}\", System.IO.FileAccess.Write, Connection = \"AzureWebJobsStorage\"  )>] writer: Stream \n                              , log     : ILogger\n                              , id      : string\n                              , filename: string ) = \n              async {\n                    log.LogInformation <| sprintf \"subiendo documento %d %s\" req.Form.Files.Count filename\n                    if req.Form.Files.Count <> 1 then\n                        log.LogWarning \"no se encontro el documento\"\n                        return ContentResult(Content = \"no se encontro el documento\", ContentType = \"text/plain\")\n                    else\n                    let  file      = req.Form.Files |> Seq.head\n                    do!  file.CopyToAsync writer |> Async.AwaitTask\n                    eff {\n                        try\n                            do!  Asy.ofAsync <| Async.Sleep 500\n                            let! blobClient = Azure.blobClientE()\n                            let  container  = blobClient.GetContainerReference \"documentos\"\n                            let  dir        = container.GetDirectoryReference id\n                            let  blobRef    = dir.GetBlockBlobReference filename\n                            Azure.getMimeO filename\n                            |> Option.iter (fun mime -> \n                                blobRef.Properties.ContentType <- mime\n                                blobRef.SetPropertiesAsync() |> Async.AwaitTask |> Async.Start\n                            )\n                        with e -> do! Rsl.ofResult <| Error (sprintf \"%A\" e)\n                    } |> AzureHandler.run |> Async.map (function | Error m -> printfn \"%A\" m |_-> ()) |> Async.Start\n                    return ContentResult(Content = \"Documento subido!\", ContentType = \"text/plain\")\n              } |> Async.StartAsTask\n        \n            [<FunctionName(\"passMessages\")>]\n            let passMessages( [<QueueTrigger(\"mensajes\", Connection = \"AzureWebJobsStorage\")>]  \n                    mensaje: Azure.Mensaje, log: ILogger) = \n                async {\n                    log.LogInformation (sprintf \"guardarMensaje %A (ignorando) \" mensaje)\n                    //let! v = AmbienteAzure.guardarMensaje mensaje\n                    //let! next = AmbienteAzure.queueMensajes.PeekMessageAsync() |> Async.AwaitTask\n                    //if isNull next then \n                        //log.LogInformation <| sprintf \"ambiente: %s\" (ambiente.NombreAmbiente())\n                        ////let! res = Acciones.ejecutarAcciones()\n                        ////log.LogInformation <| sprintf \"Acciones ejecutadas %A\" res\n                    ()\n                } |> Async.RunSynchronously\n        \n            [<FunctionName(\"path\")>]\n            let path( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"{anything}\")>] \n                        request     : HttpRequest\n                      , log         : ILogger ) =\n                //log.LogInformation(sprintf \"isMimeMultipart: %A\" <| request.Content.IsMimeMultipartContent())          \n                request.Headers |> Seq.iter (fun h -> log.LogInformation(sprintf \"header: %s %A\" h.Key (h.Value |> String.concat \"; \")) )\n                let uid    = ParseO.tryParseWith request.Headers.TryGetValue \"idAliado\" |> Option.bind Seq.tryHead |> Option.defaultValue \"\"\n                let claims = [| \"http://schemas.microsoft.com/identity/claims/objectidentifier\", uid |]\n                claims |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                ContentResult(Content = \"Hello\", ContentType = \"text/plain\")\n        \n        //#nowarn \"52\"\n        //#nowarn \"1182\"\n        //#nowarn \"1178\"\n        \n        //#define NOFRAMEWORK --noframework\n        //#define WEBSHARPER\n        \n        //// to generate function.json (s):\n        //// D:\\Abe\\CIPHERWorkspace\\AzureFunctions\\packages\\Microsoft.NET.Sdk.Functions\\tools\\net46\\Microsoft.NET.Sdk.Functions.Generator.exe bin\\ProzperServer.dll .\n        \n        //// to save function.json:\n        //// PUT https://management.azure.com/subscriptions/fd33982d-5249-477d-9587-b0f758dd6fe9/resourceGroups/Prozper/providers/Microsoft.Web/sites/Prozper0/functions/%s?api-version=2018-02-01\n        //// {\n        ////       \"properties\": {\n        ////         \"config\": %s\n        //// }\n        \n        \n        "],
"names": [],
"mappings": "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"
}
