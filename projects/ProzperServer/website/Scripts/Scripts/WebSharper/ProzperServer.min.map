{
"version": 3,
"sourceRoot": "Source",
"sources": ["ProzperServer/ProzperServer.fs"],
"sourcesContent": ["#nowarn \"3242\"\n#nowarn \"52\"\n#nowarn \"1182\"\n#nowarn \"1178\"\n////-d:FSharpStation1561191553159 -d:NETSTANDARD20 -d:NOFRAMEWORK --noframework -d:TEE -d:WEBSHARPER\n////#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/projects/ProzperServer\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.IdentityModel.Tokens\\lib\\net461\\Microsoft.IdentityModel.Tokens.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Protocols\\lib\\net461\\Microsoft.IdentityModel.Protocols.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Protocols.OpenIdConnect\\lib\\net461\\Microsoft.IdentityModel.Protocols.OpenIdConnect.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Logging\\lib\\net461\\Microsoft.IdentityModel.Logging.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.JsonWebTokens\\lib\\net461\\Microsoft.IdentityModel.JsonWebTokens.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Configuration.ConfigurationManager/lib/net461/System.Configuration.ConfigurationManager.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Cryptography.ProtectedData/lib/net461/System.Security.Cryptography.ProtectedData.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Permissions/lib/net461/System.Security.Permissions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.AccessControl/lib/net461/System.Security.AccessControl.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Buffers/lib/netstandard1.1/System.Buffers.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Numerics.Vectors/lib/net46/System.Numerics.Vectors.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Runtime.CompilerServices.Unsafe/lib/netstandard1.0/System.Runtime.CompilerServices.Unsafe.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Principal.Windows/lib/net461/System.Security.Principal.Windows.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Memory/lib/netstandard1.1/System.Memory.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages\\test2\\System.IdentityModel.Tokens.Jwt\\lib\\net461\\System.IdentityModel.Tokens.Jwt.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n//#nowarn \"3242\"\n//#nowarn \"52\"\n//#nowarn \"1182\"\n//#nowarn \"1178\"\n/// Root namespace for all code\n//#define FSharpStation1561191553159\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if !NETSTANDARD20\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n    \n    #if WEBSHARPER\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    #endif\n    #endif\n    //#define NOFRAMEWORK --noframework\n    \n    #if NETSTANDARD20\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"  \n    \n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n    \n    #if WEBSHARPER\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n    #endif\n    #endif\n    #if WEBSHARPER\n    //#nowarn \"3242\" \n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            inherit System.Attribute()\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            inherit System.Attribute()\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            inherit System.Attribute()\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library = \n            let Error = Result.Error\n        \n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            //#define TEE\n            \n            let [< Inline \"new Date(0).getTime()\" >] Utc1970_01_01                 = System.DateTime(1970,1,1,0,0,0,System.DateTimeKind.Utc)\n            let [< Inline \"$d\"                    >] date2Long (d:System.DateTime) = d.Subtract(Utc1970_01_01).Ticks / 10000L\n            let [< Inline \"$l\"                    >] long2Date (l:int64          ) = Utc1970_01_01.Add(System.TimeSpan(l * 10000L) )\n            \n            \n            (* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\n            module IDict =\n            #if WEBSHARPER\n                [< Inline >]\n            #endif\n                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            *)\n            module Dict =\n                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            \n            module LDict =\n                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n                let [<Inline>] inline tryGetValue fitem key  dict =\n                    if containsKey key dict then Some (fitem key)\n                    else None\n            \n            \n            module Memoize =\n            \n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )\n                    (checkO, getOrAdd), cache.Clear\n            \n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )\n            \n                /// Memoizes function f using the provided cache\n                /// getCache() returns 1 function:\n                ///    getOrAdd: ('p->('p->'v)->'v) \n                [< Inline >]\n                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =\n                    fun p -> getOrAdd p f\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let (check, getOrAdd), clear = getStore()\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, clear\n            \n                /// Memoizes the function f using the provided Dictionary\n                [<Inline>]\n                let memoizeWithDict dict f =\n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF\n            \n                /// Memoizes the function f and returns Dictionary\n                [<Inline>]\n                let memoizeDict f =\n                    let dict = System.Collections.Generic.Dictionary<_, _>() \n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, dict\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    let ofOption vO = \n                        match vO with\n                        | Some v -> Seq.singleton v\n                        | None   -> Seq.empty\n                \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let errorf fmt = Printf.ksprintf Error fmt\n                \n                    let rtn                          = Ok\n                    let join                       r = Result.bind id r\n                    let flatten                    r = Result.bind id r\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bind (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bind f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                /// Based on Nick Palladino's https://github.com/palladin/Eff\n                \n                [< AutoOpen >]\n                module Eff =\n                    type Effect  = abstract Extend : (Effect -> Effect) -> Effect\n                \n                    type Eff<'H, 'a> = Eff of (('a -> Effect) -> Effect) \n                        with  member this.Create = match this with Eff create -> create\n                \n                    let inline rtn  v : Eff<'H, 'a> = Eff (fun k -> k v)\n                    let bind  (f: 'a -> Eff<'H, 'b>) (effA: Eff<'H, 'a>) : Eff<'H, 'b> = \n                                        Eff (fun kb -> \n                                                let (Eff effKa) = effA\n                                                effKa (fun a -> \n                                                    let (Eff effKb) = f a\n                                                    effKb kb\n                                                )\n                                            )\n                    let inline map   f  m  = bind (f >> rtn) m\n                    let inline apply fR vR = fR |> bind (fun f -> map f vR)\n                \n                    type Done<'a>(v : 'a) =\n                        member self.Value = v\n                        interface Effect with member self.Extend(_) : Effect = self :> _\n                \n                    let done'  (v : 'a) : Effect = new Done<'a>(v) :> _ \n                    //let return'(v : 'a) : Eff<'H, 'c> = Eff( fun _ -> done' v )\n                    let return' v = Eff( fun _ -> done' v )\n                \n                    let run<'H, 'a> (eff: Eff<'H, 'a>) : 'a =\n                        match eff.Create done' with\n                        | :? Done<'a> as done' -> done'.Value\n                        | v                    -> failwithf \"Unhandled effect %A\" v\n                \n                    let inline runResult<'H, 'a> eff = \n                        try run<'H, 'a> eff |> Ok\n                        with e -> Error(e.ToString())\n                \n                \n                    let inline ( <*> ) f v   = apply f v\n                    let inline ( |>> ) v f   = map   f v\n                    let inline ( >>= ) v f   = bind  f v\n                    let inline ( >-> ) f g v = f v |>> g\n                    let inline ( >=> ) f g v = f v >>= g\n                    \n                    #if TEE\n                    let inline ( |>>!) v f   = map   (tee f                       ) v\n                    let inline ( >>=!) v f   = bind  (fun w -> f w |>> fun () -> w) v\n                    #endif\n                    \n                    let inline join m = m |> bind id\n                    \n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |>> Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)\n                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)\n                    \n                    let inline bindO (f:'a->Eff<'H,'b>) (ef:Eff<'H,'a option>) = bind (Option.map f >> insertO) ef\n                    let rec whileLoop cond fEf =\n                        if   cond () \n                        then fEf  () |> bind (fun () -> whileLoop cond fEf)\n                        else rtn  ()\n                    \n                    \n                    type EffBuilder<'H>() =\n                        member __.ReturnFrom            vEf        : Eff<'H, _   > =           vEf\n                        member __.Return                v          : Eff<'H, _   > = rtn       v  \n                        member __.Zero                  ()         : Eff<'H, unit> = rtn       () \n                        member __.Bind                 (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Combine              (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Delay                       fEf                  = fEf\n                        member __.Run                         fEf  : Eff<'H, _   > = rtn () |> bind fEf\n                        member this.TryWith   (body, handler     ) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                        member this.TryFinally(body, compensation) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                        member this.Using     (disposable, body  ) : Eff<'H,_> = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                    let body' = fun () -> body disposable\n                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                        member __.While   (guard , fEf) : Eff<'H, unit> = whileLoop guard fEf \n                        member th.For  (s: 'a seq, fEf) : Eff<'H, unit> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fEf enum.Current)))\n                    \n                    let eff<'H> = EffBuilder<'H>()\n                    \n                    //type EffBuilder<'H>() =\n                    //    member self.Zero      (                 ) = rtn ()\n                    //    member self.Return    (v   :         'A ) = rtn v\n                    //    member self.ReturnFrom eff                = eff\n                    //    member self.Bind      (eff, f           ) = bind f eff\n                    //    member self.Combine   (first, second    ) = bind (fun () -> second) first\n                    //    member __.Combine   (vEf,  fEf) : Eff<'H  , 'm> = bind fEf  vEf\n                    //    member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)\n                    ////    member inline __.Delay       f                  = f\n                    //    member __.While(guard, body) =\n                    //        let rec whileLoop guard body =\n                    //            if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    //            else rtn   ()\n                    //        whileLoop guard body\n                    //    member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                    //    member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                    //    member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                    //                let body' = fun () -> body disposable\n                    //                this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                    //    member this.For(sequence:seq<_>, body) =\n                    //        this.Using(sequence.GetEnumerator(),fun enum -> \n                    //            this.While(enum.MoveNext, \n                    //                fun () -> this.Delay(fun () -> body enum.Current)))\n                    //\n                    //\n                    //let eff<'H> = new EffBuilder<'H>()\n                    \n                    //type EA<'H, 'a, 'b> = 'a -> Eff<'H, 'b>\n                    /// Equal to (|>) \n                    //let (>|>) (ea:EA<_,_,_>) f : EA<_,_,_> = ea |> f\n                    /// Equal to (>>)\n                    //let (>>>) = (>>)\n                    \n                    module EA =\n                        let tee (f: 'a -> Eff<'H, unit>) : 'a -> Eff<'H, 'a> = (fun v -> f v |> map (fun () -> v) )\n                    \n                    //    let mapOutput  f (ea: EA<_,_, _>) : EA<_,_,          _   > = ea >> (bind (f >> rtn) )\n                    //    let bindOutput(f: EA<_,_, _>) (ea: EA<_,_, _>) : EA<_,_, _> = ea >> (bind  f  )\n                    //    let mapBoth    f (ea: EA<_,_, _>) : EA<_,_,          _   > = fun i -> i |> mapOutput (f i) ea\n                    //    let bindBoth   f (ea: EA<_,_, _>) : EA<_,_,          _   > = mapBoth f  ea |> bindOutput id\n                    //\n                    //    let mapO         (ea: EA<_,_, _>) : EA<_,_,          _   > = Option.map ea >> insertO\n                    //\n                    //    let mapFst     f (a, b) = (f a,   b)\n                    //    let mapSnd     f (a, b) = (  a, f b)\n                    //\n                    //    let bindFst    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fa = f a\n                    //        return (fa, b)\n                    //    }\n                    //\n                    //    let bindSnd    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fb = f b\n                    //        return (a, fb)\n                    //    }\n                    //\n                    //    let lift    f : EA<_,_,_> = f >> rtn\n                    //    let pairWith v ea : EA<_,_,_> =\n                    //        ea\n                    //        >-> fun fst -> fst, v\n                    //\n                    //    let getResult ea:EA<_,_,_> = ea >-> Ok\n                    \n                    \n                    module Reader =\n                        type Reader<'E> = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type Ask<'E>(k : 'E -> Effect) =\n                            member self.K = k\n                            interface Effect with\n                                member self.Extend extension : Effect = new Ask<'E>(k >> extension) :> _\n                    \n                        let ask() : Eff<'H, 'E> when 'H :> Reader<'E> = Eff (fun k -> Ask(k) :> _ )\n                    \n                        let readerHandler<'E, 'H, 'a when 'H :> Reader<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = \n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? Ask<'E>  as ask   -> ask.K env          |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        let readerFun f = ask() |> map f \n                    module Log = \n                        type Log< 'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log1<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log2<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                    \n                        type LogEntry<'L>(v : 'L, k : unit -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect with\n                                member self.Extend extension  : Effect = new LogEntry<'L>(v, k >> extension) :> _\n                    \n                        let log (s:'L)  : Eff<'H, unit> when 'H :> #Log< 'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let logf fmt = Printf.ksprintf log fmt\n                        let log1 (s:'L) : Eff<'H, unit> when 'H :> #Log1<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let log2 (s:'L) : Eff<'H, unit> when 'H :> #Log2<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                    \n                        let pureLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = \n                            let rec loop (exitK:('a * list<'L>) -> Effect) (ls: list<'L>) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> (done'.Value, ls)  |>       exitK\n                                | :? LogEntry<'L> as log   -> log.K ()           |>  loop exitK (log.Value :: ls)  \n                                | effect                   -> effect.Extend         (loop exitK ls               )\n                            Eff (fun exitK                 -> eff.Create done'   |>  loop exitK []               )\n                    \n                    \n                        let consoleLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let loggerLogHandler<'L, 'H, 'a when 'H :> Log<'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> logger log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let consoleLogHandler1<'L, 'H, 'a when 'H :> Log1<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log1: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                    module Rsl = \n                    \n                    \n                        type Rsl<'M> = interface end\n                        \n                        type IRsl<'M> = abstract Value : 'M\n                    \n                        type Fail<'a,'M>(v : 'M, k : 'a -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect   with member __.Extend extension : Effect = new Fail<'a,'M>(v, k >> extension) :> _\n                            interface IRsl<'M> with member __.Value = v\n                    \n                        let fail (s:'M) : Eff<'H, _> when 'H :> #Rsl<'M> = Eff (fun k -> new Fail<_,_>(s, k) :> _)\n                        let failf fmt = Printf.ksprintf fail fmt\n                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {\n                            match res with\n                            | Ok    v   ->  return v\n                            | Error msg ->  let! m = fail msg\n                                            return failwith \"this code should be unreachable\"\n                        }\n                        \n                        let rslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = \n                            let rec loop (exitK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function\n                                | :? Done<    'A> as done' -> Ok    done'.Value |>       exitK\n                                | :? IRsl<    'M> as fail  -> Error fail .Value |>       exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'  |>  loop exitK)\n                    \n                        let inline getResult   v                = v     |> rslHandler\n                        let inline absorbR     vvEf             = vvEf  |> bind ofResult\n                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Asy = \n                        type Asy = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type AsynG =\n                            abstract RunSync      : unit               -> Effect\n                            abstract RunAsync<'a> : (Effect -> Effect) -> Effect\n                    \n                        [< Inline \"console.log('RunSynch Not implemented in JavaSacript')\" >]\n                        let runSynch v = Async.RunSynchronously v\n                    \n                        type Asyn<'v>(v : Async<'v>, k : ('v -> Effect) ) =\n                            member __.Value = v\n                            member __.K     = k\n                            interface Effect with member __.Extend   extension = new Asyn<_>(v, k >> extension) :> _\n                            interface AsynG  with \n                                member __.RunSync  ()        = runSynch v |> k\n                                member __.RunAsync<'a> exitK = done' (v |> Async.bind (fun v -> k v |> exitK :?> Done<Async<'a>> |> fun don -> don.Value ) )\n                    \n                        let inline ofAsync (v:Async<'a>) : Eff<'H, 'a> when 'H :> Asy= Eff (fun k -> new Asyn<'a>(v, k) :> _)\n                    \n                        /// This handler uses RunSynchronously to resolve Asyncs\n                        let syncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK:'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? AsynG    as asy   -> asy.RunSync()      |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        /// this should be the last handler before Eff.run\n                        let asyncHandler0<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            let rec loop (exitK:(Async<'a>) -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value |> async.Return |>      exitK\n                                | :? AsynG    as asy   -> asy.RunAsync<'a>              (loop exitK)\n                                | effect               -> effect.Extend                 (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'            |> loop exitK)\n                    \n                        let asyncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            Async.rtn () \n                            |>  ofAsync \n                            >>= fun () -> eff \n                            |>  asyncHandler0\n                    \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = if n < 0 \n                                                  then this.Substring2(0, this.Length + n)\n                                                  else this.Substring2(0, n              )\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n                member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n                let thousands n =\n                    let v = n.ToString()\n                    let r = v.Length % 3 \n                    let s = if r = 0 then 3 else r\n                    [   yield v.[0.. s - 1]\n                        for i in 0..(v.Length - s)/ 3 - 1 do\n                            yield v.[i * 3 + s .. i * 3 + s + 2]\n                    ] |> String.concat \",\"\n            \n            let mapFst     (f: 'a->'c) (a:'a, b:'b) = (f a,   b)\n            let mapSnd     (f: 'b->'c) (a:'a, b:'b) = (  a, f b)\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n            \n            \n                /// Javascript adds time zone information when parsing a date and that can change the result\n                let parseDateO2  = (fun s -> s + \"T00:00:00\") >> tryParseWith System.DateTime.TryParse\n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseInt64O  = tryParseWith System.Int64   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Int64 |_|) = parseInt64O\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            module Serializer =\n                open System\n            \n                type JsonIntermediate = {\n                    tryFloat    : unit   ->  float                option\n                    tryInt      : unit   ->  int64                option\n                    tryString   : unit   ->  string               option\n                    tryBool     : unit   ->  bool                 option\n                    tryArray    : unit   -> (JsonIntermediate []) option\n                    tryField    : string ->  JsonIntermediate     option\n                    isObject    : unit   ->  bool\n                    isNull      : unit   ->  bool\n                }\n            \n                type SerS<'T> = ('T                 -> string   )        //      Serialization function\n                type SerD<'T> = (JsonIntermediate   -> 'T option)        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>                      // both Serialization functions\n            \n                let serialize (ser: Ser<_>) v = fst ser v\n                let (|Field|_|) field j = j.tryField field\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n            \n                let toJsonString (v:string) =\n                    seq {\n                        yield '\"'\n                        if String.IsNullOrEmpty v |> not then\n                            for i = 0 to v.Length - 1 do\n                                let c = v.[i]\n                                let ci = int c\n                                if ci >= 0 && ci <= 7 || ci = 11 || ci >= 14 && ci <= 31 then\n                                    yield! sprintf \"\\\\u%04x\" ci\n                                else \n                                match c with\n                                | '\\b' -> yield! \"\\\\b\"\n                                | '\\t' -> yield! \"\\\\t\"\n                                | '\\n' -> yield! \"\\\\n\"\n                                | '\\f' -> yield! \"\\\\f\"\n                                | '\\r' -> yield! \"\\\\r\"\n                                | '\"'  -> yield! \"\\\\\\\"\"\n                                | '\\\\' -> yield! \"\\\\\\\\\"\n                                | _    -> yield c\n                        yield '\"'\n                    } |> Seq.toArray|> String\n            \n                let serString : Ser<string  > = toJsonString          , (fun j -> j.tryString()                         )\n                let serFloat  : Ser<float   > = sprintU               , (fun j -> j.tryFloat ()                         )\n                let serInt    : Ser<int     > = sprintU               , (fun j -> j.tryInt   () |> Option.map int       )\n                let serInt64  : Ser<int64   > = sprintf \"%d\"          , (fun j -> j.tryInt   ()                         )\n                let serBool   : Ser<bool    > = sprintU               , (fun j -> j.tryBool  ()                         )\n                let serDate   : Ser<DateTime> = (date2Long >> sprintU), (fun j -> j.tryInt   () |> Option.map long2Date )\n            \n                let [< Inline >] inline serId  (get: 'a -> System.Guid) (set:System.Guid -> 'a) (print: 'a->string) : Ser<'a> =\n                    let s               = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ              = sprintf \"%A\" s\n                    let serialize   gid = get gid |> string |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize j   = j.tryField s \n                                          |> Option.bind (fun jf -> jf.tryString() ) \n                                          |> Option.bind ParseO.parseGuidO \n                                          |> Option.map  set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc j -> deser j |> Option.map (fun v -> set v rc) ) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n                    if isNull (init :> obj) then failwith \"Initial record is null\"\n                    let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize j   = fields |> Seq.fold (fun dim (n, _ser,  deser) -> j.tryField n |> Option.bind (deser dim) |> Option.defaultValue dim)   init |> Some\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.ofArray)\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser))                          )\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\"              ), (fun j -> (if j.isNull() then None else              snd ser j)|> Some                  )\n                let serDup(serFst,serSnd): Ser<'a * 'b    > = (fun (f,s  ) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s) ), (fun j -> j.tryArray () \n                                                                                                                                            |> function \n                                                                                                                                                | Some [| j1 ; j2 |] -> match snd serFst j1, snd serSnd j2 with\n                                                                                                                                                                        | Some f, Some s -> Some(f, s) |_->None\n                                                                                                                                                | _ -> None )\n                let serTrp(sF,sS,sT)      : Ser<'a *'b*'c > = (fun (f,s,t) -> sprintf \"[%s, %s, %s]\" (fst sF f) (fst sS s)  (fst sT t)) , (fun j -> j.tryArray () \n                                                                                                                                                    |> function \n                                                                                                                                                        | Some [| j1 ;j2; j3|]   -> match snd sF j1, snd sS j2, snd sT j3 with\n                                                                                                                                                                                    | Some f, Some s, Some t -> Some(f, s, t) |_-> None\n                                                                                                                                                        | _ -> None ) \n                let serMap serKey serElm : Ser<Map<'k, 'e>> =   serDup(serKey, serElm)\n                                                                |> serSeq \n                                                                |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Option.map Map) )\n            \n            \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            let rec getNamespace (t:System.Type) =\n                match t.DeclaringType with\n                | null -> match t.Namespace with null -> \"\" | ns -> ns + \".\"\n                | dt   -> getNamespace dt + dt.Name + \".\"\n            \n            let rec getTypeName (t:System.Type) =\n                if t.IsArray then getTypeName (t.GetElementType()) + \"[]\" else\n                let ns    = getNamespace t\n                let name  = if   t.Name = \"FSharpOption`1\"                then \"Option\"\n                            elif t.Name = \"FSharpList`1\"                  then \"List\"\n                            elif ns     = \"Microsoft.FSharp.Core.\"\n                              || ns     = \"Microsoft.FSharp.Collections.\" then t.Name   \n                            else  ns + t.Name\n                let name2 = name.Split('`').[0]\n                let parms = t.GenericTypeArguments |> Seq.map getTypeName |> String.concat \",\"\n                if parms = \"\" then name2 else sprintf \"%s<%s>\" name2 parms\n            \n            module DiscUnion =\n                open FSharp.Reflection\n            \n                let simple<'U> =\n                    FSharpType.GetUnionCases typeof<'U>\n                    |> Seq.filter (fun c -> c.GetFields() |> Seq.isEmpty )\n                    |> Seq.map (fun c -> c.Name)\n                    |> Seq.toArray\n            \n                let caseTuple (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType)\n                    if types.Length = 1 then c.Name, types.[0], vs.[0] else\n                    let ttype = FSharpType.MakeTupleType(types)\n                    c.Name, ttype, FSharpValue.MakeTuple(vs, ttype)\n            \n                let caseArray (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType.FullName)\n                    c.Name, Array.zip types vs\n            \n                let caseInfos<'T>            = FSharpType.GetUnionCases typeof<'T>\n                let caseInfo< 'T> (s:string) = caseInfos<'T> |> Seq.find (fun c -> c.Name = s)\n            \n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n            module Serializer =\n                open Serializer\n                open FSharp.Data\n            \n                let rec getJsonIntermediate df di ds db da (j:JsonValue) : JsonIntermediate =\n                    let jsonInt = getJsonIntermediate df di ds db da\n                    {\n                        tryFloat    = fun () -> (match j with JsonValue.Float   v ->       v |> Some | JsonValue.Number v -> float v |> Some    |_-> None) |> Option.orElseWith df\n                        tryInt      = fun () -> (match j with JsonValue.Float   v -> int64 v |> Some | JsonValue.Number v -> int64 v |> Some    |_-> None) |> Option.orElseWith di\n                        tryString   = fun () -> (match j with JsonValue.String  v ->       v |> Some                                            |_-> None) |> Option.orElseWith ds\n                        tryBool     = fun () -> (match j with JsonValue.Boolean v ->       v |> Some                                            |_-> None) |> Option.orElseWith db\n                        tryArray    = fun () -> (match j with JsonValue.Array   v ->       v |> Array.map jsonInt |> Some                       |_-> None) |> Option.orElseWith (fun () -> da  jsonInt   )\n                        tryField    = fun fl -> j.TryGetProperty fl |> Option.map jsonInt                                                                 \n                        isObject    = fun () -> (match j with JsonValue.Record  _ ->       true |_-> false)\n                        isNull      = fun () -> (match j with JsonValue.Null      ->       true |_-> false)\n                    }\n            \n            \n                let deserialize df di ds db da (ser: Serializer.Ser<_>) js = \n                    JsonValue.TryParse js //|>! print\n                    |> Option.map  (getJsonIntermediate df di ds db da)\n                    |> Option.bind (snd ser)\n            \n                let tryDeserialize ser = \n                    deserialize\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        ser\n            \n                let deserializeWithDefs ser = \n                    deserialize\n                        (fun _   -> Some 0.0                          )\n                        (fun _   -> Some 0L                           )\n                        (fun _   -> Some \"\"                           )\n                        (fun _   -> Some false                        )\n                        (fun _   -> Some [||]                         )\n                        ser\n            \n                let deserializeWithFail ser = \n                    deserialize\n                        (fun _   -> failwith  \"Error expecting float\"    )\n                        (fun _   -> failwith  \"Error expecting int\"      )\n                        (fun _   -> failwith  \"Error expecting string\"   )\n                        (fun _   -> failwith  \"Error expecting bool\"     )\n                        (fun _   -> failwith  \"Error expecting array\"    )\n                        ser\n            \n                open FSharp.Reflection\n            \n                let inline serObj ((ser, deser):Ser<'T>) : string * Ser<obj> = typeof<'T> |> getTypeName, (unbox >> ser, deser >> Option.map box)\n            \n                let serDU<'DU when 'DU : equality> (sers : (string * Ser<obj>) seq) =\n                    let cases  = FSharpType.GetUnionCases             typeof<'DU>\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType  |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (typeof<'DU> |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = box<'DU> >> FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case >> unbox<'DU>\n                                let serC (v:'DU) =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = box<'DU> >> FSharpValue.PreComputeUnionTagReader typeof<'DU> >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.tryPick(fun case -> match j with Field case.Name _ -> Some case |_-> None) |> Option.defaultWith (fun () -> failwithf \"Could not find DU element %A\" j)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n            \n                let serDUt (sers : (string * Ser<obj>) seq) (ttype:System.Type) =\n                    let cases  = FSharpType.GetUnionCases ttype\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (ttype |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case\n                                let serC v =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = FSharpValue.PreComputeUnionTagReader ttype >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.pick(fun case -> match j with Field case.Name _ -> Some case |_-> None)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n                    \n            module Default =\n                open FSharp.Reflection\n            \n                let defaults vs = vs |> Seq.map (fun v -> v.GetType().FullName, v ) |> dict\n            \n                let defs = \n                    defaults [\n                        box 0\n                        box 0L\n                        box 0.\n                        box 0.F\n                        box \"\"\n                        box false\n                        box System.Guid.Empty\n                        box System.DateTime.MinValue\n                    ]\n            \n                let rec defaultValue defs (t:System.Type) : obj =\n                    match (defs:System.Collections.Generic.IDictionary<string, obj>).TryGetValue t.FullName with\n                    | true , v -> v\n                    | false, _ ->\n                    if t.IsArray then \n                        System.Array.CreateInstance(t.GetElementType(), 0) |> box\n                    elif t.IsEnum then\n                        (System.Enum.GetValues t).GetValue [| 0 |] |> box\n                    else\n                    let c = t.GetConstructor System.Type.EmptyTypes\n                    if  isNull c |> not then\n                        c.Invoke [||]\n                    elif FSharpType.IsRecord t then\n                        FSharpType.GetRecordFields t\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeRecord(t, os)\n                    elif FSharpType.IsTuple t then\n                        FSharpType.GetTupleElements t\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeTuple(os, t)\n                    elif FSharpType.IsUnion t then\n                        let case = FSharpType.GetUnionCases t |> Seq.head\n                        case.GetFields()\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeUnion(case, os)\n                    else failwithf \"Could no create default for %s\" t.FullName\n            \n                and createArray defs (ts : System.Type []) = ts |> Array.map defs\n            \n                let inline value<'T> : 'T = typeof<'T> |> defaultValue defs |> unbox\n            \n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER \n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            \n            module Date =\n                let toYYYYMMDD     sep (date:System.DateTime) = sprintf \"%d%s%02d%s%02d\" date.Year sep  date.Month sep date.Day\n                let toHHMM             (date:System.DateTime) = sprintf \"%02d:%02d\" date.Hour  date.Minute\n                let toYYYYMMDDHHMM sep (date:System.DateTime) = sprintf \"%s %s\" (toYYYYMMDD sep date) (toHHMM date)\n                \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n    \n    //#cd @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/projects/ProzperServer\"\n    module ProzperServer =\n    \n        [< AutoOpen ; JavaScript >]\n        module Basico =\n            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id\n            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id\n            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id\n            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id\n        \n            type VariableAmbienteI   = \n                    abstract getVar  : string -> string\n                    abstract member CarpetaRaiz          : unit     -> string\n        \n            let variableAmbienteE v  = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.getVar     v \n            let carpetaRaiz       () = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.CarpetaRaiz()\n        \n        \n        [< AutoOpen ; JavaScript >]\n        module TypesV0 =\n            type LatestType = TypeV0\n        \n            type IdAliado       = IdAliado       of string          with member this.Id = match this with IdAliado       id -> id\n            type IdAuthorize    = IdAuthorize    of string          with member this.Id = match this with IdAuthorize    id -> id\n            type IdAddress      = IdAddress      of string          with member this.Id = match this with IdAddress      id -> id\n            type IdPayment      = IdPayment      of string          with member this.Id = match this with IdPayment      id -> id\n            type IdSubscription = IdSubscription of string          with member this.Id = match this with IdSubscription id -> id\n        \n            type StatusAliado =\n            | CuentaCreada\n            | Activo\n            | Inactivo\n            | Cancelado\n                with\n                    override this.ToString() = sprintf \"%A\" this\n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"CUENTACREADA\"             -> CuentaCreada\n                        | \"ACTIVO\"                   -> Activo\n                        | \"CANCELADO\"                -> Cancelado\n                        | _                          -> Inactivo\n        \n            type TipoAliado =\n            | Master\n            | Regular\n                with\n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Pais =\n            | USA\n            | Venezuela \n            | Argentina\n            | OtroP of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"EEUU\" | \"UNITED STATES\"  | \"UNITED STATES OF AMERICA\" | \"US\" | \"E.E.U.U.\" | \"AMERICA\"\n                        | \"USA\"            -> Some <| USA\n                        | \"VENEZUELA\"      -> Some <| Venezuela\n                        | \"ARGENTINA\"      -> Some <| Argentina\n                        | _                -> Some <| (OtroP <| s.Trim() )\n                    override this.ToString() = match this with OtroP s -> s | v -> sprintf \"%A\" v\n        \n            type Estado =\n            | Texas\n            | Florida\n            | OtroS of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"TX\"\n                        | \"TEXAS\"          -> Some <| Texas\n                        | \"FL\"\n                        | \"FLORIDA\"        -> Some <| Florida\n                        | _                -> Some <| (OtroS <| s.Trim() )\n                    override this.ToString() = match this with OtroS s -> s | v -> sprintf \"%A\" v\n        \n            type Territorio =\n            | Estado of Estado\n        \n            type Emisor =\n            | Pais       of Pais\n            | Territorio of Territorio\n        \n            type Documento =\n            | Pasaporte        of string\n            | Cedula           of string\n            | LicenciaConducir of string\n        \n            type Identificacion = {\n                emisor    : Emisor\n                documento : Documento\n                emision   : System.DateTime\n                vence     : System.DateTime\n            }\n        \n            type TipoArchivo =\n            | Contrato\n            | Autorizacion\n            | Pasaporte\n            | Cedula\n            | LicenciaConducir\n            | FormaW9\n            | FormaW8BEN\n            | Otro            of string\n                with \n                    static member Parse (s:string) = \n                        match s with\n                        | String.StartsWith \"Otro \" r -> Otro r\n                        | \"Contrato\"                  -> Contrato\n                        | \"FormaW9\"                   -> FormaW9\n                        | \"FormaW8BEN\"                -> FormaW8BEN\n                        | \"Autorizacion\"              -> Autorizacion\n                        | \"Pasaporte\"                 -> Pasaporte\n                        | \"Cedula\"                    -> Cedula\n                        | \"LicenciaConducir\"          -> LicenciaConducir\n                        | _                           -> Otro <| s.Trim()\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type StatusArchivo =\n            | Subido\n            | Verificado\n            | Rechazado \n            | Expirado  \n            | Cancelado  \n            | Cambiado\n                with \n                    static member Parse (s:string) = \n                        match s with\n                        | \"Cambiado\"   -> Cambiado\n                        | \"Expirado\"   -> Expirado \n                        | \"Cancelado\"  -> Cancelado\n                        | \"Verificado\" -> Verificado \n                        | \"Rechazado\"  -> Rechazado  \n                        | _            -> Subido\n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Archivo = {\n                idAliado    : IdAliado\n                tipo        : TipoArchivo\n                nombre      : string\n                modificado  : System.DateTime\n                tamano      : int64\n                status      : StatusArchivo\n                comentario  : string\n            }\n        \n            type Mes =\n            | Enero      =  1\n            | Febrero    =  2\n            | Marzo      =  3\n            | Abril      =  4\n            | Mayo       =  5\n            | Junio      =  6\n            | Julio      =  7\n            | Agosto     =  8\n            | Septiembre =  9\n            | Octubre    = 10\n            | Noviembre  = 11\n            | Diciembre  = 12\n        \n            type Expiracion = {\n                anio : int\n                mes  : Mes\n            } with\n                member this.Id = sprintf \"%04d-%02d\" this.anio (int this.mes)\n                static member TryParse (txt:string) =\n                    let create century (anio:string) (mes:string) =\n                        {\n                            anio = century   + int anio\n                            mes  = enum<Mes>  (int mes )\n                        } |> Some\n                    if txt.Length = 4 || txt.Length = 5 then \n                        create 2000 (txt.Right 2) (txt.Left  2)\n                    elif txt.Length = 7 then\n                        txt.Split[| '-' ; '/' |]\n                        |> function \n                            | [| py ; pm |] when py.Length = 4 -> create 0 py pm\n                            | [| pm ; py |] when py.Length = 4 -> create 0 py pm\n                            |_-> None\n                    else None\n        \n        \n            type NumeroCuenta   = NumeroCuenta  of string       with member this.Id = match this with NumeroCuenta  id -> id\n            type NumeroTarjeta  = NumeroTarjeta of string       with member this.Id = match this with NumeroTarjeta id -> id\n            type RoutingNumber  = RoutingNumber of string       with member this.Id = match this with RoutingNumber id -> id \n        \n            type TipoTarjeta     = \n            | Visa\n            | MasterCard\n            | Amex\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"                 -> None    \n                        | \"VISA\"             -> Some <| Visa\n                        | \"MASTERCARD\"       -> Some <| MasterCard\n                        | \"AMEX\"\n                        | \"AMERICAN EXPRESS\" -> Some <| Amex\n                        | _                  -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type TipoCuenta     = \n            | Ahorro\n            | Corriente\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"SAVINGS\"\n                        | \"AHORRO\"         -> Some <| Ahorro\n                        | \"CHECKING\"\n                        | \"CORRIENTE\"      -> Some <| Corriente\n                        | _                -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type CuentaBancaria = {\n                titular     : string\n                banco       : string\n                tipo        : TipoCuenta\n                numero      : NumeroCuenta\n                routing     : RoutingNumber\n            }\n        \n            type TarjetaCredito = {\n                titular     : string\n                tipoTarjeta : TipoTarjeta\n                numero      : NumeroTarjeta\n                expiracion  : Expiracion\n            }\n        \n            type ConceptoPago =\n            | PagoAfiliacion\n            | PagoComision\n            | Otro of string\n                with\n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"PAGOAFILIACION\" -> Some <| PagoAfiliacion\n                        | \"PAGOCOMISION\"   -> Some <| PagoComision\n                        | _                -> Some <| (ConceptoPago.Otro <| s.Trim() )\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type Transaccion = {\n                fechaPago      : System.DateTime\n                ano            : int\n                periodo        : int\n                monto          : int\n                idAliado       : IdAliado\n                concepto       : ConceptoPago\n                transaccion    : string\n                statusTran     : string\n            }\n        \n            type TipoDireccion = \n            | Habitacion\n            | Oficina\n            | ServicioPostal\n            | Otro of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"\"               -> None    \n                        | \"Habitacion\"     -> Some <| Habitacion\n                        | \"Oficina\"        -> Some <| Oficina\n                        | \"ServicioPostal\" -> Some <| ServicioPostal\n                        | s                -> Some <| Otro s\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type ZonaPostal = ZonaPostal of string\n                with \n                    static member tryParse (s:string) = if s.Trim() <> \"\" then Some (ZonaPostal <| s.Trim()) else None\n                    override this.ToString() = match this with ZonaPostal s -> s\n        \n            type Direccion = {\n                authorizeIdR  : Result<IdAddress, string>\n                tipoDireccion : TipoDireccion\n                linea1        : string\n                linea2        : string\n                ciudad        : string\n                estado        : Estado\n                pais          : Pais\n                zonaPostal    : ZonaPostal\n            }\n        \n            type TipoTelefono =\n            | Movil\n            | Oficina\n            | Habitacion\n            | Voip\n                with \n                    static member tryParse = function\n                        | \"Movil\"      -> Some Movil\n                        | \"Oficina\"    -> Some Oficina\n                        | \"Habitacion\" -> Some Habitacion\n                        | _            -> None    \n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Telefono          = {\n                tipoTelefono : TipoTelefono\n                codigoPais   : string\n                codigoArea   : string\n                numero       : string\n                extension    : string\n                mensajes     : bool\n            }\n        \n            type CorreoElectronico = {\n                email       : string\n                enviado     : System.DateTime option\n                recibido    : System.DateTime option\n            }\n                with override this.ToString() = this.email\n        \n            type Contacto =\n            | Direccion         of Direccion\n            | CorreoElectronico of CorreoElectronico\n            | Telefono          of Telefono\n            | Mensajeria        of string\n            | PaginaWeb         of string\n            | SocialMedia       of string\n        \n            type Genero =\n            | Masculino\n            | Femenino\n            | Empresa\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"Masculino\"      -> Some <| Masculino\n                        | \"Femenino\"       -> Some <| Femenino\n                        | \"Empresa\"        -> Some <| Empresa\n                        | _                -> None    \n        \n            type DatosPersonales = {\n                titulo          : string option\n                nombre1         : string\n                nombre2         : string\n                apellido1       : string\n                apellido2       : string\n                nacionalidad    : Pais\n                genero          : Genero\n                fechaNacimiento : System.DateTime\n            }\n        \n            type CuentaPago =\n            | CuentaBancaria            of CuentaBancaria\n            | TarjetaCredito            of TarjetaCredito\n            | TransferenciaElectronica  of string\n                with\n                    member this.MaskedCuenta =\n                        match this with\n                        | TarjetaCredito           tc -> tc.numero.Id\n                        | CuentaBancaria           cb -> cb.numero.Id\n                        | TransferenciaElectronica te -> te\n                    member this.TipoCorto =\n                        match this with\n                        | TarjetaCredito           tc -> \"TC\"\n                        | CuentaBancaria           bc -> \"CB\"\n                        | TransferenciaElectronica te -> \"TE\"\n                    member this.TipoLargo =\n                        match this with\n                        | TarjetaCredito           tc -> \"Tarjeta de Credito\"\n                        | CuentaBancaria           bc -> \"Cuenta Bancaria\"\n                        | TransferenciaElectronica te -> \"Transferencia Electronica\"\n                    member this.AutorizacionPre = sprintf \"Autorizacion %s %s\" this.TipoCorto this.MaskedCuenta\n        \n            type StatusFormaPago =\n            | NuevaFormaPago\n            | Registrada      of          System.DateTime option\n            | RegistroFallido of string * System.DateTime option\n        \n            type Subscripcion = {\n                idSubscripcion  : IdSubscription\n                inicio          : System.DateTime\n                monto           : int\n                descripcion     : string\n                status          : int\n            } with \n                member this.Short = sprintf \"%s %s $%d.00 %s %d\" this.idSubscripcion.Id (Date.toYYYYMMDD \"-\" this.inicio) this.monto this.descripcion this.status\n        \n            type FormaPago = {\n                nombre          : string\n                authorizeIdR    : Result<IdPayment, string>\n                cuentaPago      : CuentaPago\n                subscripcion    : Subscripcion option\n            }\n        \n            type TipoMensaje = \n            | Alerta\n            | Informacion\n            | Saludo\n        \n            type Remitente =\n            | Prozper\n            | Aliado of IdAliado\n            | OtroR  of string\n        \n            type Mensaje = {\n                tipo      : TipoMensaje\n                leido     : System.DateTime option\n                fecha     : System.DateTime\n                texto     : string\n                remitente : Remitente\n            }\n        \n            type PremisasCalculo = {\n                comisionReferidosRegular     : int\n                comisionReferidosMaster      : int\n                comisionDescendientesMaster  : int\n                comisionDescendientesRegular : int\n                montoAfiliacion              : int\n                numeroReferidosMaster        : int\n                diaCorte1                    : int\n                diaCorte2                    : int\n            }\n        \n            let premisasCalculo = {\n                comisionReferidosRegular     = 15\n                comisionReferidosMaster      = 25\n                comisionDescendientesMaster  = 25\n                comisionDescendientesRegular =  0\n                montoAfiliacion              = 75\n                numeroReferidosMaster        = 31\n                diaCorte1                    = 26\n                diaCorte2                    = 28\n            }\n        \n            let telVacio = {            \n                tipoTelefono = Movil\n                codigoPais   = \"\"\n                codigoArea   = \"\"\n                numero       = \"\"\n                extension    = \"\"\n                mensajes     = false\n            }\n        \n            let dirVacio = {\n                authorizeIdR  = Error \"\"\n                tipoDireccion = TipoDireccion.Habitacion\n                linea1        = \"\"\n                linea2        = \"\"\n                ciudad        = \"\"\n                estado        = OtroS \"\"\n                pais          = OtroP \"\"\n                zonaPostal    = ZonaPostal \"\"\n            }\n        \n            let tarVacio = {            \n                tipoTarjeta  = Visa\n                numero       = NumeroTarjeta \"\"\n                expiracion   = { anio = 2000 ; mes = Mes.Enero }\n                titular      = \"\"\n            }\n        \n            let ctaVacio = {            \n                banco        = \"\"\n                numero       = NumeroCuenta \"\"\n                tipo         = Ahorro\n                titular      = \"\"\n                routing      = RoutingNumber \"\"\n            }\n        \n            type DiaPago =\n            |   Dia01\n            |   Dia05\n            |   Dia10\n            |   Dia15\n            |   Dia20\n            |   Dia25\n        \n            type IdForAuthorize = IdForAuthorize of string  with member this.Id = match this with IdForAuthorize id -> id\n        \n            type Aliado = {\n                id              :      IdAliado\n                idPadreO        :      IdAliado       option\n                idForAuthorize  :      IdForAuthorize option\n                influyente      :      string         option\n                datosPersonales :      DatosPersonales\n                contactos       :      Contacto       []\n                identificacion  :      Identificacion []\n                isInternal      :      bool\n                status          :      StatusAliado\n                diaPago         :      DiaPago\n                tipo            :      TipoAliado\n                fechaRegistro   :      System.DateTime\n                fechaStatus     :      System.DateTime\n                nReferidos      :      int\n                nRefActivos     :      int\n                nDescendientes  :      int\n                nDescActivos    :      int\n                comision        :      int\n                nivel           :      int\n                documentos      :      int\n                docPendientes   :      int\n            }\n        \n            type Modelo = {\n                idAliado      : IdAliado\n                aliados       : Aliado []\n                anoActual     : int\n                periodoActual : int\n                premisas      : PremisasCalculo\n                nevento       : int64\n            }\n        \n            let modeloVacio = {\n                idAliado      = IdAliado \"\"\n                aliados       = [||]\n                anoActual     = System.DateTime.Now.Year\n                periodoActual = System.DateTime.Now.Month\n                premisas      = premisasCalculo\n                nevento       = 0L\n            }\n        \n            let correoVacio = {\n                email       = \"\"\n                enviado     = None\n                recibido    = None\n            }\n        \n        [< JavaScript >]\n        module Aliado =\n            open Operators\n        \n            //let statusActual ano mes al  =\n            //    al.transacciones.Value\n            //    |> Array.tryFind (fun t -> t.idAliado = al.id \n            //                            && t.ano      = ano\n            //                            && t.periodo  = mes\n            //                            && t.concepto = PagoAfiliacion)\n            //    |> Option.map    (fun _ ->  Activo )\n            //    |> Option.defaultValue    Inactivo\n        \n            open System.Collections.Generic\n        \n            let premisas pre al =\n                let comRef, comDes = match al.tipo  with\n                                     | Regular -> pre.comisionReferidosRegular, pre.comisionDescendientesRegular\n                                     | Master  -> pre.comisionReferidosMaster , pre.comisionDescendientesMaster\n                match al.status with\n                | Activo -> comRef, comDes\n                | _      -> 0     , 0\n        \n            let comision pre al = \n                let comRef, comDes = premisas pre al\n                al.nRefActivos * comRef, al.nDescActivos * comDes\n        \n            type Buscar = {\n                hijosDe        : (IdAliado -> IdAliado [])\n                nivelDe        : (IdAliado option -> int)\n                aliado         : (IdAliado -> Aliado)\n                aliadoO        : (IdAliado -> Aliado option)\n                hijos          : (Aliado -> Aliado [])\n                descendientes  : (Aliado -> Aliado [])\n            }\n        \n            let busqueda aliados =\n                let padres               = aliados \n                                           |> Seq.map(fun al -> al.idPadreO, al.id) \n                                           |> Seq.groupBy fst \n                                           |> Seq.map(fun (pO, ch) -> pO, ch |> Seq.map snd |> Seq.toArray) |> Map\n                let aliadosMap           = aliados |> Seq.map (fun al -> al.id, al) |> Map\n                let aliadoO          id  = match aliadosMap.TryGetValue id with\n                                           | true, al -> Some al\n                                           | _        -> None\n                let aliado           id  = try aliadosMap.[id] with e -> failwithf \"buscarAliado failed: %A\" id\n                let hijosDe          idO = match padres.TryGetValue (Some idO) with\n                                           | true, hijos -> hijos\n                                           | _           -> [||]\n                let rec nivelDe      idO = idO |> Option.bind aliadoO |> Option.map (fun al -> 1 + nivelDe al.idPadreO) |> Option.defaultValue 0\n                let hijos             al = hijosDe al.id |> Array.choose aliadoO\n                let rec descendientes al =\n                    [|\n                        for h in hijos al do\n                            yield                h\n                            yield! descendientes h\n                    |]\n                {\n                    hijosDe       = hijosDe       \n                    nivelDe       = nivelDe       \n                    aliado        = aliado        \n                    aliadoO       = aliadoO       \n                    hijos         = hijos         \n                    descendientes = descendientes \n                }\n        \n            let diaPago (registro:System.DateTime) =\n                let  diaMes = registro.Day\n                if   diaMes  =  1 then Dia01\n                elif diaMes <=  5 then Dia05\n                elif diaMes <= 10 then Dia10\n                elif diaMes <= 15 then Dia15\n                elif diaMes <= 20 then Dia20\n                elif diaMes <= 25 then Dia25\n                else                   Dia01\n        \n            let dia = function\n            | Dia01 ->  1\n            | Dia05 ->  5\n            | Dia10 -> 10\n            | Dia15 -> 15\n            | Dia20 -> 20\n            | Dia25 -> 25\n        \n            let actualizarAliados (transAll:Transaccion []) modelo =\n                let buscar             = busqueda modelo.aliados\n                let pre                = modelo.premisas\n                let trans              = transAll |> Array.filter (fun tr -> tr.fechaPago > System.DateTime.Today.AddMonths -1 )\n                let statusActual    al = \n                    match al.status with\n                    | Activo\n                    | Inactivo -> if trans\n                                     |> Seq.exists(fun tr -> tr.idAliado = al.id && tr.monto >= pre.montoAfiliacion ) \n                                    then Activo else Inactivo\n                    | st       -> st\n                let rec aliadoActualizado alid =\n                    let al             = buscar.aliado alid\n                    let hijos          = buscar.hijosDe al.id |> Seq.map aliadoActualizadoM |> Seq.cache\n                    let status         = statusActual al\n                    let nReferidos     = hijos |> Seq.length\n                    let nRefActivos    = hijos |> Seq.filter (fun al -> al.status = Activo && al.tipo = Regular) |> Seq.length\n                    let nDescendientes = hijos |> Seq.sumBy  (fun al -> al.nDescendientes + al.nReferidos )\n                    let nDescActivos   = hijos |> Seq.sumBy  (fun al -> al.nDescActivos   + al.nRefActivos)\n                    let tipo           = if nRefActivos >= pre.numeroReferidosMaster then Master else Regular\n                    let nivel          = 1 + buscar.nivelDe al.idPadreO\n                    let al0 =\n                        { al with\n                            status         = status\n                            tipo           = tipo\n                            nReferidos     = nReferidos    \n                            nRefActivos    = nRefActivos   \n                            nDescendientes = nDescendientes\n                            nDescActivos   = nDescActivos  \n                            diaPago        = diaPago al.fechaRegistro\n                            //fechaStatus    = System.DateTime()\n                            nivel          = nivel\n                        }\n                    let comRef, comDes = comision pre al0\n                    let al1 = { al0 with comision = comRef + comDes}\n                    {al1 with status = if al1.status = Inactivo && al1.comision >= pre.montoAfiliacion then Activo else al1.status }\n        \n                and aliadoActualizadoM = Memoize.memoize aliadoActualizado\n        \n                modelo.aliados \n                |> Seq.map (fun al -> al.id)\n                |> Seq.map aliadoActualizadoM\n                |> Seq.toArray\n        \n            //let actualizarModelEf () = eff {\n            //    let! modelo     = State.get()\n            //    do! State.put { modelo with aliados = actualizarAliados modelo }\n            //    ()\n            //}\n        \n            let empty = {\n                datosPersonales = {\n                                        titulo          = None\n                                        nombre1         = \"\"\n                                        nombre2         = \"\"\n                                        apellido1       = \"\"\n                                        apellido2       = \"\"\n                                        nacionalidad    = USA\n                                        genero          = Masculino\n                                        fechaNacimiento = System.DateTime(2000, 1, 1)\n                                    }\n                id              =  IdAliado \"\"\n                idPadreO        =  None\n                idForAuthorize  =  None\n                influyente      =  None\n                contactos       =  [||]\n                identificacion  =  [||]\n                isInternal      =  false\n                status          =  Inactivo\n                tipo            =  Regular\n                fechaRegistro   =  System.DateTime(2000, 1, 1)\n                fechaStatus     =  System.DateTime(2000, 1, 1)\n                diaPago         =  Dia01\n                nReferidos      =  0\n                nRefActivos     =  0\n                nDescendientes  =  0\n                nDescActivos    =  0\n                comision        =  0\n                nivel           =  0\n                documentos      =  0\n                docPendientes   =  0\n            }\n        \n            let nombre dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                let apellido = if dp.apellido1 = \"\" then \"\" else (dp.apellido1 + \" \" + dp.apellido2).Trim() + \", \"\n                titulo + apellido + dp.nombre1 + \" \" + dp.nombre2\n        \n            let nombre2 dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                titulo + (dp.nombre1 + \" \" + dp.nombre2).Trim() + \" \" + (dp.apellido1 + \" \" + dp.apellido2).Trim()\n        \n            let correo al  =\n                al.contactos |> Seq.choose(function | CorreoElectronico correo -> Some correo.email |_-> None ) |> Seq.tryHead |> Option.defaultValue \"\"\n                \n        module Serializador =\n            open Serializer\n            open System\n        \n            [< AutoOpen >]\n            module TypesV0 =\n                open TypesV0\n            \n                let serDate : Ser<System.DateTime> = \n                    (  fun (d:System.DateTime ) -> d.ToString(\"u\") |> sprintf \"%A\"                )\n                    , (fun (j:JsonIntermediate) -> j.tryString() |> Option.bind ParseO.parseDateO )\n        \n                let serIdAliado          = serDU<IdAliado         > [   serObj serString            ]    \n                let serIdAuthorized      = serDU<IdAuthorize      > [   serObj serString            ]    \n                let serIdForAuthorize    = serDU<IdForAuthorize   > [   serObj serString            ]    \n                let serIdPayment         = serDU<IdPayment        > [   serObj serString            ]    \n                let serIdAddress         = serDU<IdAddress        > [   serObj serString            ]    \n                let serTipoAliado        = serDU<TipoAliado       > [   serObj serString            ]\n                let serPais              = serDU<Pais             > [   serObj serString            ]    \n                let serEstado            = serDU<Estado           > [   serObj serString            ]    \n                let serTerritorio        = serDU<Territorio       > [   serObj serEstado            ]   \n                let serEmisor            = serDU<Emisor           > [   serObj serPais\n                                                                        serObj serTerritorio        ]\n                let serDocumento         = serDU<Documento        > [   serObj serString            ]    \n                let serNumeroCuenta      = serDU<NumeroCuenta     > [   serObj serString            ]    \n                let serNumeroTarjeta     = serDU<NumeroTarjeta    > [   serObj serString            ]\n                let serRoutingNumber     = serDU<RoutingNumber    > [   serObj serString            ]    \n                let serTipoCuenta        = serDU<TipoCuenta       > [   serObj serString            ]    \n                let serStatusAliado      = serDU<StatusAliado     > [   serObj serString            ]    \n                let serConceptoPago      = serDU<ConceptoPago     > [   serObj serString            ]    \n                let serTipoDireccion     = serDU<TipoDireccion    > [   serObj serString            ]    \n                let serZonaPostal        = serDU<ZonaPostal       > [   serObj serString            ]    \n                let serTipoTelefono      = serDU<TipoTelefono     > [   serObj serString            ]    \n                let serGenero            = serDU<Genero           > [   serObj serString            ]    \n                let serTipoMensaje       = serDU<TipoMensaje      > [   serObj serString            ]\n                let serDiaPago           = serDU<DiaPago          > [                               ]\n                let serTipoArchivo       = serDU<TipoArchivo      > [   serObj serString            ]    \n                let serStatusArchivo     = serDU<StatusArchivo    > [   serObj serString            ]    \n        \n                let serMes : Ser<Mes>    = (int >> fst serInt), (snd serInt >> Option.map enum<_> )\n        \n                let serIdAuthorizedR     = serDU<Result<IdAuthorize, string>> [   serObj serString ; serObj serIdAuthorized ]    \n                let serIdPaymentR        = serDU<Result<IdPayment  , string>> [   serObj serString ; serObj serIdPayment    ]    \n                let serIdAddressR        = serDU<Result<IdAddress  , string>> [   serObj serString ; serObj serIdAddress    ]    \n        \n                let serExpiracion: Ser<Expiracion> =\n                    [|\n                        serInt        |> serField \"anio\"    (fun s -> s.anio   ) (fun v s -> { s with anio    = v } )   \n                        serMes        |> serField \"mes\"     (fun s -> s.mes    ) (fun v s -> { s with mes     = v } )          \n                    |] |> serRecord tarVacio.expiracion\n        \n        \n                let serIdentificacion : Ser<Identificacion> = \n                    [|\n                        serEmisor    |> serField \"emisor\"    (fun s -> s.emisor    ) (fun v s -> { s with emisor    = v } )\n                        serDocumento |> serField \"documento\" (fun s -> s.documento ) (fun v s -> { s with documento = v } )\n                        serDate      |> serField \"emision\"   (fun s -> s.emision   ) (fun v s -> { s with emision   = v } )\n                        serDate      |> serField \"vence\"     (fun s -> s.vence     ) (fun v s -> { s with vence     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaBancaria : Ser<CuentaBancaria> =\n                    [|\n                        serString        |> serField \"titular\" (fun (s:CuentaBancaria) -> s.titular) (fun v s -> { s with titular = v } )   \n                        serString        |> serField \"banco\"   (fun  s                 -> s.banco  ) (fun v s -> { s with banco   = v } )   \n                        serTipoCuenta    |> serField \"tipo\"    (fun  s                 -> s.tipo   ) (fun v s -> { s with tipo    = v } )        \n                        serNumeroCuenta  |> serField \"numero\"  (fun  s                 -> s.numero ) (fun v s -> { s with numero  = v } )          \n                        serRoutingNumber |> serField \"routing\" (fun  s                 -> s.routing) (fun v s -> { s with routing = v } )           \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTarjetaCredito : Ser<TarjetaCredito> =\n                    [|\n                        serExpiracion    |> serField \"expiracion\" (fun s -> s.expiracion) (fun v s -> { s with expiracion = v } )   \n                        serString        |> serField \"titular\"    (fun s -> s.titular   ) (fun v s -> { s with titular    = v } )   \n                        serNumeroTarjeta |> serField \"numero\"     (fun s -> s.numero    ) (fun v s -> { s with numero     = v } )          \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTransaccion : Ser<Transaccion> = \n                    [|\n                        serDate          |> serField \"fechaPago\"   (fun s -> s.fechaPago  ) (fun v s -> { s with fechaPago   = v } ) \n                        serInt           |> serField \"ano\"         (fun s -> s.ano        ) (fun v s -> { s with ano         = v } )\n                        serInt           |> serField \"periodo\"     (fun s -> s.periodo    ) (fun v s -> { s with periodo     = v } )\n                        serInt           |> serField \"monto\"       (fun s -> s.monto      ) (fun v s -> { s with monto       = v } )\n                        serIdAliado      |> serField \"idAliado\"    (fun s -> s.idAliado   ) (fun v s -> { s with idAliado    = v } )     \n                        serConceptoPago  |> serField \"concepto\"    (fun s -> s.concepto   ) (fun v s -> { s with concepto    = v } )         \n                        serString        |> serField \"transaccion\" (fun s -> s.transaccion) (fun v s -> { s with transaccion = v } )   \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDireccion : Ser<Direccion> = \n                    [|\n                        serTipoDireccion |> serField \"tipoDireccion\" (fun s -> s.tipoDireccion) (fun v s -> { s with tipoDireccion = v } )\n                        serString        |> serField \"linea1\"        (fun s -> s.linea1       ) (fun v s -> { s with linea1        = v } )\n                        serString        |> serField \"linea2\"        (fun s -> s.linea2       ) (fun v s -> { s with linea2        = v } )\n                        serString        |> serField \"ciudad\"        (fun s -> s.ciudad       ) (fun v s -> { s with ciudad        = v } )\n                        serPais          |> serField \"pais\"          (fun s -> s.pais         ) (fun v s -> { s with pais          = v } )\n                        serZonaPostal    |> serField \"zonaPostal\"    (fun s -> s.zonaPostal   ) (fun v s -> { s with zonaPostal    = v } )\n                        serEstado        |> serField \"estado\"        (fun s -> s.estado       ) (fun v s -> { s with estado        = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTelefono : Ser<Telefono> =\n                    [|\n                        serTipoTelefono |> serField \"tipoTelefono\" (fun s -> s.tipoTelefono) (fun v s -> { s with tipoTelefono = v } )\n                        serString       |> serField \"codigoPais\"   (fun s -> s.codigoPais  ) (fun v s -> { s with codigoPais   = v } )\n                        serString       |> serField \"codigoArea\"   (fun s -> s.codigoArea  ) (fun v s -> { s with codigoArea   = v } )\n                        serString       |> serField \"numero\"       (fun s -> s.numero      ) (fun v s -> { s with numero       = v } )\n                        serString       |> serField \"extension\"    (fun s -> s.extension   ) (fun v s -> { s with extension    = v } )\n                        serBool         |> serField \"mensajes\"     (fun s -> s.mensajes    ) (fun v s -> { s with mensajes     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaPago        = serDU<CuentaPago       > [   serObj serString              \n                                                                        serObj serTarjetaCredito\n                                                                        serObj serCuentaBancaria    ]\n                let serRemitente         = serDU<Remitente        > [   serObj serIdAliado\n                                                                        serObj serString            ]\n        \n                let serFormaPago : Ser<FormaPago> =\n                    [|\n                        serCuentaPago            |> serField \"cuentaPago\"  (fun s -> s.cuentaPago   ) (fun v s -> { s with cuentaPago   = v } )\n                        serString                |> serField \"nombre\"      (fun s -> s.nombre       ) (fun v s -> { s with nombre       = v } )\n                        serIdPaymentR            |> serField \"authorizeId\" (fun s -> s.authorizeIdR ) (fun v s -> { s with authorizeIdR = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDatosPersonales : Ser<DatosPersonales> =\n                    [|\n                        serString        |> serOpt  |> serField \"titulo\"          (fun s -> s.titulo         ) (fun v s -> { s with titulo          = v } )\n                        serString                   |> serField \"nombre1\"         (fun s -> s.nombre1        ) (fun v s -> { s with nombre1         = v } )\n                        serString                   |> serField \"nombre2\"         (fun s -> s.nombre2        ) (fun v s -> { s with nombre2         = v } )\n                        serString                   |> serField \"apellido1\"       (fun s -> s.apellido1      ) (fun v s -> { s with apellido1       = v } )\n                        serString                   |> serField \"apellido2\"       (fun s -> s.apellido2      ) (fun v s -> { s with apellido2       = v } )\n                        serPais                     |> serField \"nacionalidad\"    (fun s -> s.nacionalidad   ) (fun v s -> { s with nacionalidad    = v } )\n                        serGenero                   |> serField \"genero\"          (fun s -> s.genero         ) (fun v s -> { s with genero          = v } )\n                        serDate                     |> serField \"fechaNacimiento\" (fun s -> s.fechaNacimiento) (fun v s -> { s with fechaNacimiento = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serMensaje : Ser<Mensaje> =\n                    [|\n                        serTipoMensaje           |> serField \"tipo\"      (fun (s:Mensaje) -> s.tipo     ) (fun v s -> { s with tipo      = v } )\n                        serDate        |> serOpt |> serField \"leido\"     (fun (s:Mensaje) -> s.leido    ) (fun v s -> { s with leido     = v } )\n                        serDate                  |> serField \"fecha\"     (fun (s:Mensaje) -> s.fecha    ) (fun v s -> { s with fecha     = v } )\n                        serString                |> serField \"texto\"     (fun (s:Mensaje) -> s.texto    ) (fun v s -> { s with texto     = v } )\n                        serRemitente             |> serField \"remitente\" (fun (s:Mensaje) -> s.remitente) (fun v s -> { s with remitente = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serPremisasCalculo : Ser<PremisasCalculo> =\n                    [|\n                        serInt  |> serField \"comisionReferidosRegular\"     (fun s -> s.comisionReferidosRegular    ) (fun v s -> { s with comisionReferidosRegular     = v } )\n                        serInt  |> serField \"comisionReferidosMaster\"      (fun s -> s.comisionReferidosMaster     ) (fun v s -> { s with comisionReferidosMaster      = v } )\n                        serInt  |> serField \"comisionDescendientesMaster\"  (fun s -> s.comisionDescendientesMaster ) (fun v s -> { s with comisionDescendientesMaster  = v } )\n                        serInt  |> serField \"comisionDescendientesRegular\" (fun s -> s.comisionDescendientesRegular) (fun v s -> { s with comisionDescendientesRegular = v } )\n                        serInt  |> serField \"montoAfiliacion\"              (fun s -> s.montoAfiliacion             ) (fun v s -> { s with montoAfiliacion              = v } )\n                        serInt  |> serField \"numeroReferidosMaster\"        (fun s -> s.numeroReferidosMaster       ) (fun v s -> { s with numeroReferidosMaster        = v } )\n                        serInt  |> serField \"diaCorte1\"                    (fun s -> s.diaCorte1                   ) (fun v s -> { s with diaCorte1                    = v } )\n                        serInt  |> serField \"diaCorte2\"                    (fun s -> s.diaCorte2                   ) (fun v s -> { s with diaCorte2                    = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCorreoElectronico : Ser<CorreoElectronico> = \n                    [|\n                        serString         |> serField \"email\"    (fun s -> s.email    ) (fun v s -> { s with email    = v } )\n                        serDate |> serOpt |> serField \"enviado\"  (fun s -> s.enviado  ) (fun v s -> { s with enviado  = v } )\n                        serDate |> serOpt |> serField \"recibido\" (fun s -> s.recibido ) (fun v s -> { s with recibido = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serContacto          = serDU<Contacto         > [   serObj serString     \n                                                                        serObj serTelefono\n                                                                        serObj serCorreoElectronico\n                                                                        serObj serDireccion         ] \n        \n                let serArchivo : Ser<Archivo> = \n                    [|\n                        serString                      |> serField \"nombre\"          (fun (s:Archivo)-> s.nombre) (fun v s -> { s with nombre          = v } )\n                        serIdAliado                    |> serField \"id\"              (fun s -> s.idAliado       ) (fun v s -> { s with idAliado        = v } )\n                        serDate                        |> serField \"modificado\"      (fun s -> s.modificado     ) (fun v s -> { s with modificado      = v } )\n                        serString                      |> serField \"comentario\"      (fun s -> s.comentario     ) (fun v s -> { s with comentario      = v } )\n                        serStatusArchivo               |> serField \"status\"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )\n                        serTipoArchivo                 |> serField \"tipo\"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )\n                        serInt64                       |> serField \"tamano\"          (fun s -> s.tamano         ) (fun v s -> { s with tamano          = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serAliado : Ser<Aliado> =\n                    [|\n                        serIdAliado                    |> serField \"id\"              (fun s -> s.id             ) (fun v s -> { s with id              = v } )\n                        serIdForAuthorize   |> serOpt  |> serField \"idForAuthorize\"  (fun s -> s.idForAuthorize ) (fun v s -> { s with idForAuthorize  = v } )\n                        serIdAliado         |> serOpt  |> serField \"idPadreO\"        (fun s -> s.idPadreO       ) (fun v s -> { s with idPadreO        = v } )\n                        serIdentificacion   |> serArr  |> serField \"identificacion\"  (fun s -> s.identificacion ) (fun v s -> { s with identificacion  = v } )\n                        serString           |> serOpt  |> serField \"influyente\"      (fun s -> s.influyente     ) (fun v s -> { s with influyente      = v } )\n                        serDatosPersonales             |> serField \"datosPersonales\" (fun s -> s.datosPersonales) (fun v s -> { s with datosPersonales = v } )\n                        serContacto         |> serArr  |> serField \"contactos\"       (fun s -> s.contactos      ) (fun v s -> { s with contactos       = v } )\n                        //serFormaPago        |> serArr  |> serField \"formasPago\"      (fun s -> s.formasPago     ) (fun v s -> { s with formasPago      = v } )\n                        //serTransaccion      |> serArr  |> serField \"transacciones\"   (fun s -> s.transacciones  ) (fun v s -> { s with transacciones   = v } )\n                        //serMensaje          |> serArr  |> serField \"mensajes\"        (fun s -> s.mensajes       ) (fun v s -> { s with mensajes        = v } )\n                        serBool                        |> serField \"isInternal\"      (fun s -> s.isInternal     ) (fun v s -> { s with isInternal      = v } )\n                        serStatusAliado                |> serField \"status\"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )\n                        serTipoAliado                  |> serField \"tipo\"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )\n                        serDate                        |> serField \"fechaRegistro\"   (fun s -> s.fechaRegistro  ) (fun v s -> { s with fechaRegistro   = v } )\n                        serDate                        |> serField \"fechaStatus\"     (fun s -> s.fechaStatus    ) (fun v s -> { s with fechaStatus     = v } )\n                        serDiaPago                     |> serField \"diaPago\"         (fun s -> s.diaPago        ) (fun v s -> { s with diaPago         = v } )\n                        serInt                         |> serField \"nReferidos\"      (fun s -> s.nReferidos     ) (fun v s -> { s with nReferidos      = v } )\n                        serInt                         |> serField \"nRefActivos\"     (fun s -> s.nRefActivos    ) (fun v s -> { s with nRefActivos     = v } )\n                        serInt                         |> serField \"nDescendientes\"  (fun s -> s.nDescendientes ) (fun v s -> { s with nDescendientes  = v } )\n                        serInt                         |> serField \"nDescActivos\"    (fun s -> s.nDescActivos   ) (fun v s -> { s with nDescActivos    = v } )\n                        serInt                         |> serField \"comision\"        (fun s -> s.comision       ) (fun v s -> { s with comision        = v } )\n                        serInt                         |> serField \"nivel\"           (fun s -> s.nivel          ) (fun v s -> { s with nivel           = v } )\n                        serInt                         |> serField \"documentos\"      (fun s -> s.documentos     ) (fun v s -> { s with documentos      = v } )\n                        serInt                         |> serField \"docPendientes\"   (fun s -> s.docPendientes  ) (fun v s -> { s with docPendientes   = v } )                \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serModelo : Ser<Modelo> = \n                    [|\n                        serInt64                      |> serField \"nevento\"       (fun s -> s.nevento       ) (fun v s -> { s with nevento       = v } )\n                        serIdAliado                   |> serField \"idAliado\"      (fun s -> s.idAliado      ) (fun v s -> { s with idAliado      = v } )\n                        //serAliado           |> serArr |> serField \"aliados\"       (fun s -> s.aliados       ) (fun v s -> { s with aliados       = v } )\n                        serInt                        |> serField \"anoActual\"     (fun s -> s.anoActual     ) (fun v s -> { s with anoActual     = v } )\n                        serInt                        |> serField \"periodoActual\" (fun s -> s.periodoActual ) (fun v s -> { s with periodoActual = v } )\n                        serPremisasCalculo            |> serField \"premisas\"      (fun s -> s.premisas      ) (fun v s -> { s with premisas      = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n        \n        module ObtenerEstado =\n            open Serializador\n        \n            type EstadoI<'H> =\n                    abstract member UltimoEstado        : unit          -> Eff<'H, int64 option>\n        //            abstract member LeerEventos          : int64    ->  Eff<'H, (int64 * string * string * string * string * System.DateTime) []>\n        //            abstract member LeerTipos            : unit     ->  string           []\n        //            abstract member LeerEventosTipos     : unit     -> (string * string) []\n                    abstract member GuardarEstado       : int64         -> string ->  Eff<'H, unit>\n                    abstract member GuardarAliado       : string        -> string ->  Eff<'H, unit>\n                    abstract member ObtenerEstado       : unit          -> Eff<'H, (int64 * string) option>\n                    abstract member ObtenerAliados      : unit          -> Eff<'H, string     [] >\n                    abstract member LeerTransacciones   : unit          -> Eff<'H, Transaccion[] >\n                    abstract member SalvarTransacciones : Transaccion[] -> Eff<'H, unit          >\n        \n            let guardarEstadoE   (nevento, serialModelo) = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarEstado nevento serialModelo\n            let obtenerEstado0E  ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerEstado    ()                  \n            let obtenerAliadosE  ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerAliados   ()                  \n            let guardarAliadoE   id json                 = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarAliado    id json             \n            let ultimoEstadoE    ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.UltimoEstado     ()\n            let leerTransaccsE   ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.LeerTransacciones()\n            let salvarTransaccsE ts                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.SalvarTransacciones ts\n        \n            let aliadosPrevio = System.Collections.Generic.Dictionary<_,_>()\n        \n            let guardarAliados aliados = eff {\n                let mutable first = true\n                for (aliado:Aliado) in aliados do\n                    let previoO = Dict.tryGetValue aliado.id aliadosPrevio\n                    if previoO <> Some aliado then\n                        if first then \n                            first <- false\n                            printfn \"previo = %A\" previoO \n                            printfn \"nuevo  = %A\" aliado\n                        do! aliado |> Serializer.serialize serAliado |> guardarAliadoE aliado.id.Id\n                    if previoO.IsSome then aliadosPrevio.Remove aliado.id |> ignore\n                    aliadosPrevio.Add(aliado.id, aliado)\n                    ()\n            }\n        \n            let actualizarAliadosPrevio aliados = eff {\n                aliadosPrevio.Clear()\n                for aliado in aliados do\n                    aliadosPrevio.Add(aliado.id, aliado)\n            }\n        \n            let guardarEstado nevento modelo = \n                eff {\n                    let! trans = leerTransaccsE()\n                    return!\n                        { modelo with nevento = nevento ; aliados = Aliado.actualizarAliados trans modelo } \n                        |> EA.tee (fun e -> guardarAliados e.aliados)\n                        |>> fun (modelo:Modelo) -> nevento, modelo |> Serializer.serialize serModelo\n                        >>= guardarEstadoE\n                }\n        \n            let private obtenerAliados () = eff {\n                let! aliadoss = obtenerAliadosE()\n                let  aliados  = aliadoss |> Array.choose (Serializer.deserializeWithDefs serAliado)\n                do! actualizarAliadosPrevio aliados\n                return aliados\n            }\n        \n            let obtenerEstado00E() = eff {\n                let! estadoPO = obtenerEstado0E()\n                let! estadoSinAliados = \n                    estadoPO \n                    |> Option.map snd                                       \n                    |> Option.map (Serializer.deserializeWithDefs serModelo)\n                    |> Option.defaultValue  (Some modeloVacio)              \n                    |> Result.ofOption  (fun () -> \"Modelo no fue deserializado\")\n                    |> Rsl.ofResult\n                let! aliados = obtenerAliados()\n                //let! trans = leerTransaccsE()\n                let  estado = { estadoSinAliados with aliados = aliados }\n                //return { estado with aliados = Aliado.actualizarAliados trans estado } \n                return estado\n            }\n        \n            let mutable private estadoActual : Modelo option = None\n        \n            let resetEstadoActual() = estadoActual <- None\n        \n            let obtenerEstado() = eff{\n                let! estado = ultimoEstadoE()\n                match estado, estadoActual with\n                | Some n, Some e when n = e.nevento -> return e\n                |_-> return! obtenerEstado00E() |>>! (fun e -> estadoActual <- Some e)\n            }\n        \n            //let obtenerUsuario (aid: (_*_) []) : string =  aid \n                //|>  Seq.tryFind(fun (n,v) -> n = \"http://schemas.microsoft.com/identity/aid/objectidentifier\") \n                //|>  Option.map snd\n                //|>  Option.defaultWith (fun () -> failwith \"Usuario no autenticado\")\n        \n            let obtenerAliadoEstado (aid:IdAliado) =\n                obtenerEstado()\n                |>> fun modelo -> \n                        modelo.aliados \n                        |> Array.tryFind (fun al -> al.id = aid ) \n                        |> Option.map (fun v -> v, modelo) \n                |> Rsl.absorbO (fun () -> \"Aliado no fue encontrado\")\n        \n            //let obtenerAliadoEstado    aid       = obtenerUsuario       aid |>  obtenerAliadoEstado0\n            let obtenerAliado          aid       = obtenerAliadoEstado  aid |>> fst\n            //let obtenerAliadoEstadoId (IdAliado id) = obtenerAliadoEstado id\n            //let pairAliadoEstado       aid   ev  = obtenerAliadoEstado  aid |>> fun s -> s, ev\n            //let pairAliado             aid   ev  = obtenerAliado        aid |>> fun a -> a, ev\n        \n            let obtenerSubModelo esAdmin (aliado:Aliado, modelo:Modelo) = \n                let buscar = Aliado.busqueda modelo.aliados\n                if esAdmin then modelo else\n                let subAliados = (if aliado.tipo = Master then buscar.descendientes else buscar.hijos) aliado\n                { modelo with \n                    idAliado = aliado.id\n                    aliados  = Array.append [| aliado |] subAliados \n                }\n        \n            let obtenerEstadoParaUsuario aid esAdmin =\n                obtenerAliadoEstado aid\n                |>> obtenerSubModelo esAdmin\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n        \n        module Authorize =\n            open System\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n        \n            type AuthorizeI<'H>     = abstract execute : IApiOperation<'A, 'B> -> 'B\n                                      abstract prepare : unit                  -> Eff<'H, unit>\n        \n            let authorizeMerchantId (aliado:Aliado) =\n                match aliado.idForAuthorize with\n                | Some v ->        v .Id                .Left(20)\n                | None   -> aliado.id.Id.Replace(\"-\",\"\").Left(20)\n        \n            let executeE (controller: IApiOperation<_,_> ) = Reader.ask() |>> fun (h:#AuthorizeI<_>) -> h.execute controller\n            let prepareE (                               ) = Reader.ask() >>= fun (h:#AuthorizeI<_>) -> h.prepare ()\n            let inline executeGetResponse controller : Eff<_, 'b> = eff {\n                let! response = executeE controller\n                if response = null then \n                    return! Rsl.failf \"%s Failed, Response = null\" ( controller.GetType().Name )\n                elif response.messages.resultCode = messageTypeEnum.Ok then\n                    return response\n                elif response.messages.message <> null then\n                    return! Rsl.failf \"%s Error: %s %s\"  ( controller.GetType().Name ) response.messages.message.[0].code response.messages.message.[0].text\n                else\n                    return! Rsl.failf \"%s Error: resultCode = %A, no messages\" ( controller.GetType().Name ) response.messages.resultCode\n            }\n        \n            let ( |*> ) request controllerF =\n                prepareE()\n                |>> fun () -> controllerF request\n                >>= executeGetResponse \n        \n            let ( >*= ) requestEf controllerF = \n                requestEf \n                >>= fun request -> request |*> controllerF\n        \n            let buscarPerfil aliado =\n                getCustomerProfileRequest( merchantCustomerId  = authorizeMerchantId aliado ) \n                |*> getCustomerProfileController\n                |>> fun response -> response.profile, match response.subscriptionIds with null -> [||] | v -> v\n                \n        \n            let buscarIdAuthorize aliado =\n                buscarPerfil aliado\n                |>> fun (p,_) -> IdAuthorize p.customerProfileId\n        \n            let registrarAliadoNuevo (aliado:Aliado, paymentProfile : customerPaymentProfileType) =\n                let email = aliado.contactos \n                            |> Seq.choose(function CorreoElectronico cor -> Some cor.email |_-> None) \n                            |> Seq.tryHead |> Option.defaultValue \"\"\n                let customerProfile = \n                    customerProfileType(        merchantCustomerId  = authorizeMerchantId aliado\n                                            ,   email               = email \n                                            ,   paymentProfiles     = [| paymentProfile |] )\n                createCustomerProfileRequest(   profile             = customerProfile\n                                            ,   validationMode      = validationModeEnum.liveMode )\n                |*> createCustomerProfileController \n                |>> fun response -> response.customerPaymentProfileIdList.[0]\n        \n            let registrarPagoNuevo (IdAuthorize id, pp : customerPaymentProfileType) =\n                createCustomerPaymentProfileRequest(customerProfileId = id\n                                                ,   paymentProfile    = pp\n                                                ,   validationMode    = validationModeEnum.liveMode)\n                |*> createCustomerPaymentProfileController\n                |>> fun response -> response.customerPaymentProfileId\n        \n            let pagoTipoTarjeta (tar:TarjetaCredito) =\n                let creditCard = creditCardType(cardNumber      = tar.numero.Id\n                                            ,   expirationDate  = tar.expiracion.Id               )\n                paymentType( Item = creditCard ), tar.titular\n        \n            let pagoTipoCuenta  (cta:CuentaBancaria) =\n                let  bankAccount = bankAccountType(  accountNumber   = cta.numero .Id\n                                                ,   routingNumber   = cta.routing.Id\n                                            //,   accountType     = bankAccountTypeEnum.checking\n                                            //,   echeckType      = echeckTypeEnum.WEB\n                                                ,   nameOnAccount   = cta.titular\n                                                ,   bankName        = cta.banco)\n                paymentType( Item = bankAccount  ), cta.titular\n        \n            let datosTitularO (aliado:Aliado) (titular:string) =\n                aliado.contactos \n                |> Seq.tryPick(function | Direccion dir -> Some dir |_-> None)\n                |> Option.map (fun direccion -> \n                    customerAddressType(firstName = (titular.Split ' ').[0]\n                                    ,   lastName  = (titular.Split ' ' |> Seq.skip 1 |> String.concat \" \")\n                                    ,   address   = direccion.linea1\n                                    ,   city      = direccion.ciudad\n                                    ,   state     = direccion.estado    .ToString()\n                                    ,   zip       = direccion.zonaPostal.ToString()\n                                    ,   country   = direccion.pais      .ToString()\n                                    )\n                )\n        \n            let perfilPago (tipoPago: paymentType, titular: string) (aliado:Aliado) =\n                datosTitularO aliado titular\n                |> Option.map (fun datosTitular ->\n                    aliado,\n                    customerPaymentProfileType( payment = tipoPago\n                                            ,   billTo  = datosTitular )\n                )\n        \n            let registrarFormaPago (al, pp) =\n                buscarIdAuthorize al\n                |> Rsl.getResult\n                >>= function\n                    | Ok p -> registrarPagoNuevo   (p , pp)\n                    |_     -> registrarAliadoNuevo (al, pp)\n        \n            let crearFormaPago aid (tipoPago: paymentType, titular : string) =\n                ObtenerEstado.obtenerAliado aid\n                |>> perfilPago (tipoPago, titular)\n                |>  Rsl.absorbO (fun () -> \"No se encontro direccion\")\n                >>= registrarFormaPago\n        \n            let registrarTarjeta         aid (tc:TarjetaCredito) =\n                pagoTipoTarjeta tc\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Tarjeta registrada.\"\n        \n            let registrarCuenta          aid (cta: CuentaBancaria) =\n                pagoTipoCuenta cta\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Cuenta registrada.\"\n        \n            let validarFormaPago         aid (IdPayment idp) =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        validateCustomerPaymentProfileRequest(  customerProfileId        = idm\n                                                            ,   customerPaymentProfileId = idp\n                                                            ,   validationMode           = validationModeEnum.liveMode\n                        )\n                >*= validateCustomerPaymentProfileController\n                |>> fun response -> response.directResponse\n        \n            let obtenerAliadoEstadoPerfilSubIds idAl =\n                ObtenerEstado.obtenerAliadoEstado idAl\n                >>= fun (al,md) ->\n                        buscarPerfil al\n                        |>> fun (pe,subIds) -> al, md, pe, subIds\n        \n            let getSubscription sid =\n                ARBGetSubscriptionRequest(subscriptionId = sid, refId = sid)\n                |*> ARBGetSubscriptionController\n        \n            let obtenerAliadoEstadoPerfilSubActivos idAl =\n                obtenerAliadoEstadoPerfilSubIds     idAl\n                >>= fun  (al : Aliado, md : Modelo, pe, subIds)  ->\n                        subIds\n                        |> traverseSeq getSubscription \n                        |>> Seq.filter (fun s -> s.subscription.status = ARBSubscriptionStatusEnum.active)\n                        |>> fun subs -> (al, md, pe, subs)\n        \n            let obtenerAliadoEstadoPerfilSubActiva  idAl =\n                obtenerAliadoEstadoPerfilSubActivos idAl\n                |>> fun  (al : Aliado, md : Modelo, pe, subs)  ->\n                        subs\n                        |> Seq.tryHead\n                        |> fun subO -> (al, md, pe, subO)\n        \n            let obtenerFormasDePagoId aid =\n                obtenerAliadoEstadoPerfilSubActivos aid\n                |>> fun (al, md, perfil, subs) ->\n                        if perfil.paymentProfiles = null then [||] else perfil.paymentProfiles\n                        |> Array.choose (fun pago ->\n                            match pago.payment.Item with\n                            | :? AuthorizeNet.Api.Contracts.V1.creditCardMaskedType as cc -> \n                                TarjetaCredito {\n                                    titular       = pago.billTo.firstName + \" \" + pago.billTo.lastName\n                                    tipoTarjeta   = TipoTarjeta.tryParse cc.cardType |> Option.defaultValue Visa\n                                    numero        = NumeroTarjeta cc.cardNumber\n                                    expiracion    = { anio = 0 ; mes = Mes.Enero}\n                                } |> Some\n                            | :? AuthorizeNet.Api.Contracts.V1.bankAccountMaskedType as ba -> \n                                CuentaBancaria {\n                                    titular     = ba.nameOnAccount\n                                    banco       = ba.bankName\n                                    tipo        = match ba.accountType with\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.businessChecking\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.checking          -> Corriente\n                                                    |_-> Ahorro\n                                    numero      = NumeroCuenta  ba.accountNumber\n                                    routing     = RoutingNumber ba.routingNumber\n                                } |> Some\n                            |_-> None\n                            |> Option.map (fun cta ->\n                                {\n                                    nombre        = \"\"\n                                    authorizeIdR  = pago.customerPaymentProfileId |> IdPayment |> Ok\n                                    cuentaPago    = cta\n                                    subscripcion  = subs \n                                                    |> Seq.tryFind(fun sub -> sub.subscription.profile.paymentProfile.customerPaymentProfileId = pago.customerPaymentProfileId)\n                                                    |> Option.map (fun sub -> {\n                                                        idSubscripcion = IdSubscription sub.refId \n                                                        monto          = int sub.subscription.amount\n                                                        descripcion    =     sub.subscription.name\n                                                        inicio         =     sub.subscription.paymentSchedule.startDate\n                                                        status         = int sub.subscription.status\n                                                    })\n                                }\n                            )\n                        )\n                |>  Rsl.getResult\n                |>> Result.defaultValue [||]\n        \n        //    let obtenerFormasDePago aid =\n        //        fun () -> ObtenerEstado.obtenerAliado aid\n        //        >=> obtenerFormasDePagoId\n        \n            let obtenerFormasDePagoPara (alIds:_[]) = eff {\n                let! fps =\n                    alIds \n                    |> traverseSeq (fun id -> eff {\n                        let! fp = obtenerFormasDePagoId id\n                        return id, fp\n                    })\n                return fps |> Seq.toArray \n            }\n        \n            let crearSubscripcion aid (IdPayment idp) = \n                obtenerAliadoEstadoPerfilSubActiva aid \n                >>= fun  (al : Aliado, md : Modelo, pe, subO)  -> eff {\n                        let start = DateTime(DateTime.Today.Year, DateTime.Today.Month, Aliado.dia al.diaPago)\n                                    |> fun start -> if start < DateTime.Today               then start.AddMonths 1 else start\n                                    |> fun start -> if start < al.fechaRegistro.AddMonths 1 then start.AddMonths 1 else start\n                        let sub   = if subO.IsNone then \n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   paymentSchedule         = paymentScheduleType(  interval                    = paymentScheduleTypeInterval(length = int16 1, unit = ARBSubscriptionUnitEnum.months) \n                                                                                            ,   totalOccurrences            = int16 240\n                                                                                            ,   startDate                   = start)\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                                    else\n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                        return sub, subO\n                    }\n        \n            let createSubscription sub =\n                ARBCreateSubscriptionRequest(subscription = sub)\n                |*> ARBCreateSubscriptionController\n                |>> fun response -> response.subscriptionId\n        \n            let updateSubscription subId sub =\n                ARBUpdateSubscriptionRequest(subscription = sub, subscriptionId = subId)\n                |*> ARBUpdateSubscriptionController\n                |>> fun _response -> subId\n        \n            let actualizarSubscripcion aid idp =\n                crearSubscripcion aid idp\n                >>= function\n                    | subT, None     -> createSubscription           subT\n                    | subT, Some sub -> updateSubscription sub.refId subT // usando refId para guardar subscriptionId\n        \n            let getBatchDetalles bid = \n                getTransactionListRequest(  batchId = bid )\n                |*> getTransactionListController\n                |>> fun response -> response.transactions\n        \n            let buscarPerfilPorProfileId pid =\n                getCustomerProfileRequest(  customerProfileId = string pid )\n                |*> getCustomerProfileController\n                |>> fun response -> response.profile\n        \n            let getSubscriptions active =\n                ARBGetSubscriptionListRequest(searchType = (if active then ARBGetSubscriptionListSearchTypeEnum.subscriptionActive else ARBGetSubscriptionListSearchTypeEnum.subscriptionInactive) )\n                |*> ARBGetSubscriptionListController\n                |>> fun response -> response.subscriptionDetails\n                >>= traverseSeq (fun s -> buscarPerfilPorProfileId s.customerProfileId |>> (fun p -> s, p) )\n        \n            let cancelarSubscripcion sid =\n                ARBCancelSubscriptionRequest(subscriptionId = sid)\n                |*> ARBCancelSubscriptionController\n        \n            let borrarFormaPago aid (IdPayment idp) =\n                obtenerAliadoEstadoPerfilSubActiva aid \n                >>= fun (al : Aliado, md : Modelo, pe, subO)  -> eff {\n                        match subO with\n                        | Some sub when sub.subscription.profile.paymentProfile.customerPaymentProfileId = idp -> \n                                let! _ = cancelarSubscripcion sub.refId\n                                do!      Log.logf \"Subscripcion cancelada %s\" idp\n                                return al\n                        |_->    return al\n                }\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        deleteCustomerPaymentProfileRequest(customerProfileId        = idm\n                                                        ,   customerPaymentProfileId = idp\n                        )\n                >*= deleteCustomerPaymentProfileController\n                |>> fun response -> \"Forma de pago borrada.\"\n        \n            let toTransaccion aid (tr:transactionSummaryType) = {\n                fechaPago   = tr.submitTimeLocal\n                ano         = tr.submitTimeLocal.Year\n                periodo     = tr.submitTimeLocal.Month\n                monto       = int (tr.settleAmount * 100.00M)\n                idAliado    = aid\n                concepto    = ConceptoPago.Otro tr.accountNumber\n                transaccion = tr.transId\n                statusTran  = tr.transactionStatus\n            }\n        \n            let obtenerTransacciones nO =\n                let n = Option.defaultValue 0 nO\n                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths (-n-1) \n                                         ,   lastSettlementDate  = System.DateTime.Today.AddMonths (-n  ) )\n                |*> getSettledBatchListController\n                |>> fun response -> response.batchList\n                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )\n                |>> Seq.collect (snd >> Seq.filter(fun tr -> tr.subscription <> null || tr.profile <> null) )// >> Seq.map (toTransaccion <| IdAliado \"\"))\n        \n            let ResultToOption r = r |> Result.map Some |> Result.defaultValue None\n            let getOption eff = Rsl.getResult eff |>> ResultToOption\n        \n            let actualizarTransacciones nO = eff {\n                let! modelo   = ObtenerEstado.obtenerEstado()\n                let! ts       = obtenerTransacciones nO\n                let! perfs    = modelo.aliados |> traverseSeq (fun  al -> buscarPerfil al |>> (fun (p, subs) -> al, p, subs) |> getOption) |>> (Seq.choose id >> Seq.toArray)\n                let  subs     = perfs          |> Seq.collect (fun (al,_   ,sbs) -> sbs |>  Seq.map (fun sb -> sb, al.id )   ) |>  Seq.toArray\n                let  ids      = perfs          |> Seq.map     (fun (al,perf, _ ) ->        perf.customerProfileId, al.id     ) |>  Seq.toArray\n                do!     ts \n                        |> Seq.choose(fun tr ->\n                            if   tr.subscription <> null then subs |> Seq.tryFind (fst >> (=) (string tr.subscription.id   ) ) |> Option.map snd\n                            elif tr.profile      <> null then ids  |> Seq.tryFind (fst >> (=) tr.profile.customerProfileId   ) |> Option.map snd\n                            else None\n                            |> Option.map (swap toTransaccion tr) )\n                        |> Seq.toArray\n                        |> ObtenerEstado.salvarTransaccsE\n            }\n        \n            let obtenerTransaccionesPara aid = eff {\n                let! modelo   = ObtenerEstado.obtenerEstadoParaUsuario aid false\n                let  aids     = modelo.aliados |> Seq.map(fun al -> al.id) |> Set\n                let! ts       = ObtenerEstado.leerTransaccsE ()\n                return ts |> Array.filter (fun tr -> aids |> Set.contains tr.idAliado)\n            }\n        \n            let getSubscriptionTransactions () =\n                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths -1 \n                                         ,   lastSettlementDate = System.DateTime.Now)\n                |*> getSettledBatchListController\n                |>> fun response -> response.batchList\n                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )\n                |>>(Seq.map   (fun (b,ts) -> b, ts |> Seq.filter(fun t -> t.subscription <> null) )\n                 >> Seq.filter(fun (b,ts) ->    ts |> Seq.isEmpty |> not )\n                   )\n        \n            let SubsYTransacciones () =\n                getSubscriptionTransactions()\n                |>> Seq.collect (fun (b, ts) -> ts |> Seq.map (fun t -> b, t))\n                >>= fun ts -> eff {\n                        let! subs = getSubscriptions true\n                        return ts, subs \n                    }\n                >>=! (fun (ts, subs) -> eff {\n                        let orphans = ts |> Seq.filter(fun (b,t) -> subs |> Seq.exists (fun (s,p) -> s.id = t.subscription.id) |> not) |> Seq.toArray\n                        for b, t in orphans do\n                            do! Log.logf \"Huerfano: %A\" (\n                                        b.batchId\n                                        , t.accountNumber\n                                        , t.accountType\n                                        , t.firstName\n                                        , t.lastName\n                                        , t.settleAmount\n                                        , t.subscription.id\n                                        , t.subscription.payNum\n                                        , t.transactionStatus\n                                        , t.transId )\n                    })\n                |>> fun (ts, subs) ->  subs |> Seq.map(fun (sub,p) -> sub,p, ts |> Seq.filter (fun (b,t) -> t.subscription.id = sub.id) )\n        \n            //type H() =\n            //    interface Rsl.Rsl<string>\n            //    interface Log.Log<string>\n            //    interface VariableAmbienteI with member __.getVar  v  = failwith \"VariableAmbienteI.getVar not implemented\"\n            //    interface AuthorizeI<H>     with member __.execute c  = failwith \"AuthorizeI<H>.Execute not implemented\"\n            //                                     member __.prepare () = failwith \"AuthorizeI<H>.Prepare not implemented\"\n            //    interface EstadoI with\n            //            member __.UltimoEvento      ()  = failwith \"EstadoI.UltimoEvento not implemented\"\n            //            member __.UltimoEstado      ()  = failwith \"EstadoI.UltimoEstado not implemented\"\n            //            member __.LeerEventos       p   = failwith \"EstadoI.LeerEventos not implemented\"\n            //            member __.LeerTipos         ()  = failwith \"EstadoI.LeerTipos not implemented\"\n            //            member __.LeerEventosTipos  ()  = failwith \"EstadoI.LeerEventosTipos not implemented\"\n            //            member __.GuardarEstado     p q = failwith \"EstadoI.GuardarEstado not implemented\"\n            //            member __.GuardarAliado     p q = failwith \"EstadoI.GuardarAliado not implemented\"\n            //            member __.ObtenerEstado     ()  = failwith \"EstadoI.ObtenerEstado not implemented\"\n            //            member __.ObtenerAliados    ()  = failwith \"EstadoI.ObtenerAliados not implemented\"\n        \n            let voidTransaction tid =\n                transactionRequestType(transactionType = \"voidTransaction\", refTransId = tid)\n                |>  fun trt -> createTransactionRequest(transactionRequest = trt)\n                |*> createTransactionController\n        \n            let obtenerTransaccionesReq aid req =\n                req\n                |*>  getTransactionListForCustomerController\n                |>>  fun resp ->\n                        if resp.transactions = null then [||] else \n                        resp.transactions\n                        |> Array.map (toTransaccion aid)\n        \n            let obtenerTransaccionesAliado aid =\n                ObtenerEstado.obtenerAliado aid\n                >>=  buscarPerfil\n                >>=! fun (perfil,_) -> Log.logf \"Perfil: %A %A %A\" perfil.customerProfileId perfil.description perfil.email\n                |>>  fun (perfil,_) -> getTransactionListForCustomerRequest( customerProfileId = perfil.customerProfileId)\n                >>=  obtenerTransaccionesReq aid\n        \n            let xobtenerTransaccionesForPayment aid pid =\n                ObtenerEstado.obtenerAliado aid\n                >>=  buscarPerfil\n                >>=! fun (perfil,_) -> Log.logf \"Perfil: %A %A %A\" perfil.customerProfileId perfil.description perfil.email\n                |>>  fun (perfil,_) -> getTransactionListForCustomerRequest( customerProfileId = perfil.customerProfileId, customerPaymentProfileId = pid)\n                >>=  obtenerTransaccionesReq aid          \n        \n            let xxobtenerTransaccionesPara aid = eff {\n                let! perfil, subs = ObtenerEstado.obtenerAliado aid >>= buscarPerfil\n                let! ats = getSubscriptionTransactions ()\n                let! ts2 = obtenerTransaccionesAliado aid\n                let  ts  = ats |> Seq.collect( fun (a,ts) -> ts) \n                return \n                    ts\n                    |> Seq.filter (fun tr -> subs |> Seq.contains (string tr.subscription.id) )\n                    |> Seq.map (toTransaccion aid)\n                    |> Seq.append ts2\n                    |> Seq.toArray\n            }\n        \n        \n         [< JavaScript >]\n        type DataEvento =\n        | AgregarAliados            of (Aliado[]                                                   )\n        | AgregarAliado             of (Aliado                                                     )\n        | InvitarPotencialesAliados of (IdAliado * string []                                       )\n        | RegistroNuevo             of (IdAliado * DatosPersonales * IdAliado option * Contacto [] )\n        | ActualizarDatosPersonales of (IdAliado * DatosPersonales                                 )\n        | ActualizarContactos       of (IdAliado * Contacto  []                                    )\n        //| ActualizarFormasPago      of (IdAliado * FormaPago []                                    )\n        | CorreoVerificacionEnviado of (IdAliado * string                                          )\n        | CorreoVerificado          of (IdAliado * string                                          )\n        //| ActualizarAuthorizeId     of (IdAliado * Result<IdAuthorize, string>                     )\n        //| ActualizarPagoAuthorizeId of (IdAliado * CuentaPago * Result<IdPayment, string>          )\n        | ActualizarStatusPadre     of (IdAliado * StatusAliado * (IdAliado option) * string option)\n        | ActualizarArchivos        of (IdAliado * Archivo []                                      )\n        \n        [< JavaScript >]\n        type Evento = {\n            nevento : int64\n            aliadoO : IdAliado option\n            data    : DataEvento\n        }\n        \n        [< JavaScript >]\n        type Respuesta =\n        | ROk\n        | NuevoRegistro        of string\n        | Mensaje              of string\n        \n        module Eventos =\n        \n            type TipoDatos = TipoDatos of nombre:string * tipos:string\n        \n            type ResultadoManejador<'H> = Modelo -> Eff<'H,Modelo * Respuesta>\n        \n            type ObjetoDatos<'T> = {\n                tipoDatos : TipoDatos\n                datos     : 'T\n            }\n        \n            type ManejadorDatos<'T, 'H> = {\n                tipoDatos  : TipoDatos\n                manejadorF : ObjetoDatos<'T> -> ResultadoManejador<'H>\n            }\n        \n            type EventosI<'H> =\n                abstract ManejadorGenerico    : ObjetoDatos<obj> -> ResultadoManejador<'H>\n                abstract GuardarArchivo<'H>   : Archivo          -> Eff<'H, unit>\n                abstract ObtenerListaDocs<'H> : IdAliado         -> Eff<'H, Archivo     []>\n        \n            let manejadorGenericoE msg modelo    = Reader.ask() >>= fun (h:#EventosI<_>) -> h.ManejadorGenerico msg modelo\n            let guardarArchivo (archivo:Archivo) = Reader.ask() >>= fun (h:#EventosI<_>) -> h.GuardarArchivo archivo\n            let obtenerListaDocs  alid           = Reader.ask() >>= fun (h:#EventosI<_>) -> h.ObtenerListaDocs alid                 \n        \n            let xManejadores<'H> = System.Collections.Generic.Dictionary<TipoDatos, ManejadorDatos<obj,'H>>()\n        \n            let deDatosGen (msg: ObjetoDatos<obj>) : ObjetoDatos<_> = {\n                tipoDatos = msg.tipoDatos\n                datos     = unbox msg.datos\n            }    \n        \n            let xregistrarManejador nombre (manejadorF:ObjetoDatos<'T> -> ResultadoManejador<_>) =\n                let manejador  = {\n                    tipoDatos  = TipoDatos (nombre, typeof<'T> |> getTypeName) |>! print\n                    manejadorF = deDatosGen >> manejadorF\n                }\n                xManejadores.Add(manejador.tipoDatos, manejador )\n        \n            let genManejador nombre (manejadorF:'T -> ResultadoManejador<_>) = {\n                tipoDatos  = TipoDatos (nombre, typeof<'T> |> getTypeName) |>! print\n                manejadorF = deDatosGen >> (fun oDatos -> manejadorF oDatos.datos)\n            }\n        \n            let xregistrarManejadorf nombre (manejadorF:'T -> ResultadoManejador<_>) =\n                xregistrarManejador  nombre (fun oDatos -> manejadorF oDatos.datos)\n        \n            //let xmanejadorGenerico (msg:ObjetoDatos<obj>) : ResultadoManejador<_> =\n            //    match Manejadores.TryGetValue msg.tipoDatos with\n            //    | false, _         -> failwithf \"No Handler for message: %A \\n handlers: [%s]\" msg (Manejadores.Keys |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\")\n            //    | true , manejador -> manejador.manejadorF msg\n        \n            let addNewAliados (als1: Aliado []) (als2: Aliado []) : Aliado [] =\n                als1 |> Seq.filter(fun a -> als2 |> Seq.exists (fun b -> a.id = b.id ) |> not ) |> Seq.append als2 |> Seq.toArray\n        \n            let registroNuevo (idA, datos:DatosPersonales, padre, contactos) (modelo: Modelo) : Eff<'H,Modelo * Respuesta> = eff {\n                match   contactos\n                        |> Seq.tryPick(function CorreoElectronico email -> Some email |_-> None ) with\n                | None        -> return! sprintf \"No se encontro Correo Electronico: %A\" datos |> Error |> Rsl.ofResult\n                | Some correo ->\n                if  modelo.aliados\n                    |> Seq.exists(fun al ->\n                        al.contactos\n                        |> Seq.exists(function CorreoElectronico correo2 -> correo = correo2 |_-> false ) \n                    )\n                    then return! sprintf \"Correo Electronico ya esta registrado: %A\" correo |> Error |> Rsl.ofResult\n                else\n                if modelo.aliados |> Seq.exists (fun al -> al.id = idA) \n                    then return! sprintf \"Id ya esta en uso: %A\" idA                        |> Error |> Rsl.ofResult\n                else\n                let now = System.DateTime.Now\n                let aliado = {\n                    datosPersonales =  datos\n                    id              =  idA\n                    idPadreO        =  padre\n                    idForAuthorize  =  None\n                    influyente      =  None\n                    contactos       =  contactos\n                    identificacion  =  [||]\n                    isInternal      =  false\n                    status          =  CuentaCreada\n                    tipo            =  Regular\n                    fechaRegistro   =  now\n                    fechaStatus     =  now\n                    diaPago         =  Dia01\n                    nReferidos      =  0\n                    nRefActivos     =  0\n                    nDescendientes  =  0\n                    nDescActivos    =  0\n                    comision        =  0\n                    nivel           =  0\n                    documentos      =  0\n                    docPendientes   =  0\n                }\n                return\n                    { modelo with aliados = Array.append modelo.aliados [| aliado |] }\n                ,   [ datos.nombre1 ; datos.nombre2 ; datos.apellido1 ; datos.apellido2 ] \n                    |> String.concat \" \"\n                    |> NuevoRegistro  \n            }\n        \n            let cambiaAliado ida   f (modelo:Modelo) = { modelo with aliados    = modelo.aliados          |> Array.map (fun al -> if al.id = ida then f al else al )}\n            let cambiaCorreo email f (aliado:Aliado) = { aliado with contactos  = aliado.contactos        |> Array.map (function CorreoElectronico c when c.email = email -> f c |> CorreoElectronico | co -> co )}\n            //let cambiaFormaPago cp f (aliado:Aliado) = { aliado with formasPago = aliado.formasPago.Value |> Array.map (fun fp -> if fp.cuentaPago = cp then f fp else fp ) }\n            let cambiaStatusCorreo ida email f = cambiaAliado ida (cambiaCorreo email  f)\n        \n            let actualizarDatosPersonales (idA, datos:DatosPersonales) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with datosPersonales = datos }) modelo\n                ,   Mensaje <| \"Datos personales actualizados!\" \n            }\n        \n            //let actualizarAuthorizeId   (idA, authorizeIdR) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with authorizeIdR = authorizeIdR }) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            //let actualizarPagoAuthorizeId (idA, cuenta, paymentIdR : Result<IdPayment, string> )  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (cambiaFormaPago cuenta (fun fp -> { fp with authorizeIdR = paymentIdR }) ) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            let actualizarContactos (idA, contactos:Contacto[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with contactos = contactos }) modelo\n                ,   Mensaje <| \"Contactos actualizados!\" \n            }\n        \n            let actualizarStatusPadre (idA, status:StatusAliado, padreO:IdAliado option, inflO :  string option) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with status = status ; idPadreO = padreO ; influyente = inflO }) modelo\n                ,   Mensaje <| \"status actualizados!\" \n            }\n        \n            //let actualizarFormasPago (idA, formasPago:FormaPago[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with formasPago = formasPago }) modelo\n            //    ,  Mensaje <| \"Formas de pago actualizadas!\" \n            //}\n        \n            let agregarAliado  aliado  modelo = eff { return { modelo with Modelo.aliados = addNewAliados [| aliado  |] modelo.aliados }, ROk }\n            let agregarAliados aliados modelo = eff { return { modelo with Modelo.aliados = addNewAliados    aliados    modelo.aliados }, ROk }\n        \n            let correoVerificacionEnviado (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with enviado = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let correoVerificado          (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with recibido = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let actualizarEstado (modelo: Modelo, evento: Evento) = eff {\n                if modelo.nevento <> -1L && modelo.nevento + 1L <> evento.nevento then \n                    failwithf \"Evento fuera de secuencia: %d %d\" modelo.nevento evento.nevento\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                let objData           = {\n                    tipoDatos         = TipoDatos(case, tuple |> getTypeName)\n                    datos             = data\n                }\n                return! manejadorGenericoE objData modelo\n            }\n        \n            let actualizarArchivos (idA:IdAliado, archivos:Archivo[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                for ar in archivos do\n                    do! guardarArchivo ar\n                let! ars  = obtenerListaDocs idA\n                let  n    = ars.Length\n                let  p    = ars |> Seq.filter (fun d -> d.status = Subido || d.status = Cambiado) |> Seq.length\n                return\n                    cambiaAliado idA (fun al -> { al with documentos = n ; docPendientes = p }) modelo\n                ,   Mensaje <| \"Archivos actualizados!\" \n            }\n        \n        \n            let eventoNoImplementado ev (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return! sprintf \"Evento no Implementado: %A\" ev |> Error |> Rsl.ofResult\n            } \n        \n            let invitarPotencialesAliados ev = eventoNoImplementado ev\n        module SerializadorEventos =\n            open Serializador\n            open Serializer\n            open System\n        \n            open FSharp.Reflection\n        \n            let serObject : Ser<obj> = (fun o -> o.GetType().ToString() |> sprintf \"%A\"), (fun _ -> None)\n        \n            let serSerializadoresEventos =\n                let sers = System.Collections.Generic.Dictionary<_,_>()\n                [\n                    serObj         serObject\n                    serObj         serString\n                    serObj         serAliado\n                    serObj         serIdAliado\n                    serObj         serIdAuthorized\n                    serObj (serOpt serIdAliado )\n                    serObj (serArr serContacto )\n                    serObj (serArr serFormaPago)\n                    serObj (serArr serAliado   )\n                    serObj (serArr serString   )\n                    serObj         serDatosPersonales\n                    serObj         serIdAuthorizedR\n                    serObj         serCuentaPago\n                    serObj         serIdPaymentR\n                    serObj (serArr serArchivo  )\n                ] |> Seq.iter sers.Add\n                sers\n        \n            let rec registrarSerializadorParaTipos (ts:System.Type []) =\n                if Seq.length ts <= 1 then () else\n                let tupleType = FSharpType.MakeTupleType ts\n                let tname     = getTypeName tupleType\n                if serSerializadoresEventos.ContainsKey tname then () else\n                let sers      = ts |> Array.map (fun t ->   let tname = getTypeName  t\n                                                            serSerializadoresEventos \n                                                            |> Dict.tryGetValue tname \n                                                            |> Option.defaultWith (fun () -> failwithf \"Serializador no encontrado: %s\" tname) )\n                let getValues = FSharpValue.PreComputeTupleReader      tupleType\n                let setValues = FSharpValue.PreComputeTupleConstructor tupleType\n                let serC    v = Seq.zip (getValues v) sers\n                                |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                |> String.concat \", \"\n                                |> sprintf \"[%s]\"\n                let deserC (j:JsonIntermediate) = \n                                match j.tryArray () with\n                                | None -> None\n                                | Some js -> \n                                Array.zip js sers\n                                |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                |> setValues\n                                |> Some\n                serSerializadoresEventos.Add(tname, (serC, deserC))\n        \n            and registrarSerializadoresParaDU (ttype:System.Type) =\n                FSharpType.GetUnionCases ttype\n                |> Seq.iter(fun case ->\n                    let ts = case.GetFields() |> Array.map(fun p -> p.PropertyType) \n                    ts |> Seq.iter registrarSerializadorPara \n                    ts |> registrarSerializadorParaTipos\n                )\n        \n            and registrarSerializadorPara (ttype:System.Type) =\n                let tname = getTypeName ttype\n                if serSerializadoresEventos.ContainsKey tname then () else\n                if   FSharpType.IsUnion ttype then \n                    registrarSerializadoresParaDU ttype\n                    if serSerializadoresEventos.ContainsKey tname then () else\n                    let ser = Serializer.serDUt (Seq.zip serSerializadoresEventos.Keys serSerializadoresEventos.Values) ttype\n                    serSerializadoresEventos.Add(tname, ser)\n                elif FSharpType.IsTuple ttype then\n                    let ts = FSharpType.GetTupleElements ttype\n                    ts |> Seq.iter registrarSerializadorPara\n                    registrarSerializadorParaTipos ts\n                else\n                    failwithf \"Could not register serializer for: %s\" tname\n        \n            registrarSerializadorPara typeof<DataEvento>\n        \n            let obtenerSerializador tipoEvento = \n                serSerializadoresEventos \n                |> Dict.tryGetValue tipoEvento\n                |> Option.defaultWith (fun () -> failwithf \"Could not find deserializer for %s\" tipoEvento)\n        \n        \n            let registrarF add evento (f : 'T -> Eventos.ResultadoManejador<_>) =\n                Eventos.genManejador evento f |> add\n                registrarSerializadorPara typeof<'T>\n        \n            //open CodigoGenerado\n        \n        //    let chequearEventosEnBD et =\n        //        match et with\n        //        | ActualizarDatosPersonales_V0  v -> Eventos.actualizarDatosPersonales  v\n                //| ActualizarFormasPago_V0       v -> Eventos.actualizarFormasPago       v\n                //| AgregarAliado_V1              v -> Eventos.agregarAliado              v\n                //| RegistroNuevo_V1              v -> Eventos.registroNuevo              v\n                //| CorreoVerificacionEnviado_V0  v -> Eventos.correoVerificacionEnviado  v\n        \n            let chequearEventos ev =\n                match ev with\n                | AgregarAliado                 v -> Eventos.agregarAliado              v\n                | AgregarAliados                v -> Eventos.agregarAliados             v\n                | RegistroNuevo                 v -> Eventos.registroNuevo              v\n                | ActualizarDatosPersonales     v -> Eventos.actualizarDatosPersonales  v\n                | ActualizarContactos           v -> Eventos.actualizarContactos        v\n                //| ActualizarFormasPago          v -> Eventos.actualizarFormasPago       v\n                | CorreoVerificacionEnviado     v -> Eventos.correoVerificacionEnviado  v\n                | CorreoVerificado              v -> Eventos.correoVerificado           v\n                | InvitarPotencialesAliados     v -> Eventos.invitarPotencialesAliados  v\n                //| ActualizarAuthorizeId         v -> Eventos.actualizarAuthorizeId      v\n                //| ActualizarPagoAuthorizeId     v -> Eventos.actualizarPagoAuthorizeId  v\n                | ActualizarStatusPadre         v -> Eventos.actualizarStatusPadre      v\n                | ActualizarArchivos            v -> Eventos.actualizarArchivos         v\n        \n            let registrarEventos add =\n                registrarF add \"AgregarAliado\"             Eventos.agregarAliado\n                registrarF add \"AgregarAliados\"            Eventos.agregarAliados\n                registrarF add \"RegistroNuevo\"             Eventos.registroNuevo\n                registrarF add \"ActualizarDatosPersonales\" Eventos.actualizarDatosPersonales\n                registrarF add \"ActualizarContactos\"       Eventos.actualizarContactos\n                //registrarF add \"ActualizarFormasPago\"      Eventos.actualizarFormasPago\n                registrarF add \"CorreoVerificacionEnviado\" Eventos.correoVerificacionEnviado\n                registrarF add \"CorreoVerificado\"          Eventos.correoVerificado\n                registrarF add \"InvitarPotencialesAliados\" Eventos.invitarPotencialesAliados\n                //registrarF add \"ActualizarAuthorizeId\"     Eventos.actualizarAuthorizeId\n                //registrarF add \"ActualizarPagoAuthorizeId\" Eventos.actualizarPagoAuthorizeId\n                registrarF add \"ActualizarStatusPadre\"     Eventos.actualizarStatusPadre\n                registrarF add \"ActualizarArchivos\"        Eventos.actualizarArchivos\n        \n            //SQLServer.leerTipos()\n            //|> Seq.iter (fun t ->\n            //    if serSerializadoresEventos.ContainsKey t |> not then\n            //        failwithf \"Serializador no encontrado para tipo %s\" t\n            //)\n        //\n            //SQLServer.leerEventosTipos()\n            //    |> Seq.iter (fun t ->\n            //    if Eventos.TipoDatos t |> Eventos.Manejadores.ContainsKey |> not then\n            //        failwithf \"Manejador no encontrado para evento %A\" t\n            //)\n        \n        \n        \n        module Correo =\n            open System.IO\n            open WebSharper.UI.Server\n        \n            type EmailI<'H> = abstract member SendEmail : string -> string -> string -> Eff<'H, unit>\n            let sendEmail (recipiente:string) (tema:string) (contenido:string)  = Reader.ask() >>= fun (h:#EmailI<'H>) -> h.SendEmail recipiente tema contenido\n        \n            let dummyCtxE() =\n                carpetaRaiz()\n                |>> fun raiz ->\n                        { new WebSharper.Web.Context() with\n                            member this.RootFolder      = raiz\n                            member this.RequestUri      = failwith \"Unsupported\"\n                            member this.UserSession     = failwith \"Unsupported\"\n                            member this.Environment     = failwith \"Unsupported\"\n                            member this.Json            = failwith \"Unsupported\"\n                            member this.Metadata        = failwith \"Unsupported\"\n                            member this.Dependencies    = failwith \"Unsupported\"\n                            member this.ApplicationPath = failwith \"Unsupported\"\n                            member this.ResourceContext = failwith \"Unsupported\" }\n        \n            let prepareHtml (doc:Doc) =\n                dummyCtxE()\n                |>> fun dummyCtx ->\n                        use tw  = new StringWriter()\n                        use w   = new Core.Resources.HtmlTextWriter(tw, \" \")        \n                        doc.Write(dummyCtx, w, false)\n                        tw.ToString()\n        \n            open WebSharper.UI.Templating\n         \n            let [< Literal >] TemplatesCorreos = @\"Correos.html\" \n            type TemplateCorreo = Template<TemplatesCorreos, serverLoad = ServerLoad.PerRequest>\n        \n            let hostE() = variableAmbienteE \"Website\" |>> sprintf \"https://%s\"\n        \n            let SendGridAPIKey = \"\"\n         \n            let enviarCorreoInvitacion tema (IdAliado idPadre) (email:string)= \n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Invitacion() \n                            .Logo(   TemplateCorreo.Logo().Doc()    )\n                            .Host( host                           )\n                            .IdPadre(idPadre                        )\n                            .Doc()\n                >>= prepareHtml\n                >>= sendEmail email tema\n        \n            let enviarCorreosInvitacion (tema, padre, emails:string[]) = eff {\n                for email in emails do\n                    do! enviarCorreoInvitacion tema padre email\n            }\n        \n            let enviarBienvenida (aliado:Aliado) (correo:CorreoElectronico) =\n                let sufijo = match aliado.datosPersonales.genero with Femenino -> \"a\" |_-> \"o\"\n                let nombre = Aliado.nombre2 aliado.datosPersonales\n                let tema   = sprintf \"Prozper le da la bienvenida\"\n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Bienvenida()\n                                .Logo(   TemplateCorreo.Logo().Doc())\n                                .Host(          host                )\n                                .Sufijo(        sufijo              )\n                                .NombreAfiliado(nombre              )\n                                .Doc()\n                >>= prepareHtml\n                >>= sendEmail correo.email tema\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n            let enviarVerificacionCorreo (aliado:Aliado) (correo:CorreoElectronico) =\n                WebSharper.UI.Html.div [] [ WebSharper.UI.Html.text \"CORREO CONTENIDO\" ]\n                |>  prepareHtml\n                >>= sendEmail correo.email \"Verificacion de Correo\"\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n        \n        \n        module ManejadorEventos =\n            //open ObtenerEstado\n        \n            type ManejadorI<'H> =\n                abstract member NuevoEvento<     'H> : string   -> string -> string -> string -> Eff<'H, int64         >\n                abstract member UltimoEvento<    'H> : unit     ->                               Eff<'H, int64 option  >\n                abstract member EnviarMensaje<   'H> : string   -> string -> string -> string -> Eff<'H, unit          >\n        \n            let nuevoEvento   (usuario:string) (nombre:string) (evento:string) (tipo:string) = Reader.ask() >>= fun (h:#ManejadorI<'H>) -> h.NuevoEvento usuario nombre evento tipo\n            let enviarMensaje (d:string) (r:string) (t:string) (c:string)                    = Reader.ask() >>= fun (h:#ManejadorI<'H>) -> h.EnviarMensaje d r t c                 \n        \n            type SerialEvento = {\n                nombre  : string\n                tipo    : string\n                json    : string\n                data    : obj\n            }\n        \n            type SerialEventoU = {\n                usuario   : string\n                serEvento : SerialEvento\n            }\n        \n            type SerialEventoN = {\n                nevento    : int64\n                serEventoU : SerialEventoU\n            }\n        \n            let deserializarEvento (serEvento : SerialEvento) =\n                let ser = SerializadorEventos.obtenerSerializador serEvento.tipo\n                match Serializer.deserializeWithDefs ser serEvento.json with\n                | Some data -> data\n                | None      -> failwithf \"No se pudo deserializar el Evento: %A\" serEvento\n        \n            let manejadorGenerico msg = \n                ObtenerEstado.obtenerEstado()\n                >>= fun estadoO -> \n                        Eventos.manejadorGenericoE msg estadoO\n                        |>  Rsl.getResult\n                        |>> function \n                            | Ok (estadoN, r) -> estadoN, Ok    r\n                            | Error m         -> estadoO, Error m\n        \n            let serialN2serialU (serEventoN: SerialEventoN) = serEventoN.serEventoU\n        \n            let serialU2TipoDatos (serEventoU: SerialEventoU) =\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(serEventoU.serEvento.nombre, serEventoU.serEvento.tipo)\n                    Eventos.datos     = serEventoU.serEvento.data\n                }\n        \n            let evento2TipoDatos (evento:Evento) =\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(case, tuple |> getTypeName)\n                    Eventos.datos     = data\n                }\n        \n            let separarEstado (modeloI:Modelo, eventoSerialN : SerialEventoN) oR =  \n                let modelo = oR |> Result.map fst |> Result.defaultValue modeloI\n                let resp   = oR |> Result.map snd\n                { modelo with nevento = eventoSerialN.nevento }, resp\n        \n            let ejecutarEventoSerial ev =\n                ev\n                |> serialN2serialU \n                |> serialU2TipoDatos\n                |> manejadorGenerico\n                >>= EA.tee (fst >> ObtenerEstado.guardarEstado ev.nevento)\n                |>> snd\n                |>  Rsl.absorbR\n        \n            let guardarEventoSerialU (serEventoU :  SerialEventoU) = \n                nuevoEvento\n                    serEventoU.usuario\n                    serEventoU.serEvento.nombre\n                    serEventoU.serEvento.json\n                    serEventoU.serEvento.tipo\n        \n            let serializarDataEvento (evento : DataEvento) =\n                let  name, ttype, obj = DiscUnion.caseTuple evento\n                let  tname            = ttype |> getTypeName\n                let  ser              = SerializadorEventos.obtenerSerializador tname\n                {   nombre            = name\n                    tipo              = tname\n                    json              = fst ser obj\n                    data              = obj\n                }\n        \n            let guardarEventoSerial  serEventoU =\n                guardarEventoSerialU serEventoU\n                |>> fun nevento  -> { nevento = nevento ; serEventoU = serEventoU }\n        \n            let serializarEvento (evento:Evento) =\n                evento.aliadoO \n                |> Option.map(fun (IdAliado usuario) -> { usuario = usuario ; serEvento  = serializarDataEvento evento.data })\n                |> Result.ofOption (fun () -> sprintf \"Aliado es Nulo para evento %A\" evento)\n                |> Rsl.ofResult\n        \n            let intentarEventoSerial ev =\n                serialU2TipoDatos ev\n                |>  manejadorGenerico\n                |>> snd\n                |>  Rsl.absorbR\n                |>> ignore\n        \n            let ejecutarEventoNuevo ev =\n                serializarEvento ev\n                >>= EA.tee intentarEventoSerial\n                >>= guardarEventoSerial\n                >>= fun inp ->\n                        ejecutarEventoSerial inp\n                        >>= EA.tee (fun out ->  enviarMensaje \"\" inp.serEventoU.usuario (sprintf \"%A\" out) \"\")\n        \n            let ejecutarDataEventoNuevo  claims de =\n                ObtenerEstado.obtenerAliado claims\n                |>> fun al ->\n                        {\n                            Evento.nevento = 0L\n                            Evento.aliadoO = Some al.id\n                            data           = de\n                        }\n                >>= ejecutarEventoNuevo\n        \n            let obtenerClaim claim claims =\n                claims \n                |>  Array.tryFind(fun (n,v) -> n = claim) \n                |>  Option.map snd\n        \n            let enviarBienvenida aid = \n                ObtenerEstado.obtenerAliado aid\n                >>= fun (aliado:Aliado) -> eff {\n                    for contacto in aliado.contactos do\n                        match contacto with\n                        | CorreoElectronico correo -> \n                            match correo.enviado with\n                            | None -> do! Correo.enviarBienvenida aliado correo\n                            |_-> ()\n                        | _ -> ()\n                }\n                \n            let crearRegistroNuevo (aid:IdAliado) claims (modelo:Modelo) = eff {\n                if  aid.Id    = \"admin\" || (modelo.aliados |> Array.exists (fun al -> al.id = aid)) then return None else\n                let datos     = \n                    { Default.value<DatosPersonales> with \n                        nombre1         = claims |> obtenerClaim \"given_name\"                                              |> Option.defaultValue \"\"\n                        apellido1       = claims |> obtenerClaim \"family_name\"                                             |> Option.defaultValue \"\"\n                        fechaNacimiento = claims |> obtenerClaim \"extension_DateOfBirth\" |> Option.bind ParseO.parseDateO2 |> Option.defaultValue System.DateTime.MinValue\n                    }\n                let correo    = \n                    { Default.value<CorreoElectronico> with \n                        email           = claims |> obtenerClaim \"emails\" |> Option.defaultValue \"\"\n                    }\n                let direccion    = \n                    { Default.value<Direccion> with \n                        linea1          = claims |> obtenerClaim \"streetAddress\" |> Option.defaultValue \"\"\n                        ciudad          = claims |> obtenerClaim \"city\"          |> Option.defaultValue \"\"\n                        estado          = claims |> obtenerClaim \"state\"         |> Option.bind Estado    .tryParse |> Option.defaultValue (OtroS      \"\")\n                        zonaPostal      = claims |> obtenerClaim \"postalCode\"    |> Option.bind ZonaPostal.tryParse |> Option.defaultValue (ZonaPostal \"\")\n                        pais            = claims |> obtenerClaim \"country\"       |> Option.bind Pais      .tryParse |> Option.defaultValue (OtroP      \"\")\n                        authorizeIdR    = Error \"\"\n                    }\n                let contactos = [| CorreoElectronico correo ; Direccion direccion |]\n                let referidoPor = \n                    claims \n                    |> obtenerClaim \"referidoPor\" \n                    |> Option.bind (function \"\" -> None | s -> Some s)\n                    |> Option.bind (fun ref -> modelo.aliados |> Seq.tryFind(fun padre -> padre.id.Id = ref))\n                    |> Option.map  (fun padre -> padre.id)\n                do! Log.logf \"referidoPor = %A\" referidoPor\n                //Correo.enviarBienvenida aliado // (**) mover afuera\n                return Some\n                    {\n                        Evento.nevento = 0L\n                        Evento.aliadoO = Some aid\n                        data           = DataEvento.RegistroNuevo(aid, datos, referidoPor, contactos)\n                    }\n            }\n        \n            let agregarUsuarioSiEsNuevo claims1 claims =\n                ObtenerEstado.obtenerEstado()\n                >>= crearRegistroNuevo claims1 claims        \n                |>  bindO ejecutarEventoNuevo                \n                |>  bindO (fun _ -> enviarBienvenida claims1)\n                |>  bindO (Log.logf \"agregarUsuarioSiEsNuevo: %A\")\n                |>> Option.iter id\n        \n            let obtenerListaDocs aid = eff {\n                let! al = ObtenerEstado.obtenerAliado aid\n                return!   Eventos.obtenerListaDocs al.id\n            }\n        \n            let obtenerInfluyente (inf:string) =\n                ObtenerEstado.obtenerEstado()\n                |>> fun es -> \n                        let infO = Some (inf.Trim().ToLower())\n                        es.aliados \n                        |> Seq.tryFind (fun al -> al.influyente = infO )\n                        |> Result.ofOption (fun () -> sprintf \"Influyente no encontrado : %s\" inf)\n                |>  Rsl.absorbR\n        \n            let obtenerIdInfluyente inf =\n                obtenerInfluyente   inf\n                |>> fun al -> al.id.Id\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n        module Azure =\n            open System\n            open System.IO\n        //    open Microsoft.Azure\n        //    open Microsoft.Azure.Storage\n        //    //open Microsoft.Azure.Storage.Table\n        //    open Microsoft.Azure.Storage.Queue\n        //    open Microsoft.Azure.Storage.Blob\n        //    open Microsoft.Azure.Storage.Core\n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n            open Microsoft.WindowsAzure.Storage.Table\n        \n            let storageSetting      =  \"APPSETTING_AzureWebJobsStorage\"\n            let aliadosTableName    =  \"Aliados\"\n            let eventosTableName    =  \"Eventos\"\n            let mensajesTableName   =  \"Mensajes\"\n            let estadoTableName     =  \"Modelo\"\n            let transacTableName    =  \"Transacciones\"\n            let archivosTableName   =  \"Archivos\"\n            let correosQueueName    =  \"correos\"\n            let mensajesQueueName   =  \"mensajes\"\n            let storageAccountE()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let storageAccountC()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let tableClientE   ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudTableClient()\n            let queueClientE   ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudQueueClient()\n            let blobClientE    ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudBlobClient ()\n            let fileClientE    ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudFileClient ()\n            let aliadosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(aliadosTableName )\n            let mensajesTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(mensajesTableName)\n            let eventosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(eventosTableName )\n            let estadoTableE   ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(estadoTableName  )\n            let transacTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(transacTableName )\n            let archivosTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(archivosTableName)\n            let queueCorreosE  ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(correosQueueName )\n            let queueMensajesE ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(mensajesQueueName)\n        \n            type Correo = {\n                Subject       : string\n                Content       : string\n                CustomerEmail : string\n            }\n        \n            type Mensaje = {\n                remitente     : string\n                destinatario  : string\n                tema          : string\n                contenido     : string\n            }\n        \n            let enviarCorreoAzure (recipiente:string) (tema:string) (contenido:string)  = \n                {   Subject       = tema\n                    Content       = contenido \n                    CustomerEmail = recipiente\n                }\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage\n                |> (fun m -> queueCorreosE() >>= fun queueCorreos -> queueCorreos.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            let enviarMensaje (mensaje:Mensaje) = \n                mensaje\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage \n                |> (fun m -> queueMensajesE() >>= fun queueMensajes -> queueMensajes.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            type AliadoE(id, aliado: string) =\n                inherit TableEntity(partitionKey=\"Aliado\", rowKey=id)\n                new() = AliadoE(null, null)\n                member val Aliado = aliado with get, set\n        \n            type MensajeE(mensaje: Mensaje, id) =\n                inherit TableEntity(partitionKey= mensaje.destinatario, rowKey=id)\n                new(mensaje) = MensajeE(mensaje, System.Guid.NewGuid().ToString())\n                new() = MensajeE(  {    remitente     = \"\"\n                                        destinatario  = \"\"\n                                        tema          = \"\"\n                                        contenido     = \"\"\n                                    }  )\n                member val id           = id                    with get, set\n                member val Remitente    = mensaje.remitente     with get, set\n                member val Destinatario = mensaje.destinatario  with get, set\n                member val Tema         = mensaje.tema          with get, set\n                member val Contenido    = mensaje.contenido     with get, set\n        \n            type TransacE(transac: Transaccion) =\n                inherit TableEntity(partitionKey= transac.idAliado.Id, rowKey=transac.transaccion)\n                new() = TransacE({  fechaPago      = System.DateTime.MinValue\n                                    ano            = 0\n                                    periodo        = 0\n                                    monto          = 0\n                                    idAliado       = IdAliado \"\"\n                                    concepto       = ConceptoPago.Otro \"\"\n                                    transaccion    = \"-\"\n                                    statusTran     = \"\"\n                            })\n                member val fechaPago      = transac.fechaPago             with get, set\n                member val ano            = transac.ano                   with get, set\n                member val periodo        = transac.periodo               with get, set\n                member val monto          = transac.monto                 with get, set\n                member val idAliado       = transac.idAliado.Id           with get, set\n                member val concepto       = transac.concepto.ToString()   with get, set\n                member val transaccion    = transac.transaccion           with get, set\n                member val statusTran     = transac.statusTran            with get, set\n        \n            type ArchivoE(archivo: Archivo) =\n                inherit TableEntity(partitionKey= archivo.idAliado.Id, rowKey= archivo.nombre)\n                new() = ArchivoE({  idAliado    = IdAliado \"\"\n                                    tipo        = TipoArchivo.Otro \"\"\n                                    nombre      = \"\"\n                                    modificado  = System.DateTime.MinValue\n                                    tamano      = 0L\n                                    status      = StatusArchivo.Subido\n                                    comentario  = \"\"\n                            })\n                member val modificado = archivo.modificado           with get, set\n                member val tamano     = archivo.tamano               with get, set\n                member val comentario = archivo.comentario           with get, set\n                member val tipo       = archivo.tipo  .ToString()    with get, set\n                member val status     = archivo.status.ToString()    with get, set\n        \n            type EstadoE(n:int64, estado: string) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"Estado\")\n                new() = EstadoE(0L, \"\")\n                member val nevento      = n      with get, set\n                member val estado       = estado with get, set\n        \n            type EstadoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"EstadoActual\")\n                new() = EstadoNE(0L)\n                member val nevento      = n      with get, set\n        \n            type EventoE(n:int64, usuario:string, nombre:string, evento:string, tipo:string) =\n                inherit TableEntity(partitionKey= \"Evento\", rowKey= sprintf \"%08d\" n)\n                new() = EventoE(0L, \"\", \"\", \"\", \"\")\n                member val nevento      = n       with get, set\n                member val usuario      = usuario with get, set\n                member val nombre       = nombre  with get, set\n                member val tipo         = tipo    with get, set\n                member val evento       = evento  with get, set\n        \n            type EventoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"Actual\", rowKey= \"Actual\")\n                new() = EventoNE(0L)\n                member val nevento      = n      with get, set\n        \n            let executeE      tbE  op = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteAsync      op |> Async.AwaitTask |> Asy.ofAsync\n            let executeQueryE tbE (op:TableQuery<_>) = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteQuerySegmentedAsync(op, null) |> Async.AwaitTask |> Asy.ofAsync\n        \n            let guardarAliado id contenido = \n                TableOperation.InsertOrReplace <| AliadoE(id, contenido)\n                |> executeE aliadosTableE\n        \n            let guardarMensaje mensaje =\n                TableOperation.InsertOrReplace <| MensajeE(mensaje)\n                |> executeE mensajesTableE\n        \n            let guardarTransac transac =\n                TableOperation.InsertOrReplace <| TransacE(transac)\n                |> executeE transacTableE\n        \n            let guardarTransacs (ts: Transaccion seq) = \n                ts \n                |> traverseSeq guardarTransac\n                |>> Seq.iter ignore\n        \n            let obtenerTransacs() = \n                TableQuery<TransacE>()\n                |>  executeQueryE transacTableE\n                |>> (Seq.map (fun tr -> {  \n                                    fechaPago      = tr.fechaPago  \n                                    ano            = tr.ano        \n                                    periodo        = tr.periodo    \n                                    monto          = tr.monto      \n                                    idAliado       = IdAliado tr.idAliado   \n                                    concepto       = ConceptoPago.tryParse tr.concepto |> Option.defaultValue (ConceptoPago.Otro \"\")\n                                    transaccion    = tr.transaccion\n                                    statusTran     = tr.statusTran \n                            }\n                ) >> Seq.toArray)\n        \n            let guardarArchivo archivo =\n                TableOperation.InsertOrReplace <| ArchivoE(archivo)\n                |> executeE archivosTableE\n        \n            let obtenerArchivos() = \n                TableQuery<ArchivoE>()\n                |>  executeQueryE archivosTableE\n                |>> (Seq.map (fun tr -> {  \n                                    idAliado    = IdAliado tr.PartitionKey\n                                    nombre      = tr.RowKey\n                                    modificado  = tr.modificado\n                                    tamano      = tr.tamano    \n                                    comentario  = tr.comentario\n                                    tipo        = tr.tipo   |> TipoArchivo  .Parse\n                                    status      = tr.status |> StatusArchivo.Parse \n                            }\n                ) >> Seq.toArray)\n        \n            let obtenerAliados() =\n                TableQuery<AliadoE>()\n                |>  executeQueryE aliadosTableE\n                |>> (Seq.map (fun al -> al.Aliado) >> Seq.toArray)\n        \n            let borrarAliado aid =\n                TableOperation.Delete(AliadoE(aid, \"\", ETag = \"*\") )\n                |> executeE aliadosTableE\n        \n            let guardarEstado (n:int64) s =\n                let op1 = TableOperation.InsertOrReplace <| EstadoE( n, s)\n                let op2 = TableOperation.InsertOrReplace <| EstadoNE(n   )\n                executeE estadoTableE op1\n                >>= fun _ -> executeE estadoTableE op2\n        \n            let ultimoEstado() =\n                TableQuery<EstadoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"EstadoActual\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let obtenerEstado() =\n                TableQuery<EstadoE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Estado\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento, e.estado) )\n        \n            let ultimoEvento() = //obtenerTextoArchivo archivoUltimoEvento |> Option.bind ParseO.parseInt64O \n                TableQuery<EventoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"Actual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Actual\")\n                  ))\n                |> executeQueryE eventosTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let nuevoEvento (usuario:string) (nombre:string) (evento:string) (tipo:string) =\n                ultimoEvento()\n                |>> Option.defaultValue 0L\n                |>> (+) 1L\n                >>= fun nextEvento ->\n                    EventoE( nextEvento, usuario, nombre, evento, tipo)\n                    |>  TableOperation.InsertOrReplace\n                    |>  executeE eventosTableE\n                    |>> fun _ -> EventoNE(nextEvento   )\n                    |>> TableOperation.InsertOrReplace\n                    >>= executeE eventosTableE\n                    |>> fun _ -> nextEvento\n        \n            let getMimeO (name :string)=\n                match name.ToLower() with\n                | String.EndsWith \".pdf\"  _ -> Some \"application/pdf\"\n                | String.EndsWith \".rtf\"  _ -> Some \"application/rtf\"\n                | String.EndsWith \".pbm\"  _ -> Some \"image/x-portable-bitmap\"\n                | String.EndsWith \".bmp\"  _ -> Some \"image/bmp\"\n                | String.EndsWith \".gif\"  _ -> Some \"image/gif\"\n                | String.EndsWith \".tif\"  _\n                | String.EndsWith \".tiff\" _ -> Some \"image/tiff\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".jpe\"  _ \n                | String.EndsWith \".jpeg\" _ \n                | String.EndsWith \".jpg\"  _ -> Some \"image/jpeg\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".html\" _ -> Some \"text/html\"\n                | _-> None\n        \n            let obtenerListaDocs (IdAliado alid) = eff {\n                let! bcli      = blobClientE()\n                let  container = bcli.GetContainerReference \"documentos\"\n                let  dir       = container.GetDirectoryReference  alid\n                let! blobs     = dir.ListBlobsSegmentedAsync   null |> Async.AwaitTask |> Asy.ofAsync\n                let! archivos  = obtenerArchivos() |>> Array.filter (fun a -> a.idAliado.Id = alid)\n                return\n                    blobs.Results\n                    |> Seq.choose (fun blob ->\n                        blob.Uri.GetComponents(UriComponents.Path, UriFormat.Unescaped) \n                        |> String.splitInTwoO (alid + \"/\")\n                        |> Option.map snd\n                        |> Option.map (fun nombre ->\n                            let ref = dir.GetBlockBlobReference nombre\n                            ref.FetchAttributes()\n                            archivos\n                            |> Seq.tryFind (fun a -> a.nombre = nombre) \n                            |> Option.map  (fun a ->\n                                if a.modificado = ref.Properties.LastModified.Value.DateTime && a.tamano = ref.Properties.Length then a else\n                                { a with \n                                    modificado  = ref.Properties.LastModified.Value.DateTime\n                                    tamano      = ref.Properties.Length\n                                    status      = StatusArchivo.Cambiado\n                                }\n                            )\n                            |> Option.defaultWith ( fun () -> {  \n                                idAliado    = IdAliado alid\n                                nombre      = nombre\n                                modificado  = ref.Properties.LastModified.Value.DateTime\n                                tamano      = ref.Properties.Length\n                                comentario  = \"\"\n                                tipo        = TipoArchivo.Otro \"-\"\n                                status      = StatusArchivo.Subido\n                            })\n                        )\n                    )\n                    |> Seq.toArray\n            }\n        \n            let subirBlob fromFile toContainerName toFile =\n                blobClientE()\n                >>= fun bcli ->\n                        bcli                          .GetContainerReference toContainerName\n                        |>  fun container -> container.GetBlockBlobReference toFile\n                        |>  fun blob      -> blob     .UploadFromFileAsync   fromFile |> Async.AwaitTask |> Asy.ofAsync |>> fun () -> blob\n                        >>= fun blob      -> eff { \n                                match getMimeO toFile with\n                                | None -> ()\n                                |   Some mime ->    blob.Properties.ContentType <- mime\n                                                    do! blob.SetPropertiesAsync() |> Async.AwaitTask |> Asy.ofAsync\n                            }\n        \n            let obtenerPropiedadesBlob toContainerName toFile = eff {\n                let! bcli = blobClientE()\n                let  blob =\n                        bcli                         .GetContainerReference toContainerName\n                        |> fun container -> container.GetBlockBlobReference toFile\n                let! exists = blob.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some blob.Properties else None\n            }\n        \n            let obtenerPropiedadesArchivo shareName toFile = eff {\n                let! fcli = fileClientE   () \n                let  file =\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                let! exists = file.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some file.Properties else None\n            }\n        \n            let subirArchivo fromFile shareName toFile =\n                fileClientE   () \n                >>= fun fcli ->\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                        |> fun file  -> file .UploadFromFileAsync    fromFile |> Async.AwaitTask |> Asy.ofAsync\n        \n        \n        //    let setAmbiente() =\n        //        {\n        //            new IAmbiente with \n        //                member __.UltimoEvento      ()  = ultimoEvento()\n        //                member __.UltimoEstado      ()  = ultimoEstado()\n        //                member __.LeerTipos         ()  = [||]   \n        //                member __.LeerEventosTipos  ()  = [||]   \n        //                member __.NuevoEvento       (usuario:string) (nombre:string) (evento:string) (tipo:string) = nuevoEvento usuario nombre evento tipo\n        //                member __.LeerEventos       n   = AsyncResultM.errorMsgf \"ambienteAzure.LeerEventos not implemented\"\n        //                member __.GuardarEstado     n s = guardarEstado n s\n        //                member __.ObtenerEstado     ()  = obtenerEstado\n        //                member __.GuardarAliado     i s = guardarAliado i s\n        //                member __.ObtenerAliados    ()  = obtenerAliados\n        //                member __.NombreAmbiente    ()  = \"azure\"\n        //                member __.CarpetaRaiz       ()  = carpeta\n        //                member __.EnviarCorreo    r t c = enviarCorreoAzure r t c\n        //                member __.EnviarMensaje d r t c = enviarMensaje  { \n        //                                                        remitente     = d \n        //                                                        destinatario  = r \n        //                                                        tema          = t \n        //                                                        contenido     = c \n        //                                                    }\n        //                member __.ObtenerTransacciones      id = AsyncResultM.errorMsgf \"Ambiente.ObtenerTransacciones: not implemented\"\n        //                member __.ObtenerMensajes           id = AsyncResultM.errorMsgf \"Ambiente.ObtenerMensajes: not implemented\"\n        //                member __.ObtenerListaDocs          id = obtenerListaDocs id\n        //                member __.VariableAmbiente           v = System.Environment.GetEnvironmentVariable v\n        //                member __.Prepare                   () = Authorize.prepareAuthorizeNetEnvironment()\n        //        }\n        //\n        \n            let invokeE nameF (f:'a->Eff<'H, 'b>) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n                |> join\n        \n            let invokeR nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n        \n            let invokeVerboseR nameF (f:'a->'b) (p:'a) = eff {\n                try \n                    do! Log.logf \"invokeVerboseR: %s\" (nameF p)\n                    let r = f p \n                    do! Log.logf \"%s %A\" (nameF p) r\n                    return r\n                with e ->\n                    return!\n                        Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                        |> Rsl.ofResult\n            }\n        \n            let invokeL nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Log.logf \"%s %A\" (nameF p) //|>> ignore \n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                    |> Rsl.ofResult\n        \n            let invokeLE nameF (f:'a->Eff<'H, 'b>) (p:'a) =\n                try \n                    f p \n                    >>= Log.logf \"%s %A\" (nameF p) \n                    |>  Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n                |> join\n        \n        [< AutoOpen >]\n        module AzureHandler =\n            open Authorize\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n            open Azure\n        \n        \n            type AR<'V> = Eff<AzureReader,'V>\n            and  AzureReader(?environment : string) =\n                let manejadores = System.Collections.Generic.Dictionary<Eventos.TipoDatos, Eventos.ManejadorDatos<obj,AzureReader>>()\n                let manejadorGenerico (msg:Eventos.ObjetoDatos<obj>) : Eventos.ResultadoManejador<AzureReader> =\n                        match manejadores.TryGetValue msg.tipoDatos with\n                        | false, _         -> failwithf \"No Handler for message: %A \\n handlers: [%s]\" msg (manejadores.Keys |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\")\n                        | true , manejador -> manejador.manejadorF msg\n                do SerializadorEventos.registrarEventos (fun m -> manejadores.Add(m.tipoDatos, m))\n        \n                let prepareEnvironment env id transactionKey =\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.RunEnvironment         <- env\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.MerchantAuthentication <- \n                        new merchantAuthenticationType( name            = id\n                                                    ,   ItemElementName = ItemChoiceType.transactionKey\n                                                    ,   Item            = transactionKey )\n                let mutable environmentNameO = None\n                let prepararE = eff {\n                    let! env =  eff {\n                                    match environment with\n                                    | Some v -> return v.ToUpper()\n                                    |_       -> return! variableAmbienteE \"Authorize_Environment\"\n                                }\n                    let  environment, environmentName, idV, tranKeyV =\n                        match env with\n                        | \"P\" ->(   AuthorizeNet.Environment.PRODUCTION\n                                ,   \"PRODUCTION\"\n                                ,   \"Authorize_Id_Production\"          \n                                ,   \"Authorize_Transaction_Production\" \n                                )\n                        |_->    (   AuthorizeNet.Environment.SANDBOX\n                                ,   \"SANDBOX\"\n                                ,   \"Authorize_Id_Sandbox\"          \n                                ,   \"Authorize_Transaction_Sandbox\" \n                                )\n                    let! id      = variableAmbienteE idV\n                    let! tranKey = variableAmbienteE tranKeyV\n                    environmentNameO <- Some environmentName\n                    prepareEnvironment environment id tranKey\n                }\n        \n                let obtenerTransaccionesMem, resetTransMem = \n                    let mutable transO = None\n                    fun() -> eff {\n                        match transO with\n                        | Some trans -> return trans\n                        | None       -> let!   trans = Azure.obtenerTransacs()\n                                        transO <- Some trans\n                                        let!   modelo = ObtenerEstado.obtenerEstado()\n                                        let  aliados  = Aliado.actualizarAliados trans modelo\n                                        if aliados <> modelo.aliados then\n                                            let! n = ObtenerEstado.ultimoEstadoE() |>> Option.defaultValue 0L\n                                            do! ObtenerEstado.guardarEstado (n + 1L) { modelo with aliados = aliados }\n                                        return trans\n                    }, (fun () -> transO <- None)\n        \n                interface Reader.Reader<AzureReader> \n                interface Log.Log<string> \n                interface Rsl.Rsl<string>\n                interface Asy.Asy\n                interface VariableAmbienteI with\n                    member __.getVar          v  = System.Environment.GetEnvironmentVariable v\n                    member __.CarpetaRaiz     () = @\"D:\\home\\site\\wwwroot\"\n                interface Eventos        .EventosI<AzureReader> with\n                    member __.ManejadorGenerico                  msg = manejadorGenerico msg\n                    member __.GuardarArchivo                     ar  = invokeLE  (fun _ -> \"GuardarArchivo\"    )  Azure.guardarArchivo ar\n                    member __.ObtenerListaDocs                   ida = invokeE   (fun _ -> \"ObtenerListaDocs\"  )  Azure.obtenerListaDocs ida\n                interface Correo          .EmailI<AzureReader>  with\n                    member __.SendEmail                        r t c = invokeE  (fun _ -> \"SendEmail\"          ) (Azure.enviarCorreoAzure r t      ) c\n                interface ObtenerEstado   .EstadoI<AzureReader> with\n                    member __.UltimoEstado                        () = invokeE  (fun _ -> \"UltimoEstado\"       )  Azure.ultimoEstado                 ()\n                    member __.GuardarAliado                     id s = invokeLE (fun _ -> \"GuardarAliado\"      ) (Azure.guardarAliado id  :_->AR<_>) s\n                    member __.GuardarEstado                      n s = invokeLE (fun _ -> \"GuardarEstado\"      ) (Azure.guardarEstado  n  :_->AR<_>) s\n                    member __.ObtenerEstado                       () = invokeE  (fun _ -> \"ObtenerEstado\"      )  Azure.obtenerEstado                ()\n                    member __.ObtenerAliados                      () = invokeE  (fun _ -> \"ObtenerAliados\"     )  Azure.obtenerAliados               ()\n                    member __.LeerTransacciones                   () = invokeE  (fun _ -> \"LeerTransacciones\"  )  obtenerTransaccionesMem            ()\n                    member __.SalvarTransacciones                 ts = invokeE  (fun _ -> \"SalvarTransacciones\")  Azure.guardarTransacs              ts\n                interface ManejadorEventos.ManejadorI<AzureReader> with\n                    member __.NuevoEvento usuario nombre evento tipo = invokeE  (fun _ -> \"NuevoEvento\"   ) (Azure.nuevoEvento   usuario nombre evento) tipo\n                    member __.UltimoEvento                        () = invokeE  (fun _ -> \"UltimoEvento\"  )  Azure.ultimoEvento                 ()\n                    member __.EnviarMensaje                  d r t c = invokeE  (fun _ -> \"EnviarMensaje\" )  Azure.enviarMensaje { \n                                                                                                                            remitente     = d \n                                                                                                                            destinatario  = r \n                                                                                                                            tema          = t \n                                                                                                                            contenido     = c \n                                                                                                                        }\n                interface AuthorizeI<AzureReader> with\n                    member __.execute controller =  controller.Execute()\n                                                    controller.GetApiResponse()\n                    member __.prepare         () = if environmentNameO.IsNone then prepararE else rtn ()\n                member __.RefrescarTransacciones() : Eff<AzureReader,_> = eff {\n                    do!  Authorize.actualizarTransacciones   None\n                    resetTransMem                            ()\n                    ObtenerEstado.resetEstadoActual          ()\n                    let! trans = ObtenerEstado.leerTransaccsE() \n                    ()\n                }\n        \n            let reader = AzureReader()\n            let mutable logger : string -> unit = print\n        \n            let run   (eff:Eff<_,_>) = async {\n                try\n                    return!\n                        eff\n                        |> Reader.readerHandler reader\n                        |> Log.loggerLogHandler logger\n                        |> Rsl.rslHandler \n                        |> Asy.asyncHandler\n                        |> Eff.run<AzureReader,_>\n                with e -> \n                    return Error (sprintf \"Eff Exception: %s %s\" e.Message e.StackTrace)\n            }\n        \n            let printEff (log:string -> unit) eff = \n                run eff\n                |> Async.map \n                   (function\n                    | Ok ()   -> ()\n                    | Error m -> log m)\n                |> Async.iterA id\n        \n        \n        \n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Fake.IO.FileSystem\\lib\\net46\\Fake.IO.FileSystem.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.IdentityModel.Tokens\\lib\\net461\\Microsoft.IdentityModel.Tokens.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Protocols\\lib\\net461\\Microsoft.IdentityModel.Protocols.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Protocols.OpenIdConnect\\lib\\net461\\Microsoft.IdentityModel.Protocols.OpenIdConnect.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.Logging\\lib\\net461\\Microsoft.IdentityModel.Logging.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\Microsoft.IdentityModel.JsonWebTokens\\lib\\net461\\Microsoft.IdentityModel.JsonWebTokens.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Configuration.ConfigurationManager/lib/net461/System.Configuration.ConfigurationManager.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Cryptography.ProtectedData/lib/net461/System.Security.Cryptography.ProtectedData.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Permissions/lib/net461/System.Security.Permissions.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.AccessControl/lib/net461/System.Security.AccessControl.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Buffers/lib/netstandard1.1/System.Buffers.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Numerics.Vectors/lib/net46/System.Numerics.Vectors.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Runtime.CompilerServices.Unsafe/lib/netstandard1.0/System.Runtime.CompilerServices.Unsafe.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Security.Principal.Windows/lib/net461/System.Security.Principal.Windows.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper0/System.Memory/lib/netstandard1.1/System.Memory.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages\\test2\\System.IdentityModel\\lib\\net461\\System.IdentityModel.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages\\test2\\System.IdentityModel.Tokens.Jwt\\lib\\net461\\System.IdentityModel.Tokens.Jwt.dll\"\n        module TokenValidate =\n            open System.IO\n            open Microsoft.IdentityModel.Tokens\n            open System.ComponentModel\n            open System\n            open System.Security.Cryptography\n            open System.Text\n            open System.Configuration\n            open Microsoft.IdentityModel.Protocols.OpenIdConnect\n            open System.IdentityModel.Tokens.Jwt\n        \n        /// https://prozper.b2clogin.com/tfp/prozper.onmicrosoft.com/B2C_1_Registrarse/discovery/v2.0/keys\n            let e      = \"AQAB\"\n            let n      = \"tVKUtcx_n9rt5afY_2WFNvU6PlFMggCatsZ3l4RjKxH0jgdLq6CScb0P3ZGXYbPzXvmmLiWZizpb-h0qup5jznOvOr-Dhw9908584BSgC83YacjWNqEK3urxhyE2jWjwRm2N95WGgb5mzE5XmZIvkvyXnn7X8dvgFPF5QwIngGsDG8LyHuJWlaDhr_EPLMW4wHvH0zZCuRMARIJmmqiMy3VD4ftq4nS5s8vJL0pVSrkuNojtokp84AtkADCDU_BUhrc2sIgfnvZ03koCQRoZmWiHu86SuJZYkDFstVTVSR0hiXudFlfQ2rOhPlpObmku68lXw-7V-P7jwrQRFfQVXw\"\n            \n            let addPadding (s:string) = s.Replace('_', '/').Replace('-', '+').PadRight(s.Length + (s.Length * 3) % 4, '=')\n        \n            let rsa = new RSACryptoServiceProvider()\n            rsa.ImportParameters(\n                    new RSAParameters(\n                        Exponent = Convert.FromBase64String (addPadding e)\n                      , Modulus  = Convert.FromBase64String (addPadding n)\n                    ))\n        \n        \n            let validate(token:string) =\n                let validationParameters = TokenValidationParameters(   ValidateAudience  =  false\n                                                                      , ValidateIssuer    =  false\n                                                                      , ValidateLifetime  =  true\n                                                                      , IssuerSigningKey  =  RsaSecurityKey rsa\n                                                                    )\n                let handler = JwtSecurityTokenHandler()\n                try\n                    match handler.ValidateToken(token, validationParameters) with\n                    | principal, jwt -> Ok principal\n                with e -> Error e.Message\n        \n            //match validate bearer with\n            //| Ok principal -> \n            //    //principal.Identities |> Seq.iter printObj\n            //    principal.Claims     |> Seq.map (fun c -> (c.Type, c.Value) ) |> Seq.toArray |> printObj\n            //| Error msg -> print msg\n        \n        \n        module Rpc0 =\n            open WebSharper\n            open WebSharper.JavaScript\n        \n            [< JavaScript >]\n            let serverEndPoint = \n                lazy \n                    if IsClient then \n                        if JS.Window.Location.Protocol = \"http:\" \n                        then \"http://localhost:7071/api/\"\n                        else sprintf \"https://%s/api/\" JS.Window.Location.Host\n                    else     \n                        variableAmbienteE \"Website\" \n                        |>> sprintf \"https://%s/api/\"\n                        |>  AzureHandler.run\n                        |>  Async.RunSynchronously\n                        |>  Result.defaultValue \"https://aliados.prozper.com/api\"\n        \n            let obtenerUnions0 () =\n                ( DiscUnion.simple<Pais          >\n                , DiscUnion.simple<Estado        >\n                , DiscUnion.simple<TipoDireccion >\n                , DiscUnion.simple<TipoTelefono  >\n                , DiscUnion.simple<Genero        >\n                , DiscUnion.simple<TipoCuenta    >\n                , DiscUnion.simple<TipoTarjeta   >\n                , DiscUnion.simple<StatusAliado  >\n                , [| for m in System.Enum.GetValues(typeof<Mes>)                       do yield string m |]\n                , [| for i in System.DateTime.Now.Year..System.DateTime.Now.Year + 15  do yield        i |]\n                , DiscUnion.simple<TipoArchivo   >\n                , DiscUnion.simple<StatusArchivo >\n                )        \n        \n            open Azure\n            open AzureHandler\n        \n            let borrarFormaPago0 aid    idp = eff {\n                let! fps   = Authorize.obtenerFormasDePagoId   aid\n                let! res   = Authorize.borrarFormaPago         aid idp\n                let! docs  = ManejadorEventos.obtenerListaDocs aid\n                match fps |> Seq.tryFind (fun fp -> fp.authorizeIdR = Ok idp) with\n                | None -> ()\n                | Some fp ->\n                    let  pre = fp.cuentaPago.AutorizacionPre\n                    let  docsN = docs |> Array.choose(fun doc ->\n                                    match doc.status with\n                                    | Subido | Cambiado | Verificado | Rechazado when doc.nombre.StartsWith pre -> Some { doc with status = Cancelado }\n                                    |_-> None\n                                )\n                    if docsN.Length > 0 then\n                        let! _ = ActualizarArchivos(aid, docsN) |> ManejadorEventos.ejecutarDataEventoNuevo aid\n                        ()\n                return res\n            }\n        \n            type AR<'T> = Async<Result<'T, string>>\n            let aidClaim = \"http://schemas.microsoft.com/identity/claims/objectidentifier\"\n            let jobClaim = \"jobTitle\"\n            let jobAdmin = \"AdministradorPROZPER\"\n        \n            let check tk (aid:IdAliado) = \n                eff {\n                    let! principal    = TokenValidate.validate tk |> Rsl.ofResult\n                    let  claims       = principal.Claims |> Seq.toArray\n                    let tryClaim name = claims |> Seq.tryPick (fun cl -> if cl.Type = name then Some cl.Value else None)\n                    let esAdminL      = lazy (tryClaim jobClaim = Some jobAdmin)\n                    match tryClaim aidClaim with\n                    | Some id when id = aid.Id || esAdminL.Value -> return esAdminL\n                    | _  ->   \n                        do! Log.logf \"Claims %d\" claims.Length\n                        for cl in claims do\n                            do! Log.logf \"claim: %s = %s\" cl.Type cl.Value\n                        return! Result.Error \"No autorizado!\" |> Rsl.ofResult\n                } \n        \n            let adm = IdAliado \"\"\n        \n            let [< Rpc >] obtenerUnions                          () : AR<_> =                             invokeVerboseR(fun _ -> \"obtenerUnions\")  obtenerUnions0 () |> AzureHandler.run\n            let [< Rpc >] obtenerIdInfluyente                codigo : AR<_> =                             ManejadorEventos.obtenerIdInfluyente      codigo            |> AzureHandler.run\n            let [< Rpc >] obtenerEstadoParaUsuario tk aid           : AR<_> = check tk aid >>= (fun aL -> ObtenerEstado   .obtenerEstadoParaUsuario aid    aL.Value ) |> AzureHandler.run\n            let [< Rpc >] actualizarSubscripcion   tk aid    idp    : AR<_> = check tk aid >>= (fun _  -> Authorize       .actualizarSubscripcion   aid     idp     ) |> AzureHandler.run\n            let [< Rpc >] ejecutarDataEventoNuevo  tk aid    de     : AR<_> = check tk aid >>= (fun _  -> ManejadorEventos.ejecutarDataEventoNuevo  aid     de      ) |> AzureHandler.run\n            let [< Rpc >] agregarUsuarioSiEsNuevo  tk aid    claims : AR<_> = check tk aid >>= (fun _  -> ManejadorEventos.agregarUsuarioSiEsNuevo  aid     claims  ) |> AzureHandler.run\n            let [< Rpc >] obtenerFormasDePagoId    tk aid           : AR<_> = check tk aid >>= (fun _  -> Authorize       .obtenerFormasDePagoId    aid             ) |> AzureHandler.run\n            let [< Rpc >] registrarTarjeta         tk aid    p      : AR<_> = check tk aid >>= (fun _  -> Authorize       .registrarTarjeta         aid     p       ) |> AzureHandler.run\n            let [< Rpc >] registrarCuenta          tk aid    p      : AR<_> = check tk aid >>= (fun _  -> Authorize       .registrarCuenta          aid     p       ) |> AzureHandler.run\n            let [< Rpc >] validarFormaPago         tk aid    p      : AR<_> = check tk aid >>= (fun _  -> Authorize       .validarFormaPago         aid     p       ) |> AzureHandler.run\n            let [< Rpc >] borrarFormaPago          tk aid    p      : AR<_> = check tk aid >>= (fun _  ->                  borrarFormaPago0         aid     p       ) |> AzureHandler.run\n            let [< Rpc >] obtenerListaDocs         tk aid           : AR<_> = check tk aid >>= (fun _  -> ManejadorEventos.obtenerListaDocs         aid             ) |> AzureHandler.run\n            let [< Rpc >] enviarCorreosInvitacion  tk aid (tm, ems) : AR<_> = check tk aid >>= (fun _  -> Correo          .enviarCorreosInvitacion (tm, aid, ems)   ) |> AzureHandler.run\n            let [< Rpc >] obtenerFormasDePagoPara  tk aids          : AR<_> = check tk adm >>= (fun _  -> Authorize       .obtenerFormasDePagoPara  aids            ) |> AzureHandler.run\n            let [< Rpc >] obtenerTransaccionesPara tk aid           : AR<_> = check tk aid >>= (fun _  -> Authorize       .obtenerTransaccionesPara aid             ) |> AzureHandler.run\n            let [< Rpc >] refrescarTransacciones   tk            () : AR<_> = check tk adm >>= (fun _  -> reader          .RefrescarTransacciones            ()     ) |> AzureHandler.run\n        \n        [<JavaScript>]\n        module Remoting = // not being used anymore as token now is a parameter of the rpc function\n            open WebSharper.JavaScript\n        \n            let private originalProvider = WebSharper.Remoting.AjaxProvider\n        \n            let mutable getTokenOA = fun () -> async { return None } // ... get token from storage ...\n        \n            type CustomXhrProvider () =\n                interface WebSharper.Remoting.IAjaxProvider with\n                    member this.Async url headers data ok err = \n                        async {\n                            let! tokenO = getTokenOA()\n                            tokenO |> Option.iter (fun token -> JS.Set headers \"Authorization\" <| sprintf \"Bearer %s\" token)\n                            originalProvider.Async url headers data ok err\n                        } |> Async.Start\n                    member this.Sync url headers data =\n                            originalProvider.Sync url headers data\n                    \n            let installBearer getTokenOAF =\n                getTokenOA <-  getTokenOAF\n                WebSharper.Remoting.AjaxProvider <- CustomXhrProvider()\n                \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n        \n        //#define NETSTANDARD20\n        \n        module AzureFunctions =\n            open Microsoft.Azure.WebJobs\n            open Microsoft.Azure.WebJobs.Extensions\n            open Microsoft.Azure.WebJobs.Extensions.Storage\n            open Microsoft.Azure.WebJobs.Extensions.Http\n            open Microsoft.Extensions.Logging\n            open Microsoft.AspNetCore.Http\n            open Microsoft.AspNetCore.Mvc\n            open Newtonsoft.Json\n            open System\n            open System.IO \n        \n            module RM = WebSharper.Core.Remoting\n        \n            [<FunctionName(\"keepAlive\")>]\n            let keepAlive([< TimerTrigger(\"0 */5 * * * *\") >] myTimer : TimerInfo, log : ILogger ) =\n                ()\n        \n            [<FunctionName(\"refreshTransactions\")>]\n            let refreshTransactions([< TimerTrigger(\"0 0 0 */1 * *\") >] myTimer : TimerInfo, log : ILogger ) =\n                reader.RefrescarTransacciones() |> AzureHandler.printEff log.LogInformation\n        \n            type MaxDepthJsonTextWriter(writer : TextWriter, maxDepth : int ) =\n                inherit JsonTextWriter(writer) \n                let mutable maxObservedDepth = 0\n                member this.CheckDepth() =\n                    maxObservedDepth <- Math.Max(maxObservedDepth, this.Top)\n                    if this.Top > int maxDepth then\n                        failwithf \"Depth %d Exceeds MaxDepth %A at path %A\" this.Top maxDepth this.Path\n                override this.WriteStartArray          () = base.WriteStartArray()           ; this.CheckDepth()\n                override this.WriteStartConstructor  name = base.WriteStartConstructor(name) ; this.CheckDepth()\n                override this.WriteStartObject         () = base.WriteStartObject()          ; this.CheckDepth()\n        \n            let splitAndSend n f name (txt:string) =\n                let rec loop (txt:string) =\n                    if txt.Length <= n then f txt else\n                    f txt.[0..n]\n                    loop txt.[n + 1..]\n                loop (name + \"<<<:\" + txt + \":>>>\")\n        \n            let serializeMaxDepth depth obj = \n                let settings = JsonSerializerSettings(ReferenceLoopHandling  = ReferenceLoopHandling.Ignore\n                                                    , MissingMemberHandling  = MissingMemberHandling.Ignore\n                                                    , Error                  = EventHandler<Serialization.ErrorEventArgs>(fun s a -> a.ErrorContext.Handled <- true)\n                                                    )\n                use writer      = new StringWriter()\n                use jsonWriter  = new MaxDepthJsonTextWriter(writer, depth)\n                JsonSerializer.Create(settings).Serialize(jsonWriter, obj)\n                writer.ToString()\n            \n        \n            [<FunctionName(\"rpc\")>]\n            let runRpc( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"rpc/rpc\")>] \n                        request     : HttpRequest\n                      , principal   : System.Security.Claims.ClaimsPrincipal \n                      , log         : ILogger  ) = \n                async {\n                    log.LogInformation \"runRpc: ENTERING v.015\"\n                    //serializeMaxDepth 13 request   |> splitAndSend 9999 log.LogInformation \"request\"\n                    //serializeMaxDepth 13 principal |> splitAndSend 9999 log.LogInformation \"principal\"\n                    //log.LogInformation(sprintf \"%d Headers:\" <| Seq.length request.Headers)\n                    //request.Headers |> Seq.collect (fun kvp -> kvp.Value |> Seq.map (fun v -> kvp.Key, v)) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    //log.LogInformation(sprintf \"%d real Claims:\" <| Seq.length principal.Claims)\n                    //principal.Claims |> Seq.map (fun kvp -> kvp.Type, kvp.Value) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    log.LogInformation <| sprintf \"runRpc: %s\" request.Headers.[\"x-websharper-rpc\"].[0]\n                    let start = System.DateTime.UtcNow.Ticks\n                    let  wsServer = RM.Server.Create WebSharper.Web.Shared.Metadata WebSharper.Web.Shared.Json\n                    log.LogInformation \"runRpc: after Server.Create\"\n                    let! body     = request.ReadAsStringAsync() |> Async.AwaitTask\n                    let  wsReq    = {\n                        RM.Request.Body    = body\n                        RM.Request.Headers = ParseO.tryParseWith request.Headers.TryGetValue >> Option.bind Seq.tryHead\n                    }\n                    logger <- fun s -> log.LogInformation s\n                    try\n                        let! wsResp   = wsServer.HandleRequest wsReq\n                        let elapsedSpan = new System.TimeSpan(System.DateTime.UtcNow.Ticks - start)\n                        log.LogInformation <| sprintf \"Finished: %s %s\" request.Headers.[\"x-websharper-rpc\"].[0] (elapsedSpan.ToString())\n                        //log.LogInformation (sprintf \"runRpc: after HandleRequest %s %s\" wsResp.ContentType wsResp.Content)\n                        return ContentResult(Content = wsResp.Content, ContentType = wsResp.ContentType)\n                    with e ->\n                        log.LogError (sprintf \"Exception: %A %A\" e.Message e.StackTrace)\n                        return failwithf \"Exception %A %A\" e.Message e.StackTrace\n                } |> Async.StartAsTask\n        \n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n        \n            //open Microsoft.Azure.Cosmos.Table\n            open Microsoft.AspNetCore.Http\n            open System.IO\n            open Microsoft.AspNetCore.Mvc\n        \n            [<FunctionName(\"subir\")>]\n            let subirDocumentos([<HttpTrigger(AuthorizationLevel.Anonymous, \"post\"   , Route      = \"subir/{id}/{filename}\")>] req   : HttpRequest\n                              , [<Blob(\"documentos/{id}/{filename}\", System.IO.FileAccess.Write, Connection = \"AzureWebJobsStorage\"  )>] writer: Stream \n                              , log     : ILogger\n                              , id      : string\n                              , filename: string ) = \n              async {\n                    log.LogInformation <| sprintf \"subiendo documento %d %s\" req.Form.Files.Count filename\n                    if req.Form.Files.Count <> 1 then\n                        log.LogWarning \"no se encontro el documento\"\n                        return ContentResult(Content = \"no se encontro el documento\", ContentType = \"text/plain\")\n                    else\n                    let  file      = req.Form.Files |> Seq.head\n                    do!  file.CopyToAsync writer |> Async.AwaitTask\n                    eff {\n                        try\n                            do!  Asy.ofAsync <| Async.Sleep 500\n                            let! blobClient = Azure.blobClientE()\n                            let  container  = blobClient.GetContainerReference \"documentos\"\n                            let  dir        = container.GetDirectoryReference id\n                            let  blobRef    = dir.GetBlockBlobReference filename\n                            Azure.getMimeO filename\n                            |> Option.iter (fun mime -> \n                                blobRef.Properties.ContentType <- mime\n                                blobRef.SetPropertiesAsync() |> Async.AwaitTask |> Async.Start\n                            )\n                        with e -> do! Rsl.ofResult <| Error (sprintf \"%A\" e)\n                    } |> AzureHandler.run |> Async.map (function | Error m -> printfn \"%A\" m |_-> ()) |> Async.Start\n                    return ContentResult(Content = \"Documento subido!\", ContentType = \"text/plain\")\n              } |> Async.StartAsTask\n        \n            [<FunctionName(\"passMessages\")>]\n            let passMessages( [<QueueTrigger(\"mensajes\", Connection = \"AzureWebJobsStorage\")>]  \n                    mensaje: Azure.Mensaje, log: ILogger) = \n                async {\n                    log.LogInformation (sprintf \"guardarMensaje %A (ignorando) \" mensaje)\n                    //let! v = AmbienteAzure.guardarMensaje mensaje\n                    //let! next = AmbienteAzure.queueMensajes.PeekMessageAsync() |> Async.AwaitTask\n                    //if isNull next then \n                        //log.LogInformation <| sprintf \"ambiente: %s\" (ambiente.NombreAmbiente())\n                        ////let! res = Acciones.ejecutarAcciones()\n                        ////log.LogInformation <| sprintf \"Acciones ejecutadas %A\" res\n                    ()\n                } |> Async.RunSynchronously\n        \n            [<FunctionName(\"path\")>]\n            let path( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"{anything}\")>] \n                        request     : HttpRequest\n                      , log         : ILogger ) =\n                //log.LogInformation(sprintf \"isMimeMultipart: %A\" <| request.Content.IsMimeMultipartContent())          \n                request.Headers |> Seq.iter (fun h -> log.LogInformation(sprintf \"header: %s %A\" h.Key (h.Value |> String.concat \"; \")) )\n                let uid    = ParseO.tryParseWith request.Headers.TryGetValue \"idAliado\" |> Option.bind Seq.tryHead |> Option.defaultValue \"\"\n                let claims = [| \"http://schemas.microsoft.com/identity/claims/objectidentifier\", uid |]\n                claims |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                //let serializares =\n                //    SerializadorEventos.serSerializadoresEventos.Keys \n                //    |> Seq.map (sprintf \"%A\")\n                //    |> String.concat \"\\n\"\n                //    |> sprintf \"serializers: %s\"\n                //let handlers =\n                //    Eventos.Manejadores.Keys \n                //    |> Seq.map (sprintf \"%A\")\n                //    |> String.concat \"\\n\"\n                //    |> sprintf \"Handlers: %s\"\n                //let content = sprintf \"Hello\\n%s\\n%s\" serializares handlers\n                let content = Directory.GetCurrentDirectory() //\"Hello\"\n                ContentResult(Content = content, ContentType = \"text/plain\")\n        \n        //#nowarn \"52\"\n        //#nowarn \"1182\"\n        //#nowarn \"1178\"\n        \n        //#define NOFRAMEWORK --noframework\n        //#define WEBSHARPER\n        \n        //// to generate function.json (s):\n        //// D:\\Abe\\CIPHERWorkspace\\AzureFunctions\\packages\\Microsoft.NET.Sdk.Functions\\tools\\net46\\Microsoft.NET.Sdk.Functions.Generator.exe bin\\ProzperServer.dll .\n        \n        //// to save function.json:\n        //// PUT https://management.azure.com/subscriptions/fd33982d-5249-477d-9587-b0f758dd6fe9/resourceGroups/Prozper/providers/Microsoft.Web/sites/Prozper0/functions/%s?api-version=2018-02-01\n        //// {\n        ////       \"properties\": {\n        ////         \"config\": %s\n        //// }\n        \n        \n        "],
"names": [],
"mappings": "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"
}
