{
"version": 3,
"sourceRoot": "Source",
"sources": ["ProzperServer/ProzperServer.fs", "WebSharper.Collections/BalancedTree.fs", "WebSharper.Collections/Pair.fs", "WebSharper.Collections/Map.fs", "WebSharper.Collections/MapModule.fs", "WebSharper.Collections/Set.fs", "WebSharper.Collections/SetModule.fs", "WebSharper.Collections/ResizeArray.fs", "WebSharper.Collections/LinkedList.fs", "WebSharper.Collections/Linq.fs", "WebSharper.Collections/Query.fs", "WebSharper.Main/Promise.fs", "WebSharper.Main/JavaScript.Pervasives.fs", "WebSharper.Main/Json.fs", "WebSharper.Main/Remoting.fs", "WebSharper.Main/Html.fs", "WebSharper.Main/Comparers.fs", "WebSharper.Main/Utils.fs", "WebSharper.Main/Concurrency.fs", "WebSharper.Main/Enumerator.fs", "WebSharper.Main/CollectionInternals.fs", "WebSharper.Main/Object.fs", "WebSharper.Main/IntrinsicFunctions.fs", "WebSharper.Main/Array.fs", "WebSharper.Main/ArrayModule.fs", "WebSharper.Main/Array2DModule.fs", "WebSharper.Main/Async.fs", "WebSharper.Main/Char.fs", "WebSharper.Main/CommonExtensions.fs", "WebSharper.Main/DateTime.fs", "WebSharper.Main/Delegate.fs", "WebSharper.Main/Dictionary.fs", "WebSharper.Main/Exception.fs", "WebSharper.Main/ExtraTopLevelOperators.fs", "WebSharper.Main/Guid.fs", "WebSharper.Main/HashSet.fs", "WebSharper.Main/Interfaces.fs", "WebSharper.Main/LazyExtensions.fs", "WebSharper.Main/List.fs", "WebSharper.Main/ListModule.fs", "WebSharper.Main/Nullable.fs", "WebSharper.Main/Operators.fs", "WebSharper.Main/OperatorIntrinsics.fs", "WebSharper.Main/OptionModule.fs", "WebSharper.Main/Queue.fs", "WebSharper.Main/Random.fs", "WebSharper.Main/ResultModule.fs", "WebSharper.Main/RuntimeHelpers.fs", "WebSharper.Main/SeqModule.fs", "WebSharper.Main/Stack.fs", "WebSharper.Main/String.fs", "WebSharper.Main/Task.fs", "WebSharper.Main/Unchecked.fs", "WebSharper.Main/ValueOption.fs", "WebSharper.Main/Primitives.fs", "WebSharper.Web/ClientSideJson.fs", "WebSharper.Web/Control.fs", "WebSharper.Sitelets/Router.fs", "WebSharper.Control/Observer.fs", "WebSharper.Control/HotStream.fs", "WebSharper.Control/Observable.fs", "WebSharper.Control/ObservableModule.fs", "WebSharper.Control/Event.fs", "WebSharper.Control/FSharpEvent.fs", "WebSharper.Control/EventModule.fs", "WebSharper.Control/MailboxProcessor.fs", "WebSharper.UI/Abbrev.fs", "WebSharper.UI/AppendList.fs", "WebSharper.UI/DomUtility.fs", "WebSharper.UI/Trie.fs", "WebSharper.UI/Snap.fs", "WebSharper.UI/Reactive.fs", "WebSharper.UI/Models.fs", "WebSharper.UI/ReactiveExtensions.fs", "WebSharper.UI/Animation.fs", "WebSharper.UI/Attr.fs", "WebSharper.UI/Attr.Client.fs", "WebSharper.UI/Doc.Proxy.fs", "WebSharper.UI/Templates.fs", "WebSharper.UI/Flow.fs", "WebSharper.UI/HTML.fs", "WebSharper.UI/Router.fs", "WebSharper.UI/Routing.fs", "WebSharper.UI/Input.fs"],
"sourcesContent": ["#nowarn \"3242\"\n#nowarn \"52\"\n#nowarn \"1182\"\n#nowarn \"1178\"\n////-d:FSharpStation1559368300303 -d:NOFRAMEWORK --noframework -d:WEBSHARPER\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n//#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\n//#nowarn \"3242\"\n//#nowarn \"52\"\n//#nowarn \"1182\"\n//#nowarn \"1178\"\n/// Root namespace for all code\n//#define FSharpStation1559368300303\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#nowarn \"3242\" \n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    //#define NOFRAMEWORK --noframework\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\netstandard.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\mscorlib.dll\"\n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Globalization.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Reflection.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Numerics.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Core.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Net.Http.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Runtime.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.IO.dll\"   \n    //#r \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\test\\NETStandard.Library\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll\"  \n    \n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\"\n    //#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\"\n    \n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Collections.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Main.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JQuery.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.JavaScript.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Web.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Sitelets.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\netstandard2.0\\WebSharper.Control.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\HtmlAgilityPack.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\netstandard2.0\\WebSharper.UI.Templating.Common.dll\"\n    \n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library = \n            let Error = Result.Error\n        \n            let [<Inline>] inline swap f a b = f b a\n            \n            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\n            let [<Inline>] inline __   f a b = f b a\n            \n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            (* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\n            module IDict =\n            #if WEBSHARPER\n                [< Inline >]\n            #endif\n                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            *)\n            module Dict =\n                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n                    let mutable res = Unchecked.defaultof<_>\n                    if dict.TryGetValue(key, &res)\n                    then Some res \n                    else None\n                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n            \n            module LDict =\n                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n                let [<Inline>] inline tryGetValue fitem key  dict =\n                    if containsKey key dict then Some (fitem key)\n                    else None\n            \n            \n            /// Extensible type for error messages, warnings and exceptions\n            type ResultMessage<'M> =\n                | NoMsg\n                | ErrorMsg  of string\n                | Warning   of string\n                | Info      of string\n                | Message   of 'M\n                | ExceptMsg of string * string\n                | RMessages of ResultMessage<'M> []\n                with \n                override msg.ToString() =\n                    match msg with\n                    | NoMsg          ->  \"\"\n                    | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n                    | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n                    | Info      m    ->  m\n                    | Message   m    ->  m      |> sprintf \"%O\"\n                    | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n            \n            [< AutoOpen >]\n            module ResultMessageHelpers =\n                let inline errorMsgf fmt = Printf.ksprintf ErrorMsg fmt\n                let inline warningf  fmt = Printf.ksprintf Warning  fmt\n                let inline infof     fmt = Printf.ksprintf Info     fmt\n            \n            module ResultMessage =\n            \n                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n                /// converts Messages to other type of ResultMessage\n                let rec bindMessage f msg = \n                    match msg with\n                    | NoMsg          ->  NoMsg\n                    | Message   m    ->  f         m\n                    | ErrorMsg  m    ->  ErrorMsg  m\n                    | Info      m    ->  Info      m\n                    | Warning   m    ->  Warning   m\n                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n            \n                /// a Message is converted to ErrorMsg\n                let freeMessageF f msg = msg |> bindMessage f\n                /// a Message is converted to ErrorMsg\n                let freeMessage    msg = msg |> freeMessageF (sprintf \"%O\" >> ErrorMsg)\n                /// a Message is converted to Warning\n                let freeMessageW   msg = msg |> freeMessageF (sprintf \"%O\" >> Warning )\n                /// a Message is converted to Info\n                let freeMessageI   msg = msg |> freeMessageF (sprintf \"%O\" >> Info    )\n            \n                let rec isInfoF f msg =\n                    match msg with\n                    | Info      _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n                    | _              ->  false\n                /// a Message is not considered Info\n                let isInfo  msg = msg |> isInfoF (fun _ -> false)\n                /// a Message is considered Info\n                let isInfoI msg = msg |> isInfoF (fun _ -> true )\n            \n                let rec isWarningOrInfoF f msg =\n                    match msg with\n                    | Warning   _    ->  true\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n                    | _              ->  false\n                /// a Message is not considered a Warning\n                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n                /// a Message is considered a Warning\n                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n            \n                let rec isFatalF f msg =\n                    match msg with\n                    | NoMsg\n                    | Info      _    \n                    | Warning   _    ->  false\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n                    | _              ->  true\n                    //|>! printfn \"%A = %A\" msg\n                /// a Message is considered fatal\n                let isFatal  msg = msg |> isFatalF (fun _ -> true )\n                /// a Message is not considered fatal\n                let isFatalW msg = msg |> isFatalF (fun _ -> false)\n            \n                let rec countF f msg =\n                    match msg with\n                    | NoMsg          ->  0, 0, 0\n                    | Info      _    ->  0, 0, 1\n                    | Warning   _    ->  0, 1, 0\n                    | Message   m    ->  f m\n                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n                    | _              ->  1, 0, 0\n            \n                /// a Message is considered an error\n                let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n                \n                let addMsg a b =\n                    match a, b with\n                    | NoMsg        , c\n                    | c            , NoMsg         ->  c\n                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n            \n                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg\n            \n                let summaryF f msg =\n                    match countF f msg with\n                    | 0, 0, _\n                    | 1, 0, 0\n                    | 0, 1, 0 -> \"\"\n                    | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n                    | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n                    | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n            \n                /// returns a string with a count of errors and warnings, if more than one\n                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) \"\") |> String.concat \"\\n\"\n                /// a Message is considered an error\n                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n                /// a Message is considered a Warning\n                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n                /// a Message is considered Info\n                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n                \n            module Memoize =\n            \n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =\n                    let checkO v     = let mutable res = Unchecked.defaultof<_>\n                                       let ok          = cache.TryGetValue(v, &res)\n                                       if  ok then Some res else None\n                    let store  v res = cache.[v] <- res\n                                       res\n                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )\n                    (checkO, getOrAdd), cache.Clear\n            \n                /// creates a Dictionary to store memoized values\n                /// returns 3 functions:\n                ///    checkO  : ('p->'v option) \n                ///    getOrAdd: ('p->('p->'v)->'v) \n                ///    clear   : (unit->unit)\n                [<Inline>]\n                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )\n            \n                /// Memoizes function f using the provided cache\n                /// getCache() returns 1 function:\n                ///    getOrAdd: ('p->('p->'v)->'v) \n                [< Inline >]\n                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =\n                    fun p -> getOrAdd p f\n            \n            \n                /// Memoizes the function f using a Dictionary\n                /// Returns the memoized function and a clear() function\n                /// The dictionary can be reset using the clear() function\n                [< Inline >]\n                let memoizeResetable f =\n                    let (check, getOrAdd), clear = getStore()\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, clear\n            \n                /// Memoizes the function f using the provided Dictionary\n                [<Inline>]\n                let memoizeWithDict dict f =\n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF\n            \n                /// Memoizes the function f and returns Dictionary\n                [<Inline>]\n                let memoizeDict f =\n                    let dict = System.Collections.Generic.Dictionary<_, _>() \n                    let (check, getOrAdd), clear = getStoreWithDict dict\n                    let memoF = memoizeStore getOrAdd f\n                    memoF, dict\n            \n                /// Memoizes the function f using a Dictionary\n                [<Inline>]\n                let memoize f = memoizeResetable f |> fst\n            \n            \n            [< AutoOpen >]\n            module Monads =\n                module Seq =    \n                    let rtn = Seq.singleton\n                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n                    let absorbO  vOS              = vOS |> Seq.choose id\n                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n                    let ofOption vO = \n                        match vO with\n                        | Some v -> Seq.singleton v\n                        | None   -> Seq.empty\n                \n                /// Extensions to Async\n                module Async =\n                    let [< Inline >] inline rtn   v    = async.Return v\n                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n                    let [< Inline >] inline map   f    = bind (f >> rtn)\n                    /// Executes f Synchronously\n                    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n                    /// Executes f Asynchronously\n                    let [< Inline >] inline iterA f             = map f >> Async.Start\n                    let apply fA vA = async {\n                        let! fChild = Async.StartChild fA\n                        let! vChild = Async.StartChild vA\n                        let! f = fChild\n                        let! v = vChild \n                        return f v \n                    }\n                    let sleepThen f milliseconds = async {\n                        do! Async.Sleep milliseconds\n                        return f()\n                    }\n                    let (>>=)                              v f = bind f v\n                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                \n                \n                module Result =\n                    open Result\n                \n                    let errorf fmt = Printf.ksprintf Error fmt\n                \n                    let rtn                          = Ok\n                    let join                       r = Result.bind id r\n                    let flatten                    r = Result.bind id r\n                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n                    let failIfTrue               m v = if     v then m |> Error  else Ok () \n                    let failIfFalse              m v = if not v then m |> Error  else Ok () \n                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit\n                    let get                        r = r   |>          defaultWith (string >> failwith)\n                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n                    let absorbO               f  vOR = vOR |> bind (ofOption f)\n                    let (>>=)                    r f = bind f r\n                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq        sq = traverseSeq id sq\n                        \n                    \n                    type Builder() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bind f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let result = Builder()\n                    \n                    module Operators =\n                        let inline (|>>) v f   = map   f v\n                        let inline (>>=) v f   = bind  f v\n                        let inline (>>>) f g v = f v |>> g\n                        let inline (>=>) f g v = f v >>= g\n                        let inline rtn   v     = rtn    v\n                        let result = result\n                \n                \n                    \n                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n                    /// bind version that protects against exceptions\n                    let bindP                 f    r = match r with\n                                                        | Ok   v -> try   f v\n                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                                        | Error e ->      e                                        |> Error\n                    /// map version that protects against exceptions\n                    let inline mapP           f    m = bindP (f >> rtn) m            \n                    let iterP                 fE f r = r   |> mapP f |> defaultWith fE                                                 : unit    \n                    \n                    type BuilderP() =\n                        member inline this.Return          x       = rtn  x\n                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n                        member        this.Bind           (w , r ) = Result.bind  r w\n                        member inline this.Zero           ()       = rtn ()\n                        member inline this.Delay           f       = f\n                        member inline this.Combine        (a, b)   = bind b a\n                        member inline this.Run             f       = Ok () |> bindP f\n                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n                        member this.TryFinally(body, compensation) = try body() finally   compensation()\n                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n                        member this.While(guard, body) =\n                            let rec whileLoop guard body =\n                                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                                else rtn   ()\n                            whileLoop guard body\n                        member this.For(sequence:seq<_>, body) =\n                            this.Using(sequence.GetEnumerator(),fun enum -> \n                                this.While(enum.MoveNext, \n                                    this.Delay(fun () -> body enum.Current)))\n                                    \n                    let resultP = BuilderP()\n                    \n                    \n                /// Based on Nick Palladino's https://github.com/palladin/Eff\n                \n                [< AutoOpen >]\n                module Eff =\n                    type Effect  = abstract Extend : (Effect -> Effect) -> Effect\n                \n                    type Eff<'H, 'a> = Eff of (('a -> Effect) -> Effect) \n                        with  member this.Create = match this with Eff create -> create\n                \n                    let inline rtn  v : Eff<'H, 'a> = Eff (fun k -> k v)\n                    let bind  (f: 'a -> Eff<'H, 'b>) (effA: Eff<'H, 'a>) : Eff<'H, 'b> = \n                                        Eff (fun kb -> \n                                                let (Eff effKa) = effA\n                                                effKa (fun a -> \n                                                    let (Eff effKb) = f a\n                                                    effKb kb\n                                                )\n                                            )\n                    let inline map   f  m  = bind (f >> rtn) m\n                    let inline apply fR vR = fR |> bind (fun f -> map f vR)\n                \n                    type Done<'a>(v : 'a) =\n                        member self.Value = v\n                        interface Effect with member self.Extend(_) : Effect = self :> _\n                \n                    let done'  (v : 'a) : Effect = new Done<'a>(v) :> _ \n                    //let return'(v : 'a) : Eff<'H, 'c> = Eff( fun _ -> done' v )\n                    let return' v = Eff( fun _ -> done' v )\n                \n                    let run<'H, 'a> (eff: Eff<'H, 'a>) : 'a =\n                        match eff.Create done' with\n                        | :? Done<'a> as done' -> done'.Value\n                        | v                    -> failwithf \"Unhandled effect %A\" v\n                \n                    let inline runResult<'H, 'a> eff = \n                        try run<'H, 'a> eff |> Ok\n                        with e -> Error(e.ToString())\n                \n                \n                    let inline (<*>) f v   = apply f v\n                    let inline (|>>) v f   = map   f v\n                    let inline (>>=) v f   = bind  f v\n                    let inline (>->) f g v = f v |>> g\n                    let inline (>=>) f g v = f v >>= g\n                    \n                    let inline join m = m |> bind id\n                    \n                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |>> Seq.ofList\n                    let inline sequenceSeq           sq = traverseSeq id sq\n                    \n                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)\n                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)\n                    \n                    let inline bindO (f:'a->Eff<'H,'b>) (ef:Eff<'H,'a option>) = bind (Option.map f >> insertO) ef\n                    let rec whileLoop cond fEf =\n                        if   cond () \n                        then fEf  () |> bind (fun () -> whileLoop cond fEf)\n                        else rtn  ()\n                    \n                    \n                    type EffBuilder<'H>() =\n                        member __.ReturnFrom            vEf        : Eff<'H, _   > =           vEf\n                        member __.Return                v          : Eff<'H, _   > = rtn       v  \n                        member __.Zero                  ()         : Eff<'H, unit> = rtn       () \n                        member __.Bind                 (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Combine              (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf\n                        member __.Delay                       fEf                  = fEf\n                        member __.Run                         fEf  : Eff<'H, _   > = rtn () |> bind fEf\n                        member this.TryWith   (body, handler     ) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                        member this.TryFinally(body, compensation) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                        member this.Using     (disposable, body  ) : Eff<'H,_> = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                                    let body' = fun () -> body disposable\n                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                        member __.While   (guard , fEf) : Eff<'H, unit> = whileLoop guard fEf \n                        member th.For  (s: 'a seq, fEf) : Eff<'H, unit> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                        th.While(enum.MoveNext,\n                                                                                            th.Delay(fun () -> fEf enum.Current)))\n                    \n                    let eff<'H> = EffBuilder<'H>()\n                    \n                    //type EffBuilder<'H>() =\n                    //    member self.Zero      (                 ) = rtn ()\n                    //    member self.Return    (v   :         'A ) = rtn v\n                    //    member self.ReturnFrom eff                = eff\n                    //    member self.Bind      (eff, f           ) = bind f eff\n                    //    member self.Combine   (first, second    ) = bind (fun () -> second) first\n                    //    member __.Combine   (vEf,  fEf) : Eff<'H  , 'm> = bind fEf  vEf\n                    //    member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)\n                    ////    member inline __.Delay       f                  = f\n                    //    member __.While(guard, body) =\n                    //        let rec whileLoop guard body =\n                    //            if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    //            else rtn   ()\n                    //        whileLoop guard body\n                    //    member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)\n                    //    member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )\n                    //    member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )\n                    //                let body' = fun () -> body disposable\n                    //                this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )\n                    //    member this.For(sequence:seq<_>, body) =\n                    //        this.Using(sequence.GetEnumerator(),fun enum -> \n                    //            this.While(enum.MoveNext, \n                    //                fun () -> this.Delay(fun () -> body enum.Current)))\n                    //\n                    //\n                    //let eff<'H> = new EffBuilder<'H>()\n                    \n                    //type EA<'H, 'a, 'b> = 'a -> Eff<'H, 'b>\n                    /// Equal to (|>) \n                    //let (>|>) (ea:EA<_,_,_>) f : EA<_,_,_> = ea |> f\n                    /// Equal to (>>)\n                    //let (>>>) = (>>)\n                    \n                    module EA =\n                        let tee (f: 'a -> Eff<'H, unit>) : 'a -> Eff<'H, 'a> = (fun v -> f v |> map (fun () -> v) )\n                    \n                    //    let mapOutput  f (ea: EA<_,_, _>) : EA<_,_,          _   > = ea >> (bind (f >> rtn) )\n                    //    let bindOutput(f: EA<_,_, _>) (ea: EA<_,_, _>) : EA<_,_, _> = ea >> (bind  f  )\n                    //    let mapBoth    f (ea: EA<_,_, _>) : EA<_,_,          _   > = fun i -> i |> mapOutput (f i) ea\n                    //    let bindBoth   f (ea: EA<_,_, _>) : EA<_,_,          _   > = mapBoth f  ea |> bindOutput id\n                    //\n                    //    let mapO         (ea: EA<_,_, _>) : EA<_,_,          _   > = Option.map ea >> insertO\n                    //\n                    //    let mapFst     f (a, b) = (f a,   b)\n                    //    let mapSnd     f (a, b) = (  a, f b)\n                    //\n                    //    let bindFst    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fa = f a\n                    //        return (fa, b)\n                    //    }\n                    //\n                    //    let bindSnd    (f:EA<_,_,_>) (a, b) = eff {\n                    //        let! fb = f b\n                    //        return (a, fb)\n                    //    }\n                    //\n                    //    let lift    f : EA<_,_,_> = f >> rtn\n                    //    let pairWith v ea : EA<_,_,_> =\n                    //        ea\n                    //        >-> fun fst -> fst, v\n                    //\n                    //    let getResult ea:EA<_,_,_> = ea >-> Ok\n                    \n                    \n                    module Reader =\n                        type Reader<'E> = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type Ask<'E>(k : 'E -> Effect) =\n                            member self.K = k\n                            interface Effect with\n                                member self.Extend extension : Effect = new Ask<'E>(k >> extension) :> _\n                    \n                        let ask() : Eff<'H, 'E> when 'H :> Reader<'E> = Eff (fun k -> Ask(k) :> _ )\n                    \n                        let readerHandler<'E, 'H, 'a when 'H :> Reader<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = \n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? Ask<'E>  as ask   -> ask.K env          |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        let readerFun f = ask() |> map f \n                    module Log = \n                        type Log< 'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log1<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                        type Log2<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects\n                    \n                        type LogEntry<'L>(v : 'L, k : unit -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect with\n                                member self.Extend extension  : Effect = new LogEntry<'L>(v, k >> extension) :> _\n                    \n                        let log (s:'L)  : Eff<'H, unit> when 'H :> #Log< 'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let logf fmt = Printf.ksprintf log fmt\n                        let log1 (s:'L) : Eff<'H, unit> when 'H :> #Log1<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                        let log2 (s:'L) : Eff<'H, unit> when 'H :> #Log2<'L> = Eff (fun k -> LogEntry(s, k) :> _ )\n                    \n                        let pureLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = \n                            let rec loop (exitK:('a * list<'L>) -> Effect) (ls: list<'L>) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> (done'.Value, ls)  |>       exitK\n                                | :? LogEntry<'L> as log   -> log.K ()           |>  loop exitK (log.Value :: ls)  \n                                | effect                   -> effect.Extend         (loop exitK ls               )\n                            Eff (fun exitK                 -> eff.Create done'   |>  loop exitK []               )\n                    \n                    \n                        let consoleLogHandler<'L, 'H, 'a when 'H :> Log<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let loggerLogHandler<'L, 'H, 'a when 'H :> Log<'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> logger log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                        let consoleLogHandler1<'L, 'H, 'a when 'H :> Log1<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function\n                                | :? Done<    'a> as done' -> done'.Value        |>      exitK\n                                | :? LogEntry<'L> as log   -> printfn \"Log1: %A\" log.Value\n                                                              log.K ()           |> loop exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)\n                    \n                    module Rsl = \n                    \n                    \n                        type Rsl<'M> = interface end\n                        \n                        type IRsl<'M> = abstract Value : 'M\n                    \n                        type Fail<'a,'M>(v : 'M, k : 'a -> Effect) =\n                            member self.Value = v\n                            member self.K     = k\n                            interface Effect   with member __.Extend extension : Effect = new Fail<'a,'M>(v, k >> extension) :> _\n                            interface IRsl<'M> with member __.Value = v\n                    \n                        let fail (s:'M) : Eff<'H, _> when 'H :> #Rsl<'M> = Eff (fun k -> new Fail<_,_>(s, k) :> _)\n                        let failf fmt = Printf.ksprintf fail fmt\n                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {\n                            match res with\n                            | Ok    v   ->  return v\n                            | Error msg ->  let! m = fail msg\n                                            return failwith \"this code should be unreachable\"\n                        }\n                        \n                        let rslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = \n                            let rec loop (exitK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function\n                                | :? Done<    'A> as done' -> Ok    done'.Value |>       exitK\n                                | :? IRsl<    'M> as fail  -> Error fail .Value |>       exitK\n                                | effect                   -> effect.Extend        (loop exitK)\n                            Eff (fun exitK                 -> eff.Create done'  |>  loop exitK)\n                    \n                        let inline getResult   v                = map Ok v\n                        let inline absorbR     vvEf             = vvEf  |> bind ofResult\n                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR\n                    \n                    module Asy = \n                        type Asy = interface end // this acts as a reminder to add a handler for the Effect\n                    \n                        type AsynG =\n                            abstract RunSync      : unit               -> Effect\n                            abstract RunAsync<'a> : (Effect -> Effect) -> Effect\n                    \n                        [< Inline \"console.log('RunSynch Not implemented in JavaSacript')\" >]\n                        let runSynch v = Async.RunSynchronously v\n                    \n                        type Asyn<'v>(v : Async<'v>, k : ('v -> Effect) ) =\n                            member __.Value = v\n                            member __.K     = k\n                            interface Effect with member __.Extend   extension = new Asyn<_>(v, k >> extension) :> _\n                            interface AsynG  with \n                                member __.RunSync  ()        = runSynch v |> k\n                                member __.RunAsync<'a> exitK = done' (v |> Async.bind (fun v -> k v |> exitK :?> Done<Async<'a>> |> fun don -> don.Value ) )\n                    \n                        let inline ofAsync (v:Async<'a>) : Eff<'H, 'a> when 'H :> Asy= Eff (fun k -> new Asyn<'a>(v, k) :> _)\n                    \n                        /// This handler uses RunSynchronously to resolve Asyncs\n                        let syncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =\n                            let rec loop (exitK:'a -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value        |>      exitK\n                                | :? AsynG    as asy   -> asy.RunSync()      |> loop exitK\n                                | effect               -> effect.Extend        (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)\n                    \n                        /// this should be the last handler before Eff.run\n                        let asyncHandler0<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            let rec loop (exitK:(Async<'a>) -> Effect) : Effect -> Effect = function\n                                | :? Done<'a> as done' -> done'.Value |> async.Return |>      exitK\n                                | :? AsynG    as asy   -> asy.RunAsync<'a>              (loop exitK)\n                                | effect               -> effect.Extend                 (loop exitK)\n                            Eff (fun exitK             -> eff.Create done'            |> loop exitK)\n                    \n                        let asyncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = \n                            Async.rtn () \n                            |>  ofAsync \n                            >>= fun () -> eff \n                            |>  asyncHandler0\n                    \n                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n                \n                /// A computation expression to build an Async<Result<'ok, 'error>> value\n                module AsyncResult =\n                    let mapError fE v  = v |> Async.map (Result.mapError fE)\n                    let freeMessage v  = v |> Async.map  Result.freeMessage\n                \n                    let rtn        v   = async.Return(Ok v  )\n                    let rtnR       vR  = async.Return    vR\n                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n                    let bind  fRA  vRA = async { \n                        let! vR       = vRA\n                        match   vR with\n                        | Ok    v -> return! fRA v\n                        | Error m -> return  Error m \n                    }\n                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n                        try \n                            let!  vR = vRA\n                            match vR with\n                            | Ok    v -> return! fRA   v\n                            | Error m -> return  Error m\n                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n                    }\n                    let inline map  f m = bind  (f >> rtn) m            \n                    let inline mapP f m = bindP (f >> rtn) m            \n                    let rec whileLoop cond fRA =\n                        if   cond () \n                        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n                        else rtn  ()\n                    let (>>=)                              v f = bind f v\n                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n                    let inline sequenceSeq                  sq = traverseSeq id sq\n                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n                    let absorbR   vRRA                         = vRRA |> Async.map  Result.join\n                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n                \n                type AsyncResultBuilder() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                            = fRA\n                    member __.Run              fRA                            = AsyncResult.rtn () |> AsyncResult.bind fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                    th.While(enum.MoveNext,\n                                                                                      th.Delay(fun () -> fRA enum.Current)))\n                let asyncResult = AsyncResultBuilder()\n                \n                type AsyncResultBuilderP() =\n                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n                    member __.Delay            fRA                                          = fRA\n                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                                              th.While(enum.MoveNext,\n                                                                                                th.Delay(fun () -> fRA enum.Current)))\n                let asyncResultP = AsyncResultBuilderP()\n                \n                [<AutoOpen>]\n                module Extensions =      \n                    // Having Async<_> members as extensions gives them lower priority in\n                    // overload resolution between Async<_> and Async<Result<_,_>>.\n                    type AsyncResultBuilder with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n                \n                    type AsyncResultBuilderP with\n                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n                \n                \n                \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = if n < 0 \n                                                  then this.Substring2(0, this.Length + n)\n                                                  else this.Substring2(0, n              )\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n                member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n            \n            let mapFst     (f: 'a->'c) (a:'a, b:'b) = (f a,   b)\n            let mapSnd     (f: 'b->'c) (a:'a, b:'b) = (  a, f b)\n            \n            module Array =\n            \n                /// Non-mutable element replace\n                /// produces a new array with the new element\n                let replace i item (array: _[]) = \n                    seq {\n                        if i > 0            then yield! array.[.. i - 1]\n                        yield item\n                        if i < array.Length then yield! array.[i + 1 ..]\n                    } |> Seq.toArray\n            \n                let remove i (array: _[]) = \n                    seq {\n                        if i > 0            then yield! array.[.. i - 1]\n                        if i < array.Length then yield! array.[i + 1 ..]\n                    } |> Seq.toArray\n            \n            ///    let ls = [ \"d1d\"; \"a\"; \"b\"; \"c\"; \"a3a\"; \"b2b\"; \"c1c\"]\n            ///    \n            ///    ls |> List.sortWith ( asc Seq.length)            |> print // [\"a\"; \"b\"; \"c\"; \"dd\"; \"aa\"; \"bb\"; \"cc\"]\n            ///    ls |> List.sortWith (desc Seq.length &> asc (Seq.tryItem 1) &> asc  id) |> print // [\"aa\"; \"bb\"; \"cc\"; \"dd\"; \"a\"; \"b\"; \"c\"]\n            ///    ls |> List.sortWith ( asc Seq.length &> desc id) |> print // [\"c\"; \"b\"; \"a\"; \"dd\"; \"cc\"; \"bb\"; \"aa\"]\n            module SortWith =\n                let asc   f    a b = compare (f a) (f b)\n                let desc  f    a b = compare (f b) (f a)\n                let (&>) c1 c2 a b = match c1 a b with 0 -> c2 a b | r -> r\n            \n            module ParseO =\n                let tryParseWith tryParseFunc = tryParseFunc >> function\n                        | true, v    -> Some v\n                        | false, _   -> None\n            \n            \n                /// Javascript adds time zone information when parsing a date and that can change the result\n                let parseDateO2  = (fun s -> s + \"T00:00:00\") >> tryParseWith System.DateTime.TryParse\n                let parseDateO   = tryParseWith System.DateTime.TryParse\n                let parseIntO    = tryParseWith System.Int32   .TryParse\n                let parseInt64O  = tryParseWith System.Int64   .TryParse\n                let parseSingleO = tryParseWith System.Single  .TryParse\n                let parseDoubleO = tryParseWith System.Double  .TryParse\n                let parseGuidO   = tryParseWith System.Guid    .TryParse\n                // etc.\n                \n                // active patterns for try-parsing strings\n                let (|Date  |_|) = parseDateO\n                let (|Int   |_|) = parseIntO\n                let (|Int64 |_|) = parseInt64O\n                let (|Single|_|) = parseSingleO\n                let (|Double|_|) = parseDoubleO\n                let (|Guid  |_|) = parseGuidO\n                \n            module Serializer =\n                open System\n            \n                type JsonIntermediate = {\n                    tryFloat    : unit   ->  float                option\n                    tryInt      : unit   ->  int64                option\n                    tryString   : unit   ->  string               option\n                    tryBool     : unit   ->  bool                 option\n                    tryArray    : unit   -> (JsonIntermediate []) option\n                    tryField    : string ->  JsonIntermediate     option\n                    isObject    : unit   ->  bool\n                    isNull      : unit   ->  bool\n                }\n            \n                type SerS<'T> = ('T                 -> string   )        //      Serialization function\n                type SerD<'T> = (JsonIntermediate   -> 'T option)        //    deSerialization function\n                type Ser< 'T> = SerS<'T> * SerD<'T>                      // both Serialization functions\n            \n                let serialize (ser: Ser<_>) v = fst ser v\n                let (|Field|_|) field j = j.tryField field\n            \n                let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n                let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n                let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n            \n                let toJsonString (v:string) =\n                    seq {\n                        yield '\"'\n                        if String.IsNullOrEmpty v |> not then\n                            for i = 0 to v.Length - 1 do\n                                let c = v.[i]\n                                let ci = int c\n                                if ci >= 0 && ci <= 7 || ci = 11 || ci >= 14 && ci <= 31 then\n                                    yield! sprintf \"\\\\u%04x\" ci\n                                else \n                                match c with\n                                | '\\b' -> yield! \"\\\\b\"\n                                | '\\t' -> yield! \"\\\\t\"\n                                | '\\n' -> yield! \"\\\\n\"\n                                | '\\f' -> yield! \"\\\\f\"\n                                | '\\r' -> yield! \"\\\\r\"\n                                | '\"'  -> yield! \"\\\\\\\"\"\n                                | '\\\\' -> yield! \"\\\\\\\\\"\n                                | _    -> yield c\n                        yield '\"'\n                    } |> Seq.toArray|> String\n            \n                let serString : Ser<string> = toJsonString , (fun j -> j.tryString() )\n                let serFloat  : Ser<float > = sprintU      , (fun j -> j.tryFloat () )\n                let serInt    : Ser<int   > = sprintU      , (fun j -> j.tryInt   () |> Option.map int)\n                let serInt64  : Ser<int64 > = sprintf \"%d\" , (fun j -> j.tryInt   () )\n                let serBool   : Ser<bool  > = sprintU      , (fun j -> j.tryBool  () )\n            \n                let [< Inline >] inline serId  (get: 'a -> System.Guid) (set:System.Guid -> 'a) (print: 'a->string) : Ser<'a> =\n                    let s               = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n                    let sQ              = sprintf \"%A\" s\n                    let serialize   gid = get gid |> string |> sprintf \"{%10s :%A}\" sQ\n                    let deserialize j   = j.tryField s \n                                          |> Option.bind (fun jf -> jf.tryString() ) \n                                          |> Option.bind ParseO.parseGuidO \n                                          |> Option.map  set\n                    serialize, deserialize\n            \n                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n                    serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc j -> deser j |> Option.map (fun v -> set v rc) ) \n                    \n                let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n                    if isNull (init :> obj) then failwith \"Initial record is null\"\n                    let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n                    let deserialize j   = fields |> Seq.fold (fun dim (n, _ser,  deser) -> j.tryField n |> Option.bind (deser dim) |> Option.defaultValue dim)   init |> Some\n                    serialize, deserialize\n                \n                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.ofArray)\n                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser))                          )\n                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.toList )\n                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Set        )\n                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\"              ), (fun j -> (if j.isNull() then None else              snd ser j)|> Some                  )\n                let serDup(serFst,serSnd): Ser<'a * 'b    > = (fun (f,s  ) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s) ), (fun j -> j.tryArray () \n                                                                                                                                            |> function \n                                                                                                                                                | Some [| j1 ; j2 |] -> match snd serFst j1, snd serSnd j2 with\n                                                                                                                                                                        | Some f, Some s -> Some(f, s) |_->None\n                                                                                                                                                | _ -> None )\n                let serTrp(sF,sS,sT)      : Ser<'a *'b*'c > = (fun (f,s,t) -> sprintf \"[%s, %s, %s]\" (fst sF f) (fst sS s)  (fst sT t)) , (fun j -> j.tryArray () \n                                                                                                                                                    |> function \n                                                                                                                                                        | Some [| j1 ;j2; j3|]   -> match snd sF j1, snd sS j2, snd sT j3 with\n                                                                                                                                                                                    | Some f, Some s, Some t -> Some(f, s, t) |_-> None\n                                                                                                                                                        | _ -> None ) \n                let serMap serKey serElm : Ser<Map<'k, 'e>> =   serDup(serKey, serElm)\n                                                                |> serSeq \n                                                                |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Option.map Map) )\n            \n            \n        /// Essentials that cannot run in Javascript (WebSharper)\n        [< AutoOpen >]\n        module LibraryNoJS =\n            let rec getNamespace (t:System.Type) =\n                match t.DeclaringType with\n                | null -> match t.Namespace with null -> \"\" | ns -> ns + \".\"\n                | dt   -> getNamespace dt + dt.Name + \".\"\n            \n            let rec getTypeName (t:System.Type) =\n                if t.IsArray then getTypeName (t.GetElementType()) + \"[]\" else\n                let ns    = getNamespace t\n                let name  = if   t.Name = \"FSharpOption`1\"                then \"Option\"\n                            elif t.Name = \"FSharpList`1\"                  then \"List\"\n                            elif ns     = \"Microsoft.FSharp.Core.\"\n                              || ns     = \"Microsoft.FSharp.Collections.\" then t.Name   \n                            else  ns + t.Name\n                let name2 = name.Split('`').[0]\n                let parms = t.GenericTypeArguments |> Seq.map getTypeName |> String.concat \",\"\n                if parms = \"\" then name2 else sprintf \"%s<%s>\" name2 parms\n            \n            module DiscUnion =\n                open FSharp.Reflection\n            \n                let simple<'U> =\n                    FSharpType.GetUnionCases typeof<'U>\n                    |> Seq.filter (fun c -> c.GetFields() |> Seq.isEmpty )\n                    |> Seq.map (fun c -> c.Name)\n                    |> Seq.toArray\n            \n                let caseTuple (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType)\n                    if types.Length = 1 then c.Name, types.[0], vs.[0] else\n                    let ttype = FSharpType.MakeTupleType(types)\n                    c.Name, ttype, FSharpValue.MakeTuple(vs, ttype)\n            \n                let caseArray (v:'T) = \n                    let c, vs = FSharpValue.GetUnionFields(v, typeof<'T>)\n                    let types = c.GetFields() |> Array.map (fun p -> p.PropertyType.FullName)\n                    c.Name, Array.zip types vs\n            \n                let caseInfos<'T>            = FSharpType.GetUnionCases typeof<'T>\n                let caseInfo< 'T> (s:string) = caseInfos<'T> |> Seq.find (fun c -> c.Name = s)\n            \n            //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n            module Serializer =\n                open Serializer\n                open FSharp.Data\n            \n                let rec getJsonIntermediate df di ds db da (j:JsonValue) : JsonIntermediate =\n                    let jsonInt = getJsonIntermediate df di ds db da\n                    {\n                        tryFloat    = fun () -> (match j with JsonValue.Float   v ->       v |> Some | JsonValue.Number v -> float v |> Some    |_-> None) |> Option.orElseWith df\n                        tryInt      = fun () -> (match j with JsonValue.Float   v -> int64 v |> Some | JsonValue.Number v -> int64 v |> Some    |_-> None) |> Option.orElseWith di\n                        tryString   = fun () -> (match j with JsonValue.String  v ->       v |> Some                                            |_-> None) |> Option.orElseWith ds\n                        tryBool     = fun () -> (match j with JsonValue.Boolean v ->       v |> Some                                            |_-> None) |> Option.orElseWith db\n                        tryArray    = fun () -> (match j with JsonValue.Array   v ->       v |> Array.map jsonInt |> Some                       |_-> None) |> Option.orElseWith (fun () -> da  jsonInt   )\n                        tryField    = fun fl -> j.TryGetProperty fl |> Option.map jsonInt                                                                 \n                        isObject    = fun () -> (match j with JsonValue.Record  _ ->       true |_-> false)\n                        isNull      = fun () -> (match j with JsonValue.Null      ->       true |_-> false)\n                    }\n            \n            \n                let deserialize df di ds db da (ser: Serializer.Ser<_>) js = \n                    JsonValue.TryParse js //|>! print\n                    |> Option.map  (getJsonIntermediate df di ds db da)\n                    |> Option.bind (snd ser)\n            \n                let tryDeserialize ser = \n                    deserialize\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        (fun _   -> None)\n                        ser\n            \n                let deserializeWithDefs ser = \n                    deserialize\n                        (fun _   -> Some 0.0                          )\n                        (fun _   -> Some 0L                           )\n                        (fun _   -> Some \"\"                           )\n                        (fun _   -> Some false                        )\n                        (fun _   -> Some [||]                         )\n                        ser\n            \n                let deserializeWithFail ser = \n                    deserialize\n                        (fun _   -> failwith  \"Error expecting float\"    )\n                        (fun _   -> failwith  \"Error expecting int\"      )\n                        (fun _   -> failwith  \"Error expecting string\"   )\n                        (fun _   -> failwith  \"Error expecting bool\"     )\n                        (fun _   -> failwith  \"Error expecting array\"    )\n                        ser\n            \n                open FSharp.Reflection\n            \n                let inline serObj ((ser, deser):Ser<'T>) : string * Ser<obj> = typeof<'T> |> getTypeName, (unbox >> ser, deser >> Option.map box)\n            \n                let serDU<'DU when 'DU : equality> (sers : (string * Ser<obj>) seq) =\n                    let cases  = FSharpType.GetUnionCases             typeof<'DU>\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType  |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (typeof<'DU> |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = box<'DU> >> FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case >> unbox<'DU>\n                                let serC (v:'DU) =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = box<'DU> >> FSharpValue.PreComputeUnionTagReader typeof<'DU> >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.tryPick(fun case -> match j with Field case.Name _ -> Some case |_-> None) |> Option.defaultWith (fun () -> failwithf \"Could not find DU element %A\" j)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n            \n                let serDUt (sers : (string * Ser<obj>) seq) (ttype:System.Type) =\n                    let cases  = FSharpType.GetUnionCases ttype\n                    let dCases =\n                        cases\n                        |> Array.map (fun case ->\n                            if case.GetFields().Length = 0 then\n                                let serC         _ = sprintf \"{%A:1}\" case.Name\n                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some \n                                case.Tag, (serC, deserC)\n                            else\n                                let sers2 =\n                                    case.GetFields() |> Array.map(fun fld ->\n                                        let tn = fld.PropertyType |> getTypeName\n                                        sers \n                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)\n                                        |> Option.defaultWith (fun () -> \n                                            sers |> Seq.map fst |> String.concat \", \"\n                                            |> failwithf \"serDU: Could not find Ser<%s> for %s. Provided: %s\" tn (ttype |> getTypeName) \n                                        )\n                                    ) \n                                let getValues      = FSharpValue.PreComputeUnionReader case \n                                let setValues      = FSharpValue.PreComputeUnionConstructor case\n                                let serC v =\n                                    Seq.zip (getValues v) sers2\n                                    |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                    |> String.concat \", \"\n                                    |> sprintf \"{%A:[%s]}\" case.Name\n                                let deserC (j:JsonIntermediate) = \n                                    match j with \n                                    | Field case.Name j2 ->\n                                        match j2.tryArray () with\n                                        | None -> None\n                                        | Some js -> \n                                        Array.zip js sers2\n                                        |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                        |> setValues\n                                        |> Some\n                                    |_-> None \n                                case.Tag, (serC, deserC)\n                        ) |> dict\n                    let readTag   = FSharpValue.PreComputeUnionTagReader ttype >> fun i -> dCases.[i]\n                    let serDU   v = (readTag v |> fst) v\n                    let deserDU j =\n                        let case =  cases |> Seq.pick(fun case -> match j with Field case.Name _ -> Some case |_-> None)\n                        snd dCases.[case.Tag] j\n                    serDU, deserDU\n                    \n            module Default =\n                open FSharp.Reflection\n            \n                let defaults vs = vs |> Seq.map (fun v -> v.GetType().FullName, v ) |> dict\n            \n                let defs = \n                    defaults [\n                        box 0\n                        box 0L\n                        box 0.\n                        box 0.F\n                        box \"\"\n                        box false\n                        box System.Guid.Empty\n                        box System.DateTime.MinValue\n                    ]\n            \n                let rec defaultValue defs (t:System.Type) : obj =\n                    match (defs:System.Collections.Generic.IDictionary<string, obj>).TryGetValue t.FullName with\n                    | true , v -> v\n                    | false, _ ->\n                    if t.IsArray then \n                        System.Array.CreateInstance(t.GetElementType(), 0) |> box\n                    elif t.IsEnum then\n                        (System.Enum.GetValues t).GetValue [| 0 |] |> box\n                    else\n                    let c = t.GetConstructor System.Type.EmptyTypes\n                    if  isNull c |> not then\n                        c.Invoke [||]\n                    elif FSharpType.IsRecord t then\n                        FSharpType.GetRecordFields t\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeRecord(t, os)\n                    elif FSharpType.IsTuple t then\n                        FSharpType.GetTupleElements t\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeTuple(os, t)\n                    elif FSharpType.IsUnion t then\n                        let case = FSharpType.GetUnionCases t |> Seq.head\n                        case.GetFields()\n                        |> Array.map (fun fld -> fld.PropertyType )\n                        |> createArray (defaultValue defs)\n                        |> fun os -> FSharpValue.MakeUnion(case, os)\n                    else failwithf \"Could no create default for %s\" t.FullName\n            \n                and createArray defs (ts : System.Type []) = ts |> Array.map defs\n            \n                let inline value<'T> : 'T = typeof<'T> |> defaultValue defs |> unbox\n            \n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module Promise =\n                let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n                    new Promise<'a>(fun (resolve, reject) ->\n                        Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n                    )\n            \n            module Pojo =\n                let addProp prop (pojo:JSObject) = pojo.Add prop ; pojo\n                \n                let newPojo props =\n                    let pojo = JSObject()\n                    if IsClient then\n                        props |> Seq.iter (swap addProp pojo >> ignore)\n                    pojo\n            \n                let newPojoOpt (propOs : seq<string * obj option>) =\n                    propOs\n                    |> Seq.choose(fun (n,vO) -> vO |> Option.map(fun v -> n,v))\n                    |> newPojo\n            \n            module Date =\n                let toYYYYMMDD sep (date:System.DateTime) = sprintf \"%d%s%02d%s%02d\" date.Year sep  date.Month sep date.Day\n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            let rexEmail = \"\"\"(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            module Msal =\n            \n                type Policy =\n                | SignIn\n                | SignUp\n                | EditProfile\n                | ResetPassword\n                with \n                    static member Parse (txt:string) = \n                        match txt.Replace(\" \", \"\") with\n                        | \"SignUp\"        -> SignUp\n                        | \"EditProfile\"   -> EditProfile\n                        | \"ResetPassword\" -> ResetPassword\n                        | _               -> SignIn\n                    override this.ToString() = (sprintf \"%A\" this).toUnderscore.Replace('_', ' ')\n            \n                let policies = [\n                    SignIn\n                    SignUp\n                    EditProfile\n                    ResetPassword\n                ]\n                \n                type TokenReceivedCallback = (string * string * string * string * string) -> unit\n            \n                let (==>) (n:string) (vO: _ option) = n, (vO |> Option.map (fun v -> v :> obj))\n            \n                [< AllowNullLiteral >]\n                type User (displayableId: string, name: string, identityProvider: string, userIdentifier: string, idToken: obj, sid: string) =\n                    [< Inline \"User.createUser($idToken, $clientInfo)\" >]\n                    static member createUser(idToken: obj, clientInfo: obj) : User = X<_>\n            \n                type UserAgentApplication\n                    [< Inline \"new $global.Msal.UserAgentApplication($clientId, $authority, $tokenReceivedCallback, $options)\" >]\n                    (clientId: string, authority: string, tokenReceivedCallback: TokenReceivedCallback, options: JSObject) =\n            \n            \n                    static member Options( \n                                          ?cacheLocation             : string\n                                        , ?isAngular                 : bool\n                                        , ?loadFrameTimeout          : int\n                                        , ?logger                    : obj\n                                        , ?navigateToLoginRequestUrl : bool\n                                        , ?postLogoutRedirectUri     : string\n                                        , ?protectedResourceMap      : Map<string, Array<string>>\n                                        , ?redirectUri               : string\n                                        , ?state                     : string\n                                        , ?storeAuthStateInCookie    : bool\n                                        , ?unprotectedResources      : Array<string>\n                                        , ?validateAuthority         : bool) =\n                        Pojo.newPojoOpt [\n                            \"cacheLocation\"             ==> cacheLocation\n                            \"isAngular\"                 ==> isAngular                \n                            \"loadFrameTimeout\"          ==> loadFrameTimeout         \n                            \"logger\"                    ==> logger                   \n                            \"navigateToLoginRequestUrl\" ==> navigateToLoginRequestUrl\n                            \"postLogoutRedirectUri\"     ==> postLogoutRedirectUri    \n                            \"protectedResourceMap\"      ==> protectedResourceMap     \n                            \"redirectUri\"               ==> redirectUri              \n                            \"state\"                     ==> state                    \n                            \"storeAuthStateInCookie\"    ==> storeAuthStateInCookie   \n                            \"unprotectedResources\"      ==> unprotectedResources     \n                            \"validateAuthority\"         ==> validateAuthority           \n                        ] \n            \n                    [< Inline \"$this.loginPopup($scopes,$extraQueryParameters)                              \" >] member this.loginPopup          (scopes: string [], extraQueryParameters: string                               ): Promise<string> = X<_>\n                    [< Inline \"$this.loginRedirect($scopes,$extraQueryParameters)                           \" >] member this.loginRedirect       (scopes: string [], extraQueryParameters: string                               ): Promise<string> = X<_>\n                    [< Inline \"$this.acquireTokenSilent  ($scopes, $authority, $user, $extraQueryParameters)\" >] member this.acquireTokenSilent  (scopes: string [], authority: string, user: User, extraQueryParameters: string): Promise<string> = X<_>\n                    [< Inline \"$this.acquireTokenRedirect($scopes, $authority, $user, $extraQueryParameters)\" >] member this.acquireTokenRedirect(scopes: string [], authority: string, user: User, extraQueryParameters: string): Promise<string> = X<_>\n                    [< Inline \"$this.acquireTokenPopup   ($scopes, $authority, $user, $extraQueryParameters)\" >] member this.acquireTokenPopup   (scopes: string [], authority: string, user: User, extraQueryParameters: string): Promise<string> = X<_>\n                    [< Inline \"$this.logout()                                                               \" >] member this.logout              ()                                                                              : unit            = X<_>\n                    [< Inline \"$this.getUser()                                                              \" >] member this.getUser             ()                                                                              : User            = X<_>\n                    [< Inline \"$this.getUserState($state)                                                   \" >] member this.getUserState        (state: string)                                                                 : string          = X<_>\n            \n    \n    module ProzperServer =\n        [< AutoOpen ; JavaScript >]\n        module Basico =\n            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id\n            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id\n            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id\n            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id\n        \n            type VariableAmbienteI   = \n                    abstract getVar  : string -> string\n                    abstract member CarpetaRaiz          : unit     -> string\n        \n            let variableAmbienteE v  = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.getVar     v \n            let carpetaRaiz       () = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.CarpetaRaiz()\n        \n        \n        [< AutoOpen ; JavaScript >]\n        module TypesV0 =\n            type LatestType = TypeV0\n        \n            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id\n            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id\n            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id\n            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id\n        \n            type StatusAliado =\n            | CuentaCreada\n            | DatosBancariosIngresados\n            | Activo\n            | Inactivo\n            | Cancelado\n                with\n                    override this.ToString() = sprintf \"%A\" this\n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"CUENTACREADA\"             -> CuentaCreada\n                        | \"DATOSBANCARIOSINGRESADOS\" -> DatosBancariosIngresados\n                        | \"ACTIVO\"                   -> Activo\n                        | \"CANCELADO\"                -> Cancelado\n                        | _                          -> Inactivo\n        \n            type TipoAliado =\n            | Master\n            | Regular\n                with\n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Pais =\n            | USA\n            | Venezuela \n            | Argentina\n            | OtroP of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"EEUU\" | \"UNITED STATES\"  | \"UNITED STATES OF AMERICA\" | \"US\" | \"E.E.U.U.\" | \"AMERICA\"\n                        | \"USA\"            -> Some <| USA\n                        | \"VENEZUELA\"      -> Some <| Venezuela\n                        | \"ARGENTINA\"      -> Some <| Argentina\n                        | _                -> Some <| (OtroP <| s.Trim() )\n                    override this.ToString() = match this with OtroP s -> s | v -> sprintf \"%A\" v\n        \n            type Estado =\n            | Texas\n            | Florida\n            | OtroS of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"TX\"\n                        | \"TEXAS\"          -> Some <| Texas\n                        | \"FL\"\n                        | \"FLORIDA\"        -> Some <| Florida\n                        | _                -> Some <| (OtroS <| s.Trim() )\n                    override this.ToString() = match this with OtroS s -> s | v -> sprintf \"%A\" v\n        \n            type Territorio =\n            | Estado of Estado\n        \n            type Emisor =\n            | Pais       of Pais\n            | Territorio of Territorio\n        \n            type Documento =\n            | Pasaporte        of string\n            | Cedula           of string\n            | LicenciaConducir of string\n        \n            type Identificacion = {\n                emisor    : Emisor\n                documento : Documento\n                emision   : System.DateTime\n                vence     : System.DateTime\n            }\n        \n            type Mes =\n            | Enero      =  1\n            | Febrero    =  2\n            | Marzo      =  3\n            | Abril      =  4\n            | Mayo       =  5\n            | Junio      =  6\n            | Julio      =  7\n            | Agosto     =  8\n            | Septiembre =  9\n            | Octubre    = 10\n            | Noviembre  = 11\n            | Diciembre  = 12\n        \n            type Expiracion = {\n                anio : int\n                mes  : Mes\n            } with\n                member this.Id = sprintf \"%04d-%02d\" this.anio (int this.mes)\n                static member TryParse (txt:string) =\n                    let create century (anio:string) (mes:string) =\n                        {\n                            anio = century   + int anio\n                            mes  = enum<Mes>  (int mes )\n                        } |> Some\n                    if txt.Length = 4 || txt.Length = 5 then \n                        create 2000 (txt.Right 2) (txt.Left  2)\n                    elif txt.Length = 7 then\n                        txt.Split[| '-' ; '/' |]\n                        |> function \n                            | [| py ; pm |] when py.Length = 4 -> create 0 py pm\n                            | [| pm ; py |] when py.Length = 4 -> create 0 py pm\n                            |_-> None\n                    else None\n        \n        \n            type NumeroCuenta   = NumeroCuenta  of string       with member this.Id = match this with NumeroCuenta  id -> id\n            type NumeroTarjeta  = NumeroTarjeta of string       with member this.Id = match this with NumeroTarjeta id -> id\n            type RoutingNumber  = RoutingNumber of string       with member this.Id = match this with RoutingNumber id -> id \n        \n            type TipoTarjeta     = \n            | Visa\n            | MasterCard\n            | Amex\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"                 -> None    \n                        | \"VISA\"             -> Some <| Visa\n                        | \"MASTERCARD\"       -> Some <| MasterCard\n                        | \"AMEX\"\n                        | \"AMERICAN EXPRESS\" -> Some <| Amex\n                        | _                  -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type TipoCuenta     = \n            | Ahorro\n            | Corriente\n            | Otra of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim().ToUpper() with\n                        | \"\"               -> None    \n                        | \"SAVINGS\"\n                        | \"AHORRO\"         -> Some <| Ahorro\n                        | \"CHECKING\"\n                        | \"CORRIENTE\"      -> Some <| Corriente\n                        | _                -> Some <| (Otra <| s.Trim() )\n                    override this.ToString() = match this with Otra s -> s | v -> sprintf \"%A\" v\n        \n            type CuentaBancaria = {\n                titular     : string\n                banco       : string\n                tipo        : TipoCuenta\n                numero      : NumeroCuenta\n                routing     : RoutingNumber\n            }\n        \n            type TarjetaCredito = {\n                titular     : string\n                tipoTarjeta : TipoTarjeta\n                numero      : NumeroTarjeta\n                expiracion  : Expiracion\n            }\n        \n            type ConceptoPago =\n            | PagoAfiliacion\n            | PagoComision\n            | Otro of string\n                with\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type Transaccion = {\n                fechaPago      : System.DateTime\n                ano            : int\n                periodo        : int\n                monto          : int\n                idAliado       : IdAliado\n                concepto       : ConceptoPago\n                transaccion    : string\n            }\n        \n            type TipoDireccion = \n            | Habitacion\n            | Oficina\n            | ServicioPostal\n            | Otro of string\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"\"               -> None    \n                        | \"Habitacion\"     -> Some <| Habitacion\n                        | \"Oficina\"        -> Some <| Oficina\n                        | \"ServicioPostal\" -> Some <| ServicioPostal\n                        | s                -> Some <| Otro s\n                    override this.ToString() = match this with Otro s -> s | v -> sprintf \"%A\" v\n        \n            type ZonaPostal = ZonaPostal of string\n                with \n                    static member tryParse (s:string) = if s.Trim() <> \"\" then Some (ZonaPostal <| s.Trim()) else None\n                    override this.ToString() = match this with ZonaPostal s -> s\n        \n            type Direccion = {\n                authorizeIdR  : Result<IdAddress, string>\n                tipoDireccion : TipoDireccion\n                linea1        : string\n                linea2        : string\n                ciudad        : string\n                estado        : Estado\n                pais          : Pais\n                zonaPostal    : ZonaPostal\n            }\n        \n            type TipoTelefono =\n            | Movil\n            | Oficina\n            | Habitacion\n            | Voip\n                with \n                    static member tryParse = function\n                        | \"Movil\"      -> Some Movil\n                        | \"Oficina\"    -> Some Oficina\n                        | \"Habitacion\" -> Some Habitacion\n                        | _            -> None    \n                    override this.ToString() = sprintf \"%A\" this\n        \n            type Telefono          = {\n                tipoTelefono : TipoTelefono\n                codigoPais   : string\n                codigoArea   : string\n                numero       : string\n                extension    : string\n                mensajes     : bool\n            }\n        \n            type CorreoElectronico = {\n                email       : string\n                enviado     : System.DateTime option\n                recibido    : System.DateTime option\n            }\n                with override this.ToString() = this.email\n        \n            type Contacto =\n            | Direccion         of Direccion\n            | CorreoElectronico of CorreoElectronico\n            | Telefono          of Telefono\n            | Mensajeria        of string\n            | PaginaWeb         of string\n            | SocialMedia       of string\n        \n            type Genero =\n            | Masculino\n            | Femenino\n            | Empresa\n                with \n                    static member tryParse (s:string) = \n                        match s.Trim() with\n                        | \"Masculino\"      -> Some <| Masculino\n                        | \"Femenino\"       -> Some <| Femenino\n                        | \"Empresa\"        -> Some <| Empresa\n                        | _                -> None    \n        \n            type DatosPersonales = {\n                titulo          : string option\n                nombre1         : string\n                nombre2         : string\n                apellido1       : string\n                apellido2       : string\n                nacionalidad    : Pais\n                genero          : Genero\n                fechaNacimiento : System.DateTime\n            }\n        \n            type CuentaPago =\n            | CuentaBancaria            of CuentaBancaria\n            | TarjetaCredito            of TarjetaCredito\n            | TransferenciaElectronica  of string\n        \n            type StatusFormaPago =\n            | NuevaFormaPago\n            | Registrada      of          System.DateTime option\n            | RegistroFallido of string * System.DateTime option\n        \n            type FormaPago = {\n                nombre          : string\n                authorizeIdR    : Result<IdPayment, string>\n                cuentaPago      : CuentaPago\n            }\n        \n            type TipoMensaje = \n            | Alerta\n            | Informacion\n            | Saludo\n        \n            type Remitente =\n            | Prozper\n            | Aliado of IdAliado\n            | OtroR  of string\n        \n            type Mensaje = {\n                tipo      : TipoMensaje\n                leido     : System.DateTime option\n                fecha     : System.DateTime\n                texto     : string\n                remitente : Remitente\n            }\n        \n            type PremisasCalculo = {\n                comisionReferidosRegular     : int\n                comisionReferidosMaster      : int\n                comisionDescendientesMaster  : int\n                comisionDescendientesRegular : int\n                montoAfiliacion              : int\n                numeroReferidosMaster        : int\n                diaCorte1                    : int\n                diaCorte2                    : int\n            }\n        \n            let premisasCalculo = {\n                comisionReferidosRegular     = 15\n                comisionReferidosMaster      = 25\n                comisionDescendientesMaster  = 25\n                comisionDescendientesRegular =  0\n                montoAfiliacion              = 75\n                numeroReferidosMaster        = 31\n                diaCorte1                    = 26\n                diaCorte2                    = 28\n            }\n        \n            let telVacio = {            \n                tipoTelefono = Movil\n                codigoPais   = \"\"\n                codigoArea   = \"\"\n                numero       = \"\"\n                extension    = \"\"\n                mensajes     = false\n            }\n        \n            let dirVacio = {\n                authorizeIdR  = Error \"\"\n                tipoDireccion = TipoDireccion.Habitacion\n                linea1        = \"\"\n                linea2        = \"\"\n                ciudad        = \"\"\n                estado        = OtroS \"\"\n                pais          = OtroP \"\"\n                zonaPostal    = ZonaPostal \"\"\n            }\n        \n            let tarVacio = {            \n                tipoTarjeta  = Visa\n                numero       = NumeroTarjeta \"\"\n                expiracion   = { anio = 2000 ; mes = Mes.Enero }\n                titular      = \"\"\n            }\n        \n            let ctaVacio = {            \n                banco        = \"\"\n                numero       = NumeroCuenta \"\"\n                tipo         = Ahorro\n                titular      = \"\"\n                routing      = RoutingNumber \"\"\n            }\n        \n            type DiaPago =\n            |   Dia01\n            |   Dia05\n            |   Dia10\n            |   Dia15\n            |   Dia20\n            |   Dia25\n        \n            type IdForAuthorize = IdForAuthorize of string  with member this.Id = match this with IdForAuthorize id -> id\n        \n            type Aliado = {\n                id              :      IdAliado\n                idPadreO        :      IdAliado       option\n                idForAuthorize  :      IdForAuthorize option\n                influyente      :      string         option\n                datosPersonales :      DatosPersonales\n                contactos       :      Contacto       []\n                identificacion  :      Identificacion []\n                isInternal      :      bool\n                status          :      StatusAliado\n                diaPago         :      DiaPago\n                tipo            :      TipoAliado\n                fechaRegistro   :      System.DateTime\n                fechaStatus     :      System.DateTime\n                nReferidos      :      int\n                nRefActivos     :      int\n                nDescendientes  :      int\n                nDescActivos    :      int\n                comision        :      int\n                nivel           :      int\n            }\n        \n            type Modelo = {\n                idAliado      : IdAliado\n                aliados       : Aliado []\n                anoActual     : int\n                periodoActual : int\n                premisas      : PremisasCalculo\n                nevento       : int64\n            }\n        \n            let modeloVacio = {\n                idAliado      = IdAliado \"\"\n                aliados       = [||]\n                anoActual     = System.DateTime.Now.Year\n                periodoActual = System.DateTime.Now.Month\n                premisas      = premisasCalculo\n                nevento       = 0L\n            }\n        \n            let correoVacio = {\n                email       = \"\"\n                enviado     = None\n                recibido    = None\n            }\n        \n        [< JavaScript >]\n        module Aliado =\n            open Operators\n        \n            //let statusActual ano mes al  =\n            //    al.transacciones.Value\n            //    |> Array.tryFind (fun t -> t.idAliado = al.id \n            //                            && t.ano      = ano\n            //                            && t.periodo  = mes\n            //                            && t.concepto = PagoAfiliacion)\n            //    |> Option.map    (fun _ ->  Activo )\n            //    |> Option.defaultValue    Inactivo\n        \n            open System.Collections.Generic\n        \n            let premisas pre al =\n                let comRef, comDes = match al.tipo  with\n                                     | Regular -> pre.comisionReferidosRegular, pre.comisionDescendientesRegular\n                                     | Master  -> pre.comisionReferidosMaster , pre.comisionDescendientesMaster\n                match al.status with\n                | Activo -> comRef, comDes\n                | _      -> 0     , 0\n        \n            let comision pre al = \n                let comRef, comDes = premisas pre al\n                al.nRefActivos * comRef, al.nDescActivos * comDes\n        \n            type Buscar = {\n                hijosDe        : (IdAliado -> IdAliado [])\n                nivelDe        : (IdAliado option -> int)\n                aliado         : (IdAliado -> Aliado)\n                aliadoO        : (IdAliado -> Aliado option)\n                hijos          : (Aliado -> Aliado [])\n                descendientes  : (Aliado -> Aliado [])\n            }\n        \n            let busqueda aliados =\n                let padres               = aliados \n                                           |> Seq.map(fun al -> al.idPadreO, al.id) \n                                           |> Seq.groupBy fst \n                                           |> Seq.map(fun (pO, ch) -> pO, ch |> Seq.map snd |> Seq.toArray) |> Map\n                let aliadosMap           = aliados |> Seq.map (fun al -> al.id, al) |> Map\n                let aliadoO          id  = match aliadosMap.TryGetValue id with\n                                           | true, al -> Some al\n                                           | _        -> None\n                let aliado           id  = try aliadosMap.[id] with e -> failwithf \"buscarAliado failed: %A\" id\n                let hijosDe          idO = match padres.TryGetValue (Some idO) with\n                                           | true, hijos -> hijos\n                                           | _           -> [||]\n                let rec nivelDe      idO = idO |> Option.bind aliadoO |> Option.map (fun al -> 1 + nivelDe al.idPadreO) |> Option.defaultValue 0\n                let hijos             al = hijosDe al.id |> Array.choose aliadoO\n                let rec descendientes al =\n                    [|\n                        for h in hijos al do\n                            yield                h\n                            yield! descendientes h\n                    |]\n                {\n                    hijosDe       = hijosDe       \n                    nivelDe       = nivelDe       \n                    aliado        = aliado        \n                    aliadoO       = aliadoO       \n                    hijos         = hijos         \n                    descendientes = descendientes \n                }\n        \n            let diaPago (registro:System.DateTime) =\n                let  diaMes = registro.Day\n                if   diaMes  =  1 then Dia01\n                elif diaMes <=  5 then Dia05\n                elif diaMes <= 10 then Dia10\n                elif diaMes <= 15 then Dia15\n                elif diaMes <= 20 then Dia20\n                elif diaMes <= 25 then Dia25\n                else                   Dia01\n        \n            let dia = function\n            | Dia01 ->  1\n            | Dia05 ->  5\n            | Dia10 -> 10\n            | Dia15 -> 15\n            | Dia20 -> 20\n            | Dia25 -> 25\n        \n            let actualizarAliados modelo =\n                let  buscar            = busqueda modelo.aliados\n                let pre                = modelo.premisas\n                let rec aliadoActualizado alid =\n                    let al             = buscar.aliado alid\n                    let hijos          = buscar.hijosDe al.id |> Seq.map aliadoActualizadoM |> Seq.cache\n                    let status         = al.status //statusActual modelo.anoActual modelo.periodoActual al\n                    let nReferidos     = hijos |> Seq.length\n                    let nRefActivos    = hijos |> Seq.filter (fun al -> al.status = Activo && al.tipo = Regular) |> Seq.length\n                    let nDescendientes = hijos |> Seq.sumBy  (fun al -> al.nDescendientes + al.nReferidos )\n                    let nDescActivos   = hijos |> Seq.sumBy  (fun al -> al.nDescActivos   + al.nRefActivos)\n                    let tipo           = if nRefActivos >= pre.numeroReferidosMaster then Master else Regular\n                    let nivel          = 1 + buscar.nivelDe al.idPadreO\n                    let al' =\n                        { al with\n                            status         = status\n                            tipo           = tipo\n                            nReferidos     = nReferidos    \n                            nRefActivos    = nRefActivos   \n                            nDescendientes = nDescendientes\n                            nDescActivos   = nDescActivos  \n                            diaPago        = diaPago al.fechaRegistro\n                            //fechaStatus    = System.DateTime()\n                            nivel          = nivel\n                        }\n                    let comRef, comDes = comision pre al'\n                    { al' with comision = comRef + comDes}\n                and aliadoActualizadoM = Memoize.memoize aliadoActualizado\n        \n                modelo.aliados \n                |> Seq.map (fun al -> al.id)\n                |> Seq.map aliadoActualizadoM\n                |> Seq.toArray\n        \n            //let actualizarModelEf () = eff {\n            //    let! modelo     = State.get()\n            //    do! State.put { modelo with aliados = actualizarAliados modelo }\n            //    ()\n            //}\n        \n            let empty = {\n                datosPersonales = {\n                                        titulo          = None\n                                        nombre1         = \"\"\n                                        nombre2         = \"\"\n                                        apellido1       = \"\"\n                                        apellido2       = \"\"\n                                        nacionalidad    = USA\n                                        genero          = Masculino\n                                        fechaNacimiento = System.DateTime(2000, 1, 1)\n                                    }\n                id              =  IdAliado \"\"\n                idPadreO        =  None\n                idForAuthorize  =  None\n                influyente      =  None\n                contactos       =  [||]\n                identificacion  =  [||]\n                isInternal      =  false\n                status          =  Inactivo\n                tipo            =  Regular\n                fechaRegistro   =  System.DateTime(2000, 1, 1)\n                fechaStatus     =  System.DateTime(2000, 1, 1)\n                diaPago         =  Dia01\n                nReferidos      =  0\n                nRefActivos     =  0\n                nDescendientes  =  0\n                nDescActivos    =  0\n                comision        =  0\n                nivel           =  0\n            }\n        \n            let nombre dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                let apellido = if dp.apellido1 = \"\" then \"\" else (dp.apellido1 + \" \" + dp.apellido2).Trim() + \", \"\n                titulo + apellido + dp.nombre1 + \" \" + dp.nombre2\n        \n            let nombre2 dp = \n                let titulo   = dp.titulo |> Option.map ((+) \" \") |> Option.defaultValue \"\"\n                titulo + (dp.nombre1 + \" \" + dp.nombre2).Trim() + \" \" + (dp.apellido1 + \" \" + dp.apellido2).Trim()\n        \n        module Serializador =\n            open Serializer\n            open System\n        \n            [< AutoOpen >]\n            module TypesV0 =\n                open TypesV0\n            \n                let serDate : Ser<System.DateTime> = \n                    (  fun (d:System.DateTime ) -> d.ToString(\"u\") |> sprintf \"%A\"                )\n                    , (fun (j:JsonIntermediate) -> j.tryString() |> Option.bind ParseO.parseDateO )\n        \n                let serIdAliado          = serDU<IdAliado         > [   serObj serString            ]    \n                let serIdAuthorized      = serDU<IdAuthorize      > [   serObj serString            ]    \n                let serIdForAuthorize    = serDU<IdForAuthorize   > [   serObj serString            ]    \n                let serIdPayment         = serDU<IdPayment        > [   serObj serString            ]    \n                let serIdAddress         = serDU<IdAddress        > [   serObj serString            ]    \n                let serTipoAliado        = serDU<TipoAliado       > [   serObj serString            ]\n                let serPais              = serDU<Pais             > [   serObj serString            ]    \n                let serEstado            = serDU<Estado           > [   serObj serString            ]    \n                let serTerritorio        = serDU<Territorio       > [   serObj serEstado            ]   \n                let serEmisor            = serDU<Emisor           > [   serObj serPais\n                                                                        serObj serTerritorio        ]\n                let serDocumento         = serDU<Documento        > [   serObj serString            ]    \n                let serNumeroCuenta      = serDU<NumeroCuenta     > [   serObj serString            ]    \n                let serNumeroTarjeta     = serDU<NumeroTarjeta    > [   serObj serString            ]\n                let serRoutingNumber     = serDU<RoutingNumber    > [   serObj serString            ]    \n                let serTipoCuenta        = serDU<TipoCuenta       > [   serObj serString            ]    \n                let serStatusAliado      = serDU<StatusAliado     > [   serObj serString            ]    \n                let serConceptoPago      = serDU<ConceptoPago     > [   serObj serString            ]    \n                let serTipoDireccion     = serDU<TipoDireccion    > [   serObj serString            ]    \n                let serZonaPostal        = serDU<ZonaPostal       > [   serObj serString            ]    \n                let serTipoTelefono      = serDU<TipoTelefono     > [   serObj serString            ]    \n                let serGenero            = serDU<Genero           > [   serObj serString            ]    \n                let serTipoMensaje       = serDU<TipoMensaje      > [   serObj serString            ]\n                let serDiaPago           = serDU<DiaPago          > [                               ]\n        \n                let serMes : Ser<Mes>    = (int >> fst serInt), (snd serInt >> Option.map enum<_> )\n        \n                let serIdAuthorizedR     = serDU<Result<IdAuthorize, string>> [   serObj serString ; serObj serIdAuthorized ]    \n                let serIdPaymentR        = serDU<Result<IdPayment  , string>> [   serObj serString ; serObj serIdPayment    ]    \n                let serIdAddressR        = serDU<Result<IdAddress  , string>> [   serObj serString ; serObj serIdAddress    ]    \n        \n                let serExpiracion: Ser<Expiracion> =\n                    [|\n                        serInt        |> serField \"anio\"    (fun s -> s.anio   ) (fun v s -> { s with anio    = v } )   \n                        serMes        |> serField \"mes\"     (fun s -> s.mes    ) (fun v s -> { s with mes     = v } )          \n                    |] |> serRecord tarVacio.expiracion\n        \n        \n                let serIdentificacion : Ser<Identificacion> = \n                    [|\n                        serEmisor    |> serField \"emisor\"    (fun s -> s.emisor    ) (fun v s -> { s with emisor    = v } )\n                        serDocumento |> serField \"documento\" (fun s -> s.documento ) (fun v s -> { s with documento = v } )\n                        serDate      |> serField \"emision\"   (fun s -> s.emision   ) (fun v s -> { s with emision   = v } )\n                        serDate      |> serField \"vence\"     (fun s -> s.vence     ) (fun v s -> { s with vence     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaBancaria : Ser<CuentaBancaria> =\n                    [|\n                        serString        |> serField \"titular\" (fun (s:CuentaBancaria) -> s.titular) (fun v s -> { s with titular = v } )   \n                        serString        |> serField \"banco\"   (fun  s                 -> s.banco  ) (fun v s -> { s with banco   = v } )   \n                        serTipoCuenta    |> serField \"tipo\"    (fun  s                 -> s.tipo   ) (fun v s -> { s with tipo    = v } )        \n                        serNumeroCuenta  |> serField \"numero\"  (fun  s                 -> s.numero ) (fun v s -> { s with numero  = v } )          \n                        serRoutingNumber |> serField \"routing\" (fun  s                 -> s.routing) (fun v s -> { s with routing = v } )           \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTarjetaCredito : Ser<TarjetaCredito> =\n                    [|\n                        serExpiracion    |> serField \"expiracion\" (fun s -> s.expiracion) (fun v s -> { s with expiracion = v } )   \n                        serString        |> serField \"titular\"    (fun s -> s.titular   ) (fun v s -> { s with titular    = v } )   \n                        serNumeroTarjeta |> serField \"numero\"     (fun s -> s.numero    ) (fun v s -> { s with numero     = v } )          \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTransaccion : Ser<Transaccion> = \n                    [|\n                        serDate          |> serField \"fechaPago\"   (fun s -> s.fechaPago  ) (fun v s -> { s with fechaPago   = v } ) \n                        serInt           |> serField \"ano\"         (fun s -> s.ano        ) (fun v s -> { s with ano         = v } )\n                        serInt           |> serField \"periodo\"     (fun s -> s.periodo    ) (fun v s -> { s with periodo     = v } )\n                        serInt           |> serField \"monto\"       (fun s -> s.monto      ) (fun v s -> { s with monto       = v } )\n                        serIdAliado      |> serField \"idAliado\"    (fun s -> s.idAliado   ) (fun v s -> { s with idAliado    = v } )     \n                        serConceptoPago  |> serField \"concepto\"    (fun s -> s.concepto   ) (fun v s -> { s with concepto    = v } )         \n                        serString        |> serField \"transaccion\" (fun s -> s.transaccion) (fun v s -> { s with transaccion = v } )   \n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDireccion : Ser<Direccion> = \n                    [|\n                        serTipoDireccion |> serField \"tipoDireccion\" (fun s -> s.tipoDireccion) (fun v s -> { s with tipoDireccion = v } )\n                        serString        |> serField \"linea1\"        (fun s -> s.linea1       ) (fun v s -> { s with linea1        = v } )\n                        serString        |> serField \"linea2\"        (fun s -> s.linea2       ) (fun v s -> { s with linea2        = v } )\n                        serString        |> serField \"ciudad\"        (fun s -> s.ciudad       ) (fun v s -> { s with ciudad        = v } )\n                        serPais          |> serField \"pais\"          (fun s -> s.pais         ) (fun v s -> { s with pais          = v } )\n                        serZonaPostal    |> serField \"zonaPostal\"    (fun s -> s.zonaPostal   ) (fun v s -> { s with zonaPostal    = v } )\n                        serEstado        |> serField \"estado\"        (fun s -> s.estado       ) (fun v s -> { s with estado        = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serTelefono : Ser<Telefono> =\n                    [|\n                        serTipoTelefono |> serField \"tipoTelefono\" (fun s -> s.tipoTelefono) (fun v s -> { s with tipoTelefono = v } )\n                        serString       |> serField \"codigoPais\"   (fun s -> s.codigoPais  ) (fun v s -> { s with codigoPais   = v } )\n                        serString       |> serField \"codigoArea\"   (fun s -> s.codigoArea  ) (fun v s -> { s with codigoArea   = v } )\n                        serString       |> serField \"numero\"       (fun s -> s.numero      ) (fun v s -> { s with numero       = v } )\n                        serString       |> serField \"extension\"    (fun s -> s.extension   ) (fun v s -> { s with extension    = v } )\n                        serBool         |> serField \"mensajes\"     (fun s -> s.mensajes    ) (fun v s -> { s with mensajes     = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCuentaPago        = serDU<CuentaPago       > [   serObj serString              \n                                                                        serObj serTarjetaCredito\n                                                                        serObj serCuentaBancaria    ]\n                let serRemitente         = serDU<Remitente        > [   serObj serIdAliado\n                                                                        serObj serString            ]\n        \n                let serFormaPago : Ser<FormaPago> =\n                    [|\n                        serCuentaPago            |> serField \"cuentaPago\"  (fun s -> s.cuentaPago   ) (fun v s -> { s with cuentaPago   = v } )\n                        serString                |> serField \"nombre\"      (fun s -> s.nombre       ) (fun v s -> { s with nombre       = v } )\n                        serIdPaymentR            |> serField \"authorizeId\" (fun s -> s.authorizeIdR ) (fun v s -> { s with authorizeIdR = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serDatosPersonales : Ser<DatosPersonales> =\n                    [|\n                        serString        |> serOpt  |> serField \"titulo\"          (fun s -> s.titulo         ) (fun v s -> { s with titulo          = v } )\n                        serString                   |> serField \"nombre1\"         (fun s -> s.nombre1        ) (fun v s -> { s with nombre1         = v } )\n                        serString                   |> serField \"nombre2\"         (fun s -> s.nombre2        ) (fun v s -> { s with nombre2         = v } )\n                        serString                   |> serField \"apellido1\"       (fun s -> s.apellido1      ) (fun v s -> { s with apellido1       = v } )\n                        serString                   |> serField \"apellido2\"       (fun s -> s.apellido2      ) (fun v s -> { s with apellido2       = v } )\n                        serPais                     |> serField \"nacionalidad\"    (fun s -> s.nacionalidad   ) (fun v s -> { s with nacionalidad    = v } )\n                        serGenero                   |> serField \"genero\"          (fun s -> s.genero         ) (fun v s -> { s with genero          = v } )\n                        serDate                     |> serField \"fechaNacimiento\" (fun s -> s.fechaNacimiento) (fun v s -> { s with fechaNacimiento = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serMensaje : Ser<Mensaje> =\n                    [|\n                        serTipoMensaje           |> serField \"tipo\"      (fun (s:Mensaje) -> s.tipo     ) (fun v s -> { s with tipo      = v } )\n                        serDate        |> serOpt |> serField \"leido\"     (fun (s:Mensaje) -> s.leido    ) (fun v s -> { s with leido     = v } )\n                        serDate                  |> serField \"fecha\"     (fun (s:Mensaje) -> s.fecha    ) (fun v s -> { s with fecha     = v } )\n                        serString                |> serField \"texto\"     (fun (s:Mensaje) -> s.texto    ) (fun v s -> { s with texto     = v } )\n                        serRemitente             |> serField \"remitente\" (fun (s:Mensaje) -> s.remitente) (fun v s -> { s with remitente = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serPremisasCalculo : Ser<PremisasCalculo> =\n                    [|\n                        serInt  |> serField \"comisionReferidosRegular\"     (fun s -> s.comisionReferidosRegular    ) (fun v s -> { s with comisionReferidosRegular     = v } )\n                        serInt  |> serField \"comisionReferidosMaster\"      (fun s -> s.comisionReferidosMaster     ) (fun v s -> { s with comisionReferidosMaster      = v } )\n                        serInt  |> serField \"comisionDescendientesMaster\"  (fun s -> s.comisionDescendientesMaster ) (fun v s -> { s with comisionDescendientesMaster  = v } )\n                        serInt  |> serField \"comisionDescendientesRegular\" (fun s -> s.comisionDescendientesRegular) (fun v s -> { s with comisionDescendientesRegular = v } )\n                        serInt  |> serField \"montoAfiliacion\"              (fun s -> s.montoAfiliacion             ) (fun v s -> { s with montoAfiliacion              = v } )\n                        serInt  |> serField \"numeroReferidosMaster\"        (fun s -> s.numeroReferidosMaster       ) (fun v s -> { s with numeroReferidosMaster        = v } )\n                        serInt  |> serField \"diaCorte1\"                    (fun s -> s.diaCorte1                   ) (fun v s -> { s with diaCorte1                    = v } )\n                        serInt  |> serField \"diaCorte2\"                    (fun s -> s.diaCorte2                   ) (fun v s -> { s with diaCorte2                    = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serCorreoElectronico : Ser<CorreoElectronico> = \n                    [|\n                        serString         |> serField \"email\"    (fun s -> s.email    ) (fun v s -> { s with email    = v } )\n                        serDate |> serOpt |> serField \"enviado\"  (fun s -> s.enviado  ) (fun v s -> { s with enviado  = v } )\n                        serDate |> serOpt |> serField \"recibido\" (fun s -> s.recibido ) (fun v s -> { s with recibido = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serContacto          = serDU<Contacto         > [   serObj serString     \n                                                                        serObj serTelefono\n                                                                        serObj serCorreoElectronico\n                                                                        serObj serDireccion         ] \n        \n                let serAliado : Ser<Aliado> =\n                    [|\n                        serIdAliado                    |> serField \"id\"              (fun s -> s.id             ) (fun v s -> { s with id              = v } )\n                        serIdForAuthorize   |> serOpt  |> serField \"idForAuthorize\"  (fun s -> s.idForAuthorize ) (fun v s -> { s with idForAuthorize  = v } )\n                        serIdAliado         |> serOpt  |> serField \"idPadreO\"        (fun s -> s.idPadreO       ) (fun v s -> { s with idPadreO        = v } )\n                        serIdentificacion   |> serArr  |> serField \"identificacion\"  (fun s -> s.identificacion ) (fun v s -> { s with identificacion  = v } )\n                        serString           |> serOpt  |> serField \"influyente\"      (fun s -> s.influyente     ) (fun v s -> { s with influyente      = v } )\n                        serDatosPersonales             |> serField \"datosPersonales\" (fun s -> s.datosPersonales) (fun v s -> { s with datosPersonales = v } )\n                        serContacto         |> serArr  |> serField \"contactos\"       (fun s -> s.contactos      ) (fun v s -> { s with contactos       = v } )\n                        //serFormaPago        |> serArr  |> serField \"formasPago\"      (fun s -> s.formasPago     ) (fun v s -> { s with formasPago      = v } )\n                        //serTransaccion      |> serArr  |> serField \"transacciones\"   (fun s -> s.transacciones  ) (fun v s -> { s with transacciones   = v } )\n                        //serMensaje          |> serArr  |> serField \"mensajes\"        (fun s -> s.mensajes       ) (fun v s -> { s with mensajes        = v } )\n                        serBool                        |> serField \"isInternal\"      (fun s -> s.isInternal     ) (fun v s -> { s with isInternal      = v } )\n                        serStatusAliado                |> serField \"status\"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )\n                        serTipoAliado                  |> serField \"tipo\"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )\n                        serDate                        |> serField \"fechaRegistro\"   (fun s -> s.fechaRegistro  ) (fun v s -> { s with fechaRegistro   = v } )\n                        serDate                        |> serField \"fechaStatus\"     (fun s -> s.fechaStatus    ) (fun v s -> { s with fechaStatus     = v } )\n                        serDiaPago                     |> serField \"diaPago\"         (fun s -> s.diaPago        ) (fun v s -> { s with diaPago         = v } )\n                        serInt                         |> serField \"nReferidos\"      (fun s -> s.nReferidos     ) (fun v s -> { s with nReferidos      = v } )\n                        serInt                         |> serField \"nRefActivos\"     (fun s -> s.nRefActivos    ) (fun v s -> { s with nRefActivos     = v } )\n                        serInt                         |> serField \"nDescendientes\"  (fun s -> s.nDescendientes ) (fun v s -> { s with nDescendientes  = v } )\n                        serInt                         |> serField \"nDescActivos\"    (fun s -> s.nDescActivos   ) (fun v s -> { s with nDescActivos    = v } )\n                        serInt                         |> serField \"comision\"        (fun s -> s.comision       ) (fun v s -> { s with comision        = v } )\n                        serInt                         |> serField \"nivel\"           (fun s -> s.nivel          ) (fun v s -> { s with nivel           = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n                let serModelo : Ser<Modelo> = \n                    [|\n                        serInt64                      |> serField \"nevento\"       (fun s -> s.nevento       ) (fun v s -> { s with nevento       = v } )\n                        serIdAliado                   |> serField \"idAliado\"      (fun s -> s.idAliado      ) (fun v s -> { s with idAliado      = v } )\n                        //serAliado           |> serArr |> serField \"aliados\"       (fun s -> s.aliados       ) (fun v s -> { s with aliados       = v } )\n                        serInt                        |> serField \"anoActual\"     (fun s -> s.anoActual     ) (fun v s -> { s with anoActual     = v } )\n                        serInt                        |> serField \"periodoActual\" (fun s -> s.periodoActual ) (fun v s -> { s with periodoActual = v } )\n                        serPremisasCalculo            |> serField \"premisas\"      (fun s -> s.premisas      ) (fun v s -> { s with premisas      = v } )\n                    |] |> serRecord LibraryNoJS.Default.value<_>\n        \n        \n        module ObtenerEstado =\n            open Serializador\n        \n            type EstadoI<'H> =\n                    abstract member UltimoEstado     : unit     ->  Eff<'H, int64 option>\n        //            abstract member LeerEventos          : int64    ->  Eff<'H, (int64 * string * string * string * string * System.DateTime) []>\n        //            abstract member LeerTipos            : unit     ->  string           []\n        //            abstract member LeerEventosTipos     : unit     -> (string * string) []\n                    abstract member GuardarEstado    : int64    ->  string ->  Eff<'H, unit>\n                    abstract member GuardarAliado    : string   ->  string ->  Eff<'H, unit>\n                    abstract member ObtenerEstado    : unit     ->  Eff<'H, (int64 * string) option>\n                    abstract member ObtenerAliados   : unit     ->  Eff<'H, string []>\n        \n            let guardarEstadoE  (nevento, serialModelo) = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarEstado nevento serialModelo\n            let obtenerEstado0E ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerEstado ()                  \n            let obtenerAliadosE ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerAliados()                  \n            let guardarAliadoE  id json                 = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarAliado id json             \n            let ultimoEstadoE   ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.UltimoEstado  ()                  \n        \n            let aliadosPrevio = System.Collections.Generic.Dictionary<_,_>()\n        \n            let guardarAliados aliados = eff {\n                let mutable first = true\n                for (aliado:Aliado) in aliados do\n                    let previoO = Dict.tryGetValue aliado.id aliadosPrevio\n                    if previoO <> Some aliado then\n                        if first then \n                            first <- false\n                            printfn \"previo = %A\" previoO \n                            printfn \"nuevo  = %A\" aliado\n                        do! aliado |> Serializer.serialize serAliado |> guardarAliadoE aliado.id.Id\n                    if previoO.IsSome then aliadosPrevio.Remove aliado.id |> ignore\n                    aliadosPrevio.Add(aliado.id, aliado)\n                    ()\n            }\n        \n            let actualizarAliadosPrevio modelo = eff {\n                aliadosPrevio.Clear()\n                for aliado in modelo.aliados do\n                    aliadosPrevio.Add(aliado.id, aliado)\n            }\n        \n            let guardarEstado nevento modelo =\n                { modelo with nevento = nevento ; aliados = Aliado.actualizarAliados modelo } \n                |> EA.tee (fun e -> guardarAliados e.aliados)\n                |>> fun (modelo:Modelo) -> nevento, modelo |> Serializer.serialize serModelo\n                >>= guardarEstadoE\n        \n            let obtenerAliados (modelo:Modelo) = eff {\n                let! aliadoss = obtenerAliadosE()\n                let  aliados  = aliadoss |> Array.choose (Serializer.deserializeWithDefs serAliado)\n                return { modelo with aliados = aliados}\n            }\n        \n            let salvarEstadoEnMemoria (aa: _ -> Eff<_,Modelo>) : _ -> Eff<_,Modelo> = \n                let mutable estadoActual : Modelo option = None        \n                fun ()   -> eff{\n                    let! estado = ultimoEstadoE()\n                    match estado, estadoActual with\n                    | Some n, Some e when n = e.nevento -> return e\n                    |_-> return! aa >-> tee (fun e -> estadoActual <- Some e) <| ()\n                }\n        \n            let obtenerEstado00E() =\n                obtenerEstado0E()\n                |>> Option.map snd                                       \n                |>> Option.map (Serializer.deserializeWithDefs serModelo)\n                |>> Option.defaultValue  (Some modeloVacio)              \n                |>  Rsl.absorbO   (fun () -> \"Modelo no fue deserializado\")\n                >>= obtenerAliados\n                >>= EA.tee actualizarAliadosPrevio\n        \n            let obtenerEstado() = obtenerEstado00E |> salvarEstadoEnMemoria <| ()\n        \n            let pairEstado ev =\n                obtenerEstado()\n                |>> fun modelo -> modelo, ev\n        \n            //let obtenerUsuario (aid: (_*_) []) : string =  aid \n                //|>  Seq.tryFind(fun (n,v) -> n = \"http://schemas.microsoft.com/identity/aid/objectidentifier\") \n                //|>  Option.map snd\n                //|>  Option.defaultWith (fun () -> failwith \"Usuario no autenticado\")\n        \n            let obtenerAliadoEstado (aid:IdAliado) =\n                obtenerEstado()\n                |>> fun modelo -> \n                        modelo.aliados \n                        |> Array.tryFind (fun al -> al.id = aid ) \n                        |> Option.map (fun v -> v, modelo) \n                |> Rsl.absorbO (fun () -> \"Aliado no fue encontrado\")\n        \n            //let obtenerAliadoEstado    aid       = obtenerUsuario       aid |>  obtenerAliadoEstado0\n            let obtenerAliado          aid       = obtenerAliadoEstado  aid |>> fst\n            //let obtenerAliadoEstadoId (IdAliado id) = obtenerAliadoEstado id\n            //let pairAliadoEstado       aid   ev  = obtenerAliadoEstado  aid |>> fun s -> s, ev\n            //let pairAliado             aid   ev  = obtenerAliado        aid |>> fun a -> a, ev\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\other\\AuthorizeNet\\lib\\AuthorizeNet.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n        \n        module Authorize =\n            open System\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n        \n            type AuthorizeI<'H>     = abstract execute : IApiOperation<'A, 'B> -> 'B\n                                      abstract prepare : unit                  -> Eff<'H, unit>\n        \n            let authorizeMerchantId (aliado:Aliado) =\n                match aliado.idForAuthorize with\n                | Some v ->        v .Id                .Left(20)\n                | None   -> aliado.id.Id.Replace(\"-\",\"\").Left(20)\n        \n            let executeE (controller: IApiOperation<_,_> ) = Reader.ask() |>> fun (h:#AuthorizeI<_>) -> h.execute controller\n            let prepareE (                               ) = Reader.ask() >>= fun (h:#AuthorizeI<_>) -> h.prepare ()\n            let inline executeGetResponse controller : Eff<_, 'b> = eff {\n                let! response = executeE controller\n                if response = null then \n                    return! Rsl.failf \"%s Failed, Response = null\" ( controller.GetType().Name )\n                elif response.messages.resultCode = messageTypeEnum.Ok then\n                    return response\n                elif response.messages.message <> null then\n                    return! Rsl.failf \"%s Error: %s %s\"  ( controller.GetType().Name ) response.messages.message.[0].code response.messages.message.[0].text\n                else\n                    return! Rsl.failf \"%s Error: resultCode = %A, no messages\" ( controller.GetType().Name ) response.messages.resultCode\n            }\n        \n            let ( |*> ) request controllerF =\n                prepareE()\n                |>> fun () -> controllerF request\n                >>= executeGetResponse \n        \n            let ( >*> ) requestEf controllerF = requestEf |>> controllerF >>= executeGetResponse\n        \n            let buscarPerfil aliado =\n                getCustomerProfileRequest( merchantCustomerId  = authorizeMerchantId aliado ) \n                |*> getCustomerProfileController\n                |>> fun response -> response.profile, match response.subscriptionIds with null -> [||] | v -> v\n                \n        \n            let buscarIdAuthorize aliado =\n                buscarPerfil aliado\n                |>> fun (p,_) -> IdAuthorize p.customerProfileId\n        \n            let registrarAliadoNuevo (aliado:Aliado, paymentProfile : customerPaymentProfileType) =\n                let email = aliado.contactos \n                            |> Seq.choose(function CorreoElectronico cor -> Some cor.email |_-> None) \n                            |> Seq.tryHead |> Option.defaultValue \"\"\n                let customerProfile = \n                    customerProfileType(        merchantCustomerId  = authorizeMerchantId aliado\n                                            ,   email               = email \n                                            ,   paymentProfiles     = [| paymentProfile |] )\n                createCustomerProfileRequest(   profile             = customerProfile\n                                            ,   validationMode      = validationModeEnum.liveMode )\n                |*> createCustomerProfileController \n                |>> fun response -> response.customerPaymentProfileIdList.[0]\n        \n            let registrarPagoNuevo (IdAuthorize id, pp : customerPaymentProfileType) =\n                createCustomerPaymentProfileRequest(customerProfileId = id\n                                                ,   paymentProfile    = pp\n                                                ,   validationMode    = validationModeEnum.liveMode)\n                |*> createCustomerPaymentProfileController\n                |>> fun response -> response.customerPaymentProfileId\n        \n            let pagoTipoTarjeta (tar:TarjetaCredito) =\n                let creditCard = creditCardType(cardNumber      = tar.numero.Id\n                                            ,   expirationDate  = tar.expiracion.Id               )\n                paymentType( Item = creditCard ), tar.titular\n        \n            let pagoTipoCuenta  (cta:CuentaBancaria) =\n                let  bankAccount = bankAccountType(  accountNumber   = cta.numero .Id\n                                                ,   routingNumber   = cta.routing.Id\n                                            //,   accountType     = bankAccountTypeEnum.checking\n                                            //,   echeckType      = echeckTypeEnum.WEB\n                                                ,   nameOnAccount   = cta.titular\n                                                ,   bankName        = cta.banco)\n                paymentType( Item = bankAccount  ), cta.titular\n        \n            let datosTitularO (aliado:Aliado) (titular:string) =\n                aliado.contactos \n                |> Seq.tryPick(function | Direccion dir -> Some dir |_-> None)\n                |> Option.map (fun direccion -> \n                    customerAddressType(firstName = (titular.Split ' ').[0]\n                                    ,   lastName  = (titular.Split ' ' |> Seq.skip 1 |> String.concat \" \")\n                                    ,   address   = direccion.linea1\n                                    ,   city      = direccion.ciudad\n                                    ,   state     = direccion.estado    .ToString()\n                                    ,   zip       = direccion.zonaPostal.ToString()\n                                    ,   country   = direccion.pais      .ToString()\n                                    )\n                )\n        \n            let perfilPago (tipoPago: paymentType, titular: string) (aliado:Aliado) =\n                datosTitularO aliado titular\n                |> Option.map (fun datosTitular ->\n                    aliado,\n                    customerPaymentProfileType( payment = tipoPago\n                                            ,   billTo  = datosTitular )\n                )\n        \n            let obtenerFormasDePagoId aid =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarPerfil\n                |>> fun (perfil,_) ->\n                        perfil.paymentProfiles\n                        |> Array.choose (fun pago ->\n                            match pago.payment.Item with\n                            | :? AuthorizeNet.Api.Contracts.V1.creditCardMaskedType as cc -> \n                                TarjetaCredito {\n                                    titular       = pago.billTo.firstName + \" \" + pago.billTo.lastName\n                                    tipoTarjeta   = TipoTarjeta.tryParse cc.cardType |> Option.defaultValue Visa\n                                    numero        = NumeroTarjeta cc.cardNumber\n                                    expiracion    = { anio = 0 ; mes = Mes.Enero}\n                                } |> Some\n                            | :? AuthorizeNet.Api.Contracts.V1.bankAccountMaskedType as ba -> \n                                CuentaBancaria {\n                                    titular     = ba.nameOnAccount\n                                    banco       = ba.bankName\n                                    tipo        = match ba.accountType with\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.businessChecking\n                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.checking          -> Corriente\n                                                    |_-> Ahorro\n                                    numero      = NumeroCuenta  ba.accountNumber\n                                    routing     = RoutingNumber ba.routingNumber\n                                } |> Some\n                            |_-> None\n                            |> Option.map (fun cta ->\n                                {\n                                    nombre       = \"\"\n                                    authorizeIdR = pago.customerPaymentProfileId |> IdPayment |> Ok\n                                    cuentaPago   = cta\n                                }\n                            )\n                        )\n                |>  Rsl.getResult\n                |>> Result.defaultValue [||]\n        \n        //    let obtenerFormasDePago aid =\n        //        fun () -> ObtenerEstado.obtenerAliado aid\n        //        >=> obtenerFormasDePagoId\n        \n            let obtenerFormasDePagoPara (alIds:_[]) = eff {\n                let! fps =\n                    alIds \n                    |> traverseSeq (fun id -> eff {\n                        let! fp = obtenerFormasDePagoId id\n                        return id, fp\n                    })\n                return fps |> Seq.toArray \n            }\n        \n            let registrarFormaPago (al, pp) =\n                buscarIdAuthorize al\n                |> Rsl.getResult\n                >>= function\n                    | Ok p -> registrarPagoNuevo   (p , pp)\n                    |_     -> registrarAliadoNuevo (al, pp)\n        \n            let crearFormaPago aid (tipoPago: paymentType, titular : string) =\n                ObtenerEstado.obtenerAliado aid\n                |>> perfilPago (tipoPago, titular)\n                |>  Rsl.absorbO (fun () -> \"No se encontro direccion\")\n                >>= registrarFormaPago\n        \n            let registrarTarjeta         aid (tc:TarjetaCredito) =\n                pagoTipoTarjeta tc\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Tarjeta registrada.\"\n        \n            let registrarCuenta          aid (cta: CuentaBancaria) =\n                pagoTipoCuenta cta\n                |>  crearFormaPago aid\n                |>> fun _ -> \"Cuenta registrada.\"\n        \n            let validarFormaPago         aid (IdPayment idp) =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        validateCustomerPaymentProfileRequest(  customerProfileId        = idm\n                                                            ,   customerPaymentProfileId = idp\n                                                            ,   validationMode           = validationModeEnum.liveMode\n                        )\n                >*> validateCustomerPaymentProfileController\n                |>> fun response -> response.directResponse\n        \n            let borrarFormaPago aid (IdPayment idp) =\n                ObtenerEstado.obtenerAliado aid\n                >>= buscarIdAuthorize\n                |>> fun (IdAuthorize idm)  ->\n                        deleteCustomerPaymentProfileRequest(customerProfileId        = idm\n                                                        ,   customerPaymentProfileId = idp\n                        )\n                >*> deleteCustomerPaymentProfileController\n                |>> fun response -> \"Forma de pago borrada.\"\n        \n            let obtenerAliadoEstadoPerfilSubIds idAl =\n                ObtenerEstado.obtenerAliadoEstado idAl\n                >>= fun (al,md) ->\n                        buscarPerfil al\n                        |>> fun (pe,subs) -> al, md, pe, subs\n        \n            let crearSubscripcion aid (IdPayment idp) =\n                obtenerAliadoEstadoPerfilSubIds aid \n                >>= fun  (al : Aliado, md : Modelo, pe, subs)  -> eff {\n                        let start = DateTime(DateTime.Today.Year, DateTime.Today.Month, Aliado.dia al.diaPago)\n                                    |> fun start -> if start < DateTime.Today               then start.AddMonths 1 else start\n                                    |> fun start -> if start < al.fechaRegistro.AddMonths 1 then start.AddMonths 1 else start\n                        let sub   = if subs.Length = 0 then \n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   paymentSchedule         = paymentScheduleType(  interval                    = paymentScheduleTypeInterval(length = int16 1, unit = ARBSubscriptionUnitEnum.months) \n                                                                                            ,   totalOccurrences            = int16 240\n                                                                                            ,   startDate                   = start)\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                                    else\n                                        ARBSubscriptionType(\n                                                amount                  = decimal md.premisas.montoAfiliacion\n                                            ,   name                    = \"Afiliacion Mensual Prozper\"\n                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId\n                                                                                            ,   customerPaymentProfileId    = idp)\n                                        )\n                        return sub |>! print, if (subs |>! print).Length = 0 then None else Some subs.[0]\n                    }\n        \n            let createSubscription sub =\n                ARBCreateSubscriptionRequest(subscription = sub)\n                |*> ARBCreateSubscriptionController\n                |>> fun response -> response.subscriptionId\n        \n            let updateSubscription subId sub =\n                ARBUpdateSubscriptionRequest(subscription = sub, subscriptionId = subId)\n                |*> ARBUpdateSubscriptionController\n                |>> fun _response -> subId\n        \n            let actualizarSubscripcion aid idp =\n                crearSubscripcion aid idp\n                >>= function\n                    | sub, None       -> createSubscription       sub\n                    | sub, Some subId -> updateSubscription subId sub\n        \n            let getBatchDetalles bid = \n                getTransactionListRequest(  batchId = bid )\n                |*> getTransactionListController\n                |>> fun response -> response.transactions\n        \n            let buscarPerfilPorProfileId pid =\n                getCustomerProfileRequest(  customerProfileId = string pid )\n                |*> getCustomerProfileController\n                |>> fun response -> response.profile\n        \n            let getSubscriptions active =\n                ARBGetSubscriptionListRequest(searchType = (if active then ARBGetSubscriptionListSearchTypeEnum.subscriptionActive else ARBGetSubscriptionListSearchTypeEnum.subscriptionInactive) )\n                |*> ARBGetSubscriptionListController\n                |>> fun response -> response.subscriptionDetails\n                >>= traverseSeq (fun s -> buscarPerfilPorProfileId s.customerProfileId |>> (fun p -> s, p) )\n        \n            let getSubscriptionTransactions () =\n                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths -1 \n                                         ,   lastSettlementDate = System.DateTime.Now)\n                |*> getSettledBatchListController\n                |>> fun response -> response.batchList\n                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )\n                |>>(Seq.map   (fun (b,ts) -> b, ts |> Seq.filter(fun t -> t.subscription <> null) )\n                 >> Seq.filter(fun (b,ts) ->    ts |> Seq.isEmpty |> not )\n                   )\n        \n            let SubsYTransacciones () =\n                getSubscriptionTransactions()\n                |>> Seq.collect (fun (b, ts) -> ts |> Seq.map (fun t -> b, t))\n                >>= fun ts -> eff {\n                        let! subs = getSubscriptions true\n                        return ts, subs \n                    }\n                >>= EA.tee (fun (ts, subs) -> eff {\n                        let orphans = ts |> Seq.filter(fun (b,t) -> subs |> Seq.exists (fun (s,p) -> s.id = t.subscription.id) |> not) |> Seq.toArray\n                        for b, t in orphans do\n                            do! Log.logf \"Huerfano: %A\" (\n                                        b.batchId\n                                        , t.accountNumber\n                                        , t.accountType\n                                        , t.firstName\n                                        , t.lastName\n                                        , t.settleAmount\n                                        , t.subscription.id\n                                        , t.subscription.payNum\n                                        , t.transactionStatus\n                                        , t.transId )\n                    })\n                |>> fun (ts, subs) ->  subs |> Seq.map(fun (sub,p) -> sub,p, ts |> Seq.filter (fun (b,t) -> t.subscription.id = sub.id) )\n        \n            //type H() =\n            //    interface Rsl.Rsl<string>\n            //    interface Log.Log<string>\n            //    interface VariableAmbienteI with member __.getVar  v  = failwith \"VariableAmbienteI.getVar not implemented\"\n            //    interface AuthorizeI<H>     with member __.execute c  = failwith \"AuthorizeI<H>.Execute not implemented\"\n            //                                     member __.prepare () = failwith \"AuthorizeI<H>.Prepare not implemented\"\n            //    interface EstadoI with\n            //            member __.UltimoEvento      ()  = failwith \"EstadoI.UltimoEvento not implemented\"\n            //            member __.UltimoEstado      ()  = failwith \"EstadoI.UltimoEstado not implemented\"\n            //            member __.LeerEventos       p   = failwith \"EstadoI.LeerEventos not implemented\"\n            //            member __.LeerTipos         ()  = failwith \"EstadoI.LeerTipos not implemented\"\n            //            member __.LeerEventosTipos  ()  = failwith \"EstadoI.LeerEventosTipos not implemented\"\n            //            member __.GuardarEstado     p q = failwith \"EstadoI.GuardarEstado not implemented\"\n            //            member __.GuardarAliado     p q = failwith \"EstadoI.GuardarAliado not implemented\"\n            //            member __.ObtenerEstado     ()  = failwith \"EstadoI.ObtenerEstado not implemented\"\n            //            member __.ObtenerAliados    ()  = failwith \"EstadoI.ObtenerAliados not implemented\"\n        \n            let cancelSubscription sid =\n                ARBCancelSubscriptionRequest(subscriptionId = sid)\n                |*> ARBCancelSubscriptionController\n        \n            let voidTransaction tid =\n                transactionRequestType(transactionType = \"voidTransaction\", refTransId = tid)\n                |>  fun trt -> createTransactionRequest(transactionRequest = trt)\n                |*> createTransactionController\n        \n         [< JavaScript >]\n        type DataEvento =\n        | AgregarAliados            of (Aliado[]                                                   )\n        | AgregarAliado             of (Aliado                                                     )\n        | InvitarPotencialesAliados of (IdAliado * string []                                       )\n        | RegistroNuevo             of (IdAliado * DatosPersonales * IdAliado option * Contacto [] )\n        | ActualizarDatosPersonales of (IdAliado * DatosPersonales                                 )\n        | ActualizarContactos       of (IdAliado * Contacto  []                                    )\n        //| ActualizarFormasPago      of (IdAliado * FormaPago []                                    )\n        | CorreoVerificacionEnviado of (IdAliado * string                                          )\n        | CorreoVerificado          of (IdAliado * string                                          )\n        //| ActualizarAuthorizeId     of (IdAliado * Result<IdAuthorize, string>                     )\n        //| ActualizarPagoAuthorizeId of (IdAliado * CuentaPago * Result<IdPayment, string>          )\n        | ActualizarStatusPadre     of (IdAliado * StatusAliado * (IdAliado option) * string option)\n        \n        [< JavaScript >]\n        type Evento = {\n            nevento : int64\n            aliadoO : IdAliado option\n            data    : DataEvento\n        }\n        \n        [< JavaScript >]\n        type Respuesta =\n        | ROk\n        | NuevoRegistro        of string\n        | Mensaje              of string\n        \n        \n        module Eventos =\n        \n            type TipoDatos = TipoDatos of nombre:string * tipos:string\n        \n            type ResultadoManejador<'H> = Modelo -> Eff<'H,Modelo * Respuesta>\n        \n            type ObjetoDatos<'T> = {\n                tipoDatos : TipoDatos\n                datos     : 'T\n            }\n        \n            type ManejadorDatos<'T, 'H> = {\n                tipoDatos  : TipoDatos\n                manejadorF : ObjetoDatos<'T> -> ResultadoManejador<'H>\n            }\n        \n            let Manejadores<'H> = System.Collections.Generic.Dictionary<TipoDatos, ManejadorDatos<obj,'H>>()\n        \n            let deDatosGen (msg: ObjetoDatos<obj>) : ObjetoDatos<_> = {\n                tipoDatos = msg.tipoDatos\n                datos     = unbox msg.datos\n            }    \n        \n            let registrarManejador nombre (manejadorF:ObjetoDatos<'T> -> ResultadoManejador<_>) =\n                let manejador  = {\n                    tipoDatos  = TipoDatos (nombre, typeof<'T> |> getTypeName) |>! print\n                    manejadorF = deDatosGen >> manejadorF\n                }\n                Manejadores.Add(manejador.tipoDatos, manejador )\n        \n            let registrarManejadorf nombre (manejadorF:'T -> ResultadoManejador<_>) =\n                registrarManejador  nombre (fun oDatos -> manejadorF oDatos.datos)\n        \n            let manejadorGenerico (msg:ObjetoDatos<obj>) : ResultadoManejador<_> =\n                match Manejadores.TryGetValue msg.tipoDatos with\n                | false, _         -> failwithf \"No Handler for message: %A\" msg\n                | true , manejador -> manejador.manejadorF msg\n        \n            let addNewAliados (als1: Aliado []) (als2: Aliado []) : Aliado [] =\n                als1 |> Seq.filter(fun a -> als2 |> Seq.exists (fun b -> a.id = b.id ) |> not ) |> Seq.append als2 |> Seq.toArray\n        \n            let registroNuevo (idA, datos:DatosPersonales, padre, contactos) (modelo: Modelo) : Eff<'H,Modelo * Respuesta> = eff {\n                match   contactos\n                        |> Seq.tryPick(function CorreoElectronico email -> Some email |_-> None ) with\n                | None        -> return! sprintf \"No se encontro Correo Electronico: %A\" datos |> Error |> Rsl.ofResult\n                | Some correo ->\n                if  modelo.aliados\n                    |> Seq.exists(fun al ->\n                        al.contactos\n                        |> Seq.exists(function CorreoElectronico correo2 -> correo = correo2 |_-> false ) \n                    )\n                    then return! sprintf \"Correo Electronico ya esta registrado: %A\" correo |> Error |> Rsl.ofResult\n                else\n                if modelo.aliados |> Seq.exists (fun al -> al.id = idA) \n                    then return! sprintf \"Id ya esta en uso: %A\" idA                        |> Error |> Rsl.ofResult\n                else\n                let now = System.DateTime.Now\n                let aliado = {\n                    datosPersonales =  datos\n                    id              =  idA\n                    idPadreO        =  padre\n                    idForAuthorize  =  None\n                    influyente      =  None\n                    contactos       =  contactos\n                    identificacion  =  [||]\n                    isInternal      =  false\n                    status          =  CuentaCreada\n                    tipo            =  Regular\n                    fechaRegistro   =  now\n                    fechaStatus     =  now\n                    diaPago         =  Dia01\n                    nReferidos      =  0\n                    nRefActivos     =  0\n                    nDescendientes  =  0\n                    nDescActivos    =  0\n                    comision        =  0\n                    nivel           =  0\n                }\n                return\n                    { modelo with aliados = Array.append modelo.aliados [| aliado |] }\n                ,   [ datos.nombre1 ; datos.nombre2 ; datos.apellido1 ; datos.apellido2 ] \n                    |> String.concat \" \"\n                    |> NuevoRegistro  \n            }\n        \n            let cambiaAliado ida   f (modelo:Modelo) = { modelo with aliados    = modelo.aliados          |> Array.map (fun al -> if al.id = ida then f al else al )}\n            let cambiaCorreo email f (aliado:Aliado) = { aliado with contactos  = aliado.contactos        |> Array.map (function CorreoElectronico c when c.email = email -> f c |> CorreoElectronico | co -> co )}\n            //let cambiaFormaPago cp f (aliado:Aliado) = { aliado with formasPago = aliado.formasPago.Value |> Array.map (fun fp -> if fp.cuentaPago = cp then f fp else fp ) }\n            let cambiaStatusCorreo ida email f = cambiaAliado ida (cambiaCorreo email  f)\n        \n            let actualizarDatosPersonales (idA, datos:DatosPersonales) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with datosPersonales = datos }) modelo\n                ,   Mensaje <| \"Datos personales actualizados!\" \n            }\n        \n            //let actualizarAuthorizeId   (idA, authorizeIdR) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with authorizeIdR = authorizeIdR }) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            //let actualizarPagoAuthorizeId (idA, cuenta, paymentIdR : Result<IdPayment, string> )  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (cambiaFormaPago cuenta (fun fp -> { fp with authorizeIdR = paymentIdR }) ) modelo\n            //    ,   Mensaje <| \"AuthorizeId actualizada\" \n            //}\n        \n            let actualizarContactos (idA, contactos:Contacto[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with contactos = contactos }) modelo\n                ,   Mensaje <| \"Contactos actualizados!\" \n            }\n        \n            let actualizarStatusPadre (idA, status:StatusAliado, padreO:IdAliado option, inflO :  string option) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaAliado idA (fun al -> { al with status = status ; idPadreO = padreO ; influyente = inflO }) modelo\n                ,   Mensaje <| \"status actualizados!\" \n            }\n        \n            //let actualizarFormasPago (idA, formasPago:FormaPago[]) (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n            //    return\n            //        cambiaAliado idA (fun al -> { al with formasPago = formasPago }) modelo\n            //    ,  Mensaje <| \"Formas de pago actualizadas!\" \n            //}\n        \n            let agregarAliado  aliado  modelo = eff { return { modelo with Modelo.aliados = addNewAliados [| aliado  |] modelo.aliados }, ROk }\n            let agregarAliados aliados modelo = eff { return { modelo with Modelo.aliados = addNewAliados    aliados    modelo.aliados }, ROk }\n        \n            let correoVerificacionEnviado (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with enviado = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let correoVerificado          (ida, correo)  (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return\n                    cambiaStatusCorreo ida correo (fun c -> { c with recibido = Some System.DateTime.Now }) modelo\n                ,   ROk\n            }\n        \n            let actualizarEstado (modelo: Modelo, evento: Evento) = eff {\n                if modelo.nevento <> -1L && modelo.nevento + 1L <> evento.nevento then \n                    failwithf \"Evento fuera de secuencia: %d %d\" modelo.nevento evento.nevento\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                let objData           = {\n                    tipoDatos         = TipoDatos(case, tuple |> getTypeName)\n                    datos             = data\n                }\n                return! manejadorGenerico objData modelo\n            }\n        \n            let eventoNoImplementado ev (modelo: Modelo) : Eff<_,Modelo * Respuesta> = eff {\n                return! sprintf \"Evento no Implementado: %A\" ev |> Error |> Rsl.ofResult\n            } \n        \n            let invitarPotencialesAliados ev = eventoNoImplementado ev\n        module SerializadorEventos =\n            open Serializador\n            open Serializer\n            open System\n        \n            open FSharp.Reflection\n        \n            let serObject : Ser<obj> = (fun o -> o.GetType().ToString() |> sprintf \"%A\"), (fun _ -> None)\n        \n            let serSerializadoresEventos =\n                let sers = System.Collections.Generic.Dictionary<_,_>()\n                [\n                    serObj         serObject\n                    serObj         serString\n                    serObj         serAliado\n                    serObj         serIdAliado\n                    serObj         serIdAuthorized\n                    serObj (serOpt serIdAliado )\n                    serObj (serArr serContacto )\n                    serObj (serArr serFormaPago)\n                    serObj (serArr serAliado   )\n                    serObj (serArr serString   )\n                    serObj         serDatosPersonales\n                    serObj         serIdAuthorizedR\n                    serObj         serCuentaPago\n                    serObj         serIdPaymentR\n                ] |> Seq.iter sers.Add\n                sers\n        \n            let rec registrarSerializadorParaTipos (ts:System.Type []) =\n                if Seq.length ts <= 1 then () else\n                let tupleType = FSharpType.MakeTupleType ts\n                let tname     = getTypeName tupleType\n                if serSerializadoresEventos.ContainsKey tname then () else\n                let sers      = ts |> Array.map (fun t ->   let tname = getTypeName  t\n                                                            serSerializadoresEventos \n                                                            |> Dict.tryGetValue tname \n                                                            |> Option.defaultWith (fun () -> failwithf \"Serializador no encontrado: %s\" tname) )\n                let getValues = FSharpValue.PreComputeTupleReader      tupleType\n                let setValues = FSharpValue.PreComputeTupleConstructor tupleType\n                let serC    v = Seq.zip (getValues v) sers\n                                |> Seq.map (fun (vi, seri) -> fst seri vi )\n                                |> String.concat \", \"\n                                |> sprintf \"[%s]\"\n                let deserC (j:JsonIntermediate) = \n                                match j.tryArray () with\n                                | None -> None\n                                | Some js -> \n                                Array.zip js sers\n                                |> Array.choose (fun (ji, seri) -> snd seri ji)\n                                |> setValues\n                                |> Some\n                serSerializadoresEventos.Add(tname, (serC, deserC))\n        \n            and registrarSerializadoresParaDU (ttype:System.Type) =\n                FSharpType.GetUnionCases ttype\n                |> Seq.iter(fun case ->\n                    let ts = case.GetFields() |> Array.map(fun p -> p.PropertyType) \n                    ts |> Seq.iter registrarSerializadorPara \n                    ts |> registrarSerializadorParaTipos\n                )\n        \n            and registrarSerializadorPara (ttype:System.Type) =\n                let tname = getTypeName ttype\n                if serSerializadoresEventos.ContainsKey tname then () else\n                if   FSharpType.IsUnion ttype then \n                    registrarSerializadoresParaDU ttype\n                    if serSerializadoresEventos.ContainsKey tname then () else\n                    let ser = Serializer.serDUt (Seq.zip serSerializadoresEventos.Keys serSerializadoresEventos.Values) ttype\n                    serSerializadoresEventos.Add(tname, ser)\n                elif FSharpType.IsTuple ttype then\n                    let ts = FSharpType.GetTupleElements ttype\n                    ts |> Seq.iter registrarSerializadorPara\n                    registrarSerializadorParaTipos ts\n                else\n                    failwithf \"Could not register serializer for: %s\" tname\n        \n            registrarSerializadorPara typeof<DataEvento>\n        \n            let obtenerSerializador tipoEvento = \n                serSerializadoresEventos \n                |> Dict.tryGetValue tipoEvento\n                |> Option.defaultWith (fun () -> failwithf \"Could not find deserializer for %s\" tipoEvento)\n        \n        \n            let registrarF evento (f : 'T -> Eventos.ResultadoManejador<_>) =\n                Eventos.registrarManejadorf evento f\n                registrarSerializadorPara typeof<'T>\n        \n            print \"serializers:\"\n            serSerializadoresEventos.Keys |> Seq.iter print\n        \n            //open CodigoGenerado\n        \n        //    let chequearEventosEnBD et =\n        //        match et with\n        //        | ActualizarDatosPersonales_V0  v -> Eventos.actualizarDatosPersonales  v\n                //| ActualizarFormasPago_V0       v -> Eventos.actualizarFormasPago       v\n                //| AgregarAliado_V1              v -> Eventos.agregarAliado              v\n                //| RegistroNuevo_V1              v -> Eventos.registroNuevo              v\n                //| CorreoVerificacionEnviado_V0  v -> Eventos.correoVerificacionEnviado  v\n        \n            let chequearEventos ev =\n                match ev with\n                | AgregarAliado                 v -> Eventos.agregarAliado              v\n                | AgregarAliados                v -> Eventos.agregarAliados             v\n                | RegistroNuevo                 v -> Eventos.registroNuevo              v\n                | ActualizarDatosPersonales     v -> Eventos.actualizarDatosPersonales  v\n                | ActualizarContactos           v -> Eventos.actualizarContactos        v\n                //| ActualizarFormasPago          v -> Eventos.actualizarFormasPago       v\n                | CorreoVerificacionEnviado     v -> Eventos.correoVerificacionEnviado  v\n                | CorreoVerificado              v -> Eventos.correoVerificado           v\n                | InvitarPotencialesAliados     v -> Eventos.invitarPotencialesAliados  v\n                //| ActualizarAuthorizeId         v -> Eventos.actualizarAuthorizeId      v\n                //| ActualizarPagoAuthorizeId     v -> Eventos.actualizarPagoAuthorizeId  v\n                | ActualizarStatusPadre         v -> Eventos.actualizarStatusPadre      v\n        \n            registrarF \"AgregarAliado\"             Eventos.agregarAliado\n            registrarF \"AgregarAliados\"            Eventos.agregarAliados\n            registrarF \"RegistroNuevo\"             Eventos.registroNuevo\n            registrarF \"ActualizarDatosPersonales\" Eventos.actualizarDatosPersonales\n            registrarF \"ActualizarContactos\"       Eventos.actualizarContactos\n            //registrarF \"ActualizarFormasPago\"      Eventos.actualizarFormasPago\n            registrarF \"CorreoVerificacionEnviado\" Eventos.correoVerificacionEnviado\n            registrarF \"CorreoVerificado\"          Eventos.correoVerificado\n            registrarF \"InvitarPotencialesAliados\" Eventos.invitarPotencialesAliados\n            //registrarF \"ActualizarAuthorizeId\"     Eventos.actualizarAuthorizeId\n            //registrarF \"ActualizarPagoAuthorizeId\" Eventos.actualizarPagoAuthorizeId\n            registrarF \"ActualizarStatusPadre\"     Eventos.actualizarStatusPadre\n        \n            //SQLServer.leerTipos()\n            //|> Seq.iter (fun t ->\n            //    if serSerializadoresEventos.ContainsKey t |> not then\n            //        failwithf \"Serializador no encontrado para tipo %s\" t\n            //)\n        //\n            //SQLServer.leerEventosTipos()\n            //    |> Seq.iter (fun t ->\n            //    if Eventos.TipoDatos t |> Eventos.Manejadores.ContainsKey |> not then\n            //        failwithf \"Manejador no encontrado para evento %A\" t\n            //)\n        \n        \n        module Correo =\n            open System.IO\n            open WebSharper.UI.Server\n        \n            type EmailI<'H> = abstract member SendEmail : string -> string -> string -> Eff<'H, unit>\n            let sendEmail (recipiente:string) (tema:string) (contenido:string)  = Reader.ask() >>= fun (h:#EmailI<'H>) -> h.SendEmail recipiente tema contenido\n        \n            let dummyCtxE() =\n                carpetaRaiz()\n                |>> fun raiz ->\n                        { new WebSharper.Web.Context() with\n                            member this.RootFolder      = raiz\n                            member this.RequestUri      = failwith \"Unsupported\"\n                            member this.UserSession     = failwith \"Unsupported\"\n                            member this.Environment     = failwith \"Unsupported\"\n                            member this.Json            = failwith \"Unsupported\"\n                            member this.Metadata        = failwith \"Unsupported\"\n                            member this.Dependencies    = failwith \"Unsupported\"\n                            member this.ApplicationPath = failwith \"Unsupported\"\n                            member this.ResourceContext = failwith \"Unsupported\" }\n        \n            let prepareHtml (doc:Doc) =\n                dummyCtxE()\n                |>> fun dummyCtx ->\n                        use tw  = new StringWriter()\n                        use w   = new Core.Resources.HtmlTextWriter(tw, \" \")        \n                        doc.Write(dummyCtx, w, false)\n                        tw.ToString()\n        \n            open WebSharper.UI.Templating\n        \n            let [< Literal >] TemplatesCorreos = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\src\\Correos.html\"\n            type TemplateCorreo = Template<TemplatesCorreos, serverLoad = ServerLoad.WhenChanged>\n        \n            let hostE() = variableAmbienteE \"Website\" |>> sprintf \"https://%s\"\n        \n            let SendGridAPIKey = \"\"\n         \n            let enviarCorreoInvitacion tema (IdAliado idPadre) (email:string)= \n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Invitacion() \n                            .Logo(   TemplateCorreo.Logo().Doc())\n                            .Enlace( sprintf \"%s/Register/%s\" host idPadre )\n                            .Doc()\n                >>= prepareHtml\n                >>= sendEmail email tema\n        \n            let enviarCorreosInvitacion (tema, padre, emails:string[]) = eff {\n                for email in emails do\n                    do! enviarCorreoInvitacion tema padre email\n            }\n        \n            let enviarBienvenida (aliado:Aliado) (correo:CorreoElectronico) =\n                let sufijo = match aliado.datosPersonales.genero with Femenino -> \"a\" |_-> \"o\"\n                let nombre = Aliado.nombre2 aliado.datosPersonales\n                let tema   = sprintf \"Prozper le da la bienvenida\"\n                hostE()\n                |>> fun host ->\n                        TemplateCorreo.Bienvenida()\n                                .Logo(   TemplateCorreo.Logo().Doc())\n                                .Enlace(        sprintf \"%s/#/Content/ProzperLyt.cntFormaFormasPago\" host )\n                                .Sufijo(        sufijo                                                    )\n                                .NombreAfiliado(nombre                                                    )\n                                .Doc()\n                >>= prepareHtml\n                >>= sendEmail correo.email tema\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n            let enviarVerificacionCorreo (aliado:Aliado) (correo:CorreoElectronico) =\n                WebSharper.UI.Html.div [] [ WebSharper.UI.Html.text \"CORREO CONTENIDO\" ]\n                |>  prepareHtml\n                >>= sendEmail correo.email \"Verificacion de Correo\"\n                //CorreoVerificacionEnviado (aliado.id, correo.email)\n                //|> EstadoActual.agregarEventoServer\n        \n        \n        \n        module ManejadorEventos =\n            //open ObtenerEstado\n        \n            type EventoI<'H> =\n                    abstract member NuevoEvento<     'H> : string   -> string -> string -> string -> Eff<'H, int64         >\n                    abstract member UltimoEvento<    'H> : unit     ->                               Eff<'H, int64 option  >\n                    abstract member EnviarMensaje<   'H> : string   -> string -> string -> string -> Eff<'H, unit          >\n                    abstract member ObtenerListaDocs<'H> : IdAliado ->                               Eff<'H, string      []>\n        \n            let nuevoEvento   (usuario:string) (nombre:string) (evento:string) (tipo:string) = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.NuevoEvento usuario nombre evento tipo\n            let enviarMensaje (d:string) (r:string) (t:string) (c:string)                    = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.EnviarMensaje d r t c                 \n            let obtenerListaDocs0 alid                                                       = Reader.ask() >>= fun (h:#EventoI<'H>) -> h.ObtenerListaDocs alid                 \n        \n            type SerialEvento = {\n                nombre  : string\n                tipo    : string\n                json    : string\n                data    : obj\n            }\n        \n            type SerialEventoU = {\n                usuario   : string\n                serEvento : SerialEvento\n            }\n        \n            type SerialEventoN = {\n                nevento    : int64\n                serEventoU : SerialEventoU\n            }\n        \n            let deserializarEvento (serEvento : SerialEvento) =\n                let ser = SerializadorEventos.obtenerSerializador serEvento.tipo\n                match Serializer.deserializeWithDefs ser serEvento.json with\n                | Some data -> data\n                | None      -> failwithf \"No se pudo deserializar el Evento: %A\" serEvento\n        \n            let manejadorGenerico msg = \n                ObtenerEstado.obtenerEstado()\n                >>= fun estadoO -> \n                        Eventos.manejadorGenerico msg estadoO\n                        |>  Rsl.getResult\n                        |>> function \n                            | Ok (estadoN, r) -> estadoN, Ok    r\n                            | Error m         -> estadoO, Error m\n        \n            let serialN2serialU (serEventoN: SerialEventoN) = serEventoN.serEventoU\n        \n            let serialU2TipoDatos (serEventoU: SerialEventoU) =\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(serEventoU.serEvento.nombre, serEventoU.serEvento.tipo)\n                    Eventos.datos     = serEventoU.serEvento.data\n                }\n        \n            let evento2TipoDatos (evento:Evento) =\n                let case, tuple, data = DiscUnion.caseTuple evento.data\n                {\n                    Eventos.tipoDatos = Eventos.TipoDatos(case, tuple |> getTypeName)\n                    Eventos.datos     = data\n                }\n        \n            let separarEstado (modeloI:Modelo, eventoSerialN : SerialEventoN) oR =  \n                let modelo = oR |> Result.map fst |> Result.defaultValue modeloI\n                let resp   = oR |> Result.map snd\n                { modelo with nevento = eventoSerialN.nevento }, resp\n        \n            let ejecutarEventoSerial ev =\n                ev\n                |> serialN2serialU \n                |> serialU2TipoDatos\n                |> manejadorGenerico\n                >>= EA.tee (fst >> ObtenerEstado.guardarEstado ev.nevento)\n                |>> snd\n                |>  Rsl.absorbR\n        \n            let guardarEventoSerialU (serEventoU :  SerialEventoU) = \n                nuevoEvento\n                    serEventoU.usuario\n                    serEventoU.serEvento.nombre\n                    serEventoU.serEvento.json\n                    serEventoU.serEvento.tipo\n        \n            let serializarDataEvento (evento : DataEvento) =\n                let  name, ttype, obj = DiscUnion.caseTuple evento\n                let  tname            = ttype |> getTypeName\n                let  ser              = SerializadorEventos.obtenerSerializador tname\n                {   nombre            = name\n                    tipo              = tname\n                    json              = fst ser obj\n                    data              = obj\n                }\n        \n            let guardarEventoSerial  serEventoU =\n                guardarEventoSerialU serEventoU\n                |>> fun nevento  -> { nevento = nevento ; serEventoU = serEventoU }\n        \n            let serializarEvento (evento:Evento) =\n                evento.aliadoO \n                |> Option.map(fun (IdAliado usuario) -> { usuario = usuario ; serEvento  = serializarDataEvento evento.data })\n                |> Result.ofOption (fun () -> sprintf \"Aliado es Nulo para evento %A\" evento)\n                |> Rsl.ofResult\n        \n            let intentarEventoSerial ev =\n                serialU2TipoDatos ev\n                |>  manejadorGenerico\n                |>> snd\n                |>  Rsl.absorbR\n                |>> ignore\n        \n            let ejecutarEventoNuevo ev =\n                serializarEvento ev\n                >>= EA.tee intentarEventoSerial\n                >>= guardarEventoSerial\n                >>= fun inp ->\n                        ejecutarEventoSerial inp\n                        >>= EA.tee (fun out ->  enviarMensaje \"\" inp.serEventoU.usuario (sprintf \"%A\" out) \"\")\n        \n            let ejecutarDataEventoNuevo  claims de =\n                ObtenerEstado.obtenerAliado claims\n                |>> fun al ->\n                        {\n                            Evento.nevento = 0L\n                            Evento.aliadoO = Some al.id\n                            data           = de\n                        }\n                >>= ejecutarEventoNuevo\n        \n            let obtenerSubModelo (aliado:Aliado, modelo:Modelo) = \n                let buscar = Aliado.busqueda modelo.aliados\n                if aliado.datosPersonales.nombre1 = \"Administrador\" && aliado.datosPersonales.apellido1 = \"Supremo\" then modelo else\n                let subAliados = (if aliado.tipo = Master then buscar.descendientes else buscar.hijos) aliado\n                { modelo with \n                    idAliado = aliado.id\n                    aliados  = Array.append [| aliado |] subAliados \n                }\n        \n            let obtenerEstadoParaUsuario aid =\n                ObtenerEstado.obtenerAliadoEstado aid\n                |>> obtenerSubModelo\n        \n            let obtenerClaim claim claims =\n                claims \n                |>  Array.tryFind(fun (n,v) -> n = claim) \n                |>  Option.map snd\n        \n            let enviarBienvenida aid = \n                ObtenerEstado.obtenerAliado aid\n                >>= fun (aliado:Aliado) -> eff {\n                    for contacto in aliado.contactos do\n                        match contacto with\n                        | CorreoElectronico correo -> \n                            match correo.enviado with\n                            | None -> do! Correo.enviarBienvenida aliado correo\n                            |_-> ()\n                        | _ -> ()\n                }\n                \n            let crearRegistroNuevo (aid:IdAliado) claims (modelo:Modelo) = eff {\n                if  aid.Id    = \"admin\" || (modelo.aliados |> Array.exists (fun al -> al.id = aid)) then return None else\n                let datos     = \n                    { Default.value<DatosPersonales> with \n                        nombre1         = claims |> obtenerClaim \"given_name\"                                              |> Option.defaultValue \"\"\n                        apellido1       = claims |> obtenerClaim \"family_name\"                                             |> Option.defaultValue \"\"\n                        fechaNacimiento = claims |> obtenerClaim \"extension_DateOfBirth\" |> Option.bind ParseO.parseDateO2 |> Option.defaultValue System.DateTime.MinValue\n                    }\n                let correo    = \n                    { Default.value<CorreoElectronico> with \n                        email           = claims |> obtenerClaim \"emails\" |> Option.defaultValue \"\"\n                    }\n                let direccion    = \n                    { Default.value<Direccion> with \n                        linea1          = claims |> obtenerClaim \"streetAddress\" |> Option.defaultValue \"\"\n                        ciudad          = claims |> obtenerClaim \"city\"          |> Option.defaultValue \"\"\n                        estado          = claims |> obtenerClaim \"state\"         |> Option.bind Estado    .tryParse |> Option.defaultValue (OtroS      \"\")\n                        zonaPostal      = claims |> obtenerClaim \"postalCode\"    |> Option.bind ZonaPostal.tryParse |> Option.defaultValue (ZonaPostal \"\")\n                        pais            = claims |> obtenerClaim \"country\"       |> Option.bind Pais      .tryParse |> Option.defaultValue (OtroP      \"\")\n                        authorizeIdR    = Error \"\"\n                    }\n                let contactos = [| CorreoElectronico correo ; Direccion direccion |]\n                let referidoPor = \n                    claims \n                    |> obtenerClaim \"referidoPor\" \n                    |> Option.bind (function \"\" -> None | s -> Some s)\n                    |> Option.bind (fun ref -> modelo.aliados |> Seq.tryFind(fun padre -> padre.id.Id = ref))\n                    |> Option.map  (fun padre -> padre.id)\n                do! Log.logf \"referidoPor = %A\" referidoPor\n                //Correo.enviarBienvenida aliado // (**) mover afuera\n                return Some\n                    {\n                        Evento.nevento = 0L\n                        Evento.aliadoO = Some aid\n                        data           = DataEvento.RegistroNuevo(aid, datos, referidoPor, contactos)\n                    }\n            }\n        \n            let agregarUsuarioSiEsNuevo claims1 claims =\n                ObtenerEstado.obtenerEstado()\n                >>= crearRegistroNuevo claims1 claims        \n                |>  bindO ejecutarEventoNuevo                \n                |>  bindO (fun _ -> enviarBienvenida claims1)\n                |>> Option.iter             print\n        \n            let obtenerListaDocs claims =\n                ObtenerEstado.obtenerAliado claims\n                |>> fun al -> al.id\n                >>= obtenerListaDocs0\n        \n            let obtenerInfluyente (inf:string) =\n                ObtenerEstado.obtenerEstado()\n                |>> fun es -> \n                        let infO = Some (inf.Trim().ToLower())\n                        es.aliados \n                        |> Seq.tryFind (fun al -> al.influyente = infO )\n                        |> Result.ofOption (fun () -> sprintf \"Influyente no encontrado : %s\" inf)\n                |>  Rsl.absorbR\n        \n            let obtenerIdInfluyente inf =\n                obtenerInfluyente   inf\n                |>> fun al -> al.id.Id\n        \n        \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll\"\n        module Azure =\n            open System\n            open System.IO\n        //    open Microsoft.Azure\n        //    open Microsoft.Azure.Storage\n        //    //open Microsoft.Azure.Storage.Table\n        //    open Microsoft.Azure.Storage.Queue\n        //    open Microsoft.Azure.Storage.Blob\n        //    open Microsoft.Azure.Storage.Core\n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n            open Microsoft.WindowsAzure.Storage.Table\n        \n            let storageSetting      =  \"APPSETTING_AzureWebJobsStorage\"\n            let aliadosTableName    =  \"Aliados\"\n            let eventosTableName    =  \"Eventos\"\n            let mensajesTableName   =  \"Mensajes\"\n            let estadoTableName     =  \"Modelo\"\n            let transacTableName    =  \"Transacciones\"\n            let correosQueueName    =  \"correos\"\n            let mensajesQueueName   =  \"mensajes\"\n            let storageAccountE()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let storageAccountC()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse\n            let tableClientE   ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudTableClient()\n            let queueClientE   ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudQueueClient()\n            let blobClientE    ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudBlobClient ()\n            let fileClientE    ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudFileClient ()\n            let aliadosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(aliadosTableName )\n            let mensajesTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(mensajesTableName)\n            let eventosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(eventosTableName )\n            let estadoTableE   ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(estadoTableName  )\n            let transacTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(transacTableName )\n            let queueCorreosE  ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(correosQueueName )\n            let queueMensajesE ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(mensajesQueueName)\n        \n            type Correo = {\n                Subject       : string\n                Content       : string\n                CustomerEmail : string\n            }\n        \n            type Mensaje = {\n                remitente     : string\n                destinatario  : string\n                tema          : string\n                contenido     : string\n            }\n        \n            let enviarCorreoAzure (recipiente:string) (tema:string) (contenido:string)  = \n                {   Subject       = tema\n                    Content       = contenido \n                    CustomerEmail = recipiente\n                }\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage\n                |> (fun m -> queueCorreosE() >>= fun queueCorreos -> queueCorreos.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            let enviarMensaje (mensaje:Mensaje) = \n                mensaje\n                |> Newtonsoft.Json.JsonConvert.SerializeObject\n                |> CloudQueueMessage \n                |> (fun m -> queueMensajesE() >>= fun queueMensajes -> queueMensajes.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)\n        \n            type AliadoE(id, aliado: string) =\n                inherit TableEntity(partitionKey=\"Aliado\", rowKey=id)\n                new() = AliadoE(null, null)\n                member val Aliado = aliado with get, set\n        \n            type MensajeE(mensaje: Mensaje, id) =\n                inherit TableEntity(partitionKey= mensaje.destinatario, rowKey=id)\n                new(mensaje) = MensajeE(mensaje, System.Guid.NewGuid().ToString())\n                new() = MensajeE(  {    remitente     = \"\"\n                                        destinatario  = \"\"\n                                        tema          = \"\"\n                                        contenido     = \"\"\n                                    }  )\n                member val id           = id                    with get, set\n                member val Remitente    = mensaje.remitente     with get, set\n                member val Destinatario = mensaje.destinatario  with get, set\n                member val Tema         = mensaje.tema          with get, set\n                member val Contenido    = mensaje.contenido     with get, set\n        \n            type Transac = {\n                aid      : string\n                tid      : string\n                tipo     : string\n                fecha    : System.DateTime\n                monto100 : int\n                detalles : string\n            }\n        \n            type TransacE(transac: Transac) =\n                inherit TableEntity(partitionKey= transac.aid, rowKey=transac.tid)\n                new() = TransacE(  {    monto100 = 0\n                                        fecha    = System.DateTime.MinValue\n                                        aid      = \"\"\n                                        tid      = \"\"\n                                        tipo     = \"\"\n                                        detalles = \"\"\n                                    }  )\n                //member val aid      = transac.aid      with get, set\n                //member val tid      = transac.tid      with get, set\n                member val monto100 = transac.monto100 with get, set\n                member val fecha    = transac.fecha    with get, set\n                member val tipo     = transac.tipo     with get, set\n                member val detalles = transac.detalles with get, set\n        \n            type EstadoE(n:int64, estado: string) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"Estado\")\n                new() = EstadoE(0L, \"\")\n                member val nevento      = n      with get, set\n                member val estado       = estado with get, set\n        \n            type EstadoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"EstadoActual\", rowKey= \"EstadoActual\")\n                new() = EstadoNE(0L)\n                member val nevento      = n      with get, set\n        \n            type EventoE(n:int64, usuario:string, nombre:string, evento:string, tipo:string) =\n                inherit TableEntity(partitionKey= \"Evento\", rowKey= sprintf \"%08d\" n)\n                new() = EventoE(0L, \"\", \"\", \"\", \"\")\n                member val nevento      = n       with get, set\n                member val usuario      = usuario with get, set\n                member val nombre       = nombre  with get, set\n                member val tipo         = tipo    with get, set\n                member val evento       = evento  with get, set\n        \n            type EventoNE(n:int64) =\n                inherit TableEntity(partitionKey= \"Actual\", rowKey= \"Actual\")\n                new() = EventoNE(0L)\n                member val nevento      = n      with get, set\n        \n            let executeE      tbE  op = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteAsync      op |> Async.AwaitTask |> Asy.ofAsync\n            let executeQueryE tbE (op:TableQuery<_>) = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteQuerySegmentedAsync(op, null) |> Async.AwaitTask |> Asy.ofAsync\n        \n            let guardarAliado id contenido = \n                TableOperation.InsertOrReplace <| AliadoE(id, contenido)\n                |> executeE aliadosTableE\n        \n            let guardarMensaje mensaje =\n                TableOperation.InsertOrReplace <| MensajeE(mensaje)\n                |> executeE mensajesTableE\n        \n            let guardarTransac transac =\n                TableOperation.InsertOrReplace <| TransacE(transac)\n                |> executeE transacTableE\n        \n            let obtenerAliados() = \n                TableQuery<AliadoE>()\n                |>  executeQueryE aliadosTableE\n                |>> (Seq.map (fun al -> al.Aliado) >> Seq.toArray)\n        \n            let guardarEstado (n:int64) s =\n                let op1 = TableOperation.InsertOrReplace <| EstadoE( n, s)\n                let op2 = TableOperation.InsertOrReplace <| EstadoNE(n   )\n                executeE estadoTableE op1\n                >>= fun _ -> executeE estadoTableE op2\n        \n            let ultimoEstado() =\n                TableQuery<EstadoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"EstadoActual\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let obtenerEstado() =\n                TableQuery<EstadoE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"EstadoActual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Estado\")\n                  ))\n                |> executeQueryE estadoTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento, e.estado) )\n        \n            let ultimoEvento() = //obtenerTextoArchivo archivoUltimoEvento |> Option.bind ParseO.parseInt64O \n                TableQuery<EventoNE>()\n                  .Where(\n                      TableQuery.CombineFilters(\n                          TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"Actual\"),\n                          TableOperators.And,\n                          TableQuery.GenerateFilterCondition(\"RowKey\", QueryComparisons.Equal,\"Actual\")\n                  ))\n                |> executeQueryE eventosTableE\n                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )\n        \n            let nuevoEvento (usuario:string) (nombre:string) (evento:string) (tipo:string) =\n                ultimoEvento()\n                |>> Option.defaultValue 0L\n                |>> (+) 1L\n                >>= fun nextEvento ->\n                    EventoE( nextEvento, usuario, nombre, evento, tipo)\n                    |>  TableOperation.InsertOrReplace\n                    |>  executeE eventosTableE\n                    |>> fun _ -> EventoNE(nextEvento   )\n                    |>> TableOperation.InsertOrReplace\n                    >>= executeE eventosTableE\n                    |>> fun _ -> nextEvento\n        \n            let getMimeO (name :string)=\n                match name.ToLower() with\n                | String.EndsWith \".pdf\"  _ -> Some \"application/pdf\"\n                | String.EndsWith \".rtf\"  _ -> Some \"application/rtf\"\n                | String.EndsWith \".pbm\"  _ -> Some \"image/x-portable-bitmap\"\n                | String.EndsWith \".bmp\"  _ -> Some \"image/bmp\"\n                | String.EndsWith \".gif\"  _ -> Some \"image/gif\"\n                | String.EndsWith \".tif\"  _\n                | String.EndsWith \".tiff\" _ -> Some \"image/tiff\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".jpe\"  _ \n                | String.EndsWith \".jpeg\" _ \n                | String.EndsWith \".jpg\"  _ -> Some \"image/jpeg\"\n                | String.EndsWith \".png\"  _ -> Some \"image/png\"\n                | String.EndsWith \".html\" _ -> Some \"text/html\"\n                | _-> None\n        \n            let obtenerListaDocs (IdAliado alid) =\n                blobClientE()\n                >>= fun bcli      -> \n                        bcli.GetContainerReference \"documentos\"\n                        |> fun container -> container.GetDirectoryReference  alid\n                        |> fun dir       -> dir      .ListBlobsSegmentedAsync   null |> Async.AwaitTask |> Asy.ofAsync\n                        |>> fun blobs     -> blobs.Results \n                        |>> Seq.choose (fun blob -> \n                            blob.Uri.GetComponents(UriComponents.Path, UriFormat.Unescaped) \n                            |> String.splitInTwoO (alid + \"/\")\n                            |> Option.map snd\n                            )\n                        |>> Seq.toArray\n        \n            let subirBlob fromFile toContainerName toFile =\n                blobClientE()\n                >>= fun bcli ->\n                        bcli                          .GetContainerReference toContainerName\n                        |>  fun container -> container.GetBlockBlobReference toFile\n                        |>  fun blob      -> blob     .UploadFromFileAsync   fromFile |> Async.AwaitTask |> Asy.ofAsync |>> fun () -> blob\n                        >>= fun blob      -> eff { \n                                match getMimeO toFile with\n                                | None -> ()\n                                |   Some mime ->    blob.Properties.ContentType <- mime\n                                                    do! blob.SetPropertiesAsync() |> Async.AwaitTask |> Asy.ofAsync\n                            }\n        \n            let obtenerPropiedadesBlob toContainerName toFile = eff {\n                let! bcli = blobClientE()\n                let  blob =\n                        bcli                         .GetContainerReference toContainerName\n                        |> fun container -> container.GetBlockBlobReference toFile\n                let! exists = blob.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some blob.Properties else None\n            }\n        \n            let obtenerPropiedadesArchivo shareName toFile = eff {\n                let! fcli = fileClientE   () \n                let  file =\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                let! exists = file.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync\n                return if exists then Some file.Properties else None\n            }\n        \n            let subirArchivo fromFile shareName toFile =\n                fileClientE   () \n                >>= fun fcli ->\n                        fcli                 .GetShareReference        shareName\n                        |> fun share -> share.GetRootDirectoryReference()\n                        |> fun dir   -> dir  .GetFileReference         toFile\n                        |> fun file  -> file .UploadFromFileAsync    fromFile |> Async.AwaitTask |> Asy.ofAsync\n        \n        \n        //    let setAmbiente() =\n        //        {\n        //            new IAmbiente with \n        //                member __.UltimoEvento      ()  = ultimoEvento()\n        //                member __.UltimoEstado      ()  = ultimoEstado()\n        //                member __.LeerTipos         ()  = [||]   \n        //                member __.LeerEventosTipos  ()  = [||]   \n        //                member __.NuevoEvento       (usuario:string) (nombre:string) (evento:string) (tipo:string) = nuevoEvento usuario nombre evento tipo\n        //                member __.LeerEventos       n   = AsyncResultM.errorMsgf \"ambienteAzure.LeerEventos not implemented\"\n        //                member __.GuardarEstado     n s = guardarEstado n s\n        //                member __.ObtenerEstado     ()  = obtenerEstado\n        //                member __.GuardarAliado     i s = guardarAliado i s\n        //                member __.ObtenerAliados    ()  = obtenerAliados\n        //                member __.NombreAmbiente    ()  = \"azure\"\n        //                member __.CarpetaRaiz       ()  = carpeta\n        //                member __.EnviarCorreo    r t c = enviarCorreoAzure r t c\n        //                member __.EnviarMensaje d r t c = enviarMensaje  { \n        //                                                        remitente     = d \n        //                                                        destinatario  = r \n        //                                                        tema          = t \n        //                                                        contenido     = c \n        //                                                    }\n        //                member __.ObtenerTransacciones      id = AsyncResultM.errorMsgf \"Ambiente.ObtenerTransacciones: not implemented\"\n        //                member __.ObtenerMensajes           id = AsyncResultM.errorMsgf \"Ambiente.ObtenerMensajes: not implemented\"\n        //                member __.ObtenerListaDocs          id = obtenerListaDocs id\n        //                member __.VariableAmbiente           v = System.Environment.GetEnvironmentVariable v\n        //                member __.Prepare                   () = Authorize.prepareAuthorizeNetEnvironment()\n        //        }\n        //\n        \n            let invokeE nameF (f:'a->Eff<'H, 'b>) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n                |> join\n        \n            let invokeR nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Ok\n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                |> Rsl.ofResult\n        \n            let invokeVerboseR nameF (f:'a->'b) (p:'a) = eff {\n                try \n                    do! Log.logf \"invokeVerboseR: %s\" (nameF p)\n                    let r = f p \n                    do! Log.logf \"%s %A\" (nameF p) r\n                    return r\n                with e ->\n                    return!\n                        Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                        |> Rsl.ofResult\n            }\n        \n            let invokeL nameF (f:'a->'b) (p:'a) =\n                try \n                    f p |> Log.logf \"%s %A\" (nameF p) |>> ignore \n                with e ->\n                    Error (sprintf \"Exception! %s %s\" <| nameF p <| e.ToString())\n                    |> Rsl.ofResult\n        \n        [< AutoOpen >]\n        module AzureHandler =\n            open Authorize\n            open AuthorizeNet\n            open AuthorizeNet.Api.Controllers\n            open AuthorizeNet.Api.Contracts.V1\n            open AuthorizeNet.Api.Controllers.Bases\n            open Azure\n        \n            type AR<'V> = Eff<AzureReader,'V>\n            and  AzureReader(?environment : string) =\n                let prepareEnvironment env id transactionKey =\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.RunEnvironment         <- env\n                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.MerchantAuthentication <- \n                        new merchantAuthenticationType( name            = id\n                                                    ,   ItemElementName = ItemChoiceType.transactionKey\n                                                    ,   Item            = transactionKey )\n                let mutable environmentNameO = None\n                let prepararE = eff {\n                    let! env =  eff {\n                                    match environment with\n                                    | Some v -> return v.ToUpper()\n                                    |_       -> return! variableAmbienteE \"Authorize_Environment\"\n                                }\n                    let  environment, environmentName, idV, tranKeyV =\n                        match env with\n                        | \"P\" ->(   AuthorizeNet.Environment.PRODUCTION\n                                ,   \"PRODUCTION\"\n                                ,   \"Authorize_Id_Production\"          \n                                ,   \"Authorize_Transaction_Production\" \n                                )\n                        |_->    (   AuthorizeNet.Environment.SANDBOX\n                                ,   \"SANDBOX\"\n                                ,   \"Authorize_Id_Sandbox\"          \n                                ,   \"Authorize_Transaction_Sandbox\" \n                                )\n                    let! id      = variableAmbienteE idV\n                    let! tranKey = variableAmbienteE tranKeyV\n                    environmentNameO <- Some environmentName\n                    prepareEnvironment environment id tranKey\n                }\n                interface Reader.Reader<AzureReader> \n                interface Log.Log<string> \n                interface Rsl.Rsl<string>\n                interface Asy.Asy\n                interface VariableAmbienteI with \n                    member __.getVar          v  = System.Environment.GetEnvironmentVariable v\n                    member __.CarpetaRaiz     () = \".\"\n                interface Correo          .EmailI<AzureReader> with\n                    member __.SendEmail                        r t c = invokeE (fun _ -> \"SendEmail\"     ) (Azure.enviarCorreoAzure r t      ) c\n                interface ObtenerEstado   .EstadoI<AzureReader> with\n                    member __.UltimoEstado                        () = invokeE (fun _ -> \"UltimoEstado\"  )  Azure.ultimoEstado                 ()\n                    member __.GuardarAliado                     id s = invokeL (fun _ -> \"GuardarAliado\" ) (Azure.guardarAliado id  :_->AR<_>) s\n                    member __.GuardarEstado                      n s = invokeL (fun _ -> \"GuardarEstado\" ) (Azure.guardarEstado  n  :_->AR<_>) s\n                    member __.ObtenerEstado                       () = invokeE (fun _ -> \"ObtenerEstado\" )  Azure.obtenerEstado                ()\n                    member __.ObtenerAliados                      () = invokeE (fun _ -> \"ObtenerAliados\")  Azure.obtenerAliados               ()\n                interface ManejadorEventos.EventoI<AzureReader> with\n                    member __.NuevoEvento usuario nombre evento tipo = invokeE (fun _ -> \"NuevoEvento\"   ) (Azure.nuevoEvento   usuario nombre evento) tipo\n                    member __.UltimoEvento                        () = invokeE (fun _ -> \"UltimoEvento\"  )  Azure.ultimoEvento                 ()\n                    member __.EnviarMensaje                  d r t c = invokeE (fun _ -> \"EnviarMensaje\" )  Azure.enviarMensaje { \n                                                                                                                            remitente     = d \n                                                                                                                            destinatario  = r \n                                                                                                                            tema          = t \n                                                                                                                            contenido     = c \n                                                                                                                        }\n                    member __.ObtenerListaDocs                   ida = invokeE (fun _ -> \"ObtenerListaDocs\")  Azure.obtenerListaDocs ida\n                interface AuthorizeI<AzureReader> with\n                    member __.execute controller =  controller.Execute()\n                                                    controller.GetApiResponse()\n                    member __.prepare         () = if environmentNameO.IsNone then prepararE else rtn ()\n        \n            let reader = AzureReader()\n            let mutable logger : string -> unit = print\n        \n            let run   (eff:Eff<_,_>) = \n                eff\n                |> Reader.readerHandler reader\n                |> Log.loggerLogHandler logger\n                |> Rsl.rslHandler \n                |> Asy.asyncHandler\n                |> Eff.run<AzureReader,_>\n            let print eff = \n                run (eff |>> print)\n                |> Async.map \n                   (function\n                    | Ok ()   -> ()\n                    | Error m -> print m)\n        \n        \n        \n        module Rpc =\n            open WebSharper\n            open WebSharper.JavaScript\n        \n            [< JavaScript >]\n            let serverEndPoint = \n                lazy \n                    if IsClient then \n                        if JS.Window.Location.Protocol = \"http:\" \n                        then \"http://localhost:7071/api/\"\n                        else sprintf \"https://%s/api/\" JS.Window.Location.Host\n                    else     \n                        variableAmbienteE \"Website\" \n                        |>> sprintf \"https://%s/api/\"\n                        |>  AzureHandler.run\n                        |>  Async.RunSynchronously\n                        |>  Result.defaultValue \"https://aliados.prozper.com/api\"\n        \n            let obtenerUnions0 () =\n                ( DiscUnion.simple<Pais          >\n                , DiscUnion.simple<Estado        >\n                , DiscUnion.simple<TipoDireccion >\n                , DiscUnion.simple<TipoTelefono  >\n                , DiscUnion.simple<Genero        >\n                , DiscUnion.simple<TipoCuenta    >\n                , DiscUnion.simple<TipoTarjeta   >\n                , DiscUnion.simple<StatusAliado  >\n                , [| for m in System.Enum.GetValues(typeof<Mes>)                       do yield string m |]\n                , [| for i in System.DateTime.Now.Year..System.DateTime.Now.Year + 15  do yield        i |])\n        \n            open Azure\n            open AzureHandler\n        \n            type AR<'T> = Async<Result<'T, string>>\n        \n            let [< Rpc >] obtenerUnions                       () : AR<_> = invokeVerboseR(fun _ -> \"obtenerUnions\") obtenerUnions0 ()      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerIdInfluyente             codigo : AR<_> = ManejadorEventos.obtenerIdInfluyente      codigo         |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerEstadoParaUsuario aid           : AR<_> = ManejadorEventos.obtenerEstadoParaUsuario aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] actualizarSubscripcion   aid    idp    : AR<_> = Authorize.actualizarSubscripcion          aid     idp    |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] ejecutarDataEventoNuevo  aid    de     : AR<_> = ManejadorEventos.ejecutarDataEventoNuevo  aid     de     |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] agregarUsuarioSiEsNuevo  aid    claims : AR<_> = ManejadorEventos.agregarUsuarioSiEsNuevo  aid     claims |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerFormasDePagoId    aid           : AR<_> = Authorize.obtenerFormasDePagoId           aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] registrarTarjeta         aid    p      : AR<_> = Authorize.registrarTarjeta                aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] registrarCuenta          aid    p      : AR<_> = Authorize.registrarCuenta                 aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] validarFormaPago         aid    p      : AR<_> = Authorize.validarFormaPago                aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] borrarFormaPago          aid    p      : AR<_> = Authorize.borrarFormaPago                 aid     p      |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerListaDocs         aid           : AR<_> = ManejadorEventos.obtenerListaDocs         aid            |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] enviarCorreosInvitacion  aid (tm, ems) : AR<_> = Correo.enviarCorreosInvitacion          (tm, aid, ems)   |> AzureHandler.run// |> Async.rtn\n            let [< Rpc >] obtenerFormasDePagoPara         aids   : AR<_> = Authorize.obtenerFormasDePagoPara                 aids   |> AzureHandler.run// |> Async.rtn\n        \n        [<JavaScript>]\n        module Remoting =\n            open WebSharper.JavaScript\n        \n            let private originalProvider = WebSharper.Remoting.AjaxProvider\n        \n            let mutable getTokenOA = fun () -> async { return None } // ... get token from storage ...\n        \n            type CustomXhrProvider () =\n                interface WebSharper.Remoting.IAjaxProvider with\n                    member this.Async url headers data ok err = \n                        async {\n                            let! tokenO = getTokenOA()\n                            tokenO |> Option.iter (fun token -> JS.Set headers \"Authorization\" <| sprintf \"Bearer %s\" token)\n                            originalProvider.Async url headers data ok err\n                        } |> Async.Start\n                    member this.Sync url headers data =\n                            originalProvider.Sync url headers data\n                    \n            let installBearer getTokenOAF =\n                getTokenOA <-  getTokenOAF\n                WebSharper.Remoting.AjaxProvider <- CustomXhrProvider()\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Host.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Core\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Storage\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Storage.dll\" \n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Primitives\\lib\\netstandard2.0\\Microsoft.Extensions.Primitives.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.Logging.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.Logging.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Azure.WebJobs.Extensions.Http\\lib\\netstandard2.0\\Microsoft.Azure.WebJobs.Extensions.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.Extensions.DependencyInjection.Abstractions\\lib\\netstandard2.0\\Microsoft.Extensions.DependencyInjection.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Abstractions.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Http.Features\\lib\\netstandard2.0\\Microsoft.AspNetCore.Http.Features.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Core\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Core.dll\"\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Prozper\\Microsoft.AspNetCore.Mvc.Abstractions\\lib\\netstandard2.0\\Microsoft.AspNetCore.Mvc.Abstractions.dll\"\n        \n        module AzureFunctions =\n            open Microsoft.Azure.WebJobs\n            open Microsoft.Azure.WebJobs.Extensions\n            open Microsoft.Azure.WebJobs.Extensions.Storage\n            open Microsoft.Azure.WebJobs.Extensions.Http\n            open Microsoft.Extensions.Logging\n            open Microsoft.AspNetCore.Http\n            open Microsoft.AspNetCore.Mvc\n            open Newtonsoft.Json\n            open System\n            open System.IO \n        \n            module RM = WebSharper.Core.Remoting\n        \n            [<FunctionName(\"keepAlive\")>]\n            let keepAlive([< TimerTrigger(\"0 */5 * * * *\") >] myTimer : TimerInfo, log : ILogger ) =\n                ()\n        \n            type MaxDepthJsonTextWriter(writer : TextWriter, maxDepth : int ) =\n                inherit JsonTextWriter(writer) \n                let mutable maxObservedDepth = 0\n                member this.CheckDepth() =\n                    maxObservedDepth <- Math.Max(maxObservedDepth, this.Top)\n                    if this.Top > int maxDepth then\n                        failwithf \"Depth %d Exceeds MaxDepth %A at path %A\" this.Top maxDepth this.Path\n                override this.WriteStartArray          () = base.WriteStartArray()           ; this.CheckDepth()\n                override this.WriteStartConstructor  name = base.WriteStartConstructor(name) ; this.CheckDepth()\n                override this.WriteStartObject         () = base.WriteStartObject()          ; this.CheckDepth()\n        \n            let splitAndSend n f name (txt:string) =\n                let rec loop (txt:string) =\n                    if txt.Length <= n then f txt else\n                    f txt.[0..n]\n                    loop txt.[n + 1..]\n                loop (name + \"<<<:\" + txt + \":>>>\")\n        \n            let serializeMaxDepth depth obj = \n                let settings = JsonSerializerSettings(ReferenceLoopHandling  = ReferenceLoopHandling.Ignore\n                                                    , MissingMemberHandling  = MissingMemberHandling.Ignore\n                                                    , Error                  = EventHandler<Serialization.ErrorEventArgs>(fun s a -> a.ErrorContext.Handled <- true)\n                                                    )\n                use writer      = new StringWriter()\n                use jsonWriter  = new MaxDepthJsonTextWriter(writer, depth)\n                JsonSerializer.Create(settings).Serialize(jsonWriter, obj)\n                writer.ToString()\n            \n        \n            [<FunctionName(\"rpc\")>]\n            let runRpc( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"rpc/rpc\")>] \n                        request     : HttpRequest\n                      , principal   : System.Security.Claims.ClaimsPrincipal \n                      , log         : ILogger  ) = \n                async {\n                    log.LogInformation \"runRpc: ENTERING v.014\"\n                    //serializeMaxDepth 13 request   |> splitAndSend 9999 log.LogInformation \"request\"\n                    //serializeMaxDepth 13 principal |> splitAndSend 9999 log.LogInformation \"principal\"\n                    //log.LogInformation(sprintf \"%d Headers:\" <| Seq.length request.Headers)\n                    //request.Headers |> Seq.collect (fun kvp -> kvp.Value |> Seq.map (fun v -> kvp.Key, v)) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    //log.LogInformation(sprintf \"%d real Claims:\" <| Seq.length principal.Claims)\n                    //principal.Claims |> Seq.map (fun kvp -> kvp.Type, kvp.Value) |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                    log.LogInformation \"runRpc: before Server.Create\"\n                    let  wsServer = RM.Server.Create WebSharper.Web.Shared.Metadata WebSharper.Web.Shared.Json\n                    log.LogInformation \"runRpc: after Server.Create\"\n                    let! body     = request.ReadAsStringAsync() |> Async.AwaitTask\n                    let  wsReq    = {\n                        RM.Request.Body    = body\n                        RM.Request.Headers = ParseO.tryParseWith request.Headers.TryGetValue >> Option.bind Seq.tryHead\n                    }\n                    log.LogInformation \"runRpc: before logger <-\"\n                    logger <- fun s -> log.LogInformation s\n                    log.LogInformation \"runRpc: before try\"\n                    try\n                        log.LogInformation \"runRpc: before HandleRequest v001\"\n                        let! wsResp   = wsServer.HandleRequest wsReq\n                        log.LogInformation (sprintf \"runRpc: after HandleRequest %s %s\" wsResp.ContentType wsResp.Content)\n                        return ContentResult(Content = wsResp.Content, ContentType = wsResp.ContentType)\n                    with e ->\n                        log.LogError (sprintf \"Exception: %A\" e)\n                        return failwithf \"Exception %A\" e\n                } |> Async.StartAsTask\n        \n            open Microsoft.WindowsAzure.Storage\n            open Microsoft.WindowsAzure.Storage.Queue\n        \n            //open Microsoft.Azure.Cosmos.Table\n            open Microsoft.AspNetCore.Http\n            open System.IO\n            open Microsoft.AspNetCore.Mvc\n        \n            [<FunctionName(\"subir\")>]\n            let subirDocumentos([<HttpTrigger(AuthorizationLevel.Anonymous, \"post\"   , Route      = \"subir/{id}/{filename}\")>] req   : HttpRequest\n                              , [<Blob(\"documentos/{id}/{filename}\", System.IO.FileAccess.Write, Connection = \"AzureWebJobsStorage\"  )>] writer: Stream \n                              , log     : ILogger\n                              , id      : string\n                              , filename: string ) = \n              async {\n                    log.LogInformation <| sprintf \"subiendo documento %d %s\" req.Form.Files.Count filename\n                    if req.Form.Files.Count <> 1 then\n                        log.LogWarning \"no se encontro el documento\"\n                        return ContentResult(Content = \"no se encontro el documento\", ContentType = \"text/plain\")\n                    else\n                    let  file      = req.Form.Files |> Seq.head\n                    do!  file.CopyToAsync writer |> Async.AwaitTask\n                    eff {\n                        try\n                            do!  Asy.ofAsync <| Async.Sleep 500\n                            let! blobClient = Azure.blobClientE()\n                            let  container  = blobClient.GetContainerReference \"documentos\"\n                            let  dir        = container.GetDirectoryReference id\n                            let  blobRef    = dir.GetBlockBlobReference filename\n                            Azure.getMimeO filename\n                            |> Option.iter (fun mime -> \n                                blobRef.Properties.ContentType <- mime\n                                blobRef.SetPropertiesAsync() |> Async.AwaitTask |> Async.Start\n                            )\n                        with e -> do! Rsl.ofResult <| Error (sprintf \"%A\" e)\n                    } |> AzureHandler.run |> Async.map (function | Error m -> printfn \"%A\" m |_-> ()) |> Async.Start\n                    return ContentResult(Content = \"Documento subido!\", ContentType = \"text/plain\")\n              } |> Async.StartAsTask\n        \n            [<FunctionName(\"passMessages\")>]\n            let passMessages( [<QueueTrigger(\"mensajes\", Connection = \"AzureWebJobsStorage\")>]  \n                    mensaje: Azure.Mensaje, log: ILogger) = \n                async {\n                    log.LogInformation (sprintf \"guardarMensaje %A (ignorando) \" mensaje)\n                    //let! v = AmbienteAzure.guardarMensaje mensaje\n                    //let! next = AmbienteAzure.queueMensajes.PeekMessageAsync() |> Async.AwaitTask\n                    //if isNull next then \n                        //log.LogInformation <| sprintf \"ambiente: %s\" (ambiente.NombreAmbiente())\n                        ////let! res = Acciones.ejecutarAcciones()\n                        ////log.LogInformation <| sprintf \"Acciones ejecutadas %A\" res\n                    ()\n                } |> Async.RunSynchronously\n        \n            [<FunctionName(\"path\")>]\n            let path( [<HttpTrigger(AuthorizationLevel.Anonymous, \"get\" , \"post\", \"options\", Route = \"{anything}\")>] \n                        request     : HttpRequest\n                      , log         : ILogger ) =\n                //log.LogInformation(sprintf \"isMimeMultipart: %A\" <| request.Content.IsMimeMultipartContent())          \n                request.Headers |> Seq.iter (fun h -> log.LogInformation(sprintf \"header: %s %A\" h.Key (h.Value |> String.concat \"; \")) )\n                let uid    = ParseO.tryParseWith request.Headers.TryGetValue \"idAliado\" |> Option.bind Seq.tryHead |> Option.defaultValue \"\"\n                let claims = [| \"http://schemas.microsoft.com/identity/claims/objectidentifier\", uid |]\n                claims |> Seq.iter (sprintf \"%A\" >> log.LogInformation)\n                ContentResult(Content = \"Hello\", ContentType = \"text/plain\")\n        \n        //#nowarn \"52\"\n        //#nowarn \"1182\"\n        //#nowarn \"1178\"\n        \n        //#define NOFRAMEWORK --noframework\n        //#define WEBSHARPER\n        \n        //// to generate function.json (s):\n        //// D:\\Abe\\CIPHERWorkspace\\AzureFunctions\\packages\\Microsoft.NET.Sdk.Functions\\tools\\net46\\Microsoft.NET.Sdk.Functions.Generator.exe bin\\ProzperServer.dll .\n        \n        //// to save function.json:\n        //// PUT https://management.azure.com/subscriptions/fd33982d-5249-477d-9587-b0f758dd6fe9/resourceGroups/Prozper/providers/Microsoft.Web/sites/Prozper0/functions/%s?api-version=2018-02-01\n        //// {\n        ////       \"properties\": {\n        ////         \"config\": %s\n        //// }\n        \n        \n        \n        \n        //#define WEBSHARPER\n        //#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\n        \n        [< JavaScript >]\n        module ClientSide =\n        \n            [< AutoOpen >]\n            module Templating =\n                open WebSharper.UI.Templating\n                let [< Literal >] rootdir = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\ProzperServer\\website\"\n            \n                let [< Literal >] TemplatesFileName = rootdir + @\"\\index0.html\"\n                type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n                //let [< Literal >] LoginFileName = rootdir + @\"\\Login.html\"\n                //type TemplateLogin  = Template< LoginFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n            \n                if IsClient then printfn \"%s\" TemplatesFileName\n            \n            module Msal =\n                open Msal\n            \n                let callback(errorDesc, token, error, tokenType, state) = \n                    printfn          \"callback: %A\" (errorDesc, error, tokenType, token, state)\n            \n                let storeValue name v =\n                    if IsClient then\n                        JS.Window.LocalStorage.SetItem(name, v)\n                        v\n                    else \"\"\n            \n                let storageGetItem name =\n                    if IsClient then\n                        JS.Window.LocalStorage.GetItem name\n                    else \"\"\n            \n                let storageSetItem(name, v) =\n                    if IsClient then\n                        JS.Window.LocalStorage.SetItem(name, v)\n            \n                let appId = if IsClient && JS.Window.Location.Host.StartsWith \"prozper0\" then \"76703639-1d21-4bc3-bd46-c764f5ea78ee\" else \"70ad4f9b-9a2b-409e-9c1e-d04dbb2e7cf2\"\n            \n                let applicationId       = storeValue \"applicationId\"          appId\n                let tenantName          = storeValue \"tenantName\"             \"prozper\"\n                let ref                 = storeValue \"ref\"                    \"\"\n                let extraQueryParms     = storeValue \"extraQueryParms\"        \"mkt=es-us\"\n                let refreshBefore       = storeValue \"refreshBefore\"          \"0\"\n                let createOnStart       = storeValue \"createOnStart\"          \"1\"\n                let forceLogin          = storeValue \"forceLogin\"             \"1\"\n                let signInPolicy        = storeValue \"signInPolicy\"           \"B2C_1_SignIn\"\n                let signUpPolicy        = storeValue \"signUpPolicy\"           \"B2C_1_Registrarse\"\n                let editProfilePolicy   = storeValue \"editProfilePolicy\"      \"B2C_1_EditarPerfil\"\n                let resetPasswordPolicy = storeValue \"resetPasswordPolicy\"    \"B2C_1_PasswordReset\"\n                let policyType          = storeValue \"policyType\"             \"SignIn\"\n                match storageGetItem \"preambleState\" with\n                | \"InPreamble\"  | \"\" | null ->\n                                          storeValue \"preambleState\"          \"GoToSignIn\" |> ignore\n                |_->()\n            \n                let getAuthority tenantName policyName = sprintf \"https://%s.b2clogin.com/tfp/%s.onmicrosoft.com/%s\" tenantName tenantName policyName\n            \n                let authority           = getAuthority tenantName signInPolicy\n                let userO               = Var.Create None\n            \n                let agent = \n                    lazy\n                        UserAgentApplication(applicationId\n                            , authority\n                            , callback\n                            , UserAgentApplication.Options(validateAuthority         = false\n                                                        ,  storeAuthStateInCookie    = false ))\n            \n                let getId userO = userO |> Option.map (fun user -> user?idToken?oid) |> Option.defaultValue \"\"\n            \n                let referidoPor() = storageGetItem \"referidoPor\"\n                let claims user = \n                    let r = [|\n                        \"oid\"                   ,  user?idToken?oid \n                        \"city\"                  ,  user?idToken?city \n                        \"country\"               ,  user?idToken?country \n                        \"extension_DateOfBirth\" ,  user?idToken?extension_DateOfBirth \n                        \"given_name\"            ,  user?idToken?given_name \n                        \"postalCode\"            ,  user?idToken?postalCode \n                        \"state\"                 ,  user?idToken?state \n                        \"streetAddress\"         ,  user?idToken?streetAddress \n                        \"family_name\"           ,  user?idToken?family_name \n                        \"emails\"                , (user?idToken?emails:string[]).[0]\n                        \"referidoPor\"           ,  referidoPor()\n                    |]\n                    storageSetItem(\"referidoPor\", \"\")\n                    r\n            \n                let executePolicy force (policy:Policy) =\n                    (if force then \"1\" else \"0\") |> storeValue \"forceLogin\"   |> ignore\n                    JS.Window.Location.Href      |> storeValue \"goInsideLink\" |> ignore\n                    string policy                |> storeValue \"policyType\"   |> ignore\n                    JS.Window.Location.Replace \"blob/Msal.html\"\n            \n                let checkUser() =\n                    async {\n                        do! Async.Sleep 100\n                        while true do\n                            let newO =\n                                match agent.Value.getUser() with\n                                | null -> None \n                                | user -> Some user\n                            if getId newO <> getId userO.Value then userO.Set newO\n                            if userO.Value = None then executePolicy false SignIn\n                            do! Async.Sleep 9000\n                    } |> Async.Start\n            \n                let logout          () = executePolicy true SignIn\n            \n                let getTokenO() = async {\n                    match userO.Value with\n                    | Some user  -> let! token = agent.Value.acquireTokenPopup([| sprintf \"https://%s.onmicrosoft.com/%s/user_impersonation\" tenantName appId |], authority, user, null) |> Promise.AsAsync \n                                    return Some token\n                    | None       -> return None\n                    //return\n                    //    match JS.Window.SessionStorage.GetItem \"msal.idtoken\" with\n                    //    | \"\" | null -> None\n                    //    | token     -> Some token\n                }\n            [< JavaScript >]\n            module ModeloUI =\n            \n                let modeloV = Var.Create {\n                    idAliado      = IdAliado \":\"\n                    aliados       = [||]\n                    anoActual     = System.DateTime.Now.Year\n                    periodoActual = System.DateTime.Now.Month\n                    premisas      = premisasCalculo\n                    nevento       = -2L\n                }\n            \n                let formasPagoAliadoV : Var<FormaPago []> = Var.Create [||]\n            \n                let invitacionesV = Var.Create \"\"    \n                let emailsInvitarW = \n                    invitacionesV.View |> View.Map(\n                        function\n                        | REGEX rexEmail \"gi\" r -> r\n                        |_-> [||]\n                        >> Seq.distinct\n                        >> Seq.sort\n                        >> String.concat \"\\n\"\n                    )\n                let invitacionesDisabledW = emailsInvitarW |> View.Map(function | \"\" -> \"disabled\" |_-> \"\")\n            \n                let selAliadoIdOV = Var.Create None\n            \n                let refAliadoIdOV : Var<IdAliado option> = Var.Create None\n            \n                let rec separate s parts =\n                    match s with\n                    | \"\" -> parts |> String.concat \",\"\n                    | _  -> separate (s.Left -3) (s.Right 3 :: parts)\n            \n                let money (m:int) = \"$\" + separate (string m) []\n            \n                type EndPoint =\n                | [< EndPoint \"\" >] DefaultEP\n                |                   NoUser\n                |                   PreRegister\n                |                   Content of string\n                | [<Wildcard>]      Pdf     of string\n                | [<Wildcard>]      Video   of string\n            \n                open Sitelets.InferRouter\n                module AF = FsRoot.LibraryJS.AppFramework \n            \n                let endPointV   = if IsClient then Router.Infer() |> Router.InstallHash DefaultEP else Var.Create DefaultEP\n            \n            \n                [< Inline \"showPDF($f)\" >]\n                let showPdf (f:string) : unit = X<_>\n            \n                [< Inline \"playVideo()\" >]\n                let playVideo () : unit = X<_>\n            \n                endPointV.View |> View.Sink(\n                    function\n                    | NoUser \n                    | PreRegister   -> ()\n                    | Pdf   f       -> showPdf f\n                    | Video _       -> playVideo()\n                    |_-> Msal.checkUser()\n                )\n            \n                let contentVar =\n                    Var.Make \n                        (View.Map2 \n                            (fun _ -> function\n                            | DefaultEP       when Msal.userO.Value <> None -> \"ProzperLyt.mainContent\"\n                            | Content     lyt when Msal.userO.Value <> None -> lyt\n                            | PreRegister                                   -> \"ProzperLyt.cntPreRegister\"\n                            | Pdf         _                                 -> \"ProzperLyt.cntPDF\"\n                            | Video       _                                 -> \"ProzperLyt.cntVideo\"\n                            | _                                             -> \"ProzperLyt.cntFormaNoUser\"\n                            )\n                            Msal.userO.View endPointV.View )\n                        (function\n                        | \"ProzperLyt.mainContent\"  -> DefaultEP\n                        | lyt                       -> Content lyt\n                        >> (fun v -> if endPointV.Value <> v then endPointV.Set v)\n                        )\n            \n                let aliadoIdDoc fDoc =\n                    View.Do {\n                        let! modelo   = modeloV      .View\n                        let  aid      = modelo.idAliado\n                        let  aliadoO  = modelo.aliados |> Seq.tryFind (fun al -> al.id = aid)\n                        return \n                            match aliadoO with\n                            | None    -> Doc.Empty\n                            | Some al -> View.Const al |> fDoc\n                    } |> Doc.BindView id\n            \n                let aliadoW =\n                    View.Do {\n                        let! modelo   = modeloV      .View\n                        let  aid      = modelo.idAliado\n                        let  aliadoO  = modelo.aliados |> Seq.tryFind (fun al -> al.id = aid)\n                        return \n                            match aliadoO with\n                            | None    -> Aliado.empty\n                            | Some al -> al\n                    }\n            \n                let selAliadoIdDoc fDoc =\n                    View.Do {\n                        let! modelo   = modeloV      .View\n                        let! selAlIdO = selAliadoIdOV.View\n                        let  aliadoO  = selAlIdO |> Option.bind (fun aid -> modelo.aliados |> Seq.tryFind (fun al -> al.id = aid) )\n                        return \n                            match aliadoO with\n                            | None    -> Doc.Empty\n                            | Some al -> View.Const al |> fDoc\n                    } |> Doc.BindView id\n            \n                type Aliado with\n                    static member LoggedId = Msal.userO.Value |> Option.map (fun user -> user?idToken?oid) |> Option.defaultValue \"\" |> IdAliado\n            \n                module Rpc =\n                    Remoting.installBearer Msal.getTokenO\n                    let llamadas = Var.Create 0\n                    let iterA arm = AsyncResult.iterA JS.Alert id arm\n                    let [< Inline >] inline llamar (f : _ -> Async<Result<_,string>>) p  = asyncResult {\n                        do      llamadas.Set <| llamadas.Value + 1\n                        try return! f p\n                        finally llamadas.Set <| llamadas.Value - 1\n                    }\n                    let agregarUsuarioSiEsNuevo  p = llamar (          Rpc.agregarUsuarioSiEsNuevo    Aliado.LoggedId) p\n                    let obtenerUnions            p = llamar            Rpc.obtenerUnions                               p\n                    let ejecutarDataEventoNuevo  p = llamar (          Rpc.ejecutarDataEventoNuevo    Aliado.LoggedId) p\n                    let enviarCorreosInvitacion  p = llamar (          Rpc.enviarCorreosInvitacion    Aliado.LoggedId) p\n                    let obtenerFormasDePago      p = llamar (fun () -> Rpc.obtenerFormasDePagoId      Aliado.LoggedId) p\n                    let registrarTarjeta         p = llamar (          Rpc.registrarTarjeta           Aliado.LoggedId) p\n                    let registrarCuenta          p = llamar (          Rpc.registrarCuenta            Aliado.LoggedId) p\n                    let validarFormaPago         p = llamar (          Rpc.validarFormaPago           Aliado.LoggedId) p\n                    let borrarFormaPago          p = llamar (          Rpc.borrarFormaPago            Aliado.LoggedId) p\n                    let obtenerFormasDePagoPara  p = llamar            Rpc.obtenerFormasDePagoPara                     p\n                    let obtenerListaDocs         p = llamar (fun () -> Rpc.obtenerListaDocs           Aliado.LoggedId) p\n                    let obtenerEstadoParaUsuario p = llamar            Rpc.obtenerEstadoParaUsuario   Aliado.LoggedId\n                    let actualizarSubscripcion   p = llamar (          Rpc.actualizarSubscripcion     Aliado.LoggedId) p\n                    let obtenerIdInfluyente      p = llamar            Rpc.obtenerIdInfluyente                         p\n            \n                    WebSharper.Remoting.EndPoint <- Rpc.serverEndPoint.Value + \"rpc/rpc\"\n                [< AutoOpen >]\n                module Refresh =\n                    let mutable shouldRefresh = true\n                \n                    let refrescarData force = \n                        if force then shouldRefresh <- true\n                        match Msal.userO.Value with\n                        | Some user ->\n                            asyncResult {\n                                if Msal.referidoPor() <> \"\" then\n                                    do!   Msal.claims user |> Rpc.agregarUsuarioSiEsNuevo\n                                if not JS.Document.Hidden then\n                                    if shouldRefresh then\n                                        let! data = Rpc.obtenerEstadoParaUsuario ()\n                                        shouldRefresh <- false\n                                        if modeloV.Value <> data then modeloV.Set data\n                            } |> Rpc.iterA\n                        |_-> modeloV.Set modeloVacio\n                \n                    if IsClient then\n                \n                        Msal.userO.View |> View.Sink (fun _-> refrescarData true)\n                \n                        async {\n                            while true do\n                                do! Async.Sleep (5 * 60 * 1000)\n                                //refrescarData true\n                        } |> Async.Start\n                \n                        try \n                            JS.Document.AddEventListener(\"visibilityChange\", (fun () -> (*refrescarData false*)() ), false)\n                        with _ -> ()\n                \n                    \n                module VariousUI = \n                \n                    let inline fst3 (v,_,_) = v\n                    let inline snd3 (_,v,_) = v\n                    let inline thr3 (_,_,v) = v\n                \n                    let alertIfNone name vO f = \n                        match vO with\n                        | None   -> JS.Alert (\"Error not caught: \" + name)\n                                    None\n                        | Some v -> f v\n                \n                    let paises   = Var.Create [||]\n                    let estados  = Var.Create [||]\n                    let tiposDir = Var.Create [||]\n                    let tiposTel = Var.Create [||]\n                    let generos  = Var.Create [||]\n                    let tiposCta = Var.Create [||]\n                    let tiposTar = Var.Create [||]\n                    let statuses = Var.Create [||]\n                    let aniosV   = Var.Create [||]\n                    let mesesV   = Var.Create [||]\n                \n                    if IsClient then\n                        asyncResult {\n                            let! p, e, td, tl, g, tc, tt, ss, mm, yy =  Rpc.obtenerUnions          ()\n                            paises  .Set p\n                            estados .Set e\n                            tiposDir.Set td\n                            tiposTel.Set tl\n                            generos .Set g\n                            tiposCta.Set tc\n                            tiposTar.Set tt\n                            statuses.Set ss\n                            aniosV  .Set yy\n                            mesesV  .Set mm\n                        } |> Rpc.iterA \n                \n                    let crearOption   n   = Html.Elt.option [             ] [ Html.text n] :> Doc\n                    let crearOption2  n v = Html.Elt.option [ attr.value v] [ Html.text n] :> Doc\n                    let crearOptions  ns  = ns  |> Seq.map               crearOption       |> Doc.Concat\n                    let crearOptions2 nvs = nvs |> Seq.map (fun (n,v) -> crearOption2 n v) |> Doc.Concat\n                \n                    let removeButton f doc = \n                        Html.form [ attr.``class`` \"mui-panel\" ] \n                            [   doc \n                                Doc.Button \"borrar\" [ Html.attr.title \"borrar\" ] f\n                            ]\n                \n                \n                module CorreoElectronico =\n                    open VariousUI\n                \n                    let formaDoc (corV : Var<CorreoElectronico option>) =\n                        let mensaje = Var.Create \"\"\n                \n                        let forma =\n                            TemplateLib.Correo()\n                                .Mensaje( mensaje.V )\n                                .Create()\n                        match corV.Value with | None -> () | Some v -> forma.Vars.ConfirmarCorreo.Set <| v.ToString()\n                        V (\n                            if     forma.Vars.Correo         .V.Trim() = \"\" \n                                || forma.Vars.ConfirmarCorreo.V.Trim() = \"\"\n                                || forma.Vars.Correo         .V.Trim()\n                                 = forma.Vars.ConfirmarCorreo.V.Trim() \n                                then \"\" \n                                else \"Correos no son iguales\"\n                        ) |> View.Sink mensaje.Set\n                        corV.View \n                        |> View.Sink (function\n                            | None     -> ()\n                            | Some cor -> \n                            forma.Vars.Correo.Set <| cor.email\n                            //forma.Vars.ConfirmarCorreo.Set <| cor.ToString()\n                        )\n                        let requeridosW =\n                            V(  [   forma.Vars.Correo         .V.Trim() =  \"\" , \"Correo\"\n                                    forma.Vars.ConfirmarCorreo.V.Trim() =  \"\" , \"ConfirmarCorreo\"\n                                    mensaje                   .V        <> \"\" , mensaje.V\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            )\n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            corV.Value\n                            |> Option.orElse (Some correoVacio)\n                            |> Option.map    (fun v -> { v with email = forma.Vars.Correo.V } )\n                        ) |> View.Sink (fun v -> if corV.Value <> v then corV.Set v)\n                        requeridosW, forma.Doc\n                \n                \n                module Telefono =\n                    open VariousUI\n                \n                    let formaDoc (telOV : Var<Telefono option>) = \n                        let forma =\n                            TemplateLib.Telefono()\n                                .Tipos(    V( crearOptions tiposTel.V ).V )\n                                .Create()\n                \n                        telOV.View \n                        |> View.Sink (function\n                            | None     -> ()\n                            | Some tel -> \n                            forma.Vars.CodigoArea  .Set <|              tel.codigoArea  \n                            forma.Vars.CodigoPais  .Set <|              tel.codigoPais\n                            forma.Vars.Telefono    .Set <|              tel.numero    \n                            forma.Vars.Extension   .Set <|              tel.extension\n                            forma.Vars.TipoTelefono.Set <| sprintf \"%O\" tel.tipoTelefono\n                        )\n                        let requeridosW =\n                            V(  [   forma.Vars.CodigoPais  .V.Trim() = \"\" , \"CodigoPais\"\n                                    forma.Vars.Telefono    .V.Trim() = \"\" , \"Telefono\"\n                                    forma.Vars.TipoTelefono.V.Trim() = \"\" , \"TipoTelefono\"\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            )\n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            forma.Vars.TipoTelefono.V.Trim() |> TipoTelefono.tryParse |> alertIfNone \"TipoTelefono\" <| fun tipo ->                \n                            Some {\n                                codigoArea   = forma.Vars.CodigoArea  .V.Trim()\n                                codigoPais   = forma.Vars.CodigoPais  .V.Trim()\n                                numero       = forma.Vars.Telefono    .V.Trim()\n                                extension    = forma.Vars.Extension   .V.Trim()\n                                tipoTelefono = tipo\n                                mensajes     = false\n                            }\n                        ) |> View.Sink (fun v -> if telOV.Value <> v then telOV.Set v)\n                        requeridosW, forma.Doc\n                 \n                module Direccion =\n                    open VariousUI\n                \n                    let formaDoc (dirV : Var<Direccion option>) =\n                        let forma =\n                            TemplateLib.Direccion()\n                                .Paises(   V( crearOptions paises  .V ).V )\n                                .Estados(  V( crearOptions estados .V ).V )\n                                .Tipos(    V( crearOptions tiposDir.V ).V )\n                                .Create()\n                \n                        dirV.View \n                        |> View.Sink (function\n                            | None     -> ()\n                            | Some dir -> \n                            forma.Vars.Direccion1   .Set <| dir.linea1  \n                            forma.Vars.Direccion2   .Set <| dir.linea2  \n                            forma.Vars.Ciudad       .Set <| dir.ciudad    \n                            forma.Vars.Estado       .Set <| sprintf \"%O\" dir.estado\n                            forma.Vars.Pais         .Set <| sprintf \"%O\" dir.pais\n                            forma.Vars.CodigoPostal .Set <| sprintf \"%O\" dir.zonaPostal\n                            forma.Vars.TipoDireccion.Set <| sprintf \"%O\" dir.tipoDireccion\n                        )\n                        let requeridosW = \n                            V( \n                                [\n                                    forma.Vars.Direccion1   .V.Trim() = \"\" , \"Direccion1\"\n                                    forma.Vars.Ciudad       .V.Trim() = \"\" , \"Ciudad\"\n                                    forma.Vars.Estado       .V.Trim() = \"\" , \"Estado\"\n                                    forma.Vars.Pais         .V.Trim() = \"\" , \"Pais\"\n                                    forma.Vars.CodigoPostal .V.Trim() = \"\" , \"CodigoPostal\"\n                                    forma.Vars.TipoDireccion.V.Trim() = \"\" , \"TipoDireccion\"\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            )\n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            forma.Vars.TipoDireccion.V.Trim() |> TipoDireccion.tryParse |> alertIfNone \"TipoDireccion\" <| fun tipo   ->                \n                            forma.Vars.Estado       .V.Trim() |> Estado       .tryParse |> alertIfNone \"Estado\"        <| fun estado -> \n                            forma.Vars.Pais         .V.Trim() |> Pais         .tryParse |> alertIfNone \"Pais\"          <| fun pais   -> \n                            forma.Vars.CodigoPostal .V.Trim() |> ZonaPostal   .tryParse |> alertIfNone \"CodigoPostal\"  <| fun codigo -> \n                            Some {\n                                tipoDireccion = tipo\n                                linea1        = forma.Vars.Direccion1.V.Trim()\n                                linea2        = forma.Vars.Direccion2.V.Trim()\n                                ciudad        = forma.Vars.Ciudad    .V.Trim()\n                                estado        = estado\n                                pais          = pais\n                                zonaPostal    = codigo\n                                Direccion.authorizeIdR  = dirV.V |> Option.map (fun dir -> dir.authorizeIdR) |> Option.defaultValue (Error \"\")\n                            }            \n                        ) |> View.Sink (fun v -> if dirV.Value <> v then dirV.Set v)\n                        requeridosW, forma.Doc\n                \n                module CuentaBancaria =\n                    open VariousUI\n                \n                    let formaDoc (ctaV  : Var<CuentaBancaria * string * bool>) =\n                        let disabledW = ctaV.View |> View.Map thr3\n                        let forma =\n                            TemplateLib.CuentaBancaria()\n                                .TiposCuenta( V( crearOptions tiposCta.V ).V )\n                                .Mensaje(     V( snd3         ctaV    .V ).V ) \n                                .Disabled1(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled2(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled3(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled4(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled5(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Create()\n                \n                        ctaV .View \n                        |> View.Sink (fun (cta, _, _) -> \n                            forma.Vars.Titular      .Set <| cta.titular\n                            forma.Vars.Banco        .Set <| cta.banco\n                            forma.Vars.TipoCuenta   .Set <| sprintf \"%O\" cta.tipo\n                            forma.Vars.Numero       .Set <| match cta.numero  with NumeroCuenta  s -> s\n                            forma.Vars.Routing      .Set <| match cta.routing with RoutingNumber s -> s\n                        )\n                        let requeridosW = \n                            V( \n                                [\n                                    forma.Vars.Titular      .V.Trim() = \"\" , \"Titular\"\n                                    forma.Vars.Banco        .V.Trim() = \"\" , \"Banco\"\n                                    forma.Vars.Numero       .V.Trim() = \"\" , \"Numero de Cuenta\"\n                                    forma.Vars.Routing      .V.Trim() = \"\" , \"ABA/Routing Number\"\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            )\n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            forma.Vars.TipoCuenta   .V.Trim() |> TipoCuenta   .tryParse |> alertIfNone \"TipoCuenta\"   <| fun tipoCta ->\n                            Some {\n                                banco         = forma.Vars.Banco  .V.Trim()\n                                titular       = forma.Vars.Titular.V.Trim()\n                                numero        = forma.Vars.Numero .V.Trim() |> NumeroCuenta\n                                routing       = forma.Vars.Routing.V.Trim() |> RoutingNumber\n                                tipo          = tipoCta\n                            }            \n                        ) |> View.Sink (function |None -> () | Some v -> if fst3 ctaV .Value <> v then ctaV .Set (v, \"\", false) )\n                        requeridosW, forma.Doc\n                \n                    let formaDocO (ctaOV  : Var<(CuentaBancaria * string * bool) option>) =\n                        formaDoc (Var.Lens ctaOV (Option.defaultValue (ctaVacio, \"\", false) ) (fun _ v -> Some v ))\n                \n                module TarjetaCredito =\n                    open VariousUI\n                \n                    let formaDoc (tarV  : Var<(TarjetaCredito * string * bool)>) =\n                        let disabledW = tarV.View |> View.Map thr3\n                        let forma =\n                            TemplateLib.TarjetaCredito()\n                                .TiposTarjeta( V( tiposTar.V                   |> crearOptions  ).V )\n                                .Mensaje(      V( tarV    .V                   |> snd3          ).V )\n                                .Anios(        V( aniosV  .V |> Seq.map string |> crearOptions  ).V )\n                                .Meses(        V( mesesV  .V |> Seq.map string |> crearOptions  ).V )\n                                .Disabled1(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled2(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled3(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled4(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Disabled5(    attr.disabledDynPred (View.Const \"\") disabledW       )\n                                .Create()\n                \n                        tarV .View \n                        |> View.Sink (fun (tar, mensaje, validated) -> \n                            forma.Vars.Titular      .Set <| tar.titular\n                            forma.Vars.TipoTarjeta  .Set <| sprintf \"%O\"        tar.tipoTarjeta\n                            forma.Vars.Numero       .Set <| match tar.numero with NumeroTarjeta s -> s\n                            forma.Vars.AnioVenc     .Set <| sprintf \"%04d\"      tar.expiracion.anio\n                            forma.Vars.MesVenc      .Set <| match tar.expiracion.mes with \n                                                            | Mes.Enero      -> \"Enero\"\n                                                            | Mes.Febrero    -> \"Febrero\"   \n                                                            | Mes.Marzo      -> \"Marzo\"     \n                                                            | Mes.Abril      -> \"Abril\"     \n                                                            | Mes.Mayo       -> \"Mayo\"      \n                                                            | Mes.Junio      -> \"Junio\"     \n                                                            | Mes.Julio      -> \"Julio\"     \n                                                            | Mes.Agosto     -> \"Agosto\"    \n                                                            | Mes.Septiembre -> \"Septiembre\"\n                                                            | Mes.Octubre    -> \"Octubre\"   \n                                                            | Mes.Noviembre  -> \"Noviembre\" \n                                                            | Mes.Diciembre  -> \"Diciembre\"\n                                                            | _              -> \"XX\"\n                        )\n                        let requeridosW = \n                            V( \n                                [\n                                    forma.Vars.Titular      .V.Trim() = \"\" , \"Titular\"\n                                    forma.Vars.TipoTarjeta  .V.Trim() = \"\" , \"TipoTarjeta\"\n                                    forma.Vars.Numero       .V.Trim() = \"\" , \"Numero\"\n                                    forma.Vars.AnioVenc     .V.Trim() = \"\" , \"Ano de Vencimiento\"\n                                    forma.Vars.MesVenc      .V.Trim() = \"\" , \"Mes de Vencimiento\"\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            ) \n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            forma.Vars.TipoTarjeta.V.Trim() |> TipoTarjeta.tryParse |> alertIfNone \"Tipo Tarjeta\" <| fun tipoTar ->\n                            Some {\n                                tipoTarjeta   = tipoTar\n                                titular       = forma.Vars.Titular   .V.Trim()\n                                numero        = forma.Vars.Numero    .V.Trim() |> NumeroTarjeta\n                                expiracion    = {\n                                    anio = forma.Vars.AnioVenc.V.Trim() |> ParseO.parseIntO |> Option.defaultValue 0\n                                    mes  = forma.Vars.MesVenc .V.Trim() |> (function\n                                                                            | \"Febrero\"    -> Mes.Febrero   \n                                                                            | \"Marzo\"      -> Mes.Marzo     \n                                                                            | \"Abril\"      -> Mes.Abril     \n                                                                            | \"Mayo\"       -> Mes.Mayo      \n                                                                            | \"Junio\"      -> Mes.Junio     \n                                                                            | \"Julio\"      -> Mes.Julio     \n                                                                            | \"Agosto\"     -> Mes.Agosto    \n                                                                            | \"Septiembre\" -> Mes.Septiembre\n                                                                            | \"Octubre\"    -> Mes.Octubre   \n                                                                            | \"Noviembre\"  -> Mes.Noviembre \n                                                                            | \"Diciembre\"  -> Mes.Diciembre \n                                                                            |_             -> Mes.Enero)\n                \n                                }\n                            }            \n                        ) |> View.Sink (function |None -> () | Some v -> if fst3 tarV .Value <> v then tarV .Set (v, \"\", false) ) \n                        requeridosW, forma.Doc\n                \n                    let formaDocO (tarOV  : Var<(TarjetaCredito * string * bool) option>) =\n                        formaDoc (Var.Lens tarOV (Option.defaultValue (tarVacio, \"\", false) ) (fun _ v -> Some v ))\n                \n                module DatosPersonales =\n                    open VariousUI\n                \n                    let formaDoc (datosV : Var<DatosPersonales option>) =\n                        let forma    = \n                            TemplateLib.DatosPersonales()\n                                .Generos(        V( crearOptions generos.V ).V            )\n                                .Create()\n                        datosV.View\n                        |> View.Sink (function\n                            | None     -> ()\n                            | Some dat -> \n                            forma.Vars.Nombres        .Set <| (dat.nombre1   + \" \" + dat.nombre2   ).Trim()\n                            forma.Vars.Apellidos      .Set <| (dat.apellido1 + \" \" + dat.apellido2 ).Trim()\n                            forma.Vars.FechaNacimiento.Set <| Date.toYYYYMMDD \"-\"   dat.fechaNacimiento\n                            forma.Vars.Genero         .Set <| sprintf \"%A\" dat.genero\n                        )                \n                        let requeridosW =\n                            V(  [   forma.Vars.Nombres        .V.Trim() = \"\" , \"Nombres\"\n                                    forma.Vars.Apellidos      .V.Trim() = \"\" , \"Apellidos\"\n                                    forma.Vars.FechaNacimiento.V.Trim() = \"\" , \"Fecha de Nacimiento\"\n                                    forma.Vars.Genero         .V.Trim() = \"\" , \"Genero\"\n                                ]\n                                |> Seq.filter fst\n                                |> Seq.map    snd\n                            ) \n                        V (\n                            if not (Seq.isEmpty requeridosW.V)  then None else\n                            forma.Vars.Genero         .V |> Genero.tryParse    |> alertIfNone \"Genero\"           <| fun genero ->\n                            forma.Vars.FechaNacimiento.V |> ParseO.parseDateO2 |> alertIfNone \"Fecha incorrecta\" <| fun fecha  ->\n                            Some {\n                                titulo          = None\n                                nombre1         = forma.Vars.Nombres  .V.Trim().Split(' ').[0  ]\n                                nombre2         = forma.Vars.Nombres  .V.Trim().Split(' ').[1..] |> String.concat \" \"\n                                apellido1       = forma.Vars.Apellidos.V.Trim().Split(' ').[0  ]\n                                apellido2       = forma.Vars.Apellidos.V.Trim().Split(' ').[1..] |> String.concat \" \"\n                                nacionalidad    = OtroP \"\"\n                                genero          = genero\n                                fechaNacimiento = fecha\n                            }            \n                        ) |> View.Sink (fun v -> if datosV.Value <> v then datosV.Set v)\n                \n                        requeridosW, forma.Doc\n                \n                \n                module FormaRegistro = \n                \n                    let formaDoc() =\n                        let mensajes      = Var.Create \"\"\n                        let mostrar       = Var.Create false\n                        let datosOV       = Var.Create None\n                        let correoOV      = Var.Create None\n                        let telefonoOV    = Var.Create None\n                        let direccionOV   = Var.Create None\n                \n                        let datReqsW, datosDoc     = DatosPersonales  .formaDoc datosOV\n                        let corReqsW, correoDoc    = CorreoElectronico.formaDoc correoOV\n                        let telReqsW, telefonoDoc  = Telefono         .formaDoc telefonoOV\n                        let dirReqsW, direccionDoc = Direccion        .formaDoc direccionOV\n                        let forma    =\n                            TemplateLib.FormaRegistro()\n                                .Mensajes(       if mostrar.V then mensajes     .V else \"\")\n                                .DatosPersonales(datosDoc                                 )\n                                .Correo(         correoDoc                                )\n                                .Telefono(       telefonoDoc                              )\n                                .Direccion(      direccionDoc                             )\n                                .Registrarse(fun ev ->\n                                    mostrar.Set true\n                                    let m =  mensajes.Value\n                                    if m.Trim() <> \"\" then JS.Alert m else \n                                        match datosOV    .Value\n                                            , correoOV   .Value\n                                            , telefonoOV .Value\n                                            , direccionOV.Value\n                                                with\n                                        | Some datos, Some correo, Some telefono, Some direccion ->\n                                            asyncResult {\n                                                let contactos = [|    \n                                                    CorreoElectronico correo\n                                                    Telefono          telefono\n                                                    Direccion         direccion \n                                                |]\n                                                let  nid  = System.Guid.NewGuid().ToString().Replace(\"-\", \"\").Substring(0,20) |> IdAliado\n                                                let! resp = (nid, datos, Some modeloV.Value.idAliado, contactos) |> RegistroNuevo |> Rpc.ejecutarDataEventoNuevo\n                                                refrescarData true\n                                                sprintf \"%A\" resp|> JS.Alert\n                                            } |> Rpc.iterA\n                                        | _ -> JS.Alert \"Error not caught FormaRegistro\"\n                                )\n                                .Create()\n                        V(  seq {\n                                yield! datReqsW.V\n                                yield! corReqsW.V\n                                yield! telReqsW.V\n                                yield! dirReqsW.V\n                            }\n                            |> String.concat \", \"\n                            |> fun es -> if es <> \"\" then \"Campos requeridos: \" + es else \"\"\n                        )   |> View.Sink mensajes.Set\n                        forma.Doc\n                \n                \n                module FormaDatos =\n                \n                    let formaAliado (aliadoW: View<Aliado>) =\n                        let mensajes      = Var.Create \"\"\n                        let mostrar       = Var.Create false\n                        let datosOV       = Var.Create None\n                        \n                        aliadoW\n                        |> View.Map  (fun a -> a.datosPersonales )\n                        |> View.Sink (Some >> datosOV.Set)\n                \n                        let datReqsW, datosDoc     = DatosPersonales.formaDoc datosOV\n                        let forma =\n                            TemplateLib.FormaDatosPersonales()\n                                .Mensajes(       if mostrar.V then mensajes     .V else \"\"                                     )\n                                .Changed(        if Some aliadoW.V.datosPersonales = datosOV.V then \"\" else \"mui-btn--primary\" )\n                                .DatosPersonales(datosDoc                                                                      )\n                                .Salvar(fun ev ->\n                                    mostrar.Set true\n                                    let m =  mensajes.Value\n                                    if m.Trim() <> \"\" then JS.Alert m else \n                                        match datosOV.Value, View.TryGet aliadoW with\n                                        | Some datos, Some al ->\n                                            asyncResult {\n                                                let! resp = ActualizarDatosPersonales (al.id, datos) |> Rpc.ejecutarDataEventoNuevo\n                                                refrescarData true\n                                                sprintf \"%A\" resp|> JS.Alert\n                                            } |> Rpc.iterA\n                                        | _ -> JS.Alert \"Error not caught FormaDatos\"\n                                )\n                                .Create()\n                \n                        V(  seq {\n                                yield! datReqsW.V\n                            }\n                            |> String.concat \", \"\n                            |> fun es -> if es <> \"\" then \"Campos requeridos: \" + es else \"\"\n                        )   |> View.Sink mensajes.Set\n                        forma.Doc\n                \n                    let formaDoc() = aliadoIdDoc formaAliado\n                \n                module FormaContactos =\n                    open VariousUI\n                \n                    let ftel = (function Telefono          tel -> Some tel |_-> None), Telefono\n                    let fcor = (function CorreoElectronico cor -> Some cor |_-> None), CorreoElectronico\n                    let fdir = (function Direccion         dir -> Some dir |_-> None), Direccion        \n                \n                    let formaTelefonos (aliadoW: View<Aliado>) =\n                        let contactosV    = Var.Create [||]\n                        \n                        aliadoW\n                        |> View.Map  (fun a -> a.contactos)\n                        |> View.Sink contactosV.Set\n                \n                        let contactosIV = V( contactosV.V |> Seq.indexed )\n                \n                        let makeVar (f, fr) i = \n                            Var.Make (V(contactosV.V |> Seq.tryItem i |> Option.bind f )) \n                                    (function Some nv -> Array.replace i (fr nv) contactosV.Value |> contactosV.Set |_-> () )\n                        \n                        let tels = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst ftel c |> Option.map (fun _ -> i) ) )\n                        let cors = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst fcor c |> Option.map (fun _ -> i) ) )\n                        let dirs = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst fdir c |> Option.map (fun _ -> i) ) )\n                \n                        let telDocs = tels |> Doc.BindSeqCachedBy id (makeVar ftel >> Telefono         .formaDoc >> snd )\n                        let corDocs = cors |> Doc.BindSeqCachedBy id (makeVar fcor >> CorreoElectronico.formaDoc >> snd )\n                        let dirDocs = dirs |> Doc.BindSeqCachedBy id (makeVar fdir >> Direccion        .formaDoc >> snd )\n                \n                        () //FormaGenerica.forma\n                \n                \n                    let formaContactos (aliadoW: View<Aliado>) =\n                        let mensajes      = Var.Create \"\"\n                        let mostrar       = Var.Create false\n                        let contactosV    = Var.Create [||]\n                        \n                        aliadoW\n                        |> View.Map  (fun a -> a.contactos)\n                        |> View.Sink contactosV.Set\n                \n                        let contactosIV = V( contactosV.V |> Seq.indexed )\n                \n                        let makeVar (f, fr) i = \n                            Var.Make (V(contactosV.V |> Seq.tryItem i |> Option.bind f )) \n                                    (function Some nv -> Array.replace i (fr nv) contactosV.Value |> contactosV.Set |_-> () )\n                        \n                        let ftel = (function Telefono          tel -> Some tel |_-> None), Telefono\n                        let fcor = (function CorreoElectronico cor -> Some cor |_-> None), CorreoElectronico\n                        let fdir = (function Direccion         dir -> Some dir |_-> None), Direccion        \n                \n                        let tels = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst ftel c |> Option.map (fun _ -> i) ) )\n                        let cors = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst fcor c |> Option.map (fun _ -> i) ) )\n                        let dirs = V( contactosIV.V |> Seq.choose (fun (i, c) -> fst fdir c |> Option.map (fun _ -> i) ) )\n                \n                        let telDocs = tels |> Doc.BindSeqCachedBy id (fun i -> makeVar ftel i |> Telefono         .formaDoc |> snd |> removeButton (fun _ -> contactosV.Value |> Array.remove i |> contactosV.Set ) )\n                        let corDocs = cors |> Doc.BindSeqCachedBy id (fun i -> makeVar fcor i |> CorreoElectronico.formaDoc |> snd |> removeButton (fun _ -> contactosV.Value |> Array.remove i |> contactosV.Set ) )\n                        let dirDocs = dirs |> Doc.BindSeqCachedBy id (fun i -> makeVar fdir i |> Direccion        .formaDoc |> snd |> removeButton (fun _ -> contactosV.Value |> Array.remove i |> contactosV.Set ) )\n                \n                        let forma =\n                            TemplateLib.FormaContactos()\n                                .Mensajes(    if mostrar.V then mensajes     .V else \"\"                             )\n                                .Changed(     if aliadoW.V.contactos = contactosV.V then \"\" else \"mui-btn--primary\" )\n                                .Telefonos(   telDocs              ) \n                                .Correos(     corDocs              ) \n                                .Direcciones( dirDocs              ) \n                                .MasTelefono( fun _ -> contactosV.Value |> Array.append <| [| Telefono          telVacio    |] |> contactosV.Set)\n                                .MasCorreo(   fun _ -> contactosV.Value |> Array.append <| [| CorreoElectronico correoVacio |] |> contactosV.Set)\n                                .MasDireccion(fun _ -> contactosV.Value |> Array.append <| [| Direccion         dirVacio    |] |> contactosV.Set)\n                                .Salvar(fun ev ->\n                                    mostrar.Set true\n                                    let m =  mensajes.Value\n                                    if m.Trim() <> \"\" then JS.Alert m else \n                                        match View.TryGet aliadoW with\n                                        | Some al ->\n                                            asyncResult {\n                                                let! resp = ActualizarContactos (al.id, contactosV.Value) |> Rpc.ejecutarDataEventoNuevo\n                                                refrescarData true\n                                                sprintf \"%A\" resp|> JS.Alert\n                                            } |> Rpc.iterA \n                                        | _ -> JS.Alert \"Error not caught FormaDatos\"\n                                )\n                                .Create()\n                \n                        forma.Doc\n                \n                    let formaDoc() = aliadoIdDoc formaContactos\n                \n                module FormaAutorizacion =\n                \n                    let cuentaAutorizar = Var.Create <| Html.text \"No hay cuenta seleccionada\"\n                    let titular         = Var.Create \"\"\n                    let mutable pid : IdPayment = IdPayment \"\"\n                \n                    let formaAutorizacion () =\n                        let mensajes = Var.Create \"\"\n                        let acepto   = Var.Create false\n                        //let nombreW  = V( Aliado.nombre2 aliadoW.V.datosPersonales) \n                        let ymd    (f:System.DateTime) = f.Year * 10000 + f.Month * 100 + f.Day\n                        let forma    =\n                            TemplateLib.Autorizacion()\n                                .Afiliado(          titular.V                                           ) \n                                .MontoAfiliacion(   sprintf \"$%d.00\" modeloV.V.premisas.montoAfiliacion )\n                                .dia(               string <| Aliado.dia aliadoW.V.diaPago              )\n                                .CuentaDebitar(     cuentaAutorizar.V                                   )\n                                .FirmarClass(       if mensajes.V = \"\" then \"mui-btn--primary\" else \"\"  )\n                                .Mensaje(           mensajes.V                                          )\n                                .Acepto(            acepto.V                                            )\n                                .Firmar(            fun _ -> \n                                                        if mensajes.Value <> \"\" then JS.Alert mensajes.Value else\n                                                        Rpc.actualizarSubscripcion pid\n                                                        |> AsyncResult.map (sprintf \"Subscripción #%s creada.\" >> JS.Alert)\n                                                        |> Rpc.iterA                                    )\n                                .Create()\n                        V( \n                            [\n                                forma.Vars.Titular.V.Trim()                                 <> titular.V.ToUpper()              , \"Nombre del titular en MAYUSCULAS debe coincidir\"\n                                forma.Vars.Fecha  .V |> ParseO.parseDateO |> Option.map ymd <> Some (ymd System.DateTime.Today) , \"Introduzca fecha de hoy\"\n                                forma.Vars.Acepto .V |> not                                                                     , \"Acepte los terminos indicados\"\n                            ]\n                            |> Seq.filter fst\n                            |> Seq.map    snd\n                            |> String.concat \", \"\n                        )\n                        |> View.Sink mensajes.Set\n                        forma.Doc\n                     \n                module FormaFormasPago =\n                    open VariousUI\n                \n                    let msg ({ FormaPago.authorizeIdR = idR }) = \n                        match idR with \n                        | Error \"\" -> \"La cuenta aun no ha sido verificada\" \n                        | Error m  -> m \n                        | Ok v -> sprintf \"Cuenta verificada: %A\" v \n                \n                    let ftar = (fun cp -> match cp.cuentaPago with TarjetaCredito tar -> Some (tar, msg cp, (match cp with { FormaPago.authorizeIdR = Ok _ } -> true |_-> false)) |_-> None), (fun fp v -> { fp with cuentaPago = TarjetaCredito v ; authorizeIdR = Error \"\" })\n                    let fcta = (fun cp -> match cp.cuentaPago with CuentaBancaria cta -> Some (cta, msg cp, (match cp with { FormaPago.authorizeIdR = Ok _ } -> true |_-> false)) |_-> None), (fun fp v -> { fp with cuentaPago = CuentaBancaria v ; authorizeIdR = Error \"\" })\n                \n                    let refrescarFormasPago() = Rpc.obtenerFormasDePago() |> AsyncResult.map formasPagoAliadoV.Set |> Rpc.iterA\n                \n                    let formaFormasPago (aliadoW: View<Aliado>) =\n                        let mensajes      = Var.Create \"\"\n                        let mostrar       = Var.Create false\n                        let formasPagoV   = Var.Create [||]\n                        \n                        formasPagoAliadoV.View\n                        |> View.Sink formasPagoV.Set\n                \n                        refrescarFormasPago()\n                        \n                        let formasPagoIW  = V(formasPagoV.V |> Seq.indexed)\n                \n                        let makeVar (f: (FormaPago -> ('a * string * bool) option) , fr : (FormaPago -> 'a -> FormaPago)) i = \n                            Var.Make (V(formasPagoV.V |> Seq.tryItem i |> Option.bind f )) \n                                    (function Some nv -> Array.replace i (fr formasPagoV.Value.[i] (fst3 nv) ) formasPagoV.Value |> formasPagoV.Set |_-> () )\n                        \n                        let tars = V( formasPagoIW.V |> Seq.choose (fun (i, c) -> fst ftar c |> Option.map (fun _ -> i) ) )\n                        let ctas = V( formasPagoIW.V |> Seq.choose (fun (i, c) -> fst fcta c |> Option.map (fun _ -> i) ) )\n                \n                        let validar (fp:FormaPago) = \n                            asyncResult {\n                                let! pymtId = fp .authorizeIdR\n                                let! resp   = Rpc.validarFormaPago pymtId\n                                JS.Alert resp\n                            } |> Rpc.iterA\n                \n                        let otherButtons i docF = \n                            [   \n                                yield Doc.Button \"AUTORIZAR DEBITO\" [\n                                        Html.attr.title \"Autorizar pago recurrente\" \n                                        Html.attr.styleDyn <| V (match formasPagoV.V.[i].authorizeIdR with | Ok _ -> \"\" |_-> \"display:None\")\n                                        ] \n                                        (fun _ -> \n                                            match formasPagoV.Value.[i].authorizeIdR, formasPagoV.Value.[i].cuentaPago with\n                                            | Error m, _ -> JS.Alert (\"Pago no está verificado en Authorize: \" + m)\n                                            | Ok pid,  CuentaBancaria           { titular = titular }\n                                            | Ok pid,  TarjetaCredito           { titular = titular } ->\n                                                FormaAutorizacion.cuentaAutorizar   .Set <| docF()\n                                                FormaAutorizacion.titular           .Set <| titular\n                                                FormaAutorizacion.pid                    <- pid\n                                                Content \"ProzperLyt.cntAutorizacion\"     |> endPointV.Set\n                                            | _ -> JS.Alert \"Autorizacion no esta implementada\"\n                                        )\n                                yield Html.br [] []\n                                yield docF()\n                                yield Doc.Button \"validar\" [    \n                                        Html.attr.title \"validar forma de pago\" \n                                        Html.attr.styleDyn <| V (match formasPagoV.V.[i].authorizeIdR with | Ok _ -> \"\" |_-> \"display:None\")\n                                        ] (fun _ -> validar formasPagoV.Value.[i]  )\n                            ] \n                            |> Doc.Concat\n                            |> removeButton (fun _ -> formasPagoV.Value |> Array.remove i |> formasPagoV.Set )\n                \n                \n                        let tarDocs = tars |> Doc.BindSeqCachedBy id (fun i -> makeVar ftar i |> (fun v () -> TarjetaCredito.formaDocO v |> snd) |> otherButtons i )\n                        let ctaDocs = ctas |> Doc.BindSeqCachedBy id (fun i -> makeVar fcta i |> (fun v () -> CuentaBancaria.formaDocO v |> snd) |> otherButtons i )\n                \n                        let fp cp = {\n                            cuentaPago   = cp\n                            authorizeIdR = Error \"\"\n                            nombre       = \"\"\n                        }\n                \n                        let fpIds fps  = fps |> Seq.choose(fun fp -> match fp.authorizeIdR with | Ok fpid -> Some fpid |_-> None) |> Set\n                \n                        let forma =\n                            TemplateLib.FormaCuentas()\n                                .Mensajes(    if mostrar.V then mensajes.V else \"\"                                    )\n                                .Tarjetas(    tarDocs              ) \n                                .Cuentas(     ctaDocs              ) \n                                .MasTarjeta(  fun _ -> formasPagoV.Value |> Array.append <| [| TarjetaCredito tarVacio |> fp |] |> formasPagoV.Set)\n                                .MasCuenta(   fun _ -> formasPagoV.Value |> Array.append <| [| CuentaBancaria ctaVacio |> fp |] |> formasPagoV.Set)\n                                .Changed(     if formasPagoAliadoV.V = formasPagoV.V then \"\" else \"mui-btn--primary\" )\n                                .Salvar(fun ev ->\n                                    mostrar.Set true\n                                    let m =  mensajes.Value\n                                    if  m.Trim() <> \"\" then JS.Alert m else \n                                        match View.TryGet aliadoW with\n                                        | Some al ->\n                                            asyncResult {\n                                                let fpids = fpIds formasPagoAliadoV.Value - fpIds formasPagoV.Value\n                                                for fpid in fpids do\n                                                    let! resp = Rpc.borrarFormaPago fpid\n                                                    () // do! ResultMessage.Info resp\n                                                for formaPago in formasPagoV.Value do\n                                                    let callO = match formaPago.cuentaPago with\n                                                                | TarjetaCredito tar when not (tar.numero.Id.Contains \"X\") -> Some <| Rpc.registrarTarjeta tar\n                                                                | CuentaBancaria cta when not (cta.numero.Id.Contains \"X\") -> Some <| Rpc.registrarCuenta  cta\n                                                                | _-> None\n                                                    match callO with\n                                                    | None -> ()\n                                                    | Some call ->\n                                                    let! resp = call\n                                                    () // do! ResultMessage.Info resp\n                                                refrescarFormasPago()\n                                            } |> Rpc.iterA\n                                        | _ -> JS.Alert \"Error not caught FormaDatos\"\n                                )\n                                .Create()\n                \n                        forma.Doc\n                \n                    let formaDoc() = aliadoIdDoc formaFormasPago\n                \n                module RenderAliados =\n                    open SortWith\n                \n                    let aliados() =\n                        let expandidos = Var.Create None\n                        let hijosDeO   = Var.Create None\n                \n                        let hijosDe id = hijosDeO.Value |> Option.map (fun f -> f id) |> Option.defaultValue [||]\n                \n                        let referidos al =\n                            if al.nReferidos = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nRefActivos al.nReferidos\n                        let descendientes al =\n                            if al.nDescendientes = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nDescActivos al.nDescendientes\n                        let comision v = if v = 0 then \"-\" else money v \n                        let expandido id =\n                            expandidos.View\n                            |> View.Map (fun exp -> \n                                if hijosDe id |> Seq.isEmpty then \"\" else\n                                if exp |> Option.map (Set.contains id) = Some true then \"Expandido\" else \"Colapsado\") \n                        let expandir  id =\n                            if expandidos.Value |> Option.map (Set.contains id) = Some true then Set.remove else Set.add\n                                <| id \n                                <| (expandidos.Value |> Option.defaultValue Set.empty)\n                            |> Some\n                            |> expandidos.Set\n                        let seleccionar id =  Some id |> selAliadoIdOV.Set\n                        let sortAliados als =\n                            let als = als |> Seq.sortWith (desc (fun al -> al.comision                       )\n                                                        &>  asc (fun al -> al.status                         )\n                                                        &> desc (fun al -> al.nRefActivos , al.nReferidos    )\n                                                        &> desc (fun al -> al.nDescActivos, al.nDescendientes)\n                                                        &>  asc (fun al -> Aliado.nombre al.datosPersonales  ) )\n                            let buscar = Aliado.busqueda als\n                            hijosDeO.Set <| Some buscar.hijosDe\n                            let nivel = try als |> Seq.map (fun al -> al.nivel) |> Seq.min with _ -> 1\n                            let raiz = als |> Seq.filter (fun al -> al.nivel = nivel)\n                            if raiz |> Seq.isEmpty then\n                                expandidos.Set None\n                            elif expandidos.Value.IsNone then\n                                raiz |> Seq.map (fun al -> al.id) |> Set |> Some |> expandidos.Set\n                                raiz |> Seq.map (fun al -> al.id) |> Seq.tryHead |> Option.iter seleccionar\n                            let rec buscarExpandidos (al:Aliado) = seq {\n                                yield al\n                                if expandidos.Value |> Option.map (Set.contains al.id) |> Option.defaultValue false then\n                                    for hijo in buscar.hijos al do\n                                        yield! buscarExpandidos hijo\n                            }\n                            seq {\n                                for al in raiz do\n                                    yield! buscarExpandidos al\n                            }\n                        \n                        TemplateLib.TablaAliados()\n                            .TBody(\n                                V modeloV.V.aliados\n                                |> View.Map2 (fun _ -> sortAliados) expandidos.View\n                                |> Doc.BindSeqCachedViewBy (fun al -> al.id) (fun alid alv ->\n                                    TemplateLib.FilaAliado()\n                                        .nombre(              Aliado.nombre alv.V.datosPersonales)\n                                        .status(              sprintf \"%A\"  alv.V.status         )\n                                        .tipo(                sprintf \"%A\"  alv.V.tipo           )\n                                        .nivel(               string        alv.V.nivel          )\n                                        .referidos(           referidos     alv.V                )\n                                        .descendientes(       descendientes alv.V                )\n                                        .comision(            comision      alv.V.comision       )\n                                        .expandido(           expandido     alid                 )\n                                        .expandir(   fun _ -> expandir      alid                 )\n                                        .seleccionado( if Some alid = selAliadoIdOV.V then \"seleccionado\" else \"\" )\n                                        .seleccionar(fun _ -> seleccionar   alid                 )\n                                        .Doc()\n                                )\n                            ).Doc()\n                module RenderAliado =\n                \n                    let calculo() =\n                \n                        let prem = V modeloV.V.premisas\n                \n                        let comision v = if v = 0 then \"-\" else sprintf \"%5d$\" v\n                        \n                        let alvO = \n                            let aliados = V modeloV.V.aliados\n                            let alid    = V modeloV.V.idAliado\n                            V (Seq.tryFind (fun (al:Aliado) -> al.id = alid.V) aliados.V)\n                \n                        let calculoDoc (alv: View<Aliado>) =\n                            let comisionV = V (Aliado.comision prem.V alv.V)\n                            let premisasV = V (Aliado.premisas prem.V alv.V)\n                            TemplateLib.Calculo()\n                                .referidos(        sprintf \"%d\"    alv.V.nReferidos                    )\n                                .refActivos(       sprintf \"%d\"    alv.V.nRefActivos                   )\n                                .comReferido(      sprintf \"%d\"   (alv.V.nRefActivos )                 )\n                                .descendientes(    sprintf \"%d\"    alv.V.nDescendientes                )\n                                .desActivos(       sprintf \"%d\"    alv.V.nDescActivos                  )\n                                .comision(         money (fst comisionV.V + snd comisionV.V ) )\n                                .comReferido(      money (fst comisionV.V                   ) )\n                                .comDescendiente(  money (snd comisionV.V                   ) )\n                                .porReferido(      money (fst premisasV.V                   ) )\n                                .porDescendiente(  money (snd premisasV.V                   ) )\n                                .Doc() \n                \n                        selAliadoIdDoc calculoDoc\n                \n                    let aliado() =\n                \n                        let comision v = if v = 0 then \"-\" else sprintf \"%5d$\" v\n                \n                        let correo al = \n                            al.contactos\n                            |> Seq.tryPick (function CorreoElectronico{ email = c } -> Some c |_-> None)\n                            |> Option.defaultValue \"correo no encontrado!\"\n                        \n                        let aliadoDoc (alv: View<Aliado>) =\n                            TemplateLib.Aliado()\n                                .nombre(           Aliado.nombre2 alv.V.datosPersonales)\n                                .status(           sprintf \"%A\"   alv.V.status         )\n                                .tipo(             sprintf \"%A\"   alv.V.tipo           )\n                                .contacto(         correo         alv.V                )\n                                .Calculo(          calculo()                           )\n                                .Doc() \n                \n                        selAliadoIdDoc aliadoDoc\n                \n                \n                module ReporteConsolidado =\n                    open VariousUI\n                    open SortWith\n                \n                    type Fila<'T> = {\n                        nombre        : 'T\n                        status        : 'T\n                        influyente    : 'T\n                        tipo          : 'T\n                        referido      : 'T\n                        nivel         : 'T\n                        referidos     : 'T\n                        descendientes : 'T\n                        comision      : 'T\n                        diaPago       : 'T\n                        desde         : 'T\n                        Id            : 'T\n                    }\n                \n                    let consolidado() =\n                \n                        let aliadosV = Var.Create [||]\n                \n                        V(modeloV.V.aliados)\n                        |> View.Sink aliadosV.Set\n                \n                        let referidos al =\n                            if al.nReferidos = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nRefActivos al.nReferidos\n                        let descendientes al =\n                            if al.nDescendientes = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nDescActivos al.nDescendientes\n                        let comision v = if v = 0 then \"-\" else money v \n                        let seleccionar id =  Some id |> selAliadoIdOV.Set\n                \n                        let nombreReferidor idO =\n                            idO\n                            |> Option.bind (fun id ->\n                                modeloV.Value.aliados\n                                |> Seq.tryFind (fun al -> al.id = id))\n                            |> Option.map (fun al -> Aliado.nombre al.datosPersonales)\n                            |> Option.defaultValue \"-\"\n                        \n                        let aliado2Fila al = {\n                            nombre        =      Aliado.nombre       al.datosPersonales \n                            status        =      sprintf \"%A\"        al.status          \n                            influyente    =      al.influyente |> Option.defaultValue \"\"\n                            tipo          =      sprintf \"%A\"        al.tipo            \n                            referido      =      nombreReferidor     al.idPadreO        \n                            nivel         =      sprintf \"%9d\"      al.nivel           \n                            referidos     =      sprintf \"%9s\" <| referidos           al                 \n                            descendientes =      sprintf \"%9s\" <| descendientes       al                 \n                            comision      =      sprintf \"%9s\" <| comision            al.comision        \n                            diaPago       =     (sprintf \"%A\"        al.diaPago).Right 2\n                            desde         =      Date.toYYYYMMDD \"-\" al.fechaRegistro   \n                            Id            =      sprintf \"%s\"        al.id.Id           \n                        }\n                \n                        let ordenV = \n                            Var.Create {\n                                nombre        =   2, true , (fun (d:Fila<string>) -> d.nombre       .ToUpper() )\n                                status        =   3, true , (fun (d:Fila<string>) -> d.status       .ToUpper() )\n                                influyente    =   4, false, (fun (d:Fila<string>) -> d.influyente   .ToUpper() )\n                                tipo          =   5, true , (fun (d:Fila<string>) -> d.tipo         .ToUpper() )\n                                referido      =   6, true , (fun (d:Fila<string>) -> d.referido     .ToUpper() )\n                                nivel         =   7, true , (fun (d:Fila<string>) -> d.nivel        .ToUpper() )\n                                referidos     =   8, true , (fun (d:Fila<string>) -> d.referidos    .ToUpper() )\n                                descendientes =   1, false, (fun (d:Fila<string>) -> d.descendientes.ToUpper() )\n                                comision      =   9, true , (fun (d:Fila<string>) -> d.comision     .ToUpper() )\n                                diaPago       =  10, true , (fun (d:Fila<string>) -> d.diaPago      .ToUpper() )\n                                desde         =  11, true , (fun (d:Fila<string>) -> d.desde        .ToUpper() )\n                                Id            =  12, true , (fun (d:Fila<string>) -> d.Id           .ToUpper() )\n                            }\n                \n                        let campos (orden:Fila<_*_*_>) = [|\n                            orden.nombre       \n                            orden.status       \n                            orden.influyente\n                            orden.tipo         \n                            orden.referido     \n                            orden.nivel        \n                            orden.referidos    \n                            orden.descendientes\n                            orden.comision     \n                            orden.diaPago      \n                            orden.desde        \n                            orden.Id           \n                        |] \n                \n                        let newOrden (n, _, _) (no, vo, fo) =\n                              ( if   no = n then      1\n                                elif no < n then no + 1\n                                else no)\n                            , (if n = no && n = 1 then not vo else vo)\n                            , fo\n                \n                        let toggle (v:int * bool * (Fila<string> -> string) ) = \n                            {\n                                nombre        = newOrden v ordenV.Value.nombre       \n                                status        = newOrden v ordenV.Value.status       \n                                influyente    = newOrden v ordenV.Value.influyente\n                                tipo          = newOrden v ordenV.Value.tipo         \n                                referido      = newOrden v ordenV.Value.referido     \n                                nivel         = newOrden v ordenV.Value.nivel        \n                                referidos     = newOrden v ordenV.Value.referidos    \n                                descendientes = newOrden v ordenV.Value.descendientes\n                                comision      = newOrden v ordenV.Value.comision     \n                                diaPago       = newOrden v ordenV.Value.diaPago      \n                                desde         = newOrden v ordenV.Value.desde        \n                                Id            = newOrden v ordenV.Value.Id           \n                            } |> ordenV.Set\n                \n                        let filtroV = Var.Create \"\"\n                \n                        let sortAliados (als:Aliado seq) (orden:Fila<_*_*(Fila<string> -> string)>) (filtro:string) =\n                            let vt = filtro.Trim().ToUpper()\n                            let filtros = campos orden |> Array.map (fun (_,_,f) -> f)\n                            let filtrar (fila:Fila<string>) =\n                                if vt = \"\" then true\n                                else filtros |> Seq.exists(fun f -> (f fila).Contains vt)\n                            let comparar = \n                                campos orden\n                                |> Array.sortBy (fun (n, _, _) -> n)\n                                |> Array.map    (fun (n, a, f) -> (if a then asc else desc) f)\n                                |> Array.reduce (&>)\n                            als \n                            |> Seq.map aliado2Fila\n                            |> Seq.filter   filtrar\n                            |> Seq.sortWith comparar\n                \n                        let setAliado id f = \n                            aliadosV.Value\n                            |> Array.map (fun al -> if al.id = id then f al else al)\n                            |> aliadosV.Set\n                \n                        let setStatus id (v:string) = \n                            setAliado id (fun al -> { al with status = StatusAliado.tryParse v } ) \n                \n                        let setInfluyente id (v:string) = \n                            setAliado id (fun al -> { al with influyente = if v.Trim() = \"\" then None else Some <| v.Trim() } ) \n                \n                        let setPadre id (v:string) =\n                            let padre = if v = \"\" then None else Some (IdAliado v)\n                            setAliado id (fun al -> { al with idPadreO = padre } )\n                \n                        let referidores =\n                            modeloV.View\n                            |> Doc.BindView (fun m -> \n                                m.aliados \n                                |> Seq.map (fun al -> Aliado.nombre2 al.datosPersonales, al.id.Id ) \n                                |> crearOptions2 ) \n                \n                        let obtenerAliado alid = modeloV.Value.aliados |> Seq.tryFind (fun al -> al.id = alid)\n                \n                        let salvar () = \n                            asyncResult {\n                                for al in aliadosV.Value do\n                                    match obtenerAliado al.id with\n                                    | None -> ()\n                                    | Some al2 ->\n                                    if al.status <> al2.status || al.idPadreO <> al2.idPadreO || al.influyente <> al2.influyente then\n                                        let! res = ActualizarStatusPadre(al.id, al.status, al.idPadreO, al.influyente) |> Rpc.ejecutarDataEventoNuevo\n                                        () // do! ResultMessage.Info (sprintf \"%A\" res)\n                                refrescarData true\n                            } |> Rpc.iterA\n                \n                        TemplateLib.Consolidado()\n                            .Salvar(             fun _ -> salvar() )\n                            .Cancelar(           fun _ -> aliadosV.Set   modeloV.Value.aliados   )\n                            .Changed(            if modeloV.V.aliados = aliadosV.V then \"\" else \"mui-btn--primary\" )\n                            .Filtro(             filtroV                                   )\n                            .Referidores(        referidores                               )\n                            .sort_nombre(        fun _ -> toggle ordenV.Value.nombre       )\n                            .sort_status(        fun _ -> toggle ordenV.Value.status       ) \n                            .sort_influyente(    fun _ -> toggle ordenV.Value.influyente   ) \n                            .sort_tipo(          fun _ -> toggle ordenV.Value.tipo         )\n                            .sort_referido(      fun _ -> toggle ordenV.Value.referido     )\n                            .sort_nivel(         fun _ -> toggle ordenV.Value.nivel        )\n                            .sort_referidos(     fun _ -> toggle ordenV.Value.referidos    )\n                            .sort_descendientes( fun _ -> toggle ordenV.Value.descendientes)\n                            .sort_comision(      fun _ -> toggle ordenV.Value.comision     )\n                            .sort_diaPago(       fun _ -> toggle ordenV.Value.diaPago      )\n                            .sort_desde(         fun _ -> toggle ordenV.Value.desde        )\n                            .sort_Id(            fun _ -> toggle ordenV.Value.Id           )\n                            .TBody(\n                                (V modeloV.V.aliados, ordenV.View, filtroV.View) \n                                |||> View.Map3 sortAliados\n                                |> Doc.BindSeqCachedViewBy (fun al -> al.Id) (fun alid fW ->\n                                    TemplateLib.FilaConsolidado() \n                                        .nombre(        fW.V.nombre       )\n                                        .tipo(          fW.V.tipo         )\n                                        .referido(      Var.Make (V fW.V.referido  ) (setPadre      <| IdAliado alid) )\n                                        .status(        Var.Make (V fW.V.status    ) (setStatus     <| IdAliado alid) )\n                                        .influyente(    Var.Make (V fW.V.influyente) (setInfluyente <| IdAliado alid) )\n                                        .Statuses(      statuses.View |> Doc.BindView crearOptions                    )\n                                        .nivel(         fW.V.nivel        )\n                                        .referidos(     fW.V.referidos    )\n                                        .descendientes( fW.V.descendientes)\n                                        .comision(      fW.V.comision     )\n                                        .diaPago(       fW.V.diaPago      )\n                                        .desde(         fW.V.desde        )\n                                        .Id(            fW.V.Id           )\n                                        .Doc()\n                                )\n                            ).Doc()\n                module TablaPagos =\n                    open SortWith\n                \n                    [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n                    let saveAsJavaScript (_name:string) (_txt:string) = ()\n                    \n                    let comisiones() =\n                \n                        let referidos al =\n                            if al.nReferidos = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nRefActivos al.nReferidos\n                        let descendientes al =\n                            if al.nDescendientes = 0 then \"-\" else\n                            sprintf \"%d/%d\" al.nDescActivos al.nDescendientes\n                        let comision v = if v = 0 then \"-\" else money v \n                        let seleccionar id =  Some id |> selAliadoIdOV.Set\n                        let sortAliados als =\n                            als |> Seq.sortWith (desc (fun al -> al.comision                       )\n                                              &>  asc (fun al -> al.status                         )\n                                              &> desc (fun al -> al.nRefActivos , al.nReferidos    )\n                                              &> desc (fun al -> al.nDescActivos, al.nDescendientes)\n                                              &>  asc (fun al -> Aliado.nombre al.datosPersonales  ) )\n                \n                        let pagos (als:Aliado[]) = \n                            asyncResult {\n                                let  alsf   = als  |> Seq.filter (fun al -> al.comision > 0) \n                                let  alIds  = alsf |> Seq.map    (fun al -> al.id          ) |> Seq.toArray\n                                let! fpss   = Rpc.obtenerFormasDePagoPara alIds\n                                let  ctas   = (fpss:(IdAliado * FormaPago []) []) |> Seq.map (fun (id, fps)-> id, fps |> Seq.tryPick (fun fp -> match fp.cuentaPago with | CuentaBancaria cta -> Some cta |_-> None) |> Option.defaultValue ctaVacio )\n                                let  alfps  = Seq.zip alsf ctas |> Seq.choose(fun (al, (aid2, cta) ) -> if al.id = aid2 then Some(al, cta) else None)\n                                return alfps\n                            } |> Async.map (Result.defaultValue Seq.empty)\n                \n                        let pagosW =\n                                V (modeloV.V.aliados )                \n                                |> View.MapAsync pagos\n                \n                        let def d v = if v = \"\" then d else v\n                \n                \n                        let saveAs() = \n                            async {\n                                let name = \"pagos.csv\" \n                                let! data = pagosW |> View.GetAsync\n                                let csv   = data |> Seq.map(fun alfpW ->\n                                                let alW  = fst alfpW\n                                                let ctaW = snd alfpW\n                                                sprintf \"%s,%s,%s,%s,%A,%A\" \n                                                    (\"22\"                               )\n                                                    (def \"----------\" ctaW.numero .Id   )\n                                                    (def \"----------\" ctaW.routing.Id   )\n                                                    (sprintf \"%d.00\" alW.comision       )\n                                                    (\"----------\"                       )\n                                                    (if ctaW.titular = \"\" then Aliado.nombre2 alW.datosPersonales else ctaW.titular)                    \n                                                ) |> String.concat \"\\r\\n\"\n                                csv |> saveAsJavaScript name\n                            } |> Async.Start\n                \n                \n                        TemplateLib.TablaPagos()\n                            .Exportar(   fun _ -> saveAs() )\n                            .TBody(\n                                [\n                                    TemplateLib.FilaPago()\n                                        .codigo(              sprintf \"%d\" ( pagosW.V |> Seq.length ) ) \n                                        .cuenta(              \"\"                                  )\n                                        .ABA(                 \"\"                                  )\n                                        .monto(               sprintf \"%d.00\" ( pagosW.V |> Seq.sumBy(fun (pg, _) -> pg.comision ) ) ) \n                                        .identificacion(      \"\"                                  )\n                                        .nombre(              \"\"                                  )\n                                        .Doc()\n                                    TemplateLib.FilaPago()\n                                        .codigo(              \"\"                                  )\n                                        .cuenta(              \"\"                                  )\n                                        .ABA(                 \"\"                                  )\n                                        .monto(               \"--------------------\"              )\n                                        .identificacion(      \"\"                                  )\n                                        .nombre(              \"\"                                  )\n                                        .Doc()\n                                    pagosW\n                                    |> Doc.BindSeqCachedViewBy (fun (al, _) -> al.id) (fun alid alfpW ->\n                                        let alW  = V( fst alfpW.V)\n                                        let ctaW = V( snd alfpW.V)\n                                        TemplateLib.FilaPago()\n                                            .codigo(              \"22\"                                  )\n                                            .cuenta(              def \"----------\" ctaW.V.numero .Id    )\n                                            .ABA(                 def \"----------\" ctaW.V.routing.Id    )\n                                            .monto(               sprintf \"%d.00\" alW.V.comision        )\n                                            .identificacion(      \"---------\"                           )\n                                            .nombre(              def (Aliado.nombre2 alW.V.datosPersonales) ctaW.V.titular)\n                                            .Doc()\n                                    )\n                                ]\n                            ).Doc()\n                module ListaDocs =\n                \n                    let docsV = Var.Create [||]\n                    //let docSeleccionadoV = Var.Create None\n                \n                    let refrescarListaDocs() = Rpc.obtenerListaDocs() |> AsyncResult.map docsV.Set |> Rpc.iterA \n                \n                    let uploaded : System.Action<obj,string,JQuery.JqXHR> =\n                        System.Action<_,_,_>(fun a b c -> \n                            refrescarListaDocs()\n                            JS.Alert b \n                        )\n                \n                    let subir (e:Dom.MouseEvent) id =\n                        e.PreventDefault()\n                        let form = JQuery.JQuery(\"#SubirDocumentos\")\n                        let fd = FormData()\n                        for x in form.SerializeArray() do\n                            fd.Append(x?name, (x?value : string) )\n                        let files = FileList.OfElement <| form.Children(\"input[type=file]\").First().Get(0)\n                        let file  = files.[0]\n                        let filename = file.Name\n                        fd.Append(\"file\", file)\n                        JQuery.AjaxSettings(   Type          = JQuery.RequestType.POST\n                                             , Url           = \"/api/subir/\" + id + \"/\" + filename\n                                             , Data          = fd\n                                             , ContentType   = Union1Of2 false\n                                             , ProcessData   =           false\n                                             , Success       = uploaded\n                                         )\n                        |> JQuery.JQuery.Ajax |> ignore\n                \n                    let listaDocs() =\n                \n                        refrescarListaDocs()\n                \n                        let seleccionar id =  Some id |> selAliadoIdOV.Set\n                        \n                        TemplateLib.SubirDocumentos()\n                            .TBody(\n                                docsV.View\n                                |> Doc.BindSeqCachedViewBy (id) (fun docName docNameW ->\n                                    TemplateLib.FilaDocs()\n                                        .nombre(       docNameW                )\n                                        .idAliado( V ( aliadoW.V.id.Id ) )\n                                        .Doc()\n                                )\n                            )\n                            .Subir( fun e -> View.TryGet aliadoW |> Option.iter (fun al -> subir e.Event al.id.Id) )\n                            .Doc()\n            module MainProgram =\n                open Templating\n                open ModeloUI\n            \n                open FsRoot\n                module AF = AppFramework \n            \n                let layoutName = \"ProzperLyt\"\n                let appName    = \"Prozper\"\n            \n                let scrollToBottom (e:Dom.Element) (_:obj) = \n                    async { \n                        do! Async.Sleep 100\n                        do  e.ScrollTop <- e.ScrollHeight\n                    } |> Async.Start\n            \n                let mesToString =\n                    function\n                    |  1 -> \"Ene\"\n                    |  2 -> \"Feb\"\n                    |  3 -> \"Mar\"\n                    |  4 -> \"Abr\"\n                    |  5 -> \"May\"\n                    |  6 -> \"Jun\"\n                    |  7 -> \"Jul\"\n                    |  8 -> \"Ago\"\n                    |  9 -> \"Sep\"\n                    | 10 -> \"Oct\"\n                    | 11 -> \"Nov\"\n                    | 12 -> \"Dic\"\n                    | _  -> \"---\"\n            \n                let logout () = Msal.logout()\n                let login  () = Msal.logout()\n                let enviarCorreosInvitacion () = \n                    asyncResult {\n                        let! emails0 = ModeloUI.emailsInvitarW      |> View.GetAsync\n                        let! id      = V (ModeloUI.aliadoW.V.id.Id) |> View.GetAsync\n                        let  emails  = emails0.Split '\\n' |> Array.filter (fun s -> s.Trim() <> \"\")\n                        do! Rpc.enviarCorreosInvitacion(\"Invitacion a Prozper\",  emails)\n                        match emails.Length with\n                        | 0 -> JS.Alert \"Ningun correo valido ha sido encontrado\"\n                        | 1 -> JS.Alert \"Invitacion ha sido enviada\"\n                        | _ -> JS.Alert \"Invitaciones han sido enviadas\"\n                    } |> Rpc.iterA\n            \n                let getDoc appName docName =\n                    LayoutEngine.splitName appName docName\n                    ||> AF.tryGetDoc\n                    |>  Option.map (LayoutEngine.getDocFinal [])\n                    |>  Option.defaultWith (fun () -> sprintf \"Doc not found %s\" docName |> LayoutEngine.errDoc)\n            \n                let getDocView appName docName = LayoutEngine.turnToView (fun _ ->  getDoc appName docName)\n            \n                let getContentDoc() =\n                    ModeloUI.contentVar.View\n                    |> View.Map (getDoc appName )\n                    |> Doc.EmbedView\n            \n                let getMenuDoc() =\n                    V(  match (Msal.userO.V, ModeloUI.aliadoW.V.id) with\n                        | None  , _                             -> \"ProzperLyt.mnuNoUsuario\"\n                        | Some _, id when id = Aliado.empty.id  -> \"ProzperLyt.mnuAdministrador\"\n                        | _                                     -> \"ProzperLyt.mnuUsuario\"\n                        |> getDoc appName \n                    )\n                    |> Doc.EmbedView\n            \n                let influencerV       = Var.Create \"\"\n                let influencerClassW  = influencerV.View |> View.MapAsync (fun inf -> async {\n                        let! inf = Rpc.obtenerIdInfluyente inf\n                        match inf with\n                        | Ok _ -> return \"mui-btn--primary\"\n                        | _    -> return \"\"\n                })\n                let gotoInfluencer () = \n                    async {\n                        let! inf = Rpc.obtenerIdInfluyente influencerV.Value\n                        match inf with\n                        | Ok v -> JS.Window.Location.Href <- \"/Register/\" + influencerV.Value\n                        | _    -> JS.Window.Alert <| \"Código inválido:\" + influencerV.Value\n                    } |> Async.Start\n                    \n                //let actualizarTransacciones () =\n                //    async {\n                //        Rpc.\n                //    } |> Async.Start\n            \n                [< SPAEntryPoint >]    \n                let mainProgram() =\n                    let titleV          = Var.Create appName\n                    let mesActualW      = V (mesToString    ModeloUI.modeloV.V.periodoActual  )\n                    let anoActualW      = V (string         ModeloUI.modeloV.V.anoActual      )\n                    let nombreAliadoW   = V (Aliado.nombre2 ModeloUI.aliadoW.V.datosPersonales)\n                    let idAliadoW       = V (               ModeloUI.aliadoW.V.id.Id          )\n                    let statusAliadoW   = V (string         ModeloUI.aliadoW.V.status         )\n                    let comisionAliadoW = V (string         ModeloUI.aliadoW.V.comision       )\n                    let datosAliadoW    = V (string         ModeloUI.aliadoW.V.nReferidos     )\n            \n                    AF.addPlugIn {\n                        AF.plgName    = appName\n                        AF.plgVars    = [| AF.newVar  \"title\"        titleV\n                                           AF.newVar  \"contentVar\"   ModeloUI.contentVar\n                                           AF.newVar  \"invitaciones\" ModeloUI.invitacionesV\n                                           AF.newVar  \"influencer\"   influencerV\n                                        |]  \n                        AF.plgViews   = [| AF.newViw  \"mesActual\"               mesActualW\n                                           AF.newViw  \"anoActual\"               anoActualW\n                                           AF.newViw  \"aliado\"                  nombreAliadoW\n                                           AF.newViw  \"idAliado\"                idAliadoW\n                                           AF.newViw  \"status\"                  statusAliadoW\n                                           AF.newViw  \"comision\"                comisionAliadoW\n                                           AF.newViw  \"datos\"                   datosAliadoW\n                                           AF.newViw  \"emailsInvitar\"           ModeloUI.emailsInvitarW\n                                           AF.newViw  \"invitacionesDisabled\"    ModeloUI.invitacionesDisabledW\n                                           AF.newViw  \"VideoW\"               <| V(endPointV.V |> function Video v -> v |_-> \"\")\n                                           AF.newViw  \"influencerClassW\"        influencerClassW\n                                        |]  \n                        AF.plgDocs    = [| AF.newDoc  \"Aliados\"            (lazy RenderAliados     .aliados          () )\n                                           AF.newDoc  \"Aliado\"             (lazy RenderAliado      .aliado           () )\n                                           AF.newDoc  \"Calculo\"            (lazy RenderAliado      .calculo          () )\n                                           AF.newDoc  \"FormaRegistro\"      (lazy FormaRegistro     .formaDoc         () )\n                                           AF.newDoc  \"FormaDatos\"         (lazy FormaDatos        .formaDoc         () )\n                                           AF.newDoc  \"FormaContactos\"     (lazy FormaContactos    .formaDoc         () )\n                                           AF.newDoc  \"FormaFormasPago\"    (lazy FormaFormasPago   .formaDoc         () )\n                                           AF.newDoc  \"contentDoc\"         (lazy getContentDoc                       () )\n                                           AF.newDoc  \"ReporteConsolidado\" (lazy ReporteConsolidado.consolidado      () )\n                                           AF.newDoc  \"TablaPagos\"         (lazy TablaPagos        .comisiones       () )\n                                           AF.newDoc  \"ListaDocs\"          (lazy ListaDocs         .listaDocs        () )\n                                           AF.newDoc  \"FormaAutorizacion\"  (lazy FormaAutorizacion .formaAutorizacion() )\n                                        |]  \n                        AF.plgActions = [| AF.newAct  \"Logout\"              logout\n                                           AF.newAct  \"LogIn\"               login\n                                           AF.newAct  \"enviarInvitaciones\"  enviarCorreosInvitacion\n                                           AF.newAct  \"gotoInfluencer\"      gotoInfluencer\n                                        |]\n                        AF.plgQueries = [|                                               \n                                        |]\n                    }\n                    match JS.Document.GetElementById(\"GlobalLayout\") with\n                    | null ->\n                       \"\"\"\n                            menuEditor layout\n                            |          main\n            \n                            main div \"\"\n                            :                 template  header     \"id=header\"           brand  brandV   logout \"@{Prozper.Logout}\" afiliado \"@{Prozper.aliado}\"\n                            :                 Doc       Prozper.contentDoc\n                            :                 template  sidedrawer \"id=sidedrawer\"       brand  brandV   idaliado \"@{Prozper.idAliado}\" \n                            :                 template  footer     \"id=footer\"           brand  brandV   madeby \"CIPHER Bsc\" madebylink \"www.cipherbsc.com\"\n             \n                            mainContent          template  content    \"id=content-wrapper\"  content aliados                  fecha \"@{Prozper.mesActual} @{Prozper.anoActual}\" idaliado \"@{Prozper.aliado}\"\n                            cntFormaRegistro     template  content    \"id=content-wrapper\"  content Prozper.FormaRegistro    titulo \"Referido por: @{Prozper.aliado}\"  \n                            cntFormaDatos        template  content    \"id=content-wrapper\"  content Prozper.FormaDatos       titulo \" \"\n                            cntFormaContactos    template  content    \"id=content-wrapper\"  content Prozper.FormaContactos   titulo \" \" \n                            cntFormaFormasPago   template  content    \"id=content-wrapper\"  content Prozper.FormaFormasPago  titulo \" \" \n                            cntFormaCuentas      template  content    \"id=content-wrapper\"  content ProzperLyt.FormaCuentas  titulo \" \"  \n                            cntFormaDocumentos   template  content    \"id=content-wrapper\"  content Prozper.FormaDocumentos  titulo \" \"  \n                            cntFormaNoUser       template  content    \"id=content-wrapper\"  content botonLogin               titulo \" \"  \n                            cntFormaInvitaciones template  content    \"id=content-wrapper\"  content invitaciones             titulo \" \"  \n            \n                            aliados          div       \"class=row\"\n                            :                div       \"class=mui-col-md-6\"\n                            ::               div       \"class=mui-panel mui--z5 scrollbar;max-height:550px;overflow:auto\" Prozper.Aliados\n                            :                div       \"class=mui-col-md-6\"\n                            ::               div       \"class=mui-panel mui--z5 scrollbar;max-height:550px;overflow:auto\" Aliado Comisiones\n                            brandV           Var       \"Prozper\"\n            \n                            botonLogin       div       \"class=row\"\n                            :                div       \"class=mui-col-md-6\"\n                            ::               div       \"class=mui-panel mui--z5 scrollbar;max-height:550px;overflow:auto\" \n                            :::              button    Prozper.LogIn \"class=mui-btn mui-btn--primary\" \"Ingresar al Sistema\"\n            \n                            invitaciones     div       \"class=row\"\n                            :                div       \"class=mui-col-md-6 mui-col-md-offset-1\"\n                            ::               div       \"class=mui-panel mui--z5 scrollbar; max-height:550px ; overflow:auto\" \n                            :::              h1        \"\" \"Enviar Invitaciones\"\n                            :::              textarea  Prozper.invitaciones  \"width:100% ; height:30rem; placeholder=Copie aqui las direcciones de correo electronico\" \n                            :                div       \"white-space: pre-wrap\" \"@{Prozper.emailsInvitar}\"\n                            :                button    Prozper.enviarInvitaciones \"class=mui-btn mui-btn--raised mui-btn--primary;@{Prozper.invitacionesDisabled}\" \"Enviar\"\n            \n                            Aliado           div       \"class=mui-col-md-8\"\n                            :                Doc Prozper.Aliado\n            \n                            Comisiones       template    tablacomisiones \"class=mui-col-md-3\"  tbody filasComisiones\n                            filasComisiones  concat      \"\"\n                            :                template    filacomision    \"\"  periodo \"Ene 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Feb 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Mar 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Abr 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"May 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Jun 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Jul 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Ago 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Sep 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Oct 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Nov 2018\" comision \"$1,000\"\n                            :                template    filacomision    \"\"  periodo \"Dec 2018\" comision \"$1,000\"\n                    \n                            menuEditorx      horizontal  65          menuLogo                  editorMessages\n                            double           horizontal  0-50-100    AppFramework.AppFwkClient menuEditor\n                            menuLogo         vertical    350         logo                      menu\n                            logo             span       \"margin:0;   color:gray; font-size: 55px; font-weight:530\" \"StackOverflow\"\n                            editorMessages   horizontal  10-83-100   editorButtons             messages\n                            messages         vertical    0-50-100    messagesLeft              messagesRight\n                            editorButtons    vertical    150 buttons snippetsSnippet \n                            snippetsSnippet  vertical    0-20-100    snippets                  editorProperties\n                            snippets         horizontal  20          \"@{FSharpStation.CurrentPath}\" tblDimensions2\n                            editorProperties vertical    0-100-100   snippet                   properties\n                            properties       div        \"\"           FSharpStation.Properties\n                            snippet          horizontal  35          Name                      FSharpStation.editor\n                            menu             span       \"display: grid; grid-template-columns: 30% 20% 20% 10%; grid-gap: 25px; margin:5px; grid-template-rows:50px\" inpServer btnLoad btnSaveAs\n                             \n                            severalTabs      wcomp-tabstrip  \"\" \n                            :                div \"tabname=Dimensions\" \n                            ::               div \"\" btnAddDimension RuleEditor.Dimensions\n                            :                div \"tabname=Cubes\"\n                            :                div \"tabname=Global Definitions\" RuleEditor.globalDefs\n                    \n                            btnSaveAs        button RuleEditor.SaveAs         \"class=btn @{RuleEditor.SaveNeeded}\" \"Save as...    \"\n                            btnAddDimension  button RuleEditor.AddDimension      \"\"                  \"new dim...\"\n                            btnDeleteSnippet button FSharpStation.RemoveSnippet  \"\"                  \"Delete Snippet\"\n                            btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n                            btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n                            btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n                            btnAbortFsi      button FSharpStation.AbortFsi       \"\"                  \"Abort Fsi     \"\n                    \n                            messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n                            messagesRight    wcomp-tabstrip                      \"\"                  Parser\n                    \n                            buttons          div \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\"\n                            :                button RuleEditor.AddCalculation    \"\"                 \"Add Calculation\"\n                            :                button RuleEditor.AddTotal          \"\"                 \"Add Total\"\n                            :                Doc       none x\n                            :                button RuleEditor.IndentIn          \"\"                  \"Indent In  >> \"\n                            :                button RuleEditor.IndentOut         \"\"                  \"Indent Out << \"\n                    \n                            Output           textarea  RuleEditor.Output         \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n                            FsCode           textarea  RuleEditor.CodeFS         \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n                            Parser           textarea  RuleEditor.Parser         \"tabname=Parser ; placeholder=Parser messages; dblclick=@{FSharpStation.JumpTo} ; spellcheck=false\" \n                            Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n                            inpServer        Doc       InputLabel                \"\"     \"Server:\"      RuleEditor.Server\n                            btnLoad          Doc       InputFile                 \"\"     \"Load File...\" RuleEditor.LoadFile  FileName\n                            btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n                            FileName         div                                 \"class=form-control\"  RuleEditor.fileName\n            \n                       \"\"\"\n                    | e -> e.TextContent\n                    |> LayoutEngine.newLyt layoutName\n                    |> LayoutEngine.addLayout\n            \n                    None\n                    |> Option.defaultValue layoutName\n                    |> AF.mainDocV.Set\n            \n                    let getExtraMenu =\n                        ModeloUI.aliadoW\n                        |> Doc.BindView (fun al ->\n                            if al.id = Aliado.empty.id then\n                                TemplateLib.OpcionesAdministrador().Doc()\n                            else Doc.Empty\n                        ) \n            \n                    TemplateLib()\n                        //.MainContent( AF.getMainDoc.Value )\n                        .MainContent(   getContentDoc()                     )\n                        .Menu(          getMenuDoc()                        )\n                        .headerCenter(  getDocView layoutName \"headerCenter\")\n                        .Logout(        fun _-> logout()                    )\n                        .Cortina(       if Rpc.llamadas.V > 0 then \"mui-overlay\" else \"not-mui-overlay\")\n                        .Bind()\n                    titleV.View |> View.Sink (fun t -> JS.Document.Title <- t)\n            \n                let mainProgramLoggedOff refId =\n                    ModeloUI.refAliadoIdOV.Set <| Some refId\n                    mainProgram()\n            \n            ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Provides balanced binary search tree operations.\n[<JavaScript>]\nmodule internal BalancedTree =\n\n    /// Represents a binary balanced search tree, preserving the balance\n    /// invariant: the heights of the branches differ by at most 1.\n    type Tree<'T when 'T : comparison> =\n        private {\n            Node    : 'T\n            Left    : Tree<'T>\n            Right   : Tree<'T>\n            Height  : int\n            Count   : int\n        }\n\n    [<Inline \"null\">]\n    let Empty<'T when 'T : comparison> = X<Tree<'T>>\n\n    [<Inline \"$tree == null\">]\n    let IsEmpty (tree: Tree<'T>) = X<bool>\n\n    [<Inline \"$tree == null ? 0 : $tree.Height\">]\n    let Height (tree: Tree<'T>) = X<int>\n            \n    [<Inline \"$tree == null ? 0 : $tree.Count\">]\n    let Count (tree: Tree<'T>) = X<int>\n\n    [<Inline \"$t.Left\">]\n    let Left (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Right\">]\n    let Right (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Node\">]\n    let Node (t: Tree<'T>) = X<'T>\n\n    let Branch node left right =\n        {\n            Node    = node\n            Left    = left\n            Right   = right\n            Height  = 1 + max (Height left) (Height right)\n            Count   = 1 + Count left + Count right\n        }\n\n    let Enumerate flip (t: Tree<'T>) : seq<'T> =\n        let rec gen (t, spine: list<'T * Tree<'T>>) =\n            if IsEmpty t then\n                match spine with\n                | []                    -> None\n                | (t, other) :: spine   -> Some (t, (other, spine))\n            else\n                if flip\n                then gen (Right t, (Node t, Left t) :: spine)\n                else gen (Left t, (Node t, Right t) :: spine)\n        Seq.unfold gen (t, [])\n\n    /// Traverses the tree in ascending order.\n    [<Inline>]\n    let Ascend t = Enumerate false t\n\n    /// Traverses the tree in descending order.\n    [<Inline>]\n    let Descend t = Enumerate true t\n\n    /// Builds a tree from sorted input and the indices of the\n    /// first and the last elements to include.\n    let rec private Build (data: 'T []) min max : Tree<'T> =\n        let sz = max - min + 1\n        if sz <= 0 then\n            Empty\n        else\n            let center = (min + max) / 2\n            let left   = Build data min (center - 1)\n            let right  = Build data (center + 1) max\n            Branch data.[center] left right\n\n    /// Quickly constructs a tree from a sorted, distinct array.\n    [<Inline>]\n    let OfSorted (data: 'T []) : Tree<'T> =\n        Build data 0 (Array.length data - 1)\n\n    let OfSeq (data: seq<'T>) : Tree<'T> =\n        let a = Seq.toArray (Seq.distinct data)\n        Array.sortInPlace a\n        OfSorted a\n\n    [<Inline \"$x.unshift($y)\">]\n    let private unshift (x: 'T) y = X<unit>\n\n    /// Unzips a tree into a matching node and a spine.\n    let Lookup (k: 'T) (t: Tree<'T>) =\n        let mutable spine = [||]\n        let mutable t = t\n        let mutable loop = true\n        while loop do\n            if IsEmpty t then loop <- false else\n                match compare k t.Node with\n                | 0 -> loop <- false\n                | 1 ->\n                    unshift spine (true, t.Node, t.Left)\n                    t <- t.Right\n                | _ ->\n                    unshift spine (false, t.Node, t.Right)\n                    t <- t.Left\n        (t, spine)\n\n    /// Rebuilds an unzipped tree by going up the spine and performing\n    /// rotations where necessary for balance.\n    let private Rebuild<'T when 'T : comparison>\n            (spine: (bool * 'T * Tree<'T>) []) (t: Tree<'T>) : Tree<'T> =\n        let h (x: Tree<'T>) = Height x\n        let mutable t = t\n        for i = 0 to spine.Length - 1 do\n            t <- (\n                match spine.[i] with\n                | false, x, r ->\n                    if h t > h r + 1 then\n                        if h t.Right = h t.Left + 1 then\n                            // Double rotation:\n                            let m = t.Right\n                            Branch  m.Node\n                                    (Branch t.Node t.Left m.Left)\n                                    (Branch x m.Right r)\n                        else\n                            // Single rotation:\n                            Branch  t.Node\n                                    t.Left\n                                    (Branch x t.Right r)\n                    else\n                        // No rotation:\n                        Branch x t r\n                | true, x, l ->\n                    if h t > h l + 1 then\n                        if h t.Left = h t.Right + 1 then\n                            // Double rotation:\n                            let m = t.Left\n                            Branch m.Node\n                                    (Branch x l m.Left)\n                                    (Branch t.Node m.Right t.Right)\n                        else\n                            // Single rotation:\n                            Branch t.Node\n                                    (Branch x l t.Left)\n                                    t.Right\n                    else\n                        // No rotation:\n                        Branch x l t\n            )\n        t\n\n    /// Inserts or updates a node in the tree. If a matching node is found,\n    /// it is replaced with the value of \"combine old new\".\n    let Put<'T when 'T : comparison> combine k (t: Tree<'T>) : Tree<'T> =\n        let (t, spine) = Lookup k t\n        if IsEmpty t then\n            Rebuild spine (Branch k Empty Empty)\n        else\n            Rebuild spine (Branch (combine t.Node k) t.Left t.Right)\n\n    /// Removes a node from the tree.\n    let Remove k (src: Tree<'T>) =\n        let (t, spine) = Lookup k src\n        if IsEmpty t then\n            src\n        else\n            if IsEmpty t.Right then\n                Rebuild spine t.Left\n            elif IsEmpty t.Left then\n                Rebuild spine t.Right\n            else\n                Seq.append (Ascend t.Left) (Ascend t.Right)\n                |> Seq.toArray\n                |> OfSorted\n                |> Rebuild spine\n\n    /// Adds a node into the tree, replacing an existing one if found.\n    let Add<'T when 'T : comparison> (x: 'T) (t: Tree<'T>) : Tree<'T> =\n        Put (fun _ x -> x) x t\n\n    /// Checks if a tree contains a given key.\n    let rec Contains (v: 'T) (t: Tree<'T>) : bool =\n        not (IsEmpty (fst (Lookup v t)))\n\n    /// Looks up a node by key.\n    let TryFind (v: 'T) (t: Tree<'T>) =\n        let x = fst (Lookup v t)\n        if IsEmpty x then None else Some x.Node\n\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\n\n/// Represents a key-value pair with comparison and equality\n/// ignoring the value and using only the key.\n[<CustomComparison>]\n[<CustomEquality>]\n[<JavaScript>]\ntype internal Pair<'K,'V when 'K : comparison> =\n    {\n        Key     : 'K\n        Value   : 'V\n    }\n\n    override this.GetHashCode() = hash this.Key\n\n    override this.Equals(other: obj) =\n        this.Key = (other :?> Pair<'K,'V>).Key\n\n    interface System.IComparable with\n        member this.CompareTo(other: obj) =\n            compare this.Key (other :?> Pair<'K,'V>).Key\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Collections\nmodule T = BalancedTree\n\n[<JavaScript>]\n[<AutoOpen>]\nmodule private MapUtil =\n\n    let fromSeq(s: seq<_>) =\n        let a : Pair<_,_> [] =\n            [| for (k, v) in Seq.distinctBy fst s ->\n                { Key = k; Value = v } |]\n        Array.sortInPlace a\n        T.OfSorted a\n\n/// Implements a proxy for the F# Map type.\n[<Name \"FSharpMap\">]\n[<Proxy(typeof<Map<_,_>>)>]\ntype internal FSharpMap<'K,'V when 'K : comparison>\n\n    (tree: T.Tree<Pair<'K,'V>>) =\n\n        new (s: seq<_>) = new FSharpMap<_,_>(fromSeq s)\n\n        member this.Tree = tree\n\n        member this.Add(k: 'K, v: 'V) : Map<'K,'V> =\n            As (FSharpMap<'K,'V>(tree |> T.Add {Key=k; Value=v}))\n\n        member this.ContainsKey k = \n            tree |> T.Contains {Key=k; Value = JS.Undefined}\n\n        member this.TryGetValue (k: 'K, r: byref<'V>) = \n            match this.TryFind k with\n            | Some v ->\n                r <- v\n                true\n            | _ ->\n                false\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member this.Item \n            with get (k: 'K) : 'V =\n                match this.TryFind k with\n                | Some v    ->v\n                | None      ->\n                    failwith \"The given key was not present in the dictionary.\"\n\n        member this.Remove(k: 'K) : Map<'K,'V> =\n            As (FSharpMap(tree |> T.Remove {Key=k; Value=JS.Undefined}))\n\n        member this.TryFind(k: 'K) =\n            tree\n            |> T.TryFind {Key=k; Value=JS.Undefined}\n            |> Option.map (fun kv -> kv.Value)\n\n        member this.GetEnumerator() =\n            let s =\n                T.Ascend tree\n                |> Seq.map (fun kv ->\n                    new KeyValuePair<_,_>(kv.Key, kv.Value))\n            s.GetEnumerator()\n\n        override this.GetHashCode() =\n            hash (Seq.toArray this)\n\n        override this.Equals(other) =\n            let other = As<FSharpMap<'K,'V>> other\n            this.Count = other.Count\n            && Seq.forall2 ( = ) this other\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith (fun x y ->\n                    compare (As<Pair<'K,'V>> x) (As<Pair<'K,'V>> y))\n                    this\n                    (As<Map<'K,'V>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Map module.\n[<Proxy \"Microsoft.FSharp.Collections.MapModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Map\">]\nmodule internal MapModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (m: Map<'K,'V>) =\n        (As<FSharpMap<'K,'V>> m).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<_>) : Map<'K,'V> =\n        As (new FSharpMap<'K,'V>(t))\n\n    [<Inline>]\n    let Add k v (m: Map<'K,'V>) : Map<'K,'V> = m.Add(k, v)\n\n    [<Inline>]\n    let ContainsKey k (m: Map<'K,'V>) : bool = m.ContainsKey k\n\n    [<Inline>]\n    let Empty<'K,'V when 'K : comparison> : Map<'K,'V> = new Map<_,_>([||])\n\n    let Exists (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : bool =\n        m |> Seq.exists (fun kv -> f kv.Key kv.Value)\n\n    let Filter (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> =\n        T.Ascend (ToTree m)\n        |> Seq.filter (fun kv -> f kv.Key kv.Value)\n        |> Seq.toArray\n        |> T.OfSorted\n        |> OfTree\n\n    [<Inline>]\n    let Find (k: 'K) (m: Map<'K,'V>) : 'V = m.[k]\n\n    let FindKey (f: 'K -> 'T -> bool) (m: Map<'K,'T>) : 'K =\n        m \n        |> Seq.pick (fun kv -> \n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec Fold<'K,'V,'S when 'K : comparison>\n        (f: 'S -> 'K -> 'V -> 'S) (s: 'S) (m: Map<'K,'V>) : 'S =\n            T.Ascend (ToTree m)\n            |> Seq.fold (fun s kv -> f s kv.Key kv.Value) s\n\n    let rec FoldBack (f: 'K -> 'V -> 'S -> 'S) (m: Map<'K,'V>) (s: 'S) : 'S =\n        T.Descend (ToTree m)\n        |> Seq.fold (fun s kv -> f kv.Key kv.Value s) s\n\n    let rec ForAll (f: 'K -> 'V -> bool) (m: Map<'K, 'V>) : bool =\n        m |> Seq.forall (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let IsEmpty (m: Map<'K, 'V>) : bool = m.IsEmpty\n\n    let rec Iterate (f: 'K -> 'V -> unit) (m: Map<'K, 'V>) : unit =\n        m |> Seq.iter (fun kv -> f kv.Key kv.Value)\n\n    let OfArray (a: ('K * 'V) []) : Map<'K,'V> =\n        a\n        |> Seq.map (fun (k, v) -> {Key = k; Value = v} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n    [<Inline>]\n    let OfList (kvs: list<'K * 'V>) : Map<'K,'V> = Map.ofSeq kvs\n\n    [<Inline>]\n    let OfSeq (s: seq<'K * 'V>) : Map<'K, 'V> =\n        Map.ofArray (Seq.toArray s)\n\n    let Partition (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> * Map<'K,'V> =\n        let (x, y) =\n            Seq.toArray (T.Ascend (ToTree m))\n            |> Array.partition (fun kv -> f kv.Key kv.Value)\n        (OfTree (T.OfSorted x), OfTree (T.OfSorted y))\n\n    let Pick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : 'T =\n        m |> Seq.pick (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let Remove (k: 'K) (m: Map<'K, 'V>) : Map<'K, 'V> = m.Remove k\n\n    [<Inline>]\n    let ToArray (m: Map<'K, 'V>) : array<'K * 'V> = Seq.toArray (Map.toSeq m)\n\n    [<Inline>]\n    let ToList (m: Map<'K, 'V>) : list<'K * 'V> = Seq.toList (Map.toSeq m)\n\n    let ToSeq (m: Map<'K, 'V>) : seq<'K * 'V> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> (kv.Key, kv.Value))\n\n    let TryFind (k: 'K) (m: Map<'K, 'V>) : option<'V> = m.TryFind k\n\n    let TryFindKey (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : option<'K> =\n        m |> Seq.tryPick (fun kv ->\n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec TryPick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : option<'T> =\n        m |> Seq.tryPick (fun kv -> f kv.Key kv.Value)\n         \n    let rec Map (f: 'K -> 'V -> 'T) (m: Map<'K,'V>) : Map<'K,'T> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> \n            {Key = kv.Key; Value = f kv.Key kv.Value} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nmodule T = BalancedTree\n\n/// Implements a proxy for the F# Set type.\n[<Name \"FSharpSet\">]\n[<Proxy(typeof<Set<_>>)>]\ntype private FSharpSet<'T when 'T : comparison>\n\n    internal (tree: T.Tree<'T>) =\n\n        new (s: seq<'T>) = new FSharpSet<'T>(T.OfSeq s)\n\n        member this.add(x: Set<'T>) =\n            Set.union (As this) x\n\n        member this.sub(x: Set<'T>) =\n            Set.difference (As this) x\n\n        member this.Add x : Set<'T> =\n            As (FSharpSet<'T>(T.Add x tree))\n\n        member this.Contains v = T.Contains v tree\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member internal this.Tree = tree\n\n        member this.IsProperSubsetOf(s: Set<'T>) =\n            this.IsSubsetOf s && this.Count < s.Count\n\n        member this.IsProperSupersetOf(s: Set<'T>) =\n            this.IsSupersetOf s && this.Count > s.Count\n\n        member this.IsSubsetOf(s: Set<'T>) =\n            Seq.forall s.Contains this\n\n        member this.IsSupersetOf(s: Set<'T>) =\n            Seq.forall this.Contains s\n\n        member this.MaximumElement = Seq.head (T.Descend tree)\n\n        member this.MinimumElement = Seq.head (T.Ascend tree)\n\n        member this.Remove v : Set<'T> =\n            As (FSharpSet<'T>(T.Remove v tree))\n\n        member this.GetEnumerator() =\n            (T.Ascend tree).GetEnumerator()\n\n        static member (+) (x, y) : Set<'T> =\n            Set.union x y        \n\n        static member (-) (x, y) : Set<'T> =\n            Set.difference x y        \n\n        override this.GetHashCode() =\n            -1741749453 + ((Seq.toArray this).GetHashCode())\n\n        override this.Equals(other: obj) =\n            this.Count = (As<FSharpSet<'T>> other).Count\n            && Seq.forall2 ( = ) this (As<FSharpSet<'T>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith compare this (As<FSharpSet<'T>> other)\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Set module.\n[<Proxy \"Microsoft.FSharp.Collections.SetModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Set\">]\nmodule internal SetModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (s: Set<'T>) =\n        (As<FSharpSet<'T>> s).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<'T>) =\n        As<Set<'T>> (new FSharpSet<'T>(t))\n\n    [<Inline>]\n    let Add v (s: Set<_>) = s.Add v\n\n    [<Inline>]\n    let Contains v (s: Set<_>) = s.Contains v\n\n    [<Inline>]\n    let Count (s: Set<_>) = s.Count\n\n    [<Inline>]\n    let Difference (s1: Set<_>) (s2: Set<_>) =\n        Set.filter (fun x -> not (s2.Contains x)) s1\n\n    [<Inline>]\n    let Empty<'T when 'T : comparison> : Set<'T> = OfTree T.Empty\n\n    [<Inline>]\n    let Exists f (s: Set<'T>) = Seq.exists f s\n\n    let Filter f (s: Set<'T>) =\n        OfTree (T.OfSorted (Seq.toArray (Seq.filter f s)))\n\n    [<Inline>]\n    let Fold<'T,'S when 'T : comparison>\n        (f: 'S -> 'T -> 'S) (x: 'S) (a: Set<'T>) =\n            Seq.fold f x a\n\n    let FoldBack (f: 'T -> 'S -> 'S) (a: Set<'T>) (s: 'S) : 'S =\n        Seq.fold (fun s x -> f x s) s (T.Descend (ToTree a))\n\n    [<Inline>]\n    let ForAll f (a: Set<_>) = Seq.forall f a\n\n    [<Inline>]\n    let Intersect (s1: Set<'T>) (s2: Set<'T>) = Set.filter s2.Contains s1\n\n    [<Inline>]\n    let IntersectMany (s: seq<Set<_>>) = Seq.reduce Set.intersect s\n\n    [<Inline>]\n    let IsEmpty (a: Set<_>) = a.IsEmpty\n\n    [<Inline>]\n    let IsProperSubset (a: Set<_>) b = a.IsProperSubsetOf b\n\n    [<Inline>]\n    let IsProperSuperset (a: Set<_>) b = a.IsProperSupersetOf b\n\n    [<Inline>]\n    let IsSubset (a: Set<_>) b = a.IsSubsetOf b\n\n    [<Inline>]\n    let IsSuperset (a: Set<_>) b = a.IsSupersetOf b\n\n    [<Inline>]\n    let Iterate f (s: Set<_>) = Seq.iter f s\n\n    [<Inline>]\n    let Map f (s: Set<_>) = Set.ofSeq (Seq.map f s)\n\n    [<Inline>]\n    let MaxElement (s: Set<_>) = s.MaximumElement\n\n    [<Inline>]\n    let MinElement (s: Set<_>) = s.MinimumElement\n\n    [<Inline>]\n    let OfArray (a: 'T []) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfList (a: list<'T>) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfSeq (a: seq<'T>) = OfTree (T.OfSeq a)\n\n    let Partition f (a: Set<_>) =\n        let (x, y) = Array.partition f (Seq.toArray a)\n        (Set.ofArray x, Set.ofArray y)\n\n    [<Inline>]\n    let Remove v (a: Set<_>) = a.Remove v\n\n    [<Inline>]\n    let Singleton x = Set.add x Set.empty\n\n    [<Inline>]\n    let ToArray (a: Set<_>) = Seq.toArray a\n\n    [<Inline>]\n    let ToList (a: Set<_>) = Seq.toList a\n\n    [<Inline>]\n    let ToSeq (a: Set<_>) : seq<_> = a :> _\n\n    [<Inline>]\n    let Union (s1: Set<_>) (s2: Set<_>) =\n        Set.ofSeq (Seq.append s1 s2)\n\n    [<Inline>]\n    let UnionMany (sets: seq<Set<_>>) =\n        Set.ofSeq (Seq.concat sets)\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.ResizeArray\n\nopen WebSharper\nopen WebSharper.JavaScript\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\n\n[<Name \"WebSharper.Collections.ListEnumerator\">]\n[<Proxy(typeof<System.Collections.Generic.List.Enumerator<_>>)>]\ntype ResizeArrayEnumeratorProxy<'T> [<JavaScript>] (arr: 'T[]) =\n    let mutable i = -1\n\n    [<JavaScript>] \n    member this.MoveNext() =\n        i <- i + 1\n        i < arr.Length\n\n    [<JavaScript>] \n    member this.Current with get() = arr.[i]\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = this.MoveNext()\n        [<JavaScript>]\n        member this.Current with get() = box (arr.[i])\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = arr.[i]\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = ()\n\n[<Proxy(typeof<System.Collections.Generic.List<_>>)>]\n[<Name \"WebSharper.Collections.List\">]\n[<Prototype false>]\ntype ResizeArrayProxy<'T> [<Inline \"$_arr\">] (_arr: 'T []) =\n\n    [<Inline \"[]\">]\n    new () =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline \"[]\">]\n    new (size: int) =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline>]\n    new (el: seq<'T>) =\n        new ResizeArrayProxy<'T>(Seq.toArray el)\n\n    [<Inline>]\n    member this.GetEnumerator() =\n        As<System.Collections.Generic.List.Enumerator<'T>>(new ResizeArrayEnumeratorProxy<'T>(As<'T[]> this))\n\n    interface 'T seq with\n        member this.GetEnumerator() = (As<System.Collections.IEnumerable> this).GetEnumerator()\n        member this.GetEnumerator() = (As<seq<'T>> this).GetEnumerator()\n\n    [<Inline>]\n    member this.Add(x: 'T) : unit =\n        As<'T[]>(this).JS.Push(x) |> ignore\n\n    [<Inline>]\n    member this.AddRange(x: seq<'T>) : unit =\n        Seq.iter this.Add x\n\n    [<Inline>]\n    member this.AsReadOnly() : System.Collections.ObjectModel.ReadOnlyCollection<'T> =\n        System.Array.AsReadOnly(As<'T[]> this)\n\n    [<Inline>]\n    member this.BinarySearch(start: int, length: int, item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, start, length, item, comparer)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T) : int =\n        System.Array.BinarySearch(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, item, comparer)\n\n    [<Inline>]\n    member this.Clear() : unit =\n        (As<'T[]> this).JS.Splice(0, this.Count) |> ignore\n\n    [<Inline>]\n    member this.Contains(item: 'T) : bool =\n        System.Array.Exists(As<'T[]> this, fun x -> System.Collections.Generic.EqualityComparer.Default.Equals(item, x))\n\n    [<Inline>]\n    member this.ConvertAll<'U>(conv: System.Converter<'T, 'U>) : ResizeArray<'U> =\n        ResizeArray<'U>(System.Array.ConvertAll(As<'T[]> this, conv))\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[]) : unit =\n        this.CopyTo(arr, 0)\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[], offset: int) : unit =\n        this.CopyTo(0, arr, offset, this.Count)\n\n    [<Inline>]\n    member this.CopyTo(index: int, target: 'T[], offset: int, count: int) : unit =\n        Array.blit (As<'T[]> this) index target offset count\n\n    [<Inline>]\n    member this.Count : int = (As<'T[]> this).Length\n\n    [<Inline>]\n    member this.Exists(pred: System.Predicate<'T>) : bool =\n        System.Array.Exists(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.Find(pred: System.Predicate<'T>) : 'T =\n        System.Array.Find(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindAll(pred: System.Predicate<'T>) : ResizeArray<'T> =\n        ResizeArray<'T>(System.Array.FindAll(As<'T[]> this, pred))\n\n    [<Inline>]\n    member this.FindIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.FindLast(pred: System.Predicate<'T>) : 'T =\n        System.Array.FindLast(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.ForEach(action: System.Action<'T>) : unit =\n        System.Array.ForEach(As<'T[]> this, action)\n\n    [<Inline>]\n    member this.GetRange(index: int, count: int) : ResizeArray<'T> =\n        As (ResizeArrayProxy<'T>(Array.sub (As<'T[]> this) index count))\n\n    [<Inline>]\n    member this.IndexOf(item: 'T) : int =\n        System.Array.IndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start, count)\n\n    [<Inline>]\n    member this.Insert(index: int, item: 'T) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, item) |> ignore\n\n    [<Inline>]\n    member this.InsertRange(index: int, items: seq<'T>) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, Array.ofSeq items) |> ignore\n\n    member this.Item\n        with [<Inline>] get (x: int) : 'T = (As<'T[]> this).[x]\n        and [<Inline>] set (x: int) (v: 'T) = (As<'T[]> this).[x] <- v\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start, count)\n\n    member this.Remove(item: 'T) : bool =\n        match this.IndexOf(item) with\n        | -1 -> false\n        | n -> this.RemoveAt(n); true\n\n    member this.RemoveAll(pred: System.Predicate<'T>) : int =\n        let mutable removed = 0\n        let mutable i = 0\n        while i < this.Count do\n            if pred.Invoke((As<'T[]> this).JS.[i]) then\n                let mutable j = i + 1\n                while j < this.Count && pred.Invoke((As<'T[]> this).JS.[j]) do\n                    j <- j + 1\n                removed <- removed + j - i\n                (As<'T[]> this).JS.Splice(i, j - i) |> ignore\n            else\n                i <- i + 1\n        removed\n\n    [<Inline>]\n    member this.RemoveAt(x: int) : unit =\n        (As<'T[]> this).JS.Splice(x, 1) |> ignore\n\n    [<Inline>]\n    member this.RemoveRange(index: int, count: int) : unit =\n        (As<'T[]> this).JS.Splice(index, count) |> ignore\n\n    [<Inline>]\n    member this.Reverse() : unit =\n        System.Array.Reverse(As<'T[]> this)\n\n    [<Inline>]\n    member this.Reverse(index: int, count: int) : unit =\n        System.Array.Reverse(As<'T[]> this, index, count)\n\n    [<Inline>]\n    member this.Sort() : unit =\n        System.Array.Sort(As<'T[]> this)\n\n    [<Inline>]\n    member this.Sort(comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.Sort(start: int, length: int, comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, start, length, comp)\n\n    [<Inline>]\n    member this.Sort(comp: System.Comparison<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.ToArray() : 'T [] =\n        Array.copy (As<'T[]> this)\n\n    [<Inline>]\n    member this.TrimExcess() = ()\n\n    [<Inline>]\n    member this.TrueForAll(pred: System.Predicate<'T>) : bool =\n        System.Array.TrueForAll(As<'T[]> this, pred)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.LinkedList\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype LL<'T> = LinkedList<'T>\ntype LLN<'T> = LinkedListNode<'T>\ntype LLE<'T> = LinkedList<'T>.Enumerator\n\n[<Proxy(typeof<LLN<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListNode\">]\ntype NodeProxy<'T> =\n    member this.Previous with [<Inline \"$this.p\">] get () = X<LLN<'T>>\n    member this.Next     with [<Inline \"$this.n\">] get () = X<LLN<'T>>\n    member this.Value    with [<Inline \"$this.v\">] get () = X<'T>\n\n[<Inline \"{p: $p, n: $n, v: $v}\">]\nlet newNode<'T> (p: LLN<'T>) (n: LLN<'T>) (v: 'T) = X<LLN<'T>>\n\n[<Inline \"$node.p = $p\" >]\nlet setPrev (node: LLN<'T>) (p: LLN<'T>) = ()\n\n[<Inline \"$node.n = $n\" >]\nlet setNext (node: LLN<'T>) (n: LLN<'T>) = ()\n\n[<Proxy(typeof<LLE<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListEnumerator\">]\ntype EnumeratorProxy<'T> [<JavaScript>] (l: LLN<'T>) =\n    let mutable c = l\n\n    interface IEnumerator<'T> with\n        member this.Current = c.Value\n        \n        member this.Current = c.Value |> box\n\n        member this.MoveNext() =\n            c <- c.Next\n            c <> null\n\n        member this.Dispose() = ()\n\n        member this.Reset() = ()\n\n[<Proxy(typeof<LL<_>>)>]\n[<Name \"WebSharper.Collections.LinkedList\">]\ntype ListProxy<'T> [<JavaScript>] (coll: 'T seq) =\n    let mutable c = 0\n    let mutable n = null\n    let mutable p = null\n\n    do  let ie = coll.GetEnumerator()\n        if ie.MoveNext() then\n            n <- newNode null null ie.Current\n            p <- n\n            c <- 1\n        while ie.MoveNext() do\n            let node = newNode p null ie.Current\n            setNext p node\n            p <- node\n            c <- c + 1\n            \n    new () = ListProxy(Seq.empty)          \n\n    [<Inline>]\n    member this.Count = c\n\n    [<Inline>]\n    member this.First = n\n\n    [<Inline>]\n    member this.Last = p\n\n    member this.AddAfter(after: LLN<'T>, value) =\n        let before = after.Next\n        let node = newNode after before value\n        if after.Next = null then p <- node\n        setNext after node\n        if before <> null then setPrev before node\n        c <- c + 1\n        node\n\n    member this.AddBefore(before: LLN<'T>, value) =\n        let after = before.Previous\n        let node = newNode after before value\n        if before.Previous = null then n <- node \n        setPrev before node\n        if after <> null then setNext after node\n        c <- c + 1\n        node\n\n    member this.AddFirst(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddBefore(n, value)\n\n    member this.AddLast(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddAfter(p, value)\n\n    member this.Clear() =\n        c <- 0\n        n <- null\n        p <- null\n\n    member this.Contains(value: 'T) =\n        let mutable found = false\n        let mutable node = n\n        while node <> null && not found do\n            if node.Value ==. value then found <- true \n            else node <- node.Next\n        found\n            \n    member this.Find(value: 'T) =\n        let mutable node = n\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Next\n        if notFound then null else node\n\n    member this.FindLast(value: 'T) = \n        let mutable node = p\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Previous\n        if notFound then null else node\n                \n    member this.GetEnumerator(): LinkedList<'T>.Enumerator =\n        As (new EnumeratorProxy<_>(As this))\n\n    interface IEnumerable with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    interface IEnumerable<'T> with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    member this.Remove(node: LLN<'T>) =\n        let before = node.Previous\n        let after = node.Next\n        if before = null then n <- after else setNext before after\n        if after = null then p <- before else setPrev after before\n        c <- c - 1\n        \n    member this.Remove(value) = \n        let node = this.Find(value)\n        if node = null then false\n        else\n            this.Remove(node)\n            true\n\n    member this.RemoveFirst() = this.Remove(n)\n\n    member this.RemoveLast() = this.Remove(p)\n               \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<IGrouping<_, _>>)>]\ntype internal IGroupingProxy<'K, 'T> =\n    abstract Key : 'K\n\n[<JavaScript>]\ntype internal Grouping<'K, 'T> (k: 'K, v: seq<'T>) =\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            v.GetEnumerator()\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() =\n            (v :> System.Collections.IEnumerable).GetEnumerator()\n\n    interface System.Linq.IGrouping<'K, 'T> with\n        member this.Key = k\n\n[<Proxy(typeof<IOrderedEnumerable<_>>)>]\ntype internal IOrderedEnumerableProxy<'T> =\n    inherit seq<'T>\n    abstract CreateOrderedEnumerable<'K>\n        : keySelector: Func<'T, 'K>\n        * comparer: IComparer<'K>\n        * descending: bool\n        -> IOrderedEnumerable<'T>\n\n[<JavaScript>]\ntype internal FsComparer<'T when 'T : comparison>() =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            compare x y\n\n[<JavaScript>]\ntype internal ProjectionComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke x, projection.Invoke y)\n\n[<JavaScript>]\ntype internal CompoundComparer<'T>(primary: IComparer<'T>, secondary: IComparer<'T>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            match primary.Compare(x, y) with\n            | 0 -> secondary.Compare(x, y)\n            | n -> n\n\n[<JavaScript>]\ntype internal ReverseComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke y, projection.Invoke x)\n\n[<JavaScript>]\ntype internal OrderedEnumerable<'T>(source: seq<'T>, primary: IComparer<'T>) =\n    interface IOrderedEnumerable<'T> with\n        member this.CreateOrderedEnumerable(keySelector, secondary, descending) =\n            let secondary =\n                if descending then\n                    ReverseComparer(secondary, keySelector) :> IComparer<'T>\n                else\n                    ProjectionComparer(secondary, keySelector) :> IComparer<'T>\n            OrderedEnumerable<'T>(source, CompoundComparer(primary, secondary)) :> _\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let a = Array.ofSeq source\n            Array.sortInPlaceWith (fun x y -> primary.Compare(x, y)) a\n            (a :> seq<'T>).GetEnumerator()\n    interface IEnumerable with\n        member this.GetEnumerator() =\n            (this :> IEnumerable<'T>).GetEnumerator() :> _\n\n//[<Proxy(typeof<ILookup<_, _>>)>]\n//type internal ILookupProxy<'K, 'E> =\n//    inherit seq<IGrouping<'K, 'E>>\n//    inherit IEnumerable\n//    abstract Item : 'K -> 'E with get\n//    abstract Count : int with get\n//    abstract Contains : 'K -> bool\n//\n//[<JavaScript>]\n//type internal Lookup<'K, 'T, 'E>(source: seq<'T>, key: Func<'T, 'K>, elt: Func<'T, 'E>, comparer: IEqualityComparer<'K>) =\n//\n//    let dc = lazy (\n//        let d = Dictionary<'K, ResizeArray<'E>>(comparer)\n//        let count = ref 0\n//        source |> Seq.iter (fun e ->\n//            incr count\n//            let k = key.Invoke e\n//            let v = elt.Invoke e\n//            if d.ContainsKey k then\n//                d.[k].Add(v)\n//            else\n//                d.Add(k, ResizeArray([|v|]))\n//        )\n//        d, !count\n//    )\n//\n//    let s = lazy (\n//        fst dc.Value |> Seq.map (fun (KeyValue(k, v)) ->\n//            Grouping(k, v) :> IGrouping<_,_>)\n//    )\n//\n//    interface seq<IGrouping<'K, 'E>> with\n//        member this.GetEnumerator() = s.Value.GetEnumerator()\n//    interface IEnumerable with\n//        member this.GetEnumerator() = (s.Value :> IEnumerable).GetEnumerator()\n//    interface ILookup<'K, 'E> with\n//        member this.Item with get k = (fst dc.Value).[k] :> seq<_>\n//        member this.Count = snd dc.Value\n//        member this.Contains(k) = (fst dc.Value).ContainsKey(k)\n\ntype private LinqMacro() =\n    inherit Macro()\n\n    override this.TranslateCall(c) = //e, t, m, a, _) =\n        let targ = c.Method.Generics.[0]\n        WebSharper.Core.Macros.EqualityComparer.GetDefault(c.Compilation, targ)\n        |> MacroResult.Map (fun ec ->\n            let m' =\n                let t =\n                    AST.Type.ConcreteType {\n                        Generics = [targ]\n                        Entity =\n                            typedefof<IEqualityComparer<int>>\n                            |> AST.Reflection.ReadTypeDefinition\n                    }\n                let m = c.Method.Entity.Value\n                { m with Parameters = m.Parameters @ [t] }\n            let m = { c.Method with Entity = Hashed m' }\n            AST.Call(c.This, c.DefiningType, c.Method, c.Arguments @ [ec]))\n\n[<Name \"WebSharper.Linq\">]\n[<Proxy(typeof<System.Linq.Enumerable>)>]\n[<JavaScript>]\ntype private LinqProxy =\n\n    [<Inline>]\n    static member Aggregate<'T>(this: seq<'T>, func: Func<'T, 'T, 'T>) : 'T =\n        Seq.reduce (fun x y -> func.Invoke(x, y)) this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>) : 'U =\n        Seq.fold (fun x y -> func.Invoke(x, y)) seed this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U, 'R>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>, resultSelector: Func<'U, 'R>) : 'R =\n        resultSelector.Invoke(Seq.fold (fun x y -> func.Invoke(x, y)) seed this)\n\n    [<Inline>]\n    static member All<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.forall predicate.Invoke this\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>) : bool =\n        not (Seq.isEmpty this)\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.exists predicate.Invoke this\n\n    [<Inline>]\n    static member AsEnumerable<'T>(this: seq<'T>) : seq<'T> =\n        this\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    static member Average(this: seq<Nullable<float>>) : Nullable<float> =\n        let mutable x = [||]\n        use e = this.GetEnumerator()\n        while e.MoveNext() do\n            if e.Current.HasValue then\n                x.JS.Push e.Current.Value |> ignore\n        if x.Length = 0 then\n            Nullable()\n        else\n            Nullable(Seq.sum x / float x.Length)\n\n    [<Inline>]\n    static member Average(this: seq<float>) : float =\n        Seq.average this\n\n    [<Inline>]\n    static member Average(this: seq<int64>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average(this: seq<int>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int64>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        Seq.average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Cast<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast this\n\n    [<Inline>]\n    static member Concat<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        Seq.append this second\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T) : bool =\n        LinqProxy.Contains(this, value, EqualityComparer.Default)\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T, comparer: IEqualityComparer<'T>) : bool =\n        Seq.exists (fun x -> comparer.Equals(value, x)) this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>) : int =\n        Seq.length this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int =\n        Seq.length (Seq.filter predicate.Invoke this)\n\n    [<Inline>]\n    static member DefaultIfEmpty<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.DefaultIfEmpty(this, Unchecked.defaultof<'T>)\n\n    static member DefaultIfEmpty<'T>(this: seq<'T>, defaultValue: 'T) : seq<'T> =\n        if Seq.isEmpty this then\n            Seq.singleton defaultValue\n        else this\n\n    [<Inline>]\n    static member Distinct<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.Distinct(this, EqualityComparer.Default)\n\n    static member Distinct<'T>(this: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let tbl = HashSet(comparer)\n            while e.MoveNext() do\n                if tbl.Add(e.Current) then\n                    yield e.Current\n        }\n\n    [<Inline>]\n    static member ElementAt<'T>(this: seq<'T>, index: int): 'T =\n        Seq.item index this\n\n    [<Inline>]\n    static member ElementAtOrDefault<'T>(this: seq<'T>, index: int) =\n        LinqProxy.JSElementAtOrDefault(this, index, Unchecked.defaultof<'T>)\n\n    [<Name \"ElementAtOrDefault\">]\n    static member JSElementAtOrDefault<'T>(this: seq<'T>, index: int, defaultValue: 'T) : 'T =\n        try Seq.item index this\n        with _ -> defaultValue\n\n    [<Inline>]\n    static member Empty<'T>() : seq<'T> =\n        Seq.empty\n\n    [<Inline>]\n    static member Except<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Except(this, second, EqualityComparer.Default)\n\n    static member Except<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for x in second do tbl.Remove(x) |> ignore\n        tbl :> _\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>) : 'T =\n        Seq.head this\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        Seq.find predicate.Invoke this\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        if e.MoveNext() then e.Current else defaultValue\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault$1\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match Seq.tryFind predicate.Invoke this with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, resultSelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : seq<IGrouping<'K, 'E>> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'E>> =\n        Seq.delay (fun () ->\n            // Using an array instead of a seq is important here: the returned groupings\n            // use a ResizeArray that is filled here, so this enumeration must be finished\n            // before the user can enumerate any of the groupings.\n            [|\n                let t = Dictionary<'K, ResizeArray<'E>>(comparer)\n                for x in this do\n                    let k = keySelector.Invoke x\n                    let e = elementSelector.Invoke x\n                    match t.TryGetValue k with\n                    | true, a -> a.Add(e)\n                    | false, _ ->\n                        let a = ResizeArray<'E>()\n                        a.Add(e)\n                        t.[k] <- a\n                        yield Grouping(k, a) :> IGrouping<_,_>\n            |] :> _\n        )\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), resultSelector, comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, comparer)\n        |> Seq.map (fun g -> resultSelector.Invoke(g.Key, g))\n\n    [<Inline>]\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>) : seq<'R> =\n        LinqProxy.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            a |> Array.iteri (fun i (o, is) ->\n                a.[i] <- As (resultSelector.Invoke(o, is)))\n            As a\n        )\n\n    [<Inline>]\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Intersect(this, second, EqualityComparer.Default)\n\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let t1 = HashSet(this, comparer)\n        seq {\n            let t2 = HashSet(comparer)\n            for x in second do\n                if t1.Contains(x) && t2.Add(x) then\n                    yield x\n        }\n\n    [<Inline>]\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>) : IEnumerable<'R> =\n        LinqProxy.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>, comparer: IEqualityComparer<'K>) : IEnumerable<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            [|\n                for (o, is) in a do\n                    for i in is do\n                        yield resultSelector.Invoke(o, i)\n            |] :> _\n        )\n\n    [<Inline>]\n    static member Last<'T>(this: seq<'T>) : 'T =\n        Seq.last this\n\n    static member LastPred(this: seq<'T>, predicate: Func<'T, bool>) : option<'T> =\n        (None, this)\n        ||> Seq.fold (fun acc elt ->\n            if predicate.Invoke elt then Some elt else acc)\n\n    static member Last<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> invalidOp \"Sequence contains no matching element\"\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>) : 'T =\n        Enumerable.LastOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSLastOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"LastOrDefault\">]\n    static member JSLastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>) : int64 =\n        As(Enumerable.Count(this))\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int64 =\n        As(Enumerable.Count(this, predicate))\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<float>) : float =\n        Seq.max this\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<int64>) : int64 =\n        Seq.max this\n\n    static member Max(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.max s)\n\n    [<Inline>]\n    static member Max(this: seq<int>) : int =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<float>) : float =\n        Seq.min this\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<int64>) : int64 =\n        Seq.min this\n\n    static member Min(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.min s)\n\n    [<Inline>]\n    static member Min(this: seq<int>) : int =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member OfType<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast<'T> this\n\n    [<Inline>]\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderBy(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ProjectionComparer(comparer, keySelector)) :> _\n\n    [<Inline>]\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderByDescending(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ReverseComparer(comparer, keySelector)) :> _\n\n    static member Range(start: int, count: int) : seq<int> =\n        Seq.init count ((+) start)\n\n    static member Repeat<'T>(element: 'T, count: int) : seq<'T> =\n        Seq.init count (fun _ -> element)\n\n    static member Reverse<'T>(this: seq<'T>) : seq<'T> =\n        Array.rev (Array.ofSeq this) :> _\n\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, int, 'R>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this\n\n    [<Inline>]\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, 'R>) : seq<'R> =\n        Seq.map selector.Invoke this\n\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'R>>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this |> Seq.concat\n\n    [<Inline>]\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, seq<'R>>) : seq<'R> =\n        Seq.collect selector.Invoke this\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.map (fun t -> t, selector.Invoke t)\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.mapi (fun i t -> t, selector.Invoke(t, i))\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    [<Inline>]\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>) : bool =\n        LinqProxy.SequenceEqual(this, second, EqualityComparer.Default)\n\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : bool =\n        use e1 = this.GetEnumerator()\n        use e2 = this.GetEnumerator()\n        let rec go() =\n            if e1.MoveNext() then\n                e2.MoveNext() && comparer.Equals(e1.Current, e2.Current) && go()\n            else\n                not (e2.MoveNext())\n        go()\n\n    [<Inline>]\n    static member Single<'T>(this: seq<'T>) : 'T =\n        Seq.exactlyOne this\n\n    static member Single<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        let x =\n            (None, this)\n            ||> Seq.fold (fun state cur ->\n                if predicate.Invoke cur then\n                    if state.IsSome then\n                        invalidOp \"Sequence contains more than one matching element\"\n                    else Some cur\n                else state\n            )\n        match x with\n        | None -> invalidOp \"Sequence contains no elements\"\n        | Some x -> x\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.SingleOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSSingleOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"SingleOrDefault\">]\n    static member JSSingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        let mutable found = None\n        while e.MoveNext() do\n            if predicate.Invoke e.Current then\n                match found with\n                | None -> found <- Some e.Current\n                | Some _ -> invalidOp \"Sequence contains more than one element\"\n        match found with\n        | Some x -> x\n        | None -> defaultValue\n\n    static member Skip<'T>(this: seq<'T>, count: int) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do i <- i + 1\n            while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    i <- i + 1\n                else\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if not (predicate.Invoke e.Current) then\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    [<Inline>]\n    static member Sum(this: seq<int64>) : int64 =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<float>) : float =\n        Seq.sum this\n\n    static member Sum(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.sum s)\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<int>) : int =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    static member Take<'T>(this: seq<'T>, count: int) =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() && predicate.Invoke(e.Current, i) do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            while e.MoveNext() && predicate.Invoke(e.Current) do\n                yield e.Current\n        }\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, false)\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, false)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, true)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, true)\n\n    [<Inline>]\n    static member ToArray<'T>(this: seq<'T>) : 'T[] =\n        Seq.toArray this\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>) : Dictionary<'K, 'T> =\n        LinqProxy.ToDictionary(this, keySelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'T> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, x)) this\n        d\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : Dictionary<'K, 'E> =\n        LinqProxy.ToDictionary(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'E> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, elementSelector.Invoke x)) this\n        d\n\n    [<Inline>]\n    static member ToList<'T>(this: seq<'T>) : List<'T> =\n        List<'T>(this)\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), comparer) :> _\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, comparer) :> _\n\n    [<Inline>]\n    static member Union<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Union(this, second, EqualityComparer<'T>.Default)\n\n    static member Union<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for e in second do tbl.Add(e) |> ignore\n        tbl :> _\n\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    yield e.Current\n                i <- i + 1\n        }\n\n    [<Inline>]\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        Seq.filter predicate.Invoke this\n\n    [<Inline>]\n    static member Zip<'T, 'U, 'R>(this: seq<'T>, second: seq<'U>, resultSelector: Func<'T, 'U, 'R>) : seq<'R> =\n        Seq.map2 (fun x y -> resultSelector.Invoke(x, y)) this second\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\nopen FSharp.Quotations\n\nopen FSharp.Linq\n\n[<Proxy(typeof<QuerySource<_,_>>)>]\ntype internal QuerySourceProxy<'T, 'Q> [<Inline \"$source\">] (source: IEnumerable<'T>) =\n\n    [<Inline \"$this\">]\n    member this.Source = source\n                                \n[<Proxy(typeof<QueryBuilder>)>]\n[<Name \"WebSharper.Query\">]\ntype internal QueryBuilderProxy() =\n    [<Inline>]\n    member this.All(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.forall predicate source.Source\n\n    [<Inline>]\n    member inline this.AverageBy\n            (source: QuerySource<'T, 'Q>, projection: 'T -> ^Value) =\n        Seq.averageBy projection source.Source\n\n    [<Name \"averageByNullable\">]\n    static member inline AverageByNullableImpl \n            (source: QuerySource<'T, 'Q>, projection: 'T -> Nullable< ^TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        if filtered.Length = 0 then Nullable() else Nullable(Array.average filtered) \n\n    [<Inline>]\n    member inline this.AverageByNullable (source, projection) = QueryBuilderProxy.AverageByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Contains(source: QuerySource<'T, 'Q>, key: 'T) =\n        Seq.contains key source.Source\n\n    [<Inline>]\n    member this.Count(source: QuerySource<'T, 'Q>) =\n        Seq.length source.Source\n\n    [<Inline>]\n    member this.Distinct(source: QuerySource<'T, 'Q>) =\n        Seq.distinct source.Source |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ExactlyOne(source: QuerySource<'T, 'Q>) =\n        Seq.exactlyOne source.Source\n     \n    [<Inline>]\n    member this.ExactlyOneOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.SingleOrDefault()\n\n    [<Inline>]\n    member this.Exists(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.exists predicate source.Source\n     \n    [<Inline>]\n    member this.Find(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.find predicate source.Source\n\n    [<Inline>]\n    member this.For(source: QuerySource<'T, 'Q>, body: 'T -> QuerySource<'TResult, 'Q2>) =\n        Seq.collect (fun x -> (body x).Source) source.Source |> QuerySource<'TResult, 'Q>\n     \n    [<Inline>]\n    member this.GroupBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy(fun x -> keySelector x) |> QuerySource<IGrouping<'TKey, 'T>, 'Q>\n\n    [<Inline>]\n    member this.GroupJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.GroupValBy<'T, 'TKey, 'TValue, 'Q>(source: QuerySource<'T, 'Q>, resultSelector: 'T -> 'TValue, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy((fun x -> keySelector x), (fun x -> resultSelector x)) |> QuerySource<IGrouping<'TKey, 'TValue>, 'Q>\n\n    [<Inline>]\n    member this.Head(source: QuerySource<'T, 'Q>) =\n        Seq.head source.Source\n\n    [<Inline>]\n    member this.HeadOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.FirstOrDefault()\n    \n    [<Inline>]\n    member this.Join\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> 'TInner -> 'TResult\n      ) =\n        outerSource.Source.Join(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Last(source: QuerySource<'T, 'Q>) =\n        Seq.last source.Source\n \n    [<Inline>]\n    member this.LastOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.LastOrDefault()\n\n    [<Inline>]\n    member this.LeftOuterJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x (y.DefaultIfEmpty()))\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.MaxBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Max(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MaxByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Max(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.MinBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Min(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MinByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Min(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.Nth(source: QuerySource<'T, 'Q>, index: int) =\n        Seq.item index source.Source\n\n    [<Inline>]\n    member this.Quote(q: Expr<'T>) = q\n\n    [<Inline>]\n    member this.Run(q: Expr<QuerySource<'T, IQueryable>>) =\n        (As<QuerySource<'T, obj>> q).Source |> As<IQueryable<'T>>      \n           \n    [<Inline>]\n    member this.Select(source: QuerySource<'T, 'Q>, projection: 'T -> 'TResult) =\n        source.Source |> Seq.map projection |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Skip(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Skip(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SkipWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.SkipWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    [<Inline>]\n    member this.SortBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Source(source: seq<'T>) = \n        QuerySource<'T,  System.Collections.IEnumerable>(source)\n\n    [<Inline>]\n    member this.Source(source: IQueryable<'T>) = \n        QuerySource<'T, 'Q>(source)\n\n    [<Inline>]                                                              \n    member inline this.SumBy(source: QuerySource<'T, 'Q>, projection: 'T -> ^TValue) =\n        Seq.sumBy projection source.Source\n\n    [<Name \"sumByNullable\">]                                                              \n    static member inline SumByNullableImpl(source: QuerySource<'T, 'Q>, projection: 'T -> Nullable<'TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        Nullable(Array.sum filtered) \n\n    [<Inline>]\n    member inline this.SumByNullable(source, projection) = QueryBuilderProxy.SumByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Take(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Take(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.TakeWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.TakeWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    static member CheckThenBySource(source: IEnumerable<'T>) =\n        match source with\n        | :? IOrderedEnumerable<'T> as e ->\n            e\n        | _ ->\n            failwith \"'thenBy' and 'thenByDescending' may only be used with an ordered input\"\n\n    [<Inline>]\n    member this.ThenBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Where(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.Where(fun x -> predicate x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Yield(value: 'T) =\n        Seq.singleton value |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.YieldFrom(computation: QuerySource<'T, 'Q>) =\n        computation\n    \n    [<Inline>]\n    member this.Zero() =\n        Seq.empty |> QuerySource<'T, 'Q>\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Core.ExtraTopLevelOperators, FSharp.Core\">]\nmodule internal ExtraTopLevelOperatorsQueryProxy =\n    \n    [<Inline \"null\">]\n    let query = query\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority, FSharp.Core\">]\nmodule internal HighPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsEnumerable (this: QueryBuilder) (q: Expr<QuerySource<'T, IEnumerable>>) =\n        (As<QuerySource<'T, IEnumerable>> q).Source   \n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority, FSharp.Core\">]\nmodule internal LowPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsValue (this: QueryBuilder) (q: Expr<'T>) =\n        As<'T> q\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.JavaScript\n\nopen System\nopen System.Runtime.CompilerServices\nopen System.Threading.Tasks\nopen WebSharper\n\n[<JavaScript>]\ntype NonStandardPromiseRejectionException(reason: obj) =\n    inherit Exception(\"Promise rejected\")\n\n    member this.Reason = reason\n\n[<JavaScript>]\nmodule Promise =\n\n    let private unwrapExn (x: obj) : exn =\n        match x with\n        | :? exn as e -> e\n        | x -> NonStandardPromiseRejectionException x :> exn\n\n    let OfAsync (a: Async<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            Async.StartWithContinuations(a, resolve, reject, reject)\n        )\n\n    let OfTask (t: Task<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            t.ContinueWith(fun (t: Task<'T>) ->\n                if t.IsCanceled then\n                    reject (TaskCanceledException())\n                elif t.IsFaulted then\n                    reject t.Exception\n                else // RanToCompletion\n                    resolve t.Result\n            )\n            |> ignore\n        )\n\n    let AsAsync (p: Promise<'T>) : Async<'T> =\n        Async.FromContinuations(fun (ok, ko, _) ->\n            p.Then(ok, fun (err: obj) ->\n                ko (unwrapExn err)\n            )\n            |> ignore\n        )\n\n    let AsTask (p: Promise<'T>) : Task<'T> =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n        p.Then(tcs.SetResult, fun (err: obj) ->\n            tcs.SetException(unwrapExn err)\n        )\n        |> ignore\n        tcs.Task\n\n    let private For (xs: seq<'T>) (f: 'T -> Promise<unit>) : Promise<unit> =\n        let e = xs.GetEnumerator()\n        let rec run() : Promise<unit> =\n            if e.MoveNext() then\n               (f e.Current).Then<unit>(run)\n            else\n                Promise.Resolve(())\n        // Call run() in a Promise rather than immediately,\n        // or .Finally wouldn't catch an exception when enumerating the first item.\n        Promise<unit>(fun (resolve, reject) -> resolve (unbox<unit>(run())))\n            .Finally(fun () -> e.Dispose())\n\n    type Builder [<Inline \"null\">] internal () =\n\n        [<Inline>]\n        member this.Bind(p: Promise<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            p.Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Async<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfAsync a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Task<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfTask a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Return(x: 'T) : Promise<'T> =\n            Promise<'T>.Resolve(x)\n\n        [<Inline>]\n        member this.ReturnFrom(x: Promise<'T>) : Promise<'T> =\n            x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Async<'T>) : Promise<'T> =\n            OfAsync x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Task<'T>) : Promise<'T> =\n            OfTask x\n\n        [<Inline>]\n        member this.Using(x: 'T when 'T :> IDisposable, f: 'T -> Promise<'U>) : Promise<'U> =\n            Promise(fun (resolve, reject) -> resolve (unbox<'U> (f x)))\n                .Finally(fun () -> x.Dispose())\n\n        [<Inline>]\n        member this.For(xs: seq<'T>, f: 'T -> Promise<unit>) : Promise<unit> =\n            For xs f\n\n        [<Inline>]\n        member this.Zero() : Promise<unit> =\n            Promise.Resolve(())\n\n        [<Inline>]\n        member this.Combine(p1: Promise<'T>, p2: Promise<'T>) : Promise<'T> =\n            p1.Then<'T>(fun _ -> p2)\n\n        [<Inline>]\n        member this.TryWith(p: Promise<'T>, f: exn -> Promise<'T>) : Promise<'T> =\n            p.Catch<'T>(unwrapExn >> f)\n\n        [<Inline>]\n        member this.TryFinally(p: Promise<'T>, f: unit -> unit) : Promise<'T> =\n            p.Finally(fun () -> f())\n\n        [<Inline>]\n        member this.Delay(f: unit -> Promise<'T>) : Promise<'T> =\n            Promise<'T>(fun (resolve, _) -> resolve (unbox<'T> (f())))\n\n    [<Inline>]\n    let Do = Builder()\n\n[<Extension; JavaScript>]\ntype PromiseExtensions =\n\n    [<Extension; Inline>]\n    static member AsAsync this = Promise.AsAsync this\n\n    [<Extension; Inline>]\n    static member AsTask this = Promise.AsTask this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfAsync this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfTask this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines operators and functions that are automatically available whenever\n/// `WebSharper` is open.\n[<AutoOpen>]\nmodule WebSharper.JavaScript.Pervasives\n\nopen WebSharper\nmodule M = WebSharper.Core.Macros\n\n/// Casts an object to the desired type.\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"$x * $y\">]\nlet ( *. ) x y = X<obj>\n\n[<Inline \"$x / $y\">]\nlet ( /. ) x y = X<obj>\n\n[<Inline \"$x % $y\">]\nlet ( %. ) x y = X<obj>\n\n[<Inline \"$x + $y\">]\nlet ( +. ) x y = X<obj>\n\n[<Inline \"$x - $y\">]\nlet ( -. ) x y = X<obj>\n\n[<Inline \"$x << $y\">]\nlet ( <<. ) x y = X<obj>\n\n[<Inline \"$x >> $y\">]\nlet ( >>. ) x y = X<obj>\n\n[<Inline \"$x >>> $y\">]\nlet ( >>>. ) x y = X<obj>\n\n[<Inline \"$x < $y\">]\nlet ( <. ) x y = X<bool>\n\n[<Inline \"$x > $y\">]\nlet ( >. ) x y = X<bool>\n\n[<Inline \"$x >= $y\">]\nlet ( >=. ) x y = X<bool>\n\n[<Inline \"$x <= $y\">]\nlet ( <=. ) x y = X<bool>\n\n[<Inline \"$x == $y\">]\nlet ( ==. ) x y = X<bool>\n\n[<Inline \"$x === $y\">]\nlet ( ===. ) x y = X<bool>\n\n[<Inline \"$x != $y\">]\nlet ( !=. ) x y = X<bool>\n\n[<Inline \"$x !== $y\">]\nlet ( !==. ) x y = X<bool>\n\n[<Inline \"$x | $y\">]\nlet ( |. ) x y = X<obj>\n\n[<Inline \"$x & $y\">]\nlet ( &. ) x y = X<obj>\n\n[<Inline \"$x ^ $y\">]\nlet ( ^. ) x y = X<obj>\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"[$x,$y]\">]\nlet ( => ) (x: string) (y: obj) = (x, y)\n\n[<JavaScript>]\nlet private NewFromSeq<'T> (fields: seq<string * obj>) : 'T =\n    let r = JS.Inline \"{}\"\n    for (k, v) in fields do\n        (?<-) r k v\n    As r\n\n/// Constructs a new object as if an object literal was used.\n[<Macro(typeof<M.New>); Inline>]\nlet New<'T> (fields: seq<string * obj>) = NewFromSeq<'T> fields\n\n/// Constructs an proxy to a remote object instance.\n[<Constant null>]\nlet Remote<'T> = X<'T>\n\n/// Gets JavaScript properties in sequence dynamically from an object.\n[<JavaScript; Macro(typeof<M.GetJS>)>]\nlet GetJS<'T> (x: obj) (items: seq<string>) =\n    let mutable x = x\n    for i in items do\n        x <- x?(i)\n    As<'T> x    \n\n/// Erases generic parameters inside this expression during WebSharper translation.\n/// You can get use this to translate `defaultof` inside a generic function.\n[<Macro(typeof<M.DefaultToUndefined>)>]\nlet DefaultToUndefined<'T> (x: 'T) = x\n\nmodule Optional =\n    /// Converts an F# option value to a JavaScript erased option\n    [<Inline>]\n    let ofOption x =\n        match x with\n        | None -> Undefined\n        | Some v -> Defined v\n\n    /// Converts a JavaScript erased option to an F# option value\n    [<Inline>]\n    let toOption x =\n        match x with\n        | Undefined -> None\n        | Defined v -> Some v\n\n    [<Inline \"$x !== undefined\">]\n    let isDefined x =\n        match x with\n        | Undefined -> false\n        | Defined _ -> true\n\n    [<Inline \"$x === undefined\">]\n    let isUndefined x =\n        match x with\n        | Undefined -> true\n        | Defined _ -> false\n\nmodule Union =\n// {{ generated by genInterop.fsx, do not modify\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice2 (x: Choice<'T1, 'T2>) = X<Union<'T1, 'T2>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice2 x =\n        match x with\n        | Union1Of2 v -> Choice1Of2 v\n        | Union2Of2 v -> Choice2Of2 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice3 (x: Choice<'T1, 'T2, 'T3>) = X<Union<'T1, 'T2, 'T3>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice3 x =\n        match x with\n        | Union1Of3 v -> Choice1Of3 v\n        | Union2Of3 v -> Choice2Of3 v\n        | Union3Of3 v -> Choice3Of3 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice4 (x: Choice<'T1, 'T2, 'T3, 'T4>) = X<Union<'T1, 'T2, 'T3, 'T4>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice4 x =\n        match x with\n        | Union1Of4 v -> Choice1Of4 v\n        | Union2Of4 v -> Choice2Of4 v\n        | Union3Of4 v -> Choice3Of4 v\n        | Union4Of4 v -> Choice4Of4 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice5 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice5 x =\n        match x with\n        | Union1Of5 v -> Choice1Of5 v\n        | Union2Of5 v -> Choice2Of5 v\n        | Union3Of5 v -> Choice3Of5 v\n        | Union4Of5 v -> Choice4Of5 v\n        | Union5Of5 v -> Choice5Of5 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice6 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice6 x =\n        match x with\n        | Union1Of6 v -> Choice1Of6 v\n        | Union2Of6 v -> Choice2Of6 v\n        | Union3Of6 v -> Choice3Of6 v\n        | Union4Of6 v -> Choice4Of6 v\n        | Union5Of6 v -> Choice5Of6 v\n        | Union6Of6 v -> Choice6Of6 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice7 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice7 x =\n        match x with\n        | Union1Of7 v -> Choice1Of7 v\n        | Union2Of7 v -> Choice2Of7 v\n        | Union3Of7 v -> Choice3Of7 v\n        | Union4Of7 v -> Choice4Of7 v\n        | Union5Of7 v -> Choice5Of7 v\n        | Union6Of7 v -> Choice6Of7 v\n        | Union7Of7 v -> Choice7Of7 v\n// }}\n\n/// The computation expression for JavaScript Promises.\n[<Inline>]\nlet promise = Promise.Builder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen WebSharper.JavaScript\nmodule Js = WebSharper.Core.Json\nmodule Re = WebSharper.Core.Resources\n\ntype Resource() =\n    interface Re.IResource with\n        member this.Render ctx =\n            let name = if ctx.DebuggingEnabled then \"Json.js\" else \"Json.min.js\"\n            let ren = Re.Rendering.GetWebResourceRendering(ctx, typeof<Resource>, name)\n            fun html ->\n                let html = html Re.Scripts\n                html.WriteLine \"<!--[if lte IE 7.0]>\"\n                ren.Emit(html, Re.Js)\n                html.WriteLine \"<![endif]-->\"\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"JSON.parse($json)\">]\n[<Require(typeof<Resource>)>]\nlet Parse (json: string) = X<obj>\n\n[<Inline \"JSON.stringify($obj)\">]\n[<Require(typeof<Resource>)>]\nlet Stringify (obj: obj) = X<string>\n\n/// Lookups an object by its FQN.\n[<JavaScript>]\nlet lookup<'T> (x: string []) : obj =\n    let k = x.Length\n    let mutable r = JS.Global\n    let mutable i = 0\n    while i < k do\n        let n  = x.[i]\n        let rn = (?) r n\n        if JS.TypeOf rn <> JS.Undefined then\n            r <- rn\n            i <- i + 1\n        else\n            failwith (\"Invalid server reply. Failed to find type: \" + n)\n    r\n\n/// Does a shallow generic mapping over an object.\n[<JavaScript>]\nlet shallowMap (f: obj -> obj) (x: obj) : obj =\n    if x :? System.Array then\n        As (Array.map f (As x))\n    else\n        match JS.TypeOf x with\n        | JS.Object ->\n            let r = New []\n            JS.ForEach x (fun y -> (?<-) r y (f ((?) x y)); false)\n            r\n        | _ ->\n            x\n\ntype SpecialTypes =\n    | List = 1\n    | Decimal = 2\n\n[<JavaScript>]\n[<Require(typeof<Resource>)>]\nlet Activate<'T> (json: obj) : 'T =\n    let types = if As json then json?(\"$TYPES\") : obj[] else JS.Undefined\n    let data =\n        if types ===. JS.Undefined then\n            json\n        else\n            for i = 0 to types.Length - 1 do\n                types.[i] <- \n                    match As<string[]> types.[i] with\n                    | [| \"WebSharper\"; \"List\"; \"T\" |] -> box SpecialTypes.List\n                    | [| \"WebSharper\"; \"Decimal\" |] -> box SpecialTypes.Decimal\n                    | t -> lookup t\n            json?(\"$DATA\")\n    let rec decode (x: obj) : obj =\n        if x = null then x else\n            match JS.TypeOf x with\n            | JS.Object ->\n                if x :? System.Array then\n                    shallowMap decode x\n                else\n                    let o  = shallowMap decode (x?(\"$V\"))\n                    let ti = x?(\"$T\")\n                    if ti ===. JS.Undefined then o else\n                        let t = types.[ti]\n                        if t ===. SpecialTypes.List then\n                            box (List.ofArray (As<obj[]> o))\n                        elif t ===. SpecialTypes.Decimal then\n                            box (JS.Global?WebSharper?Decimal?CreateDecimalBits(o))\n                        else\n                            let r = JS.New types.[ti]\n                            JS.ForEach o (fun k -> (?<-) r k ((?) o k); false)\n                            r\n            | _ ->\n                x\n    As (decode data)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Remoting\n\nopen WebSharper.JavaScript\n\nmodule R = WebSharper.Core.Remoting\n\n[<JavaScript>]\nlet mutable EndPoint = \"?\"\n\n[<JavaScript>]\nlet UseHttps() =\n    try\n        if not (JS.Window.Location.Href.StartsWith \"https://\") then\n            EndPoint <- JS.Window.Location.Href.Replace(\"http://\", \"https://\")\n            true\n        else false\n    with _ ->\n        // This function is intended to be callable from the top-level in a module,\n        // which means that it will be (unnecessarily) called on the server too\n        // and throw NotImplementedException. Just silence it.\n        false\n\ntype Data = string\ntype Headers = obj\ntype Url = string\n\n[<JavaScript>]\ntype IAjaxProvider =\n    [<Name \"Async\">]\n    abstract member Async : Url -> Headers -> Data -> (Data -> unit) -> (exn -> unit) -> unit\n\n    [<Name \"Sync\">]\n    abstract member Sync : Url -> Headers -> Data -> Data\n\n[<Direct @\"\n    var xhr = new XMLHttpRequest();\n    var csrf = document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*csrftoken\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1');\n    xhr.open('POST', $url, $async);\n    if ($async == true) {\n        xhr.withCredentials = true;\n    }\n    for (var h in $headers) {\n        xhr.setRequestHeader(h, $headers[h]);\n    }\n    if (csrf) {\n        xhr.setRequestHeader('x-csrftoken', csrf);\n    }\n    function k() {\n        if (xhr.status == 200) {\n            $ok(xhr.responseText)\n        } else if ($csrf && xhr.status == 403 && xhr.responseText == 'CSRF') {\n            $csrf();\n        } else {\n            var msg = 'Response status is not 200: ';\n            $err(new Error(msg + xhr.status));\n        }\n    }\n    if ('onload' in xhr) {\n        xhr.onload = xhr.onerror = xhr.onabort = k;\n    } else {\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                k();\n            }\n        };\n    }\n    xhr.send($data);\n\">]\nlet private ajax (async: bool) (url: Url) (headers: Headers) (data: Data)\n    (ok: Data -> unit) (err: exn -> unit) (csrf: unit -> unit) = ()\n\ntype XhrProvider [<JavaScript>] () =\n    interface IAjaxProvider with\n\n        [<JavaScript>]\n        member this.Async url headers data ok err =\n            ajax true url headers data ok err\n                (fun () -> ajax true url headers data ok err JS.Undefined)\n\n        [<JavaScript>]\n        member this.Sync url headers data =\n            let res = ref Unchecked.defaultof<_>\n            ajax false url headers data\n                (fun x -> res := x)\n                (fun e -> raise e)\n                (fun () ->\n                    ajax false url headers data\n                        (fun x -> res := x)\n                        (fun e -> raise e)\n                        JS.Undefined)\n            !res\n\n[<JavaScript>]\nlet mutable AjaxProvider = XhrProvider() :> IAjaxProvider\n\n[<JavaScript>]\nlet private makeHeaders (m: string) =\n    New [\n        \"content-type\" => \"application/json\"   \n        \"x-websharper-rpc\" => m\n    ]\n\n[<JavaScript>]\nlet private makePayload (data: obj []) =\n    Json.Stringify data\n\n[<JavaScript>]\ntype IRemotingProvider =\n    [<Name \"Sync\">]\n    abstract member Sync : string -> obj[] -> obj\n    [<Name \"Async\">]\n    abstract member Async : string -> obj[] -> Async<obj>\n    [<Name \"Task\">]\n    abstract member Task : string -> obj[] -> System.Threading.Tasks.Task<obj>\n    [<Name \"Send\">]\n    abstract member Send : string -> obj[] -> unit\n\n[<JavaScript>]\n[<Name \"WebSharper.Remoting.AjaxRemotingProvider\">]\ntype AjaxRemotingProvider() =\n    abstract EndPoint : string\n    override this.EndPoint = EndPoint\n\n    abstract AsyncBase : string * obj[] -> Async<obj> \n    override this.AsyncBase(m, data) = \n        async {\n            let headers = makeHeaders m\n            let payload = makePayload data\n            let! token = Async.CancellationToken\n            return! Async.FromContinuations (fun (ok, err, cc) ->\n                let waiting = ref true\n                let reg =\n                    token.Register(fun () ->\n                        if !waiting then\n                            waiting := false\n                            cc (new System.OperationCanceledException(token))\n                    )\n                let ok (x: Data) = \n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        ok (Json.Activate (Json.Parse x))\n                let err (e: exn) =\n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        err e\n                AjaxProvider.Async this.EndPoint headers payload ok err)\n        }\n\n    interface IRemotingProvider with\n        member this.Sync m data : obj =\n            let data = AjaxProvider.Sync this.EndPoint (makeHeaders m) (makePayload data)\n            Json.Activate (Json.Parse data)\n\n        member this.Async m data : Async<obj> =\n            this.AsyncBase(m, data)\n\n        member this.Task m data : System.Threading.Tasks.Task<obj> =\n            this.AsyncBase(m, data) |> Async.StartAsTask   \n\n        member this.Send m data =\n            Async.Start (Async.Ignore (this.AsyncBase(m, data)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nmodule M = WebSharper.Core.Metadata\nmodule J = WebSharper.Core.Json\n\n/// An interface that has to be implemented by controls\n/// that depend on resources.\ntype IRequiresResources =\n    abstract member Requires : M.Info -> seq<M.Node>\n    abstract member Encode : M.Info * J.Provider -> list<string * J.Encoded>\n\n/// HTML content that can be used as the Body of a web Control.\n/// Can be zero, one or many DOM nodes.\ntype IControlBody =\n    /// Replace the given node with the HTML content.\n    /// The node is guaranteed to be present in the DOM.\n    /// Called exactly once on startup on an IControl's Body.\n    [<JavaScript; Name \"ReplaceInDom\">]\n    abstract ReplaceInDom : Dom.Node -> unit\n\n/// An interface that has to be implemented by controls that\n/// are subject to activation, ie. server-side controls that\n/// contain client-side elements.\ntype IControl =\n    inherit IRequiresResources\n    [<JavaScript; Name \"Body\">]\n    abstract member Body : IControlBody\n    abstract member Id : string\n\n[<AutoOpen>]\nmodule HtmlContentExtensions =\n\n    [<JavaScript>]\n    type private SingleNode(node: Dom.Node) =\n        interface IControlBody with\n            member this.ReplaceInDom(old) =\n                node.ParentNode.ReplaceChild(node, old) |> ignore\n\n    [<JavaScript>]\n    type IControlBody with\n        /// Create HTML content comprised of a single DOM node.\n        static member SingleNode (node: Dom.Node) =\n            new SingleNode(node) :> IControlBody\n\n[<JavaScript>]\nmodule Activator =\n\n    /// The identifier of the meta tag holding the controls.\n    [<Literal>]\n    let META_ID = \"websharper-data\"\n\n    let mutable Instances : obj = null\n\n    let private onReady (f: unit -> unit) =\n        let mutable readyFired = false\n        let rec ready() =\n            if not readyFired then\n                readyFired <- true\n                f()\n                JS.Document.RemoveEventListener(\"DOMContentLoaded\", ready, false)\n                JS.Window.RemoveEventListener(\"load\", ready, false)\n        if JS.Document?readyState = \"complete\" then\n            ready()\n        else\n            JS.Document.AddEventListener(\"DOMContentLoaded\", ready, false)\n            JS.Window.AddEventListener(\"load\", ready, false)\n\n    let private Activate() =\n        if As JS.Document then\n            let meta = JS.Document.GetElementById(META_ID)\n            if (As meta) then\n                onReady <| fun () ->\n                    let text = meta.GetAttribute(\"content\")\n                    let obj = Json.Activate (Json.Parse text)\n                    JS.GetFields obj\n                    |> Array.iter (fun (k, v) ->\n                        match v with\n                        | :? IControl as v ->\n                            let p = v.Body\n                            let old = JS.Document.GetElementById k\n                            p.ReplaceInDom old\n                        | _ -> ()\n                    )\n                    Instances <- obj\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Comparers\n\nopen WebSharper\n\n[<JavaScript>]\ntype private EquatableEqualityComparer<'T when 'T :> System.IEquatable<'T>>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = (x :> System.IEquatable<_>).Equals(y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private BaseEqualityComparer<'T>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = obj.Equals(box x, box y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private ComparableComparer<'T when 'T :> System.IComparable<'T>>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = (x :> System.IComparable<'T>).CompareTo(y)\n\n[<JavaScript>]\ntype private BaseComparer<'T when 'T : comparison>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = compare x y\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\nmodule private WebSharper.Utils\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nlet toSafe (s: string) =\n    if s ==. null then \"\" else s  \n\n[<JavaScript>]\nlet plusForPos (n: obj, s) =\n    if 0 <=. n then \"+\" + s else s     \n\n[<JavaScript>]\nlet spaceForPos (n: obj, s) =\n    if 0 <=. n then \" \" + s else s      \n\n[<Inline \"$s.substr(1)\">]\nlet skip1 (s: string) = X<string>\n\n[<JavaScript>]\nlet padNumLeft (s: string, l) =\n    let f = (As<string[]> s).[0]\n    if f = \" \" || f = \"+\" || f = \"-\" then\n        f + (skip1 s).PadLeft(l - 1, '0')\n    else s.PadLeft(l, '0')\n\n[<JavaScript>]\nlet printList (p: obj -> string, o: obj list) =\n    \"[\" + (o |> Seq.map p |> String.concat \"; \") + \"]\" \n\n[<JavaScript>]\nlet printArray (p: obj -> string, o: obj[]) =\n    if o ===. null then \"null\" else\n    \"[|\" + (o |> Array.map p |> String.concat \"; \") + \"|]\" \n\n[<JavaScript>]\nlet printArray2D (p: obj -> string, o: obj[,]) =\n    if o ===. null then \"null\" else\n     \"[[\" + (\n        seq {\n            let l2 = Array2D.length2 o\n            for i in 0 .. Array2D.length1 o - 1 ->\n                seq { for j in 0 .. l2 - 1 -> p o.[i, j] } \n                |> String.concat \"; \"\n        }\n        |> String.concat \"][\"\n     ) + \"]]\" \n\n[<JavaScript>]\nlet rec prettyPrint (o: obj) =\n    let printObject (o: obj) =\n        let s = string o\n        if s = \"[object Object]\" then\n            \"{\" + (JS.GetFields o |> Array.map (fun (k, v) -> k + \" = \" + prettyPrint v) |> String.concat \"; \") + \"}\"\n        else s\n    if o ===. null then \"null\" else\n    let t = JS.TypeOf o\n    if t  ==. JS.String then\n        \"\\\"\" + As o + \"\\\"\"\n    elif t  ==. JS.Object then\n        if o :? System.Array then\n            \"[|\" + (As o |> Array.map prettyPrint |> String.concat \"; \") + \"|]\"\n        else printObject o\n    else string o\n\n[<JavaScript>]\n[<Name \"WebSharper.Operators.charRange\">]\nlet charRange (min: char) (max: char) : seq<char> =\n    let minv = int min\n    let count = 1 + int max - minv\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> char (x + minv))\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.op\">]\nlet nullableOp (a: obj) (b: obj) f = if a ==. null || b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opL\">]\nlet nullableOpL (a: obj) (b: obj) f = if a ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opR\">]\nlet nullableOpR (a: obj) (b: obj) f = if b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmp\">]\nlet nullableCmp (a: obj) (b: obj) f = if a ==. null || b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpE\">]\nlet nullableCmpE (a: obj) (b: obj) f =\n    if a ==. null then\n        b ==. null\n    elif b ==. null then \n        false \n    else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpL\">]\nlet nullableCmpL (a: obj) (b: obj) f = if a ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpR\">]\nlet nullableCmpR (a: obj) (b: obj) f = if b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.conv\">]\nlet nullableConv (a: obj) f = if a ==. null then null else f a", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements concurrency primitives.\nmodule internal WebSharper.Concurrency\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype private OCE = System.OperationCanceledException\n\n[<JavaScript; Prototype false>]\ntype Result<'T> =\n    | Ok of 'T\n    | No of exn\n    | Cc of OCE\n  \n[<JavaScript; Prototype false>]\ntype CT =\n    { \n        [<Name \"c\">] mutable IsCancellationRequested : bool \n        [<Name \"r\">] Registrations : (unit -> unit)[]\n    }\n\n[<Inline \"$arr.push($item)\">]\nlet private push arr item = X<int>\n\n[<JavaScript>]\nlet internal noneCT =           \n    { \n        IsCancellationRequested = false\n        Registrations = [||]\n    }\n\n[<JavaScript>]\nlet internal Register (ct: CT) (callback: unit -> unit) =\n    if ct ===. noneCT then\n        { new System.IDisposable with\n            member this.Dispose() = ()\n        }\n    else\n        let i = push ct.Registrations callback - 1\n        { new System.IDisposable with\n            member this.Dispose() = ct.Registrations.[i] <- ignore\n        }\n\n[<JavaScript; Prototype false>]\ntype AsyncBody<'T> =\n    {\n        k  : Result<'T> -> unit\n        ct : CT\n    }\n\ntype Concurrent<'T>     = AsyncBody<'T> -> unit\nand private C<'T>       = Concurrent<'T>\n\ntype private Queue<'T>  = System.Collections.Generic.Queue<'T>\ntype Milliseconds       = int\n\ntype private Scheduler [<JavaScript>]() =\n    let mutable idle    = true\n    let robin           = Queue<unit->unit>()\n\n    [<JavaScript>]\n    let rec tick () =\n        let t = System.DateTime.Now\n        let mutable loop = true\n        while loop do\n            match robin.Count with\n            | 0 ->\n                idle <- true\n                loop <- false\n            | _ ->\n                robin.Dequeue()()\n                if System.DateTime.Now - t > System.TimeSpan.FromMilliseconds 40. then\n                    JS.SetTimeout tick 0 |> ignore\n                    loop <- false\n\n    [<JavaScript>]\n    member this.Fork(action: unit -> unit) =\n        robin.Enqueue action\n        if idle then\n            idle <- false\n            JS.SetTimeout tick 0 |> ignore\n\n[<JavaScript>]\nlet private scheduler = Scheduler()\n\n[<JavaScript>]\nlet internal defCTS = ref(new System.Threading.CancellationTokenSource())\n\n[<Inline>]\nlet fork action = scheduler.Fork action\n\n[<JavaScript>]\nlet private cancel c = c.k (Cc (new OCE(As<System.Threading.CancellationToken> c.ct)))\n\n[<JavaScript>]\nlet private checkCancel r =\n    ()\n    fun c -> if c.ct.IsCancellationRequested then cancel c else r c\n\n[<JavaScript; Pure>]\nlet Return (x: 'T) : C<'T> =\n    ()\n    fun c -> c.k (Ok x)\n\n[<JavaScript; Pure>]\nlet Zero =\n    Return ()\n\n[<JavaScript; Pure>]\nlet Bind (r: C<'T>, f: 'T -> C<'R>) =\n    checkCancel <| fun c ->\n        r { \n            k = function \n                | Ok x -> fork (fun () -> try f x c with e -> c.k (No e))\n                | res  -> fork (fun () -> c.k (As res)) // error or cancellation\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Combine (a: C<unit>, b: C<'T>) : C<'T> = \n    Bind (a, fun _ -> b)\n\n[<Inline>]\nlet Ignore (r: C<'T>): C<unit> = As<C<unit>> r\n\n[<JavaScript; Pure>]\nlet Delay (mk: unit -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        try mk () c with e -> c.k (No e)\n\n[<JavaScript; Pure>]\nlet TryFinally (run: C<'T>, f: unit -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = fun r -> \n                try f ()\n                    c.k r \n                with e -> c.k (No e)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet TryWith (r: C<'T>, f: exn -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        r {\n            k = function\n                | Ok x -> c.k (Ok x)\n                | No e as res -> try f e c with e -> c.k (As res)\n                | res -> c.k (As res)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Catch (r : C<'T>) : C<Choice<'T, exn>> =\n    ()\n    fun c ->\n        try r {\n                k = function \n                    | Ok x -> c.k (Ok (Choice1Of2 x))\n                    | No e -> c.k (Ok (Choice2Of2 e))\n                    | res  -> c.k (As res)\n                ct = c.ct\n            }\n        with e -> c.k (Ok (Choice2Of2 e))\n\n[<JavaScript; Pure>]\nlet GetCT : C<CT> =\n    ()\n    fun c -> c.k (Ok c.ct)\n\n[<JavaScript; Pure>]\nlet FromContinuations (subscribe: ('T -> unit) * (exn -> unit) * (OCE -> unit) -> unit) : C<'T> =\n    ()\n    fun c ->\n        let continued = ref false\n        let once cont : unit =\n            if !continued then failwith \"A continuation provided by Async.FromContinuations was invoked multiple times\" else\n            continued := true\n            fork cont   \n        subscribe (\n            fun a -> once (fun () -> c.k (Ok a))\n        ,   fun e -> once (fun () -> c.k (No e))\n        ,   fun e -> once (fun () -> c.k (Cc e))\n        )\n\n[<JavaScript>]\nlet StartWithContinuations (c: C<'T>, s: 'T -> unit, f: exn -> unit, cc: OCE -> unit, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | Ok x -> s x\n                | No e -> f e\n                | Cc e -> cc e\n            ct = ct\n        }\n\n[<JavaScript>]\nlet UncaughtAsyncError (e: exn) =\n    Console.Log (\"WebSharper: Uncaught asynchronous exception\", e)\n\n[<JavaScript>]\nlet Start (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    fork (fun () -> \n        if not ct.IsCancellationRequested then\n            c {\n                k = function\n                    | No e -> UncaughtAsyncError e\n                    | _ -> ()\n                ct = ct\n            }\n    )\n\n[<JavaScript>]\nlet StartImmediate (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | No e -> UncaughtAsyncError e\n                | _ -> ()\n            ct = ct\n        }\n\n#nowarn \"40\"\n\n[<JavaScript; Pure>]\nlet AwaitEvent (e: IEvent<'T>, ca: option<unit -> unit>) : C<'T> =\n    ()\n    fun c ->\n        let mutable sub = JS.Undefined<System.IDisposable>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        sub <-\n            e.Subscribe (fun x -> \n                sub.Dispose()\n                creg.Dispose()\n                fork (fun () -> c.k (Ok x))        \n            )\n        creg <-\n            Register c.ct (fun () -> \n                match ca with\n                | Some ca ->\n                    ca()\n                | _ ->\n                    sub.Dispose()\n                    fork (fun () -> cancel c)    \n            ) \n\n[<JavaScript; Pure>]\nlet AwaitTask (t: System.Threading.Tasks.Task) : C<unit> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun t ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok()   \n        ) |> ignore\n    )\n\n[<JavaScript; Pure>]\nlet AwaitTask1 (t: System.Threading.Tasks.Task<'T>) : C<'T> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun (t: System.Threading.Tasks.Task<'T>) ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok t.Result  \n        ) |> ignore\n    )\n\n[<JavaScript>]\nlet StartAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    fork (fun () ->\n        StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    )\n    tcs.Task\n\n[<JavaScript>]\nlet StartImmediateAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    tcs.Task\n\n[<JavaScript; Pure>]\nlet Sleep (ms: Milliseconds) : C<unit> =\n    ()\n    fun c ->\n        let mutable pending = JS.Undefined<JS.Handle>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        pending <-\n            JS.SetTimeout (fun () -> \n                creg.Dispose()\n                fork (fun () -> c.k (Ok ()))\n            ) ms\n        creg <-\n            Register c.ct (fun () -> \n                JS.ClearTimeout pending\n                fork (fun () -> cancel c)\n            )\n\n[<JavaScript; Pure>]\nlet Parallel (cs: seq<C<'T>>) : C<'T[]> =\n    let cs = Array.ofSeq cs\n    if cs.Length = 0 then Return [||] else\n    fun c ->\n        let n = Array.length cs\n        let o = ref n\n        let a = As<'T[]>(JavaScript.Array(n))\n        let accept i x =\n            match !o, x with\n            | 0, _     -> ()\n            | 1, Ok x  -> a.[i] <- x; o := 0; c.k (Ok a)\n            | n, Ok x  -> a.[i] <- x; o := n - 1\n            | n, res   -> o := 0; c.k (As res)\n        Array.iteri (fun i run ->\n            fork (fun () -> run { k = accept i; ct = c.ct }))\n            cs\n\n[<JavaScript; Pure>]\nlet StartChild (r : C<'T>, t: Milliseconds option) : C<C<'T>> =\n    ()\n    fun c ->\n        let inTime = ref true\n        let cached = ref None\n        let queue  = Queue()\n        let tReg =\n            match t with\n            | Some timeout ->\n                JS.SetTimeout (fun () ->\n                    inTime := false\n                    let err = No (System.TimeoutException())\n                    while queue.Count > 0 do\n                        queue.Dequeue() err\n                ) timeout |> Some     \n            | _ -> None\n        fork (fun _ ->\n            if not c.ct.IsCancellationRequested then\n                r {\n                    k = fun res ->\n                        if !inTime then\n                            cached := Some res\n                            match tReg with\n                            | Some r -> JS.ClearTimeout r\n                            | _ -> ()\n                            while queue.Count > 0 do\n                                queue.Dequeue() res\n                    ct = c.ct\n                }\n        )\n        let r2 c2 =            \n            if !inTime then\n                match cached.Value with\n                | Some x    -> c2.k x\n                | None      -> queue.Enqueue c2.k\n            else c2.k (No (System.TimeoutException()))\n        c.k (Ok r2)\n\n[<JavaScript>]\nlet StartChildAsTask (r : C<'T>) =\n    ()\n    fun c ->\n        let ch = StartChild(r, None)\n        ch {\n            k = function\n                | Ok r2 -> c.k (Ok (StartImmediateAsTask(r2, Some c.ct)))\n                | _ -> ()\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet OnCancel (action: unit -> unit) : C<System.IDisposable> =\n    ()\n    fun c -> c.k (Ok (Register c.ct action))\n\n[<JavaScript; Pure>]\nlet TryCancelled (run: C<'T>, comp: OCE -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = function\n                | Cc e as res ->\n                    comp e\n                    c.k res\n                | res -> c.k res\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Using (x: 'U, f: 'U -> C<'T>) =\n    TryFinally (f x, fun () -> (x :> System.IDisposable).Dispose())\n\n[<JavaScript; Pure>]\nlet rec While (g: unit -> bool, c: C<unit>) : C<unit> = \n    if g() then \n        Bind (c, fun () -> While (g, c)) \n    else\n        Return ()\n\n[<JavaScript; Pure>]\nlet rec For (s: seq<'T>, b: 'T -> C<unit>) =\n    Using (s.GetEnumerator(), fun ie -> \n        While ((fun () -> ie.MoveNext()), \n            Delay (fun () -> b ie.Current)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides an `IEnumerator` implementation.\nmodule private WebSharper.Enumerator\n\nopen WebSharper.JavaScript\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n/// Represents an unfolding enumerator.\n[<Sealed>]\ntype T<'S,'T> [<JavaScript>] (s: 'S, c: 'T, n: T<'S,'T> -> bool, d: T<'S,'T> -> unit) =\n    [<Inline; JavaScript>] \n    member this.MoveNext() = n this\n    member this.State with [<Inline; JavaScript>] get() = s and [<Inline; JavaScript>] set (v: 'S) = this?s <- v\n    member this.Current with [<Inline; JavaScript>] get() = c and [<Inline; JavaScript>] set (v: 'T) = this?c <- v\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = n this\n        [<JavaScript>]\n        member this.Current with get() = box c\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = c\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = if As d then d this\n\n/// Constructs a new `IEnumerator` by unfolding a function.\n[<Inline>]\n[<JavaScript>]\nlet New<'S,'T> (state: 'S) (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, As JS.Undefined)) \n\n[<Inline>]\n[<JavaScript>]\nlet NewDisposing<'S,'T> (state: 'S) dispose (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, dispose))\n\n[<Inline \"$x.GetEnumerator()\">]\nlet getEnumerator (x: obj) : IE<'T> = X\n\n[<JavaScript>]\nlet ArrayEnumerator (s: obj[]) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet StringEnumerator (s: string) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet Get (x: seq<'T>) : IE<'T> =\n    if x :? System.Array then\n        ArrayEnumerator (As x)\n    elif JS.TypeOf x = JS.String then\n        StringEnumerator (As x)\n    else\n        getEnumerator x\n\n[<Inline \"'GetEnumerator0' in $x ? $x.GetEnumerator0() : $x.GetEnumerator()\">]\nlet getEnumerator0 (x: obj) : System.Collections.IEnumerator = X\n\n[<JavaScript>]\nlet Get0 (x: System.Collections.IEnumerable) : System.Collections.IEnumerator =\n    if x :? System.Array then\n        As (ArrayEnumerator (As x))\n    elif JS.TypeOf x = JS.String then\n        As (StringEnumerator (As x))\n    else\n        getEnumerator0 x\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides seq/list/array proxies\n[<JavaScript>]\nmodule internal WebSharper.CollectionInternals\n\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Arrays.splitInto\">]\nlet ArraySplitInto count (arr: 'T[]) =\n    if count <= 0 then failwith \"Count must be positive\"\n    let len = arr.Length\n    if len = 0 then\n        [| |]\n    else\n        let count = min count len\n        let res = Array.zeroCreate count : 'T[][]\n        let minChunkSize = len / count\n        let mutable startIndex = 0\n        for i = 0 to len % count - 1 do\n            res.JS.[i] <- Array.sub arr startIndex (minChunkSize + 1)\n            startIndex <- startIndex + minChunkSize + 1\n        for i = len % count to count - 1 do\n            res.JS.[i] <-  Array.sub arr startIndex minChunkSize\n            startIndex <- startIndex + minChunkSize\n        res\n\n[<Name \"WebSharper.Arrays.contains\">]\nlet ArrayContains (item: 'T) (arr: 'T[])  =\n    let mutable c = true\n    let mutable i = 0\n    let l = arr.Length\n    while c && i < l do\n        if arr.JS.[i] = item then\n            c <- false\n        else\n            i <- i + 1\n    not c\n\n[<Name \"WebSharper.Arrays.tryFindBack\">]\nlet ArrayTryFindBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        let r = arr.JS.[i]\n        if f r then res <- Some r\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.tryFindIndexBack\">]\nlet ArrayTryFindIndexBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        if f arr.[i] then res <- Some i\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.mapFold\">]\nlet ArrayMapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) (zero: 'S) (arr: 'T[]) : 'R[] * 'S =\n    let r = JavaScript.Array(Array.length arr)\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        let a, b = f acc arr.JS.[i]\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapFoldBack\">]\nlet ArrayMapFoldBack<'T,'S,'R> (f: 'T -> 'S -> 'R * 'S) (arr: 'T[]) (zero: 'S) : 'R[] * 'S =\n    let r = JavaScript.Array<'R>(Array.length arr)\n    let mutable acc = zero\n    let len = Array.length arr\n    for j = 1 to len do\n        let i = len - j\n        let a, b = f arr.JS.[i] acc\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapInPlace\">]\nlet mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f arr.JS.[i])\n\n[<Name \"WebSharper.Arrays.mapiInPlace\">]\nlet mapiInPlace (f: int -> 'T1 -> 'T2) (arr: 'T1 []) : 'T2[] =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f i arr.JS.[i])\n    As arr\n\n[<Name \"WebSharper.Arrays.sortInPlaceByDescending\">]\nlet ArraySortInPlaceByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"WebSharper.Seq.tryHead\">]\nlet SeqTryHead (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryItem\">]\nlet SeqTryItem i (s: seq<'T>) =\n    if i < 0 then None else\n    let mutable j = 0\n    use e = Enumerator.Get s\n    let mutable go = true\n    while go && j <= i do\n        if e.MoveNext() then\n            j <- j + 1\n        else\n            go <- false\n    if go then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryLast\">]\nlet SeqTryLast (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then \n        while e.MoveNext() do ()\n        Some e.Current \n    else None\n\n[<Name \"WebSharper.Seq.chunkBySize\">]\nlet SeqChunkBySize (size: int) (s: seq<'T>) =\n    if size <= 0 then failwith \"Chunk size must be positive\"\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) <| fun e ->\n            if e.State && o.MoveNext() then\n                let res = [|o.Current|]\n                while e.State && res.Length < size do\n                    if o.MoveNext() then\n                        res.JS.Push o.Current |> ignore\n                    else \n                        e.State <- false\n                e.Current <- res\n                true\n            else false\n\n[<Name \"WebSharper.Arrays.countBy\">]\nlet ArrayCountBy (f: 'T -> 'K) (a: 'T[]) : ('K * int)[] =\n    let d = System.Collections.Generic.Dictionary<'K, int>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k] <- d.[k] + 1 \n        else\n            keys.Push(k) |> ignore\n            d.Add(k, 1)\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.except\">]\nlet SeqExcept (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet(itemsToExclude)\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"WebSharper.List.skip\">]\nlet ListSkip i (l : list<'T>) =\n    let mutable res = l\n    for j = 1 to i do\n        match res with \n        | _ :: t ->\n            res <- t\n        | [] -> failwith \"Input list too short.\"\n    res\n\n[<Name \"WebSharper.Arrays.groupBy\">]\nlet ArrayGroupBy (f: 'T -> 'K when 'K : equality) (a: 'T[]) : ('K * 'T[])[] =\n    let d = System.Collections.Generic.Dictionary<'K, 'T[]>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k].JS.Push(c) |> ignore\n        else\n            keys.Push(k) |> ignore\n            d.Add(k, [| c |])\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.insufficient\">]\nlet InsufficientElements() =\n    failwith \"The input sequence has an insufficient number of elements.\"\n\n[<Name \"WebSharper.Seq.last\">]\nlet SeqLast (s: seq<_>) =\n    use e = Enumerator.Get s\n    if not <| e.MoveNext() then InsufficientElements()\n    else \n        while e.MoveNext() do ()\n        e.Current\n\n[<Name \"WebSharper.Seq.contains\">]\nlet SeqContains (el: 'T) (s: seq<'T>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- e.Current = el\n    r\n\n[<Name \"WebSharper.List.skipWhile\">]\nlet rec ListSkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    let mutable rest = list\n    while not (List.isEmpty rest) && predicate (List.head rest) do\n        rest <- List.tail rest \n    rest\n\n[<Name \"WebSharper.Seq.nonNegative\">]\nlet InputMustBeNonNegative() =\n    failwith \"The input must be non-negative.\"\n\n[<Name \"WebSharper.Arrays.transposeArray\">]\nlet ArrayTranspose (array:'T[][]) : 'T[][] =\n    let len = array.Length\n    if len = 0 then [||] else\n    let lenInner = array.[0].Length\n\n    for j in 1..len-1 do\n        if lenInner <> array.[j].Length then\n            failwith \"The arrays have different lengths.\"\n\n    let result = Array lenInner\n    for i in 0..lenInner-1 do\n        result.[i] <- Array len\n        for j in 0..len-1 do\n            result.[i].[j] <- array.[j].[i]\n    As result", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\n#nowarn \"864\"\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.Object>)>]\n[<Name \"WebSharper.Obj\">]\ntype private ObjectProxy() =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Name \"GetHashCode\">]\n    member this.GetHashCodeImpl() = -1\n\n    [<Name \"Equals\">]\n    member this.EqualsImpl(obj: obj) = this ===. obj\n\n    [<Inline>]\n    static member Equals(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member ReferenceEquals(a: obj, b: obj) = a ===. b\n\n    [<Inline>]\n    static member op_Equality(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member op_Inequality(a: obj, b: obj) = not (Unchecked.equals a b)\n\n    [<Inline>]\n    override this.ToString() = string this\n\n[<Proxy(typeof<System.ValueType>)>]\ntype private ValueTypeProxy =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Inline>]\n    override this.ToString() = string this", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.IntrinsicFunctionProxy\n\nopen System\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$value\">]\nlet UnboxGeneric<'T> (value: obj) = X<'T>\n\n[<Inline \"$value\">]\nlet UnboxFast<'T> (value: obj) = X<'T>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestGeneric<'T> (value: obj) = X<bool>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestFast<'T> (value: obj) = X<bool>\n\n[<Inline \"$arr.length\">]\nlet GetArray2DLength1 (arr: 'T[,]) = X<int>\n\n[<Inline \"$arr.length ? $arr[0].length : 0\">]\nlet GetArray2DLength2 (arr: 'T[,]) =  X<int>\n\n[<Name \"WebSharper.Arrays.checkBounds\">]\nlet checkBounds (arr: 'T[]) (n: int) =\n    if n < 0 || n >= Array.length arr then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Name \"WebSharper.Arrays.checkBounds2D\">]\nlet checkBounds2D<'T> (arr: 'T[,]) (n1: int) (n2: int) =\n    if n1 < 0 || n2 < 0 || n1 >= GetArray2DLength1 arr\n        || n2 >= GetArray2DLength2 arr then\n        raise (new IndexOutOfRangeException())\n\n[<Name \"WebSharper.Arrays.checkRange\">]\n\nlet checkRange (arr: 'T []) (start: int) (size: int) : unit =\n    if (size < 0) || (start < 0) || (Array.length arr < start + size) then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Inline \"$arr[$n]\">]\nlet GetArrayInternal<'T> (arr: 'T[]) (n:int) = X<'T>\n\n[<Inline \"void ($arr[$n] = $x)\">]\nlet SetArrayInternal<'T> (arr: 'T[]) (n:int) (x:'T) = ()\n\n[<Name \"WebSharper.Arrays.set\">]\nlet SetArray<'T> (arr: 'T[]) (n: int) (x: 'T) =\n    checkBounds arr n\n    SetArrayInternal arr n x\n\n[<Inline \"$s[$ix]\">]\n[<Name \"WebSharper.Strings.get\">]\nlet GetString (s: string) (ix: int) = X<char>\n\n[<Name \"WebSharper.Arrays.get\">]\nlet GetArray<'T> (arr: 'T[]) (n: int) =\n    checkBounds arr n\n    GetArrayInternal arr n\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Name \"WebSharper.Arrays.sub\">]\nlet GetArraySub<'T> (arr: 'T[]) start length =\n    checkRange arr start length\n    subArray arr start length\n\n[<Name \"WebSharper.Arrays.setSub\" >]\nlet SetArraySub<'T> (arr: 'T[]) start len (src: 'T[]) =\n    for i = 0 to len - 1 do\n        arr.[start+i] <- src.[i]\n\n[<Inline \"$arr[$n1][$n2]\">]\nlet GetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) = X<'T>\n\n[<Name \"WebSharper.Arrays.get2D\" >]\nlet GetArray2D (arr: 'T[,]) (n1: int) (n2: int) =\n    checkBounds2D arr n1 n2\n    GetArray2DInternal arr n1 n2\n\n[<Inline \"void ($arr[$n1][$n2] = $x)\">]\nlet SetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) (x:'T) = ()\n\n\n[<Name \"WebSharper.Arrays.set2D\" >]\nlet SetArray2D (arr: 'T[,]) (n1: int) (n2: int) (x: 'T) =\n    checkBounds2D arr n1 n2\n    SetArray2DInternal arr n1 n2 x\n\n[<Name \"WebSharper.Arrays.zeroCreate2D\" >]\nlet Array2DZeroCreate<'T> (n:int) (m:int) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.zeroCreate m))\n    arr?dims <- 2\n    arr\n\n[<Name \"WebSharper.Arrays.sub2D\" >]\nlet GetArray2DSub<'T> (src: 'T[,]) src1 src2 len1 len2 =\n    let len1 = (if len1 < 0 then 0 else len1)\n    let len2 = (if len2 < 0 then 0 else len2)\n    let dst = Array2DZeroCreate len1 len2\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[i,j] <- src.[src1 + i, src2 + j]\n    dst\n\n[<Name \"WebSharper.Arrays.setSub2D\" >]\nlet SetArray2DSub<'T> (dst: 'T[,]) src1 src2 len1 len2 (src: 'T[,]) =\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[src1+i, src2+j] <- src.[i, j]\n\n[<Name \"WebSharper.Arrays.length\" >]\nlet GetLength<'T> (arr: System.Array) =\n    match arr?dims with\n    | 2 -> GetArray2DLength1 (As arr) * GetArray2DLength1 (As arr)\n    | _ -> Array.length (As arr)\n\n[<Name \"WebSharper.checkThis\">]\nlet CheckThis (this: 'T) =\n    if this = null then\n        invalidOp \"The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.\"\n    else this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\ntype private IComparer = System.Collections.IComparer\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\ntype private JSArray<'T> = WebSharper.JavaScript.Array<'T>\ntype private Comparer<'T> = System.Collections.Generic.Comparer<'T>\n\n[<AutoOpen; JavaScript>]\nmodule ArrayProxy =\n\n    [<Name \"WebSharper.Arrays.binarySearch\">]\n    let binarySearch (haystack: 'T[]) (comparer: 'T -> int) start finish =\n        if start < 0 then raise (ArgumentOutOfRangeException(\"index\", \"Non-negative number required.\"))\n        if finish > haystack.Length then raise (ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\"))\n        if finish < start then raise (ArgumentOutOfRangeException(\"length\", \"Non-negative number required.\"))\n        let rec search left right =\n            if left > right then\n                ~~~left\n            else\n                let pivot = (left + right) / 2\n                let cmp = comparer haystack.[pivot]\n                if left = right then\n                    if cmp = 0 then left\n                    elif cmp > 0 then ~~~(left + 1)\n                    else ~~~left\n                elif cmp <= 0 then\n                    search left pivot\n                else\n                    search (pivot + 1) right\n        search start (finish - 1)\n\n    [<Name \"WebSharper.Arrays.binarySearchComparer\">]\n    let objBinarySearchComparer (needle: obj) =\n       // Check for an implementation of IComparable\n       if needle?CompareTo0 then\n           As<IComparable>(needle).CompareTo\n       else\n           fun x ->\n               if x?CompareTo0 then\n                   -As<IComparable>(x).CompareTo(needle)\n               else\n                   InvalidOperationException(\n                       \"Failed to compare two elements in the array.\",\n                       ArgumentException(\"At least one object must implement IComparable.\"))\n                   |> raise\n\n    [<Name \"WebSharper.Arrays.sortInternal\">]\n    let sortInternal (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) (swap: int -> int -> unit) : unit =\n        let partition l r =\n            let pivot = keys.JS.[r]\n            let mutable i = l - 1\n            for j = l to r - 1 do\n                if comp(keys.JS.[j], pivot) < 0 then\n                    i <- i + 1\n                    swap i j\n            if comp(keys.JS.[r], keys.JS.[i + 1]) < 0 then\n                swap (i + 1) r\n            i + 1\n        let rec quicksort l r =\n            if l < r then\n                let p = partition l r\n                quicksort l (p - 1)\n                quicksort (p + 1) r\n        quicksort index (index + length - 1)\n\n    [<Name \"WebSharper.Arrays.sortSub\">]\n    let sortSub (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n        sortInternal keys index length comp swap\n\n    [<Name \"WebSharper.Arrays.sortByKeys\">]\n    let sortByKeys (keys: 'K[]) (items: 'V[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n            let v = items.JS.[i]\n            items.JS.[i] <- items.JS.[j]\n            items.JS.[j] <- v\n        sortInternal keys index length comp swap\n\n[<Proxy(typeof<System.Array>)>]\ntype private ArrayProxy =\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Name \"WebSharper.Arrays.clear\">]\n    static member Clear(array: System.Array, index: int, length: int) : unit =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if index < 0 || length < 0 || index + length > array.Length then raise (IndexOutOfRangeException())\n        for i = index to index + length - 1 do\n            (As<JSArray<obj>> array).[i] <-\n                match JS.TypeOf (As<JSArray<obj>> array).[i] with\n                | JS.Number -> box 0\n                | _ -> null\n\n    [<Inline>]\n    member this.Clone() =\n        Array.copy (As<obj[]> this) :> obj\n\n    [<Name \"WebSharper.Arrays.constrainedCopy\">]\n    static member ConstrainedCopy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        if src ===. dst && dstIndex <= srcIndex + length then\n            let tmp = Array.init length (fun i -> (As<obj[]> src).[srcIndex + i])\n            Array.blit tmp 0 (As<obj[]> dst) dstIndex length\n        else\n            Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    static member Copy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    member this.CopyTo(dst: System.Array, index: int) =\n        if this.Length + index < dst.Length then raise (ArgumentException(\"array\"))\n        Array.blit (As<obj[]> this) 0 (As<obj[]> dst) index this.Length\n\n    [<Inline>]\n    static member Copy(src: System.Array, dst: System.Array, length: int) =\n        Array.blit (As<obj[]> src) 0 (As<obj[]> dst) 0 length\n\n    [<Inline>]\n    static member ConvertAll<'T, 'U>(array: 'T[], converter: Converter<'T, 'U>) : 'U[] =\n        Array.map converter.Invoke array\n\n    [<Inline>]\n    static member Empty<'T>() : 'T[] =\n        Array.empty\n\n    [<Inline>]\n    static member Exists<'T>(array: 'T[], predicate: Predicate<'T>) : bool =\n        Array.exists predicate.Invoke array\n\n    [<Inline>]\n    static member Find<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFind predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    static member FindAll<'T>(array: 'T[], predicate: Predicate<'T>) : 'T[] =\n        Array.filter predicate.Invoke array\n\n    [<Name \"WebSharper.Arrays.findIndexBound\">]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f finish i =\n            if i = finish then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f finish (i + 1)\n        f (startIndex + count) startIndex\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member FindLast<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFindBack predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Name \"WebSharper.Arrays.findLastIndexBound\">]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f i =\n            if i < startIndex then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f (i - 1)\n        f (startIndex + count - 1)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member ForEach<'T>(array: 'T[], action: Action<'T>) : unit =\n        Array.iter action.Invoke array\n\n    [<Inline>]\n    member this.GetValue(i: int) =\n        (As<obj[]> this).[i]\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member Resize<'T>(array: byref<'T[]>, newSize: int) =\n        let a = Array.zeroCreate newSize\n        if not (isNull array) then\n            Array.blit array 0 a 0 (min newSize array.Length)\n        array <- a\n\n    [<Inline \"$array.reverse()\">]\n    static member Reverse(array: System.Array) = X<unit>\n\n    [<Name \"WebSharper.Arrays.reverse\">]\n    static member Reverse(array: System.Array, offset: int, length: int) =\n        let a = Array.rev (Array.sub (As array) offset length)\n        Array.blit a 0 (As array) offset a.Length\n\n    [<Inline>]\n    member this.SetValue(v: obj, index: int) =\n        (As<obj[]> this).[index] <- v\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int, comp: IComparer<'K>) : unit =\n        sortByKeys keys items index length comp.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int) : unit =\n        sortByKeys keys items index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], comparer: IComparer<'K>) : unit =\n        sortByKeys keys items 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[]) : unit =\n        sortByKeys keys items 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int, comparer: IComparer<'K>) : unit =\n        sortSub keys index length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int) : unit =\n        sortSub keys index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparer: IComparer<'K>) : unit =\n        sortSub keys 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[]) : unit =\n        sortSub keys 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparison: Comparison<'K>) =\n        sortSub keys 0 keys.Length comparison.Invoke\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) index length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int) : unit =\n        sortSub (As<obj[]> keys) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member TrueForAll<'T>(array : 'T[], predicate: Predicate<'T>) : bool =\n        Array.forall predicate.Invoke array\n\n    member this.Length\n        with [<Inline>] get() = F.GetLength (As this)   \n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get0 (As this)         \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ArrayModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ArrayModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\nlet checkLength (arr1: 'T1[]) (arr2: 'T2[]) =\n    if Array.length arr1 <> Array.length arr2 then\n        failwith \"The arrays have different lengths.\"\n\n[<Inline \"$x.push($y)\">]\nlet push (x: obj) (y: obj) = ()\n\n[<Inline \"$arr1.concat($arr2)\">]\nlet Append<'T> (arr1: 'T []) (arr2: 'T []) : 'T [] = arr1\n\n[<Name \"allPairs\">]\nlet AllPairs (array1: 'T1 []) (array2: 'T2 []) =\n    let len1 = Array.length array1\n    let len2 = Array.length array2\n    let res = JavaScript.Array (len1 * len2)\n    for i = 0 to len1-1 do\n        for j = 0 to len2-1 do\n            res.[i * len2 + j] <- (array1.JS.[i],array2.JS.[j])\n    res |> As<('T1 * 'T2) []>\n\n[<Name \"average\">]\nlet inline Average (arr: 'T []): 'T = As (float (Array.sum arr) / float (Array.length arr))\n\n[<Name \"averageBy\">]\nlet inline AverageBy (f: 'T -> 'U) (arr: 'T []) : 'U = As (float (Array.sumBy f arr) / float (Array.length arr))\n\n[<Name \"blit\">]\nlet CopyTo<'T> (arr1: 'T [], start1, arr2: 'T [], start2, length) =\n    F.checkRange arr1 start1 length\n    F.checkRange arr2 start2 length\n    for i = 0 to length - 1 do\n        arr2.JS.[start2 + i] <- arr1.JS.[start1 + i]\n\n[<Name \"choose\">]\nlet Choose<'T,'U> (f: 'T -> option<'U>) (arr: 'T []) : 'U [] =\n    let q : 'U [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match f arr.JS.[i] with\n        | Some x -> push q x\n        | None   -> ()\n    q\n\n[<Inline \"Array.prototype.concat.apply([], $x)\"; Pure>]\nlet concatArray (x: 'T[][]) = X<'T[]>\n\n[<Name \"collect\">]\nlet Collect<'T,'U> (f: 'T -> 'U[]) (x: 'T []) : 'U[] =\n    concatArray (Array.map f x)\n\n[<Name \"concat\">]\nlet Concat<'T> (xs: seq<'T []>) : 'T [] =\n    concatArray (Array.ofSeq xs)\n\n[<Inline>]\nlet SplitInto count (arr: 'T[]) = ArraySplitInto count arr\n\n[<Inline \"$x.slice()\">]\nlet Copy (x: 'T []) = X<'T []>\n\n[<Name \"create\">]\nlet Create (size: int) value =\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- value\n    r.Self\n\n[<Inline \"[]\">]\nlet Empty () = X<'T []>\n\n[<Name \"exists\">]\nlet Exists<'T> (f: 'T -> bool) (x: 'T []) =\n    let mutable e = false\n    let mutable i = 0\n    let l = x.Length\n    while not e && i < l do\n        if f x.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n    e\n\n[<Name \"exists2\">]\nlet Exists2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable e = false\n    let mutable i = 0\n    let l = x1.Length\n    while not e && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n\n    e\n\n[<Name \"fill\">]\nlet Fill<'T> (arr: 'T []) (start: int) (length: int) (value: 'T) =\n    F.checkRange arr start length\n    for i = start to start + length - 1 do\n        arr.JS.[i] <- value\n\n[<Name \"filter\">]\nlet Filter<'T> f (arr: 'T []) : 'T [] =\n    let r : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push r arr.JS.[i]\n    r\n\n[<Name \"find\">]\nlet Find f (arr: _ []) =\n    match Array.tryFind f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex f (arr: _ []) =\n    match Array.tryFindIndex f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S =\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> f (zero: 'S) (arr1: 'T1 []) (arr2: 'T2 []) : 'S =\n    checkLength arr1 arr2\n    let mutable accum = zero\n    for i in 0 .. Array.length arr1 - 1 do\n        accum <- f accum arr1.JS.[i] arr2.JS.[i]\n    accum\n\n[<Name \"foldBack\">]\nlet FoldBack f (arr: _ []) zero =\n    let mutable acc = zero\n    let len = Array.length arr\n    for i = 1 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (arr1: _ []) (arr2: _ []) zero =\n    checkLength arr1 arr2\n    let len = Array.length arr1\n    let mutable accum = zero\n    for i in 1 .. len do\n        accum <- f arr1.JS.[len - i] arr2.JS.[len - i] accum\n    accum\n\n[<Name \"forall\">]\nlet ForAll f (x: _ []) =\n    let mutable a = true\n    let mutable i = 0\n    let l = x.Length\n    while a && i < l do\n        if f x.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable a = true\n    let mutable i = 0\n    let l = x1.Length\n    while a && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Inline>]\nlet Get (arr: _ []) index =\n    F.GetArray arr index\n\n[<Inline>]\nlet Item index (arr: _ []) =\n    F.GetArray arr index\n\n[<Name \"init\">]\nlet Initialize (size: int) f =\n    if size < 0 then\n        failwith \"Negative size given.\"\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- f i\n    r.Self\n\n[<Inline \"$arr.length == 0\">]\nlet IsEmpty (arr: _ []) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f arr.JS.[i]\n\n[<Name \"iter2\">]\nlet Iterate2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f arr1.JS.[i] arr2.JS.[i]\n\n[<Name \"iteri\">]\nlet IterateIndexed f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f i arr.JS.[i]\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f i arr1.JS.[i] arr2.JS.[i]\n\n[<Inline \"$arr.length\">]\nlet Length<'T> (arr: 'T []) = X<int>\n\n[<Name \"map\">]\nlet Map<'T1,'T2> (f: 'T1 -> 'T2) (arr: 'T1 []) : 'T2 [] =\n    let r = JavaScript.Array<'T2>(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        r.[i] <- f arr.JS.[i]\n    r.Self\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (arr1: 'T1 []) (arr2: 'T2 []) : 'T3 [] =\n    checkLength arr1 arr2\n    let r = JavaScript.Array<'T3>(Array.length arr2)\n    for i = 0 to Array.length arr2 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i]\n    r.Self\n\n[<Name \"mapi\">]\nlet MapIndexed f (arr: _ []) =\n    let y = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        y.[i] <- f i arr.JS.[i]\n    y.Self\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (arr1: 'T1 []) (arr2: 'T2 []): 'U[] =\n    checkLength arr1 arr2\n    let res = JavaScript.Array(Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.[i] <- f i arr1.JS.[i] arr2.JS.[i]\n    res.Self\n\n[<Inline>]\nlet MapFold<'T,'S,'R> f zero arr = ArrayMapFold<'T, 'S, 'R> f zero arr\n\n[<Inline>]\nlet MapFoldBack f arr zero = ArrayMapFoldBack f arr zero\n\nlet private nonEmpty (arr: _ []) =\n    if Array.length arr = 0 then\n        failwith \"The input array was empty.\"\n\n[<Name \"max\">]\nlet Max arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x > m then\n            m <- x\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"min\">]\nlet Min arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x < m then\n            m <- x\n    m\n\n\n[<Name \"minBy\">]\nlet MinBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"ofList\">]\nlet OfList<'T> (xs: list<'T>) =\n    let q : 'T [] = [||]\n    let mutable l = xs\n    while not (List.isEmpty l) do\n        push q l.Head\n        l <- l.Tail\n    q\n\n[<Name \"ofSeq\">]\nlet OfSeq<'T> (xs: seq<'T>) : 'T [] =\n    if xs :? System.Array then\n        Array.copy (As<'T[]> xs)\n    elif xs :? _ list then\n        Array.ofList (As<'T list> xs)\n    else\n        let q : 'T [] = [||]\n        use o = Enumerator.Get xs\n        while o.MoveNext() do\n            push q o.Current\n        q\n\n[<Name \"partition\">]\nlet Partition f (arr: 'T []) : 'T [] * 'T [] =\n    let ret1 : 'T [] = [||]\n    let ret2 : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push ret1 arr.JS.[i]\n        else\n            push ret2 arr.JS.[i]\n    (ret1, ret2)\n\n[<Name \"permute\">]\nlet Permute f (arr: 'T []) =\n    let ret = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        ret.[f i] <- arr.JS.[i]\n    ret.Self\n\n[<Name \"pick\">]\nlet Pick f (arr: _ []) =\n    match Array.tryPick f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"reduce\">]\nlet Reduce f (arr: _ []) =\n    nonEmpty arr\n    let mutable acc = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (arr: _ []) =\n    nonEmpty arr\n    let len = Array.length arr\n    let mutable acc = arr.JS.[len - 1]\n    for i = 2 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Inline \"$x.slice().reverse()\">]\nlet Reverse (x: 'T []) = X<'T []>\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S [] =\n    let ret = JavaScript.Array(1 + Array.length arr)\n    ret.[0] <- zero\n    for i = 0 to Array.length arr - 1 do\n        ret.[i + 1] <- f ret.[i] arr.JS.[i]\n    ret.Self\n\n[<Name \"scanBack\">]\nlet ScanBack (f: 'T -> 'S -> 'S) (arr: 'T []) (zero: 'S) : 'S [] =\n    let len = Array.length arr\n    let ret = JavaScript.Array(1 + len)\n    ret.[len] <- zero\n    for i = 0 to len - 1 do\n        ret.[len - i - 1] <- f arr.JS.[len - i - 1] ret.[len - i]\n    ret.Self\n\n[<Inline>]\nlet Set (arr: _ []) i v =\n    F.SetArray arr i v\n\n[<Name \"sort\">]\nlet Sort<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> Array.map fst\n\n[<Name \"sortBy\">]\nlet SortBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortInPlace\">]\nlet SortInPlace<'T when 'T: comparison> (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> mapInPlace fst\n\n[<Name \"sortInPlaceBy\">]\nlet SortInPlaceBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"sortInPlaceWith\">]\nlet SortInPlaceWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) =\n    arr.JS.Sort(fun (x, y) -> comparer x y) |> ignore\n\n[<Name \"sortWith\">]\nlet SortWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) : 'T [] =\n    (Array.copy arr).JS.Sort(fun (x, y) -> comparer x y)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> - compare x y) |> Array.map fst\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Inline>]\nlet GetSubArray (arr: 'T []) (start: int) (length: int) : 'T []=\n    F.GetArraySub arr start length\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $arr[i]; return sum\">]\n[<Name \"sum\">]\nlet Sum (arr: 'T []) : 'T = X<'T>\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $f($arr[i]); return sum\">]\n[<Name \"sumBy\">]\nlet SumBy (f: 'T -> 'U) (arr: 'T []) : 'U =  X<'U>\n\n[<Name \"transpose\">]\nlet Transpose (x: 'T[] seq) : 'T[][] =\n    match x with\n    | :? System.Array -> ArrayTranspose (As<'T[][]> x)\n    | _ -> ArrayTranspose (Array.ofSeq x)\n\n[<Inline>]\nlet ToList arr = List.ofArray arr\n\n[<Inline \"$arr\">]\nlet ToSeq (arr: _ []) = arr :> seq<_>\n\n[<Name \"tryFind\">]\nlet TryFind f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some arr.JS.[i]\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindBack f (arr: _ []) = ArrayTryFindBack f arr\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some i\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindIndexBack f (arr: _ []) = ArrayTryFindIndexBack f arr\n\n[<Name \"tryHead\">]\nlet TryHead (arr: 'T[]) =\n    if Array.length arr = 0 then None else Some arr.JS.[0]\n\n[<Name \"tryItem\">]\nlet TryItem i (arr: 'T[]) =\n    if Array.length arr <= i || i < 0 then None else Some arr.JS.[i]\n\n[<Name \"tryLast\">]\nlet TryLast (arr: 'T[]) =\n    let len = Array.length arr\n    if len = 0 then None else Some arr.JS.[len - 1]\n\n[<Name \"tryPick\">]\nlet TryPick f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        match f arr.JS.[i] with\n        | Some _ as r -> res <- r\n        | _ -> ()\n        i <- i + 1\n    res\n\n[<Name \"unzip\">]\nlet Unzip<'T1,'T2> (arr: ('T1 * 'T2) []) : 'T1 [] * 'T2 [] =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        let (a, b) = arr.JS.[i]\n        push x a\n        push y b\n    (x, y)\n\n[<Name \"unzip3\">]\nlet Unzip3<'T1,'T2,'T3> (arr: ('T1 * 'T2 * 'T3) []) =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    let z : 'T3 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match arr.JS.[i] with\n        | (a, b, c) ->\n            push x a\n            push y b\n            push z c\n    (x, y, z)\n\n[<Inline>]\n[<Name \"zeroCreate\">]\nlet ZeroCreate<'T> (size: int) =\n    Create size Unchecked.defaultof<'T>\n\n[<Name \"zip\">]\nlet Zip (arr1: 'T1 []) (arr2: 'T2 []) =\n    checkLength arr1 arr2\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i])\n    res\n\n[<Name \"zip3\">]\nlet Zip3 (arr1: _ [], arr2: _ [], arr3: _ []) =\n    checkLength arr1 arr2\n    checkLength arr2 arr3\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i], arr3.JS.[i])\n    res\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size array =\n    SeqChunkBySize size (Array.toSeq array)\n    |> Seq.toArray\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (a1: 'T []) (a2: 'T []) : int =\n    Seq.compareWith f (Array.toSeq a1) (Array.toSeq a2)\n\n[<Inline>]\nlet CountBy (f: 'T -> 'K) (a: 'T []) : ('K * int) [] =\n    ArrayCountBy f a\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: 'T []) : 'T [] =\n    Seq.distinct (Array.toSeq l)\n    |> Seq.toArray\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (a: 'T []) : 'T [] =\n    Seq.distinctBy f (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (a: 'T []) =\n    SeqExcept itemsToExclude (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"findBack\">]\nlet FindBack p (s: _ []) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: _ []) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (a: 'T []) : ('K * 'T []) [] =\n    ArrayGroupBy f a\n\n[<Name \"head\">]\nlet Head (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[0]\n\n[<Name \"last\">]\nlet Last (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[Array.length arr - 1]\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (arr1: 'T1 []) (arr2: 'T2 []) (arr3: 'T3 []) : 'T4 [] =\n    checkLength arr1 arr2\n    checkLength arr1 arr3\n    let r = JavaScript.Array<'T4>(Array.length arr3)\n    for i = 0 to Array.length arr3 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i] arr3.JS.[i]\n    r.Self\n\n[<Inline>]\nlet Contains (el: 'T) (a: 'T []) =\n    ArrayContains el a\n\n[<Name \"pairwise\">]\nlet Pairwise (a: 'T []) : ('T * 'T) [] =\n    Seq.pairwise (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    Array.create size value\n\n[<Name \"indexed\">]\nlet Indexed (ar : 'T []) : (int * 'T) [] =\n    Array.mapi (fun a b -> (a, b)) ar\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [| x |]\n\n[<Name \"skip\">]\nlet Skip<'T> i (ar : 'T []) =\n    if i < 0 then InputMustBeNonNegative() else\n    if i > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(i)\n\n[<Name \"skipWhile\">]\nlet SkipWhile<'T> (predicate : 'T -> bool) (ar : 'T []) : 'T [] =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(i)\n\n[<Name \"tail\">]\nlet Tail<'T> (ar : 'T []) : 'T [] =\n    Skip 1 ar\n\n[<Name \"take\">]\nlet Take<'T> n (ar: 'T []) =\n    if n < 0 then InputMustBeNonNegative() else\n    if n > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(0, n)\n\n[<Name \"takeWhile\">]\nlet TakeWhile<'T> (predicate : 'T -> bool) (ar: 'T []) =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(0, i)\n\n[<Inline>]\nlet Truncate<'T> n (ar: 'T []) =\n    ar.JS.Slice(0, n)\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (ar : 'T []) =\n    if Array.length ar = 1 then\n        ar.JS.[0]\n    else\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : 'T [] =\n    Seq.unfold f s\n    |> Seq.toArray\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T []) : 'T [] =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T []) : array<'T []> =\n    Seq.windowed windowSize (Array.toSeq s)\n    |> Seq.toArray\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (ar: 'T []) =\n    Take n ar, Skip n ar\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays2D\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.Array2DModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.Array2DModuleProxy\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Inline>]\nlet Length1 (arr: 'T[,]) = F.GetArray2DLength1 arr\n\n[<Inline>]\nlet Length2 (arr: 'T[,]) = F.GetArray2DLength2 arr\n\n[<Inline>]\nlet Get (array: 'T[,]) (n:int) (m:int) = F.GetArray2D array n m\n\n[<Inline>]\nlet Set (array: 'T[,]) (n:int) (m:int) (x:'T) = F.SetArray2D array n m x\n\n[<Inline>]\nlet ZeroCreate (n:int) (m:int) = F.Array2DZeroCreate n m\n    \n[<Inline>]\nlet Create n m (x:'T) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.create m x))\n    arr?dims <- 2\n    arr\n     \n[<Name \"init\">]\nlet Initialize n m f = \n    let array = ZeroCreate n m : 'T[,]  \n    for i = 0 to n - 1 do \n        for j = 0 to m - 1 do \n            array.[i, j] <- f i j\n    array\n\n[<Name \"iter\">]\nlet Iterate f array = \n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f array.[i,j]\n\n[<Name \"iteri\">]\nlet IterateIndexed (f : int -> int -> 'T -> unit) (array:'T[,]) =\n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f i j array.[i,j]\n\n[<Name \"map\">]\nlet Map f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f array.[i,j])\n\n[<Name \"mapi\">]\nlet MapIndexed f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f i j array.[i,j])\n\n[<Name \"copy\">]\nlet Copy array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> array.[i,j])\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\ntype private CT  = System.Threading.CancellationToken\ntype private CTS  = System.Threading.CancellationTokenSource\ntype private CTR  = System.Threading.CancellationTokenRegistration\ntype private OCE = System.OperationCanceledException\nmodule C = WebSharper.Concurrency\n\n[<Proxy(typeof<Async>)>]\ntype private AsyncProxy =\n\n    [<Inline>]\n    static member Catch(a: Async<'T>) : Async<Choice<'T,exn>>  =\n        As (C.Catch (As a))\n\n    [<Inline>]\n    static member Start(computation: Async<unit>, ?t: CT) : unit =\n        C.Start (As computation, As t)\n\n    [<Inline>]\n    static member Ignore (computation: Async<'T>) : Async<unit> =\n        As (C.Ignore (As computation))\n\n    [<Inline>]\n    static member Sleep milliseconds : Async<unit> =\n        As (C.Sleep milliseconds)\n\n    [<Inline>]\n    static member StartWithContinuations(op: Async<'T>,\n                                         c1: 'T -> unit,\n                                         c2: exn -> unit,\n                                         c3: OCE -> unit,\n                                         ?t: CT) : unit =\n        C.StartWithContinuations (As op, c1, c2, c3, As t)\n\n    [<Inline>]\n    static member FromContinuations(callback: (('T -> unit) *\n                                               (exn -> unit) *\n                                               (OCE -> unit)) -> unit)\n                                    : Async<'T> =\n        As (C.FromContinuations callback)\n\n    [<Inline>]\n    static member AwaitEvent(ev: IEvent<'D,'T>, ?t: unit -> unit) : Async<'T> =\n        As (C.AwaitEvent (As ev, t))\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task) : Async<unit> =\n        As (C.AwaitTask t)\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task<'T>) : Async<'T> =\n        As (C.AwaitTask1 t)\n\n    [<Inline>]\n    static member StartChild(a: Async<'T>, ?timeOut: int) : Async<Async<'T>> =\n        As (C.StartChild (As a, timeOut))\n\n    [<Inline>]\n    static member StartChildAsTask(a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions) \n        : Async<System.Threading.Tasks.Task<'T>> =\n        As (C.StartChildAsTask (As a))\n\n    [<Inline>]\n    static member Parallel(cs: seq<Async<'T>>) : Async<'T []> =\n        As (C.Parallel (As cs))\n\n    [<Inline>]\n    static member StartImmediate(c: Async<unit>, ?t: CT) : unit =\n        C.StartImmediate (As c, As t)\n\n    [<Inline>]\n    static member StartAsTask (a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartAsTask(As a, As t)        \n\n    [<Inline>]\n    static member StartImmediateAsTask (a: Async<'T>, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartImmediateAsTask(As a, As t)        \n\n    [<Inline>]\n    static member DefaultCancellationToken : CT =\n        As !C.defCTS\n\n    [<Inline>]\n    static member CancelDefaultToken() : unit =\n        let cts = !C.defCTS\n        C.defCTS := new CTS()\n        cts.Cancel()    \n\n    [<Inline>]\n    static member CancellationToken : Async<CT> =\n        As C.GetCT\n\n    [<Inline>]\n    static member OnCancel(action: unit -> unit) : Async<System.IDisposable> =\n        As (C.OnCancel action)\n    \n    [<Inline>]\n    static member TryCancelled(p: Async<'T>, f: OCE -> unit) : Async<'T> =\n        As (C.TryCancelled(As p, f))\n\n[<Proxy(typeof<CT>)>]\ntype private CancellationTokenProxy =\n    [<Inline \"$this.c\">]\n    member this.IsCancellationRequested = X<bool>\n\n    [<Inline>]\n    member this.Register(callback: System.Action) =\n        As<CTR> (C.Register (As this) callback.Invoke)\n\n    [<Inline>]\n    member this.ThrowIfCancellationRequested() =\n        if this.IsCancellationRequested then raise (OCE(As<CT> this)) \n\n    [<Inline>]\n    static member None = As<CT> C.noneCT\n        \n[<Proxy(typeof<CTS>)>]\n[<Name \"CancellationTokenSource\">]\ntype private CancellationTokenSourceProxy () =\n    let mutable c = false\n\n    let mutable pending = None\n\n    let r = [||] : (unit -> unit)[]\n\n    [<Inline>]\n    new (delay: int) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    new (delay: System.TimeSpan) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    member this.IsCancellationRequested = c\n\n    member this.Token \n        with [<Inline \"$this\">] get() = X<CT>\n\n    member this.Cancel() =\n        if not c then\n            c <- true\n            let errors = \n                r |> Array.choose (fun a -> \n                    try a()\n                        None\n                    with e -> Some e\n                )\n            if errors.Length > 0 then\n                raise (System.AggregateException(errors))    \n            \n    member this.Cancel(throwOnFirstException) =\n        if not throwOnFirstException then\n            this.Cancel()\n        else\n            if not c then\n                c <- true\n                r |> Array.iter (fun a -> a())   \n \n    member this.CancelAfter(delay: int) =\n        if not c then\n            pending |> Option.iter JS.ClearTimeout\n            pending <- Some <| JS.SetTimeout this.Cancel delay\n\n    [<Inline>]\n    member this.CancelAfter(delay: System.TimeSpan) = this.CancelAfter(As<int> delay)\n\n    static member CreateLinkedTokenSource(tokens: CT[]) =\n        let cts = new CTS()\n        tokens |> Array.iter (fun t -> t.Register(fun () -> cts.Cancel()) |> ignore)\n        cts\n\n    static member CreateLinkedTokenSource(t1: CT, t2: CT) =\n        CancellationTokenSourceProxy.CreateLinkedTokenSource [| t1; t2 |]\n\n[<Proxy(typeof<System.Threading.CancellationTokenRegistration>)>]\ntype private CancellationTokenRegistrationProxy =\n    [<Inline>]\n    member this.Dispose() = (this :> System.IDisposable).Dispose() \n    \n    interface System.IDisposable with\n        [<JavaScript false>]\n        member this.Dispose() = ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name \"Char\">]\n[<Proxy(typeof<System.Char>)>]\ntype private CharProxy =\n\n    [<Inline \"'\\u0000'\">]\n    new () = {}\n\n    [<Inline>]\n    member this.CompareTo(s: char) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: char) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    static member GetNumericValue(c: char) : float =\n        if c >= '0' && c <= '9' then float c - float '0' else -1.\n\n    [<Inline>]\n    static member GetNumericValue(s: string, i: int) = CharProxy.GetNumericValue(s.[i])\n\n    static member IsControl(c: char) : bool =\n        c >= '\\u0000' && c <= '\\u001f'\n        || c >= '\\u0080' && c <= '\\u009f'\n\n    [<Inline>]\n    static member IsControl(s: string, i: int) = CharProxy.IsControl(s.[i])\n\n    static member IsDigit(c: char) : bool =\n        c >= '0' && c <= '9'\n\n    [<Inline>]\n    static member IsDigit(s: string, i: int) = CharProxy.IsDigit(s.[i])\n\n    static member IsLetter(c: char) : bool =\n        c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLetter(s: string, i: int) = CharProxy.IsLetter(s.[i])\n\n    static member IsLetterOrDigit(c: char) : bool =\n        System.Char.IsLetter c || System.Char.IsDigit c\n\n    [<Inline>]\n    static member IsLetterOrDigit(s: string, i: int) = CharProxy.IsLetterOrDigit(s.[i])\n\n    static member IsLower(c: char) : bool =\n        c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLower(s: string, i: int) = CharProxy.IsLower(s.[i])\n\n    static member IsUpper(c: char) : bool =\n        c >= 'A' && c <= 'Z'\n\n    [<Inline>]\n    static member IsUpper(s: string, i: int) = CharProxy.IsUpper(s.[i])\n\n    [<Direct @\"$c.match(/\\s/) !== null\">]\n    static member IsWhiteSpace(c: char) = X<bool>\n\n    [<Inline>]\n    static member IsWhiteSpace(s: string, i: int) = CharProxy.IsWhiteSpace(s.[i])\n\n    static member Parse(s: string) =\n        if s.Length = 1 then As<char> s else\n            failwith \"String must be exactly one character long.\"\n\n    [<Inline \"String.fromCharCode($x.charCodeAt() + $y.charCodeAt())\">]\n    static member (+) (x: char, y: char) : char = x + y\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Util\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.CommonExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.CommonExtensionsProxy\n\nopen WebSharper.JavaScript\n\nlet observer (h: 'T -> unit) : System.IObserver<'T> =\n    { new System.IObserver<'T> with \n        member this.OnCompleted() = ()\n        member this.OnError _ = ()\n        member this.OnNext args = h args\n    }\n\n[<Inline>]\nlet AddToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h) |> ignore\n\n[<Inline>]\nlet SubscribeToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\nopen System\n\ntype private D = System.DateTime\ntype private K = System.DateTimeKind\ntype internal TS = System.TimeSpan\ntype private DO = System.DateTimeOffset\n\n[<JavaScript>]\n[<Name \"DateUtil\">]\nmodule private DateTimeHelpers =\n    let DatePortion (d: int) =\n        let e = Date(d)\n        Date(       \n            e.GetFullYear(),\n            e.GetMonth(),\n            e.GetDate()\n        ).GetTime()\n        |> As<D>        \n\n    let TimePortion (d: int) =\n        let e = Date(d)\n        TS(\n            0,\n            e.GetHours(), \n            e.GetMinutes(), \n            e.GetSeconds(), \n            e.GetMilliseconds()\n        )        \n        |> As<TS>        \n\n    let AddYears(d: int, years) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear() + years,\n            e.GetMonth(),\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()\n        |> As<D>        \n\n    let AddMonths(d: int, months: int) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear(),\n            e.GetMonth() + months,\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()    \n        |> As<D>        \n\n    let TryParse (s: string) =\n        let d = Date.Parse(s)   \n        if JS.IsNaN(d) then\n            None\n        else Some d\n\n    let Parse (s: string) =\n        match TryParse s with\n        | Some d -> d\n        | _ ->\n            failwith \"Failed to parse date string.\"\n\n    [<Direct \"(new Date($d)).toLocaleDateString({}, {year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'})\">]\n    let LongDate (d: obj) = X<string>\n     \n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', hour12: false})\">]\n    let ShortTime (d: obj) = X<string>\n\n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})\">]\n    let LongTime (d: obj) = X<string>\n                \n// DateTime is represented as an UTC epoch for remoting purposes.\n// Properties for getting sub-dates/times like Day or Hour convert it to local time on the client for easier display purposes.\n// This is inconsistent, but covers most common uses.\n// If you need UTC time details, use .JS and its UTC methods.\n[<Proxy(typeof<System.DateTime>)>]\ntype private DateTimeProxy =\n    [<Inline \"0\">]\n    new () = {}\n\n    [<Inline \"new Date($y,$mo-1,$d).getTime()\">]\n    new (y: int, mo: int, d: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s,$ms).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int, ms: int) = {}\n    \n    static member Now\n        with [<Inline \"Date.now()\">] get() = X<D>\n\n    static member UtcNow\n        with [<Inline \"Date.now()\">] get() = X<D>\n    \n    [<Inline \"1\">]\n    member this.Kind = X<System.DateTimeKind>\n\n    member this.Date \n        with [<Inline; JavaScript>] get() : D = DateTimeHelpers.DatePortion(As this)\n\n    static member Today\n        with [<Inline; JavaScript>] get() = DateTimeProxy.Now.Date  \n\n    member this.TimeOfDay \n        with [<Inline; JavaScript>] get() = DateTimeHelpers.TimePortion(As this)\n\n    member this.Year\n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetFullYear()\n\n    member this.Month \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMonth() + 1\n\n    member this.Day \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetDate()\n\n    member this.Hour \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetHours()\n                                                  \n    member this.Minute \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMinutes()\n    \n    member this.Second \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetSeconds()\n\n    member this.Millisecond \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMilliseconds()\n    \n    member this.DayOfWeek \n        with [<Inline; JavaScript>] get() = As<System.DayOfWeek>(Date(As<int> this).GetDay())\n\n    member this.Ticks\n        with [<Inline \"$this * 1E4\">] get() = X<int64>\n\n    [<Inline \"$this + $t\">]\n    member this.Add(t: TS) = X<D>\n                            \n    [<Inline \"$this - $t\">]\n    member this.Subtract(t: TS) = X<D>\n\n    [<Inline \"$this - $d\">]\n    member this.Subtract(d: D) = X<TS>\n\n    [<Inline; JavaScript>]\n    member this.AddYears(years: int) : D = DateTimeHelpers.AddYears(As this, years)\n\n    [<Inline; JavaScript>]\n    member this.AddMonths(months: int) : D = DateTimeHelpers.AddMonths(As this, months)\n\n    [<Inline; JavaScript>]\n    member this.AddDays(days: float) : D =\n        this.Add(TS.FromDays days)\n\n    [<Inline; JavaScript>]\n    member this.AddHours(hours: float) : D =\n        this.Add(TS.FromHours hours)\n\n    [<Inline; JavaScript>]\n    member this.AddMinutes(minutes: float) : D =\n        this.Add (TS.FromMinutes minutes)\n\n    [<Inline; JavaScript>]\n    member this.AddSeconds(seconds: float) : D =\n        this.Add (TS.FromSeconds seconds)\n\n    [<Inline; JavaScript>]\n    member this.AddMilliseconds(msec: float) : D =\n        this.Add (TS.FromMilliseconds msec)\n\n    [<Inline; JavaScript>]\n    member this.AddTicks(ticks: int64) : D =\n        this.Add (TS.FromTicks ticks)\n\n    [<Inline \"new Date($this).toLocaleDateString()\">]\n    member this.ToShortDateString() = X<string>\n    \n    [<Inline; JavaScript>]\n    member this.ToLongDateString() = DateTimeHelpers.LongDate(this)\n    \n    [<Inline; JavaScript>]\n    member this.ToShortTimeString() = DateTimeHelpers.ShortTime(this)\n\n    [<Inline; JavaScript>]\n    member this.ToLongTimeString() = DateTimeHelpers.LongTime(this)\n\n    [<Inline; JavaScript>]\n    static member Parse(s) = As<D>(DateTimeHelpers.Parse(s))\n\n    [<Inline; JavaScript>]\n    static member TryParse(s, [<Out>] res: byref<D>) =\n        match DateTimeHelpers.TryParse s with\n        | Some d ->\n            res <- As<D> d   \n            true\n        | _ -> false    \n\n    static member MaxValue\n        with [<Inline \"8640000000000000\">] get () = X<int>\n\n    static member MinValue\n        with [<Inline \"-8640000000000000\">] get () = X<int>\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: D) = X<TS>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a > $b\">]\n    static member op_GreaterThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a < $b\">]\n    static member op_LessThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a >= $b\">]\n    static member op_GreaterThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"$a <= $b\">]\n    static member op_LessThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"new Date($y, $mo, 0).getDate()\">]\n    static member DaysInMonth (y: int, mo: int) = X<int>\n\n    [<Inline \"new Date($y, 1, 29).getDate() == 29\">]\n    static member IsLeapYear (y: int) = X<bool>\n\n[<Proxy(typeof<System.DateTimeOffset>)>]\n[<Prototype false>]\n[<Name \"DateTimeOffset\">]\n// \"d\" contains UTC epoch time\n// \"o\" contains time zone offset in minutes\ntype private DateTimeOffsetProxy [<Inline \"{d: $d, o: $o}\">] (d: D, o: int) =\n\n    [<Inline>]\n    new (d: D, o: TS) = DateTimeOffsetProxy(d, int o.TotalMinutes) \n\n    [<Inline>]\n    new (d: D) = DateTimeOffsetProxy(d, 0) \n\n    member this.DateTime = d\n\n    [<Inline \"$this.o * 60000\">]\n    member this.Offset = X<TS>\n\n    [<Direct \"var d = new Date(); return { d: d.getTime(), o: -d.getTimezoneOffset() } \">]\n    static member Now = X<DO>\n\n    [<Inline \"{ d: Date.now(), o: 0 }\">]\n    static member UtcNow = X<DO>\n        \n    [<Inline>]\n    member this.ToLocalTime() =\n        DO(d, As<TS>(Date().GetTimezoneOffset()))\n        \n    [<Inline>]\n    member this.ToUniversalTime() =\n        DO(d, TS.Zero)\n\n    [<Inline>]\n    member this.UtcDateTime = d\n\n    [<Inline>]\n    member this.TimeOfDay = d.TimeOfDay\n\n    [<Inline>]\n    member this.Year = d.Year\n\n    [<Inline>]\n    member this.Month = d.Month\n\n    [<Inline>]\n    member this.Day = d.Day\n\n    [<Inline>]\n    member this.Hour = d.Hour\n                                                  \n    [<Inline>]\n    member this.Minute = d.Minute\n    \n    [<Inline>]\n    member this.Second = d.Second\n\n    [<Inline>]\n    member this.Millisecond = d.Millisecond\n    \n    [<Inline>]\n    member this.DayOfWeek = d.DayOfWeek\n\n    [<Inline>]\n    member this.Ticks = d.Ticks\n\n    [<Inline>]\n    member this.Add(t: TS) = DateTimeOffsetProxy(d.Add(t), o)\n                            \n    [<Inline>]\n    member this.Subtract(t: TS) = DateTimeOffsetProxy(d.Subtract(t), o)\n\n    [<Inline>]\n    member this.Subtract(o: DO) = d.Subtract(o?d: D)\n\n    [<Inline>]\n    member this.AddYears(years: int) = DateTimeOffsetProxy(d.AddYears(years), o)\n\n    [<Inline>]\n    member this.AddMonths(months: int) = DateTimeOffsetProxy(d.AddMonths(months), o)\n\n    [<Inline>]\n    member this.AddDays(days: float) = DateTimeOffsetProxy(d.AddDays(days), o)\n\n    [<Inline>]\n    member this.AddHours(hours: float) = DateTimeOffsetProxy(d.AddHours(hours), o)\n\n    [<Inline>]\n    member this.AddMinutes(minutes: float) = DateTimeOffsetProxy(d.AddMinutes(minutes), o)\n\n    [<Inline>]\n    member this.AddSeconds(seconds: float) = DateTimeOffsetProxy(d.AddSeconds(seconds), o)\n\n    [<Inline>]\n    member this.AddMilliseconds(msec: float) = DateTimeOffsetProxy(d.AddMilliseconds(msec), o)\n\n    [<Inline>]\n    member this.AddTicks(ticks: int64) = DateTimeOffsetProxy(d.AddTicks(ticks), o)\n\n    [<Inline>]\n    static member (+) (a: DO, b: TS) = a.Add(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: TS) = a.Subtract(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: DO) = a.Subtract(b)\n\n    [<Inline \"$a.d == $b.d\">]\n    static member op_Equality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d != $b.d\">]\n    static member op_Inequality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d > $b.d\">]\n    static member op_GreaterThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d < $b.d\">]\n    static member op_LessThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d >= $b.d\">]\n    static member op_GreaterThanOrEqual (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d <= $b.d\">]\n    static member op_LessThanOrEqual (a: DO, b: DO) = X<bool>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Delegate\">]\n[<Proxy(typeof<Delegate>)>]\ntype internal DelegateProxy =\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline \"$this.apply(null, $args)\">]\n    member this.DynamicInvoke(args: obj[]) = X<obj>\n\n    [<Direct \"$0.$Invokes || [$0]\">]\n    static member InvocationList(del: Delegate) = X<Delegate[]> \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n    \n    static member DelegateTarget(del) =\n        if (JS.Not del) then null\n        elif (JS.In \"$Target\" del) then del?``$Target``\n        elif (JS.In \"$Invokes\" del) then \n            let inv = del?``$Invokes`` : (_ * _)[]\n            snd inv.[inv.Length - 1]\n        else null\n\n    [<Inline>]\n    member this.Target =\n        DelegateProxy.DelegateTarget this\n\n    [<Inline \"$wsruntime.CreateDelegate($0)\">]\n    static member JSCreateDelegate(invokes: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates([$0, $1])\">]\n    static member Combine(a: Delegate, b: Delegate) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates($0)\">]\n    static member Combine(delegates: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member DelegateEqual(d1: Delegate, d2: Delegate) = X<bool>\n                           \n    static member Remove(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        let resInv = [||]\n        let mutable found = false\n        for i = sourceInv.Length - 1 downto 0 do\n            let it = sourceInv.[i]\n            if not found && DelegateProxy.DelegateEqual(it, value) then\n                found <- true\n            else\n                resInv.JS.Unshift(it) |> ignore\n        DelegateProxy.JSCreateDelegate(resInv)         \n\n    static member RemoveAll(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        DelegateProxy.JSCreateDelegate(sourceInv |> Array.filter (fun i -> not (i.Equals(value))))         \n\n[<Proxy(typeof<MulticastDelegate>)>]\ntype internal MulticastDelegateProxy =\n    \n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Collections\nopen System.Collections.Generic\n\ntype private KVP<'K,'V> = KeyValuePair<'K,'V>\ntype private D<'K,'V> = Dictionary<'K,'V>\n\n[<JavaScript>]\nmodule internal DictionaryUtil =\n\n    let notPresent () =\n        failwith \"The given key was not present in the dictionary.\"\n\n    let alreadyAdded () =\n        failwith \"An item with the same key has already been added.\"\n\n    let equals (c: IEqualityComparer<'T>) =\n        FuncWithArgs(fun (x, y) -> c.Equals(x, y))\n\n    [<Inline>]\n    let genEquals<'T when 'T : equality> () = \n        FuncWithArgs(fun (x :'T, y) -> x = y)\n\n    let getHashCode (c: IEqualityComparer<'T>) x =\n        c.GetHashCode x\n\nopen DictionaryUtil\nopen System.Runtime.InteropServices\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.KeyCollection.Enumerator>)>]\n[<Stub>]\ntype private KeyCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'K> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.ValueCollection.Enumerator>)>]\n[<Stub>]\ntype private ValueCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'V> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Name \"WebSharper.Collections.KeyCollection\">]\n[<Proxy(typeof<D<_,_>.KeyCollection>)>]\ntype private KeyCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.KeyCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Key)).GetEnumerator())\n            \n    interface IEnumerable<'K> with\n        member this.GetEnumerator() = As<IEnumerator<'K>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Name \"WebSharper.Collections.ValueCollection\">]\n[<Proxy(typeof<D<_,_>.ValueCollection>)>]\ntype private ValueCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.ValueCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Value)).GetEnumerator())\n            \n    interface IEnumerable<'V> with\n        member this.GetEnumerator() = As<IEnumerator<'V>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Proxy(typeof<D<_,_>.Enumerator>)>]\n[<Stub>]\ntype private DictionaryEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<KVP<'K,'V>> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n/// Implements a proxy for the .NET dictionary.\n[<Name \"WebSharper.Collections.Dictionary\">]\n[<Proxy(typeof<D<_,_>>)>]\ntype internal Dictionary<'K,'V when 'K : equality>\n\n    private (init   : seq<KVP<'K,'V>>,\n             equals : FuncWithArgs<'K * 'K, bool>,\n             hash   : 'K -> int) =\n\n        let mutable count = 0\n        let mutable data  = As<Array<Array<KVP<'K, 'V>>>> [||]\n\n        let get k =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                notPresent()\n            else\n                d.Self |> Array.pick (fun (KeyValue(dk, v)) -> \n                    if equals.Call(dk, k) then Some v else None\n                ) \n\n        let set k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==.null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                match d.Self |> Array.tryFindIndex (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) with\n                | Some i ->\n                    d.[i] <- KVP(k, v) \n                | None ->\n                    count <- count + 1\n                    d.Push(KVP(k, v)) |> ignore\n                    \n        let add k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                if d.Self |> Array.exists (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) then\n                    alreadyAdded()                    \n                count <- count + 1\n                d.Push(KVP(k, v)) |> ignore\n                    \n        let remove k =\n            let h = hash k \n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let r = d.Self |> Array.filter (fun (KeyValue(dk, _)) -> not (equals.Call(dk, k)))\n                if r.Length < d.Length then                  \n                    count <- count - 1\n                    data.[h] <- r.JS\n                    true\n                else\n                    false\n\n        do for x in init do\n            set x.Key x.Value\n\n        new () = new Dictionary<'K,'V>([||], genEquals<'K>(), hash)\n\n        new (capacity: int) = new Dictionary<'K,'V>()\n\n        new (comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>([||], equals comparer, getHashCode comparer)\n\n        new (capacity: int, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(comparer)\n\n        new (dictionary: IDictionary<'K,'V>) =\n            new Dictionary<'K,'V>(dictionary, genEquals<'K>(), hash)\n\n        new (dictionary: IDictionary<'K,'V>, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(\n                dictionary,\n                equals comparer,\n                getHashCode comparer\n            )\n\n        member this.Add(k: 'K, v: 'V) =\n            add k v\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member this.ContainsKey(k: 'K) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                d.Self |> Array.exists (fun (KeyValue(dk, _)) -> \n                    equals.Call(dk, k)\n                ) \n\n        member this.Count with [<Inline>] get () = count\n\n        member this.Item\n            with get (k: 'K) : 'V = get k\n            and set (k: 'K) (v: 'V) = set k v\n\n        member this.GetEnumerator() = As<D<'K,'V>.Enumerator> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        interface System.Collections.IEnumerable with\n            member this.GetEnumerator() = \n                let s = JS.GetFieldValues data\n                (As<KeyValuePair<'K,'V>[][]> s |> Array.concat).GetEnumerator()\n            \n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = As<IEnumerator<KeyValuePair<'K,'V>>> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        member this.Remove(k: 'K) =\n            remove k\n\n        member this.TryGetValue(k: 'K, [<Out>] res : byref<'V>) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let v =\n                    d.Self |> Array.tryPick (fun (KeyValue(dk, v)) -> \n                        if equals.Call(dk, k) then Some v else None\n                    ) \n                match v with \n                | Some v -> \n                    res <- v\n                    true\n                | _ -> false\n\n        member this.Values =\n            As<D<'K,'V>.ValueCollection>(ValueCollectionProxy(As<D<'K,'V>>this))\n\n        member this.Keys =\n            As<D<'K,'V>.KeyCollection>(KeyCollectionProxy(As<D<'K,'V>>this))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Exception =\n    let withInner (msg, inner) =\n        let e = Error(msg)\n        e?inner <- inner\n        e\n\n[<Name [| \"Error\" |]>]\n[<Proxy(typeof<System.Exception>)>]\ntype private ExceptionProxy =\n    [<Inline \"new Error()\">]\n    new () = { }\n\n    [<Inline \"new Error($message)\">]\n    new (message: string) = { }\n\n    [<Inline>]\n    static member CtorProxy (message: string, inner: exn) = Exception.withInner (message, inner)\n\n    member this.Message with [<Inline \"$this.message\">] get () = X<string>\n    member this.InnerException with [<Inline \"$this.inner\">] get () = X<System.Exception>\n    member this.StackTrace with [<Inline \"$this.stack\">] get () = X<string>\n\n[<Proxy(typeof<MatchFailureException>)>]\n[<Name \"MatchFailureException\">]\ntype private MatchFailureExceptionProxy (message: string, line: int, column: int) =\n    inherit exn(message + \" at \" + string line + \":\" + string column)\n\n[<Proxy(typeof<System.IndexOutOfRangeException>)>]\n[<Name \"IndexOutOfRangeException\">]\ntype private IndexOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n\n    new () = IndexOutOfRangeExceptionProxy \"Index was outside the bounds of the array.\"\n\n[<Proxy(typeof<System.OperationCanceledException>)>]\n[<Name \"OperationCanceledException\">]\ntype private OperationCanceledExceptionProxy(message: string, inner: exn, ct: CT) =\n    inherit exn(message, inner)\n\n    new (ct) = OperationCanceledExceptionProxy (\"The operation was canceled.\", null, ct)\n    \n    [<Inline>]\n    new () = OperationCanceledExceptionProxy (CT.None)\n    [<Inline>]\n    new (message) = OperationCanceledExceptionProxy (message, null, CT.None)\n    [<Inline>]\n    new (message, ct) = OperationCanceledExceptionProxy (message, null, ct)\n    [<Inline>]\n    new (message, inner) = OperationCanceledExceptionProxy (message, inner, CT.None)\n\n    [<Inline>]\n    member this.CancellationToken = ct\n\n[<Proxy(typeof<System.ArgumentException>)>]\n[<Name \"ArgumentException\">]\ntype private ArgumentExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentExceptionProxy \"Value does not fall within the expected range.\"\n\n    new (argumentName: string, message: string) =\n        ArgumentExceptionProxy (message + \"\\nParameter name: \" + argumentName)\n\n[<Proxy(typeof<System.ArgumentOutOfRangeException>)>]\n[<Name \"ArgumentOutOfRangeException\">]\ntype private ArgumentOutOfRangeExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Specified argument was out of the range of valid values.\") }\n\n    new (argumentName: string) =\n        new ArgumentOutOfRangeExceptionProxy(argumentName, \"Specified argument was out of the range of valid values.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.ArgumentNullException>)>]\n[<Name \"ArgumentNullException\">]\ntype private ArgumentNullExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Value cannot be null.\") }\n\n    new (argumentName: string) =\n        new ArgumentNullExceptionProxy(argumentName, \"Value cannot be null.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.InvalidOperationException>)>]\n[<Name \"InvalidOperationException\">]\ntype private InvalidOperationExceptionProxy(message: string, innerExn: exn) =\n    inherit exn(message, innerExn)\n    \n    new () = InvalidOperationExceptionProxy \"Operation is not valid due to the current state of the object.\"\n\n    new (message) =\n        new InvalidOperationExceptionProxy(message, null)\n\n[<Proxy(typeof<System.AggregateException>)>]\n[<Name \"AggregateException\">]\ntype private AggregateExceptionProxy(message: string, innerExceptions: exn[]) =\n    inherit exn(message)\n\n    new (innerExceptions: exn[]) = AggregateExceptionProxy(\"One or more errors occurred.\", innerExceptions)\n\n    new (innerExceptions: seq<exn>) = AggregateExceptionProxy(\"One or more errors occurred.\", Array.ofSeq innerExceptions)\n\n    new (message, innerExceptions: seq<exn>) = AggregateExceptionProxy(message, Array.ofSeq innerExceptions)\n\n    new (message, innerException: exn) = AggregateExceptionProxy(message, [| innerException |])\n\n    [<Inline>]\n    member this.InnerExceptions \n        with get() = As<System.Collections.ObjectModel.ReadOnlyCollection<exn>> innerExceptions\n\n[<Proxy(typeof<System.TimeoutException>)>]\n[<Name \"TimeoutException\">]\ntype private TimeoutExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = TimeoutExceptionProxy \"The operation has timed out.\"\n\n[<Proxy(typeof<System.FormatException>)>]\n[<Name \"FormatException\">]\ntype private FormatException(message: string) =\n    inherit exn(message)\n\n    new () = FormatException \"One of the identified items was in an invalid format.\"\n\n[<Proxy(typeof<System.OverflowException>)>]\n[<Name \"OverflowException\">]\ntype private OverflowException(message: string) =\n    inherit exn(message)\n\n    new () = OverflowException \"Arithmetic operation resulted in an overflow.\"\n\n[<Proxy(typeof<System.Threading.Tasks.TaskCanceledException>)>]\n[<Name \"TaskCanceledException\">]\ntype private TaskCanceledException(message: string) =\n    inherit exn(message)\n\n    new () = TaskCanceledException \"A task was canceled.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ExtraTopLevelOperators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ExtraTopLevelOperatorsProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"null\">]\nlet DefaultAsyncBuilder : Control.AsyncBuilder =\n    As (AsyncBuilderProxy())\n\n[<Name \"WebSharper.Arrays.create2D\" >]\nlet CreateArray2D (rows : seq<#seq<'T>>) =\n    let arr = rows |> Seq.map (Array.ofSeq) |> Array.ofSeq |> As<'T[,]>\n    arr?dims <- 2\n    arr\n\n[<Inline \"+$0\">]\nlet ToDouble<'T> (x: 'T) : double = X\n\n[<Inline \"$f(function(x){return x;})\">]\nlet PrintFormatToString (f: Printf.StringFormat<'T>) = X<'T>\n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThen k f = Printf.ksprintf k f \n\n[<Inline; JavaScript>]\nlet PrintFormatLine f = Printf.printfn f \n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThenFail f = Printf.failwithf f \n\n[<Inline; JavaScript>]\nlet SpliceExpression (e: Microsoft.FSharp.Quotations.Expr<'T>) =\n    As<'T> e\n\n[<Inline; JavaScript>]\nlet SpliceUntypedExpression<'T> (e: Microsoft.FSharp.Quotations.Expr) =\n    As<'T> e\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen Concurrency\nopen System.Runtime.InteropServices\n\n[<Proxy(typeof<System.Guid>)>]\n[<Prototype(false)>]\ntype internal GuidProxy =\n    \n    [<Inline \"$g\">]\n    new (g: string) = {}\n    \n    [<Direct \"return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&3|8);\n        return v.toString(16); });\">]\n    static member NewGuid() = X<System.Guid>\n\n    [<Constant \"00000000-0000-0000-0000-000000000000\">]\n    static member Empty = X<System.Guid>\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline>]\n    member this.CompareTo(s: System.Guid) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    static member FormatError() =\n        raise (FormatException \"\"\"Format String can be only \"D\", \"d\", \"N\", \"n\", \"P\", \"p\", \"B\", \"b\", \"X\" or \"x\".\"\"\")\n\n    static member HexaError() =\n        raise (FormatException \"Hexadecimal Guid printing not implemented by WebSharper.\")\n\n    static member ShapeError() =\n        raise (FormatException \"Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\")\n\n    static member ParseError() =\n        raise (FormatException \"Unrecognized Guid format.\")\n\n    member this.ToString(format: string) =\n        match format.ToUpper() with\n        | \"N\" -> (As<string> this).Replace(\"-\", \"\")\n        | \"D\" -> As<string> this\n        | \"B\" -> \"{\" + As<string> this + \"}\"\n        | \"P\" -> \"(\" + As<string> this + \")\"\n        | \"X\" ->\n            let s = As<string> this\n            \"{0x\" + s.Substring(0, 8) + \",0x\" + s.Substring(9, 4) + \",0x\" + s.Substring(14, 4) + \",{0x\"\n            + s.Substring(19, 2) + \",0x\" + s.Substring(21, 2) + \",0x\" + s.Substring(24, 2) + \",0x\"\n            + s.Substring(26, 2) + \",0x\" + s.Substring(28, 2) + \",0x\" + s.Substring(30, 2) + \",0x\" \n            + s.Substring(32, 2) + \",0x\" + s.Substring(34, 2) + \"}}\"\n        | _ -> GuidProxy.FormatError()\n    \n    static member Parse(input: string) =\n        try GuidProxy.ParseExact(input, \"D\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"B\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"P\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"N\") \n        with _ ->\n            GuidProxy.ParseExact(input, \"X\") \n\n    static member ParseExact(input: string, format: string) =\n        let parseD (s: string) =\n            for i = 0 to 35 do\n                match i with \n                | 8 | 13 | 18 | 23 -> if s.[i] <> '-' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            As<System.Guid> s    \n\n        match format.ToUpper() with\n        | \"N\" -> \n            let s = input.Trim().ToLower()\n            if s.Length <> 32 then GuidProxy.ShapeError()\n            for i = 0 to 31 do\n                let c = s.[i]\n                if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            s.Substring(0, 8) + \"-\" + s.Substring(8, 4) + \"-\" + s.Substring(12, 4) + \"-\" \n            + s.Substring(16, 4) + \"-\" + s.Substring(20)\n            |> As<System.Guid>\n        | \"D\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 36 then GuidProxy.ShapeError()\n            parseD s\n        | \"B\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '{' || s.[17] <> '}' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"P\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '(' || s.[17] <> ')' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"X\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 68 then GuidProxy.ShapeError()\n            for i = 0 to 67 do\n                match i with \n                | 0 | 26 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | 1 | 12 | 19 | 27 | 32 | 37 | 42 | 47 | 52 | 57 | 62 -> if s.[i] <> '0' then GuidProxy.ShapeError()\n                | 2 | 13 | 20 | 28 | 33 | 38 | 43 | 48 | 53 | 58 | 63 -> if s.[i] <> 'x' then GuidProxy.ShapeError()\n                | 11 | 18 | 25 | 31 | 36 | 41 | 46 | 51 | 56 | 61 -> if s.[i] <> ',' then GuidProxy.ShapeError()\n                | 66 | 67 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError() \n            s.Substring(3, 8) + \"-\" + s.Substring(14, 4) + \"-\" + s.Substring(21, 4) + \"-\" + s.Substring(29, 2) \n            + s.Substring(34, 2) + \"-\" + s.Substring(39, 2) + s.Substring(44, 2) + s.Substring(49, 2) \n            + s.Substring(54, 2) + s.Substring(59, 2) + s.Substring(64, 2)\n            |> As<System.Guid>\n        | _ -> GuidProxy.FormatError()\n\n    static member TryParse(input: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.Parse(input)\n            true\n        with _ -> false\n\n    static member TryParseExact(input: string, format: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.ParseExact(input, format)\n            true\n        with _ -> false\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule private HashSetUtil =\n    [<Direct \"var r=[]; for(var k in $o) { r.push.apply(r, $o[k]) }; return r\">]\n    let concat (o: Array<Array<'T>>) = X<Array<'T>>\n    \nopen DictionaryUtil\n\n// not really used, an array enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<HashSet<_>.Enumerator>)>]\n[<Stub>]\ntype private HashSetEnumeratorProxy<'T> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'T> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Proxy(typeof<HashSet<_>>)>]\n[<Name \"HashSet\">]\ntype internal HashSetProxy<'T when 'T : equality>\n\n    private (init   : seq<'T>,\n             equals : FuncWithArgs<'T * 'T, bool>,\n             hash   : 'T -> int) =\n\n        let mutable data  = Array<Array<'T>>()\n        let mutable count = 0\n\n        let arrContains (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let arrRemove (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    arr.Splice(i, 1) |> ignore\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let add (item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then\n                data.[h] <- As [| item |]\n                count <- count + 1\n                true\n            else\n                if arrContains item arr then false else    \n                    arr.Push item |> ignore\n                    count <- count + 1\n                    true\n\n        do for x in init do add x |> ignore\n\n        new () = HashSetProxy<'T>(Seq.empty, genEquals<'T>(), hash)\n\n        new (init: seq<'T>) = new HashSetProxy<'T>(init, genEquals<'T>(), hash)\n\n        new (comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(Seq.empty, equals comparer, getHashCode comparer)\n\n        new (init: seq<'T>, comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(init, equals comparer, getHashCode comparer)\n\n        member this.Add(item: 'T) = add item\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member x.Contains(item: 'T) =\n            let arr = data.[hash item]\n            if arr ==. null then false else arrContains item arr\n\n        member x.CopyTo(arr: 'T[]) =\n            let mutable i = 0\n            let all = concat data \n            for i = 0 to all.Length - 1 do \n                arr.[i] <- all.[i]\n\n        member x.Count = count\n\n        member x.ExceptWith(xs: seq<'T>) =\n            for item in xs do\n                x.Remove(item) |> ignore\n\n        [<Inline>]\n        member this.GetEnumerator() =\n           As<HashSet<'T>.Enumerator>((As<seq<'T>>(concat data)).GetEnumerator())\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n        \n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        // TODO: optimize methods by checking if other collection\n        // is a HashSet with the same IEqualityComparer\n        \n        member x.IntersectWith(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash) \n            let all = concat data\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if other.Contains(item) |> not then\n                    x.Remove(item) |> ignore\n\n        member x.IsProperSubsetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count < other.Length && x.IsSubsetOf(other)\n\n        member x.IsProperSupersetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count > other.Length && x.IsSupersetOf(other)\n\n        member x.IsSubsetOf(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            As<_[]>(concat data) |> Array.forall other.Contains\n\n        member x.IsSupersetOf(xs: seq<'T>) =\n            xs |> Seq.forall x.Contains\n\n        member x.Overlaps(xs: seq<'T>) =\n            xs |> Seq.exists x.Contains\n\n        member x.Remove(item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then false else\n                if arrRemove item arr then\n                    count <- count - 1\n                    true\n                else false\n\n        member x.RemoveWhere(cond: System.Predicate<'T>) =\n            let all = concat data\n            let mutable res = 0\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if cond.Invoke item then\n                    if x.Remove(item) then\n                        res <- res + 1\n            res\n\n        member x.SetEquals(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            x.Count = other.Count && x.IsSupersetOf(other)\n\n        member x.SymmetricExceptWith(xs: seq<'T>) =\n            for item in xs do\n                if x.Contains item then\n                    x.Remove(item) |> ignore\n                else\n                    x.Add(item) |> ignore\n\n        member x.UnionWith(xs: seq<'T>) =\n            for item in xs do\n                x.Add(item) |> ignore\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Proxy(typeof<System.IComparable>)>]\ntype private IComparableProxy =\n    [<Name \"CompareTo0\">]\n    abstract CompareTo : obj -> int\n\n[<Proxy(typeof<System.IComparable<_>>)>]\ntype private IComparableProxy<'T> =\n    [<Name \"CompareTo\">]\n    abstract CompareTo : 'T -> int\n\n[<Proxy(typeof<System.Collections.IEqualityComparer>)>]\ntype private IEqualityComparerProxy =\n    [<Name \"CEquals0\">]\n    abstract Equals : obj * obj -> bool \n    [<Name \"CGetHashCode0\">]\n    abstract GetHashCode : obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IEqualityComparer<_>>)>]\ntype private IEqualityComparerProxy<'T> =\n    [<Name \"CEquals\">]\n    abstract Equals : 'T * 'T -> bool \n    [<Name \"CGetHashCode\">]\n    abstract GetHashCode : 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.EqualityComparer<_>>)>]\n[<Name \"WebSharper.Collections.EqualityComparer\">]\n[<AbstractClass>]\ntype private EqualityComparerProxy<'T>() =\n    abstract Equals : 'T * 'T -> bool \n    abstract GetHashCode : 'T -> int\n    interface System.Collections.Generic.IEqualityComparer<'T> with\n        member this.Equals(x, y) = this.Equals(x, y)\n        member this.GetHashCode(x) = this.GetHashCode(x)\n    interface System.Collections.IEqualityComparer with\n        member this.Equals(x, y) = this.Equals(As x, As y)\n        member this.GetHashCode(x) = this.GetHashCode(As x)\n    [<Macro(typeof<M.EqualityComparer>)>]\n    static member Default = X<System.Collections.Generic.EqualityComparer<'T>>\n\n[<Proxy(typeof<System.Collections.IComparer>)>]\ntype private IComparerProxy =\n    [<Name \"Compare0\">]\n    abstract Compare : obj * obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IComparer<_>>)>]\ntype private IComparerProxy<'T> =\n    [<Name \"Compare\">]\n    abstract Compare : 'T * 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.Comparer<_>>)>]\n[<Name \"WebSharper.Collections.Comparer\">]\n[<AbstractClass>]\ntype private ComparerProxy<'T>() =\n    abstract Compare : 'T * 'T -> int\n    interface System.Collections.Generic.IComparer<'T> with\n        member this.Compare(x, y) = this.Compare(x, y)\n    interface System.Collections.IComparer with\n        member this.Compare(x, y) = this.Compare(As x, As y)\n    [<Macro(typeof<M.Comparer>)>]\n    static member Default = X<System.Collections.Generic.Comparer<'T>>\n\n[<Proxy(typeof<System.IEquatable<_>>)>]\ntype private IEquatableProxy<'T> =\n    [<Name \"EEquals\">]\n    abstract Equals : 'T -> bool\n\n[<Proxy(typeof<System.Collections.IStructuralEquatable>)>]\ntype private IStructuralEquatableProxy =\n    [<Name \"SEquals\">]\n    abstract Equals : obj * System.Collections.IEqualityComparer -> bool \n    [<Name \"SGetHashCode\">]\n    abstract GetHashCode : System.Collections.IEqualityComparer -> int\n\n[<Proxy(typeof<System.Collections.IStructuralComparable>)>]\ntype private IStructuralComparableProxy =\n    [<Name \"SCompareTo\">]\n    abstract CompareTo : obj * System.Collections.IComparer -> int \n\n[<Proxy(typeof<System.IDisposable>)>]\ntype private IDisposableProxy =\n    [<Name \"Dispose\">]\n    abstract member Dispose : unit -> unit\n\n[<Proxy(typeof<System.Collections.IEnumerable>)>]  \ntype private IEnumerableProxy =\n\n    [<Name \"GetEnumerator0\">]\n    abstract GetEnumerator : unit -> System.Collections.IEnumerator\n\n[<Proxy(typeof<seq<_>>)>]  \ntype private IEnumerableProxy<'T> =\n    inherit System.Collections.IEnumerable \n    \n    [<Name \"GetEnumerator\">]\n    abstract GetEnumerator : unit -> System.Collections.Generic.IEnumerator<'T>\n    \n[<Proxy(typeof<System.Collections.IEnumerator>)>]\n[<Name \"WebSharper.IEnumerator\">]\ntype private IEnumeratorProxy =\n    [<Name \"Current0\">]\n    abstract member Current  : obj\n    [<Name \"MoveNext\">]\n    abstract member MoveNext : unit -> bool\n    [<Name \"Reset\">]\n    abstract member Reset    : unit -> unit\n\n[<Proxy(typeof<System.Collections.Generic.IEnumerator<_>>)>]\n[<Name \"WebSharper.IEnumerator1\">]\ntype private IEnumeratorProxy<'T> =\n    [<Name \"Current\">]\n    abstract member Current : 'T\n\n[<Proxy(typeof<System.IObservable<_>>)>]\ntype private IObservableProxy<'T> =\n    [<Name \"Subscribe\">]\n    abstract member Subscribe : System.IObserver<'T> -> System.IDisposable\n\n[<Proxy(typeof<System.IObserver<_>>)>]\ntype private IObserverProxy<'T> =\n    [<Name \"OnCompleted\">]\n    abstract member OnCompleted : unit -> unit\n    [<Name \"OnError\">]\n    abstract member OnError : exn -> unit\n    [<Name \"OnNext\">]\n    abstract member OnNext : 'T -> unit\n\n[<Proxy(typeof<IDelegateEvent<_>>)>]\ntype private IDelegateEventProxy<'D> =\n    [<Name \"AddHandler\">]\n    abstract AddHandler : 'D -> unit\n    [<Name \"RemoveHandler\">]\n    abstract RemoveHandler : 'D -> unit\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Lazy\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.LazyExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.LazyExtensionsProxy\n\nopen WebSharper.JavaScript\n\n[<JavaScript; Prototype false>]\ntype LazyRecord<'T> =\n    {\n        [<Name \"c\">] mutable created : bool\n        [<Name \"v\">] mutable evalOrVal : obj\n        [<Name \"f\">] mutable force : unit -> 'T\n    }\n\nlet cachedLazy<'T> () =\n    JS.This.evalOrVal\n\nlet forceLazy<'T> () =\n    let v = (As JS.This.evalOrVal)()\n    JS.This.created <- true\n    JS.This.evalOrVal <- v\n    JS.This.force <- As cachedLazy\n    v\n\nlet Create (f: unit -> 'T) : Lazy<'T> =\n    As {\n        created = false\n        evalOrVal = f\n        force = As forceLazy\n    }\n\nlet CreateFromValue (v: 'T) : Lazy<'T> =\n    As {\n        created = true\n        evalOrVal = v\n        force = As cachedLazy\n    }\n\nlet Force (x: Lazy<'T>) : 'T =\n    As<LazyRecord<'T>>(x).force()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<list<_>>)>]\n[<Name \"WebSharper.List.T\">]\n[<DefaultAugmentation(false)>]\ntype private ListProxy<'T> =\n    | Empty\n    | Cons of Head: 'T * Tail: List<'T>\n\n    [<Inline; Pure>]\n    static member Cons(head: 'T, tail: list<'T>) = head :: tail\n\n    [<Inline; Pure>]\n    static member Empty : list<'T> = []\n\n    member this.Head with [<Inline>] get () = List.head (As this) : 'T\n    member this.Tail with [<Inline>] get () = List.tail (As this) : list<'T>\n    member this.IsEmpty with [<Inline \"$this.$ == 0\">] get () = X<bool>\n\n    member this.Length with get () = List.length (As this)\n\n    member this.Item with get (x: int) : 'T = List.item x (As this)\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() = (this :> _ seq).GetEnumerator() :> _\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let data = As<list<'T>> this\n            Enumerator.New data (fun e ->\n                match e.State with\n                | x :: xs ->\n                    e.Current <- x\n                    e.State <- xs\n                    true\n                | [] ->\n                    false)\n\n    member this.GetSlice(start, finish) : list<'T> =\n        match start, finish with\n        | None, None -> As this\n        | Some i, None -> As this |> CollectionInternals.ListSkip i\n        | None, Some j -> As this |> Seq.take (j + 1) |> List.ofSeq  \n        | Some i, Some j -> As this |> CollectionInternals.ListSkip i |> Seq.take (j - i + 1) |> List.ofSeq        \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"List\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ListModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ListModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nlet badLengths() =\n    failwith \"The lists have different lengths.\"\n\nlet listEmpty() =\n    failwith \"The input list was empty.\"\n\n[<Inline \"$l.$0\">]\nlet unsafeHead (l: list<'T>) = X<'T> \n\n[<Inline \"$l.$1\">]\nlet unsafeTail (l: list<'T>) = X<list<'T>> \n\n[<Inline>]\nlet setValue (l: list<'T>) (v: 'T) =\n    JS.Set l \"$0\" v\n\n[<Inline>]\nlet setTail (l: list<'T>) (t: list<'T>) =\n    JS.Set l \"$1\" t\n\n[<Inline \"new WebSharper.List.T({$: 1})\"; Pure>]\nlet freshEmptyList() = X<list<'T>>\n\n[<Inline>]\nlet freshTail (l: list<'T>) =\n    let t = freshEmptyList()\n    setTail l t\n    t\n\n[<Inline \"$l.$ == 1\">]\nlet notEmpty (l: list<_>) = X<bool>\n\n[<Name \"allPairs\">]\nlet AllPairs (l1: list<_>) (l2: list<_>) =\n    let arr1 = Array.ofList l1\n    let arr2 = Array.ofList l2\n    let res = Array.allPairs arr1 arr2\n    List.ofArray res\n\n[<Name \"append\">]\nlet Append (x: list<'T>) (y: list<'T>) = \n    if List.isEmpty x then y\n    elif List.isEmpty y then x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (unsafeHead l)\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r y |> ignore\n    res\n\n[<Inline>]\nlet inline Average (l: list<_>) = Seq.average l\n\n[<Inline>]\nlet inline AverageBy f (l: list<_>) = Seq.averageBy f l\n\n[<Name \"choose\">]\nlet Choose f (l: list<_>) = List.ofSeq (Seq.choose f l)\n\n[<Name \"collect\">]\nlet Collect (f: _ -> list<_>) (l: list<_>) = List.ofSeq (Seq.collect f l)\n\n[<Name \"concat\">]\nlet Concat (s: seq<list<_>>) = List.ofSeq (Seq.concat s)\n\n[<Inline>]\nlet Empty<'T> : list<'T> = []\n\n[<Name \"exists\">]\nlet Exists<'T> (p: 'T -> bool) (x: list<'T>) =\n    let mutable e = false\n    let mutable l = x\n    while not e && notEmpty l do\n        e <- p (unsafeHead l)\n        l <- unsafeTail l\n    e\n\n[<Name \"exists2\">]\nlet Exists2<'T1,'T2> (p : 'T1 -> 'T2 -> bool)\n                        (x1: list<'T1>)\n                        (x2: list<'T2>) =\n    let mutable e = false\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while not e && notEmpty l1 && notEmpty l2 do\n        e <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if not e && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    e\n\n[<Name \"filter\">]\nlet Filter<'T> (p: 'T -> bool) (l: list<'T>) =\n    List.ofSeq (Seq.filter p l)\n\n[<Inline>]\nlet Find p (l: list<_>) = Seq.find p l\n\n[<Inline>]\nlet FindIndex p (l: list<_>) = Seq.findIndex p l\n\n[<Inline>]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : 'S =\n    Seq.fold f s l\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (l1: list<'T1>)\n                        (l2: list<'T2>) : 'S =\n    Array.fold2 f s (Array.ofList l1) (Array.ofList l2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (l: list<_>) s =\n    Array.foldBack f (Array.ofList l) s\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (l1: list<_>) (l2: list<_>) s =\n    Array.foldBack2 f (Array.ofList l1) (Array.ofList l2) s\n\n[<Name \"forAll\">]\nlet ForAll p (x: list<_>) =\n    let mutable a = true\n    let mutable l = x\n    while a && notEmpty l do\n        a <- p (unsafeHead l)\n        l <- unsafeTail l\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 p (x1: list<_>) (x2: list<_>) =\n    let mutable a = true\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while a && notEmpty l1 && notEmpty l2 do\n        a <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if a && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    a\n\n[<Name \"head\">]\nlet Head (l: list<'T>) =\n    match l with \n    | h :: _ -> h\n    | _ -> listEmpty()\n\n[<Name \"init\">]\nlet Initialize s f = List.ofArray (Array.init s f)\n\n[<Inline \"$l.$ == 0\">]\nlet IsEmpty (l: list<_>) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (l: list<_>) =\n    let mutable r = l\n    while notEmpty r do\n        f r.Head\n        r <- r.Tail\n\n[<Name \"iter2\">]\nlet Iterate2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"iteri\">]\nlet IterateIndexed f (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        f i r.Head\n        r <- r.Tail\n        i <- i + 1\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    let mutable i = 0\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f i r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n        i <- i + 1\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"length\">]\nlet Length (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        r <- r.Tail\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T1 -> 'T2) (x: list<'T1>) = \n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (f (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r []\n    res\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (x1: list<'T1>) (x2: list<'T2>) (x3: list<'T3>) =\n    let mutable go = notEmpty x1 && notEmpty x2 && notEmpty x3\n    if not go then \n        if notEmpty x1 || notEmpty x2 || notEmpty x3 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable l3 = x3\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2) (unsafeHead l3))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        l3 <- unsafeTail l3\n        if notEmpty l1 && notEmpty l2 && notEmpty l3 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 || notEmpty l3 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T1 -> 'T2) (x: list<'T1>) =\n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable i = 0\n    let mutable go = true\n    while go do\n        setValue r (f i (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then \n            go <- false\n        else\n            r <- freshTail r\n            i <- i + 1\n    setTail r []\n    res\n\n[<Name \"mapi2\">]\nlet MapIndexed2 (f: int -> 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable i = 0\n    while go do\n        setValue r (f i (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n            i <- i + 1\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\nlet private nonEmpty (l: list<_>) =\n    if List.isEmpty l then\n        listEmpty()\n\n[<Name \"max\">]\nlet Max (list: list<_>) = \n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x > m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Name \"min\">]\nlet Min (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x < m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"minBy\">]\nlet MinBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Inline>]\nlet Get (l: list<_>) ix = Seq.item ix l\n\n[<Inline>]\nlet Item ix (l: list<_>) = Seq.item ix l\n\n[<Name \"ofArray\">]\nlet OfArray<'T> (arr: 'T []) =\n    let mutable r = []\n    for i = arr.Length - 1 downto 0 do\n        r <- arr.[i] :: r\n    r\n\n[<Name \"ofSeq\">]\nlet OfSeq (s: seq<'T>) =\n    if s :? _ list then\n        As<'T list> s\n    elif s :? System.Array then\n        List.ofArray (As<'T[]> s)\n    else\n        use e = Enumerator.Get s\n        let mutable go = e.MoveNext()\n        if not go then [] else\n        let res = freshEmptyList()\n        let mutable r = res\n        while go do\n            setValue r e.Current\n            if e.MoveNext() then\n                r <- freshTail r\n            else    \n                go <- false\n        setTail r []\n        res\n\n[<Name \"partition\">]\nlet Partition p (l: list<_>) =\n    let (a, b) = Array.partition p (Array.ofList l)\n    (List.ofArray a, List.ofArray b)\n\n[<Name \"permute\">]\nlet Permute f (l: list<_>) =\n    List.ofArray (Array.permute f (Array.ofList l))\n\n[<Inline>]\nlet Pick f (l: list<_>) = Seq.pick f l\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (list: list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        r <- f r (unsafeHead l)\n        l <- unsafeTail l\n    r\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (l: list<_>) =\n    Array.reduceBack f (Array.ofList l)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    List.ofArray (Array.create size value)\n\n[<Name \"rev\">]\nlet Reverse (l: list<'T>) =\n    let mutable res = []\n    let mutable r = l\n    while notEmpty r do\n        res <- unsafeHead r :: res\n        r <- unsafeTail r\n    res\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : list<'S> =\n    List.ofSeq (Seq.scan f s l)\n\n[<Name \"scanBack\">]\nlet ScanBack f (l: list<_>) s =\n    List.ofArray (Array.scanBack f (Array.ofList l) s)\n\n[<Name \"sort\">]\nlet Sort (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlace a\n    List.ofArray a\n\n[<Name \"sortBy\">]\nlet SortBy f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceBy f a\n    List.ofArray a\n\n[<Name \"sortByDescending\">]\nlet SortByDescending f (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending f a\n    List.ofArray a\n\n[<Name \"sortDescending\">]\nlet SortDescending (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending id a\n    List.ofArray a\n\n[<Name \"sortWith\">]\nlet SortWith f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceWith f a\n    List.ofArray a\n\n[<Inline>]\nlet inline Sum (l: list<'T>) : 'T = Seq.sum l\n\n[<Inline>]\nlet inline SumBy (f: 'T -> 'U) (l: list<'T>) : 'U = Seq.sumBy f l\n\n[<Name \"tail\">]\nlet Tail (l: list<'T>) = \n    match l with \n    | _ :: t -> t\n    | _ -> listEmpty()\n\n[<Inline>]\nlet ToArray (l: list<_>) = Array.ofList l\n\n[<Inline \"$x\">]\nlet ToSeq<'T> (x: list<'T>) : seq<'T> = x :> _\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<list<'T>>) : list<list<'T>> =\n    ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofList))\n    |> Seq.map List.ofArray |> List.ofSeq\n\n[<Inline>]\nlet TryFind p (l: list<_>) = Seq.tryFind p l\n\n[<Inline>]\nlet TryFindIndex p (l: list<_>) = Seq.tryFindIndex p l\n\n[<Inline>]\nlet TryPick p (l: list<_>) = Seq.tryPick p l\n\n[<Name \"unzip\">]\nlet Unzip (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    for (a, b) in l do\n        x.Enqueue a\n        y.Enqueue b\n    (List.ofArray (x.ToArray()), List.ofArray (y.ToArray()))\n\n[<Name \"unzip3\">]\nlet Unzip3 (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    let z = System.Collections.Generic.Queue<_>()\n    for (a, b, c) in l do\n        x.Enqueue a\n        y.Enqueue b\n        z.Enqueue c\n    (\n        List.ofArray (x.ToArray()),\n        List.ofArray (y.ToArray()),\n        List.ofArray (z.ToArray())\n    )\n\n[<Name \"zip\">]\nlet Zip (l1: list<_>) (l2: list<_>) =\n    List.map2 (fun x y -> x, y) l1 l2\n\n[<Name \"zip3\">]\nlet Zip3 (l1: list<_>) (l2: list<_>) (l3: list<_>) =\n    Map3 (fun x y z -> (x, y, z)) l1 l2 l3\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size list =\n    SeqChunkBySize size (List.toSeq list)\n    |> Seq.toList\n    |> List.map Array.toList\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (l1: list<'T>) (l2: list<'T>) : int =\n    Seq.compareWith f (List.toSeq l1) (List.toSeq l2)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (l: list<'T>) : list<'K * int> =\n    ArrayCountBy f (List.toArray l)\n    |> Array.toList\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: list<'T>) : list<'T> =\n    Seq.distinct (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (l: list<'T>) : list<'T> =\n    Seq.distinctBy f (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"splitInto\">]\nlet SplitInto count (list: list<'T>) =\n    ArraySplitInto count (List.toArray list)\n    |> Array.toList\n    |> List.map Array.toList\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (l: list<'T>) =\n    SeqExcept itemsToExclude l\n    |> Seq.toList\n\n[<Name \"tryFindBack\">]\nlet TryFindBack ok (l: list<_>) =\n    ArrayTryFindBack ok (Array.ofList l)\n\n[<Name \"findBack\">]\nlet FindBack p (s: list<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet TryFindIndexBack ok (l: list<_>) =\n    ArrayTryFindIndexBack ok (Array.ofList l) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: list<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (l: list<'T>) : list<'K * list<'T>> =\n    let arr = ArrayGroupBy f (List.toArray l)\n    arr |> mapInPlace (fun (k, s) -> (k, Array.toList s))\n    Array.toList (As arr)\n\n[<Name \"last\">]\nlet Last (list : list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = list\n    let mutable t = unsafeTail r\n    while notEmpty t do\n        r <- t\n        t <- unsafeTail r\n    unsafeHead r\n\n[<Name \"contains\">]\nlet Contains (el: 'T) (x: list<'T>) =\n    let mutable c = false\n    let mutable l = x\n    while not c && notEmpty l do\n        c <- el = unsafeHead l\n        l <- unsafeTail l\n    c\n\n[<Name \"mapFold\">]\nlet MapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) zero list =\n    ArrayMapFold f zero (List.toArray list)\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T, 'S, 'R> f list zero =\n    ArrayMapFoldBack<'T, 'S, 'R> f (List.toArray list) zero\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"pairwise\">]\nlet Pairwise (l: list<'T>) : list<'T * 'T> =\n    Seq.pairwise (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"indexed\">]\nlet Indexed (list : list<'T>) : list<int * 'T> =\n    List.mapi (fun a b -> (a, b)) list\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [x]\n\n[<Inline>]\nlet Skip<'T> i (l : list<'T>) = ListSkip i l\n\n[<Inline>]\nlet SkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    ListSkipWhile predicate list\n\n[<Inline>]\nlet Take<'T> n (list: list<'T>) =\n    Seq.take n list |> List.ofSeq\n\n[<Inline>]\nlet TakeWhile<'T> (predicate : 'T -> bool) (list: list<'T>) =\n    Seq.takeWhile predicate list |> List.ofSeq\n\n[<Inline>]\nlet Truncate<'T> n (list: list<'T>) =\n    Seq.truncate n list |> List.ofSeq\n\n[<Name \"tryHead\">]\nlet TryHead<'T> (list: list<'T>) =\n    match list with\n    | head :: _ ->\n        Some head\n    | [] ->\n        None\n\n[<Inline>]\nlet TryItem<'T> n (list: list<'T>) =\n    SeqTryItem n list \n\n[<Inline>]\nlet TryLast<'T> (list: list<'T>) =\n    SeqTryLast list\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (list : 'T list) =\n    match list with\n    | head :: [] ->\n        head\n    | _ ->\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : list<'T> =\n    Seq.unfold f s\n    |> Seq.toList\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T list) : 'T list =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T list) : list<list<'T>> =\n    Seq.windowed windowSize (List.toSeq s)\n    |> Seq.map List.ofArray |> Seq.toList\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (list: 'T list) =\n    (Take n list, Skip n list)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Nullable =\n    let get (x: obj) =\n        if x ===. null then failwith \"Nullable object must have a value.\" else x\n\n////    let getOrDefault<'T> (x: 'T) =\n//        if x ==. null then Unchecked.defaultof<'T> else x     \n\n    let getOrValue<'T> (x: 'T) (v: 'T)  =\n        if x ===. null then v else x     \n\n[<Proxy(typeof<System.Nullable<_>>)>]\ntype private NullableProxy<'T> =\n    \n    [<Inline \"null\">]\n    new () = {}\n\n    [<Inline \"$v\">]\n    new (v: 'T) = {}\n\n    member this.Value \n        with [<JavaScript; Inline>] get(): 'T = As<'T>(Nullable.get this)\n\n    member this.HasValue\n        with [<JavaScript; Inline>] get() = this !=. null\n\n    [<Inline>]\n    member this.GetValueOrDefault() : 'T = Nullable.getOrValue (As<'T> this) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    member this.GetValueOrDefault(v: 'T) : 'T = Nullable.getOrValue (As<'T> this) v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Operators\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorsProxy\n\n#nowarn \"86\"\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"range\">]\n[<Macro(typeof<M.Range>)>]\nlet ( .. ) (min: 'T) (max: 'T) : seq<'T> =\n    let count = 1 + As max - As min\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> As (x + As min))\n\n[<Name \"step\">]\nlet ( .. .. ) (min: 'T1) (step: 'T2) (max: 'T1) : seq<'T1> =\n    let s = sign (As<int> step)\n    Seq.initInfinite (fun k -> As<int> min + k * As<int> step)\n    |> Seq.takeWhile (fun k -> s * (As<int> max - As<int> k) >= 0)\n    |> As\n\n[<Inline \"$r[0]\">]\nlet ( ! ) (r: ref<'T>) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( % ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"$a & $b\">]\nlet ( &&& ) (a: 'T1) (b: 'T1) = X<'T1>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( * ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"Math.pow($a, $b)\">]\nlet ( ** ) (a: 'T1) (b: 'T2) = X<'T1>\n\n[<Inline \"Math.pow($a, $p)\">]\nlet PowInteger (a: 'T, p: int) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( + ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( - ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( / ) (x: 'T1) (y: 'T2) = X<'T3>\n\n[<Inline \"void ($a[0] = $b)\">]\nlet ( := ) (a: ref<'T>) (b: 'T) = X<unit>\n\n[<Inline>]\nlet ( << ) (f: 'T1 -> 'T2) (g: 'T3 -> 'T1) : 'T3 -> 'T2 = \n    ()\n    fun x -> f (g x)\n\n[<Inline \"$a << $b\">]\nlet inline ( <<< ) (a: 'T) (b: int) = X<'T>\n\n[<Inline>]\nlet ( <| ) (f: 'T -> 'TR) (x: 'T) : 'TR = f x\n\n[<Inline>]\nlet ( <|| ) (f: 'T1 -> 'T2 -> 'TR) (x: 'T1, y: 'T2) : 'TR = f x y\n\n[<Inline>]\nlet ( <||| ) (f: 'T1 -> 'T2 -> 'T3 -> 'TR)\n             (x: 'T1, y: 'T2, z: 'T3) : 'TR = f x y z\n\n[<Macro(typeof<M.Comp>)>]\nlet ( = ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <> ) (a: 'T) (b: 'T) =  X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( < ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( > ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( >= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Inline>]\nlet ( >> ) (f: 'T1 -> 'T2) (g: 'T2 -> 'T3): 'T1->'T3 = \n    ()\n    fun x -> g (f x)\n\n[<Inline \"$a >> $b\">]\nlet inline ( >>> ) (a: 'T) (b: int) : 'T = a >>> b\n\n[<Inline>]\nlet ( @ ) a b = List.append a b\n\n[<Inline \"$a + $b\">]\nlet ( ^ ) (a: string) (b: string) : string = a + b\n\n[<Inline \"$a ^ $b\">]\nlet ( ^^^ ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |> ) (x: 'T1) (f: 'T1 -> 'T2) : 'T2 = f x\n\n[<Inline>]\nlet ( ||> ) (x: 'T1, y: 'T2) (f: 'T1 -> 'T2 -> 'TR) : 'TR = f x y\n\n[<Inline \"$a | $b\">]\nlet ( ||| ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |||> ) (x: 'T1, y: 'T2, z: 'T3)\n             (f: 'T1 -> 'T2 -> 'T3 -> 'TR) : 'TR = f x y z\n\n[<Inline \"+ $x\">]\nlet ( ~+ ) (x: 'T) = X<'T>\n\n[<Inline \"- $x\">]\nlet ( ~- ) (x: 'T) = X<'T>\n\n[<Inline \"~ $x\">]\nlet ( ~~~ ) (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Abs>)>]\n[<Inline \"Math.abs($x)\">]\nlet Abs (x: 'T) = X<'T>\n\n[<Inline \"Math.acos($x)\">]\nlet Acos (x: 'T) = X<'T>\n\n[<Inline \"Math.asin($x)\">]\nlet Asin (x: 'T) = X<'T>\n\n[<Inline \"Math.atan($x)\">]\nlet Atan (x: 'T) = X<'T>\n\n[<Inline \"Math.atan2($x, $y)\">]\nlet Atan2 (x: 'T1) (y: 'T1) = X<'T2>\n\n[<Inline \"$x\">]\nlet Box (x: 'T) = X<obj>\n\n[<Inline \"Math.ceil($x)\">]\nlet Ceiling (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Char>)>]\nlet ToChar (x: 'T) = X<char>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToByte (x: 'T) = X<byte>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSByte (x: 'T) = X<sbyte>\n\n[<Inline>]\nlet Compare<'T> (a: 'T) (b: 'T) = Unchecked.compare a b\n\n[<Inline \"Math.cos($x)\">]\nlet Cos (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)+Math.exp(-$x))/2\">]\nlet Cosh<'T> (x: 'T) = X<'T>\n\n[<Inline \"void ($x[0]--)\">]\nlet Decrement (x: ref<int>) = ()\n\n[<Inline>]\nlet DefaultArg x d =\n    match x with\n    | Some x -> x\n    | None   -> d\n\n[<Inline>]\nlet DefaultValueArg x d =\n    match x with\n    | ValueSome x -> x\n    | ValueNone   -> d\n\n[<Inline \"$x\">]\nlet Enum<'T when 'T : enum<int>> (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDecimal (x: 'T) = X<decimal>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDouble (x: 'T) = X<double>\n\n[<Inline \"Math.exp($x)\">]\nlet inline Exp (x: 'T) = X<'T>\n\nlet FailWith (msg: string) : 'T = raise (exn msg)\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToFloat (x: 'T) = X<float>\n\n[<Inline \"Math.floor($x)\">]\nlet Floor (x: 'T) = X<'T>\n\n[<Inline \"$x[0]\">]\nlet Fst (x: TupleProxy<'T1,'T2>) = X<'T1>\n\n[<Inline>]\nlet Hash<'T when 'T : equality> (x: 'T) = Unchecked.hash x\n\n[<Inline \"$x\">]\nlet Identity (x: 'T) = X<'T>\n\n[<Inline \"void $x\">]\nlet Ignore (x: 'T) = X<unit>\n\n[<Inline \"void ($x[0]++)\">]\nlet Increment (x: ref<int>) = ()\n\n[<Inline \"Infinity\">]\nlet Infinity = Unchecked.defaultof<double>\n\nlet InvalidOp (msg: string) : 'T = raise (System.InvalidOperationException(msg))\n\nlet InvalidArg (arg: string) (msg: string) : 'T = raise (System.ArgumentException(arg, msg))\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt (x: 'T) = X<int>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt16 (x: 'T) = X<int16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSingle (x: 'T) = X<single>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt32 (x: 'T) = X<int32>\n\nlet toUInt (x: float) : int =\n    (if x < 0. then Math.Ceil(x) else Math.Floor(x)) >>>. 0 |> As<int>\n\nlet toInt (x: float) : int =\n    let u = toUInt x\n    if u >= As<int> 2147483648L then u - As<int> 4294967296L else u\n\n[<Inline \"$x\">]\nlet ToEnum<'T> (x: int) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt64 (x: 'T) = X<int64>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt16 (x: 'T) = X<uint16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt32 (x: 'T) = X<uint32>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt64 (x: 'T) = X<uint64>\n\n[<Inline \"Math.log($x)\">]\nlet Log (x: 'T) = X<'T>\n\n[<Inline \"Math.log($x)/Math.log(10)\">]\nlet Log10 (x: 'T) = X<'T>\n\n[<Inline>]\nlet Max<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a > b then a else b\n\n[<Inline>]\nlet Min<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a < b then a else b\n\n[<Inline \"Infinity\">]\nlet InfinitySingle = single infinity\n\n[<Inline \"NaN\">]\nlet NaNSingle = single nan\n\n[<Inline \"NaN\">]\nlet NaN = nan\n\n[<Inline \"!$x\">]\nlet Not (x: bool) = X<bool>\n\nlet Pown<'T> (a: 'T) (n: int) =\n    let a = box a :?> double\n    let rec p n =\n        match n with\n        | 1 ->\n            a\n        | n when n % 2 = 0 ->\n            let b = p (n / 2)\n            b * b\n        | n ->\n            a * (p (n - 1))\n    p n\n\n[<Inline \"throw $e\">]\nlet Raise (e: exn) = X<'T>\n\n[<Inline \"[$x]\">]\nlet Ref (x: 'T) = X<ref<'T>>\n\n[<Inline \"Math.round($x)\">]\nlet Round (x: 'T) = X<'T>\n\n[<Inline \"$x\">]\nlet CreateSequence (x: seq<'T>) = X<seq<'T>>\n\n[<Macro(typeof<M.Sign>); JavaScript>]\nlet Sign<'T> (x: 'T) =\n    match As<int> x with\n    | 0            -> 0\n    | n when n < 0 -> -1\n    | _            -> 1\n\n[<Inline \"Math.sin($x)\">]\nlet Sin (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)-Math.exp(-$x))/2\">]\nlet Sinh (x: 'T) = x\n\n[<Inline \"$x[1]\">]\nlet Snd (x: TupleProxy<'T1,'T2>) = X<'T2>\n\n[<Inline \"Math.sqrt($x)\">]\nlet Sqrt (x: 'T1) = X<'T2>\n\n[<Macro(typeof<M.String>)>]\nlet ToString (x: 'T) = X<string>\n\n[<Inline \"Math.tan($x)\">]\nlet inline Tan (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp(2*$x)-1)/(Math.exp(2*$x)+1)\">]\nlet Tanh (x: 'T) = X<'T>\n\nlet inline Truncate<'T> (x: 'T) =\n    if x <. 0 then Ceiling x else Floor x\n\n[<Inline \"$x\">]\nlet Unbox (x: obj) = X<'T>\n\n[<Inline \"$x == null\">]\nlet IsNull (x: 'T) = X<bool>\n\n[<Inline>]\nlet Using t f =\n    try f t finally (t :> System.IDisposable).Dispose()\n\n[<Name \"KeyValue\">]\nlet KeyValuePattern (kvp: System.Collections.Generic.KeyValuePair<_,_>) =\n    (kvp.Key, kvp.Value)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Slice\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+OperatorIntrinsics, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorIntrinsicsProxy \n\nopen WebSharper.JavaScript\n\n[<Inline \"$s.slice($st,$e)\">]\nlet Slice (s: 'T) (st: int) (e: int) = X<'T>\n\n[<Inline \"$s.slice($st)\">]\nlet SliceStart (s: 'T) (st: int) = X<'T>\n\n[<Name \"string\">]\nlet GetStringSlice (source: string) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> \"\"\n\n[<Name \"array\">]\nlet GetArraySlice<'T> (source: 'T[]) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> [||]\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Name \"setArray\">]\nlet SetArraySlice (dst: _[]) start finish (src:_[]) = \n    let start  = (match start with None -> 0 | Some n -> n) \n    let finish = (match finish with None -> Array.length dst - 1 | Some n -> n) \n    F.SetArraySub dst start (finish - start + 1) src\n\n[<Name \"array2D\">]\nlet GetArraySlice2D (arr: _[,]) start1 finish1 start2 finish2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let len2 = (finish2 - start2 + 1)\n    F.GetArray2DSub arr start1 start2 len1 len2\n\n[<Name \"array2Dfix1\">]\nlet GetArraySlice2DFixed1 (arr: _[,]) fixed1 start2 finish2 = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    let dst = JavaScript.Array(len2)\n    for j = 0 to len2 - 1 do \n        F.SetArray dst.Self j (F.GetArray2D arr fixed1 (start2+j))\n    dst.Self\n\n[<Name \"array2Dfix2\">]\nlet GetArraySlice2DFixed2 (arr: _[,]) start1 finish1 fixed2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let dst = JavaScript.Array(len1)\n    for i = 0 to len1 - 1 do \n        F.SetArray dst.Self i (F.GetArray2D arr (start1+i) fixed2)\n    dst.Self\n\n[<Name \"setArray2Dfix1\">]\nlet SetArraySlice2DFixed1 (dst: _[,]) fixed1 start2 finish2 (src:_[]) = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    for j = 0 to len2 - 1 do\n        F.SetArray2D dst fixed1 (start2+j) (F.GetArray src j)\n\n[<Name \"setArray2Dfix2\">]\nlet SetArraySlice2DFixed2 (dst: _[,]) start1 finish1 fixed2 (src:_[]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    for i = 0 to len1 - 1 do\n        F.SetArray2D dst (start1+i) fixed2 (F.GetArray src i)\n\n[<Name \"setArray2D\">]\nlet SetArraySlice2D (dst: _[,]) start1 finish1 start2 finish2 (src:_[,]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    F.SetArray2DSub dst start1 start2 (finish1 - start1 + 1) (finish2 - start2 + 1) src\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Option\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.OptionModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OptionModuleProxy\n\nopen WebSharper.JavaScript\n\n[<Inline>]\nlet Bind f x =\n    match x with\n    | Some x -> f x\n    | None   -> None\n\n[<Inline>]\nlet Contains v o =\n    match o with\n    | Some x -> x = v\n    | None -> false\n\n[<Inline \"$x ? 1 : 0\">]\nlet Count (x: option<_>) = X<int>\n\n[<Inline>]\nlet DefaultValue v o =\n    match o with\n    | Some x -> x \n    | None -> v\n\n[<Inline>]\nlet DefaultWith f o =\n    match o with\n    | Some x -> x \n    | None -> f()\n\n[<Inline>]\nlet Exists p x =\n    match x with\n    | Some x -> p x\n    | None   -> false\n\n[<Name \"filter\">]\nlet Filter f o =\n    match o with\n    | Some x when f x -> o\n    | _ -> None\n\n[<Inline>]\nlet Flatten o =\n    match o with\n    | Some x -> x\n    | None -> None\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (x: option<'T>) : 'S =\n    match x with\n    | Some x -> f s x\n    | None   -> s\n\n[<Name \"foldBack\">]\nlet FoldBack f x s =\n    match x with\n    | Some x -> f x s\n    | None   -> s\n\n[<Inline>]\nlet ForAll p x =\n    match x with\n    | Some x -> p x\n    | None   -> true\n\n[<Inline \"$x.$0\"; Pure>]\nlet GetValue (x: option<'T>) = X<'T>\n\n[<Inline \"$x==null\">]\nlet IsNone (x: option<'T>) = false\n\n[<Inline \"$x!=null\">]\nlet IsSome (x: option<'T>) =  false\n\n[<Inline>]\nlet Iterate p x =\n    match x with\n    | Some x -> p x\n    | None   -> ()\n\n[<Inline>]\nlet Map f x =\n    match x with\n    | Some x -> Some (f x)\n    | None -> None\n\n[<Inline>]\nlet Map2 f x y =\n    match x, y with\n    | Some x, Some y -> Some (f x y)\n    | _ -> None\n\n[<Inline>]\nlet Map3 f x y z =\n    match x, y, z with\n    | Some x, Some y, Some z -> Some (f x y z)\n    | _ -> None\n\n[<Name \"ofNullable\">]\nlet OfNullable (o: System.Nullable<'T>) =\n    if o ==. null then None else Some o.Value                   \n\n[<Name \"ofObj\">]\nlet OfObj o = \n    if o ==. null then None else Some o\n\n[<Inline>]\nlet OrElse v o =\n    match o with\n    | Some x -> o \n    | None -> v\n\n[<Inline>]\nlet OrElseWith f o =\n    match o with\n    | Some x -> o \n    | None -> f()\n\n[<Name \"toArray\">]\nlet ToArray x =\n    match x with\n    | Some x -> [|x|]\n    | None   -> [||]\n\n[<Name \"toList\">]\nlet ToList x =\n    match x with\n    | Some x -> [x]\n    | None   -> []\n\n[<Name \"toNullable\">]\nlet ToNullable o =\n    match o with\n    | Some v -> System.Nullable(v)\n    | _ -> System.Nullable()\n\n[<Name \"toObj\">]\nlet ToObj o = \n    match o with\n    | Some v -> v\n    | None -> null\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Queue\">]\nmodule private WebSharper.QueueProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (a: obj) =\n    splice a 0 (a :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (a: obj) (el: 'T) =\n    Seq.exists ((=) el) (a :?> seq<'T>)\n\n[<JavaScript>]\nlet CopyTo (a: obj) (array: 'T[]) (index: int) =\n    Array.blit (a :?> 'T []) 0 array index (a :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Queue<_>>)>]\n[<WebSharper.Name \"WebSharper.Queue\">]\ntype private QueueProxy<'T when 'T : equality>\n\n    [<Inline \"$data\">] private (data: 'T []) =\n\n    [<Inline \"[]\">]\n    private new () = QueueProxy [||]\n\n    [<Inline>]\n    private new (s: seq<'T>) = QueueProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index: int) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Dequeue() = X<'T>\n\n    [<Inline \"$this.push($x)\">]\n    member this.Enqueue(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = data\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule RandomHelpers =\n    [<Inline \"Math.floor(Math.random() * 2147483648)\">]\n    let Next() = X<int>\n    \n    [<Inline \"Math.floor(Math.random() * $maxValue)\">]\n    let NextMax (maxValue: int) = X<int>\n\n[<Name \"Random\">]\n[<Proxy(typeof<System.Random>)>]\ntype internal RandomProxy() =\n    member this.Next() = Next()\n\n    member this.Next maxValue =\n        if maxValue < 0 then\n            failwith \"'maxValue' must be greater than zero.\"\n        else NextMax maxValue\n\n    member this.Next (minValue: int, maxValue: int) =\n        if minValue > maxValue then\n            failwith \"'minValue' cannot be greater than maxValue.\"\n        else minValue + NextMax (maxValue - minValue)\n\n    member this.NextBytes (buffer: byte[]) =\n        for i = 0 to buffer.Length - 1 do\n            buffer.[i] <- As (NextMax 256)\n\n    [<Inline \"Math.random()\">]\n    member this.NextDouble() = X<float>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Result\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ResultModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ResultModuleProxy\n    \nlet Bind f r =\n    match r with\n    | Ok x -> f x\n    | Error e -> Error e\n        \nlet Map f r =\n    match r with\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n        \nlet MapError f r =\n    match r with\n    | Ok x -> Ok x\n    | Error e -> Error (f e)    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.RuntimeHelpersProxy\n\n#nowarn \"40\"\n\nopen WebSharper.JavaScript\n\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"WebSharper.Seq.enumFinally\">]\nlet EnumerateThenFinally (s: seq<'T>) (f: unit -> unit) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get s with e -> f(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); f()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumUsing\">]\nlet EnumerateUsing<'T1,'T2,'T3 when 'T1 :> System.IDisposable\n                                and 'T2 :> seq<'T3>>\n        (x: 'T1) (f: 'T1 -> 'T2) : seq<'T3> =\n\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get (f x) with e -> x.Dispose(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); x.Dispose()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumWhile\">]\nlet EnumerateWhile (f: unit -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let rec next (en: Enumerator.T<IE<_>,'T>) =\n            match en.State with\n            | null ->\n                if f () then\n                    en.State <- Enumerator.Get s\n                    next en\n                else\n                    false\n            | e ->\n                if e.MoveNext() then\n                    en.Current <- e.Current\n                    true\n                else\n                    e.Dispose()\n                    en.State <- null\n                    next en\n        Enumerator.NewDisposing null (fun en -> safeDispose en.State) next)\n\n[<Name \"WebSharper.Control.createEvent\">]\nlet CreateEvent<'D, 'A when 'D : delegate<'A, unit> and 'D :> System.Delegate> \n        (add: 'D -> unit) \n        (remove: 'D -> unit)\n        (create: (obj -> 'A -> unit) -> 'D) : IEvent<'D, 'A> =\n    { new IEvent<'D, 'A> with\n        member this.AddHandler h = add h\n        member this.RemoveHandler h = remove h\n        member this.Subscribe (r: System.IObserver<'A>) =     \n            let h = create (fun _ args -> r.OnNext(args))\n            add h\n            { new System.IDisposable with member this.Dispose() = remove h }\n    }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Seq\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.SeqModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.SeqModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\nlet seqEmpty() =\n    failwith \"The input sequence was empty.\"\n\n[<Name \"allPairs\">]\nlet AllPairs (source1: seq<_>) (source2: seq<_>) =\n    let cached = Seq.cache source2\n    source1 |> Seq.collect (fun x -> cached |> Seq.map (fun y -> x,y))\n\n[<Name \"append\">]\nlet Append (s1: seq<'T>) (s2: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let e1 = Enumerator.Get s1\n        let first = ref true\n        Enumerator.NewDisposing e1 (fun x -> safeDispose x.State) (fun x ->\n            if x.State.MoveNext() then\n                x.Current <- x.State.Current\n                true\n            else \n                safeDispose x.State\n                x.State <- null\n                if !first then\n                    first := false\n                    x.State <- Enumerator.Get s2\n                    if x.State.MoveNext() then\n                        x.Current <- x.State.Current\n                        true\n                    else\n                        x.State.Dispose()\n                        x.State <- null\n                        false\n                else \n                    false)) \n\n[<Name \"average\">]\nlet Average<'T> (s: seq<'T>) : 'T =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> x))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'T> (sum / As<float> count)\n\n[<Name \"averageBy\">]\nlet AverageBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> (f x)))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'U> (sum / As<float> count)\n\n[<Name \"cache\">]\nlet Cache<'T> (s: seq<'T>) : seq<'T> =\n    let cache = JavaScript.Array<'T>()\n    let o  = ref (Enumerator.Get s)\n    Enumerable.Of <| fun () ->\n        let next (e: Enumerator.T<_,_>) =\n            if e.State < cache.Length then\n                e.Current <- cache.[e.State]\n                e.State   <- e.State + 1\n                true\n            else\n                let en = !o\n                if en = null then false\n                elif en.MoveNext() then\n                    e.State   <- e.State + 1\n                    e.Current <- en.Current\n                    cache.Push(e.Current) |> ignore\n                    true\n                else\n                    en.Dispose()\n                    o := null\n                    false\n        Enumerator.New 0 next\n\n/// IEnumerable is not supported.\n[<Inline \"$i\">]\nlet Cast<'T> (i: System.Collections.IEnumerable) = X<seq<'T>>\n\n[<Inline>]\nlet Contains (el: 'T) (s: seq<'T>) =\n    SeqContains el s\n\n[<Name \"choose\">]\nlet Choose (f: 'T -> option<'U>) (s: seq<'T>) : seq<'U> =\n    s\n    |> Seq.collect (fun x ->\n        match f x with\n        | Some v -> [v]\n        | None   -> [])\n\n[<Inline>]\nlet ChunkBySize (size: int) (s: seq<'T>) = SeqChunkBySize size s\n\n[<Name \"collect\">]\nlet Collect f s = Seq.concat (Seq.map f s)\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (s1: seq<'T>) (s2: seq<'T>) : int =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = 0\n    let mutable loop = true\n    while loop && r = 0 do\n        match e1.MoveNext(), e2.MoveNext() with\n        | true, false ->\n            r <- 1\n        | false, true ->\n            r <- -1\n        | false, false ->\n            loop <- false\n        | true, true ->\n            r <- f e1.Current e2.Current\n    r\n\n[<Name \"concat\">]\nlet Concat (ss: seq<#seq<'T>>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let outerE = Enumerator.Get ss\n        let rec next (st: Enumerator.T<Enumerator.IE<'T>,'T>) =\n            match st.State with\n            | null ->\n                if outerE.MoveNext() then\n                    st.State <- Enumerator.Get outerE.Current\n                    next st\n                else\n                    outerE.Dispose()\n                    false\n            | innerE ->\n                if innerE.MoveNext() then\n                    st.Current <- innerE.Current\n                    true\n                else\n                    (st :> System.IDisposable).Dispose()\n                    st.State <- null\n                    next st\n        Enumerator.NewDisposing null (fun st -> \n            safeDispose st.State \n            safeDispose outerE) \n            next)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (s: seq<'T>) : seq<'K * int> =\n    Seq.delay <| fun () ->\n        ArrayCountBy f (Array.ofSeq s) |> Seq.ofArray\n\n[<Name \"delay\">]\nlet Delay<'T> (f: unit -> seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get(f()))\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (s: seq<'T>) : seq<'T> =\n    Seq.distinctBy id s\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet<'K>()\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(f cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(f cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"splitInto\">]\nlet SplitInto count (s: seq<'T>) =\n    if count <= 0 then failwith \"Count must be positive\"\n    Seq.delay (fun () -> ArraySplitInto count (Array.ofSeq s) |> Seq.ofArray)   \n\n[<Inline>]\nlet Empty<'T> : seq<'T> = As [||]\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne<'T> (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then\n        let x = e.Current\n        if e.MoveNext() then\n            invalidOp \"Sequence contains more than one element\"\n        else x\n    else invalidOp \"Sequence contains no elements\"\n\n[<Inline>]\nlet Except (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    SeqExcept itemsToExclude s\n\n[<Name \"exists\">]\nlet Exists p (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- p e.Current\n    r\n\n[<Name \"exists2\">]\nlet Exists2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = false\n    while not r && e1.MoveNext() && e2.MoveNext() do\n        r <- p e1.Current e2.Current\n    r\n\n[<Name \"filter\">]\nlet Filter (f: 'T -> bool) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            let mutable loop = o.MoveNext()\n            let mutable c    = o.Current\n            let mutable res  = false\n            while loop do\n                if f c then\n                    e.Current <- c\n                    res       <- true\n                    loop      <- false\n                else\n                    if o.MoveNext() then\n                        c <- o.Current\n                    else\n                        loop <- false\n            res\n\n[<Name \"find\">]\nlet Find p (s: seq<_>) =\n    match Seq.tryFind p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex p (s: seq<_>) =\n    match Seq.tryFindIndex p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : 'S =\n    let mutable r = x\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"forall\">]\nlet ForAll p s =\n    not (Seq.exists (fun x -> not (p x)) s)\n\n[<Name \"forall2\">]\nlet ForAll2 p s1 s2 =\n    not (Seq.exists2 (fun x y -> not (p x y)) s1 s2)\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality) (s: seq<'T>) : seq<'K * seq<'T>> =\n    Seq.delay <| fun () ->\n        ArrayGroupBy f (Array.ofSeq s) |> As\n\n[<Name \"head\">]\nlet Head (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if e.MoveNext() then e.Current else InsufficientElements()\n\n[<Name \"init\">]\nlet Initialize (n: int) (f: int -> 'T) : seq<'T> =\n    Seq.take n (Seq.initInfinite f)\n\n[<Name \"initInfinite\">]\nlet InitializeInfinite (f: int -> 'T) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New 0 <| fun e ->\n            e.Current <- f e.State\n            e.State   <- e.State + 1\n            true\n\n[<Name \"isEmpty\">]\nlet IsEmpty (s: seq<'T>) : bool =\n    use e = Enumerator.Get s\n    not (e.MoveNext())\n\n[<Name \"iter\">]\nlet Iterate p (s: seq<_>) =\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p e.Current\n\n[<Name \"iter2\">]\nlet Iterate2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        p e1.Current e2.Current\n\n[<Name \"iteri\">]\nlet IterateIndexed p (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p i e.Current\n        i <- i + 1\n\n[<Inline>]\nlet Last (s: seq<_>) =\n    SeqLast s\n\n[<Name \"length\">]\nlet Length (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> en.Dispose()) <| fun e ->\n            if en.MoveNext() then\n                e.Current <- f en.Current\n                true\n            else\n                false\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Seq.map2 f (Seq.initInfinite id) s\n\n[<Name \"map2\">]\nlet Map2 (f: 'T -> 'U -> 'V) (s1: seq<'T>) (s2: seq<'U>) : seq<'V> =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() then\n                e.Current <- f e1.Current e2.Current\n                true\n            else\n                false\n\n[<Name \"maxBy\">]\nlet MaxBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"minBy\">]\nlet MinBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"max\">]\nlet Max (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x > m then\n            m <- x\n    m\n\n[<Name \"min\">]\nlet Min (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x < m then\n            m <- x\n    m\n\n[<Name \"nth\">]\nlet Get index (s: seq<'T>) =\n    if index < 0 then\n        failwith \"negative index requested\"\n    let mutable pos = -1\n    use e = Enumerator.Get s\n    while pos < index do\n        if not (e.MoveNext()) then\n            InsufficientElements()\n        pos <- pos + 1\n    e.Current\n\n[<Inline>]\nlet Item index (s: seq<'T>) = Get index s\n\n[<Inline \"$a\">]\n[<Name \"ofArray\">]\nlet OfArray (a: 'T[]) = X<seq<'T>>\n\n[<Inline \"$l\">]\n[<Name \"ofList\">]\nlet OfList (l: list<'T>) = X<seq<'T>>\n\n[<Name \"pairwise\">]\nlet Pairwise (s: seq<'T>) : seq<'T * 'T> =\n    Seq.windowed 2 s\n    |> Seq.map (fun x -> (x.[0], x.[1]))\n\n[<Name \"pick\">]\nlet Pick p (s: seq<_>) =\n    match Seq.tryPick p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"readOnly\">]\nlet ReadOnly (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get s)\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (source: seq<'T>) : 'T =\n    use e = Enumerator.Get source\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable r = e.Current\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : seq<'S> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing false (fun _ -> en.Dispose()) <| fun e ->\n            if e.State then\n                if en.MoveNext() then\n                    e.Current <- f e.Current en.Current\n                    true\n                else\n                    false\n            else\n                e.Current <- x\n                e.State <- true\n                true\n\n[<Inline \"[$x]\">]\n[<Name \"singleton\">]\nlet Singleton<'T> (x: 'T) = X<seq<'T>>\n\n[<Name \"skip\">]\nlet Skip (n: int) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                for i = 1 to n do\n                    if not (o.MoveNext()) then\n                        InsufficientElements()\n                e.State <- false\n            if o.MoveNext() then\n                e.Current <- o.Current\n                true\n            else\n                false))\n\n[<Name \"skipWhile\">]\nlet SkipWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                let mutable go = true\n                let mutable empty = false\n                while go do\n                    if o.MoveNext() then\n                        if not (f o.Current) then go <- false \n                    else \n                        go <-false\n                        empty <- true\n                e.State <- false\n                if empty then \n                    false \n                else\n                    e.Current <- o.Current\n                    true\n            else\n                if o.MoveNext() then\n                    e.Current <- o.Current\n                    true\n                else\n                    false))\n\n[<Name \"sort\">]\nlet Sort<'T when 'T : comparison> (s: seq<'T>) =\n    Seq.sortBy id s\n\n[<Name \"sortBy\">]\nlet SortBy<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        Array.sortInPlaceBy f array\n        array :> _)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        ArraySortInPlaceByDescending f array\n        array :> _)\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T : comparison> (s: seq<'T>) =\n    SortByDescending id s\n\n[<Name \"sum\">]\nlet Sum<'T> (s: seq<'T>) : 'T =\n    box (Seq.fold (fun s x -> s + (box x :?> _)) 0. s) :?> _\n\n[<Name \"sumBy\">]\nlet SumBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    box (Seq.fold (fun s x -> s + (box (f x) :?> _)) 0. s) :?> _\n\n[<Name \"take\">]\nlet Take (n: int) (s: seq<'T>) : seq<'T> =\n    if n < 0 then\n        InputMustBeNonNegative()\n    Enumerable.Of (fun () ->\n        let e = ref (Enumerator.Get s)\n        Enumerator.NewDisposing 0 (fun _ -> safeDispose !e) (fun o ->\n            o.State <- o.State + 1\n            if o.State > n then false else\n            let en = !e\n            if en = null then InsufficientElements()\n            elif en.MoveNext() then\n                o.Current <- en.Current\n                if o.State = n then\n                    en.Dispose()\n                    e := null\n                true\n            else\n                en.Dispose()\n                e := null\n                InsufficientElements()\n        )\n    )\n\n[<Name \"takeWhile\">]\nlet TakeWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        while e.MoveNext() && f e.Current do\n            yield e.Current\n    }\n\n[<Inline>]\nlet ToArray (s: seq<'T>) =\n    Array.ofSeq s\n\n[<Inline>]\nlet ToList (s: seq<'T>) = List.ofSeq s\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<#seq<'T>>) : seq<seq<'T>> =\n    Seq.delay (fun () ->\n        ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofSeq)) |> As\n    )\n\n[<Name \"truncate\">]\nlet Truncate (n: int) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        let i = ref 0\n        while e.MoveNext() && !i < n do\n            incr i\n            yield e.Current\n    }\n\n[<Name \"tryFind\">]\nlet TryFind ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r.IsNone && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            r <- Some x\n    r\n\n[<Inline>]\nlet TryFindBack ok (s: seq<_>) =\n    ArrayTryFindBack ok (Array.ofSeq s) \n\n[<Inline>]\nlet TryHead (s: seq<'T>) = SeqTryHead s\n\n[<Inline>]\nlet TryItem i (s: seq<'T>) = SeqTryItem i s\n\n[<Inline>]\nlet TryLast (s: seq<'T>) =  SeqTryLast s\n\n[<Name \"findBack\">]\nlet FindBack p (s: seq<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable loop = true\n    let mutable i = 0\n    while loop && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            loop <- false\n        else\n            i <- i + 1\n    if loop then None else Some i\n\n[<Inline>]\nlet TryFindIndexBack ok (s: seq<_>) =\n    ArrayTryFindIndexBack ok (Array.ofSeq s) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: seq<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryPick\">]\nlet TryPick f (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r = None && e.MoveNext() do\n        r <- f e.Current\n    r\n\n[<Name \"unfold\">]\nlet Unfold<'S, 'T> (f: 'S -> option<'T * 'S>) (s: 'S) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New s <| fun e ->\n            match f e.State with\n            | Some (t, s) ->\n                e.Current <- t\n                e.State  <- s\n                true\n            | None ->\n                false\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: seq<'T>) : seq<'T []> =\n    if windowSize <= 0 then\n        failwith \"The input must be positive.\"\n    seq {\n        use e = Enumerator.Get s\n        let q = new System.Collections.Generic.Queue<'T>()\n        while q.Count < windowSize && e.MoveNext() do\n            q.Enqueue e.Current\n        if q.Count = windowSize then\n            yield q.ToArray()\n            while e.MoveNext() do\n                ignore (q.Dequeue())\n                q.Enqueue e.Current\n                yield q.ToArray()\n    }\n\n[<Name \"zip\">]\nlet Zip (s1: seq<'T>) (s2: seq<'U>) =\n    Seq.map2 (fun x y -> x, y) s1 s2\n\n[<Name \"map3\">]\nlet Map3 f (s1: seq<_>) (s2: seq<_>) (s3: seq<_>) =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        let e3 = Enumerator.Get s3\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose(); e3.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() && e3.MoveNext() then\n                e.Current <- f e1.Current e2.Current e3.Current\n                true\n            else\n                false\n\n[<Name \"zip3\">]\nlet Zip3 (s1: seq<'T>) (s2: seq<'U>) (s3: seq<'V>) : seq<'T * 'U * 'V> =\n    Map3 (fun x y z -> x, y, z) s1 s2 s3\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (s1: seq<'T1>)\n                        (s2: seq<'T2>) : 'S =\n    Array.fold2 f s (Array.ofSeq s1) (Array.ofSeq s2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (s: seq<_>) state =\n    Array.foldBack f (Array.ofSeq s) state\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (s1: seq<_>) (s2: seq<_>) s =\n    Array.foldBack2 f (Array.ofSeq s1) (Array.ofSeq s2) s\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    let mutable i = 0\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        f i e1.Current e2.Current\n        i <- i + 1\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    Map3 f (Seq.initInfinite id) s1 s2\n\n[<Name \"mapFold\">]\nlet MapFold<'T,'S,'R> f zero s =\n    ArrayMapFold<'T,'S,'R> f zero (Seq.toArray s)\n    |> As<seq<'R> * 'S>\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T,'S,'R> f s zero =\n    ArrayMapFoldBack<'T,'S,'R> f (Seq.toArray s) zero\n    |> As<seq<'R> * 'S>\n\n[<Name \"permute\">]\nlet Permute f (s: seq<_>) =\n    Seq.delay (fun () -> Seq.ofArray (Array.permute f (Array.ofSeq s)))\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (s: seq<_>) =\n    Array.reduceBack f (Array.ofSeq s)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    if size < 0 then InputMustBeNonNegative()\n    seq { for i in 0 .. size - 1 -> value }\n\n[<Name \"rev\">]\nlet Reverse (s: seq<'T>) =\n    Seq.delay (fun () -> Array.rev (Seq.toArray s) |> Array.toSeq)\n    \n[<Name \"scanBack\">]\nlet ScanBack f (l: seq<_>) s =\n    Seq.delay (fun () -> Seq.ofArray (Array.scanBack f (Array.ofSeq l) s))\n\n[<Name \"indexed\">]\nlet Indexed (s : seq<'T>) : seq<int * 'T> =\n    Seq.mapi (fun a b -> (a, b)) s\n\n[<Name \"sortWith\">]\nlet SortWith f (s: seq<_>) =\n    Seq.delay (fun () -> \n        let a = Array.ofSeq s\n        Array.sortInPlaceWith f a\n        Seq.ofArray a)\n\n[<Name \"tail\">]\nlet Tail<'T> (s : seq<'T>) : seq<'T> =\n    Seq.skip 1 s\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : seq<'T>) : seq<'T> =\n    Filter predicate s\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Stack\">]\nmodule private WebSharper.StackProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (stack: obj) =\n    splice stack 0 (stack :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (stack: obj) (el: 'T) =\n    Seq.exists ((=) el) (stack :?> 'T[])\n    \n[<JavaScript>]\nlet CopyTo (stack: obj) (array: 'T[]) (index: int) =\n    Array.blit array 0 array index (stack :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Stack<_>>)>]\n[<Name \"WebSharper.Stack\">]\ntype private StackProxy<'T when 'T : equality> =\n\n    [<Inline \"[].concat($s).reverse()\">]\n    private new (s: 'T []) = {}\n\n    [<Inline \"[]\">]\n    new () = {}\n\n    [<Inline>]\n    private new (s: seq<'T>) = StackProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) : bool = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Pop() = X<'T>\n\n    [<Inline \"$this.unshift($x)\">]\n    member this.Push(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = X<'T[]>\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Strings\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.StringModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.StringProxy\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\nlet Compare (x: string) (y: string) = compare x y\n\nlet CopyTo (s: string) (o: int) (d: char []) (off: int) (ct: int) =\n    Array.blit (s.ToCharArray()) o d off ct\n\n[<Direct \"$x.substring($x.length - $s.length) == $s\">]\nlet EndsWith (x: string) (s: string) = X<bool>\n\n[<Direct \"$s.indexOf($c,$i)\">]\nlet IndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$x.substring(0,$index-1)+$s+$x.substring($index)\">]\nlet Insert (x: string) (index: int) (s: string) = X<string>\n\n[<Direct \"$x == null || $x == ''\">]\nlet IsNullOrEmpty (x: string) = X<bool>\n\n[<Direct \"\"\"$x == null || /^\\s*$/.test($x)\"\"\">]\nlet IsNullOrWhiteSpace (x: string) = X<bool>\n\n[<Direct \"$s.lastIndexOf($c,$i)\">]\nlet LastIndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$n>$s.length?Array($n-$s.length+1).join($c)+$s:$s\">]\nlet PadLeftWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadLeft (s: string) (n: int) =\n    PadLeftWith s n ' '\n\n[<Direct \"$n>$s.length?$s+Array($n-$s.length+1).join($c):$s\">]\nlet PadRightWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadRight (s: string) (n: int) =\n    PadRightWith s n ' '\n\n[<Direct \"$x.substring(0,$ix) + $x.substring($ix+$ct)\">]\nlet Remove (x: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$string.replace($search,$replace)\">]\nlet ReplaceOnce string search replace = X<string>\n\nlet Replace (subject: string) (search: string) (replace: string) =\n    let rec replaceLoop (subj: string) =\n        let index = subj.IndexOf(search)\n        if index <> -1 then\n            let replaced = ReplaceOnce subj search replace\n            let nextStartIndex = index + replace.Length\n            (replaced.Substring(0, index + replace.Length)) +\n                (replaceLoop (replaced.Substring(nextStartIndex)))\n        else subj\n    replaceLoop subject\n\nlet ReplaceChar (s: string) (oldC: char) (newC: char) =\n    Replace s (string oldC) (string newC)\n\n[<Direct \"$s.substr($ix,$ct)\">]\nlet Substring (s: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$t.substring(0,$s.length) == $s\">]\nlet StartsWith (t: string) (s: string) = X<bool>\n\nlet ToCharArray (s: string) = Array.init s.Length (fun x -> s.[x])\n\nlet ToCharArrayRange (s: string) (startIndex: int) (length: int) =\n    Array.init length (fun i -> s.[startIndex + i])\n\n[<Direct @\"$s.replace(/^\\s+/,'').replace(/\\s+$/,'')\">]\nlet Trim (s: string) = X<string>\n\n[<Direct @\"$s.replace(/^\\s+/,'')\">]\nlet TrimStartWS (s: string) = X<string>\n\nlet TrimStart (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimStartWS s\n    else\n        let mutable i = 0\n        let mutable go = true\n        while i < s.Length && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i + 1 \n            else go <- false\n        s.Substring(i)\n\n[<Direct @\"$s.replace(/\\s+$/,'')\">]\nlet TrimEndWS (s: string) = X<string>\n\nlet TrimEnd (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimEndWS s\n    else \n        let mutable i = s.Length - 1\n        let mutable go = true\n        while i >= 0 && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i - 1 \n            else go <- false\n        s.Substring(0, i + 1)\n\n[<Direct \"$values.join($sep)\">]\nlet Join (sep: string) (values: string []) = X<string>\n\n[<Direct \"$str.split($pat)\">]\nlet SplitWith (str: string) (pat: obj) = X<string[]>\n\n[<Inline \"new RegExp($pat)\">]\nlet MakeRegexp (pat: string) = X<obj>\n\n[<Direct @\"$s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\">]\nlet RegexEscape (s: string) = X<string>\n\nlet Split (s: string) (pat: obj) (opts: System.StringSplitOptions) =\n    let res = SplitWith s pat\n    if opts ===. System.StringSplitOptions.RemoveEmptyEntries then\n        Array.filter (fun x -> x !==. \"\") res\n    else\n        res\n\nlet SplitChars (s: string) (sep: char[]) (opts: System.StringSplitOptions) =\n    let re = \"[\" + RegexEscape (new System.String(sep)) + \"]\"\n    Split s (MakeRegexp re) opts\n\nlet SplitStrings (s: string) (sep: string[]) (opts: System.StringSplitOptions) =\n    let re = String.concat \"|\" (Array.map RegexEscape sep)\n    Split s (MakeRegexp re) opts\n\nlet Filter f (s: string) =\n    System.String.Concat(s |> Seq.choose (fun c -> if f c then Some (string c) else None) |> Array.ofSeq)\n\n[<Inline \"$text.replace($pattern, $replace)\">]\nlet ReplaceString (pattern: RegExp) (replace: 'obj) (text: string) = X<string>\n\nlet SFormat (format: string) (args: obj[]) =\n    let pattern = RegExp(\"{(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?}\", \"g\")\n    format\n    |> ReplaceString pattern (FuncWithArgs(fun (_, i, w) ->\n        let r = string args.[JS.Plus i]\n\n        if w <> JS.Undefined then\n            let w1 = JS.Plus w\n            let w2 = abs w1\n\n            if w2 > r.Length then\n                if w1 > 0 then r.PadLeft(w2)\n                else r.PadRight(w2)\n            else r\n        else r\n    ))\n\n[<Proxy(typeof<string>)>]\ntype private StringProxy =\n\n    [<Inline \"''\">]\n    new () = {}\n\n    [<Inline \"$chars.join('')\">]\n    new (chars: char []) = {}\n\n    [<Inline>]\n    static member CtorProxy(ch: char, n: int) = String.replicate n (string ch)\n\n    [<Inline \"$chars.slice($i, $i + $j).join('')\">]\n    new (chars: char [], i: int, j: int) = {}\n\n    member this.Chars  with [<Inline \"$this[$pos]\">]\n                            get (pos: int) = X<char>\n\n    [<Inline \"$this\">]\n    member this.Clone() = this :> obj\n\n    [<Inline \"$this\">]\n    member this.Copy() = this\n\n    [<Inline>]\n    static member Compare(x: string, y: string) =\n        Unchecked.compare x y\n\n    [<Inline>]\n    static member Compare(x: string, y: string, b: bool) =\n        if b then\n            Unchecked.compare (x.ToLower()) (y.ToLower())\n        else\n        Unchecked.compare x y\n\n    [<Inline>]\n    member this.CompareTo(s: string) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline>]\n    static member Concat(strings: string seq) =\n        Join \"\" (Array.ofSeq strings)\n\n    [<Inline>]\n    static member Concat<'T>(objs: 'T seq) : string =\n        Join \"\" (Array.ofSeq (objs |> Seq.map (fun o -> o.ToString())))\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string) = s1 + s2\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string) = s1 + s2 + s3\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string, s4: string) = s1 + s2 + s3 + s4\n\n    [<Inline>]\n    static member Concat(o1: obj) = string o1\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj) = string o1 + string o2\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj) = string o1 + string o2 + string o3\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj, o4: obj) = string o1 + string o2 + string o3 + string o4\n\n    [<Inline \"$strings.join('')\">]\n    static member Concat([<System.ParamArray>] strings: string[]) = X<string>\n\n    [<Inline>]\n    static member Concat(objs: obj[]) =\n        Join \"\" (As<string[]> objs)\n\n    [<Inline \"$this.indexOf($s) != -1\">]\n    member this.Contains(s: string) = X<bool>\n\n    [<Inline>]\n    member this.CopyTo(s: int, d: char [], off: int, ct: int) =\n        CopyTo (As this) s d off ct\n\n    static member Empty with [<Inline \"''\">] get () = X<string>\n\n    [<Inline>]\n    member this.EndsWith(other: string) = EndsWith (As this) other\n\n    [<Inline \"$x == $y\">]\n    static member Equals(x: string, y: string) = X<bool>\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: string) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get (unbox<seq<char>> this) |> As<System.CharEnumerator>\n\n    [<Inline \"$this.indexOf($s)\">]\n    member this.IndexOf(s: string) = X<int>\n\n    [<Inline \"$this.indexOf($c)\">]\n    member this.IndexOf(c: char) = X<int>\n\n    [<Inline \"$this.indexOf($s,$i)\">]\n    member this.IndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.IndexOf(c: char, i: int) = IndexOf (As this) c i\n\n    [<Inline>]\n    static member IsNullOrEmpty(x: string) = IsNullOrEmpty x\n\n    [<Inline>]\n    static member IsNullOrWhiteSpace(x: string) = IsNullOrWhiteSpace x\n\n    member this.Item\n        with    [<Inline \"$this[$pos]\">]\n                get (pos: int) = X<char>\n\n    [<Inline>]\n    static member Join(sep: string, values: string seq) =\n        Join sep (Array.ofSeq values)\n\n    [<Inline>]\n    static member Join(sep: string, [<System.ParamArray>] values: string[]) =\n        Join sep values\n\n    [<Inline \"$this.lastIndexOf($s)\">]\n    member this.LastIndexOf(s: string) = X<int>\n\n    [<Inline \"$this.lastIndexOf($c)\">]\n    member this.LastIndexOf(c: char) = X<int>\n\n    [<Inline \"$this.lastIndexOf($s,$i)\">]\n    member this.LastIndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.LastIndexOf(c: char, i: int) =\n        LastIndexOf (As this) c i\n\n    member this.Length with [<Inline \"$this.length\">]\n                            get () = X<int>\n\n    [<Inline>]\n    member this.PadLeft(i: int) =\n        PadLeft (As this) i\n\n    [<Inline>]\n    member this.PadLeft(i: int, c: char) =\n        PadLeftWith (As this) i c\n\n    [<Inline>]\n    member this.PadRight(i: int) =\n        PadRight (As this) i\n\n    [<Inline>]\n    member this.PadRight(i: int, c: char) =\n        PadRightWith (As this) i c\n\n    [<Inline \"$this.substring(0,$ix)\">]\n    member this.Remove(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Remove(ix: int, count: int) = Remove (As this) ix count\n\n    [<Inline>]\n    member this.ToCharArray() = ToCharArray (As this)\n\n    [<Inline>]\n    member this.Replace(subj: string, repl: string) =\n        Replace (As this) subj repl\n\n    [<Inline>]\n    member this.Replace(subj: char, repl: char) =\n        ReplaceChar (As this) subj repl\n\n    [<Inline>]\n    member this.Split([<System.ParamArray>] sep: char[]) =\n        SplitChars (As this) sep  System.StringSplitOptions.None\n\n    [<Inline>]\n    member this.Split(sep: char[], opts: System.StringSplitOptions) =\n        SplitChars (As this) sep opts\n\n    [<Inline>]\n    member this.Split(sep: string[], opts: System.StringSplitOptions) =\n        SplitStrings (As this) sep opts\n\n    [<Inline>]\n    member this.StartsWith(s: string) =\n        StartsWith (As this) s\n\n    [<Inline \"$this.substring($ix)\">]\n    member this.Substring(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Substring(ix: int, ct: int) =\n        Substring (As this) ix ct\n\n    [<Inline>]\n    member this.ToCharArray(i: int, l: int) =\n        ToCharArrayRange (As this) i l\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n    \n    [<Inline \"$this.toLowerCase()\">]\n    member this.ToLower() = X<string>\n\n    [<Inline \"$this.toUpperCase()\">]\n    member this.ToUpper() = X<string>\n\n    [<Inline>]\n    member this.Trim() = Trim (As this)\n\n    [<Inline>]\n    member this.TrimStart(t: char[]) = TrimStart (As this) t\n\n    [<Inline>]\n    member this.TrimEnd(t: char[]) = TrimEnd (As this) t\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: string, b: string) = X<string>\n\n    [<Inline>]\n    static member (+) (a: obj, b: string) = string a + b \n\n    [<Inline>]\n    static member (+) (a: string, b: obj) = a + string b\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: string, b: string) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: string, b: string) = X<bool>\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, [<System.ParamArray>] arguments: obj []) = SFormat format arguments\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj): string = SFormat format [|arg0|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj): string = SFormat format [|arg0; arg1|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj, arg2: obj): string = SFormat format [|arg0; arg1; arg2|]\n\nlet protect (s : string) =\n    if s = null then \"\" else s\n\n[<Inline \"$strings.join($sep)\">]\nlet join (strings: string[]) (sep: string) = X<string>\n\n[<Name \"collect\">]\nlet Collect (f: char -> string) (s: string) : string =\n    System.String.Concat(Array.init s.Length (fun i -> f s.[i]))\n\n[<Name \"concat\">]\nlet Concat (separator: string) (strings: seq<string>) : string =\n    join (Seq.toArray strings) separator\n\n[<Name \"exists\">]\nlet Exists (f: char -> bool) (s: string) : bool =\n    Seq.exists f (protect s)\n\n[<Name \"forall\">]\nlet ForAll (f: char -> bool) (s: string) : bool =\n    Seq.forall f (protect s)\n\n[<Name \"init\">]\nlet Initialize (count: int) (f: int -> string) : string =\n    System.String.Concat(Array.init count f)\n\n[<Name \"iter\">]\nlet Iterate (f: char -> unit) (s: string) : unit =\n    Seq.iter f (protect s)\n\n[<Name \"iteri\">]\nlet IterateIndexed (f: int -> char -> unit) (s: string) : unit =\n    Seq.iteri f (protect s)\n\n[<Name \"length\">]\nlet Length (s: string) : int =\n    (protect s).Length\n\n[<Name \"map\">]\nlet Map (f: char -> char) (s: string) : string =\n    Collect (fun x -> string (f x)) (protect s)\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> char -> char) (s: string) : string =\n    System.String.Concat (Seq.toArray (Seq.mapi (fun i x -> string (f i x)) s))\n\n[<Name \"replicate\">]\nlet Replicate (count: int) (s: string) : string =\n    System.String.Concat(Array.create count s)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nopen System.Threading\nopen System.Threading.Tasks\n\n[<Proxy(typeof<Task>); Name \"Task\">]\ntype private TaskProxy(action: System.Action, token: CT, status, exc) =\n    [<Name \"status\">]\n    let mutable status = status\n    [<Name \"continuations\">]\n    let continuations = [||] : TaskProxy[]\n    [<Name \"exc\">]\n    let mutable exc = exc : System.AggregateException\n\n    abstract Execute : unit -> unit\n    default this.Execute() = action.Invoke()\n\n    member this.Exception = exc\n\n    member this.IsCanceled = \n        status = TaskStatus.Canceled\n\n    member this.IsCompleted = \n        status = TaskStatus.RanToCompletion || status = TaskStatus.Faulted || status = TaskStatus.Canceled\n\n    member this.IsFaulted =\n        status = TaskStatus.Faulted\n\n    member this.Status = status\n\n    new (action) = TaskProxy(action, CT.None, TaskStatus.Created, null)\n\n    new (action, ct) = TaskProxy(action, ct, TaskStatus.Created, null)\n    \n    new (action: System.Action<obj>, obj: obj) = TaskProxy((fun () -> action.Invoke(obj)), CT.None, TaskStatus.Created, null)\n\n    new (action: System.Action<obj>, obj: obj, ct: CT) = TaskProxy((fun () -> action.Invoke(obj)), ct, TaskStatus.Created, null)\n\n    member this.OnCompleted(cont : unit -> unit) =\n        if this.IsCompleted then \n            cont()\n        else \n            if this.Status = TaskStatus.Created then this.Start()\n            this.ContinueWith(fun (_: Task) -> cont()) |> ignore\n\n    member this.RunContinuations() =\n        for c in continuations do\n            c.StartContinuation()    \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task>) =\n        this.ContinueWith(action, CT.None)\n\n    member this.ContinueWith(action: System.Action<Task>, ct) =\n        let res = TaskProxy((fun () -> action.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task> res\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task,'T>) =\n        this.ContinueWith(func, CT.None)\n\n    member this.ContinueWith(func: System.Func<Task,'T>, ct) =\n        let res = TaskProxy<'T>((fun () -> func.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null, JS.Undefined)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task<'T>> res\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke (t, obj))\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke (t, obj)), ct)\n\n    member this.StartContinuation() =\n        if status = TaskStatus.WaitingForActivation then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                if status = TaskStatus.WaitingToRun then\n                    status <- TaskStatus.Running\n                    try\n                        this.Execute()\n                        status <- TaskStatus.RanToCompletion\n                    with e ->\n                        exc <- System.AggregateException(e)\n                        status <- TaskStatus.Faulted\n                    this.RunContinuations()\n            )\n\n    member this.Start() =\n        if status = TaskStatus.Created then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                status <- TaskStatus.Running\n                try\n                    this.Execute()\n                    status <- TaskStatus.RanToCompletion\n                with\n                | :? OCE as e when e.CancellationToken = token ->\n                    Console.Log(\"Task cancellation caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Canceled\n                | e ->\n                    Console.Log(\"Task error caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Faulted\n                this.RunContinuations()\n            )\n        else\n            invalidOp \"Task not in initial state\"\n        \n    static member FromCanceled ct = \n        As<Task> (TaskProxy(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException())))\n\n    static member FromCanceled(ct: CT) = \n        As<Task<_>> (TaskProxy<_>(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException()), As null)) \n\n    static member FromException (exc: exn) =\n        As<Task> (TaskProxy(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc)))\n\n    static member FromException (exc: exn) =\n        As<Task<_>> (TaskProxy<_>(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc), As null))\n\n    static member FromResult (res: 'T) = \n        As<Task<'T>> (TaskProxy<'T>(null, CT.None, TaskStatus.RanToCompletion, null, res)) \n\n    [<Inline>]\n    static member Run(action : System.Action) =\n       TaskProxy.Run(action, CT.None)\n        \n    static member Run(action : System.Action, ct) =\n        let res = TaskProxy(action, ct, TaskStatus.Created, null)\n        res.Start()\n        As<Task> res\n\n    [<Inline>]\n    static member Run(func : System.Func<Task>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled ct : Task else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    [<Inline>]\n    static member Run(func : System.Func<'T>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<'T>, ct) =\n        let res = TaskProxy<'T>(func, ct, TaskStatus.Created, null, JS.Undefined)\n        res.Start()\n        As<Task<'T>> res   \n\n    [<Inline>]\n    static member Run(func : System.Func<Task<'T>>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task<'T>>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled<'T> ct else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    static member Delay(time: int) =   \n        Async.StartAsTask (Async.Sleep time) :> Task\n             \n    static member Delay(time: int, ct) =        \n        Async.StartAsTask (Async.Sleep time, cancellationToken = ct) :> Task\n\n    [<Inline>]\n    static member Delay(time: System.TimeSpan) =        \n        TaskProxy.Delay(As<int> time)\n             \n    [<Inline>]\n    static member Delay(time: System.TimeSpan, ct) =        \n        TaskProxy.Delay(As<int> time, ct)\n\n    static member WhenAny(tasks: Task[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAny(tasks: Task<'T>[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<Task<'T>>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task<'T>>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun t -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    if !completed = target then tcs.TrySetResult() |> ignore \n            ) |> ignore\n        tcs.Task :> Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task<'T>[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let results = JavaScript.Array(target)\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun (t: Task<'T>) -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    results.[i] <- t.Result\n                    if !completed = target then tcs.SetResult results.Self\n            ) |> ignore\n        tcs.Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task<'T>>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member Yield() =\n        new Task(fun () -> ()) |> As<System.Runtime.CompilerServices.YieldAwaitable>  \n\nand [<Proxy(typeof<Task<_>>); Name \"Task1\">] private TaskProxy<'T>(func: System.Func<'T>, token: CT, status, exc, result) =\n    inherit TaskProxy(null, token, status, exc)\n    \n    [<Name \"result\">]\n    let mutable result = result\n\n    new (func) = TaskProxy<'T>(func, CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func, ct) = TaskProxy<'T>(func, ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj) = TaskProxy<'T>((fun () -> func.Invoke obj), CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj, ct: CT) = TaskProxy<'T>((fun () -> func.Invoke obj), ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    member this.Result = \n        match this.Status with\n        | TaskStatus.RanToCompletion -> result\n        | TaskStatus.Faulted\n        | TaskStatus.Canceled -> raise this.Exception \n        | _ -> invalidOp \"Task has not been completed, has no Result\"\n\n    override this.Execute () =\n        result <- func.Invoke()\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>) =\n        this.ContinueWith(As<System.Action<Task>> action)\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>, ct) =\n        this.ContinueWith(As<System.Action<Task>> action, ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>, ct) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func, ct) \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke(t, obj)) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke(t, obj)), ct) \n\n[<Proxy(typeof<TaskCompletionSource<_>>)>]\n[<Name \"TaskCompletionSource\">]\ntype private TaskCompletionSourceProxy<'T>() =\n    let task = new TaskProxy<'T>(null, CT.None, TaskStatus.WaitingForActivation, null, JS.Undefined)\n\n    member this.Task = As<Task<'T>> task\n\n    member this.SetCanceled() =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Canceled\n        task.RunContinuations()\n\n    member this.SetException(exc: exn) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Faulted\n        task?exc <- System.AggregateException(exc)\n        task.RunContinuations()\n\n    member this.SetException(exs : seq<exn>) =\n        this.SetException(System.AggregateException(exs))\n\n    member this.SetResult(res: 'T) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.RanToCompletion\n        task?result <- res \n        task.RunContinuations()\n\n    member this.TrySetCanceled() =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetCanceled(ct: CT) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task?token <- ct\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exc: exn) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Faulted\n            task?exc <- System.AggregateException(exc)\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exs : seq<exn>) =\n        this.TrySetException(System.AggregateException(exs))\n\n    member this.TrySetResult(res: 'T) =        \n        if not task.IsCompleted then\n            task?status <- TaskStatus.RanToCompletion\n            task?result <- res \n            task.RunContinuations()\n            true\n        else false\n    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements generic comparison, equality and hashing.\n[<WebSharper.Name \"Unchecked\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+Unchecked, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.UncheckedProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$a instanceof Array\">]\nlet isArray (a: obj) = X<bool>\n\n[<Inline \"$a instanceof Date\">]\nlet isDate (a: obj) = X<bool>\n\nlet rec compareArrays (a: obj []) (b: obj []) =\n    if a.Length < b.Length   then -1\n    elif a.Length > b.Length then 1\n    else\n        let mutable cmp = 0\n        let mutable i = 0\n        while cmp = 0 && i < a.Length do\n            cmp <- Unchecked.compare a.[i] b.[i]\n            i <- i + 1\n        cmp\n\n[<Inline \"$d.getTime()\">]\nlet getTime (d: obj) : int = X\n\nlet rec compareDates (a: obj) (b: obj) =\n    compare (getTime a) (getTime b)\n\n/// Compares two values generically.\nlet Compare<'T> (a: 'T) (b: 'T) : int =\n    let objCompare (a: obj) (b: obj) =\n        let cmp = ref 0\n        JS.ForEach a (fun k ->\n            if not (JS.HasOwnProperty a k) then\n                false\n            elif not (JS.HasOwnProperty b k) then\n                cmp := 1; true\n            else\n                cmp := Unchecked.compare a?(k) b?(k); !cmp <> 0)\n        if !cmp = 0 then\n            JS.ForEach b (fun k ->\n                if not (JS.HasOwnProperty b k) then\n                    false\n                elif not (JS.HasOwnProperty a k) then\n                    cmp := -1; true\n                else false)\n        !cmp\n    if a ===. b then 0 else\n        match JS.TypeOf a with\n        | JS.Undefined ->\n            match JS.TypeOf b with\n            | JS.Undefined -> 0\n            | _ -> -1\n        | JS.Function ->\n            failwith \"Cannot compare function values.\"\n        | JS.Boolean | JS.Number | JS.String ->\n            if a <. b then -1 else 1\n        | JS.Object ->\n            if a ===. null then -1\n            elif b ===. null then 1\n            elif JS.In \"CompareTo\" a then (As<System.IComparable<_>> a).CompareTo(b)\n            elif JS.In \"CompareTo0\" a then (As<System.IComparable> a).CompareTo(b)\n            elif isArray a && isArray b then compareArrays (As a) (As b)\n            elif isDate a && isDate b then compareDates a b\n            else objCompare (As a) (As b)\n\n/// Produces an undefined value.\n[<Macro(typeof<M.DefaultOf>)>]\n[<Inline \"undefined\">]\nlet DefaultOf<'T> = X<'T>\n\nlet arrayEquals (a: obj []) (b: obj []) =\n    if a.Length = b.Length then\n        let mutable eq = true\n        let mutable i = 0\n        while eq && i < a.Length do\n            if not (Unchecked.equals a.[i] b.[i]) then\n                eq <- false\n            i <- i + 1\n        eq\n    else\n        false\n\nlet dateEquals a b =\n    getTime a ===. getTime b\n\n[<Inline \"$a.Equals($b)\">]\nlet private equals (a: obj) (b: obj) = X<bool>\n\n/// Tests if two values are equal.\nlet Equals (a: 'T) (b: 'T) : bool =\n    let objEquals (a: obj) (b: obj) =\n        let eqR = ref true\n        JS.ForEach a (fun k ->\n            eqR := not (JS.HasOwnProperty a k) || JS.HasOwnProperty b k && Unchecked.equals a?(k) b?(k)\n            not !eqR)\n        if !eqR then\n            JS.ForEach b (fun k ->\n                eqR := not (JS.HasOwnProperty b k) || JS.HasOwnProperty a k\n                not !eqR)\n        !eqR\n    if a ===. b then true else\n        match JS.TypeOf a with\n        | JS.Object ->\n            if a ===. null || a ===. JS.Undefined || b ===. null || b ===. JS.Undefined then false\n            elif JS.In \"Equals\" a then equals a b\n            elif isArray a && isArray b then arrayEquals (As a) (As b)\n            elif isDate a && isDate b then dateEquals a b\n            else objEquals (As a) (As b)\n        | JS.Function ->\n            if JS.In \"$Func\" a then\n                a?``$Func`` ===. b?``$Func`` && a?``$Target`` ===. b?``$Target``\n            elif JS.In \"$Invokes\" a && JS.In \"$Invokes\" b then\n                arrayEquals a?``$Invokes`` b?``$Invokes``  \n            else false\n        | _ ->\n            false\n\nlet hashMix (x: int) (y: int) : int =\n    (x <<< 5) + x + y\n\nlet hashArray (o: obj []) =\n    let mutable h = -34948909\n    for i in 0 .. o.Length - 1 do\n        h <- hashMix h (Unchecked.hash o.[i])\n    h\n\nlet hashString (s: string) : int =\n    if s ===. null then 0 else\n        let mutable hash = 5381\n        for i = 0 to s.Length - 1 do\n            hash <- hashMix hash (int s.[i])\n        hash\n\n[<Inline \"$o.GetHashCode()\">]\nlet getHashCode(o: obj) = X<int>\n\nlet hashObject (o: obj) =\n    if JS.In \"GetHashCode\" o then getHashCode o else\n        let (++) = hashMix\n        let h = ref 0\n        JS.ForEach o (fun key ->\n            h := !h ++ hashString key ++ Unchecked.hash ((?) o key)\n            false)\n        !h\n\n/// Computes the hash of an object.\nlet Hash<'T> (o: 'T) : int =\n    match JS.TypeOf o with\n    | JS.Undefined -> 0\n    | JS.Function  -> 0\n    | JS.Boolean   -> if As o then 1 else 0\n    | JS.Number    -> As o\n    | JS.String    -> hashString (As o)\n    | JS.Object    -> if o ==. null then 0\n                      elif isArray o then hashArray (As o)\n                      else hashObject o\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<voption<_>>)>]\n[<RequireQualifiedAccess>]\ntype private ValueOptionProxy<'T> =\n    | ValueNone \n    | ValueSome of 'T\n\n    member this.Value =\n        match this with \n        | ValueNone -> invalidOp \"ValueOption.Value\"\n        | ValueSome x -> x \n\n    static member Test =\n        (ValueSome 2).Value\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"Numeric\">]\ntype internal N =\n    static member Parse<'T>(s: string, min: 'T, max: 'T, overflowMsg) =\n        let x : float = JS.Plus s\n        if x !==. (x -. (x %. 1)) then\n            raise (System.FormatException \"Input string was not in a correct format.\")\n        elif (x <. min) || (x >. max) then\n            raise (System.OverflowException overflowMsg)\n        else As<'T> x\n\n    static member TryParse<'T>(s: string, min: 'T, max: 'T, r: byref<'T>) =\n        let x : float = JS.Plus s\n        let ok = x ===. (x -. (x %. 1)) && (x >=. min) && (x <=. max)\n        if ok then r <- As<'T> x\n        ok\n\n    static member ParseBool(s: string) =\n        match s.ToLower() with\n        | \"true\" -> true\n        | \"false\" -> false\n        | _ -> raise (System.FormatException \"String was not recognized as a valid Boolean.\")\n\n    static member TryParseBool(s: string, r: byref<bool>) =\n        match s.ToLower() with\n        | \"true\" -> r <- true; true\n        | \"false\" -> r <- false; true\n        | _ -> false\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Byte>)>]\ntype internal NB =\n\n    [<Name \"WebSharper.Numeric.ParseByte\">]\n    static member Parse(s: string) : System.Byte =\n        N.Parse(s, System.Byte.MinValue, System.Byte.MaxValue, \"Value was either too large or too small for an unsigned byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseByte\">]\n    static member TryParse(s: string, r: byref<System.Byte>) : bool =\n        N.TryParse(s, System.Byte.MinValue, System.Byte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.SByte>)>]\ntype internal NSB =\n\n    [<Name \"WebSharper.Numeric.ParseSByte\">]\n    static member Parse(s: string) : System.SByte =\n        N.Parse(s, System.SByte.MinValue, System.SByte.MaxValue, \"Value was either too large or too small for a signed byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseSByte\">]\n    static member TryParse(s: string, r: byref<System.SByte>) : bool =\n        N.TryParse(s, System.SByte.MinValue, System.SByte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int16>)>]\n[<Name \"Int16\">]\ntype internal NI16 =\n\n    [<Name \"WebSharper.Numeric.ParseInt16\">]\n    static member Parse(s: string) : System.Int16 =\n        N.Parse(s, System.Int16.MinValue, System.Int16.MaxValue, \"Value was either too large or too small for an Int16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt16\">]\n    static member TryParse(s: string, r: byref<System.Int16>) : bool =\n        N.TryParse(s, System.Int16.MinValue, System.Int16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int32>)>]\n[<Name \"Int32\">]\ntype internal NI32 =\n\n    [<Name \"WebSharper.Numeric.ParseInt32\">]\n    static member Parse(s: string) : System.Int32 =\n        N.Parse(s, System.Int32.MinValue, System.Int32.MaxValue, \"Value was either too large or too small for an Int32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt32\">]\n    static member TryParse(s: string, r: byref<System.Int32>) : bool =\n        N.TryParse(s, System.Int32.MinValue, System.Int32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt16>)>]\n[<Name \"UInt16\">]\ntype internal NUI16 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt16\">]\n    static member Parse(s: string) : System.UInt16 =\n        N.Parse(s, System.UInt16.MinValue, System.UInt16.MaxValue, \"Value was either too large or too small for an UInt16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt16\">]\n    static member TryParse(s: string, r: byref<System.UInt16>) : bool =\n        N.TryParse(s, System.UInt16.MinValue, System.UInt16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt32>)>]\n[<Name \"UInt32\">]\ntype internal NUI32 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt32\">]\n    static member Parse(s: string) : System.UInt32 =\n        N.Parse(s, System.UInt32.MinValue, System.UInt32.MaxValue, \"Value was either too large or too small for an UInt32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt32\">]\n    static member TryParse(s: string, r: byref<System.UInt32>) : bool =\n        N.TryParse(s, System.UInt32.MinValue, System.UInt32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int64>)>]\n[<Name \"Int64\">]\ntype internal NI64 =\n\n    [<Name \"WebSharper.Numeric.ParseInt64\">]\n    static member Parse(s: string) : System.Int64 =\n        N.Parse(s, System.Int64.MinValue, System.Int64.MaxValue, \"Value was either too large or too small for an Int64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt64\">]\n    static member TryParse(s: string, r: byref<System.Int64>) : bool =\n        N.TryParse(s, System.Int64.MinValue, System.Int64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt64>)>]\n[<Name \"UInt64\">]\ntype internal NUI64 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt64\">]\n    static member Parse(s: string) : System.UInt64 =\n        N.Parse(s, System.UInt64.MinValue, System.UInt64.MaxValue, \"Value was either too large or too small for an UInt64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt64\">]\n    static member TryParse(s: string, r: byref<System.UInt64>) : bool =\n        N.TryParse(s, System.UInt64.MinValue, System.UInt64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Single>)>]\ntype internal NS =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: single) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: single) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: single) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: single) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Single>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Single>) = X<bool>\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Double>)>]\ntype internal ND =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: double) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: double) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: double) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: double) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Double>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Double>) = X<bool>\n\n[<Proxy(typeof<System.Boolean>)>]\ntype internal B = \n    [<Inline>]\n    static member op_LogicalNot(a: bool) = not a\n\n    [<Inline \"$this == $x\">]\n    member this.Equals(x: bool) = X<bool>\n\n    [<Inline \"$this === $x\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: bool, b: bool) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: bool, b: bool) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Constant \"true\">]\n    static member TrueString = X<string>\n\n    [<Constant \"false\">]\n    static member FalseString = X<string>\n\n    [<Inline>]\n    override this.ToString() = string this\n\n    [<Inline>]\n    member this.CompareTo(x: bool) =\n        Unchecked.compare (this :> obj) (x :> obj)\n\n    [<Inline>]\n    member this.CompareTo(x: obj) =\n        Unchecked.compare (this :> obj) x\n\n    [<Inline>]\n    static member Parse(x: string) =\n        N.ParseBool x\n\n    [<Inline>]\n    static member TryParse(x: string, r: byref<bool>) =\n        N.TryParseBool(x, &r)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule internal WebSharper.ClientSideJson\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype OptionalFieldKind =\n    /// The field doesn't have type option<'T>\n    | NotOption = 0\n    /// The field has type option<'T>\n    | NormalOption = 1\n    /// The field has type option<'T> and is marked [<OptionalField>]\n    | MarkedOption = 2\n    /// The field has type Optional<'T>\n    | ErasedOption = 3\n\nlet ServerSideProvider = WebSharper.Core.Json.Provider.Create ()\n\n[<JavaScript>]\nmodule Provider =\n    let Id () = \n        ()\n        fun () -> id\n\n    let EncodeTuple (encs: (unit -> obj -> obj)[]) : (unit -> obj[] -> obj) =\n        ()\n        fun () args ->\n            box (Array.map2 (fun f x -> f () x) encs args)\n\n    let EncodeDateTime () =\n        ()\n        fun () (x: System.DateTime) ->\n            box (x.JS.ToISOString())\n\n    let EncodeDateTimeOffset () =\n        ()\n        fun () (x: System.DateTimeOffset) ->\n            box (New [ \"d\" => x.DateTime.JS.ToISOString(); \"o\" => x?o ])\n\n    let EncodeList (encEl: unit -> 'T -> obj) : (unit -> list<'T> -> obj) =\n        ()\n        fun () (l: list<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            l |> List.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeRecord (_: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            let o = New []\n            fields |> Array.iter (fun (name, enc, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    o?(name) <- enc () x?(name)\n                | OptionalFieldKind.NormalOption ->\n                    match x?(name) with\n                    | Some x -> o?(name) <- enc () x\n                    | None -> ()\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- enc () x?(name)\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- enc () x?(name)\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let EncodeUnion (_: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = New []\n                let tag = x?(\"$\")\n                let tagName, fields = cases.[tag]\n                if JS.TypeOf discr = JS.Kind.String then o?(discr) <- tagName\n                fields |> Array.iter (fun (from, ``to``, enc, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let record = enc () (x?(\"$0\"))\n                        JS.ForEach record (fun f -> o?(f) <- record?(f); false)\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(``to``) <- enc () (x?(from))\n                        | OptionalFieldKind.NormalOption ->\n                            match x?(from) with\n                            | Some x -> o?(``to``) <- enc () x\n                            | None -> ()\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else box x // [<Constant>]\n\n    let EncodeArray (encEl: (unit -> 'T -> obj)) : (unit -> 'T[] -> obj) =\n        ()\n        fun () (a: 'T[]) ->\n            let e = encEl()\n            box (Array.map e a)\n\n    let EncodeSet (encEl: (unit -> 'T -> obj)) : (unit -> Set<'T> -> obj) =\n        ()\n        fun () (s: Set<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            s |> Set.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeStringMap (encEl:(unit -> 'T -> obj)) : (unit -> Map<string, 'T> -> obj) =\n        ()\n        fun () (m: Map<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            m |> Map.iter (fun k v -> o?(k) <- e v)\n            o\n\n    let EncodeArrayMap (encKey:(unit -> 'K -> obj)) (encEl:(unit -> 'V -> obj)) : (unit -> Map<'K, 'V> -> obj) =\n        ()\n        fun () (m: Map<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            m |> Map.iter (fun key el -> a.JS.Push([| [| k key; e el |] |]) |> ignore)\n            box a\n\n    let EncodeStringDictionary (encEl:(unit -> 'T -> obj)) : (unit -> Dictionary<string, 'T> -> obj) =\n        ()\n        fun () (d: Dictionary<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            for KeyValue(k, v) in d :> seq<_> do o?(k) <- e v\n            o\n\n    let EncodeArrayDictionary (encKey: (unit -> 'K -> obj)) (encEl: (unit -> 'V -> obj)) : (unit -> Dictionary<'K, 'V> -> obj) =\n        ()\n        fun () (d: Dictionary<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            for KeyValue(key, el) in d do a.JS.Push([| [| k key; e el |] |]) |> ignore\n            box a\n\n    let EncodeLinkedList (encEl:(unit -> 'T -> obj)) : (unit -> LinkedList<'T> -> obj) =\n        ()\n        fun () (d: LinkedList<'T>) ->\n            let o = Array<'T>()\n            let e = encEl()\n            for x in d :> seq<'T> do o.Push(e x) |> ignore\n            box o\n\n    let DecodeTuple (decs: (unit -> obj -> obj)[]) : (unit -> obj -> obj[]) =\n        As (EncodeTuple decs)\n\n    let DecodeDateTime() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                Date(x?d: string).Self\n            else \n                Date(x :?> string).Self\n\n    let DecodeDateTimeOffset() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                System.DateTimeOffset(Date(x?d: string).Self, System.TimeSpan.FromMinutes x?o)\n            else \n                System.DateTimeOffset(Date(x :?> string).Self, System.TimeSpan.Zero)\n\n    let DecodeList (decEl: (unit -> obj -> 'T)) : (unit -> obj -> list<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            List.init (a :?> obj[]).Length (fun i -> e (a :?> obj[]).[i])\n\n    let DecodeSet (decEl: unit -> obj -> 'T) : (unit -> obj -> Set<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            Set.ofArray(Array.map e (a :?> obj[]))\n\n    let DecodeRecord (t: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            let o = if t ===. JS.Undefined then New [] else JS.New t\n            fields |> Array.iter (fun (name, dec, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- dec () x?(name)\n                    else failwith (\"Missing mandatory field: \" + name)\n                | OptionalFieldKind.NormalOption ->\n                    o?(name) <-\n                        if JS.HasOwnProperty x name\n                        then Some (dec () x?(name))\n                        else None\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- (dec () x?(name))\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- (dec () x?(name))\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let DecodeUnion (t: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = if t ===. JS.Undefined then New [] else JS.New t\n                let tag =\n                    // [<NamedUnionCases(discr)>]\n                    if JS.TypeOf discr = JS.Kind.String then\n                        let tagName = x?(discr)\n                        cases |> Array.findIndex (fun (name, _) -> name = tagName)\n                    else // [<NamedUnionCases>]\n                        let r = ref JS.Undefined\n                        JS.ForEach discr (fun k ->\n                            if JS.HasOwnProperty x k then r := discr?(k); true else false)\n                        !r\n                o?(\"$\") <- tag\n                cases.[tag] |> snd |> Array.iter (fun (from, ``to``, dec, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let r = dec () x\n                        // eliminate tag field if record deserializer is identity\n                        if As<bool> ``to`` then \n                            JS.Delete r discr\n                        o?(\"$0\") <- r\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(from) <- dec () (x?(``to``))\n                        | OptionalFieldKind.NormalOption ->\n                            o?(from) <-\n                                if JS.HasOwnProperty x ``to``\n                                then Some (dec () x?(``to``))\n                                else None\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else x :?> 'T // [<Constant>]\n\n    let DecodeArray (decEl :(unit -> obj -> 'T)) : (unit -> obj -> 'T[]) =\n        As (EncodeArray (As decEl))\n\n    let DecodeStringMap (decEl :(unit -> obj -> 'T)) : (unit -> obj -> Map<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let m = ref Map.empty\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> m := Map.add k (decEl o?(k)) !m; false)\n            !m\n\n    let DecodeArrayMap (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Map<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let mutable m = Map<'K, 'V> []\n            for k, v in o :?> (obj * obj)[] do m <- Map.add (decKey k) (decEl v) m\n            m\n\n    let DecodeStringDictionary (decEl: unit -> obj -> 'T) : (unit -> obj -> Dictionary<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let d = System.Collections.Generic.Dictionary()\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> d.Add(k, decEl o?(k)); false)\n            d\n\n    let DecodeArrayDictionary (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Dictionary<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let d = Dictionary<'K, 'V>()\n            for k, v in o :?> (obj * obj)[] do d.Add(decKey k, decEl v)\n            d\n\n    let DecodeLinkedList (decEl: unit -> obj -> 'T) : (unit -> obj -> LinkedList<'T>) =\n        ()\n        fun () (o: obj) ->\n            let l = LinkedList<'T>()\n            let decEl = decEl()\n            for x in o :?> obj[] do l.AddLast(decEl x) |> ignore\n            l\n\nmodule Macro =\n\n    module M = WebSharper.Core.Metadata\n    open WebSharper.Core.AST\n    module JI = WebSharper.Core.Json.Internal\n    type private BF = System.Reflection.BindingFlags\n\n    type Parameters =\n        {\n            Warnings : ResizeArray<string>\n            Dependencies : ResizeArray<M.Node>\n            Compilation : M.ICompilation\n        }\n\n    [<AutoOpen>]\n    module private Internals =\n\n        let cString s = !~ (Literal.String s)\n        let inline cInt i = !~ (Int i)\n\n        let mainJsonModule =\n            TypeDefinition {\n                FullName = \"WebSharper.Json\"\n                Assembly = \"WebSharper.Main\"\n            }\n        let mJson (comp: M.ICompilation) f args =\n            let m = comp.GetClassInfo(mainJsonModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric mainJsonModule, NonGeneric m, args)\n\n        let (|T|) (t: TypeDefinition) = t.Value.FullName\n        let (|C|_|) (t: Type) =\n            match t with \n            | ConcreteType { Entity = e; Generics = g} -> Some (e, g)\n            | _ -> None\n\n        let providerType = \n            TypeDefinition {\n                FullName = \"WebSharper.ClientSideJson+Provider\"\n                Assembly = \"WebSharper.Web\"\n            }\n        let invoke (comp: M.ICompilation) isEnc n args = \n            let f = (if isEnc then \"Encode\" else \"Decode\") + n\n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric providerType, NonGeneric m, args)\n        let invokeId (comp: M.ICompilation) = \n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = \"Id\")\n            Call(None, NonGeneric providerType, NonGeneric m, [])\n\n        type EncodeResult = Choice<Expression, string, Type>\n\n        let (>>=) (x: EncodeResult) (f: Expression -> EncodeResult) =\n            match x with\n            | Choice1Of3 e -> f e\n            | _ -> x\n        let ok x = Choice1Of3 x : EncodeResult\n        let fail x = Choice2Of3 x : EncodeResult\n        let generic t = Choice3Of3 t : EncodeResult\n\n        let mapOk f x =\n            match x with\n            | Choice1Of3 x -> Choice1Of3 (f x) \n            | _ -> x\n\n        /// Returns None if MacroNeedsResolvedTypeArg.\n        let getEncoding name isEnc param (t: Type) : EncodeResult =\n            let warn msg = param.Warnings.Add msg\n            let addTypeDep td = param.Dependencies.Add (M.TypeNode td)\n            let comp = param.Compilation\n            let call = invoke comp isEnc\n            let ident = invokeId comp \n            let isIdent r =\n                match r with \n                | Choice1Of3 e when obj.ReferenceEquals(e, ident) -> true\n                | _ -> false\n            let rec encode t =\n                match t with\n                | ArrayType (t, 1)\n                | C (T \"System.Collections.Generic.List`1\", [t])\n                | C (T \"System.Collections.Generic.Queue`1\", [t])\n                | C (T \"System.Collections.Generic.Stack`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Array\" [e])\n                | ArrayType _ ->\n                    fail \"JSON serialization for multidimensional arrays is not supported.\"\n                | VoidType\n                | C (T (\"Microsoft.FSharp.Core.Unit\"\n                            | \"System.Boolean\"\n                            | \"System.SByte\"   | \"System.Byte\"\n                            | \"System.Int16\"   | \"System.UInt16\"\n                            | \"System.Int32\"   | \"System.UInt32\"\n                            | \"System.Int64\"   | \"System.UInt64\"\n                            | \"System.Single\"  | \"System.Double\"\n                            | \"System.String\"  | \"System.Guid\"\n                            | \"WebSharper.Core.Json+Encoded\"), []) ->\n                    ok ident\n                | C (T \"System.Object\", []) ->\n                    if isEnc then \n                        fail \"JSON serialization for System.Object is not supported; only deserialization.\" \n                    else ok ident\n                | C (T \"Microsoft.FSharp.Collections.FSharpList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"List\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpSet`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Set\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpMap`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e -> \n                        ok (call \"StringMap\" [e])\n                    | _ ->\n                        encode k >>= fun k -> \n                        encode t >>= fun e -> \n                        ok (call \"ArrayMap\" [k; e])\n                | C (T \"System.Collections.Generic.Dictionary`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e ->\n                        ok (call \"StringDictionary\" [e])\n                    | _ ->\n                        encode k >>= fun k ->\n                        encode t >>= fun e ->\n                        ok (call \"ArrayDictionary\" [k; e])\n                | C (T \"System.Collections.Generic.LinkedList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"LinkedList\" [e])\n                | TupleType (ts, _) ->\n                    ((fun es -> ok (call \"Tuple\" [NewArray es])), ts)\n                    ||> List.fold (fun k t ->\n                        fun es -> encode t >>= fun e -> k (e :: es))\n                    <| []\n                | C (T \"System.DateTime\", []) ->\n                    ok (call \"DateTime\" [])\n                | C (T \"System.DateTimeOffset\", []) ->\n                    ok (call \"DateTimeOffset\" [])\n                | C (td, args) ->                    \n                    let top = comp.AssemblyName.Replace(\".\",\"$\") + if isEnc then \"_JsonEncoder\" else \"_JsonDecoder\"\n                    let key = M.CompositeEntry [ M.StringEntry top; M.TypeEntry t ]\n                    match comp.GetMetadataEntries key with                    \n                    | M.StringEntry \"id\" :: _ ->\n                        ok ident\n                    | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                        Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                    | _ ->\n                        let gtd, gm, _ = comp.NewGenerated([top; \"j\"])\n                        let _, gv, va = comp.NewGenerated([top; \"_\" + \"v\"])\n                        comp.AddGeneratedCode(gv, Undefined)\n                        comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                        ((fun es ->\n                            let enc = encRecType t args es\n                            if isIdent enc then\n                                comp.AddMetadataEntry(key, M.StringEntry \"id\")\n                                comp.AddGeneratedInline(gm, ident)\n                                enc\n                            else\n                                enc >>= fun e ->\n                                let v = Lambda([], Call (None, NonGeneric gtd, NonGeneric gv, []))\n                                let vn = Value (String va.Value.Head)\n                                let b = Lambda ([], Conditional(v, v, ItemSet(Global [top], vn, Application(e, [], NonPure, Some 0))))\n                                comp.AddGeneratedCode(gm, b)\n                                Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                         ), args)\n                        ||> List.fold (fun k t es ->\n                            encode t >>= fun e -> k ((t, e) :: es))\n                        <| []\n                | ConcreteType _ -> failwith \"impossible\"\n                | FSharpFuncType _ -> \n                    fail (name + \": Cannot de/serialize a function value.\")\n                | ByRefType _ ->\n                    fail (name + \": Cannot de/serialize a byref value.\")\n                | LocalTypeParameter\n                | StaticTypeParameter _ \n                | TypeParameter _ ->\n                    generic t\n            // Encode a type that might be recursively defined\n            and encRecType t targs args =\n                let td = t.TypeDefinition\n                match comp.GetCustomTypeInfo td with\n                | M.EnumInfo _ -> ok ident\n                | M.FSharpRecordInfo fields ->\n                    let fieldEncoders =\n                        fields\n                        |> List.map (fun f ->\n                            if Option.isSome f.DateTimeFormat then\n                                warn (sprintf \"Warning: This record field has a custom DateTime format: %s.%s. \\\n                                    Client-side JSON serialization does not support custom DateTime formatting. \\\n                                    This field will be serialized using ISO format.\"\n                                    f.RecordFieldType.TypeDefinition.Value.FullName f.Name)\n                            let t, optionKind =\n                                match f.RecordFieldType with\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                    if f.Optional then p, OptionalFieldKind.MarkedOption\n                                    else p, OptionalFieldKind.NormalOption\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                    p, OptionalFieldKind.ErasedOption\n                                | t ->    \n                                    t, OptionalFieldKind.NotOption\n                            f.JSName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                        )  \n                    let pr =\n                        match comp.GetClassInfo td with\n                        | Some cls -> \n                            addTypeDep td \n                            if cls.HasWSPrototype then\n                                GlobalAccess cls.Address.Value\n                            else Undefined\n                        | _ -> Undefined\n                    if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                        fo <> OptionalFieldKind.NormalOption && isIdent fe\n                    )\n                    then ok ident\n                    else\n                        ((fun es ->\n                            let es, tts = List.unzip es\n                            ok (call \"Record\" [pr; NewArray es])\n                            ), fieldEncoders)\n                        ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                fe >>= fun e ->\n                                k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                        <| []\n                // TODO: handle nested case type (possible when using from C#)\n                | M.FSharpUnionInfo u ->\n                    let tryGetInlinableRecordInfo (uci: M.FSharpUnionCaseInfo) =\n                        match uci.Kind with \n                        | M.NormalFSharpUnionCase [f] when f.Name = \"Item\" ->\n                            let rec inl uft =\n                                match uft with\n                                | ConcreteType { Entity = fTd } as ft ->\n                                    match comp.GetCustomTypeInfo fTd with\n                                    | M.FSharpRecordInfo fRec -> Some (ft, fRec)\n                                    | _ -> None\n                                | TypeParameter i -> inl (targs.[i])\n                                | _ -> None\n                            inl f.UnionFieldType\n                        | _ -> None\n                    let isOption (t: Type) =\n                        match t with\n                        | ConcreteType { Entity = e } ->\n                            e.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\"\n                        | _ -> false\n                    let discr =\n                        match u.NamedUnionCases with\n                        | None -> JI.StandardField\n                        | Some None -> \n                            let allCases =\n                                u.Cases |> Seq.mapi (fun i uci ->\n                                    i,\n                                    match tryGetInlinableRecordInfo uci with\n                                    | Some (_, fRec) ->\n                                        fRec |> Seq.filter (fun rf -> not (isOption rf.RecordFieldType))\n                                        |> Seq.map (fun rf -> rf.JSName) |> Set.ofSeq\n                                    | None ->\n                                        match uci.Kind with \n                                        | M.NormalFSharpUnionCase fs ->\n                                            fs\n                                            |> List.choose (fun f ->\n                                                if isOption f.UnionFieldType then None else Some f.Name)\n                                            |> Set.ofList\n                                        | _ -> Set.empty\n                                )\n                                |> Map.ofSeq\n                            let findDistinguishingCase (cases: Map<int, Set<string>>) =\n                                cases\n                                |> Map.tryPick (fun t fs ->\n                                    let allOtherFields =\n                                        allCases\n                                        |> Seq.choose (fun (KeyValue(t', fs)) ->\n                                            if t = t' then None else Some fs)\n                                        |> Set.unionMany\n                                    let uniqueCases = fs - allOtherFields\n                                    if Set.isEmpty uniqueCases then\n                                        None\n                                    else Some (Seq.head uniqueCases, t)\n                                )\n                            let rec buildTable acc cases =\n                                if Map.isEmpty cases then acc else\n                                match findDistinguishingCase cases with\n                                | None -> failwithf \"No decoder for %s\" t.AssemblyQualifiedName\n                                | Some (name, tag) ->\n                                    buildTable\n                                        <| (name, tag) :: acc\n                                        <| Map.remove tag cases\n                            buildTable [] allCases |> JI.NoField\n                        | Some (Some n) -> JI.NamedField n\n                    let cases = u.Cases\n                    ((0, fun cases ->\n                        let cases = NewArray cases\n                        let discr =\n                            match discr with\n                            | JI.NoField discrFields ->\n                                discrFields\n                                |> List.map (fun (name, id) -> name, cInt id)\n                                |> Object\n                            | JI.StandardField -> cString \"$\"\n                            | JI.NamedField n -> cString n\n                        let tn =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td\n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else\n                                    Undefined\n                            | _ -> Undefined\n                        ok (call \"Union\" [tn; discr; cases])\n                        ), cases)\n                    ||> List.fold (fun (i, k) case ->\n                        i + 1, fun es ->\n                            match tryGetInlinableRecordInfo case with\n                            | Some (ft, _) -> \n                                let tag =\n                                    match discr with\n                                    | JI.StandardField -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                let encF = encode ft \n                                let elimTag =\n                                    if isIdent encF then !~(Bool true) else !~Null\n                                encF >>= fun e ->\n                                k (NewArray [tag; NewArray [NewArray [!~Null; elimTag; e]]] :: es)\n                            | _ ->\n                            match case.Kind with\n                            | M.NormalFSharpUnionCase fields ->\n                                ((0, fun argNames ->\n                                    let tag =\n                                        match u.NamedUnionCases with\n                                        | None -> cInt i\n                                        | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                    k (NewArray [tag; NewArray argNames] :: es)\n                                    ), fields)\n                                ||> List.fold (fun (j, k) f -> //(argName, argT, argFlags) ->\n                                    if Option.isSome f.DateTimeFormat then\n                                        warn (sprintf \"Warning: This union case field has a custom DateTime format: %s.%s [%s]. \\\n                                            Client-side JSON serialization does not support custom DateTime formatting. \\\n                                            This field will be serialized using ISO format.\"\n                                            f.UnionFieldType.TypeDefinition.Value.FullName case.Name f.Name)\n                                    let argT, optionKind =\n                                        match f.UnionFieldType with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            p, cInt (int OptionalFieldKind.NormalOption)\n                                        | t ->    \n                                            t, cInt (int OptionalFieldKind.NotOption)\n                                    j + 1, fun es ->\n                                        encode (argT.SubstituteGenerics (Array.ofList targs)) >>= fun e ->\n                                        k (NewArray [cString (\"$\" + string j); cString f.Name; e; optionKind] :: es))\n                                |> snd\n                                <| []\n                            | M.SingletonFSharpUnionCase ->\n                                let tag =\n                                    match u.NamedUnionCases with\n                                    | None -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                k (NewArray [tag; NewArray []] :: es)\n                            | M.ConstantFSharpUnionCase _ -> k (!~Null :: es)\n                    )\n                    |> snd\n                    <| []\n                | _ -> \n                    match comp.GetClassInfo td with\n                    | Some cls ->\n                        let fieldEncoders =\n                            cls.Fields.Values\n                            |> Seq.choose (fun (f, _, ft) ->\n                                let jsNameTypeAndOption =\n                                    let isOption name isMarked =\n                                        match ft with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            if isMarked then\n                                                Some (name, p, OptionalFieldKind.MarkedOption) \n                                            else\n                                                Some (name, p, OptionalFieldKind.NormalOption) \n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                            Some (name, p, OptionalFieldKind.ErasedOption) \n                                        | ft ->    \n                                            Some (name, ft, OptionalFieldKind.NotOption)\n                                    match f with\n                                    | M.InstanceField n -> isOption n false\n                                    | M.IndexedField i -> isOption (string i) false\n                                    | M.OptionalField n -> isOption n true\n                                    | M.StaticField _ -> None\n                                jsNameTypeAndOption |> Option.map (fun (jsName, t, optionKind) ->\n                                    jsName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                                )\n                            ) |> List.ofSeq\n                        let pr =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td \n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else Undefined\n                            | _ -> Undefined\n                        if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                            fo <> OptionalFieldKind.NormalOption && isIdent fe\n                        )\n                        then ok ident\n                        else\n                            ((fun es ->\n                                let es, tts = List.unzip es\n                                ok (call \"Record\" [pr; NewArray es])\n                                ), fieldEncoders)\n                            ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                    fe >>= fun e ->\n                                    k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                            <| []\n                    | _ ->\n                        fail (name + \": Type not supported: \" + t.TypeDefinition.Value.FullName)\n            encode t\n\n        let encodeLambda name param t =\n            getEncoding name true param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let encode name param t arg =\n            encodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n        let decodeLambda name param t =\n            getEncoding name false param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let decode name param t arg =\n            decodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n    let Encode param t arg =\n        // ENCODE()(arg)\n        encode \"Encode\" param t arg\n\n    let EncodeLambda warn t =\n        // ENCODE()\n        encodeLambda \"EncodeLambda\" warn t\n\n    let Serialize param t arg =\n        // JSON.stringify(ENCODE()(arg))\n        encode \"Serialize\" param t arg\n        |> mapOk (fun x -> mJson param.Compilation \"Stringify\" [x])\n\n    let SerializeLambda param t =\n        encodeLambda \"SerializeLambda\" param t\n        |> mapOk (fun x ->\n            let enc = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let enc = ENCODE() in fun arg -> JSON.stringify(enc(arg))\n            Let(enc, x,\n                Lambda([arg],\n                    mJson param.Compilation \"Stringify\" [Application(Var enc, [Var arg], Pure, Some 1)])))\n\n    let Decode param t arg =\n        // DECODE()(arg)\n        decode \"Decode\" param t arg\n\n    let DecodeLambda param t =\n        // DECODE()\n        decodeLambda \"DecodeLambda\" param t\n\n    let Deserialize param t arg =\n        // DECODE()(JSON.parse(arg))\n        decode \"Deserialize\" param t (mJson param.Compilation \"Parse\" [arg])\n\n    let DeserializeLambda param t =\n        decodeLambda \"DeserializeLambda\" param t\n        |> mapOk (fun x ->\n            let dec = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let dec = DECODE() in fun arg -> dec(JSON.parse(arg))\n            Let(dec, x,\n                Lambda([arg],\n                    Application(Var dec, [mJson param.Compilation \"Parse\" [Var arg]], Pure, Some 1))))\n\n    type SerializeMacro() =\n        inherit WebSharper.Core.Macro()\n\n        static let rec last = function\n            | [x] -> x\n            | x :: l -> last l\n            | _ -> failwith \"\"\n\n        override this.TranslateCall(c) =\n            let f =\n                match c.Method.Entity.Value.MethodName with\n                | \"Encode\" -> Encode\n                | \"Decode\" -> Decode\n                | \"Serialize\" -> Serialize\n                | \"Deserialize\" -> Deserialize\n                | _ -> failwith \"Invalid macro invocation\"\n            let param = \n                {\n                    Compilation = c.Compilation\n                    Warnings = ResizeArray()\n                    Dependencies = ResizeArray()\n                }\n            let res =\n                match f param c.Method.Generics.Head (last c.Arguments) with\n                | Choice1Of3 x -> WebSharper.Core.MacroOk x\n                | Choice2Of3 e -> WebSharper.Core.MacroError e\n                | Choice3Of3 t -> WebSharper.Core.MacroNeedsResolvedTypeArg t\n            let resWithWarnings =\n                if param.Warnings.Count > 0 then\n                    param.Warnings |> Seq.fold (fun res msg -> \n                        WebSharper.Core.MacroWarning (msg, res)) res\n                else res\n            if param.Dependencies.Count > 0 then\n                WebSharper.Core.MacroDependencies (List.ofSeq param.Dependencies, resWithWarnings)\n            else resWithWarnings    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Web\n\nopen WebSharper\nopen WebSharper.Core\n\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require (t: System.Type, [<System.ParamArray>] parameters: obj[]) =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    let t = AST.Reflection.ReadTypeDefinition t\n    let req = \n        [M.ResourceNode (t, \n            if parameters.Length = 0 then None else Some(M.ParameterObject.OfObj parameters))]\n\n    interface INode with\n        member this.Write(_, _) = ()\n        member this.IsAttribute = false\n\n    interface IRequiresResources with\n        member this.Encode(_, _) = []\n        member this.Requires(_) = req :> _\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(None, this, Shared.Metadata, Shared.Json)\n\n    override this.Render _ = ()\n#endif\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require<'T when 'T :> Resources.IResource>() =\n    inherit Require(typeof<'T>)\n\n/// A base class for defining custom ASP.NET controls. Inherit from this class,\n/// override the Body property and use the new class as a Server ASP.NET\n/// control in your application.\n[<AbstractClass>]\ntype Control() =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    static let gen = System.Random()\n    [<System.NonSerialized>]\n    let mutable id = System.String.Format(\"ws{0:x}\", gen.Next().ToString())\n\n#if NET461 // ASP.NET: Control\n    override this.ID\n#else\n    member this.ID\n#endif\n        with get () = id\n        and set x = id <- x\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(Some id, this, Shared.Metadata, Shared.Json)\n#endif\n\n    interface INode with\n        member this.IsAttribute = false\n        member this.Write (_, w) =\n            w.Write(\"\"\"<div id=\"{0}\"></div>\"\"\", this.ID)\n\n    [<JavaScript>]\n    abstract member Body : IControlBody\n\n    interface IControl with\n        [<JavaScript>]\n        member this.Body = this.Body\n        member this.Id = this.ID\n\n    member this.GetBodyNode() =\n        let t = this.GetType()\n        let t = if t.IsGenericType then t.GetGenericTypeDefinition() else t\n        let m = t.GetProperty(\"Body\").GetGetMethod()\n        M.MethodNode (R.ReadTypeDefinition t, R.ReadMethod m)\n\n    interface IRequiresResources with\n        member this.Requires(_) =\n            this.GetBodyNode() |> Seq.singleton\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n#if NET461 // ASP.NET: Control\n    override this.Render writer =\n#else\n    member this.Render (writer: WebSharper.Core.Resources.HtmlTextWriter) =\n#endif\n        writer.WriteLine(\"<div id='{0}'></div>\", this.ID)\n\nopen WebSharper.JavaScript\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\n\nmodule ClientSideInternals =\n\n    module M = WebSharper.Core.Metadata\n    module R = WebSharper.Core.AST.Reflection\n    module J = WebSharper.Core.Json\n    module P = FSharp.Quotations.Patterns\n\n    let getLocation' (q: Expr) =\n        let (|Val|_|) e : 't option =\n            match e with\n            | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n            | _ -> None\n        let l =\n            q.CustomAttributes |> Seq.tryPick (function\n                | NewTuple [ Val \"DebugRange\";\n                             NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                    Some (sprintf \"%s: %i.%i-%i.%i\" file startLine startCol endLine endCol)\n                | _ -> None)\n        defaultArg l \"(no location)\"\n\n    let (|Val|_|) e : 't option =\n        match e with\n        | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n        | _ -> None\n\n    let getLocation (q: Expr) =\n        q.CustomAttributes |> Seq.tryPick (function\n            | P.NewTuple [ Val \"DebugRange\";\n                           P.NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                ({\n                    FileName = System.IO.Path.GetFileName(file)\n                    Start = (startLine, startCol)\n                    End = (endLine, endCol)\n                } : WebSharper.Core.AST.SourcePos)\n                |> Some\n            | _ -> None)\n\n    let rec findArgs (env: Set<string>) (setArg: string -> obj -> unit) (q: Expr) =\n        match q with\n        | P.ValueWithName (v, _, n) when not (env.Contains n) -> setArg n v\n        | P.AddressOf q\n        | P.Coerce (q, _)\n        | P.FieldGet (Some q, _)\n        | P.QuoteRaw q\n        | P.QuoteTyped q\n        | P.VarSet (_, q)\n        | P.WithValue (_, _, q)\n        | P.TupleGet (q, _)\n        | P.TypeTest (q, _)\n        | P.UnionCaseTest (q, _)\n            -> findArgs env setArg q\n        | P.AddressSet (q1, q2)\n        | P.Application (q1, q2)\n        | P.Sequential (q1, q2)\n        | P.TryFinally (q1, q2)\n        | P.WhileLoop (q1, q2)\n            -> findArgs env setArg q1; findArgs env setArg q2\n        | P.PropertyGet (q, _, qs)\n        | P.Call (q, _, qs) ->\n            Option.iter (findArgs env setArg) q\n            List.iter (findArgs env setArg) qs\n        | P.FieldSet (q1, _, q2) ->\n            Option.iter (findArgs env setArg) q1; findArgs env setArg q2\n        | P.ForIntegerRangeLoop (v, q1, q2, q3) ->\n            findArgs env setArg q1\n            findArgs env setArg q2\n            findArgs (Set.add v.Name env) setArg q3\n        | P.IfThenElse (q1, q2, q3)\n            -> findArgs env setArg q1; findArgs env setArg q2; findArgs env setArg q3\n        | P.Lambda (v, q) ->\n            findArgs (Set.add v.Name env) setArg q\n        | P.Let (v, q1, q2) ->\n            findArgs env setArg q1\n            findArgs (Set.add v.Name env) setArg q2\n        | P.LetRecursive (vqs, q) ->\n            let vs, qs = List.unzip vqs\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q\n        | P.NewObject (_, qs)\n        | P.NewRecord (_, qs)\n        | P.NewTuple qs\n        | P.NewUnionCase (_, qs)\n        | P.NewArray (_, qs) ->\n            List.iter (findArgs env setArg) qs\n        | P.NewDelegate (_, vs, q) ->\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            findArgs env setArg q\n        | P.PropertySet (q1, _, qs, q2) ->\n            Option.iter (findArgs env setArg) q1\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q2\n        | P.TryWith (q, v1, q1, v2, q2) ->\n            findArgs env setArg q\n            findArgs (Set.add v1.Name env) setArg q1\n            findArgs (Set.add v2.Name env) setArg q2\n        | _ -> ()\n    \n    let internal compileClientSide (meta: M.Info) (reqs: list<M.Node>) (q: Expr) : (obj[] * _) =\n        let rec compile (reqs: list<M.Node>) (q: Expr) =\n            match getLocation q with\n            | Some p ->\n                match meta.Quotations.TryGetValue(p) with\n                | false, _ ->\n                    let ex =\n                        meta.Quotations.Keys\n                        |> Seq.map (sprintf \"  %O\")\n                        |> String.concat \"\\n\"\n                    failwithf \"Failed to find compiled quotation at position %O\\nExisting ones:\\n%s\" p ex\n                | true, (declType, meth, argNames) ->\n                    match meta.Classes.TryGetValue declType with\n                    | false, _ -> failwithf \"Error in ClientSide: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                    | true, c ->\n                        let argIndices = Map (argNames |> List.mapi (fun i x -> x, i))\n                        let args = Array.create argNames.Length null\n                        let reqs = ref (M.MethodNode (declType, meth) :: M.TypeNode declType :: reqs)\n                        let setArg (name: string) (value: obj) =\n                            let i = argIndices.[name]\n                            if isNull args.[i] then\n                                args.[i] <-\n                                    match value with\n                                    | :? Expr as q ->\n                                        failwith \"Error in ClientSide: Spliced expressions are not allowed in InlineControl\"\n                                    | value ->\n                                        let typ = value.GetType ()\n                                        reqs := M.TypeNode (WebSharper.Core.AST.Reflection.ReadTypeDefinition typ) :: !reqs\n                                        value\n                        if not (List.isEmpty argNames) then\n                            findArgs Set.empty setArg q\n                        args, !reqs\n            | None -> failwithf \"Failed to find location of quotation: %A\" q\n        compile reqs q \n\n    type private FSV = Reflection.FSharpValue\n\n    let internal compileClientSideFallback (elt: Expr) = \n        let declType, meth, args, fReqs, subs =\n            let elt =\n                match elt with\n                | Coerce (e, _) -> e\n                | e -> e\n            let rec get subs expr =\n                match expr with\n                | PropertyGet(None, p, args) ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Call(None, m, args) ->\n                    let dt = R.ReadTypeDefinition m.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Let(var, value, body) ->\n                    get (subs |> Map.add var value) body\n                | e -> failwithf \"Wrong format for InlineControl at %s: expected global value or function access, got: %A\" (getLocation' elt) e\n            get Map.empty elt\n        let args, argReqs =\n            args\n            |> List.mapi (fun i value ->\n                let rec get expr =\n                    match expr with\n                    | Value (v, t) ->\n                        let v = match v with null -> WebSharper.Core.Json.Internal.MakeTypedNull t | _ -> v\n                        v, M.TypeNode (R.ReadTypeDefinition t)\n                    | TupleGet(v, i) ->\n                        let v, n = get v\n                        FSV.GetTupleField(v, i), n\n                    | Var v when subs.ContainsKey v ->\n                        get subs.[v]   \n                    | _ -> failwithf \"Wrong format for InlineControl at %s: argument #%i is not a literal or a local variable\" (getLocation' elt) (i+1)\n                get value\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        args, declType, meth, fReqs @ argReqs\n\nopen ClientSideInternals\n\n/// Implements a web control based on a quotation-wrapped top-level body.\n/// Use the function ClientSide or ctx.ClientSide to create an InlineControl.\n[<CompiledName \"FSharpInlineControl\">]\ntype InlineControl<'T when 'T :> IControlBody>(elt: Expr<'T>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    let mutable args = [||]\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Requires(meta) =\n            let declType, meth, reqs =\n                match getLocation elt with\n                | None -> failwith \"Failed to find location of quotation\"\n                | Some p ->\n                    match meta.Quotations.TryGetValue p with\n                    | true, (ty, m, _) ->\n                        let argVals, deps = compileClientSide meta [] elt\n                        args <- argVals\n                        ty, m, deps\n                    | false, _ ->\n                        let argVals, ty, m, deps = compileClientSideFallback elt\n                        args <- argVals\n                        ty, m, deps\n\n            // set funcName\n            let fail() =\n                failwithf \"Error in InlineControl at %s: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the assembly needs to be compiled with WsFsc.exe\" \n                    (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n            match meta.Classes.TryFind declType with\n            | None -> fail()\n            | Some cls ->\n                match cls.Methods.TryFind meth with\n                | Some (M.Static a, _, _) ->\n                    funcName <- Array.ofList (List.rev a.Value)\n                | Some _ ->\n                    failwithf \"Error in InlineControl at %s: Method %s.%s must be static and not inlined\"\n                        (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n                | None -> fail()\n\n            this.GetBodyNode() :: reqs |> Seq.ofList\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n\nopen System\nopen System.Reflection\nopen System.Linq.Expressions\n\n// TODO: test in arguments: needs .NET 4.5\n// open System.Runtime.CompilerServices\n//[<CallerFilePath; Optional>] sourceFilePath \n//[<CallerLineNumber; Optional>] sourceLineNumber\n[<CompiledName \"InlineControl\">]\ntype CSharpInlineControl(elt: System.Linq.Expressions.Expression<Func<IControlBody>>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    static let ctrlReq = M.TypeNode (R.ReadTypeDefinition typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let reduce (e: Expression) = if e.CanReduce then e.Reduce() else e\n        let declType, meth, args, fReqs =\n            match reduce elt.Body with\n            | :? MemberExpression as e ->\n                match e.Member with\n                | :? PropertyInfo as p ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, [], [M.MethodNode (dt, meth)]\n                | _ -> failwith \"member must be a property\"\n            | :? MethodCallExpression as e -> \n                let m = e.Method\n                let dt = R.ReadTypeDefinition m.DeclaringType\n                let meth = R.ReadMethod m\n                dt, meth, e.Arguments |> List.ofSeq, [M.MethodNode (dt, meth)]\n            | e -> failwithf \"Wrong format for InlineControl: expected global value or function access, got: %A\"  e\n        let args, argReqs =\n            args\n            |> List.mapi (fun i a -> \n                let rec get needType (a: Expression) =\n                    match reduce a with\n                    | :? ConstantExpression as e ->\n                        let v = match e.Value with null -> WebSharper.Core.Json.Internal.MakeTypedNull e.Type | _ -> e.Value\n                        v, if needType then M.TypeNode (R.ReadTypeDefinition e.Type) else M.EntryPointNode\n                    | :? MemberExpression as e ->\n                        let o = \n                            match e.Expression with\n                            | null -> null\n                            | ee -> fst (get false ee)\n                        match e.Member with\n                        | :? FieldInfo as f ->\n                            f.GetValue(o), if needType then M.TypeNode (R.ReadTypeDefinition f.FieldType) else M.EntryPointNode\n                        | :? PropertyInfo as p ->\n                            if p.GetIndexParameters().Length > 0 then\n                                failwithf \"Wrong format for InlineControl in argument #%i, indexed property not allowed\" (i+1)\n                            p.GetValue(o, null), if needType then M.TypeNode (R.ReadTypeDefinition p.PropertyType) else M.EntryPointNode\n                        | m -> failwithf \"Wrong format for InlineControl in argument #%i, member access not allowed: %s\" (i+1) (m.GetType().Name)\n                    | a -> failwithf \"Wrong format for InlineControl in argument #%i, expression type: %s\" (i+1) (a.GetType().Name)\n                get true a\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs\n        args, (declType, meth, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, meth, reqs = snd bodyAndReqs\n                let fail() =\n                    failwithf \"Error in InlineControl: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the project file needs to include WebSharper.CSharp.targets\" \n                        declType.Value.FullName meth.Value.MethodName\n                match meta.Classes.TryFind declType with\n                | None -> fail()\n                | Some cls ->\n                    match cls.Methods.TryFind meth with\n                    | Some (M.Static a, _, _) ->\n                        funcName <- Array.ofList (List.rev a.Value)\n                    | Some _ -> \n                        failwithf \"Error in InlineControl: Method %s.%s must be static and not inlined\"\n                            declType.Value.FullName meth.Value.MethodName\n                    | None -> fail()\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n        member this.Requires(_) =\n            let _, _, reqs = snd bodyAndReqs \n            this.GetBodyNode() :: reqs |> Seq.ofList\n\nnamespace WebSharper\n\n[<AutoOpen>]\nmodule WebExtensions =\n\n    open Microsoft.FSharp.Quotations\n    open WebSharper.Web\n\n    /// Embed the given client-side control body in a server-side control.\n    /// The client-side control body must be an implicit or explicit quotation expression.\n    /// It can capture local variables, of the same types which are serializable by WebSharper as RPC results.\n    let ClientSide ([<JavaScript; ReflectedDefinition>] e: Expr<#IControlBody>) =\n        new InlineControl<_>(e)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Sitelets\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen System.Collections.Generic\nopen System.Text\n\n#nowarn \"64\" // type parameter renaming warnings \n\n[<NamedUnionCases \"result\"; RequireQualifiedAccess>]\ntype ParseRequestResult<'T> =\n    | [<CompiledName \"success\">]\n      Success of endpoint: 'T\n    | [<CompiledName \"invalidMethod\">]\n      InvalidMethod of endpoint: 'T * ``method``: string\n    | [<CompiledName \"invalidJson\">]\n      InvalidJson of endpoint: 'T\n    | [<CompiledName \"missingQueryParameter\">]\n      MissingQueryParameter of endpoint: 'T * queryParam: string\n    | [<CompiledName \"missingFormData\">]\n      MissingFormData of endpoint: 'T * formFieldName: string\n\n    member this.Value =\n        match this with\n        | Success a\n        | InvalidMethod (a, _)\n        | InvalidJson a\n        | MissingQueryParameter (a, _)\n        | MissingFormData (a, _) -> a\n\n    [<System.Obsolete \"Use Value instead\">]\n    member this.Action = this.Value\n\n[<System.Obsolete \"Use ParseRequestResult instead of ActionEncoding.DecodeResult\">]\n/// For back-compatibility only, use ParseRequestResult instead of ActionEncoding.DecodeResult\nmodule ActionEncoding =\n\n    type DecodeResult<'T> = ParseRequestResult<'T>\n\n    let Success endpoint = ParseRequestResult.Success endpoint\n    let InvalidMethod (endpoint, ``method``) = ParseRequestResult.InvalidMethod(endpoint, ``method``)\n    let InvalidJson endpoint = ParseRequestResult.InvalidJson endpoint\n    let MissingQueryParameter (endpoint, queryParam) = ParseRequestResult.MissingQueryParameter(endpoint, queryParam)\n    let MissingFormData (endpoint, formFieldName) = ParseRequestResult.MissingFormData(endpoint, formFieldName)\n\nmodule StringEncoding =\n\n    [<JavaScript>]\n    let isUnreserved isLast c =\n        match c with\n        | '-' | '_' -> true\n        | '.' -> not isLast\n        | c when c >= 'A' && c <= 'Z' -> true\n        | c when c >= 'a' && c <= 'z' -> true\n        | c when c >= '0' && c <= '9' -> true\n        | _ -> false\n    \n    let writeEscaped (w: System.Text.StringBuilder) isLast c =\n        let k = int c\n        if isUnreserved isLast c then w.Append c\n        elif k < 256 then w.AppendFormat(\"~{0:x2}\", k)\n        else w.AppendFormat(\"~u{0:x4}\", k)\n        |> ignore\n\n    [<JavaScript>]\n    let writeEscapedAsString isLast c =\n        let k = int c\n        if isUnreserved isLast c then string c\n        elif k < 256 then \"~\" + k.JS.ToString(16).PadLeft(2, '0')\n        else \"~u\" + k.JS.ToString(16).PadLeft(4, '0')\n\n    [<JavaScript>]\n    let write (s: string) = \n        if IsClient then\n            s |> Seq.mapi (fun i c ->\n                writeEscapedAsString (i + 1 = s.Length) c\n            )\n            |> String.concat \"\"\n        else\n            let b = System.Text.StringBuilder()\n            s |> Seq.iteri (fun i c ->\n                writeEscaped b (i + 1 = s.Length) c)\n            string b\n\n    [<JavaScript>]\n    let inline ( ++ ) (a: int) (b: int) = (a <<< 4) + b\n\n    [<Literal>]\n    let EOF = -1\n\n    [<Literal>]\n    let ERROR = -2\n\n    let readEscaped (r: System.IO.TextReader) =\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match r.Read() with\n        | x when x = int '~' ->\n            match r.Read() with\n            | x when x = int 'u' ->\n                let a = r.Read()\n                let b = r.Read()\n                let c = r.Read()\n                let d = r.Read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = r.Read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n\n    [<JavaScript>]\n    let readEscapedFromChars (chars: int list) =\n        let mutable chars = chars\n        let read() =\n            match chars with\n            | [] -> -1\n            | h :: t ->\n                chars <- t\n                h\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match read() with\n        | x when x = int '~' ->\n            match read() with\n            | x when x = int 'u' ->\n                let a = read()\n                let b = read()\n                let c = read()\n                let d = read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n        , chars\n\n    [<JavaScript>]\n    let read (s: string) = \n        if IsClient then\n            let buf = ResizeArray()\n            let rec loop chars =\n                match readEscapedFromChars chars with\n                | ERROR, _ -> None\n                | EOF, _ -> Some (buf |> String.concat \"\")\n                | x, chars -> \n                    buf.Add(string (char x))\n                    loop chars\n            s |> Seq.map int |> List.ofSeq |> loop\n        else\n            let buf = System.Text.StringBuilder()\n            use i = new System.IO.StringReader(s)\n            let rec loop () =\n                match readEscaped i with\n                | ERROR -> None\n                | EOF -> Some (string buf)\n                | x -> buf.Append(char x) |> ignore; loop ()\n            loop ()\n\ntype internal PathUtil =\n    static member WriteQuery q =\n        let sb = StringBuilder 128\n        let mutable start = true\n        q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n            if start then\n                start <- false\n            else \n                sb.Append('&') |> ignore                    \n            sb.Append(k).Append('=').Append(v) |> ignore\n        )\n        sb.ToString()\n\n    static member WriteLink s q =\n        let sb = StringBuilder 128\n        if List.isEmpty s then\n            sb.Append('/') |> ignore\n        else\n            s |> List.iter (fun x ->\n                if not (System.String.IsNullOrEmpty x) then\n                    sb.Append('/').Append(x) |> ignore\n            )\n        if Map.isEmpty q then () \n        else \n            let mutable start = true\n            sb.Append('?') |> ignore                    \n            q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n                if start then\n                    start <- false\n                else \n                    sb.Append('&') |> ignore                    \n                sb.Append(k).Append('=').Append(v) |> ignore\n            )\n        sb.ToString()\n\n[<Proxy(typeof<PathUtil>)>]\ntype internal PathUtilProxy =\n    static member Concat xs = \n        let sb = System.Collections.Generic.Queue()\n        let mutable start = true\n        xs |> List.iter (fun x ->\n            if not (System.String.IsNullOrEmpty x) then\n                if start then\n                    start <- false\n                else \n                    sb.Enqueue(\"/\") |> ignore                    \n                sb.Enqueue(x) |> ignore\n        )\n        sb |> System.String.Concat\n\n    static member WriteQuery q =\n        q |> Map.toSeq |> Seq.map (fun (k, v) -> k + \"=\" + v) |> String.concat \"&\"\n\n    static member WriteLink s q =\n        let query = \n            if Map.isEmpty q then \"\" \n            else \"?\" + PathUtil.WriteQuery(q)\n        \"/\" + PathUtilProxy.Concat s + query\n\n[<JavaScript>]\ntype Route =\n    {\n        Segments : list<string>\n        QueryArgs : Map<string, string>\n        FormData : Map<string, string>\n        Method : option<string> \n        Body : Lazy<string>\n    }\n\n    static member Empty =\n        {\n            Segments = []\n            QueryArgs = Map.empty\n            FormData = Map.empty\n            Method = None\n            Body = Lazy.CreateFromValue null\n        }\n    \n    static member Segment s =\n        { Route.Empty with\n            Segments = [ s ]\n        }\n\n    static member Segment s =\n        { Route.Empty with\n            Segments = s\n        }\n\n    static member Segment (s, m) =\n        { Route.Empty with\n            Segments = s\n            Method = m\n        }\n\n    static member Combine (paths: seq<Route>) =\n        let paths = Seq.toArray paths\n        match paths.Length with\n        | 1 -> paths.[0]\n        | 0 -> Route.Empty\n        | _ ->\n        let mutable method = None\n        let mutable body = null\n        let segments = System.Collections.Generic.Queue()\n        let mutable queryArgs = Map.empty\n        let mutable formData = Map.empty\n        let mutable i = 0\n        let l = paths.Length\n        while i < l do\n            let p = paths.[i]\n            match p.Method with\n            | Some _ as m ->\n                method <- m\n            | _ -> ()\n            match p.Body.Value with\n            | null -> ()\n            | b ->\n                body <- b\n            queryArgs <- p.QueryArgs |> Map.foldBack Map.add queryArgs \n            formData <- p.FormData |> Map.foldBack Map.add formData \n            p.Segments |> List.iter segments.Enqueue\n            i <- i + 1\n        {\n            Segments = List.ofSeq segments\n            QueryArgs = queryArgs\n            FormData = formData\n            Method = method\n            Body = Lazy.CreateFromValue body\n        }\n\n    static member ParseQuery(q: string) =\n        q.Split('&') |> Array.choose (fun kv ->\n            match kv.Split('=') with\n            | [| k; v |] -> Some (k, v)\n            | _ -> \n                printfn \"wrong format for query argument: %s\" kv\n                None\n        ) |> Map.ofSeq\n    \n    static member WriteQuery(q) = PathUtil.WriteQuery q\n\n    static member FromUrl(path: string, ?strict: bool) =\n        let s, q = \n            match path.IndexOf '?' with\n            | -1 -> path, Map.empty\n            | i -> \n                path.Substring(0, i),\n                path.Substring(i + 1) |> Route.ParseQuery\n        let splitOptions =\n            if Option.isSome strict && strict.Value then \n                System.StringSplitOptions.None\n            else\n                System.StringSplitOptions.RemoveEmptyEntries\n        { Route.Empty with\n            Segments = \n                s.Split([| '/' |], splitOptions) |> List.ofArray\n            QueryArgs = q\n        }\n\n    [<JavaScript false>]\n    static member FromRequest(r: Http.Request) =\n        let u = r.Uri\n        let p =\n            if u.IsAbsoluteUri then \n                u.AbsolutePath \n            else \n                let s = u.OriginalString\n                match s.IndexOf('?') with\n                | -1 -> s\n                | q -> s.Substring(0, q)\n        {\n            Segments = p.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries) |> List.ofArray\n            QueryArgs = r.Get.ToList() |> Map.ofList\n            FormData = r.Post.ToList() |> Map.ofList\n            Method = Some (r.Method.ToString())\n            Body = lazy r.BodyText\n        }\n\n    static member FromHash(path: string, ?strict: bool) =\n        match path.IndexOf \"#\" with\n        | -1 -> Route.Empty\n        | i -> \n            let h = path.Substring(i + 1)\n            if Option.isSome strict && strict.Value then \n                if h = \"\" || h = \"/\" then\n                    Route.Empty\n                elif h.StartsWith \"/\" then\n                    Route.FromUrl(h.Substring(1), true)\n                else\n                    Route.Segment(h)                    \n            else\n                Route.FromUrl(path.Substring(i), false)\n\n    member this.ToLink() = PathUtil.WriteLink this.Segments this.QueryArgs\n\n[<JavaScript>]\nmodule internal List =\n    let rec startsWith s l =\n        match s, l with\n        | [], _ -> Some l\n        | sh :: sr, lh :: lr when sh = lh -> startsWith sr lr\n        | _ -> None\n\ntype IRouter<'T> =\n    abstract Route : Http.Request -> option<'T>\n    abstract Link : 'T -> option<System.Uri>\n\n[<JavaScript>]\ntype Router =\n    {\n        Parse : Route -> Route seq\n        Segment : seq<Route> \n    }\n    \n    static member FromString (name: string) =\n        let parts = name.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton path\n                Segment = Seq.empty\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p })\n                    | _ -> Seq.empty\n                Segment = \n                    Seq.singleton (Route.Segment parts)\n            }\n\n    static member (/) (before: Router, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Segment = \n                Seq.append before.Segment after.Segment\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router, b: Router) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Segment = a.Segment\n        }\n\n    [<Inline>]\n    static member Combine<'A, 'B when 'A: equality and 'B: equality>(a: Router<'A>, b: Router<'B>) : Router<'A * 'B> =\n        a / b\n\nand [<JavaScript>] Router<'T when 'T: equality> =\n    {\n        Parse : Route -> (Route * 'T) seq\n        Write : 'T -> option<seq<Route>> \n    }\n    \n    static member (/) (before: Router<'T>, after: Router<'U>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun (p, y) -> (p, (x, y))))\n            Write = fun (v1, v2) ->\n                match before.Write v1, after.Write v2 with\n                | Some p1, Some p2 -> Some (Seq.append p1 p2)\n                | _ -> None\n        }\n\n    static member (/) (before: Router, after: Router<'T>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Write = fun v ->\n                after.Write v |> Option.map (Seq.append before.Segment)\n        }\n\n    static member (/) (before: Router<'T>, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun p -> (p, x)))\n            Write = fun v ->\n                before.Write v |> Option.map (fun x -> Seq.append x after.Segment)\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router<'T>) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router<'T>, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router<'T>, b: Router<'T>) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Write = fun value ->\n                match a.Write value with\n                | None -> b.Write value\n                | p -> p\n        }\n\n    interface IRouter<'T> with\n        [<JavaScript false>]\n        member this.Route req = \n            let path = Route.FromRequest req\n            this.Parse path\n            |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n        [<JavaScript false>]\n        member this.Link ep =\n            this.Write ep |> Option.map (fun p -> System.Uri((Route.Combine p).ToLink(), System.UriKind.Relative))\n        \n[<JavaScript>]\nmodule Router =\n    [<Inline>]\n    let Combine (a: Router<'A>) (b: Router<'B>) = a / b\n    \n    [<Inline>]\n    let Shift (prefix: string) (router: Router<'A>) =\n        prefix / router\n\n    let Empty<'A when 'A: equality> : Router<'A> =\n        {\n            Parse = fun _ -> Seq.empty\n            Write = fun _ -> None\n        }\n\n    /// Creates a fully customized router.\n    let New (route: Http.Request -> option<'T>) (link: 'T -> option<System.Uri>) =\n        { new IRouter<'T> with\n            member this.Route req = route req\n            member this.Link e = link e\n        }\n\n    /// Creates a router for parsing/writing a full route using URL segments.\n    let Create (ser: 'T -> list<string>) (des: list<string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des path.Segments with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment(ser value)))\n        } : Router<'T>\n\n    /// Creates a router for parsing/writing a full route using URL segments and query parameters.\n    let CreateWithQuery (ser: 'T -> list<string> * Map<string, string>) (des: list<string> * Map<string, string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des (path.Segments, path.QueryArgs) with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                let s, q = ser value\n                Some (Seq.singleton { Route.Empty with Segments = s; QueryArgs = q })\n        }\n    \n    /// Parses/writes a single value from a query argument with the given key instead of url path.\n    let Query key (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.empty\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (p, v) ->\n                        { path with QueryArgs = newQa }, v\n                    )\n            Write = fun value ->\n                item.Write value |> Option.map (fun p -> \n                    let p = Route.Combine p\n                    match p.Segments with\n                    | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                    | _ -> Seq.empty\n                )\n        }\n\n    /// Parses/writes a single option value from an optional query argument with the given key instead of url path.\n    let QueryOption key (item: Router<'A>) : Router<option<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, None)\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, Some v\n                    )\n            Write = fun value ->\n                match value with\n                | None -> Some Seq.empty\n                | Some v ->\n                    item.Write v |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n        }\n\n    /// Parses/writes a single nullable value from an optional query argument with the given key instead of url path.\n    let QueryNullable key (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, System.Nullable())\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, System.Nullable v\n                    )\n            Write = fun value ->\n                if value.HasValue then\n                    item.Write value.Value |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n                else\n                    Some Seq.empty\n        }\n\n    let Method (m: string) : Router =\n        {\n            Parse = fun path ->\n                match path.Method with\n                | Some pm when pm = m -> Seq.singleton path\n                | _ -> Seq.empty\n            Segment =\n                Seq.singleton { Route.Empty with Method = Some m }\n        }\n\n    let Body (deserialize: string -> option<'A>) (serialize: 'A -> string) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.Body.Value with\n                | null -> Seq.empty\n                | x ->\n                    match deserialize x with\n                    | Some b -> Seq.singleton ({ path with Body = Lazy.CreateFromValue null}, b)\n                    | _ -> Seq.empty\n            Write = fun value ->\n                Some <| Seq.singleton { Route.Empty with Body = Lazy.CreateFromValue (serialize value) }\n        }\n\n    let FormData (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                item.Parse { path with QueryArgs = path.FormData }\n                |> Seq.map (fun (_, r) -> path, r)\n            Write = fun value ->\n                item.Write value\n                |> Option.map (Seq.map (fun p -> { p with QueryArgs = Map.empty; FormData = p.QueryArgs }))  \n        }\n    \n    let Parse (router: Router<'A>) path =\n        router.Parse path\n        |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n\n    let Write (router: Router<'A>) endpoint =\n        router.Write endpoint |> Option.map Route.Combine \n\n    let TryLink (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> Some (p.ToLink())\n        | None -> None\n\n    let Link (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> p.ToLink()\n        | None -> \"\"\n\n    let Ajax (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some path ->\n            let settings = AjaxSettings(DataType = DataType.Text)\n            match path.Method with\n            | Some m -> settings.Type <- As m\n            | _ -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    settings.ContentType <- Union1Of2 false\n                    settings.Data <- fd\n                    settings.ProcessData <- false\n            | b ->\n                settings.ContentType <- Union2Of2 \"application/json\"\n                settings.Data <- b\n                settings.ProcessData <- false\n            if Option.isNone path.Method then settings.Type <- RequestType.POST \n            Async.FromContinuations (fun (ok, err, cc) ->\n                settings.Success <- fun res _ _ -> ok (As<string> res) \n                settings.Error <- fun _ _ msg -> err (exn msg)\n                // todo: cancellation\n                let url = path.ToLink()\n                JQuery.Ajax(url, settings) |> ignore\n            )\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let Fetch (router: Router<'A>) endpoint : Promise<Response> =\n        match Write router endpoint with\n        | Some path ->\n            let options = RequestOptions()\n            match path.Method with\n            | Some m -> options.Method <- m\n            | None -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    options.Body <- fd\n            | b ->\n                options.Body <- b\n            if Option.isNone path.Method then options.Method <- \"POST\"\n            JS.Fetch(path.ToLink(), options)\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let HashLink (router: Router<'A>)  endpoint =\n        \"#\" + Link router endpoint\n    \n    /// Maps a router to a narrower router type. The decode function must return None if the\n    /// value can't be mapped to a value of the target.\n    let Slice (decode: 'T -> 'U option) (encode: 'U -> 'T) (router: Router<'T>) : Router<'U> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Maps a router to a wider router type. The encode function must return None if the\n    /// value can't be mapped back to a value of the source.\n    let Embed (decode: 'A -> 'B) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Maps a router with a bijection.\n    let Map (decode: 'A -> 'B) (encode: 'B -> 'A) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Combination of Slice and Embed, a mapping from a subset of source values to\n    /// a subset of target values. Both encode and decode must return None if\n    /// there is no mapping to a value of the other type.\n    let TryMap (decode: 'A -> 'B option) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Filters a router, only parsing/writing values that pass the predicate check.\n    let Filter predicate router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.filter (snd >> predicate)\n            Write = fun value ->\n                if predicate value then router.Write value else None\n        }\n\n    [<Name \"Box\">]\n    let private BoxImpl tryUnbox (router: Router<'A>): Router<obj> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, box v) \n            Write = fun value ->\n                tryUnbox value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts to Router<obj>. When writing, a type check against type A is performed.\n    let Box (router: Router<'A>): Router<obj> =\n        BoxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Inline>]\n    let Json<'T when 'T: equality> : Router<'T> =\n        Body (fun s -> try Some (Json.Deserialize<'T> s) with _ -> None) Json.Serialize<'T>\n\n    [<Name \"Unbox\">]\n    let UnboxImpl<'A when 'A: equality> tryUnbox (router: Router<obj>) : Router<'A> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryUnbox v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                box value |> router.Write\n        }\n\n    [<Inline>]\n    /// Converts from Router<obj>. When parsing, a type check against type A is performed.\n    let Unbox<'A when 'A: equality> (router: Router<obj>) : Router<'A> =\n        UnboxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Name \"Cast\">]\n    let private CastImpl tryParseCast tryWriteCast (router: Router<'A>): Router<'B> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryParseCast v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                tryWriteCast value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts a Router<A> to Router<B>. When parsing and writing, type checks are performed.\n    /// Upcasting do not change set of parsed routes, downcasting restricts it within the target type.\n    let Cast (router: Router<'A>): Router<'B> =\n        CastImpl (fun v -> match box v with :? 'B as v -> Some v | _ -> None) (fun v -> match box v with :? 'A as v -> Some v | _ -> None) router\n\n    /// Maps a single-valued (non-generic) Router to a specific value.\n    let MapTo value (router: Router) =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun p -> p, value) \n            Write = fun v ->\n                if v = value then Some router.Segment else None\n        }\n\n    /// Parses/writes using any of the routers, attempts are made in the given order.\n    let Sum (routers: seq<Router<_>>) =\n        let routers = Array.ofSeq routers\n        {\n            Parse = fun path ->\n                routers |> Seq.collect (fun r -> r.Parse path)\n            Write = fun value ->\n                routers |> Seq.tryPick (fun r -> r.Write value)\n        }\n    \n    // todo: optimize\n    let Table<'T when 'T : equality> (mapping: seq<'T * string>) : Router<'T> =\n        mapping |> Seq.map (fun (v, s) -> Router.FromString s |> MapTo v) |> Sum \n\n    let Single<'T when 'T : equality> (endpoint: 'T) (route: string) : Router<'T> =\n        let parts = route.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton (path, endpoint)\n                Write = fun value -> if value = endpoint then Some Seq.empty else None\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p }, endpoint)\n                    | _ -> Seq.empty\n                Write = fun value ->\n                    if value = endpoint then Some (Seq.singleton (Route.Segment parts)) else None\n            }\n\n    let Delay<'T when 'T: equality> (getRouter: unit -> Router<'T>) : Router<'T> =\n        let r = lazy getRouter()\n        {\n            Parse = fun path -> r.Value.Parse path\n            Write = fun value -> r.Value.Write value\n        }\n\n    /// Creates a router for parsing/writing an Array of values.\n    let Array (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Int32.TryParse h with\n                    | true, l ->\n                        let rec collect l path acc =\n                            if l = 0 then Seq.singleton (path, Array.ofList (List.rev acc))\n                            else item.Parse path |> Seq.collect(fun (p, a) -> collect (l - 1) p (a :: acc))\n                        collect l { path with Segments = t } []\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (Seq.append (Seq.singleton (Route.Segment (string value.Length))) (parts |> Seq.collect Option.get))\n                else None                      \n        }\n\n    /// Creates a router for parsing/writing a Nullable value.\n    let Nullable (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"null\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, System.Nullable())\n                | _ ->\n                    item.Parse path |> Seq.map (fun (p, v) -> p, System.Nullable v)\n            Write = fun value ->\n                if value.HasValue then \n                    item.Write value.Value\n                else \n                    Some (Seq.singleton (Route.Segment \"null\"))\n        }\n\n    /// Creates a router for parsing/writing an F# option of a value.\n    let Option (item: Router<'A>) : Router<'A option> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"None\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, None)\n                | \"Some\" :: p ->\n                    item.Parse { path with Segments = p } |> Seq.map (fun (p, v) -> p, Some v)\n                | _ ->\n                    Seq.empty\n            Write = fun value ->\n                match value with \n                | None -> Some (Seq.singleton (Route.Segment \"None\"))\n                | Some v -> \n                    item.Write v |> Option.map (Seq.append (Seq.singleton (Route.Segment \"Some\")))\n        }\n\n    module FArray = Collections.Array\n\n    type IListArrayConverter =\n        abstract OfArray: obj -> obj\n        abstract ToArray: obj -> obj\n\n    type ListArrayConverter<'T>() =\n        interface IListArrayConverter with\n            member this.OfArray a = List.ofArray (unbox<'T []> a) |> box\n            member this.ToArray l = List.toArray (unbox<'T list> l) |> box\n\n    /// Creates a router for parsing/writing an F# list of a value.\n    let List (item: Router<'A>) : Router<'A list> =\n        Array item |> Map List.ofArray FArray.ofList\n\ntype Router with\n    [<Inline>]\n    member this.MapTo(value: 'T) =\n        Router.MapTo value this\n\n    [<Inline>]\n    static member Sum ([<System.ParamArray>] routers: Router<'T>[]) =\n        Router.Sum routers\n\n    [<Inline>]\n    static member Empty<'T when 'T: equality>() =\n        Router.Empty<'T>\n\n    [<JavaScript false>]\n    static member New(route: System.Func<Http.Request, 'T>, link: System.Func<'T, System.Uri>) =\n        Router.New (route.Invoke >> Option.ofObj) (link.Invoke >> Option.ofObj)\n\n    [<Inline>]\n    static member Method(method:string) =\n        Router.Method method\n\n    [<Inline>]\n    static member Body(des:System.Func<string, 'T>, ser: System.Func<'T, string>) =\n        Router.Body (fun s -> des.Invoke s |> Option.ofObj) ser.Invoke \n\n    [<Inline>]\n    static member Json<'T when 'T: equality>() =\n        Router.Json<'T>\n\n    [<Inline>]\n    static member Table([<System.ParamArray>] mapping: ('T * string)[]) =\n        Router.Table mapping\n\n    [<Inline>]\n    static member Single(endpoint, route) =\n        Router.Single endpoint route\n\n    [<Inline>]\n    static member Delay(getRouter: System.Func<Router<'T>>) =\n        Router.Delay getRouter.Invoke\n\ntype Router<'T when 'T: equality> with\n\n    [<Inline>]\n    member this.Query(key: string) =\n        Router.Query key this\n\n    [<Inline>]\n    member this.Link(endpoint: 'T) =\n        Router.Link this endpoint\n\n    [<Inline>]\n    member this.TryLink(endpoint: 'T, link: byref<string>) =\n        match Router.TryLink this endpoint with\n        | Some l ->\n            link <- l\n            true\n        | _ -> false\n               \n    [<Inline>]\n    member this.HashLink(endpoint: 'T) =\n        Router.HashLink this endpoint\n\n    [<Inline>]\n    member this.Map(decode: System.Func<'T, 'U>, encode: System.Func<'U, 'T>) =\n        Router.TryMap (decode.Invoke >> ofObjNoConstraint) (encode.Invoke >> ofObjNoConstraint) this\n\n    [<Inline>]\n    member this.Filter(predicate: System.Func<'T, bool>) =\n        Router.Filter predicate.Invoke this\n\n    [<Inline>]\n    member this.Cast<'U when 'U: equality>() : Router<'U> =\n        Router.Cast this\n\n    [<Inline>]\n    member this.FormData() =\n        Router.FormData this\n\n    [<Inline>]\n    member this.Ajax(endpoint) =\n        Router.Ajax this endpoint |> Async.StartAsTask\n\n    [<Inline>]\n    member this.Box() =\n        Router.Box this\n\n    [<Inline>]\n    member this.Array() =\n        Router.Array this\n\nopen System.Runtime.CompilerServices\n    \n[<Extension>]\ntype RouterExtensions =\n    [<Inline>]\n    static member QueryNullable(router, key) =\n        Router.QueryNullable key router\n\n    [<Inline>]\n    static member Unbox<'T when 'T: equality>(router) =\n        Router.Unbox<'T> router\n\n    [<Inline>]\n    static member Nullable(router) =\n        Router.Nullable router\n\nmodule IRouter =\n    open System\n\n    let Empty : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route _ = None\n            member this.Link _ = None\n        }        \n\n    let Add (r1: IRouter<'T>) (r2: IRouter<'T>) =\n        { new IRouter<'T> with\n            member this.Route req = match r1.Route req with Some _ as l -> l | _ -> r2.Route req\n            member this.Link e = match r1.Link e with Some _ as l -> l | _ -> r2.Link e\n        }        \n\n    let Sum (routers: seq<IRouter<'T>>) : IRouter<'T> =\n        let routers = Array.ofSeq routers\n        if Seq.isEmpty routers then Empty else\n            { new IRouter<'T> with\n                member this.Route req = routers |> Array.tryPick (fun r -> r.Route req)\n                member this.Link e = routers |> Array.tryPick (fun r -> r.Link e)\n            }        \n            \n    let Map encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> router.Link\n        } \n        \n    let TryMap encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.bind encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let Embed encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let private makeUri uri =\n        let mutable res = null\n        if Uri.TryCreate(uri, UriKind.Relative, &res) then res else\n            Uri(uri, UriKind.Absolute)\n    \n    let private path (uri: Uri) =\n        if uri.IsAbsoluteUri\n        then uri.AbsolutePath\n        else uri.OriginalString |> joinWithSlash \"/\"\n        \n    let private trimFinalSlash (s: string) =\n        match s.TrimEnd('/') with\n        | \"\" -> \"/\"\n        | s -> s\n    \n    let Shift prefix (router: IRouter<'T>) =\n        let prefix = joinWithSlash \"/\" prefix\n        let shift (loc: System.Uri) =\n            if loc.IsAbsoluteUri then loc else\n                makeUri (joinWithSlash prefix (path loc) |> trimFinalSlash)\n        { new IRouter<'T> with\n            member this.Route req =\n                let builder = UriBuilder req.Uri\n                if builder.Path.StartsWith prefix then\n                    builder.Path <- builder.Path.Substring prefix.Length\n                    router.Route (req.WithUri(builder.Uri))\n                else\n                    None\n            member this.Link e = router.Link e |> Option.map shift\n        }     \n        \n    let Box (router: IRouter<'T>) : IRouter<obj> =\n        { new IRouter<obj> with\n            member this.Route req = router.Route req |> Option.map box\n            member this.Link e = tryUnbox<'T> e |> Option.bind router.Link\n        } \n\n    let Unbox (router: IRouter<obj>) : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route req = router.Route req |> Option.bind tryUnbox<'T>\n            member this.Link e = box e |> router.Link\n        } \n\n[<JavaScript>]\nmodule RouterOperators =\n    let rRoot : Router =\n        {\n            Parse = fun path -> Seq.singleton path\n            Segment = Seq.empty\n        }\n    \n    [<Inline>]\n    /// Parse/write a specific string.\n    let r name : Router = Router.FromString name\n\n    /// Parse/write a string using URL encode/decode.\n    let rString : Router<string> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some s ->\n                        Seq.singleton ({ path with Segments = t }, s)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if isNull value then \"null\" else StringEncoding.write value)))\n        }\n\n    /// Parse/write a char.\n    let rChar : Router<char> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some c when c.Length = 1 ->\n                        Seq.singleton ({ path with Segments = t }, char c)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    [<Inline>]\n    let inline rTryParse< ^T when ^T: (static member TryParse: string * byref< ^T> -> bool) and ^T: equality>() =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    let mutable res = Unchecked.defaultof< ^T>\n                    let ok = (^T: (static member TryParse: string * byref< ^T> -> bool) (h, &res))\n                    if ok then \n                        Seq.singleton ({ path with Segments = t }, res)\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    /// Parse/write a Guid.\n    let rGuid = rTryParse<System.Guid>()\n    /// Parse/write an int.\n    let rInt = rTryParse<int>()\n    /// Parse/write a double.\n    let rDouble = rTryParse<double>()\n    /// Parse/write a signed byte.\n    let rSByte = rTryParse<sbyte>() \n    /// Parse/write a byte.\n    let rByte = rTryParse<byte>() \n    /// Parse/write a 16-bit int.\n    let rInt16 = rTryParse<int16>() \n    /// Parse/write a 16-bit unsigned int.\n    let rUInt16 = rTryParse<uint16>() \n    /// Parse/write an unsigned int.\n    let rUInt = rTryParse<uint32>() \n    /// Parse/write a 64-bit int.\n    let rInt64 = rTryParse<int64>() \n    /// Parse/write a 64-bit unsigned int.\n    let rUInt64 = rTryParse<uint64>() \n    /// Parse/write a single.\n    let rSingle = rTryParse<single>() \n\n    /// Parse/write a bool.\n    let rBool : Router<bool> =\n        // we define rBool not with rTryParse so that fragments are capitalized\n        // to be fully consistent on client+server\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Boolean.TryParse h with\n                    | true, g ->\n                        Seq.singleton ({ path with Segments = t }, g)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if value then \"True\" else \"False\")))\n        }\n\n    /// Parses any remaining part of the URL as a string, no URL encode/decode is done.\n    let rWildcard : Router<string> = \n        {\n            Parse = fun path ->\n                let s = path.Segments |> String.concat \"/\"\n                Seq.singleton ({ path with Segments = [] }, s)\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment value))\n        }\n    \n    let rWildcardArray (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, Array.ofList (List.rev acc))\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let rWildcardList (item: Router<'A>) : Router<'A list> = \n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, List.rev acc)\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> List.map item.Write\n                if List.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    /// Parse/write a DateTime in `YYYY-MM-DD-HH.mm.ss` format.\n    let rDateTime : Router<System.DateTime> =\n        let pInt x =\n            match System.Int32.TryParse x with\n            | true, i -> Some i\n            | _ -> None\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    if h.Length = 19 && h.[4] = '-' && h.[7] = '-' && h.[10] = '-' && h.[13] = '.' && h.[16] = '.' then\n                        match pInt h.[0 .. 3], pInt h.[5 .. 6], pInt h.[8 .. 9], pInt h.[11 .. 12], pInt h.[14 .. 15], pInt h.[17 .. 18] with\n                        | Some y, Some m, Some d, Some h, Some mi, Some s  ->\n                            Seq.singleton ({ path with Segments = t }, System.DateTime(y, m, d, h, mi, s))\n                        | _ -> Seq.empty\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun d ->\n                let pad2 (x: int) =\n                    let s = string x\n                    if s.Length = 1 then \"0\" + s else s\n                let pad4 (x: int) =\n                    let s = string x\n                    match s.Length with\n                    | 1 -> \"000\" + s\n                    | 2 -> \"00\" + s\n                    | 3 -> \"0\" + s\n                    | _ -> s\n                let s = \n                    pad4 d.Year + \"-\" + pad2 d.Month + \"-\" + pad2 d.Day\n                    + \"-\" + pad2 d.Hour + \".\" + pad2 d.Minute + \".\" + pad2 d.Second\n                Some (Seq.singleton (Route.Segment s))\n        }\n      \n    let internal Tuple (readItems: obj -> obj[]) (createTuple: obj[] -> obj) (items: Router<obj>[]) =\n        {\n            Parse = fun path ->\n                let rec collect elems path acc =\n                    match elems with \n                    | [] -> Seq.singleton (path, createTuple (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect (List.ofArray items) path []\n            Write = fun value ->\n                let parts =\n                    (readItems value, items) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let internal JSTuple (items: Router<obj>[]) : Router<obj> =\n        let readItems (value: obj) =\n            Array.init items.Length (fun i ->\n                (As<Array<obj>> value).[i]\n            )\n        Tuple readItems box items\n\n    [<Inline>]\n    let internal JSEmpty () : Router<obj> = Router.Empty<obj>\n\n    [<Inline>]\n    let internal JSArray item = Router.Array item\n    \n    [<Inline>]\n    let internal JSList item = Router.List item\n\n    [<Inline>]\n    let internal JSOption item = Router.Option item\n\n    [<Inline>]\n    let internal JSNullable item = Router.Nullable item\n\n    [<Inline>]\n    let internal JSQuery key item = Router.Query key item\n\n    [<Inline>]\n    let internal JSQueryOption key item = Router.QueryOption key item\n\n    [<Inline>]\n    let internal JSQueryNullable key item = Router.QueryNullable key item\n\n    [<Inline>]\n    let internal JSFormData item = Router.FormData item\n\n    [<Inline>]\n    let internal JSJson<'T when 'T: equality> = Router.Json<'T>\n\n    [<Inline>]\n    let internal JSBox item = Router.Box item\n\n    [<Inline>]\n    let internal JSDelayed getRouter = Router.Delay getRouter\n        \n    let internal JSRecord (t: obj) (fields: (string * bool * Router<obj>)[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createRecord fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let fields = fields |> Array.map (fun (_, _, r) -> r)\n        let fieldsList =  List.ofArray fields        \n        {\n            Parse = fun path ->\n                let rec collect fields path acc =\n                    match fields with \n                    | [] -> Seq.singleton (path, createRecord (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect fieldsList path []\n            Write = fun value ->\n                let parts =\n                    (readFields value, fields) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n    \n    let internal isCorrectMethod m p =\n        match p, m with\n        | Some pm, Some m -> pm = m\n        | _, Some _ -> false\n        | _ -> true\n\n    let internal JSUnion (t: obj) (cases: (option<obj> * (option<string> * string[])[] * Router<obj>[])[]) : Router<obj> = \n        let getTag value = \n            let constIndex =\n                cases |> Seq.tryFindIndex (\n                    function\n                    | Some c, _, _ -> value = c\n                    | _ -> false\n                )\n            match constIndex with\n            | Some i -> i\n            | _ -> value?(\"$\") \n        let readFields tag value =\n            let _, _, fields = cases.[tag]\n            Array.init fields.Length (fun i ->\n                value?(\"$\" + string i)\n            )\n        let createCase tag fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            match cases.[tag] with\n            | Some constant, _, _ -> constant\n            | _ ->\n                o?(\"$\") <- tag\n                fieldValues |> Seq.iteri (fun i v ->\n                    o?(\"$\" + string i) <- v\n                )\n                o\n        let parseCases =\n            cases |> Seq.indexed |> Seq.collect (fun (i, (_, eps, fields)) ->\n                eps |> Seq.map (fun (m, p) -> i, m, p, fields)    \n            )\n        {                                                    \n            Parse = fun path ->\n                parseCases |> Seq.collect (fun (i, m, s, fields) ->\n                    if isCorrectMethod m path.Method then\n                        match path.Segments |> List.startsWith (List.ofArray s) with\n                        | Some p -> \n                            match List.ofArray fields with\n                            | [] -> Seq.singleton ({ path with Segments = p }, createCase i [||])\n                            | fields -> \n                                let rec collect fields path acc =\n                                    match fields with \n                                    | [] -> Seq.singleton (path, createCase i (Array.ofList (List.rev acc)))\n                                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                                collect fields { path with Segments = p } []\n                        | None -> Seq.empty\n                    else\n                        Seq.empty\n                )\n            Write = fun value ->\n                let tag = getTag value\n                let _, eps, fields = cases.[tag]\n                let method, path = eps.[0]\n                let casePath = Seq.singleton (Route.Segment (List.ofArray path, method))\n                match fields with\n                | [||] -> Some casePath\n                | _ ->\n                    let fieldParts =\n                        (readFields tag value, fields) ||> Array.map2 (fun v f -> f.Write v)\n                    if Array.forall Option.isSome fieldParts then\n                        Some (Seq.append casePath (fieldParts |> Seq.collect Option.get))\n                    else None                      \n        }\n\n    let internal JSClass (ctor: unit -> obj) (fields: (string * bool * Router<obj>)[]) (endpoints: (option<string> * Union<string, int>[])[]) (subClasses: Router<obj>[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createObject fieldValues =\n            let o = ctor()\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let partsAndRoutersLists =\n            endpoints |> Array.map (fun (m, ep) ->\n                m, \n                ep |> Seq.map (fun p ->\n                    match p with\n                    | Union1Of2 s -> Choice1Of2 s\n                    | Union2Of2 i -> \n                        let _, _, r = fields.[i]\n                        Choice2Of2 (i, r)\n                ) |> List.ofSeq\n            )\n        let thisClass =\n            {\n                Parse = fun path ->\n                    let rec collect fields path arr =\n                        match fields with \n                        | [] -> \n                            Seq.singleton (path, createObject arr)\n                        | Choice1Of2 p :: t -> \n                            match path.Segments with\n                            | pp :: pr when pp = p ->\n                                collect t { path with Segments = pr } arr\n                            | _ -> Seq.empty\n                        | Choice2Of2 (i, h) :: t -> \n                            h.Parse path |> Seq.collect(fun (p, a) -> \n                                let narr = Array.copy arr\n                                narr.[i] <- a\n                                collect t p narr\n                            )\n                    partsAndRoutersLists |> Seq.collect (fun (m, ps) -> \n                        if isCorrectMethod m path.Method then\n                            let arr = Array.zeroCreate fields.Length\n                            collect ps path arr\n                        else Seq.empty\n                    )\n                Write = fun value ->\n                    let values = readFields value\n                    let method, ep = endpoints.[0]\n                    let parts =\n                        ep |> Array.map (function\n                            | Union1Of2 p -> Some (Seq.singleton (Route.Segment(p)))\n                            | Union2Of2 i ->\n                                let _, _, r = fields.[i] \n                                r.Write(values.[i])\n                        )\n                    if Array.forall Option.isSome parts then\n                        let w = parts |> Seq.collect Option.get\n                        match method with\n                        | Some _ -> Some (Seq.append (Seq.singleton { Route.Empty with Method = method }) w)\n                        | None -> Some w\n                    else None                      \n            }\n        if Array.isEmpty subClasses then\n            thisClass\n        else\n            Router.Sum (Seq.append subClasses (Seq.singleton thisClass))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule internal Observer =\n\n    type Message<'T> =\n        | Message of 'T\n        | Error of exn\n        | Completed\n\n    let Of f : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = raise x\n            member __.OnCompleted() = ()\n        }\n\n    let New (f, e, c) : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = e x\n            member __.OnCompleted() = c()\n        }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\nmodule internal HotStream =\n    open System\n\n    /// Implementation for \"hot stream\".\n    /// Subscribers to hot streams will only observe the latest\n    /// and future values.\n    [<JavaScript>]\n    type HotStream<'T> =\n        internal\n            {\n                Latest  : ref<option<'T>>\n                Event   : Event<'T>\n            }\n        interface IObservable<'T> with\n            member this.Subscribe(o) =\n                if this.Latest.Value.IsSome then\n                    o.OnNext this.Latest.Value.Value\n                let disp =\n                    this.Event.Publish.Subscribe(fun v ->\n                        o.OnNext(v)\n                    )\n                disp\n\n        member this.Trigger(v) =\n            this.Latest := Some v\n            this.Event.Trigger v\n\n        static member New<'U>() : HotStream<'U> =\n            {\n                Latest = ref None\n                Event = Event<_>()\n            }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.JavaScript>]\nmodule internal WebSharper.Control.Observable\n\nopen System\nopen WebSharper\n\n[<Inline>]\nlet New f : IObservable<'T> = { new IObservable<'T> with member __.Subscribe o = f o }\n\nlet Of (f: ('T -> unit) -> (unit -> unit)) : IObservable<_> =\n    New (fun o -> Disposable.Of (f (fun x -> o.OnNext x)))\n\nlet Return<'T> (x: 'T) : IObservable<'T> =\n    let f (o : IObserver<'T>) =\n        o.OnNext x\n        o.OnCompleted ()\n        Disposable.Of ignore\n    New f\n\nlet Never<'T> () : IObservable<'T> =\n    New(fun _ ->\n        Disposable.Of ignore\n    )\n\nlet Protect f succeed fail =\n    match (try Choice1Of2 (f ()) with e -> Choice2Of2 e) with\n    | Choice1Of2 x -> (succeed x)\n    | Choice2Of2 e -> (fail e)\n\nlet Map (f: 'T -> 'U) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) o1.OnNext o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\n\nlet Filter (f: 'T -> bool) (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let on v = \n            Protect (fun () -> if f v then Some v else None)\n                (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <|  Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Choose  (f: 'T -> option<'U>) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Drop count (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let index = ref 0\n        let on v =\n            incr index\n            if index.Value > count then\n                o1.OnNext v\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Merge (io1: IObservable<'T>) (io2: IObservable<'T>) : IObservable<'T> =\n    New <| fun o ->\n        let completed1 = ref false\n        let completed2 = ref false\n        let disp1 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed1 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io1.Subscribe\n        let disp2 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed2 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io2.Subscribe\n        Disposable.Of (fun () -> disp1.Dispose(); disp2.Dispose())\n\nlet Concat (io1: IObservable<'T>) (io2: IObservable<'T>) =\n    New <| fun o ->\n        let innerDisp = ref None\n        let outerDisp =\n            io1.Subscribe(\n                Observer.New(o.OnNext, ignore, fun () ->\n                    innerDisp := Some <| io2.Subscribe(o)\n                )\n            )\n        Disposable.Of <| fun () ->\n            if innerDisp.Value.IsSome then\n                innerDisp.Value.Value.Dispose ()\n            outerDisp.Dispose()\n\n\nlet Range (start: int , count: int) : IObservable<int> =\n    New <| fun o ->\n        for i = start to start + count do\n            o.OnNext i\n        Disposable.Of ignore\n\n\nlet CombineLatest   (io1 : IObservable<'T>)\n                    (io2: IObservable<'U>)\n                    (f: 'T -> 'U -> 'S) : IObservable<'S> =\n    New <| fun o ->\n        let lv1 = ref None\n        let lv2 = ref None\n        let update () =\n            match !lv1, !lv2 with\n            | Some v1, Some v2  ->\n                Protect (fun () -> f v1 v2) o.OnNext o.OnError\n            | _                 ->\n                ()\n        let o1 =\n            let onNext x =\n                lv1 := Some x\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let o2 =\n            let onNext y =\n                lv2 := Some y\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let d1 = io1.Subscribe(o1)\n        let d2 = io2.Subscribe(o2)\n        Disposable.Of (fun () -> d1.Dispose() ; d2.Dispose())\n\nlet Switch (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp =\n            let index = ref 0\n            let disp : option<IDisposable> ref = ref None\n\n            // Subscribe to outer stream\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Update counter\n                incr index\n\n                // Dispose old observer\n                if disp.Value.IsSome then\n                    disp.Value.Value.Dispose ()\n\n                let currentIndex = index.Value\n                let d =\n                    o1.Subscribe (fun v ->\n                        if currentIndex = index.Value then\n                            o.OnNext(v)\n                    ) |> Some\n                // Update dispose\n                disp := d\n            )\n        disp\n    )\n\nlet SelectMany (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp = ref ignore\n        // Subscribe to outer stream\n        let d =\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Subscribe to inner stream\n                let d =\n                    o1.Subscribe (fun v ->\n                        o.OnNext v\n                    )\n                disp := fun () ->\n                    disp.Value ()\n                    d.Dispose ()\n            )\n        Disposable.Of (fun () ->\n            disp.Value ()\n            d.Dispose ()\n        )\n    )\n\nlet Aggregate (io: IObservable<'T>) (seed: 'S) (fold: 'S -> 'T -> 'S) =\n    New <| fun o1 ->\n        let state = ref seed\n        let on v = \n            Protect (fun () -> fold !state v) \n                (fun s -> state := s; o1.OnNext s) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n////    let CollectLatest (outer: IObservable<IObservable<'T>>) : IObservable<seq<'T>> =\n//        New (fun o ->\n//            let dict = System.Collections.Generic.Dictionary<int, 'T>()\n//            let index = ref 0\n//\n//            // Outer subscription\n//            outer.Subscribe(fun (inner: IObservable<'T>) ->\n//                incr index\n//                let currentIndex = index.Value\n//\n//                // Inner subscription\n//                inner.Subscribe(fun value ->\n//                    dict.[currentIndex] <- value\n//                    seq {for pair in dict do yield pair.Value}\n//                    |> o.OnNext\n//                )|> ignore\n//            )\n//        )\n\nlet Sequence (ios: seq<IObservable<'T>>) : IObservable<List<'T>> =\n    let rec sequence (ios: list<IObservable<'T>>) =\n        match ios with\n        | []        ->\n            Return []\n        | x::xs  ->\n            let rest = sequence xs\n            CombineLatest x rest  (fun x y -> x :: y)\n    sequence (List.ofSeq ios)\n\n\n[<Inline>]\nlet Heat (io: IObservable<'T>) : IObservable<'T> =\n    let formStream = HotStream.HotStream<_>.New()\n    let disp =\n        io.Subscribe formStream.Trigger\n    formStream :> IObservable<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.ObservableModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private ObservableModule =\n\n    [<Inline>]\n    let Add (f: 'T -> unit) (o: IObservable<'T>) =\n        ignore (o.Subscribe (Observer.Of f))\n\n    [<Inline>]\n    let Choose (c: 'T -> option<'U>) (e: IObservable<'T>) =\n        Observable.Choose c e\n\n    [<Inline>]\n    let Filter (ok: 'T -> bool) (e: IObservable<'T>) : IObservable<'T> =\n        Observable.Filter ok e\n\n    [<Inline>]\n    let Map (f: 'T -> 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.Map f e\n\n    [<Inline>]\n    let Merge (e1: IObservable<'T>) (e2: IObservable<'T>) =\n        Observable.Merge e1 e2\n\n    let Pairwise (e: IObservable<'T>) : IObservable<'T * 'T> =\n        Observable.New <| fun o1 ->\n            let last = ref None\n            let on v =\n                match !last with\n                | None -> ()\n                | Some l -> o1.OnNext(l, v)\n                last := Some v\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Partition (f: 'T -> bool) (e: IObservable<'T>) :\n            IObservable<'T> * IObservable<'T> =\n        (Observable.Filter f e, Observable.filter (f >> not) e)\n\n    let Scan (fold: 'U -> 'T -> 'U) (seed: 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.New <| fun o1 ->\n            let state = ref seed\n            let on v = \n                Observable.Protect (fun () -> fold !state v) \n                    (fun s -> state := s; o1.OnNext s) o1.OnError\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Split (f: 'T -> Core.Choice<'U1,'U2>) (e: IObservable<'T>) :\n            IObservable<'U1> * IObservable<'U2> =\n        let left =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _ -> None)\n        let right =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _ -> None)\n        (left, right)\n\n    [<Inline>]\n    let Subscribe (f: 'T -> unit) (e: IObservable<'T>) =\n        e.Subscribe f\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nmodule internal Event =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type Event<'T> = private { Handlers : ResizeArray<Handler<'T>> } with\n\n        member this.Trigger(x: 'T) =\n            for h in this.Handlers.ToArray() do\n                h.Invoke(null, x)\n\n        member this.AddHandler(h: Handler<'T>) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: Handler<'T>) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        member this.Subscribe(observer: IObserver<'T>) =\n            let h = new Handler<'T>(fun _ x -> observer.OnNext x)\n            this.AddHandler h\n            Disposable.Of (fun () -> this.RemoveHandler h)\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IObservable<'T> with\n                member this.Subscribe observer = this.Subscribe observer\n\n        interface IDelegateEvent<Handler<'T>> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n        interface IEvent<'T>\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n\nmodule internal DelegateEvent =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type DelegateEvent<'T when 'T :> System.Delegate and 'T: equality> = private { Handlers : ResizeArray<'T> } with\n\n        member this.Trigger(x: obj[]) =\n            for h in this.Handlers.ToArray() do\n                h.DynamicInvoke(x) |> ignore\n\n        member this.AddHandler(h: 'T) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: 'T) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IDelegateEvent<'T> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\n[<Proxy(typeof<Event<_>>)>]\n[<Name \"WebSharper.Control.FSharpEvent\">]\ntype private FSharpEvent<'T> [<JavaScript>] () =\n    let event = Event.New ()\n\n    [<Inline>]\n    member this.Trigger(x: 'T) = event.Trigger x\n\n    member this.Publish with [<Inline>] get () = event :> IEvent<_>\n\n[<Proxy(typeof<DelegateEvent<_>>)>]\n[<Name \"WebSharper.Control.FSharpDelegateEvent\">]\ntype private FSharpDelegateEvent<'T when 'T :> System.Delegate and 'T: equality> [<JavaScript>] () =\n    let event = DelegateEvent.New ()\n\n    [<Inline>]\n    member this.Trigger(args: obj[]) = event.Trigger args\n\n    member this.Publish with [<Inline>] get () = event :> IDelegateEvent<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.EventModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private EventModule =\n\n    [<Inline>]\n    let Add f (e: IEvent<_,_>) = e.Add f\n\n    let Choose c (e: IEvent<_,_>) : IEvent<_> =\n        // let r = Event.New ()\n        let r = Event<_>()\n        e.Add (fun x ->\n            match c x with\n            | Some y    -> r.Trigger y\n            | None      -> ())\n        r.Publish :> _\n\n    let Filter ok (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> if ok x then r.Trigger x)\n        r :> _\n\n    let Map f (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> r.Trigger (f x))\n        r :> _\n\n    let Merge<'D1,'T,'D2 when 'D1 :> Delegate\n                          and 'D1 :  delegate<'T,unit>\n                          and 'D2 :> Delegate\n                          and 'D2 :  delegate<'T,unit>>\n            (e1: IEvent<'D1,'T>) (e2: IEvent<'D2,'T>) : IEvent<_> =\n        let r = Event.New ()\n        e1.Add r.Trigger\n        e2.Add r.Trigger\n        r :> _\n\n    let Pairwise (e: IEvent<_,_>) : IEvent<_> =\n        let buf = ref None\n        let ev  = Event.New ()\n        e.Add (fun x ->\n            match buf.Value with\n            | None ->\n                buf := Some x\n            | Some old ->\n                buf := Some x\n                ev.Trigger(old, x))\n        ev :> _\n\n    let Partition f e =\n        (Event.filter f e, Event.filter (f >> not) e)\n\n    let Scan fold seed e =\n        let state = ref seed\n        let f value =\n            state := fold !state value\n            !state\n        Event.map f e\n\n    let Split (f: 'T -> Choice<'U1,'U2>) (e: IEvent<'Del,'T>) =\n        (\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _                 -> None),\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _                 -> None)\n        )\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Threading\n\n[<Proxy(typeof<AsyncReplyChannel<_>>)>]\ntype private ChannelProxy<'T> =\n    [<Inline \"$this($res)\">]\n    member this.Reply(res: 'T) = X<unit>\n\n[<Proxy(typeof<MailboxProcessor<_>>)>]\n[<Name \"MailboxProcessor\">]\ntype private MailboxProcessorProxy<'T> (initial, ?token: CancellationToken) =\n    let mutable started = false\n    let errorEvent = Event<exn>()\n    let mailbox = LinkedList<'T>()\n    let mutable savedCont = None\n\n    let startAsync a =\n        Async.Start(a, ?cancellationToken = token)\n\n    let resume() =\n        match savedCont with\n        | None -> ()\n        | Some c ->\n            savedCont <- None\n            c |> startAsync\n\n    do  match token with\n        | Some ct -> \n            ct.Register(fun () -> resume()) |> ignore\n        | None -> ()\n\n    let dequeue() =\n        let f = mailbox.First.Value\n        mailbox.RemoveFirst()\n        f\n\n    [<CLIEvent>]\n    member this.Error = errorEvent.Publish\n\n    member val DefaultTimeout = -1 with get, set    \n\n    member this.Start() =\n        if started then\n            failwith \"The MailboxProcessor has already been started.\"\n        else\n            started <- true\n            async {\n                try do! initial (As<MailboxProcessor<'T>> this)\n                with err -> errorEvent.Trigger err\n            } |> startAsync\n\n    static member Start(initial, ?token: CancellationToken) =\n        let mb = new MailboxProcessor<'T>(initial, ?cancellationToken = token)\n        mb.Start()\n        mb\n\n    [<Inline>]\n    member this.Post(msg: 'T) =\n        mailbox.AddLast msg |> ignore\n        resume()\n\n    member this.TryReceive(?timeout: int) =        \n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if mailbox.First = null then\n                if timeout < 0 then\n                    savedCont <- Some <| async { dequeue() |> Some |> ok }\n                else  \n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout \n                    savedCont <- Some <| async { \n                        if !waiting then do\n                            waiting := false  \n                            JS.ClearTimeout pending\n                            dequeue() |> Some |> ok \n                    }\n            else dequeue() |> Some |> ok\n\n    member this.Receive(?timeout: int) =\n        async {\n            let! x = this.TryReceive(?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n                              \n    member this.CurrentQueueLength = mailbox.Count\n\n    member this.PostAndTryAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R option> =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if timeout < 0 then\n                As (Some >> ok) |> msgf |> this.Post\n            else\n                let waiting = ref true\n                As (fun res ->\n                    if !waiting then\n                        waiting := false\n                        ok (Some res)\n                ) |> msgf |> this.Post\n                JS.SetTimeout (fun () ->\n                    if !waiting then\n                        waiting := false\n                        ok None        \n                ) timeout |> ignore               \n\n    member this.PostAndAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R> =\n        async {\n            let! x = this.PostAndTryAsyncReply(msgf, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n\n    member this.TryScan(scanner, ?timeout: int) =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        async {\n            let scanInbox() =\n                let mutable m = mailbox.First\n                let mutable found = None\n                while m <> null do \n                    match scanner m.Value with\n                    | None ->\n                        m <- m.Next\n                    | _ as a ->\n                        mailbox.Remove m\n                        m <- null\n                        found <- a\n                found\n            match scanInbox() with\n            | Some found -> \n                let! res = found\n                return Some res\n            | _ -> return! Async.FromContinuations <| fun (ok, _, _) -> \n                if timeout < 0 then\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                ok (Some res)\n                        }\n                    scanNext()\n                else\n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                if !waiting then do\n                                    waiting := false\n                                    JS.ClearTimeout pending\n                                    ok (Some res)\n                        }\n                    scanNext()\n        }\n        \n    member this.Scan(scanner, ?timeout: int) =\n        async {\n            let! x = this.TryScan(scanner, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\nmodule Array =\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine\n    /// all items into a single value.\n    [<JavaScript>]\n    let TreeReduce (defaultValue: 'A) (reduction: 'A -> 'A -> 'A) (array: 'A[]) : 'A =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine \n    /// all items into a single value using the mapping function first on each item.\n    [<JavaScript>]\n    let MapTreeReduce (mapping: 'A -> 'B) (defaultValue: 'B) (reduction: 'B -> 'B -> 'B) (array: 'A[]) : 'B =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                mapping array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    [<JavaScript>]\n    /// Same as Array.ofSeq, but if argument is an array, it does not copy it.\n    let ofSeqNonCopying (xs: seq<'T>) : 'T [] =\n        if xs :? System.Array then\n            xs :?> 'T[]\n        elif xs :? _ list then\n            Array.ofList (xs :?> 'T list)\n        elif obj.ReferenceEquals(xs, null) then\n            [||]\n        else\n            let q : 'T [] = [||]\n            use o = xs.GetEnumerator()\n            while o.MoveNext() do\n                q.JS.Push(o.Current) |> ignore\n            q\n\n    [<JavaScript>]\n    /// Unsafe operation, modifies each element of an array by a mapping function.\n    let mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n        if IsClient then\n            for i = 0 to Array.length arr - 1 do\n                arr.JS.[i] <- As (f arr.JS.[i])\n            As<'T2[]> arr\n        else Array.map f arr\n\nmodule internal String =\n\n    [<JavaScript>]\n    let isBlank s =\n        String.forall Char.IsWhiteSpace s\n\nmodule internal List =\n\n    // TODO: better impl only going to n?\n    [<JavaScript>]\n    let replaceFirst (k: 'A -> bool) (f: 'A -> 'A) (l: list<'A>) =\n        let didIt = ref false\n        l |> List.map (fun x -> if not !didIt && k x then f x else x)\n\n    // TODO: better impl only going to n?\n    [<JavaScript>]\n    let maybeReplaceFirst (k: 'A -> bool) (f: 'A -> option<'A>) (l: list<'A>) =\n        let didIt = ref false\n        l |> List.map (fun x -> if not !didIt && k x then defaultArg (f x) x else x)\n\n/// Abbreviations and small utilities for this assembly.\n[<AutoOpen>]\nmodule internal Abbrev =\n\n    [<JavaScript>]\n    module Fresh =\n\n        let mutable private counter = 0\n\n        let Int () =\n            counter <- counter + 1\n            counter\n\n        let Id () =\n            counter <- counter + 1\n            \"uid\" + string counter\n\n    [<JavaScript>]\n    module HashSet =\n\n        let ToArray (set: HashSet<'T>) =\n            let arr = Array.create set.Count JS.Undefined\n            set.CopyTo(arr)\n            arr\n\n        let Except (excluded: HashSet<'T>) (included: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray included)\n            set.ExceptWith(ToArray excluded)\n            set\n\n        let Intersect (a: HashSet<'T>) (b: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray a)\n            set.IntersectWith(ToArray b)\n            set\n\n        let Filter (ok: 'T -> bool) (set: HashSet<'T>) =\n            HashSet<'T>(ToArray set |> Array.filter ok)\n\n    [<JavaScript>]\n    module Dict =\n\n        let ToKeyArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Key)\n            arr\n\n        let ToValueArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Value)\n            arr\n\n    module Queue =\n\n        [<Inline \"$q\">]\n        let ToArray (q: Queue<_>) = q.ToArray()\n\n    [<JavaScript>]\n    [<Sealed>]\n    type Slot<'T,'K when 'K : equality>(key: 'T -> 'K, value: 'T) =\n        member s.Value = value\n\n        override s.Equals(o: obj) =\n            key value = key (o :?> Slot<'T,'K>).Value\n\n        override s.GetHashCode() = hash (key value)\n\n    [<JavaScript>]\n    type Slot =\n        static member Create key value = Slot(key, value)\n\n    [<JavaScript>]\n    module Async =\n\n        [<Direct \"console.log('WebSharper UI: Uncaught asynchronous exception', $e)\">]\n        let OnError (e: exn) = ()\n\n        let StartTo comp k =\n            Async.StartWithContinuations (comp, k, OnError, ignore)\n\n        [<Inline \"WebSharper.Concurrency.scheduler().Fork($f)\">]\n        let Schedule f =\n            async { return f () }\n            |> Async.Start\n\n    [<JavaScript>]\n    module Mailbox =\n\n        type MailboxState =\n            | Idle = 0\n            | Working = 1\n            | WorkingMore = 2\n\n        /// Simplified MailboxProcessor implementation.\n        let StartProcessor procAsync =\n            let st = ref MailboxState.Idle\n            let rec work() =\n                async {\n                    do! procAsync\n                    match !st with\n                    | MailboxState.Working -> \n                        st := MailboxState.Idle\n                    | MailboxState.WorkingMore ->\n                        st := MailboxState.Working\n                        return! work() \n                    | _ -> ()\n                }\n            let post() =\n                match !st with\n                | MailboxState.Idle ->\n                    st := MailboxState.Working\n                    Async.Start (work()) \n                | MailboxState.Working -> \n                    st := MailboxState.WorkingMore\n                | _ -> ()\n            post\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System.Collections.Generic\n\ntype AppendList<'T> =\n    | AL0\n    | AL1 of 'T\n    | AL2 of AppendList<'T> * AppendList<'T>\n    | AL3 of 'T []\n\n[<JavaScript>]\nmodule AppendList =\n\n    type T<'T> = AppendList<'T>\n\n    let Empty<'T> : T<'T> = AL0\n\n    let Append x y =\n        match x, y with\n        | AL0, x | x, AL0 -> x\n        | _ -> AL2 (x, y)\n\n    let Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Empty Append\n\n    let Single x =\n        AL1 x\n\n    let ToArray xs =\n        let out = Queue()\n        let rec loop xs =\n            match xs with\n            | AL0 -> ()\n            | AL1 x -> out.Enqueue x\n            | AL2 (x, y) -> loop x; loop y\n            | AL3 xs -> Array.iter (fun v -> out.Enqueue v) xs\n        loop xs\n        out.ToArray()\n\n    let FromArray xs =\n        match Array.length xs with\n        | 0 -> AL0\n        | 1 -> AL1 xs.[0]\n        | _ -> AL3 (Array.copy xs)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Utility functions for manipulating DOM.\n[<JavaScript>]\nmodule internal DomUtility =\n\n    /// The current DOM Document.\n    let Doc = JS.Document\n\n    /// Appends a child node to the given DOM element.\n    let AppendTo (ctx: Dom.Element) node =\n        ctx.AppendChild(node) |> ignore\n\n    /// Removes all attributes from the given DOM element.\n    let ClearAttrs (ctx: Dom.Element) =\n        while ctx.HasAttributes() do\n            ctx.RemoveAttributeNode(ctx.Attributes.[0] :?> _) |> ignore\n\n    /// Removes all child nodes from the given DOM element.\n    let Clear (ctx: Dom.Element) =\n        while ctx.HasChildNodes() do\n            ctx.RemoveChild(ctx.FirstChild) |> ignore\n\n    /// Creates a new DOM element.\n    let CreateElement (name: string) =\n        Doc.CreateElement name\n\n    /// Creates an element in the SVG namespace.\n    let CreateSvgElement (name: string) =\n        Doc.CreateElementNS(\"http://www.w3.org/2000/svg\", name)\n\n    /// Creates a new DOM text node with the given value.\n    let CreateText s =\n        Doc.CreateTextNode(s)\n\n    /// Creates a new DOM attribute.\n    let CreateAttr name value =\n        let a = Doc.CreateAttribute(name)\n        a.Value <- value\n        a\n\n    /// Removes a DOM attribute.\n    let RemoveAttr (el: Dom.Element) (attrName: string) =\n        el.RemoveAttribute attrName\n\n    /// Sets the value of the attribute given by\n    /// `name` to `value` in element `el`.\n    let SetAttr (el: Dom.Element) name value =\n        el.SetAttribute(name, value)\n\n    [<Direct \"$target.setProperty($name, $value)\">]\n    let private SetProperty (target: obj) (name: string) (value: string) = ()\n\n    /// Sets a style property.\n    let SetStyle (el: Dom.Element) name value =\n        SetProperty el?style name value\n\n    /// Safe remove of a node\n    let RemoveNode (parent: Dom.Element) (el: Dom.Node) =\n        // make sure not to remove already removed nodes\n        if obj.ReferenceEquals(el.ParentNode, parent) then\n            parent.RemoveChild(el) |> ignore\n\n    /// Position in a `children` list of a DOM Element\n    /// where a node can be inserted.\n    [<AllowNullLiteral>]\n    type InsertPos [<Inline \"$x\">] private (x: Dom.Node) =\n        [<Inline>]\n        static member AtEnd = null : InsertPos\n        [<Inline>]\n        static member BeforeNode n = InsertPos n\n    [<Inline>]\n    let AtEnd = InsertPos.AtEnd\n    [<Inline>]\n    let BeforeNode n = InsertPos.BeforeNode n\n\n    /// Inserts a new child node into the tree under\n    /// a given `parent` at given `pos`.\n    let InsertAt (parent: Dom.Element) (pos: InsertPos) (node: Dom.Node) =\n        let currentPos (node: Dom.Node) =\n            match node.NextSibling with\n            | null -> AtEnd\n            | s -> BeforeNode s\n        let canSkip =\n            node.ParentNode ===. parent\n            && pos ===. currentPos node\n        if not canSkip then\n            parent.InsertBefore(node, As pos) |> ignore\n\n    let private clsRE cls =\n        new RegExp(@\"(\\s+|^)\" + cls + @\"(?:\\s+\" + cls + \")*(\\s+|$)\", \"g\")\n\n    [<Inline \"$element instanceof SVGElement\">]\n    let private isSvg (element: Dom.Element) = X<bool>\n\n    let private getClass (element: Dom.Element) =\n        if isSvg element then\n            element.GetAttribute(\"class\")\n        else\n            element.ClassName\n\n    let private setClass (element: Dom.Element) (value: string) =\n        if isSvg element then\n            element.SetAttribute(\"class\", value)\n        else\n            element.ClassName <- value\n\n    /// Adds a class.\n    let AddClass (element: Dom.Element) (cl: string) =\n        let c = getClass element\n        if c = \"\" then\n            setClass element cl\n        elif not <| (clsRE cl).Test(c) then\n            setClass element (c + \" \" + cl)\n\n    /// Removes a class.\n    let RemoveClass (element: Dom.Element) (cl: string) =\n        setClass element <|\n            (clsRE cl).Replace(getClass element, FuncWithArgs(fun (_fullStr, before, after) ->\n                if before = \"\" || after = \"\" then \"\" else \" \"\n            ))\n\n    /// Retrieve the children of an element as an array.\n    let ChildrenArray (element: Dom.Element) : Dom.Node[] =\n        let a = [||]\n        for i = 0 to element.ChildNodes.Length - 1 do\n            a.JS.Push(element.ChildNodes.[i]) |> ignore\n        a\n\n    /// Iterate through a NodeList assuming it's all Elements.\n    let IterSelector (el: Dom.Element) (selector: string) (f: Dom.Element -> unit) =\n        let l = el.QuerySelectorAll(selector)\n        for i = 0 to l.Length - 1 do f (l.[i] :?> Dom.Element)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System.Collections.Generic\nmodule M = Map\n\n/// Trie lookup structure.\ntype Trie<'K,'V when 'K : comparison> =\n    | TrieBranch of Map<'K,Trie<'K,'V>> // invariant: not empty\n    | TrieEmpty\n    | TrieLeaf of 'V\n\n/// Trie combinators.\n[<JavaScript>]\nmodule Trie =\n\n    /// Branch trie, maintaining invariant.\n    let TrieBranch xs =\n        if M.isEmpty xs then TrieEmpty else TrieBranch xs\n\n    /// Singleton trie.\n    let Leaf v =\n        TrieLeaf v\n\n    /// Prefix a trie - becomes a branch.\n    let Prefix key trie =\n        TrieBranch (Map [key, trie])\n\n    /// Finds a value in a multi-map.\n    let MultiFind key map =\n        defaultArg (M.tryFind key map) []\n\n    /// Adds a value to a multi-map.\n    let MultiAdd key value map =\n        Map.add key (value :: MultiFind key map) map\n\n    /// Makes sure all results are Some.\n    let AllSome (xs: seq<option<'T>>) =\n        let e = xs.GetEnumerator()\n        let r = ResizeArray()\n        let mutable ok = true\n        while ok && e.MoveNext() do\n            match e.Current with\n            | None -> ok <- false\n            | Some x -> r.Add(x)\n        if ok then Some (r.ToArray() :> seq<_>) else None\n\n    /// Merges multiple maps into one given a merge function on values.\n    let MergeMaps merge maps =\n        Seq.collect M.toSeq maps\n        |> Seq.fold (fun s (k, v) -> MultiAdd k v s) M.empty\n        |> M.toSeq\n        |> Seq.map (fun (k, vs) -> merge vs |> Option.map (fun v -> (k, v)))\n        |> AllSome\n        |> Option.map Map.ofSeq\n\n    /// Checks for leaves.\n    let IsLeaf t =\n        match t with\n        | TrieLeaf _ -> true\n        | _ -> false\n\n    /// Merges tries.\n    let rec Merge (ts: seq<_>) =\n        let ts = Array.ofSeqNonCopying ts\n        match ts.Length with\n        | 0 -> Some TrieEmpty\n        | 1 -> Some ts.[0]\n        | _ ->\n            // leaves do not merge\n            if Array.exists IsLeaf ts then None else\n                ts\n                |> Seq.choose (function\n                    | TrieBranch map -> Some map\n                    | _ -> None)\n                |> MergeMaps Merge\n                |> Option.map TrieBranch\n\n    /// Inner loop for Map function.\n    let rec MapLoop loc f trie =\n        match trie with\n        | TrieBranch mp ->\n            mp\n            |> M.map (fun k v -> MapLoop (loc @ [k]) f v)\n            |> TrieBranch\n        | TrieEmpty -> TrieEmpty\n        | TrieLeaf x -> TrieLeaf (f loc x)\n\n    /// Maps a function.\n    let Map f trie =\n        MapLoop [] f trie\n\n    /// Map with a counter.\n    let Mapi f trie =\n        let counter = ref 0\n        let next () =\n            let c = !counter\n            counter := c + 1\n            c\n        Map (fun x -> f (next ()) x) trie\n\n    /// Collects all values.\n    let ToArray trie =\n        // TODO: more efficient than this.\n        let all = Queue()\n        Map (fun _ v -> all.Enqueue v) trie\n        |> ignore\n        all.ToArray()\n\n    /// Result of lookup function.\n    type LookupResult<'K,'V> =\n        | Found of value: 'V * remainder: list<'K>\n        | NotFound\n\n    /// Lookup main loop.\n    let rec Look key trie =\n        match trie, key with\n        | TrieLeaf v, _ -> Found (v, key)\n        | TrieBranch map, k :: ks ->\n            match M.tryFind k map with\n            | Some trie -> Look ks trie\n            | None -> NotFound\n        | _ -> NotFound\n\n    /// Looks up a value in the trie.\n    let Lookup trie key =\n        Look (Seq.toList key) trie\n\n    /// Empty trie.\n    let Empty<'K,'V when 'K : comparison> : Trie<'K,'V> =\n        TrieEmpty\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\n(*\n\nSnap implements a snapshot of a time-varying value.\n\nFinal states:\n\n    Forever     -- will never be obsolete\n    Obsolete    -- is obsolete\n\nDistinguishing Forever state is important as it avoids a class of\nmemory leaks connected with waiting on a Snap to become obsolete\nwhen it will never do so.\n\nState transitions:\n\n    Waiting         -> Forever      // MarkForever\n    Waiting         -> Obsolete     // MarkObsolete\n    Waiting         -> Ready        // MarkReady\n    Ready           -> Obsolete     // MarkObsolete\n\n*)\n\n[<JavaScript false>]\ntype ISnap =\n    abstract Obsolete : unit -> unit\n    abstract IsNotObsolete : unit -> bool\n\ntype OnObsoleted = Union<ISnap, unit -> unit>\n\n[<JavaScript>]\ntype SnapState<'T> =\n    | Forever of 'T\n    | [<Constant null>] Obsolete\n    | Ready of 'T * Queue<OnObsoleted>\n    | Waiting of Queue<'T -> unit> * Queue<OnObsoleted>\n\n[<JavaScript; AutoOpen>]\nmodule SnapInternals =\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $o()\">]\n    let obs (o: OnObsoleted) doObs =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> f()\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $doFunc($o)\">]\n    let clean (o: OnObsoleted) doObs doFunc =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> doFunc f\n\ntype Snap<'T> =\n    {\n        [<Name \"s\">] mutable State : SnapState<'T>\n    }\n\n    [<JavaScript>]\n    static member Obsolete(sn: Snap<'T>) =\n        match sn.State with\n        | Forever _ | Obsolete -> ()\n        | Ready (_, q) | Waiting (_, q) ->\n            sn.State <- Obsolete\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                obs qa.[i] (fun sn -> sn.Obsolete())\n\n    interface ISnap with\n        member this.Obsolete() =\n            Snap.Obsolete(this)\n\n        member this.IsNotObsolete() =\n            match this.State with\n            | Obsolete -> false\n            | _ -> true\n\n[<Proxy(typeof<ISnap>)>]\ntype internal ISnapProxy =\n    [<Inline>]\n    member this.Obsolete() =\n        Snap.Obsolete(As<Snap<obj>> this)\n\n    [<Inline \"$this.s\">]\n    member this.IsNotObsolete() = X<bool>\n\n[<JavaScript>]\nmodule Snap =\n\n  // constructors\n\n    [<Inline>]\n    let Make st = { State = st }\n\n    [<Inline>]\n    let Create () = Make (Waiting (Queue(), Queue()))\n\n    [<Inline>]\n    let CreateForever v = Make (Forever v)\n\n    [<Inline>]\n    let CreateWithValue v = Make (Ready (v, Queue()))\n\n  // misc\n\n    [<Inline>]\n    let IsForever snap =\n        match snap.State with\n        | Forever _ -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsObsolete snap =\n        match snap.State with\n        | Obsolete -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsDone snap =\n        match snap.State with\n        | Forever _ | Ready _ -> true\n        | _ -> false\n\n    let TryGet snap =\n        match snap.State with\n        | Forever x | Ready (x, _) -> Some x\n        | _ -> None\n\n  // transitions\n\n    let MarkForever sn v =\n        match sn.State with\n        | Waiting (q, _) ->\n            sn.State <- Forever v\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    [<Inline>]\n    let MarkObsolete (sn: Snap<_>) =\n        (sn :> ISnap).Obsolete()\n\n    let MarkReady sn v =\n        match sn.State with\n        | Waiting (q1, q2) ->\n            sn.State <- Ready (v, q2)\n            let qa = Queue.ToArray q1\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    let MarkDone res sn v =\n        if IsForever sn then\n            MarkForever res v\n        else\n            MarkReady res v\n\n    let EnqueueSafe (q: Queue<_>) x =\n        q.Enqueue x\n        if q.Count % 20 = 0 then\n            let qcopy = q.ToArray()\n            q.Clear()\n            for i = 0 to qcopy.Length - 1 do\n                clean qcopy.[i]\n                    (fun sn -> if sn.IsNotObsolete() then q.Enqueue (Union1Of2 sn))\n                    (fun f -> q.Enqueue (Union2Of2 f)) \n\n  // eliminators\n\n    let When snap avail (obs: ISnap) =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q1) -> EnqueueSafe q1 (Union1Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenRun snap avail obs =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs()\n        | Ready (v, q1) -> q1.Enqueue (Union2Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; q2.Enqueue (Union2Of2 obs)\n\n    let WhenReady snap avail =\n        match snap.State with\n        | Forever v\n        | Ready (v, _) -> avail v\n        | Obsolete -> ()\n        | Waiting (q1, _) -> q1.Enqueue avail\n\n    let WhenObsolete snap (obs: ISnap) =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q) -> EnqueueSafe q (Union1Of2 obs)\n        | Waiting (q1, q2) -> EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenObsoleteRun snap obs =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs()\n        | Ready (v, q) -> q.Enqueue (Union2Of2 obs)\n        | Waiting (q1, q2) -> q2.Enqueue (Union2Of2 obs)\n\n    let ValueAndForever snap =\n        match snap.State with\n        | Forever v -> Some (v, true)\n        | Ready (v, _) -> Some (v, false)\n        | _ -> None\n\n  // combinators\n\n    let Join snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n        When snap onReady res\n        res\n\n    let JoinInner snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n            WhenObsolete snap y\n        When snap onReady res\n        res\n\n    let CreateForeverAsync a =\n        let o = Make (Waiting (Queue(), Queue()))\n        Async.StartTo a (MarkForever o)\n        o\n\n    let Sequence (snaps : seq<Snap<'T>>) =\n        let snaps = Array.ofSeq snaps\n        if Array.isEmpty snaps then CreateForever Seq.empty\n        else\n            let res = Create () : Snap<seq<'T>>\n            let w = ref (snaps.Length - 1)\n            let cont _ =\n                if !w = 0 then\n                    // all source snaps should have a value\n                    let vs = \n                        snaps |> Array.map (fun s -> \n                            match s.State with\n                            | Forever v | Ready (v, _) -> v\n                            | _ -> failwith \"value not found by View.Sequence\")\n                    if Array.forall IsForever snaps then\n                        MarkForever res (vs :> seq<_>)\n                    else\n                        MarkReady res (vs :> seq<_>)\n                else\n                    decr w\n            snaps\n            |> Array.iter (fun s -> When s cont res)\n            res\n\n    let Map fn sn =\n        match sn.State with\n        | Forever x -> CreateForever (fn x) // optimization\n        | _ ->\n            let res = Create ()\n            When sn (fun a -> MarkDone res sn (fn a)) res\n            res\n\n    let WithInit x sn =\n        match sn.State with\n        | Forever _\n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = CreateWithValue x\n            When sn (fun _ -> Snap.Obsolete res) res\n            res\n\n    let WithInitOption sn =\n        match sn.State with\n        | Forever x -> CreateForever (Some x) // optimization\n        | Obsolete -> { State = Obsolete }\n        | Ready (v, _) ->\n            let res = CreateWithValue (Some v)\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = CreateWithValue None\n            When sn (fun _ -> Snap.Obsolete res) res\n            res\n\n    let Copy sn =\n        match sn.State with\n        | Forever _ \n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = Create ()\n            When sn (MarkDone res sn) res\n            res\n\n    let MapCachedBy eq prev fn sn =\n        let fn x =\n            match !prev with\n            | Some (x', y) when eq x x' -> y\n            | _ ->\n                let y = fn x\n                prev := Some (x, y)\n                y\n        Map fn sn\n\n    let Map2Opt1 fn x sn2 = Map (fun y -> fn x y) sn2\n    let Map2Opt2 fn y sn1 = Map (fun x -> fn x y) sn1\n    let Map2 fn sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever x, Forever y -> CreateForever (fn x y) // optimization\n        | Forever x, _ -> Map2Opt1 fn x sn2 // optimize for known sn1\n        | _, Forever y -> Map2Opt2 fn y sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (x, f1), Some (y, f2) ->\n                        if f1 && f2 then\n                            MarkForever res (fn x y)\n                        else\n                            MarkReady res (fn x y) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map2Unit sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever (), Forever () -> CreateForever () // optimization\n        | Forever (), _ -> sn2 // optimize for known sn1\n        | _, Forever () -> sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont () =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (_, f1), Some (_, f2) ->\n                        if f1 && f2 then\n                            MarkForever res ()\n                        else\n                            MarkReady res () \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map3Opt1 fn x y sn3   = Map (fun z -> fn x y z) sn3\n    let Map3Opt2 fn x z sn2   = Map (fun y -> fn x y z) sn2\n    let Map3Opt3 fn x sn2 sn3 = Map2 (fun y z -> fn x y z) sn2 sn3\n    let Map3Opt4 fn y z sn1   = Map (fun x -> fn x y z) sn1\n    let Map3Opt5 fn y sn1 sn3 = Map2 (fun x z -> fn x y z) sn1 sn3\n    let Map3Opt6 fn z sn1 sn2 = Map2 (fun x y -> fn x y z) sn1 sn2\n    let Map3 fn sn1 sn2 sn3 =\n        match sn1.State, sn2.State, sn3.State with\n        | Forever x, Forever y, Forever z -> CreateForever (fn x y z)\n        | Forever x, Forever y, _         -> Map3Opt1 fn x y sn3  \n        | Forever x, _,         Forever z -> Map3Opt2 fn x z sn2  \n        | Forever x, _,         _         -> Map3Opt3 fn x sn2 sn3\n        | _,         Forever y, Forever z -> Map3Opt4 fn y z sn1  \n        | _,         Forever y, _         -> Map3Opt5 fn y sn1 sn3\n        | _,         _,         Forever z -> Map3Opt6 fn z sn1 sn2    \n        | _,         _,         _         ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2, ValueAndForever sn3 with\n                    | Some (x, f1), Some (y, f2), Some (z, f3) ->\n                        if f1 && f2 && f3 then\n                            MarkForever res (fn x y z)\n                        else\n                            MarkReady res (fn x y z) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            When sn3 cont res\n            res\n\n    let SnapshotOn sn1 sn2 =\n        let res = Create ()\n        let cont _ =\n            if not (IsDone res) then \n                match ValueAndForever sn1, ValueAndForever sn2 with\n                | Some (_, f1), Some (y, f2) ->\n                    if f1 || f2 then\n                        MarkForever res y \n                    else\n                        MarkReady res y\n                | _ -> ()\n        When sn1 cont res\n        WhenReady sn2 cont\n        res\n\n    let MapAsync fn snap =\n        let res = Create ()\n        When snap\n            (fun v -> Async.StartTo (fn v) (MarkDone res snap))\n            res\n        res\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n#nowarn \"40\" // AsyncAwait let rec\n\nopen System.Collections.Generic\nopen WebSharper\ntype private JS = WebSharper.JavaScript.JS\n\n[<JavaScript; AbstractClass>]\ntype Var<'T>() =\n    abstract Get : unit -> 'T\n    abstract Set : 'T -> unit\n    abstract SetFinal : 'T -> unit\n    member this.Value\n        with [<Inline>] get() = this.Get()\n        and [<Inline>] set v = this.Set v\n    abstract Update : ('T -> 'T) -> unit\n    abstract UpdateMaybe : ('T -> 'T option) -> unit\n    abstract View : View<'T>\n    abstract Id : string\n\nand [<JavaScript>] View<'T> =\n    | View of (unit -> Snap<'T>)\n\n[<AutoOpen>]\nmodule ViewOptimization =\n    open WebSharper.JavaScript\n    [<Inline \"$x\">]\n    let V (x: unit -> Snap<'T>) = View x\n    [<Inline \"$x\">]\n    let (|V|) (x: View<'T>) = let (View v) = x in v\n    [<Inline \"$x\">]\n    let getSnapV (x: Snap<View<'T>>) = Snap.Map (|V|) x\n    [<Inline \"$x\">]\n    let getSnapF (x: 'A -> View<'T>) = x >> (|V|)\n    [<Inline \"null\">]\n    let jsNull<'T>() = Unchecked.defaultof<'T>\n    [<Inline \"Error().stack\">]\n    let jsStack<'T>() = \"\"\n    \n/// Var either holds a Snap or is in Const state.\n[<JavaScript>]\ntype ConcreteVar<'T>(isConst: bool, initSnap: Snap<'T>, initValue: 'T) =\n    inherit Var<'T>()\n\n    let mutable isConst = isConst\n    let mutable current = initValue\n    let mutable snap = initSnap\n    let view = V (fun () -> snap)\n    let id = Fresh.Int()\n\n    override this.Get() = current\n\n    override this.Set(v) =\n        if isConst then\n            printfn \"WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete snap\n            current <- v\n            snap <- Snap.CreateWithValue v\n\n    override this.SetFinal(v) =\n        if isConst then\n            printfn \"WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete snap\n            isConst <- true\n            current <- v\n            snap <- Snap.CreateForever v\n\n    override this.Update(f) =\n        this.Set (f (this.Get()))\n\n    override this.UpdateMaybe(f) =\n        match f (this.Get()) with\n        | None -> ()\n        | Some v -> this.Set(v)\n\n    override this.View = view\n\n    override this.Id = \"uinref\" + string id\n\nand [<JavaScript; Sealed>] Var private () =\n\n    [<Inline>]\n    static let (?) x f = WebSharper.JavaScript.Pervasives.(?) x f\n\n    [<Inline>]\n    static let (?<-) x f v = WebSharper.JavaScript.Pervasives.(?<-) x f v\n\n    static member Create v =\n        ConcreteVar<'T>(false, Snap.CreateWithValue v, v)\n        :> Var<'T>\n\n    static member CreateLogged (name: string) v =\n        if IsClient then\n            if not (JS.Global?UINVars) then\n                JS.Global?UINVars <- [||]\n            let res = Var.Create v\n            JS.Global?UINVars?push([| name; unbox res |])\n            res\n        else\n            Var.Create v\n\n    static member Create() =\n        ConcreteVar<unit>(false, Snap.CreateWithValue(), ())\n        :> Var<unit>\n\n    static member CreateWaiting<'T>() =\n        ConcreteVar<'T>(false, Snap.Create(), jsNull<'T>())\n        :> Var<'T>\n\n    [<Inline>]\n    static member Get (var: Var<'T>) =\n        var.Get()\n\n    static member Set (var: Var<'T>) value =\n        var.Set(value)\n\n    static member SetFinal (var: Var<'T>) value =\n        var.SetFinal(value)\n\n    static member Update var fn =\n        Var.Set var (fn (Var.Get var))\n\n    [<Inline>]\n    static member GetId (var: Var<'T>) =\n        var.Id\n\ntype [<JavaScript>] Updates = \n    {\n        [<Name \"c\">] mutable Current : View<unit>\n        [<Name \"s\">] mutable Snap : Snap<unit>\n        [<Name \"v\">] VarView : View<unit>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Current = v\n                Snap = jsNull()\n                VarView = \n                    let obs () =\n                        let mutable c = var.Snap\n                        if obj.ReferenceEquals(c, null) then\n                            let (V observe) = var.Current\n                            c <- observe() |> Snap.Copy\n                            var.Snap <- c\n                            Snap.WhenObsoleteRun c (fun () -> \n                                var.Snap <- jsNull())\n                            c\n                        else c\n                    \n                    V obs\n            }\n        var\n\n    member this.Value\n        with [<Inline>] get() = this.Current\n        and set v =\n            let sn = this.Snap\n            if not (obj.ReferenceEquals(sn, null)) then\n                Snap.MarkObsolete sn\n            this.Current <- v\n\ntype ViewNode<'A,'B> =\n    {\n        [<Name \"e\">] NValue : 'B\n        [<Name \"r\">] NVar : Var<'A>\n        [<Name \"w\">] NView : View<'A>\n    }\n\ntype LazyView<'T> =\n    {\n        [<Name \"c\">] mutable Current : Snap<'T>\n        [<Name \"o\">] mutable Observe : unit -> Snap<'T>  \n    } \n\n[<JavaScript>]\n[<Sealed>]\ntype View =\n\n    [<Inline>]\n    static member FromVar (var: Var<'T>) =\n        var.View\n\n    static member CreateLazy observe =\n        let lv =\n            {\n                Current = jsNull()\n                Observe = observe \n            }\n        let obs () =\n            let mutable c = lv.Current\n            if obj.ReferenceEquals(c, null) then\n                c <- lv.Observe()\n                lv.Current <- c\n                if Snap.IsForever c then \n                    lv.Observe <- jsNull()\n                else\n                    Snap.WhenObsoleteRun c (fun () -> \n                        lv.Current <- jsNull()) \n                c\n            else c\n        V obs\n\n    static member Map fn (V observe) =\n        View.CreateLazy (fun () ->\n            observe () |> Snap.Map fn)\n\n    static member MapCachedBy eq fn (V observe) =\n        let vref = ref None\n        View.CreateLazy (fun () ->\n            observe () |> Snap.MapCachedBy eq vref fn)\n\n    static member MapCached fn v =\n        View.MapCachedBy (=) fn v\n\n    static member Map2 fn (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2 fn s1 s2)\n\n    static member Map2Unit (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2Unit s1 s2)\n\n    static member Map3 fn (V o1) (V o2) (V o3) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            let s3 = o3 ()\n            Snap.Map3 fn s1 s2 s3)\n\n    static member MapAsync fn (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.MapAsync fn)\n\n    static member MapAsync2 fn v1 v2 =\n        View.Map2 fn v1 v2 |> View.MapAsync id\n\n    static member TryGet (V observe) =\n        Snap.TryGet (observe ())\n\n    static member Get (f: 'T -> unit) (V observe) =\n        let ok = ref false\n        let rec obs () =\n            Snap.WhenRun (observe ())\n                (fun v ->\n                    if not !ok then\n                        ok := true\n                        f v)\n                (fun () -> if not !ok then obs ())\n        obs ()\n\n    static member WithInit (x: 'T) (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.WithInit x)\n\n    static member WithInitOption (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.WithInitOption)\n\n    static member GetAsync v =\n        Async.FromContinuations (fun (ok, _, _) -> View.Get ok v)\n\n    static member SnapshotOn def (V o1) (V o2) =\n        let sInit = Snap.CreateWithValue def\n\n        let obs () =\n            let s1 = o1 ()\n            if Snap.IsObsolete sInit then\n                let s2 = o2 ()\n                Snap.SnapshotOn s1 s2\n            else\n                Snap.WhenObsolete s1 sInit\n                sInit\n\n        View.CreateLazy obs\n\n     // Collections --------------------------------------------------------------\n\n    static member MapSeqCachedBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'A -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let res =\n                        if prevState.ContainsKey k\n                            then prevState.[k]\n                            else conv x\n                    newState.[k] <- res\n                    res)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCached conv view =\n        View.MapSeqCachedBy (fun x -> x) conv view\n\n    static member ConvertSeqNode conv value =\n        let var = Var.Create value\n        let view = View.FromVar var\n        {\n            NValue = conv view\n            NVar = var\n            NView = view\n        }\n\n    static member MapSeqCachedViewBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'K -> View<'A> -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let node =\n                        if prevState.ContainsKey k then\n                            let n = prevState.[k]\n                            Var.Set n.NVar x\n                            n\n                        else\n                            View.ConvertSeqNode (fun v -> conv k v) x\n                    newState.[k] <- node\n                    node.NValue)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCachedView conv view =\n        View.MapSeqCachedViewBy (fun x -> x) (fun _ v -> conv v) view\n\n    [<Inline>]\n    static member Convert<'A, 'B when 'A : equality> (f: 'A -> 'B) v =\n        View.MapSeqCached f v\n\n    [<Inline>]\n    static member ConvertBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'A -> 'B) v =\n        View.MapSeqCachedBy k f v\n\n    [<Inline>]\n    static member ConvertSeq<'A, 'B when 'A : equality> (f: View<'A> -> 'B) v =\n        View.MapSeqCachedView f v\n\n    [<Inline>]\n    static member ConvertSeqBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'K -> View<'A> -> 'B) v =\n        View.MapSeqCachedViewBy k f v\n\n  // More cominators ------------------------------------------------------------\n\n    static member Join (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.Join (getSnapV (observe ())))\n\n    static member Bind (fn: 'A -> View<'B>) view =\n        View.Join (View.Map fn view)\n\n    static member JoinInner (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.JoinInner (getSnapV (observe ())))\n\n    static member BindInner fn view =\n        View.JoinInner (View.Map fn view)\n\n    static member UpdateWhile def v1 v2 =\n        let value = ref def\n        View.BindInner (fun pred ->\n            if pred then\n                View.Map (fun v ->\n                    value := v\n                    v\n                ) v2   \n            else View.Const (!value) \n        ) v1\n\n    static member Sequence views =\n        View.CreateLazy(fun () ->\n            views\n            |> Seq.map (fun (V observe) -> observe ())\n            |> Snap.Sequence)\n\n    static member Const x =\n        let o = Snap.CreateForever x\n        V (fun () -> o)\n\n    static member ConstAsync a =\n        let o = Snap.CreateForeverAsync a\n        V (fun () -> o)\n\n    static member TryWith (f: exn -> View<'T>) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            with exn ->\n                let (V obs) = f exn\n                obs ()\n        )\n\n    static member TryFinally (f: unit -> unit) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            finally\n                f ()\n        )\n\n    static member Sink act (V observe) =\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn act (fun () ->\n                Async.Schedule loop)\n        Async.Schedule loop\n\n    static member RemovableSink act (V observe) =\n        let cont = ref true\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn\n                (fun x -> if !cont then act x)\n                (fun () -> if !cont then Async.Schedule loop)\n        Async.Schedule loop\n        fun () -> cont := false\n\n    static member AsyncAwait filter view =\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec remove =\n                View.RemovableSink (fun value ->\n                    if filter value then\n                        remove ()\n                        ok value\n                ) view\n            ()\n\n    static member Apply fn view =\n        View.Map2 (fun f x -> f x) fn view\n\ntype Var with\n\n    [<JavaScript>]\n    static member Lens (var: Var<_>) get update =\n        let id = Fresh.Id()\n        let view = var.View |> View.Map get\n\n        { new Var<'V>() with\n\n            member this.Get() =\n                get (var.Get())\n\n            member this.Set(v) =\n                var.Update(fun t -> update t v)\n\n            member this.SetFinal(v) =\n                this.Set(v)\n\n            member this.Update(f) =\n                var.Update(fun t -> update t (f (get t)))\n\n            member this.UpdateMaybe(f) =\n                var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n\n            member this.View =\n                view\n\n            member this.Id =\n                id\n        }\n\n    static member MapLens<'A, 'B, 'K when 'K : equality> (getKey: 'A -> 'K) (f: Var<'A> -> 'B) (var: Var<list<'A>>) : View<seq<'B>> =\n        var.View |> View.MapSeqCachedViewBy getKey (fun k v ->\n            let id = Fresh.Id()\n            let isThis a =\n                getKey a = k\n            f { new Var<'A>() with\n\n                member this.Get() =\n                    List.find isThis var.Value\n\n                member this.Set(v) =\n                    var.Update (List.replaceFirst isThis (fun _ -> v))\n\n                member this.SetFinal(v) =\n                    this.Set(v)\n\n                member this.Update(f) =\n                    var.Update(List.replaceFirst isThis f)\n\n                member this.UpdateMaybe(f) =\n                    var.Update(List.maybeReplaceFirst isThis f)\n\n                member this.View =\n                    v\n\n                member this.Id =\n                    id\n            }\n        )\n\n\n// These methods apply to any View<'A>, so we can use `type View with`\n// and they'll be compiled as normal instance methods on View<'A>.\ntype View<'T> with\n\n    [<JavaScript; Inline>]\n    member v.Map f = View.Map f v\n\n    //[<JavaScript; Inline>]\n    //member v.Map (f: System.Func<_, 'B>) =\n    //    View.Map (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.MapAsync f = View.MapAsync f v\n\n    //member v.MapAsync (f: System.Func<_, System.Threading.Tasks.Task<'B>>) =\n    //    v |> View.MapAsync (fun a ->\n    //        async {\n    //            let! res = f.Invoke(a) |> Async.AwaitTask\n    //            return res\n    //        })\n\n    [<JavaScript; Inline>]\n    member v.Bind f = View.Bind f v\n\n    [<JavaScript; Inline>]\n    member v.BindInner f = View.BindInner f v\n\n    //[<JavaScript; Inline>]\n    //member v.Bind (f: System.Func<_, View<'B>>) =\n    //    View.Bind (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.SnapshotOn init v' = View.SnapshotOn init v' v\n\n    [<JavaScript; Inline>]\n    member v.UpdateWhile init vPred = View.UpdateWhile init vPred v\n\n    [<JavaScript; Macro(typeof<Macros.VProp>)>]\n    member v.V = failwith \"View<'T>.V can only be called in an argument to a V-enabled function or if 'T = Doc.\" : 'T\n\ntype Var<'T> with\n\n    [<Macro(typeof<Macros.VProp>)>]\n    member this.V = this.View.V\n\n    [<JavaScript; Inline>]\n    member var.Lens get update =\n        Var.Lens var get update\n\n[<JavaScript>]\ntype FromView<'T>(view: View<'T>, set: 'T -> unit) =\n    inherit Var<'T>()\n\n    let id = Fresh.Int()\n    let mutable current =\n        match View.TryGet view with\n        | Some x -> x\n        | None -> jsNull<'T>()\n    let view = view |> View.Map (fun x -> current <- x; x)\n\n    override this.View = view\n\n    override this.Get() = current\n\n    override this.Set(x) = set x\n\n    override this.UpdateMaybe(f) =\n        view |> View.Get (fun x ->\n            match f x with\n            | None -> ()\n            | Some x -> set x\n        )\n\n    override this.Update(f) =\n        view |> View.Get (f >> set)\n\n    override this.SetFinal(x) = set x\n\n    override this.Id = \"uinref\" + string id\n\ntype Var with\n\n    [<JavaScript; Inline>]\n    static member Make view set =\n        FromView(view, set) :> Var<_>\n\ntype ViewBuilder =\n    | B\n\n    [<JavaScript; Inline>]\n    member b.Bind(x, f) = View.Bind f x\n\n    [<JavaScript; Inline>]\n    member b.Return x = View.Const x\n\n    [<JavaScript; Inline>]\n    member b.ReturnFrom(v: View<'T>) = v\n\n    [<JavaScript; Inline>]\n    member b.TryWith(v, f) = View.TryWith f v\n\n    [<JavaScript; Inline>]\n    member b.TryFinally(v, f) = View.TryFinally f v\n\ntype View with\n    [<JavaScript>]\n    static member Do = B\n\n[<Sealed; JavaScript>]\ntype Submitter<'T> (input: View<'T>, init: 'T) =\n    let var = Var.Create ()\n    let view = View.SnapshotOn init var.View input\n\n    [<Inline>]\n    member this.View = view\n\n    member this.Trigger() = var.Value <- ()\n\n    [<Inline>]\n    member this.Input = input\n\n[<Sealed; JavaScript>]\ntype Submitter =\n\n    [<Inline>]\n    static member CreateDefault input =\n        Submitter<_>(input, Unchecked.defaultof<_>)\n\n    [<Inline>]\n    static member Create input init =\n        Submitter<_>(input, init)\n\n    static member CreateOption input =\n        Submitter<_>(View.Map Some input, None)\n\n    [<Inline>]\n    static member View (s: Submitter<_>) =\n        s.View\n\n    [<Inline>]\n    static member Trigger (s: Submitter<_>) =\n        s.Trigger()\n\n    [<Inline>]\n    static member Input (s: Submitter<_>) =\n        s.Input\n\n[<AutoOpen>]\nmodule V =\n\n    [<Macro(typeof<Macros.V>)>]\n    let V (x: 'T) = View.Const x\n\n[<assembly:System.Runtime.CompilerServices.Extension>]\ndo ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\n\n[<JavaScript>]\ntype Key =\n    | Key of int\n\n    static member Fresh () = Key (Fresh.Int ())\n\n[<JavaScript>]\ntype Model<'I,'M>(var: Var<'M>, view: View<'I>) =\n\n    new (proj: Func<'M, 'I>, init: 'M) =\n        let var = Var.Create init\n        let view = View.Map proj.Invoke var.View\n        Model(var, view)\n\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.View = view\n\n[<JavaScript>]\n[<Sealed>]\ntype Model =\n\n    static member Create proj init =\n        Model(Func<_,_>(proj), init)\n\n    static member Update update (m: Model<'I, 'M>) =\n        Var.Update m.Var (fun x -> update x; x)\n\n    [<Inline>]\n    static member View (m: Model<'I, 'M>) =\n        m.View\n\ntype Storage<'T> =\n    [<Name \"SAppend\">]\n    abstract member Append : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SAppendMany\">]\n    abstract member AppendMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrepend\">]\n    abstract member Prepend : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrependMany\">]\n    abstract member PrependMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SInit\">]\n    abstract member Init : unit -> 'T[]\n    [<Name \"SRemoveIf\">]\n    abstract member RemoveIf : ('T -> bool) -> 'T [] -> 'T[]\n    [<Name \"SSetAt\">]\n    abstract member SetAt : int -> 'T -> 'T[] -> 'T[]\n    [<Name \"SSet\">]\n    abstract member Set : 'T seq -> 'T[]\n\ntype Serializer<'T> =\n    {\n        Encode : 'T -> obj\n        Decode : obj -> 'T\n    }\n\n[<JavaScript>]\nmodule Serializer =\n    open WebSharper\n    open WebSharper.JavaScript\n\n    let Default =\n        {\n            Encode = box\n            Decode = unbox\n        }\n\n    [<Inline>]\n    let Typed =\n        {\n            Encode = WebSharper.Json.Encode<'T>\n            Decode = WebSharper.Json.Decode<'T>\n        }\n\n[<JavaScript>]\nmodule Storage =\n    open WebSharper\n    open WebSharper.JavaScript\n    \n    type private ArrayStorage<'T>(init) =\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Init () = init\n            member x.RemoveIf pred arr = Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; arr\n            member x.Set coll = Seq.toArray coll\n\n    type private LocalStorageBackend<'T>(id : string, serializer : Serializer<'T>) =\n        let storage = JS.Window.LocalStorage\n        let set (arr : 'T[]) = \n            storage.SetItem(id, arr |> Array.map serializer.Encode |> Json.Stringify)\n            arr\n        let clear () = storage.RemoveItem(id)\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; set arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; set arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; set arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; set arr\n\n            member x.Init () =\n                let item = storage.GetItem(id)\n                if item = null then [||]\n                else \n                    try\n                        let arr = As<obj []> <| Json.Parse(item)\n                        arr |> Array.map serializer.Decode\n                    with _ -> [||]\n\n            member x.RemoveIf pred arr = set <| Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; set arr\n            member x.Set coll = set <| Seq.toArray coll\n\n    let InMemory init =\n        new ArrayStorage<_>(init) :> Storage<_>\n\n    let LocalStorage id serializer =\n        new LocalStorageBackend<_>(id, serializer) :> Storage<_>\n\ntype ListModelState<'T> =\n    [<Inline>]\n    member this.Length =\n        JavaScript.Pervasives.As<'T[]>(this).Length\n    [<Inline>]\n    member this.Item\n        with get i = JavaScript.Pervasives.As<'T[]>(this).[i]\n    [<Inline>]\n    member this.ToArray() =                             \n        Array.copy (JavaScript.Pervasives.As<'T[]>(this))\n    [<Inline>]\n    member this.ToArray(pred: Predicate<'T>) =\n        Array.filter pred.Invoke (JavaScript.Pervasives.As<'T[]>(this))\n    interface seq<'T> with\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T[]>(this)).GetEnumerator()\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T seq>(this)).GetEnumerator()\n\n[<JavaScript>]\ntype ListModel<'Key, 'T when 'Key : equality>\n    (\n        key : System.Func<'T, 'Key>,\n        var: Var<'T[]>,\n        storage : Storage<'T>\n    ) =\n\n    let v = var.View.Map(fun x -> Array.copy x :> _ seq)\n           \n    let it = Dictionary<'Key, Snap<option<'T>>>()\n\n    new (key: System.Func<'T, 'Key>, init: seq<'T>) =\n        let init = Seq.toArray init\n        ListModel<'Key, 'T>(key, Var.Create init, Storage.InMemory init)\n\n    new (key: System.Func<'T, 'Key>) =\n        ListModel<'Key, 'T>(key, [||])\n\n    new (key: System.Func<'T, 'Key>, storage: Storage<'T>) =\n        let var =\n            Seq.distinctBy key.Invoke (storage.Init ())\n            |> Seq.toArray\n            |> Var.Create\n        ListModel<'Key, 'T>(key, var, storage)\n\n    [<Inline>]\n    member this.key x = key.Invoke x\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.Storage = storage\n    [<Inline>]\n    member this.View = v\n    [<Inline>]\n    member this.ViewState = JavaScript.Pervasives.As<View<ListModelState<'T>>> var.View\n    [<Inline>]\n    member this.itemSnaps = it\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            (Seq.ofArray var.Value).GetEnumerator()\n\n        member this.GetEnumerator() =\n            var.Value.GetEnumerator()\n\n[<JavaScript>]\nmodule ListModels =\n               \n    let Contains keyFn item xs =\n        let t = keyFn item\n        Array.exists (fun it -> keyFn it = t) xs\n\ntype ListModel<'Key,'T when 'Key : equality> with\n\n    [<Inline>]\n    member m.Key x = m.key x\n\n    [<Inline>]\n    member m.Add item =\n        m.Append item\n\n    member m.ObsoleteKey key =\n        match m.itemSnaps.TryGetValue(key) with\n        | true, sn ->\n            Snap.MarkObsolete sn \n            m.itemSnaps.Remove key |> ignore\n        | _ -> ()\n\n    member m.ObsoleteAll() =\n        m.itemSnaps |> Seq.iter (fun ksn -> Snap.MarkObsolete ksn.Value)\n        m.itemSnaps.Clear()\n\n    member m.Append item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Append item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.AppendMany items =\n        let toAppend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index ->\n                    m.Storage.SetAt index item v\n                | None -> toAppend.Add item; v)\n        m.Var.Value <- m.Storage.AppendMany toAppend v\n\n    member m.Prepend item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Prepend item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.PrependMany items =\n        let toPrepend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index -> \n                    m.Storage.SetAt index item v\n                | None -> toPrepend.Add item; v)\n        m.Var.Value <- m.Storage.PrependMany toPrepend v\n\n    member m.Remove item =\n        let v = m.Var.Value\n        if ListModels.Contains m.key item v then\n            let keyFn = m.key\n            let k = keyFn item\n            m.Var.Value <- m.Storage.RemoveIf (fun i -> keyFn i = k) v\n            m.ObsoleteKey k\n\n    member m.RemoveBy (f: 'T -> bool) =\n        for v in m.Var.Value do\n            if f v then\n                m.ObsoleteKey (m.key v)\n        m.Var.Value <- m.Storage.RemoveIf f m.Var.Value\n\n    member m.RemoveByKey key =\n        m.Var.Value <- m.Storage.RemoveIf (fun i -> m.Key i = key) m.Var.Value\n        m.ObsoleteKey key\n\n    member m.Iter fn =\n        Array.iter fn m.Var.Value\n\n    member m.Set lst =\n        m.Var.Value <- m.Storage.Set lst\n        m.ObsoleteAll()\n\n    member m.ContainsKey key =\n        Array.exists (fun it -> m.key it = key) m.Var.Value\n\n    member m.ContainsKeyAsView key =\n        m.Var.View |> View.Map (Array.exists (fun it -> m.key it = key))\n\n    member m.Find pred =\n        Array.find pred m.Var.Value\n\n    member m.TryFind pred =\n        Array.tryFind pred m.Var.Value\n\n    member m.FindAsView pred =\n        m.Var.View |> View.Map (Array.find pred)\n\n    member m.TryFindAsView pred =\n        m.Var.View |> View.Map (Array.tryFind pred)\n\n    member m.FindByKey key =\n        Array.find (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKey key =\n        Array.tryFind (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKeyAsView key =\n        ViewOptimization.V (fun () -> \n            match m.itemSnaps.TryGetValue(key) with\n            | true, snap -> snap                \n            | _ ->\n                let it = m.TryFindByKey(key)\n                let sn = Snap.CreateWithValue it\n                m.itemSnaps.Add(key, sn)\n                sn\n        )\n\n    member m.FindByKeyAsView key =\n        m.TryFindByKeyAsView key |> View.Map Option.get\n\n    member m.UpdateAll fn =\n        m.Var.Update <| fun a ->\n            a |> Array.iteri (fun i x ->\n                fn x |> Option.iter (fun y -> a.[i] <- y))\n            m.Storage.Set a\n        m.ObsoleteAll()\n\n    member m.UpdateBy fn key =\n        let v = m.Var.Value\n        match Array.tryFindIndex (fun it -> m.key it = key) v with\n        | None -> ()\n        | Some index ->\n            match fn v.[index] with\n            | None -> ()\n            | Some value ->\n                m.Var.Value <- m.Storage.SetAt index value v\n                m.ObsoleteKey key\n\n    [<Inline>]\n    member m.UpdateByU(fn, key) =\n        m.UpdateBy fn key\n\n    member m.Clear () =\n        m.Var.Value <- m.Storage.Set Seq.empty\n        m.ObsoleteAll()\n\n    member m.Length =\n        m.Var.Value.Length\n\n    member m.LengthAsView =\n        m.Var.View |> View.Map (fun arr -> arr.Length)\n\n    member private m.LensInto'(get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key, view: View<'V>) : Var<'V> =\n        let id = Fresh.Id()\n    \n        { new Var<'V>() with\n\n            member r.Get() =\n                m.FindByKey key |> get\n\n            member r.Set(v) =\n                m.UpdateBy (fun i -> Some (update i v)) key\n\n            member r.SetFinal(v) =\n                r.Set(v)\n\n            member r.Update(f) =\n                m.UpdateBy (fun i -> Some (update i (f (get i)))) key\n\n            member r.UpdateMaybe(f) =\n                m.UpdateBy (fun i -> Option.map (fun v -> update i v) (f (get i))) key\n\n            member r.View =\n                view\n\n            member r.Id =\n                id\n        }\n\n    member m.LensInto (get: 'T -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) : Var<'V> =\n        let view = m.FindByKeyAsView(key) |> View.Map get\n        m.LensInto'(get, update, key, view)\n\n    [<Inline>]\n    member m.LensIntoU<'V> (get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key) : Var<'V> =\n        m.LensInto get update key\n\n    member m.Lens (key: 'Key) =\n        m.LensInto id (fun _ -> id) key\n\n    member m.Value\n        with [<Inline>] get () = m.Var.Value :> seq<_>\n        and [<Inline>] set v = m.Set(v)\n\n    [<Inline>]\n    member m.Map (f: 'T -> 'V) : View<seq<'V>> =\n        View.MapSeqCachedBy m.key f m.ViewState\n\n    [<Inline>]\n    member m.Map (f: 'Key -> View<'T> -> 'V) : View<seq<'V>> =\n        View.MapSeqCachedViewBy m.key f m.ViewState\n\n    member m.MapLens (f: 'Key -> Var<'T> -> 'V) =\n        let get k v =\n            f k (m.LensInto'(id, (fun _ -> id), k, v))\n        View.MapSeqCachedViewBy m.key get m.ViewState\n\n[<JavaScript>]\ntype ListModel =\n\n    static member CreateWithStorage<'Key,'T when 'Key : equality>\n            (key: 'T -> 'Key) (storage : Storage<'T>) =\n        ListModel<'Key, 'T>(key, storage)\n\n    static member Create<'Key, 'T when 'Key : equality> (key: 'T -> 'Key) init =\n        ListModel.CreateWithStorage key (Storage.InMemory <| Seq.toArray init)\n\n    static member FromSeq init =\n        ListModel.Create id init\n\n    static member Wrap<'Key, 'T, 'U when 'Key : equality>\n            (underlying: ListModel<'Key, 'U>)\n            (extract: 'T -> 'U)\n            (createItem: 'U -> 'T)\n            (updateItem: 'T -> 'U -> 'T) =\n        let state = ref (Dictionary<'Key, 'T>())\n        let init =\n            underlying.Var.Value |> Array.map (fun u ->\n                let t = createItem u\n                (!state).[underlying.Key u] <- t\n                t)\n        let var : Var<'T[]> =\n            underlying.Var.Lens\n                <| fun us ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let ts =\n                        us |> Array.map (fun u ->\n                            let k = underlying.Key u\n                            let t =\n                                if (!state).ContainsKey(k) then\n                                    updateItem (!state).[k] u\n                                else\n                                    createItem u\n                            newState.[k] <- t\n                            t\n                        )\n                    state := newState\n                    ts\n                <| fun us ts ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let us =\n                        ts |> Array.map (fun t ->\n                            let u = extract t\n                            newState.[underlying.Key u] <- t\n                            u)\n                    state := newState\n                    us\n        ListModel<'Key, 'T>(Func<_,_>(extract >> underlying.Key), var, Storage.InMemory init)\n\n    [<Inline>]\n    static member View (m: ListModel<_,_>) =\n        m.View\n\n    [<Inline>]\n    static member ViewState (m: ListModel<_,_>) =\n        m.ViewState\n\n    [<Inline>]\n    static member Key (m: ListModel<_,_>) =\n        m.key\n\n    [<Inline>]\n    static member Map f (m: ListModel<_, _>) =\n        View.MapSeqCachedBy m.key f m.ViewState\n\n    [<Inline>]\n    static member MapView f (m: ListModel<_, _>) =\n        View.MapSeqCachedViewBy m.key f m.ViewState\n\n    [<Inline>]\n    static member MapLens f (m: ListModel<_, _>) =\n        m.MapLens f\n\ntype ListModel<'Key,'T when 'Key : equality> with\n\n    member this.Wrap extract wrap update =\n        ListModel.Wrap this extract wrap update\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System.Runtime.CompilerServices\nopen WebSharper\nopen WebSharper.JavaScript\ntype private KV<'K, 'V> = System.Collections.Generic.KeyValuePair<'K, 'V>\n\n[<AutoOpen>]\nmodule VarModule =\n\n    [<Macro(typeof<Macros.LensFunction>)>]\n    let Lens (x: 'T) = Var.Create x\n\n// These methods apply to specific types of View (such as View<seq<'A>> when 'A : equality)\n/// so we need to use C#-style extension methods.\n[<Extension; JavaScript>]\ntype ReactiveExtensions() =\n\n    [<Extension; Inline>]\n    static member MapCached (v, f) = View.MapCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<seq<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<seq<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<seq<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<seq<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<list<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<list<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<list<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<list<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<array<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<array<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<array<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<array<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<ListModelState<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<ListModelState<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<ListModelState<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<ListModelState<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality and 'K : comparison>\n        (v: View<Map<'K, 'A>>, f: 'K -> View<'A> -> 'B) =\n        View.MapSeqCachedViewBy\n            (fun (kv: KV<'K, 'A>) -> kv.Key)\n            (fun k v -> f k (View.Map (fun (kv: KV<'K, 'A>) -> kv.Value) v))\n            v\n\n    [<Extension; Macro(typeof<Macros.LensMethod>)>]\n    static member LensAuto<'T, 'U>(ref: Var<'T>, getter: 'T -> 'U) = X<Var<'U>>\n\n    [<Extension; Inline>]\n    static member MapLens<'A, 'B, 'K when 'K : equality>(v: Var<list<'A>>, k: 'A -> 'K, f: Var<'A> -> 'B) = Var.MapLens k f v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype Time = double\ntype NormalizedTime = double\n\n// Interpolation --------------------------------------------------------------\n\ntype Interpolation<'T> =\n    [<Name \"Interpolate\">]\n    abstract Interpolate : NormalizedTime -> 'T -> 'T -> 'T\n\n[<JavaScript>]\ntype DoubleInterpolation =\n    | DoubleInterpolation\n\n    interface Interpolation<double> with\n        member d.Interpolate t x y =\n            x + t * (y - x)\n\n[<JavaScript>]\n[<Sealed>]\ntype Interpolation =\n    static member Double = DoubleInterpolation :> Interpolation<_>\n\n// Easing ---------------------------------------------------------------------\n\n[<JavaScript>]\ntype Easing (transformTime : Converter<NormalizedTime, NormalizedTime>) =\n\n    member this.TransformTime t = transformTime.Invoke t\n    static member Custom f = Easing (fun t -> f t)\n\n[<JavaScript>]\nmodule Easings =\n\n    let CubicInOut =\n        let f t =\n            let t2 = t * t\n            let t3 = t2 * t\n            3. * t2 - 2. * t3\n        Easing.Custom f\n\ntype Easing with\n    static member CubicInOut = Easings.CubicInOut\n\n// Animation ------------------------------------------------------------------\n\ntype Anim<'T> =\n    private {\n        Compute : Time -> 'T\n        Duration : Time\n    }\n\ntype Animation =\n    | Finally of (unit -> unit)\n    | Work of Anim<unit>\n\n[<JavaScript>]\n[<Name \"An\">]\ntype Anim =\n    | Anim of AppendList<Animation>\n\n[<JavaScript>]\nmodule Anims =\n\n    let List (Anim xs) =\n        xs\n\n    let Finalize (Anim all) =\n        AppendList.ToArray all\n        |> Array.iter (function\n            | Finally f -> f ()\n            | _ -> ())\n\n    let Def d f =\n        { Compute = f; Duration = d}\n\n    let Const v =\n        Def 0. (fun t -> v)\n\n    // \"Prolongs\" an animation to the given time by adding in several\n    // no-ops after the animation finishes.\n    let Prolong nextDuration anim =\n        let comp = anim.Compute\n        let dur = anim.Duration\n        let last = lazy anim.Compute anim.Duration\n        let compute t = if t >= dur then last.Value else comp t\n\n        {\n            Compute = compute\n            Duration = nextDuration\n        }\n\n    let ConcatActions xs =\n        let xs = Array.ofSeqNonCopying xs\n        match xs.Length with\n        | 0 -> Const ()\n        | 1 -> xs.[0]\n        | _ ->\n            let dur = xs |> Seq.map (fun anim -> anim.Duration) |> Seq.max\n            let xs = Array.map (Prolong dur) xs\n            Def dur (fun t -> Array.iter (fun anim -> anim.Compute t) xs)\n\n    let Actions (Anim all) =\n        AppendList.ToArray all\n        |> Array.choose (function\n            | Work w -> Some w\n            | _ -> None)\n        |> ConcatActions\n\n    let mutable UseAnimations = true\n\ntype Anim with\n\n    static member UseAnimations \n        with get() = Anims.UseAnimations\n        and set v = Anims.UseAnimations <- v \n\n    static member Append (Anim a) (Anim b) =\n        Anim (AppendList.Append a b)\n\n    static member Concat xs =\n        xs\n        |> Seq.map Anims.List\n        |> AppendList.Concat\n        |> Anim\n\n    static member Const v =\n        Anims.Const v\n\n    static member Simple (inter: Interpolation<'T>) (easing: Easing) dur x y=\n        {\n            Duration = dur\n            Compute = fun t ->\n                let t = easing.TransformTime (t / dur)\n                inter.Interpolate t x y\n        }\n\n    static member Delayed (inter: Interpolation<'T>) (easing: Easing) dur delay x y =\n        {\n            Duration = dur + delay\n            Compute = fun t ->\n              //  JavaScript.Log <| \"T: \" + (string t) + \", delay: \" + (string delay)\n                if t <= delay then\n                    x\n                else\n                    let normalisedTime = easing.TransformTime ((t - delay) / dur)\n                    inter.Interpolate normalisedTime x y\n        }\n\n    static member Map f anim =\n        Anims.Def anim.Duration (anim.Compute >> f)\n\n    static member Pack anim =\n        Anim (AppendList.Single (Work anim))\n\n    static member Play anim =\n        async {\n            do! Anims.Actions anim\n                |> Anim.Run ignore\n            return Anims.Finalize anim\n        }\n\n    static member Run k anim =\n        let dur = anim.Duration\n        if dur = 0. then async.Zero() else\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec loop start now =\n                let t = now - start\n                k (anim.Compute t)\n                if t <= dur then\n                    JS.RequestAnimationFrame (fun t -> loop start t) |> ignore\n                else ok ()\n            JS.RequestAnimationFrame (fun t -> loop t t) |> ignore\n\n    static member WhenDone f main =\n        main\n        |> Anim.Append (Anim (AppendList.Single (Finally f)))\n\n    static member Empty =\n        Anim AppendList.Empty\n\n// Transitions ----------------------------------------------------------------\n\ntype TFlags =\n    | TTrivial = 0\n    | TChange = 1\n    | TEnter = 2\n    | TExit = 4\n\n[<JavaScript>]\ntype Trans<'T>\n    (\n        change: Func<'T, 'T, Anim<'T>>,\n        enter: Func<'T, Anim<'T>>,\n        exit: Func<'T, Anim<'T>>,\n        flags: TFlags\n    ) =\n\n    new () =\n        Trans(\n            (fun x y -> Anim.Const y),\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TTrivial\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>) =\n        Trans(\n            ch,\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TChange\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>, enter, exit) =\n        Trans(\n            ch,\n            (if enter = null then Func<_,_>(fun t -> Anim.Const t) else enter),\n            (if exit = null then Func<_,_>(fun t -> Anim.Const t) else exit),\n            TFlags.TChange ||| \n                (if enter = null then TFlags.TTrivial else TFlags.TEnter) |||\n                (if exit = null then TFlags.TTrivial else TFlags.TExit)\n        )\n\n    member this.TChange x y = change.Invoke(x, y)\n    member this.TEnter = enter.Invoke\n    member this.TExit = exit.Invoke\n    member this.TFlags = flags\n\n    member this.Copy(?change, ?enter, ?exit, ?flags) =\n        let ch = defaultArg change this.TChange\n        let en = defaultArg enter this.TEnter\n        let ex = defaultArg exit this.TExit\n        let fl = defaultArg flags this.TFlags\n        Trans(Func<_,_,_>(ch), Func<_,_>(en),\n            Func<_,_>(ex), fl)\n\n[<JavaScript>]\n[<Sealed>]\ntype Trans =\n\n  // Using a Trans ---------------\n\n    static member AnimateChange (tr: Trans<'T>) x y = tr.TChange x y\n    static member AnimateEnter (tr: Trans<'T>) x = tr.TEnter x\n    static member AnimateExit (tr: Trans<'T>) x = tr.TExit x\n    static member CanAnimateChange (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TChange)\n    static member CanAnimateEnter (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TEnter)\n    static member CanAnimateExit (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TExit)\n\n  // Creating a Trans ------------\n\n    static member Trivial () =\n        Trans()\n\n    static member Create (ch: 'T -> 'T -> Anim<'T>) =\n        Trans(Func<_,_,_>(ch))\n\n    static member Change ch (tr: Trans<'T>) =\n        tr.Copy(change = ch, flags = (tr.TFlags ||| TFlags.TChange))\n\n    static member Enter f (tr: Trans<'T>) =\n        tr.Copy(enter = f, flags = (tr.TFlags ||| TFlags.TEnter))\n\n    static member Exit f (tr: Trans<'T>) =\n        tr.Copy(exit = f, flags = (tr.TFlags ||| TFlags.TExit))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Linq.Expressions\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Core.Resources\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\nmodule J = WebSharper.Core.Json\nmodule P = FSharp.Quotations.Patterns\n\nmodule private Internal =\n\n    open WebSharper.Core\n    open WebSharper.Web.ClientSideInternals\n\n    let activateNode =\n        M.MethodNode(\n            AST.TypeDefinition {\n                Assembly = \"WebSharper.Main\"\n                FullName = \"WebSharper.Activator\"\n            },\n            AST.Method {\n                MethodName = \"Activate\"\n                Parameters = []\n                ReturnType = AST.VoidType\n                Generics = 0\n            } \n        )\n\n    let compile (meta: M.Info) (json: J.Provider) (q: Expr) (doCall: string -> string) =\n        let reqs = ResizeArray<M.Node>()\n        let rec compile' (q: Expr) =\n            match getLocation q with\n            | Some p ->\n                match meta.Quotations.TryGetValue(p) with\n                | false, _ ->\n                    None\n                | true, (declType, meth, argNames) ->\n                    match meta.Classes.TryGetValue declType with\n                    | false, _ -> failwithf \"Error in Handler: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                    | true, c ->\n                        let argIndices = Map (argNames |> List.mapi (fun i x -> x, i))\n                        let args = Array.create argNames.Length null\n                        reqs.Add(M.MethodNode (declType, meth))\n                        reqs.Add(M.TypeNode declType)\n                        let setArg (name: string) (value: obj) =\n                            let i = argIndices.[name]\n                            if isNull args.[i] then\n                                args.[i] <-\n                                    match value with\n                                    | :? Expr as q ->\n                                        compile' q |> Option.get\n                                    | value ->\n                                        let typ = value.GetType()\n                                        reqs.Add(M.TypeNode (WebSharper.Core.AST.Reflection.ReadTypeDefinition typ))\n                                        let packed = json.GetEncoder(typ).Encode(value) |> json.Pack\n                                        let s =\n                                            WebSharper.Core.Json.Stringify(packed)\n                                                .Replace(\"&\", \"&amp;\")\n                                                .Replace(\"\\\"\", \"&quot;\")\n                                        match packed with\n                                        | WebSharper.Core.Json.Object (((\"$TYPES\" | \"$DATA\"), _) :: _) ->\n                                            \"WebSharper.Json.Activate(\" + s + \")\"\n                                        | _ -> s\n                        findArgs Set.empty setArg q\n                        let addr =\n                            match c.Methods.TryGetValue meth with\n                            | true, (M.CompiledMember.Static x, _, _) -> x.Value\n                            | _ -> failwithf \"Error in Handler: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                        let funcall = String.concat \".\" (List.rev addr)\n                        let args = String.concat \",\" args\n                        Some (sprintf \"%s(%s)\" funcall args)\n            | None -> None\n        compile' q\n        |> Option.map (fun s ->\n            reqs.Add(activateNode)\n            doCall s, reqs :> seq<_>\n        )\n\ntype private OnAfterRenderControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body =\n        let l = JS.Document.QuerySelectorAll(\"[ws-runafterrender]\")\n        for i = 0 to l.Length - 1 do\n            let x = l.[i] :?> Dom.Element\n            let f = JS.Eval(x.GetAttribute(\"ws-runafterrender\")) :?> (Dom.Element -> unit)\n            x.RemoveAttribute(\"ws-runafterrender\")\n            f x\n        { new IControlBody with member this.ReplaceInDom(_) = () }\n\n// We would have wanted to use UseNullAsTrueValue so that EmptyAttr = null,\n// which makes things much easier when it comes to optional arguments in Templating.\n// The problem is that for some reason UNATV is ignored if there are 4 or more cases.\n// So we end up having to do explicit null checks everywhere :(\ntype Attr =\n    | AppendAttr of list<Attr>\n    | SingleAttr of string * string\n    | DepAttr of string * (M.Info -> string) * (M.Info -> seq<M.Node>) * (M.Info -> J.Provider -> list<string * J.Encoded>)\n\n    member this.Write(meta, w: HtmlTextWriter, removeWsHole) =\n        match this with\n        | AppendAttr attrs ->\n            attrs |> List.iter (fun a ->\n                if not (obj.ReferenceEquals(a, null))\n                then a.Write(meta, w, removeWsHole))\n        | SingleAttr (n, v) ->\n            if not (removeWsHole && n = \"ws-hole\") then\n                w.WriteAttribute(n, v)\n        | DepAttr (n, v, _, _) ->\n            w.WriteAttribute(n, v meta)\n\n    interface IRequiresResources with\n\n        member this.Requires(meta) =\n            match this with\n            | AppendAttr attrs ->\n                attrs |> Seq.collect (fun a ->\n                    if obj.ReferenceEquals(a, null)\n                    then Seq.empty\n                    else (a :> IRequiresResources).Requires(meta))\n            | DepAttr (_, _, reqs, _) -> reqs meta\n            | SingleAttr _ -> Seq.empty\n\n        member this.Encode (meta, json) =\n            match this with\n            | AppendAttr attrs ->\n                attrs |> List.collect (fun a ->\n                    if obj.ReferenceEquals(a, null)\n                    then []\n                    else (a :> IRequiresResources).Encode(meta, json))\n            | DepAttr (_, _, _, enc) -> enc meta json\n            | SingleAttr _ -> []\n\n    member this.WithName(n) =\n        match this with\n        | AppendAttr _ -> this\n        | SingleAttr(_, v) -> SingleAttr(n, v)\n        | DepAttr(_, v, d, e) -> DepAttr(n, v, d, e)\n\n    static member Create name value =\n        SingleAttr (name, value)\n\n    static member Append a b =\n        AppendAttr [a; b]\n\n    static member Empty =\n        AppendAttr []\n\n    static member Concat (xs: seq<Attr>) =\n        AppendAttr (List.ofSeq xs)\n\n    static member WithDependencies(name, getValue, deps) =\n        DepAttr (name, getValue, deps, fun _ _ -> [])\n\n    static member OnAfterRenderImpl(q: Expr<Dom.Element -> unit>) =\n        let json = WebSharper.Web.Shared.Json // TODO: fix?\n        let value = ref None\n        let init meta =\n            if Option.isNone !value then\n                value :=\n                    match Internal.compile meta json q id with\n                    | Some _ as v -> v\n                    | _ ->\n                        let m =\n                            match q with\n                            | Lambda (x1, Call(None, m, [Var x2])) when x1 = x2 -> m\n                            | _ -> failwithf \"Invalid handler function: %A\" q\n                        let loc = WebSharper.Web.ClientSideInternals.getLocation' q\n                        let func, reqs = Attr.HandlerFallback(m, loc, id)\n                        Some (func meta, reqs)\n        let getValue (meta: M.Info) =\n            init meta\n            fst (Option.get !value)\n        let getReqs (meta: M.Info) =\n            init meta\n            snd (Option.get !value)\n        let enc (meta: M.Info) (json: J.Provider) =\n            init meta\n            (new OnAfterRenderControl() :> IRequiresResources).Encode(meta, json)\n        DepAttr(\"ws-runafterrender\", getValue, getReqs, enc)\n\n    static member HandlerImpl(event: string, q: Expr<Dom.Element -> #Dom.Event -> unit>) =\n        let json = WebSharper.Web.Shared.Json // TODO: fix?\n        let value = ref None\n        let init meta =\n            if Option.isNone !value then\n                value :=\n                    match Internal.compile meta json q (fun s -> s + \"(this)(event)\") with\n                    | Some _ as v -> v\n                    | _ ->\n                        let m =\n                            match q with\n                            | Lambda (x1, Lambda (y1, Call(None, m, [Var x2; (Var y2 | Coerce(Var y2, _))]))) when x1 = x2 && y1 = y2 -> m\n                            | _ -> failwithf \"Invalid handler function: %A\" q\n                        let loc = WebSharper.Web.ClientSideInternals.getLocation' q\n                        let func, reqs = Attr.HandlerFallback(m, loc, fun s -> s + \"(this, event)\")\n                        Some (func meta, reqs)\n        let getValue (meta: M.Info) =\n            init meta\n            fst (Option.get !value)\n        let getReqs (meta: M.Info) =\n            init meta\n            snd (Option.get !value)\n        Attr.WithDependencies(\"on\" + event, getValue, getReqs)\n\n    static member Handler (event: string) ([<JavaScript>] q: Expr<Dom.Element -> #Dom.Event -> unit>) =\n        Attr.HandlerImpl(event, q)\n\n    static member HandlerFallback(m, location, doCall) =\n        let meth = R.ReadMethod m\n        let declType = R.ReadTypeDefinition m.DeclaringType\n        let reqs = [M.MethodNode (declType, meth); M.TypeNode declType]\n        let value = ref None\n        let fail() =\n            failwithf \"Error in Handler%s: Couldn't find JavaScript address for method %s.%s\"\n                location declType.Value.FullName meth.Value.MethodName\n        let func (meta: M.Info) =\n            match !value with\n            | None ->\n                match meta.Classes.TryGetValue declType with\n                | true, c ->\n                    let addr =\n                        match c.Methods.TryGetValue meth with\n                        | true, (M.CompiledMember.Static x, _, _) -> x.Value\n                        | _ -> fail()\n                    let s = String.concat \".\" (List.rev addr) |> doCall\n                    value := Some s\n                    s\n                | _ -> fail()\n            | Some v -> v\n        func, reqs :> seq<_>\n\n    static member HandlerLinqImpl(event, m, location) =\n        let func, reqs = Attr.HandlerFallback(m, location, fun s -> s + \"(this, event)\")\n        DepAttr (\"on\" + event, func, (fun _ -> reqs), (fun _ _ -> []))\n\n    static member HandlerLinq (event: string) (q: Expression<Action<Dom.Element, #Dom.Event>>) =\n        let meth =\n            match q.Body with\n            | :? MethodCallExpression as e -> e.Method\n            | _ -> failwithf \"Invalid handler function: %A\" q\n        Attr.HandlerLinqImpl(event, meth, \"\")\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Client\n\nopen System.Collections.Generic\nopen Microsoft.FSharp.Quotations\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nmodule DU = DomUtility\n\ntype IAttrNode =\n    [<Name \"NChanged\">]\n    abstract Changed : View<unit>\n    [<Name \"NGetChangeAnim\">]\n    abstract GetChangeAnim : Dom.Element -> Anim\n    [<Name \"NGetEnterAnim\">]\n    abstract GetEnterAnim : Dom.Element -> Anim\n    [<Name \"NGetExitAnim\">]\n    abstract GetExitAnim : Dom.Element -> Anim\n    [<Name \"NSync\">]\n    abstract Sync : Dom.Element -> unit\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.AnimatedAttrNode\">]\ntype AnimatedAttrNode<'T>(tr: Trans<'T>, view: View<'T>, push: Dom.Element -> 'T -> unit) =\n    let mutable logical : option<'T> = None // current logical value\n    let mutable visible : option<'T> = None // current value pushed to the parent element\n    let mutable dirty = true // logical <> visible\n\n    let updates =\n        view\n        |> View.Map (fun x ->\n            logical <- Some x\n            dirty <- true)\n\n    let pushVisible el v =\n        visible <- Some v\n        dirty <- true\n        push el v\n\n    let sync p =\n        if dirty then\n            Option.iter (fun v -> push p v) logical\n            visible <- logical\n            dirty <- false\n\n    interface IAttrNode with\n\n        member a.GetChangeAnim parent =\n            match visible, logical with\n            | Some v, Some l when dirty ->\n                Trans.AnimateChange tr v l\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetEnterAnim parent =\n            match visible, logical with\n            | Some vi, Some lo when dirty ->\n                Trans.AnimateChange tr vi lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | None, Some lo ->\n                Trans.AnimateEnter tr lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetExitAnim parent =\n            match visible with\n            | Some cur ->\n                Trans.AnimateExit tr cur\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> dirty <- true; visible <- None)\n\n        /// NOTE: enter or change animation will do the sync.\n        member a.Sync parent = ()\n\n        member a.Changed = updates\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.DynamicAttrNode\">]\ntype DynamicAttrNode<'T>(view: View<'T>, push: Dom.Element -> 'T -> unit) =\n    let mutable value = JS.Undefined\n    let mutable dirty = false\n    let updates = view |> View.Map (fun x -> value <- x; dirty <- true)\n    interface IAttrNode with\n        member a.GetChangeAnim parent = Anim.Empty\n        member a.GetEnterAnim parent = Anim.Empty\n        member a.GetExitAnim parent = Anim.Empty\n        member a.Sync parent = if dirty then push parent value; dirty <- false\n        member a.Changed = updates\n\ntype AttrFlags =\n    | Defaults = 0\n    | HasEnterAnim = 1\n    | HasExitAnim = 2\n    | HasChangeAnim = 4\n\n[<JavaScript; Proxy(typeof<Attr>); Name \"WebSharper.UI.AttrProxy\"; Prototype>]\ntype internal AttrProxy =\n    | [<Constant(null)>] A0\n    | A1 of IAttrNode\n    | A2 of AttrProxy * AttrProxy\n    | A3 of init: (Dom.Element -> unit)\n    | A4 of onAfterRender: (Dom.Element -> unit)\n\n[<JavaScript; Name \"WebSharper.UI.Attrs\">]\nmodule Attrs =\n\n    type Dyn =\n        {\n            DynElem : Dom.Element\n            DynFlags : AttrFlags\n            DynNodes : IAttrNode []\n            [<OptionalField>]\n            OnAfterRender : option<Dom.Element -> unit>\n        }\n\n    let HasChangeAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasChangeAnim\n\n    let HasEnterAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasEnterAnim\n\n    let HasExitAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasExitAnim\n\n    let Flags a =\n        if a !==. null && JS.HasOwnProperty a \"flags\"\n        then a?flags\n        else AttrFlags.Defaults\n\n    let SetFlags (a: AttrProxy) (f: AttrFlags) =\n        a?flags <- f\n\n    /// Synchronizes dynamic attributes.\n    let Sync elem dyn =\n        dyn.DynNodes\n        |> Array.iter (fun d ->\n            d.Sync elem)\n\n    /// Inserts static attributes and computes dynamic attributes.\n    let Insert elem (tree: Attr) =\n        let nodes = Queue()\n        let oar = Queue()\n        let rec loop node =\n          if not (obj.ReferenceEquals(node, null)) then // work around WS issue with UseNullAsTrueValue\n            match node with\n            | A0 -> ()\n            | A1 n -> nodes.Enqueue n\n            | A2 (a, b) -> loop a; loop b\n            | A3 mk -> mk elem\n            | A4 cb -> oar.Enqueue cb\n        loop (As<AttrProxy> tree)\n        let arr = nodes.ToArray()\n        {\n            DynElem = elem\n            DynFlags = Flags tree\n            DynNodes = arr\n            OnAfterRender =\n                if oar.Count = 0 then None else\n                Some (fun el -> Seq.iter (fun f -> f el) oar)\n        }\n\n    let Empty e =\n        {\n            DynElem = e\n            DynFlags = AttrFlags.Defaults\n            DynNodes = [||]\n            OnAfterRender = None\n        }\n\n    let Updates dyn =\n        dyn.DynNodes\n        |> Array.MapTreeReduce (fun x -> x.Changed) (View.Const ()) View.Map2Unit\n\n    let GetAnim dyn f =\n        dyn.DynNodes\n        |> Array.map (fun n -> f n dyn.DynElem)\n        |> Anim.Concat\n\n    let GetEnterAnim dyn =\n        GetAnim dyn (fun n -> n.GetEnterAnim)\n\n    let GetExitAnim dyn =\n        GetAnim dyn (fun n -> n.GetExitAnim)\n\n    let GetChangeAnim dyn =\n        GetAnim dyn (fun n -> n.GetChangeAnim)\n\n    [<Inline>]\n    let GetOnAfterRender dyn =\n        dyn.OnAfterRender\n\n    let AppendTree a b =\n        // work around WS issue with UseNullAsTrueValue\n        if obj.ReferenceEquals(a, null) then b\n        elif obj.ReferenceEquals(b, null) then a\n        else\n        let x = A2 (a, b)\n        SetFlags x (Flags a ||| Flags b)\n        x\n//        match a, b with\n//        | A0, x | x, A0 -> x\n//        | _ -> A2 (a, b)\n\n    let internal EmptyAttr = A0\n\n    let internal Animated tr view set =\n        let node = AnimatedAttrNode (tr, view, set)\n        let mutable flags = AttrFlags.HasChangeAnim\n        if Trans.CanAnimateEnter tr then\n            flags <- flags ||| AttrFlags.HasEnterAnim\n        if Trans.CanAnimateExit tr then\n            flags <- flags ||| AttrFlags.HasExitAnim\n        let n = A1 node\n        SetFlags n flags\n        n\n\n    let internal Dynamic view set =\n        A1 (DynamicAttrNode (view, set))\n\n    let internal Static attr =\n        A3 attr\n\n\n[<JavaScript>]\ntype AttrProxy with\n\n    static member Create name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetAttr el name value))\n\n    static member Append (a: Attr) (b: Attr) =\n        As<Attr> (Attrs.AppendTree (As a) (As b))\n\n    [<Inline>]\n    static member Empty =\n        As<Attr> Attrs.EmptyAttr\n\n    static member Concat (xs: seq<Attr>) =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Attr.Empty Attr.Append\n\n    static member OnAfterRenderImpl(q: Expr<Dom.Element -> unit>) =\n        As<Attr> (A4 (As q))\n\n    static member HandlerImpl(event: string, q: Expr<Dom.Element -> #Dom.Event-> unit>) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(event, (As<Dom.Element -> Dom.Event -> unit> q) el, false)))\n\n    static member Handler (event: string) (q: Expr<Dom.Element -> #Dom.Event-> unit>) =\n        AttrProxy.HandlerImpl(event, q)\n\n[<JavaScript; Name \"WebSharper.UI.CheckedInput\">]\ntype CheckedInput<'T> =\n    | Valid of value: 'T * inputText: string\n    | Invalid of inputText: string\n    | Blank of inputText: string\n\n    static member Make(x: 'T) =\n        Valid (x, x.ToString())\n\n    member this.Input =\n        match this with\n        | Valid (_, x)\n        | Invalid x\n        | Blank x -> x\n\n[<JavaScript; Name \"WebSharper.UI.AttrModule\">]\nmodule Attr =\n\n    [<JavaScript; Macro(typeof<Macros.AttrStyle>)>]\n    let Style name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetStyle el name value))\n\n    let Animated name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetAttr el name (attr v)))\n\n    let AnimatedStyle name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetStyle el name (attr v)))\n\n    let Dynamic name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetAttr el name v))\n\n    let DynamicCustom set view =\n        As<Attr> (Attrs.Dynamic view set)\n\n    let DynamicStyle name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetStyle el name v))\n\n    let Handler name (callback: Dom.Element -> #Dom.Event -> unit) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(name, As<Dom.Event -> unit> (callback el), false)))\n\n    let HandlerView name (view: View<'T>) (callback: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let init (el: Dom.Element) =\n            let callback = callback el\n            el.AddEventListener(name, (fun (ev: Dom.Event) -> View.Get (callback (As ev)) view), false)\n        As<Attr> (Attrs.Static init)\n\n    let OnAfterRender (callback: Dom.Element -> unit) =\n        As<Attr> (A4 callback)\n\n    let OnAfterRenderView (v: View<'T>) (callback: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        Attr.Append\n            (OnAfterRender (fun el -> callback el el?(id)))\n            (DynamicCustom (fun el x -> el?(id) <- x) v)\n\n    let DynamicClassPred name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            if v then DU.AddClass el name else DU.RemoveClass el name))\n\n    [<JavaScript; Macro(typeof<Macros.AttrClass>)>]\n    let ClassPred name isSet =\n        As<Attr> (Attrs.Static (fun el ->\n            if isSet then DU.AddClass el name else DU.RemoveClass el name))\n\n    let Class name = ClassPred name true\n\n    let DynamicClass name view ok =\n        DynamicClassPred name (View.Map ok view)\n\n    let DynamicPred name predView valView =\n        let viewFn el (p, v) =\n            if p then\n                DU.SetAttr el name v\n            else\n                DU.RemoveAttr el name\n        let tupleView = View.Map2 (fun pred value -> (pred, value)) predView valView\n        As<Attr> (Attrs.Dynamic tupleView viewFn)\n\n    let DynamicProp name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            el?(name) <- v))\n\n    let CustomVar (var: Var<'a>) (set: Dom.Element -> 'a -> unit) (get: Dom.Element -> 'a option) =\n        let onChange (el: Dom.Element) (e: Dom.Event) =\n            var.UpdateMaybe(fun v ->\n                match get el with\n                | Some x as o when x <> v -> o\n                | _ -> None)\n        let set e v =\n            match get e with\n            | Some x when x = v -> ()\n            | _ -> set e v\n        Attr.Concat [\n            Handler \"change\" onChange\n            Handler \"input\" onChange\n            Handler \"keypress\" onChange\n            DynamicCustom set var.View\n        ]\n\n    let CustomValue (var: Var<'a>) (toString : 'a -> string) (fromString : string -> 'a option) =\n        CustomVar var (fun e v -> e?value <- toString v) (fun e -> fromString e?value)\n\n    let ContentEditableText (var: Var<string>) =\n        CustomVar var (fun e v -> e.TextContent <- v) (fun e -> Some e.TextContent)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let ContentEditableHtml (var: Var<string>) =\n        CustomVar var (fun e v -> e?innerHTML <- v) (fun e -> Some e?innerHTML)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let Value (var: Var<string>) =\n        CustomValue var id (id >> Some)\n\n    [<JavaScript; Inline \"$e.checkValidity?$e.checkValidity():true\">]\n    let CheckValidity (e: Dom.Element) = X<bool>\n\n    let IntValueUnchecked (var: Var<int>) =\n        let parseInt (s: string) =\n            if String.isBlank s then Some 0 else\n            let pd : int = JS.Plus s\n            if pd !==. (pd >>. 0) then None else Some pd\n        CustomValue var string parseInt\n\n    let IntValue (var: Var<CheckedInput<int>>) =\n        let parseCheckedInt (el: Dom.Element) : option<CheckedInput<int>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                match System.Int32.TryParse(s) with\n                | true, i -> Valid (i, s)\n                | false, _ -> Invalid s\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedInt\n\n    let FloatValueUnchecked (var: Var<float>) =\n        let parseFloat (s: string) =\n            if String.isBlank s then Some 0. else\n            let pd : float = JS.Plus s\n            if JS.IsNaN pd then None else Some pd\n        CustomValue var string parseFloat\n\n    let FloatValue (var: Var<CheckedInput<float>>) =\n        let parseCheckedFloat (el: Dom.Element) : option<CheckedInput<float>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                let i = JS.Plus s\n                if JS.IsNaN i then Invalid s else Valid (i, s)\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedFloat\n\n    let Checked (var: Var<bool>) =\n        let onSet (el: Dom.Element) (ev: Dom.Event) =\n            if var.Value <> el?``checked`` then\n                var.Value <- el?``checked``\n        Attr.Concat [\n            DynamicProp \"checked\" var.View\n            Handler \"change\" onSet\n        ]\n\n    let ValidateForm () =\n        OnAfterRender Resources.H5F.Setup\n\n[<assembly:System.Reflection.AssemblyVersionAttribute(\"4.0.0.0\")>]\ndo()\n", "namespace WebSharper.UI.Client\n\n#nowarn \"44\" // HTML deprecated\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\n\nmodule DU = DomUtility\ntype private A = Attr\n\n[<JavaScript>]\nmodule Settings =\n    let mutable BatchUpdatesEnabled = true\n\n[<JavaScript>]\ntype internal DocNode =\n    | AppendDoc of DocNode * DocNode\n    | ElemDoc of DocElemNode\n    | EmbedDoc of DocEmbedNode\n    | [<Constant(null)>] EmptyDoc\n    | TextDoc of DocTextNode\n    | TextNodeDoc of Dom.Text\n    | TreeDoc of DocTreeNode\n\nand [<CustomEquality>]\n    [<JavaScript>]\n    [<NoComparison>]\n    [<Name \"WebSharper.UI.DocElemNode\">]\n    internal DocElemNode =\n    {\n        Attr : Attrs.Dyn\n        mutable Children : DocNode\n        [<OptionalField>]\n        Delimiters : (Dom.Node * Dom.Node) option\n        El : Dom.Element\n        ElKey : int\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\n    override this.Equals(o: obj) =\n        this.ElKey = (o :?> DocElemNode).ElKey\n\n    override this.GetHashCode() =\n        this.ElKey\n\nand internal DocEmbedNode =\n    {\n        mutable Current : DocNode\n        mutable Dirty : bool\n    }\n\nand internal DocTextNode =\n    {\n        Text : Dom.Text\n        mutable Dirty : bool\n        mutable Value : string\n    }\n\nand internal DocTreeNode =\n    {\n        mutable Els : Union<Dom.Node, DocNode>[]\n        mutable Dirty : bool\n        mutable Holes : DocElemNode[]\n        Attrs : (Dom.Element * Attrs.Dyn)[]\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n        [<OptionalField>]\n        El : option<Dom.Element>\n    }\n\ntype EltUpdater =\n    inherit Elt\n\n    member this.AddUpdated(doc: Elt) = ()\n    member this.RemoveUpdated(doc: Elt) = ()\n    member this.RemoveAllUpdated() = ()\n\n[<JavaScript; Name \"WebSharper.UI.Docs\">]\nmodule internal Docs =\n\n    /// Sets of DOM nodes.\n    type DomNodes =\n        | DomNodes of Dom.Node[]\n\n        /// Actual chidlren of an element.\n        static member Children (elem: Dom.Element) (delims: option<Dom.Node * Dom.Node>) =\n            match delims with\n            | None ->\n                DomNodes (Array.init elem.ChildNodes.Length elem.ChildNodes.Item)\n            | Some (ldelim, rdelim) ->\n                let a = Array<_>()\n                let mutable n = ldelim.NextSibling\n                while n !==. rdelim do\n                    a.Push(n) |> ignore\n                    n <- n.NextSibling\n                DomNodes (As a)\n\n        /// Shallow children of an element node.\n        static member DocChildren node =\n            let q = Queue()\n            let rec loop doc =\n                match doc with\n                | AppendDoc (a, b) -> loop a; loop b\n                | EmbedDoc d -> loop d.Current\n                | ElemDoc e -> q.Enqueue (e.El :> Dom.Node)\n                | EmptyDoc -> ()\n                | TextNodeDoc tn -> q.Enqueue (tn :> Dom.Node)\n                | TextDoc t -> q.Enqueue (t.Text :> Dom.Node)\n                | TreeDoc t ->\n                    t.Els |> Array.iter (function\n                        | Union1Of2 e -> q.Enqueue e\n                        | Union2Of2 n -> loop n\n                    )\n            loop node.Children\n            DomNodes (Array.ofSeqNonCopying q)\n\n        /// Set difference - currently only using equality O(N^2).\n        /// Can do better? Can store <hash> data on every node?\n        static member Except (DomNodes excluded) (DomNodes included) =\n            included\n            |> Array.filter (fun n ->\n                excluded\n                |> Array.forall (fun k -> not (n ===. k)))\n            |> DomNodes\n\n        /// Iteration.\n        static member Iter f (DomNodes ns) =\n            Array.iter f ns\n\n        /// Iteration.\n        static member FoldBack f (DomNodes ns) z =\n            Array.foldBack f ns z\n\n    /// Inserts a node at position.\n    let InsertNode parent node pos =\n        DU.InsertAt parent pos node\n        DU.BeforeNode node\n\n    /// Inserts a doc at position.\n    let rec InsertDoc parent doc pos =\n        match doc with\n        | AppendDoc (a, b) -> InsertDoc parent a (InsertDoc parent b pos)\n        | ElemDoc e -> InsertNode parent e.El pos\n        | EmbedDoc d -> d.Dirty <- false; InsertDoc parent d.Current pos\n        | EmptyDoc -> pos\n        | TextDoc t -> InsertNode parent t.Text pos\n        | TextNodeDoc t -> InsertNode parent t pos\n        | TreeDoc t ->\n            Array.foldBack (fun el pos ->\n                match el with\n                | Union1Of2 e -> InsertNode parent e pos\n                | Union2Of2 n -> InsertDoc parent n pos\n            ) t.Els pos\n\n    /// Synchronizes an element with its children (shallow).\n    let DoSyncElement (el : DocElemNode) =\n        let parent = el.El\n        let rec ins doc pos =\n            match doc with\n            | AppendDoc (a, b) -> ins a (ins b pos)\n            | ElemDoc e -> DU.BeforeNode e.El\n            | EmbedDoc d ->\n                if d.Dirty then\n                    d.Dirty <- false\n                    InsertDoc parent d.Current pos\n                else\n                    ins d.Current pos\n            | EmptyDoc -> pos\n            | TextDoc t -> DU.BeforeNode t.Text\n            | TextNodeDoc t -> DU.BeforeNode t\n            | TreeDoc t ->\n                if t.Dirty then t.Dirty <- false\n                Array.foldBack (fun el pos ->\n                    match el with\n                    | Union1Of2 e -> DU.BeforeNode e\n                    | Union2Of2 n -> ins n pos\n                ) t.Els pos\n        let ch = DomNodes.DocChildren el\n        // remove children that are not in the current set\n        DomNodes.Children el.El el.Delimiters\n        |> DomNodes.Except ch\n        |> DomNodes.Iter (DU.RemoveNode el.El)\n        // insert current children\n        let pos =\n            match el.Delimiters with\n            | None -> DU.AtEnd\n            | Some (_, rdelim) -> DU.BeforeNode rdelim\n        ins el.Children pos |> ignore\n\n    /// Optimized version of DoSyncElement.\n    let SyncElement (el: DocElemNode) =\n        /// Test if any children have changed.\n        let rec hasDirtyChildren el =\n            let rec dirty doc =\n                match doc with\n                | AppendDoc (a, b) -> dirty a || dirty b\n                | EmbedDoc d -> d.Dirty || dirty d.Current\n                | TreeDoc t -> t.Dirty || Array.exists hasDirtyChildren t.Holes\n                | _ -> false\n            dirty el.Children\n        Attrs.Sync el.El el.Attr\n        if hasDirtyChildren el then\n            DoSyncElement el\n\n    /// Links an element to children by inserting them.\n    let LinkElement el children =\n        InsertDoc el children DU.AtEnd |> ignore\n\n    /// Links an element to previous siblings by inserting them.\n    let LinkPrevElement (el: Dom.Node) children =\n        InsertDoc (el.ParentNode :?> _) children (DU.BeforeNode el) |> ignore\n\n    let InsertBeforeDelim (afterDelim: Dom.Node) (doc: DocNode) =\n        let p = afterDelim.ParentNode\n        let before = JS.Document.CreateTextNode(\"\") :> Dom.Node\n        p.InsertBefore(before, afterDelim) |> ignore\n        LinkPrevElement afterDelim doc\n        before\n\n    /// Invokes and clears an element's afterRender callback(s).\n    let AfterRender (el: DocElemNode) =\n        match el.Render with\n        | None -> ()\n        | Some f -> f el.El; el.Render <- None\n\n    /// Synchronizes the document (deep).\n    let rec Sync doc =\n        match doc with\n        | AppendDoc (a, b) -> Sync a; Sync b\n        | ElemDoc el -> SyncElemNode false el\n        | EmbedDoc n -> Sync n.Current\n        | EmptyDoc\n        | TextNodeDoc _ -> ()\n        | TextDoc d ->\n            if d.Dirty then\n                d.Text.NodeValue <- d.Value\n                d.Dirty <- false\n        | TreeDoc t ->\n            Array.iter (SyncElemNode false) t.Holes\n            Array.iter (fun (e, a) -> Attrs.Sync e a) t.Attrs\n            AfterRender (As t)\n\n    /// Synchronizes an element node (deep).\n    and SyncElemNode childrenOnly el =\n        if not childrenOnly then\n            SyncElement el\n        Sync el.Children\n        AfterRender el\n\n    /// A set of node element nodes.\n    type NodeSet =\n        | NodeSet of HashSet<DocElemNode>\n\n        /// Filters out only nodes that have on-remove animations.\n        static member Filter f (NodeSet set) =\n            NodeSet (HashSet.Filter f set)\n\n        /// Finds all node elements in a tree.\n        static member FindAll doc =\n            let q = Queue()\n            let rec loop node =\n                match node with\n                | AppendDoc (a, b) -> loop a; loop b\n                | ElemDoc el -> loopEN el\n                | EmbedDoc em -> loop em.Current\n                | TreeDoc t -> t.Holes |> Array.iter loopEN\n                | _ -> ()\n            and loopEN el =\n                q.Enqueue el\n                loop el.Children\n            loop doc\n            NodeSet (HashSet q)\n\n        /// Set difference.\n        static member Except (NodeSet excluded) (NodeSet included) =\n            NodeSet (included |> HashSet.Except excluded)\n\n        /// Set intersection.\n        static member Intersect (NodeSet a) (NodeSet b) =\n            NodeSet (HashSet.Intersect a b)\n\n        /// Checks if empty.\n        static member IsEmpty (NodeSet ns) =\n            ns.Count = 0\n\n        /// The empty set.\n        static member Empty =\n            NodeSet (HashSet ())\n\n        /// Converts to array.\n        static member ToArray (NodeSet ns) =\n            HashSet.ToArray ns\n\n    /// State of the Doc.Run (updator) proces.\n    type RunState =\n        {\n            mutable PreviousNodes : NodeSet\n            Top : DocElemNode\n        }\n\n    /// Creates an element node.\n    let CreateElemNode el attr children =\n        LinkElement el children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = None\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates an element node that handles a delimited subset of its children.\n    let CreateDelimitedElemNode (ldelim: Dom.Node) (rdelim: Dom.Node) attr children =\n        let el = ldelim.ParentNode :?> Dom.Element\n        LinkPrevElement rdelim children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = Some (ldelim, rdelim)\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates a new RunState.\n    let CreateRunState parent doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateElemNode parent Attr.Empty doc\n        }\n\n    /// Creates a new RunState for a delimited subset of the children of a node.\n    let CreateDelimitedRunState ldelim rdelim doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateDelimitedElemNode ldelim rdelim Attr.Empty doc\n        }\n\n    /// Computes the animation of nodes that animate removal.\n    let ComputeExitAnim st cur =\n        st.PreviousNodes\n        |> NodeSet.Filter (fun n -> Attrs.HasExitAnim n.Attr)\n        |> NodeSet.Except cur\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetExitAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for changed nodes.\n    let ComputeChangeAnim st cur =\n        let relevant = NodeSet.Filter (fun n -> Attrs.HasChangeAnim n.Attr)\n        NodeSet.Intersect (relevant st.PreviousNodes) (relevant cur)\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetChangeAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for entering nodes.\n    let ComputeEnterAnim st cur =\n        cur\n        |> NodeSet.Filter (fun n -> Attrs.HasEnterAnim n.Attr)\n        |> NodeSet.Except st.PreviousNodes\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetEnterAnim n.Attr)\n        |> Anim.Concat\n\n    let SyncElemNodesNextFrame childrenOnly st =\n        if Settings.BatchUpdatesEnabled then\n            Async.FromContinuations <| fun (ok, _, _) ->\n                JS.RequestAnimationFrame (fun _ ->\n                    SyncElemNode childrenOnly st.Top\n                    ok()\n                ) |> ignore\n        else\n            async.Return(SyncElemNode childrenOnly st.Top)\n\n    /// The main function: how to perform an animated top-level document update.\n    let PerformAnimatedUpdate childrenOnly st doc =\n        if Anim.UseAnimations then\n            async {\n                let cur = NodeSet.FindAll doc\n                let change = ComputeChangeAnim st cur\n                let enter = ComputeEnterAnim st cur\n                let exit = ComputeExitAnim st cur\n                do! Anim.Play (Anim.Append change exit)\n                do! SyncElemNodesNextFrame childrenOnly st\n                do! Anim.Play enter\n                return st.PreviousNodes <- cur\n            }\n        else\n            SyncElemNodesNextFrame childrenOnly st\n\n    let PerformSyncUpdate childrenOnly st doc =\n        let cur = NodeSet.FindAll doc\n        SyncElemNode childrenOnly st.Top\n        st.PreviousNodes <- cur\n\n    /// EmbedNode constructor.\n    let CreateEmbedNode () =\n        {\n            Current = EmptyDoc\n            Dirty = false\n        }\n\n    /// EmbedNode update (marks dirty).\n    let UpdateEmbedNode node upd =\n        node.Current <- upd\n        node.Dirty <- true\n\n    /// Text node constructor.\n    let CreateTextNode () =\n        {\n            Dirty = false\n            Text = DU.CreateText \"\"\n            Value = \"\"\n        }\n\n    /// Text node update (marks dirty).\n    let UpdateTextNode n t =\n        n.Value <- t\n        n.Dirty <- true\n\n// We implement the Doc interface, the Doc module proxy and the Client.Doc module proxy\n// all in this so that it all neatly looks like Doc.* in javascript.\n[<Name \"WebSharper.UI.Doc\"; Proxy(typeof<Doc>)>]\ntype internal Doc' [<JavaScript>] (docNode, updates) =\n\n    [<JavaScript; Inline>]\n    member this.DocNode = docNode\n    [<JavaScript; Inline>]\n    member this.Updates = updates\n\n    interface IControlBody with\n\n        [<JavaScript>]\n        member this.ReplaceInDom(elt) =\n            // Insert empty text nodes that will serve as delimiters for the Doc.\n            let rdelim = JS.Document.CreateTextNode \"\"\n            elt.ParentNode.ReplaceChild(rdelim, elt) |> ignore\n            Doc'.RunBefore rdelim this\n\n    [<JavaScript>]\n    static member Mk node updates =\n        Doc'(node, updates)\n\n    [<JavaScript>]\n    static member Append (a: Doc') (b: Doc') =\n        (a.Updates, b.Updates)\n        ||> View.Map2Unit\n        |> Doc'.Mk (AppendDoc (a.DocNode, b.DocNode))\n\n    [<JavaScript>]\n    static member Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Doc'.Empty Doc'.Append\n\n    [<JavaScript>]\n    static member Empty\n        with get () =\n            Doc'.Mk EmptyDoc (View.Const ())\n\n    [<JavaScript; Inline>]\n    static member Elem el attr (children: Doc') =\n        Elt'.New(el, attr, children)\n\n    [<JavaScript>]\n    static member TextNode v =\n        Doc'.Mk (TextNodeDoc (DU.CreateText v)) (View.Const ())\n\n    [<JavaScript>]\n    static member StaticProxy el : Elt' =\n        Doc'.Elem el Attr.Empty Doc'.Empty\n\n    [<JavaScript; Inline>]\n    static member Static el : Elt = As (Doc'.StaticProxy el)\n\n    [<JavaScript>]\n    static member Verbatim html =\n        let a =\n            match JQuery.JQuery.ParseHTML html with\n            | null -> [||]\n            | a -> a\n        let elem (n: Dom.Node) =\n            if n.NodeType = Dom.NodeType.Text then\n                TextNodeDoc (n :?> Dom.Text)\n            else\n                ElemDoc (Docs.CreateElemNode (n :?> Dom.Element) Attr.Empty EmptyDoc)\n        let append x y = AppendDoc (x, y)\n        let es = Array.MapTreeReduce elem EmptyDoc append a\n        Doc'.Mk es (View.Const ())\n\n    [<JavaScript>]\n    static member EmbedView (view: View<Doc'>) =\n        let node = Docs.CreateEmbedNode ()\n        view\n        |> View.Bind (fun doc ->\n            Docs.UpdateEmbedNode node doc.DocNode\n            doc.Updates)\n        |> View.Map ignore\n        |> Doc'.Mk (EmbedDoc node)\n\n    [<JavaScript>]\n    static member BindView (f: 'T -> Doc') (view: View<'T>) =\n        Doc'.EmbedView (View.Map f view)\n\n    [<JavaScript>]\n    static member Async (a: Async<Doc'>) : Doc' =\n        View.Const a\n        |> View.MapAsync id\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member RunBetween ldelim rdelim (doc: Doc') =\n        Docs.LinkPrevElement rdelim doc.DocNode\n        let st = Docs.CreateDelimitedRunState ldelim rdelim doc.DocNode\n        let p =\n            if Anim.UseAnimations || Settings.BatchUpdatesEnabled then\n                Mailbox.StartProcessor (Docs.PerformAnimatedUpdate false st doc.DocNode)\n            else\n                fun () -> Docs.PerformSyncUpdate false st doc.DocNode\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunBefore (rdelim: Dom.Node) (doc: Doc') =\n        let ldelim = JS.Document.CreateTextNode(\"\")\n        rdelim.ParentNode.InsertBefore(ldelim, rdelim) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunBeforeById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunBefore el doc\n\n    [<JavaScript>]\n    static member RunAfter (ldelim : Dom.Node) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode(\"\")\n        ldelim.ParentNode.InsertBefore(rdelim, ldelim.NextSibling) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunAfterById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAfter el doc\n\n    [<JavaScript>]\n    static member RunAppend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.AppendChild(rdelim) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunAppendById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAppend el doc\n\n    [<JavaScript>]\n    static member RunPrepend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.InsertBefore(rdelim, parent.FirstChild) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunPrependById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunPrepend el doc\n\n    [<JavaScript>]\n    static member RunInPlace childrenOnly parent (doc: Doc') =\n        let d = doc.DocNode\n        let st = Docs.CreateRunState parent d\n        let p =\n            if Anim.UseAnimations || Settings.BatchUpdatesEnabled then\n                Mailbox.StartProcessor (Docs.PerformAnimatedUpdate childrenOnly st doc.DocNode)\n            else\n                fun () -> Docs.PerformSyncUpdate childrenOnly st doc.DocNode\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member Run parent (doc: Doc') =\n        Docs.LinkElement parent doc.DocNode\n        Doc'.RunInPlace false parent doc\n\n    [<JavaScript>]\n    static member RunById id tr =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.Run el tr\n\n    [<JavaScript>]\n    static member RunReplaceById id (tr: Doc') =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> (tr :> IControlBody).ReplaceInDom(el)\n\n    [<JavaScript>]\n    static member TextView txt =\n        let node = Docs.CreateTextNode ()\n        txt\n        |> View.Map (Docs.UpdateTextNode node)\n        |> Doc'.Mk (TextDoc node)\n\n    [<JavaScript>]\n    static member Flatten view =\n        view\n        |> View.Map Doc'.Concat\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member Convert render view =\n        View.MapSeqCached render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertBy key render view =\n        View.MapSeqCachedBy key render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeq render view =\n        View.MapSeqCachedView render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqBy key render view =\n        View.MapSeqCachedViewBy key (As render) view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqVarBy key render var =\n        Var.MapLens key (As render) var |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member InputInternal elemTy attr =\n        let el = DU.CreateElement elemTy\n        Doc'.Elem el (Attr.Concat (attr el)) Doc'.Empty\n\n    [<JavaScript>]\n    static member Input attr (var: Var<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member PasswordBox attr (var: Var<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                Attr.Value var\n                Attr.Create \"type\" \"password\"\n            |])\n\n    [<JavaScript>]\n    static member IntInputUnchecked attr (var: Var<int>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0 then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.IntValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member IntInput attr (var: Var<CheckedInput<int>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.IntValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInputUnchecked attr (var: Var<float>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0. then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.FloatValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInput attr (var: Var<CheckedInput<float>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.FloatValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member InputArea attr (var: Var<string>) =\n        Doc'.InputInternal \"textarea\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member SelectImpl attrs (show: 'T -> string) (optionElements) (current: Var<'T>) =\n        let options = ref []\n        let getIndex (el: Dom.Element) =\n            el?selectedIndex : int\n        let setIndex (el: Dom.Element) (i: int) =\n            el?selectedIndex <- i\n        let getSelectedItem el =\n            let i = getIndex el\n            (!options).[i]\n        let itemIndex x =\n            List.findIndex ((=) x) !options\n        let setSelectedItem (el: Dom.Element) item =\n            setIndex el (itemIndex item)\n        let el = DU.CreateElement \"select\"\n        let selectedItemAttr =\n            current.View\n            |> Attr.DynamicCustom setSelectedItem\n        let onChange (x: Dom.Event) =\n            current.UpdateMaybe(fun x ->\n                let y = getSelectedItem el\n                if x = y then None else Some y\n            )\n        el.AddEventListener(\"change\", onChange, false)\n        let attrs =\n            Attr.Concat attrs\n            |> Attr.Append selectedItemAttr\n            |> Attr.Append (Attr.OnAfterRender (fun el -> \n                setSelectedItem el <| current.Get()))\n        Doc'.Elem el attrs (optionElements options)\n\n    [<JavaScript>]\n    static member SelectDyn attrs (show: 'T -> string) (vOptions: View<list<'T>>) (current: Var<'T>) =\n        let optionElements options =\n            vOptions\n            |> View.Map (fun l ->\n                options := l\n                l |> Seq.mapi (fun i x -> i, x)\n            )\n            |> Doc'.Convert (fun (i, o) ->\n                Doc'.Element \"option\" [\n                    Attr.Create \"value\" (string i)\n                ] [Doc'.TextNode (show o)]\n                :> Doc'\n            )\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member Select attrs show options current =\n        let optionElements rOptions =\n            rOptions := options\n            options\n            |> List.mapi (fun i o ->\n                Doc'.Element \"option\" [\n                    Attr.Create \"value\" (string i)\n                ] [Doc'.TextNode (show o)]\n                :> Doc'\n            )\n            |> Doc'.Concat\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member SelectOptional attrs noneText show options current =\n        Doc'.Select attrs\n            (function None -> noneText | Some x -> show x)\n            (None :: List.map Some options)\n            current\n\n    [<JavaScript>]\n    static member SelectDynOptional attrs noneText show vOptions current =\n        Doc'.SelectDyn attrs\n            (function None -> noneText | Some x -> show x)\n            (vOptions |> View.Map (fun options -> None :: List.map Some options))\n            current\n\n    [<JavaScript>]\n    static member CheckBox attrs (chk: Var<bool>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attrs [\n                Attr.Create \"type\" \"checkbox\"\n                Attr.Checked chk\n            ])\n\n    [<JavaScript>]\n    static member CheckBoxGroup attrs (item: 'T) (chk: Var<list<'T>>) =\n        let rv =\n            chk.Lens\n                (List.exists ((=) item))\n                (fun l b ->\n                    if b then\n                        if List.exists ((=) item) l then l else item :: l\n                    else\n                        List.filter ((<>) item) l\n                )\n        Doc'.CheckBox attrs rv\n\n    [<JavaScript>]\n    static member Clickable elem action =\n        let el = DU.CreateElement elem\n        el.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            ev.PreventDefault()\n            action ()), false)\n        el\n\n    [<JavaScript>]\n    static member Button caption attrs action =\n        let attrs = Attr.Concat attrs\n        let el = Doc'.Clickable \"button\" action\n        Doc'.Elem el attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member ButtonView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr|] attrs)\n        Doc'.Elem (DU.CreateElement \"button\") attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member Link caption attrs action =\n        let attrs = Attr.Concat attrs |> Attr.Append (Attr.Create \"href\" \"#\")\n        let el = Doc'.Clickable \"a\" action\n        Doc'.Elem el attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member LinkView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr; Attr.Create \"href\" \"#\"|] attrs)\n        Doc'.Elem (DU.CreateElement \"a\") attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member Radio attrs value (var: Var<_>) =\n        // Radio buttons work by taking a common var, which is given a unique ID.\n        // This ID is serialised and used as the name, giving us the \"grouping\"\n        // behaviour.\n        let el = DU.CreateElement \"input\"\n        el.AddEventListener(\"click\", (fun (x : Dom.Event) -> var.Set value), false)\n        let predView = View.Map (fun x -> x = value) var.View\n        let valAttr = Attr.DynamicProp \"checked\" predView\n        let (==>) k v = Attr.Create k v\n        let attr =\n            [\n                \"type\" ==> \"radio\"\n                \"name\" ==> var.Id\n                valAttr\n            ] @ (List.ofSeq attrs) |> Attr.Concat\n        Doc'.Elem el attr Doc'.Empty\n\n    // Actual proxy members\n\n    [<JavaScript>]\n    static member Element (name: string) (attr: seq<Attr>) (children: seq<Doc'>) : Elt' =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat children\n        Doc'.Elem (DU.CreateElement name) attr children\n\n    static member ToMixedDoc (o: obj) =\n        match o with\n        | :? Doc' as d -> d\n        | :? string as t -> Doc'.TextNode t\n        | :? Dom.Element as e -> Doc'.StaticProxy e :> Doc'\n        | :? Function as v ->\n            Doc'.EmbedView ((As<View<_>>v).Map Doc'.ToMixedDoc)\n        | :? Var<obj> as v ->\n            Doc'.EmbedView (v.View.Map Doc'.ToMixedDoc)\n        | null -> Doc'.Empty\n        | o -> Doc'.TextNode (string o)\n\n    static member MixedNodes (nodes: seq<obj>) =\n        let attrs = ResizeArray()\n        let children = ResizeArray()\n        for n in nodes do\n            match n with\n            | :? Attr as a -> attrs.Add a\n            | _ -> children.Add (Doc'.ToMixedDoc n)\n        attrs :> _ seq, children :> _ seq \n\n    static member ConcatMixed (elts: obj[]) =\n        Doc'.Concat (Seq.map Doc'.ToMixedDoc elts)\n\n    [<JavaScript>]\n    static member ElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc'.Element tagname attrs children \n\n    [<JavaScript>]\n    static member SvgElement (name: string) (attr: seq<Attr>) (children: seq<Doc'>) : Elt' =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat children\n        Doc'.Elem (DU.CreateSvgElement name) attr children\n\n    [<JavaScript>]\n    static member SvgElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc'.SvgElement tagname attrs children \n\n    [<JavaScript; Inline>]\n    static member ClientSide (expr: Microsoft.FSharp.Quotations.Expr<#IControlBody>) : Doc' =\n        As expr\n\nand [<JavaScript; Proxy(typeof<Elt>); Name \"WebSharper.UI.Elt\">]\n    internal Elt'(docNode, updates, elt: Dom.Element, rvUpdates: Updates) =\n    inherit Doc'(docNode, updates)\n\n    static member New(el: Dom.Element, attr: Attr, children: Doc') =\n        let node = Docs.CreateElemNode el attr children.DocNode\n        let rvUpdates = Updates.Create children.Updates\n        let attrUpdates = Attrs.Updates node.Attr\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(ElemDoc node, updates, el, rvUpdates)\n\n    /// Assumes tree.Els = [| Union1Of2 someDomElement |]\n    static member TreeNode(tree: DocTreeNode, updates) =\n        let rvUpdates = Updates.Create updates\n        let attrUpdates =\n            tree.Attrs\n            |> Array.map (snd >> Attrs.Updates)\n            |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(TreeDoc tree, updates, tree.Els.[0].Value1 :?> _, rvUpdates)\n\n    [<Inline \"$0.elt\">]\n    member this.Element = elt\n\n    member this.on (ev: string, cb: Dom.Element -> #Dom.Event -> unit) =\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> cb elt (ev :?> _)), false)\n        this\n\n    member this.onView (ev: string, view: View<'T>, cb: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let cb = cb elt\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> View.Get (cb (ev :?> _)) view), false)\n        this\n\n    [<Name \"On\"; Inline>]\n    member this.onExpr (ev: string, cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> #Dom.Event -> unit>) =\n        this.on (ev, As<_ -> _ -> _> cb)\n\n    member this.OnAfterRender' (cb: Dom.Element -> unit) =\n        match docNode with\n        | ElemDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | TreeDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | _ -> failwith \"Invalid docNode in Elt\"\n        this\n\n    member this.OnAfterRender (cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> unit>) =\n        this.OnAfterRender' (As<Dom.Element -> unit> cb)\n\n    member this.OnAfterRenderView (view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        this.AppendDoc(Doc'.BindView (fun x -> this.Element?(id) <- x; Doc'.Empty) view)\n        this.OnAfterRender'(fun e -> cb e e?(id))\n\n    abstract AddHole : DocElemNode -> unit \n    default this.AddHole h = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes.JS.Push h |> ignore\n        | _ -> ()\n\n    abstract ClearHoles : unit -> unit \n    default this.ClearHoles() = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes <- [||]\n        | _ -> ()\n\n    [<Name \"Append\">]\n    member this.AppendDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(e.Children, doc.DocNode)\n            Docs.InsertDoc elt doc.DocNode DU.AtEnd |> ignore\n        | TreeDoc e ->\n            let after = elt.AppendChild(JS.Document.CreateTextNode \"\")\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            } \n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Prepend\">]\n    member this.PrependDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(doc.DocNode, e.Children)\n            let pos =\n                match elt.FirstChild with\n                | null -> DU.AtEnd\n                | n -> DU.BeforeNode n\n            Docs.InsertDoc elt doc.DocNode pos |> ignore\n        | TreeDoc e ->\n            let after = elt.InsertBefore(JS.Document.CreateTextNode \"\", elt.FirstChild)\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            }\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Clear\">]\n    member this.Clear'() =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        while (elt.HasChildNodes()) do elt.RemoveChild(elt.FirstChild) |> ignore\n\n    [<JavaScript>]\n    member this.ToUpdater() =\n        let docTreeNode : DocTreeNode =\n            match docNode with\n            | ElemDoc e ->\n                {\n                    Els = [| Union1Of2 (upcast elt) |]\n                    Holes = [||]\n                    Attrs = [| elt, e.Attr |]\n                    Render = None\n                    Dirty = true\n                    El = Some elt\n                }\n            | TreeDoc e -> e\n            | _ -> failwith \"Invalid docNode in Elt\"\n\n        EltUpdater'(docTreeNode, updates, elt, rvUpdates, Var.Create [||])\n\n    [<Name \"Html\">]\n    member this.Html'() : string =\n        elt?outerHTML\n\n    [<Name \"Id\">]\n    member this.Id'() : string =\n        elt?id\n\n    [<Name \"GetValue\">]\n    member this.GetValue() : string =\n        elt?value\n\n    [<Name \"SetValue\">]\n    member this.SetValue(v: string) : unit =\n        elt?value <- v\n\n    [<Name \"GetText\">]\n    member this.GetText() : string =\n        elt.TextContent\n\n    [<Name \"SetText\">]\n    member this.SetText(v: string) : unit =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        elt.TextContent <- v\n\n    [<Name \"SetAttribute\">]\n    member this.SetAttribute'(name: string, value: string) =\n        elt.SetAttribute(name, value)\n\n    [<Name \"GetAttribute\">]\n    member this.GetAttribute'(name) =\n        elt.GetAttribute(name)\n\n    [<Name \"HasAttribute\">]\n    member this.HasAttribute'(name) =\n        elt.HasAttribute(name)\n\n    [<Name \"RemoveAttribute\">]\n    member this.RemoveAttribute'(name) =\n        elt.RemoveAttribute(name)\n\n    [<Name \"SetProperty\">]\n    member this.SetProperty'(name: string, value: 'T) =\n        elt?(name) <- value\n\n    [<Name \"GetProperty\">]\n    member this.GetProperty'(name: string) : 'T =\n        elt?(name)\n\n    [<Inline>]\n    member this.AddClass'(cls: string) =\n        DU.AddClass elt cls\n\n    [<Inline>]\n    member this.RemoveClass'(cls: string) =\n        DU.RemoveClass elt cls\n\n    [<Name \"HasClass\">]\n    member this.HasClass'(cls: string) =\n        (new RegExp(@\"(\\s|^)\" + cls + @\"(\\s|$)\")).Test(elt?className)\n\n    [<Name \"SetStyle\">]\n    member this.SetStyle'(style: string, value: string) =\n        elt?style?(style) <- value\n\n    // {{ event\n    [<Inline>]\n    member this.OnAbort(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"abort\", cb)\n    [<Inline>]\n    member this.OnAfterPrint(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"afterprint\", cb)\n    [<Inline>]\n    member this.OnAnimationEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationend\", cb)\n    [<Inline>]\n    member this.OnAnimationIteration(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationiteration\", cb)\n    [<Inline>]\n    member this.OnAnimationStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationstart\", cb)\n    [<Inline>]\n    member this.OnAudioProcess(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"audioprocess\", cb)\n    [<Inline>]\n    member this.OnBeforePrint(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beforeprint\", cb)\n    [<Inline>]\n    member this.OnBeforeUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beforeunload\", cb)\n    [<Inline>]\n    member this.OnBeginEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beginEvent\", cb)\n    [<Inline>]\n    member this.OnBlocked(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"blocked\", cb)\n    [<Inline>]\n    member this.OnBlur(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.FocusEvent -> unit>) = this.onExpr(\"blur\", cb)\n    [<Inline>]\n    member this.OnCached(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"cached\", cb)\n    [<Inline>]\n    member this.OnCanPlay(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"canplay\", cb)\n    [<Inline>]\n    member this.OnCanPlayThrough(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"canplaythrough\", cb)\n    [<Inline>]\n    member this.OnChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"change\", cb)\n    [<Inline>]\n    member this.OnChargingChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"chargingchange\", cb)\n    [<Inline>]\n    member this.OnChargingTimeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"chargingtimechange\", cb)\n    [<Inline>]\n    member this.OnChecking(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"checking\", cb)\n    [<Inline>]\n    member this.OnClick(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"click\", cb)\n    [<Inline>]\n    member this.OnClose(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"close\", cb)\n    [<Inline>]\n    member this.OnComplete(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"complete\", cb)\n    [<Inline>]\n    member this.OnCompositionEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionend\", cb)\n    [<Inline>]\n    member this.OnCompositionStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionstart\", cb)\n    [<Inline>]\n    member this.OnCompositionUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionupdate\", cb)\n    [<Inline>]\n    member this.OnContextMenu(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"contextmenu\", cb)\n    [<Inline>]\n    member this.OnCopy(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"copy\", cb)\n    [<Inline>]\n    member this.OnCut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"cut\", cb)\n    [<Inline>]\n    member this.OnDblClick(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"dblclick\", cb)\n    [<Inline>]\n    member this.OnDeviceLight(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"devicelight\", cb)\n    [<Inline>]\n    member this.OnDeviceMotion(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"devicemotion\", cb)\n    [<Inline>]\n    member this.OnDeviceOrientation(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"deviceorientation\", cb)\n    [<Inline>]\n    member this.OnDeviceProximity(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"deviceproximity\", cb)\n    [<Inline>]\n    member this.OnDischargingTimeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dischargingtimechange\", cb)\n    [<Inline>]\n    member this.OnDOMActivate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"DOMActivate\", cb)\n    [<Inline>]\n    member this.OnDOMAttributeNameChanged(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMAttributeNameChanged\", cb)\n    [<Inline>]\n    member this.OnDOMAttrModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMAttrModified\", cb)\n    [<Inline>]\n    member this.OnDOMCharacterDataModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMCharacterDataModified\", cb)\n    [<Inline>]\n    member this.OnDOMContentLoaded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMContentLoaded\", cb)\n    [<Inline>]\n    member this.OnDOMElementNameChanged(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMElementNameChanged\", cb)\n    [<Inline>]\n    member this.OnDOMNodeInserted(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeInserted\", cb)\n    [<Inline>]\n    member this.OnDOMNodeInsertedIntoDocument(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeInsertedIntoDocument\", cb)\n    [<Inline>]\n    member this.OnDOMNodeRemoved(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeRemoved\", cb)\n    [<Inline>]\n    member this.OnDOMNodeRemovedFromDocument(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeRemovedFromDocument\", cb)\n    [<Inline>]\n    member this.OnDOMSubtreeModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMSubtreeModified\", cb)\n    [<Inline>]\n    member this.OnDownloading(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"downloading\", cb)\n    [<Inline>]\n    member this.OnDrag(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"drag\", cb)\n    [<Inline>]\n    member this.OnDragEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragend\", cb)\n    [<Inline>]\n    member this.OnDragEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragenter\", cb)\n    [<Inline>]\n    member this.OnDragLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragleave\", cb)\n    [<Inline>]\n    member this.OnDragOver(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragover\", cb)\n    [<Inline>]\n    member this.OnDragStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragstart\", cb)\n    [<Inline>]\n    member this.OnDrop(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"drop\", cb)\n    [<Inline>]\n    member this.OnDurationChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"durationchange\", cb)\n    [<Inline>]\n    member this.OnEmptied(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"emptied\", cb)\n    [<Inline>]\n    member this.OnEnded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"ended\", cb)\n    [<Inline>]\n    member this.OnEndEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"endEvent\", cb)\n    [<Inline>]\n    member this.OnError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"error\", cb)\n    [<Inline>]\n    member this.OnFocus(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.FocusEvent -> unit>) = this.onExpr(\"focus\", cb)\n    [<Inline>]\n    member this.OnFullScreenChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"fullscreenchange\", cb)\n    [<Inline>]\n    member this.OnFullScreenError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"fullscreenerror\", cb)\n    [<Inline>]\n    member this.OnGamepadConnected(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"gamepadconnected\", cb)\n    [<Inline>]\n    member this.OnGamepadDisconnected(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"gamepaddisconnected\", cb)\n    [<Inline>]\n    member this.OnHashChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"hashchange\", cb)\n    [<Inline>]\n    member this.OnInput(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"input\", cb)\n    [<Inline>]\n    member this.OnInvalid(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"invalid\", cb)\n    [<Inline>]\n    member this.OnKeyDown(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keydown\", cb)\n    [<Inline>]\n    member this.OnKeyPress(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keypress\", cb)\n    [<Inline>]\n    member this.OnKeyUp(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keyup\", cb)\n    [<Inline>]\n    member this.OnLanguageChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"languagechange\", cb)\n    [<Inline>]\n    member this.OnLevelChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"levelchange\", cb)\n    [<Inline>]\n    member this.OnLoad(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"load\", cb)\n    [<Inline>]\n    member this.OnLoadedData(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadeddata\", cb)\n    [<Inline>]\n    member this.OnLoadedMetadata(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadedmetadata\", cb)\n    [<Inline>]\n    member this.OnLoadEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadend\", cb)\n    [<Inline>]\n    member this.OnLoadStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadstart\", cb)\n    [<Inline>]\n    member this.OnMessage(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"message\", cb)\n    [<Inline>]\n    member this.OnMouseDown(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mousedown\", cb)\n    [<Inline>]\n    member this.OnMouseEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseenter\", cb)\n    [<Inline>]\n    member this.OnMouseLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseleave\", cb)\n    [<Inline>]\n    member this.OnMouseMove(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mousemove\", cb)\n    [<Inline>]\n    member this.OnMouseOut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseout\", cb)\n    [<Inline>]\n    member this.OnMouseOver(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseover\", cb)\n    [<Inline>]\n    member this.OnMouseUp(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseup\", cb)\n    [<Inline>]\n    member this.OnNoUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"noupdate\", cb)\n    [<Inline>]\n    member this.OnObsolete(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"obsolete\", cb)\n    [<Inline>]\n    member this.OnOffline(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"offline\", cb)\n    [<Inline>]\n    member this.OnOnline(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"online\", cb)\n    [<Inline>]\n    member this.OnOpen(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"open\", cb)\n    [<Inline>]\n    member this.OnOrientationChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"orientationchange\", cb)\n    [<Inline>]\n    member this.OnPageHide(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pagehide\", cb)\n    [<Inline>]\n    member this.OnPageShow(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pageshow\", cb)\n    [<Inline>]\n    member this.OnPaste(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"paste\", cb)\n    [<Inline>]\n    member this.OnPause(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pause\", cb)\n    [<Inline>]\n    member this.OnPlay(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"play\", cb)\n    [<Inline>]\n    member this.OnPlaying(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"playing\", cb)\n    [<Inline>]\n    member this.OnPointerLockChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pointerlockchange\", cb)\n    [<Inline>]\n    member this.OnPointerLockError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pointerlockerror\", cb)\n    [<Inline>]\n    member this.OnPopState(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"popstate\", cb)\n    [<Inline>]\n    member this.OnProgress(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"progress\", cb)\n    [<Inline>]\n    member this.OnRateChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"ratechange\", cb)\n    [<Inline>]\n    member this.OnReadyStateChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"readystatechange\", cb)\n    [<Inline>]\n    member this.OnRepeatEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"repeatEvent\", cb)\n    [<Inline>]\n    member this.OnReset(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"reset\", cb)\n    [<Inline>]\n    member this.OnResize(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"resize\", cb)\n    [<Inline>]\n    member this.OnScroll(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"scroll\", cb)\n    [<Inline>]\n    member this.OnSeeked(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"seeked\", cb)\n    [<Inline>]\n    member this.OnSeeking(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"seeking\", cb)\n    [<Inline>]\n    member this.OnSelect(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"select\", cb)\n    [<Inline>]\n    member this.OnShow(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"show\", cb)\n    [<Inline>]\n    member this.OnStalled(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"stalled\", cb)\n    [<Inline>]\n    member this.OnStorage(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"storage\", cb)\n    [<Inline>]\n    member this.OnSubmit(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"submit\", cb)\n    [<Inline>]\n    member this.OnSuccess(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"success\", cb)\n    [<Inline>]\n    member this.OnSuspend(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"suspend\", cb)\n    [<Inline>]\n    member this.OnSVGAbort(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGAbort\", cb)\n    [<Inline>]\n    member this.OnSVGError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGError\", cb)\n    [<Inline>]\n    member this.OnSVGLoad(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGLoad\", cb)\n    [<Inline>]\n    member this.OnSVGResize(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGResize\", cb)\n    [<Inline>]\n    member this.OnSVGScroll(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGScroll\", cb)\n    [<Inline>]\n    member this.OnSVGUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGUnload\", cb)\n    [<Inline>]\n    member this.OnSVGZoom(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGZoom\", cb)\n    [<Inline>]\n    member this.OnTimeOut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"timeout\", cb)\n    [<Inline>]\n    member this.OnTimeUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"timeupdate\", cb)\n    [<Inline>]\n    member this.OnTouchCancel(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchcancel\", cb)\n    [<Inline>]\n    member this.OnTouchEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchend\", cb)\n    [<Inline>]\n    member this.OnTouchEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchenter\", cb)\n    [<Inline>]\n    member this.OnTouchLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchleave\", cb)\n    [<Inline>]\n    member this.OnTouchMove(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchmove\", cb)\n    [<Inline>]\n    member this.OnTouchStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchstart\", cb)\n    [<Inline>]\n    member this.OnTransitionEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"transitionend\", cb)\n    [<Inline>]\n    member this.OnUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"unload\", cb)\n    [<Inline>]\n    member this.OnUpdateReady(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"updateready\", cb)\n    [<Inline>]\n    member this.OnUpgradeNeeded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"upgradeneeded\", cb)\n    [<Inline>]\n    member this.OnUserProximity(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"userproximity\", cb)\n    [<Inline>]\n    member this.OnVersionChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"versionchange\", cb)\n    [<Inline>]\n    member this.OnVisibilityChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"visibilitychange\", cb)\n    [<Inline>]\n    member this.OnVolumeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"volumechange\", cb)\n    [<Inline>]\n    member this.OnWaiting(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"waiting\", cb)\n    [<Inline>]\n    member this.OnWheel(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.WheelEvent -> unit>) = this.onExpr(\"wheel\", cb)\n    // }}\n\nand [<JavaScript; Proxy(typeof<EltUpdater>)>] \n    internal EltUpdater'(treeNode : DocTreeNode, updates, elt, rvUpdates: Updates, holeUpdates: Var<(int * View<unit>)[]>) =\n    inherit Elt'(\n        TreeDoc treeNode, \n        View.Map2Unit updates (holeUpdates.View |> View.BindInner (Array.map snd >> Array.TreeReduce (View.Const ()) View.Map2Unit)),\n        elt, rvUpdates)\n\n    let mutable origHoles = treeNode.Holes\n\n    override this.AddHole h =\n        origHoles.JS.Push h |> ignore\n        treeNode.Holes <- Array.append treeNode.Holes [| h |]\n\n    override this.ClearHoles() =\n        origHoles <- [||]\n        treeNode.Holes <- [||]\n        holeUpdates.Value <- [||]\n\n    member this.AddUpdated(doc: Elt') =\n        match doc.DocNode with\n        | ElemDoc e ->\n            treeNode.Holes <- Array.append treeNode.Holes [| e |]\n            let hu = holeUpdates.Value\n            hu.JS.Push ((e.ElKey, doc.Updates)) |> ignore\n            holeUpdates.Value <- hu\n        | _ -> failwith \"DocUpdater.AddUpdated expects a single element node\"\n\n    member this.RemoveUpdated(doc: Elt') =\n        match doc.DocNode with\n        | ElemDoc e ->\n            let k = e.ElKey\n            treeNode.Holes <-\n                treeNode.Holes |> Array.filter (fun h -> h.ElKey <> k)\n            holeUpdates.Value <-\n                holeUpdates.Value |> Array.filter (function\n                    | uk, _ when uk = k -> false\n                    | _ -> true\n                )  \n        | _ -> failwith \"DocUpdater.RemoveUpdated expects a single element node\"\n\n    member this.RemoveAllUpdated() =\n        treeNode.Holes <- origHoles\n        holeUpdates.Value <- [||]\n", "namespace WebSharper.UI.Client\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\n\n[<JavaScript>]\nmodule internal Templates =\n\n    let LoadedTemplates = Dictionary<string, Dictionary<string, Dom.Element>>()\n    let LoadedTemplateFile name =\n        match LoadedTemplates.TryGetValue name with\n        | true, d -> d\n        | false, _ ->\n            let d = Dictionary()\n            LoadedTemplates.[name] <- d\n            d\n    let mutable LocalTemplatesLoaded = false\n\n    let TextHoleRE = \"\"\"\\${([^}]+)}\"\"\"\n\n    let InlineTemplate (el: Dom.Element) (fillWith: seq<TemplateHole>) =\n        let holes : DocElemNode[] = [||]\n        let updates : View<unit>[] = [||]\n        let attrs : (Dom.Element * Attrs.Dyn)[] = [||]\n        let afterRender : (Dom.Element -> unit)[] = [||]\n        let fw = Dictionary()\n        for x in fillWith do fw.[TemplateHole.Name x] <- x\n        let els = As<Union<Dom.Node, DocNode>[]> (DomUtility.ChildrenArray el)\n        let addAttr (el: Dom.Element) (attr: Attr) =\n            let attr = Attrs.Insert el attr\n            updates.JS.Push (Attrs.Updates attr) |> ignore\n            attrs.JS.Push ((el, attr)) |> ignore\n            match Attrs.GetOnAfterRender attr with\n            | Some f -> afterRender.JS.Push(fun _ -> f el) |> ignore\n            | None -> ()\n        let tryGetAsDoc name =\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Elt (_, doc) -> Some (As<Doc'> doc)\n            | true, TemplateHole.Text (_, text) -> Some (Doc'.TextNode text)\n            | true, TemplateHole.TextView (_, tv) -> Some (Doc'.TextView tv)\n            | true, TemplateHole.VarStr (_, v) -> Some (Doc'.TextView v.View)\n            | true, TemplateHole.VarBool (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarInt (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarIntUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarFloat (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarFloatUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, _ -> Console.Warn(\"Content hole filled with attribute data\", name); None\n            | false, _ -> None\n\n        DomUtility.IterSelector el \"[ws-hole]\" <| fun p ->\n            let name = p.GetAttribute(\"ws-hole\")\n            p.RemoveAttribute(\"ws-hole\")\n            while (p.HasChildNodes()) do\n                p.RemoveChild(p.LastChild) |> ignore\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                Docs.LinkElement p doc.DocNode\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = None\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-replace]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-replace\")\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                let p = e.ParentNode :?> Dom.Element\n                let after = JS.Document.CreateTextNode(\"\") :> Dom.Node\n                p.ReplaceChild(after, e) |> ignore\n                let before = Docs.InsertBeforeDelim after doc.DocNode\n                els\n                |> Array.tryFindIndex ((===.) e)\n                |> Option.iter (fun i -> els.[i] <- Union2Of2 doc.DocNode)\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = Some (before, after)\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-attr]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-attr\")\n            e.RemoveAttribute(\"ws-attr\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Attribute (_, attr) -> addAttr e attr\n            | true, _ -> Console.Warn(\"Attribute hole filled with non-attribute data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-on]\" <| fun e ->\n            e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Array.choose (fun x ->\n                let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                match fw.TryGetValue(a.[1]) with\n                | true, TemplateHole.Event (_, handler) -> Some (Attr.Handler a.[0] handler)\n                | true, TemplateHole.EventQ (_, _, handler) -> Some (A.Handler a.[0] handler)\n                | true, _ ->\n                    Console.Warn(\"Event hole on\" + a.[0] + \" filled with non-event data\", a.[1])\n                    None\n                | false, _ -> None\n            )\n            |> Attr.Concat\n            |> addAttr e\n            e.RemoveAttribute(\"ws-on\")\n\n        DomUtility.IterSelector el \"[ws-onafterrender]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-onafterrender\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.AfterRender (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender handler)\n            | true, TemplateHole.AfterRenderQ (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender (As handler))\n            | true, _ -> Console.Warn(\"onafterrender hole filled with non-onafterrender data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-var]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-var\")\n            e.RemoveAttribute(\"ws-var\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.VarStr (_, var) -> addAttr e (Attr.Value var)\n            | true, TemplateHole.VarBool (_, var) -> addAttr e (Attr.Checked var)\n            | true, TemplateHole.VarInt (_, var) -> addAttr e (Attr.IntValue var)\n            | true, TemplateHole.VarIntUnchecked (_, var) -> addAttr e (Attr.IntValueUnchecked var)\n            | true, TemplateHole.VarFloat (_, var) -> addAttr e (Attr.FloatValue var)\n            | true, TemplateHole.VarFloatUnchecked (_, var) -> addAttr e (Attr.FloatValueUnchecked var)\n            | true, _ -> Console.Warn(\"Var hole filled with non-Var data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-attr-holes]\" <| fun e ->\n            let re = new RegExp(TextHoleRE, \"g\")\n            let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            e.RemoveAttribute(\"ws-attr-holes\")\n            for attrName in holeAttrs do\n                let s = e.GetAttribute(attrName)\n                let mutable m = null\n                let mutable lastIndex = 0\n                let res : (string * string)[] = [||]\n                while (m <- re.Exec s; m !==. null) do\n                    let textBefore = s.[lastIndex .. re.LastIndex-m.[0].Length-1]\n                    lastIndex <- re.LastIndex\n                    let holeName = m.[1]\n                    res.JS.Push((textBefore, holeName)) |> ignore\n                let finalText = s.[lastIndex..]\n                re.LastIndex <- 0\n                let value =\n                    Array.foldBack (fun (textBefore, holeName: string) (textAfter, views) ->\n                        let holeContent =\n                            match fw.TryGetValue(holeName) with\n                            | true, TemplateHole.Text (_, t) -> Choice1Of2 t\n                            | true, TemplateHole.TextView (_, v) -> Choice2Of2 v\n                            | true, TemplateHole.VarStr (_, v) -> Choice2Of2 v.View\n                            | true, TemplateHole.VarBool (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarInt (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarIntUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarFloat (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarFloatUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, _ ->\n                                Console.Warn(\"Attribute value hole filled with non-text data\", holeName)\n                                Choice1Of2 \"\"\n                            | false, _ -> Choice1Of2 \"\"\n                        match holeContent with\n                        | Choice1Of2 text -> textBefore + text + textAfter, views\n                        | Choice2Of2 v ->\n                            let v =\n                                if textAfter = \"\" then v else\n                                View.Map (fun s -> s + textAfter) v\n                            textBefore, v :: views\n                    ) res (finalText, [])\n                match value with\n                | s, [] -> Attr.Create attrName s\n                | \"\", [v] -> Attr.Dynamic attrName v\n                | s, [v] -> Attr.Dynamic attrName (View.Map (fun v -> s + v) v)\n                | s, [v1; v2] -> Attr.Dynamic attrName (View.Map2 (fun v1 v2 -> s + v1 + v2) v1 v2)\n                | s, [v1; v2; v3] -> Attr.Dynamic attrName (View.Map3 (fun v1 v2 v3 -> s + v1 + v2 + v3) v1 v2 v3)\n                | s, vs ->\n                    View.Sequence vs\n                    |> View.Map (fun vs -> s + String.concat \"\" vs)\n                    |> Attr.Dynamic attrName\n                |> addAttr e\n\n        let docTreeNode : DocTreeNode =\n            {\n                Els = els\n                Holes = holes\n                Attrs = attrs\n                Render =\n                    if Array.isEmpty afterRender\n                    then None\n                    else Some (fun el -> Array.iter (fun f -> f el) afterRender)\n                Dirty = true\n                El =\n                    match els with\n                    | [| Union1Of2 (:? Dom.Element as el) |] -> Some el\n                    | _ -> None\n            }\n        let updates =\n            updates |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        docTreeNode, updates\n\n    let ChildrenTemplate (el: Dom.Element) (fillWith: seq<TemplateHole>) =\n        let docTreeNode, updates = InlineTemplate el fillWith\n        match docTreeNode.Els with\n        | [| Union1Of2 e |] when e.NodeType = Dom.NodeType.Element ->\n            Elt'.TreeNode(docTreeNode, updates) :> Doc'\n        | _ ->\n            Doc'.Mk (TreeDoc docTreeNode) updates\n\n    let FakeRoot (els: Dom.Node[]) =\n        let fakeroot = JS.Document.CreateElement(\"div\")\n        for el in els do fakeroot.AppendChild el |> ignore\n        fakeroot\n\n    let FakeRootSingle (el: Dom.Element) =\n        el.RemoveAttribute(\"ws-template\")\n        match el.GetAttribute(\"ws-replace\") with\n        | null -> ()\n        | replace ->\n            el.RemoveAttribute(\"ws-replace\")\n            match el.ParentNode with\n            | null -> ()\n            | p ->\n                let n = JS.Document.CreateElement(el.TagName)\n                n.SetAttribute(\"ws-replace\", replace)\n                p.ReplaceChild(n, el) |> ignore\n        FakeRoot [| el |]\n\n    module private Prepare =\n\n        let convertAttrs (el: Dom.Element) =\n            let attrs = el.Attributes\n            let toRemove = [||]\n            let events = [||]\n            let holedAttrs = [||]\n            for i = 0 to attrs.Length - 1 do\n                let a = attrs.[i]\n                if a.NodeName.StartsWith \"ws-on\" && a.NodeName <> \"ws-onafterrender\" && a.NodeName <> \"ws-on\" then\n                    toRemove.JS.Push(a.NodeName) |> ignore\n                    events.JS.Push(a.NodeName.[\"ws-on\".Length..] + \":\" + a.NodeValue.ToLower()) |> ignore\n                elif not (a.NodeName.StartsWith \"ws-\") && RegExp(TextHoleRE).Test(a.NodeValue) then\n                    a.NodeValue <-\n                        RegExp(TextHoleRE, \"g\")\n                            .Replace(a.NodeValue, FuncWithArgs (fun (_, h: string) ->\n                                \"${\" + h.ToLower() + \"}\"))\n                    holedAttrs.JS.Push(a.NodeName) |> ignore\n            if not (Array.isEmpty events) then\n                el.SetAttribute(\"ws-on\", String.concat \" \" events)\n            if not (Array.isEmpty holedAttrs) then\n                el.SetAttribute(\"ws-attr-holes\", String.concat \" \" holedAttrs)\n            let lowercaseAttr name =\n                match el.GetAttribute(name) with\n                | null -> ()\n                | x -> el.SetAttribute(name, x.ToLower())\n            lowercaseAttr \"ws-hole\"\n            lowercaseAttr \"ws-replace\"\n            lowercaseAttr \"ws-attr\"\n            lowercaseAttr \"ws-onafterrender\"\n            lowercaseAttr \"ws-var\"\n            Array.iter el.RemoveAttribute toRemove\n\n        let convertTextNode (n: Dom.Node) =\n            let mutable m = null\n            let mutable li = 0\n            let s = n.TextContent\n            let strRE = RegExp(TextHoleRE, \"g\")\n            while (m <- strRE.Exec s; m !==. null) do\n                n.ParentNode.InsertBefore(JS.Document.CreateTextNode(s.[li..strRE.LastIndex-m.[0].Length-1]), n) |> ignore\n                li <- strRE.LastIndex\n                let hole = JS.Document.CreateElement(\"span\")\n                hole.SetAttribute(\"ws-replace\", m.[1].ToLower())\n                n.ParentNode.InsertBefore(hole, n) |> ignore\n            strRE.LastIndex <- 0\n            n.TextContent <- s.[li..]\n\n        let mapHoles (t: Dom.Element) (mappings: Dictionary<string, string>) =\n            let run attrName =\n                DomUtility.IterSelector t (\"[\" + attrName + \"]\") <| fun e ->\n                    match mappings.TryGetValue(e.GetAttribute(attrName).ToLower()) with\n                    | true, m -> e.SetAttribute(attrName, m)\n                    | false, _ -> ()\n            run \"ws-hole\"\n            run \"ws-replace\"\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector t \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.map (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        match mappings.TryGetValue(a.[1]) with\n                        | true, x -> a.[0] + \":\" + x\n                        | false, _ -> x\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector t \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        (e.GetAttribute(attrName), mappings)\n                        ||> Seq.fold (fun s (KeyValue(a, m)) ->\n                            RegExp(\"\\\\${\" + a + \"}\", \"ig\").Replace(s, \"${\" + m + \"}\")\n                        )\n                    e.SetAttribute(attrName, s)\n\n        let fillInstanceAttrs (instance: Dom.Element) (fillWith: Dom.Element) =\n            convertAttrs fillWith\n            let name = fillWith.NodeName.ToLower()\n            match instance.QuerySelector(\"[ws-attr=\" + name + \"]\") with\n            | null -> Console.Warn(\"Filling non-existent attr hole\", name)\n            | e ->\n                e.RemoveAttribute(\"ws-attr\")\n                for i = 0 to fillWith.Attributes.Length - 1 do\n                    let a = fillWith.Attributes.[i]\n                    if a.Name = \"class\" && e.HasAttribute(\"class\") then\n                        e.SetAttribute(\"class\", e.GetAttribute(\"class\") + \" \" + a.NodeValue)\n                    else\n                        e.SetAttribute(a.Name, a.NodeValue)\n\n        let removeHolesExcept (instance: Dom.Element) (dontRemove: HashSet<string>) =\n            let run attrName =\n                DomUtility.IterSelector instance (\"[\" + attrName + \"]\") <| fun e ->\n                    if not (dontRemove.Contains(e.GetAttribute attrName)) then\n                        e.RemoveAttribute(attrName)\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector instance \"[ws-hole]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-hole\")) then\n                    e.RemoveAttribute(\"ws-hole\")\n                    while e.HasChildNodes() do\n                        e.RemoveChild(e.LastChild) |> ignore\n            DomUtility.IterSelector instance \"[ws-replace]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-replace\")) then\n                    e.ParentNode.RemoveChild(e) |> ignore\n            DomUtility.IterSelector instance \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.filter (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        dontRemove.Contains a.[1]\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        RegExp(TextHoleRE, \"g\")\n                            .Replace(e.GetAttribute(attrName), FuncWithArgs(fun (full: string, h: string) ->\n                                if dontRemove.Contains h then full else \"\"\n                            ))\n                    e.SetAttribute(attrName, s)\n\n        let fillTextHole (instance: Dom.Element) (fillWith: string) (templateName: string) =\n            match instance.QuerySelector \"[ws-replace]\" with\n            | null ->\n                Console.Warn(\"Filling non-existent text hole\", templateName)\n                None\n            | n ->\n                n.ParentNode.ReplaceChild(Dom.Text fillWith, n) |> ignore\n                Some <| n.GetAttribute(\"ws-replace\")\n\n        let rec fill (fillWith: Dom.Element) (p: Dom.Node) n =\n            if fillWith.HasChildNodes() then\n                fill fillWith p (p.InsertBefore(fillWith.LastChild, n))\n\n        let failNotLoaded (name: string) =\n            Console.Warn(\"Instantiating non-loaded template\", name)\n\n    let rec PrepareTemplateStrict (baseName: string) (name: option<string>) (els: Dom.Node[]) (root: option<Dom.Element>) (prepareLocalTemplate: option<string -> unit>) =\n        let rec fillDocHole (instance: Dom.Element) (fillWith: Dom.Element) =\n            let name = fillWith.NodeName.ToLower()\n            let fillHole (p: Dom.Node) (n: Dom.Node) =\n                // The \"title\" node is treated specially by HTML, its content is considered pure text,\n                // so we need to re-parse it.\n                if name = \"title\" && fillWith.HasChildNodes() then\n                    let parsed = JQuery.JQuery.ParseHTML fillWith.TextContent\n                    fillWith.RemoveChild(fillWith.FirstChild) |> ignore\n                    for i in parsed do\n                        fillWith.AppendChild(i) |> ignore\n                convertElement fillWith\n                Prepare.fill fillWith p n\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    e.SetAttribute(attrName,\n                        RegExp(\"\\\\${\" + name + \"}\", \"ig\").\n                            Replace(e.GetAttribute(attrName), fillWith.TextContent)\n                    )\n            match instance.QuerySelector(\"[ws-hole=\" + name + \"]\") with\n            | null ->\n                match instance.QuerySelector(\"[ws-replace=\" + name + \"]\") with\n                | null -> ()\n                | e ->\n                    fillHole e.ParentNode e\n                    e.ParentNode.RemoveChild(e) |> ignore\n            | e ->\n                while e.HasChildNodes() do\n                    e.RemoveChild(e.LastChild) |> ignore\n                e.RemoveAttribute(\"ws-hole\")\n                fillHole e null\n\n        and convertElement (el: Dom.Element) =\n            if el.NodeName.ToLower().StartsWith \"ws-\" then\n                convertInstantiation el\n            else\n                Prepare.convertAttrs el\n                convertNodeAndSiblings el.FirstChild\n\n        and convertNodeAndSiblings (n: Dom.Node) =\n            if n !==. null then\n                let next = n.NextSibling\n                if n.NodeType = Dom.NodeType.Text then\n                    Prepare.convertTextNode n\n                elif n.NodeType = Dom.NodeType.Element then\n                    convertElement (n :?> Dom.Element)\n                convertNodeAndSiblings next\n\n        and convertInstantiation (el: Dom.Element) =\n            let name = el.NodeName.[3..].ToLower()\n            let instBaseName, instName =\n                match name.IndexOf('.') with\n                | -1 -> baseName, name\n                | n -> name.[..n-1], name.[n+1..]\n            if instBaseName <> \"\" && not (LoadedTemplates.ContainsKey instBaseName) then\n                Prepare.failNotLoaded instName\n            else\n            if instBaseName = \"\" && prepareLocalTemplate.IsSome then\n                prepareLocalTemplate.Value instName\n            let d = LoadedTemplates.[instBaseName]\n            if not (d.ContainsKey instName) then Prepare.failNotLoaded instName else\n            let t = d.[instName]\n            let instance = t.CloneNode(true) :?> Dom.Element\n            let usedHoles = HashSet()\n            let mappings = Dictionary()\n            // 1. gather mapped and filled holes.\n            let attrs = el.Attributes\n            for i = 0 to attrs.Length - 1 do\n                let name = attrs.[i].Name.ToLower()\n                let mappedName = match attrs.[i].NodeValue with \"\" -> name | s -> s.ToLower()\n                mappings.[name] <- mappedName\n                if not (usedHoles.Add(name)) then\n                    Console.Warn(\"Hole mapped twice\", name)\n            for i = 0 to el.ChildNodes.Length - 1 do\n                let n = el.ChildNodes.[i]\n                if n.NodeType = Dom.NodeType.Element then\n                    let n = n :?> Dom.Element\n                    if not (usedHoles.Add(n.NodeName.ToLower())) then\n                        Console.Warn(\"Hole filled twice\", instName)\n            // 2. If single text hole, apply it.\n            let singleTextFill = el.ChildNodes.Length = 1 && el.FirstChild.NodeType = Dom.NodeType.Text\n            if singleTextFill then\n                Prepare.fillTextHole instance el.FirstChild.TextContent instName\n                |> Option.iter (usedHoles.Add >> ignore)\n            // 3. eliminate non-mapped/filled holes.\n            Prepare.removeHolesExcept instance usedHoles\n            // 4. apply mappings/fillings.\n            if not singleTextFill then\n                for i = 0 to el.ChildNodes.Length - 1 do\n                    let n = el.ChildNodes.[i]\n                    if n.NodeType = Dom.NodeType.Element then\n                        let n = n :?> Dom.Element\n                        if n.HasAttributes() then\n                            Prepare.fillInstanceAttrs instance n\n                        else\n                            fillDocHole instance n\n            Prepare.mapHoles instance mappings\n            // 5. insert result.\n            Prepare.fill instance el.ParentNode el\n            el.ParentNode.RemoveChild(el) |> ignore\n\n        let rec convertNestedTemplates (el: Dom.Element) =\n            match el.QuerySelector \"[ws-template]\" with\n            | null ->\n                match el.QuerySelector \"[ws-children-template]\" with\n                | null -> ()\n                | n ->\n                    let name = n.GetAttribute \"ws-children-template\"\n                    n.RemoveAttribute \"ws-children-template\"\n                    PrepareTemplateStrict baseName (Some name) (DomUtility.ChildrenArray n) None None\n                    convertNestedTemplates el\n            | n ->\n                let name = n.GetAttribute \"ws-template\"\n                PrepareSingleTemplate baseName (Some name) n None\n                convertNestedTemplates el\n\n        let fakeroot = root |> Option.defaultWith (fun () -> FakeRoot els)\n        let name = (defaultArg name \"\").ToLower()\n        LoadedTemplateFile(baseName).[name] <- fakeroot\n        if els.Length > 0 then\n            convertNestedTemplates fakeroot\n            convertNodeAndSiblings els.[0]\n\n    and PrepareSingleTemplate (baseName: string) (name: option<string>) (el: Dom.Element) =\n        let root = FakeRootSingle el\n        PrepareTemplateStrict baseName name [| el |] (Some root)\n\n    let PrepareTemplate (baseName: string) (name: option<string>) (els: unit -> Dom.Node[]) =\n        if not (LoadedTemplateFile(baseName).ContainsKey(defaultArg name \"\")) then\n            let els = els()\n            for el in els do\n                match el.ParentNode :?> Dom.Element with\n                | null -> ()\n                | p -> p.RemoveChild(el) |> ignore\n            PrepareTemplateStrict baseName name els None None\n\n    /// Load all the templates declared nested under `root` into `baseName`.\n    let LoadNestedTemplates (root: Dom.Element) baseName =\n        let loadedTpls = LoadedTemplateFile baseName\n        let rawTpls = Dictionary()\n        let wsTemplates = root.QuerySelectorAll \"[ws-template]\"\n        for i = 0 to wsTemplates.Length - 1 do\n            let node = wsTemplates.[i] :?> Dom.Element\n            let name = node.GetAttribute(\"ws-template\").ToLower()\n            node.RemoveAttribute(\"ws-template\")\n            rawTpls.[name] <- ([| node :> Dom.Node |], FakeRootSingle node)\n        let wsChildrenTemplates = root.QuerySelectorAll \"[ws-children-template]\"\n        for i = 0 to wsChildrenTemplates.Length - 1 do\n            let node = wsChildrenTemplates.[i] :?> Dom.Element\n            let name = node.GetAttribute(\"ws-children-template\").ToLower()\n            node.RemoveAttribute(\"ws-children-template\")\n            rawTpls.[name] <-\n                let els = DomUtility.ChildrenArray node\n                (els, FakeRoot els)\n        let instantiated = HashSet()\n        let rec prepareTemplate name =\n            if not (loadedTpls.ContainsKey name) then\n                match rawTpls.TryGetValue(name) with\n                | false, _ ->\n                    Console.Warn(\n                        if instantiated.Contains(name)\n                        then \"Encountered loop when instantiating \" + name\n                        else \"Local template does not exist: \" + name)\n                | true, (els, root) ->\n                    instantiated.Add(name) |> ignore\n                    rawTpls.Remove(name) |> ignore\n                    PrepareTemplateStrict baseName (Some name) els (Some root) (Some prepareTemplate)\n        while rawTpls.Count > 0 do\n            prepareTemplate (Seq.head rawTpls.Keys)\n\n    let LoadLocalTemplates (baseName: string) =\n        if not LocalTemplatesLoaded then\n            LocalTemplatesLoaded <- true\n            LoadNestedTemplates JS.Document.Body \"\"\n        LoadedTemplates.[baseName] <- LoadedTemplateFile(\"\")\n\n    let RunFullDocTemplate (fillWith: seq<TemplateHole>) =\n        LoadLocalTemplates \"\"\n        PrepareTemplateStrict \"\" None (DomUtility.ChildrenArray JS.Document.Body) (Some JS.Document.Body) None\n        ChildrenTemplate JS.Document.Body fillWith\n        |>! Doc'.RunInPlace true JS.Document.Body\n\n    let Template (els: Dom.Node[]) (fillWith: seq<TemplateHole>) =\n        ChildrenTemplate (FakeRoot els) fillWith\n\n    let NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) =\n        match LoadedTemplateFile(baseName).TryGetValue(defaultArg name \"\") with\n        | true, t -> ChildrenTemplate (t.CloneNode(true) :?> Dom.Element) fillWith\n        | false, _ -> Console.Warn(\"Local template doesn't exist\", name); Doc'.Empty\n\n    let GetOrLoadTemplate (baseName: string) (name: option<string>) (els: unit -> Dom.Node[]) (fillWith: seq<TemplateHole>) =\n        LoadLocalTemplates \"\"\n        PrepareTemplate baseName name els\n        NamedTemplate baseName name fillWith\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System\nopen WebSharper.UI.Client\n\n[<JavaScript>]\ntype Flow<'T>(render: Var<Doc> -> ('T -> unit) -> unit) =\n\n    new (define: Func<Func<'T, unit>, Doc>) =\n        Flow(fun var cont -> Var.Set var (define.Invoke (Func<_,_>(cont))))\n\n    member this.Render = render\n\n[<JavaScript>]\n[<Sealed>]\ntype Flow =\n\n    static member Map f (x: Flow<'A>) =\n        Flow(fun var cont -> x.Render var (fun r -> (f r) |> cont))\n\n    // \"Unwrap\" the value from the flowlet, use it as an argument to the\n    // continuation k, and return the value of the applied continuation.\n\n    // Semantically, what we're doing here is running the form (or other\n    // input mechanism, but let's stick with thinking about forms), getting\n    // the result, and then using this as an input to the continuation.\n    static member Bind (m: Flow<'A>) (k: 'A -> Flow<'B>) =\n        Flow(fun var cont -> m.Render var (fun r -> (k r).Render var cont))\n\n    static member Return x =\n        Flow(fun var cont -> cont x)\n\n    static member Embed (fl: Flow<'A>) =\n        let var = Var.Create Doc.Empty\n        fl.Render var ignore\n        Doc.EmbedView var.View\n\n    static member Define (f: ('A -> unit) -> Doc) =\n        Flow(Func<_,_>(fun (x: Func<'A, unit>) -> f x.Invoke))\n\n    static member Static doc =\n        Flow(fun var cont -> Var.Set var doc; cont ())\n\n[<JavaScript>]\n[<Sealed>]\ntype FlowBuilder() =\n    member x.Bind(comp, func) = Flow.Bind comp func\n    member x.Return(value) = Flow.Return value\n    member x.ReturnFrom(inner: Flow<'A>) = inner\n\ntype Flow with\n\n    static member Do =\n        FlowBuilder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n#nowarn \"44\" // HTML deprecated\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// This is an auto-generated module providing HTML5 vocabulary.\n/// Generated using tags.csv from WebSharper;\n/// See tools/UpdateElems.fsx for the code-generation logic.\n// Warning: don't mark this module as JavaScript: some submodules _must_ not\n// be JavaScript because they are proxied.\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Html =\n\n    /// Create a text node with constant content, or with dynamic content using `view.V`.\n    [<JavaScript; Inline; Macro(typeof<Macros.TextView>)>]\n    let text t = Doc.TextNode t\n\n    /// Create a text node with dynamic content.\n    [<JavaScript; Inline>]\n    let textView v = Client.Doc.TextView v\n\n    /// Insert a client-side Doc.\n    [<JavaScript; Inline>]\n    let client ([<ReflectedDefinition; JavaScript>] q) = Doc.ClientSide q\n\n    module Elt =\n\n        // {{ tag normal colliding deprecated [elt]\n        /// Create an HTML element <a> with attributes and children.\n        [<JavaScript; Inline>]\n        let a ats ch = Doc.Element \"a\" ats ch\n        /// Create an HTML element <abbr> with attributes and children.\n        [<JavaScript; Inline>]\n        let abbr ats ch = Doc.Element \"abbr\" ats ch\n        /// Create an HTML element <acronym> with attributes and children.\n        [<JavaScript; Inline>]\n        let acronym ats ch = Doc.Element \"acronym\" ats ch\n        /// Create an HTML element <address> with attributes and children.\n        [<JavaScript; Inline>]\n        let address ats ch = Doc.Element \"address\" ats ch\n        /// Create an HTML element <applet> with attributes and children.\n        [<JavaScript; Inline>]\n        let applet ats ch = Doc.Element \"applet\" ats ch\n        /// Create an HTML element <area> with attributes and children.\n        [<JavaScript; Inline>]\n        let area ats ch = Doc.Element \"area\" ats ch\n        /// Create an HTML element <article> with attributes and children.\n        [<JavaScript; Inline>]\n        let article ats ch = Doc.Element \"article\" ats ch\n        /// Create an HTML element <aside> with attributes and children.\n        [<JavaScript; Inline>]\n        let aside ats ch = Doc.Element \"aside\" ats ch\n        /// Create an HTML element <audio> with attributes and children.\n        [<JavaScript; Inline>]\n        let audio ats ch = Doc.Element \"audio\" ats ch\n        /// Create an HTML element <b> with attributes and children.\n        [<JavaScript; Inline>]\n        let b ats ch = Doc.Element \"b\" ats ch\n        /// Create an HTML element <base> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``base`` ats ch = Doc.Element \"base\" ats ch\n        /// Create an HTML element <basefont> with attributes and children.\n        [<JavaScript; Inline>]\n        let basefont ats ch = Doc.Element \"basefont\" ats ch\n        /// Create an HTML element <bdi> with attributes and children.\n        [<JavaScript; Inline>]\n        let bdi ats ch = Doc.Element \"bdi\" ats ch\n        /// Create an HTML element <bdo> with attributes and children.\n        [<JavaScript; Inline>]\n        let bdo ats ch = Doc.Element \"bdo\" ats ch\n        /// Create an HTML element <big> with attributes and children.\n        [<JavaScript; Inline>]\n        let big ats ch = Doc.Element \"big\" ats ch\n        /// Create an HTML element <blockquote> with attributes and children.\n        [<JavaScript; Inline>]\n        let blockquote ats ch = Doc.Element \"blockquote\" ats ch\n        /// Create an HTML element <body> with attributes and children.\n        [<JavaScript; Inline>]\n        let body ats ch = Doc.Element \"body\" ats ch\n        /// Create an HTML element <br> with attributes and children.\n        [<JavaScript; Inline>]\n        let br ats ch = Doc.Element \"br\" ats ch\n        /// Create an HTML element <button> with attributes and children.\n        [<JavaScript; Inline>]\n        let button ats ch = Doc.Element \"button\" ats ch\n        /// Create an HTML element <canvas> with attributes and children.\n        [<JavaScript; Inline>]\n        let canvas ats ch = Doc.Element \"canvas\" ats ch\n        /// Create an HTML element <caption> with attributes and children.\n        [<JavaScript; Inline>]\n        let caption ats ch = Doc.Element \"caption\" ats ch\n        /// Create an HTML element <center> with attributes and children.\n        [<JavaScript; Inline>]\n        let center ats ch = Doc.Element \"center\" ats ch\n        /// Create an HTML element <cite> with attributes and children.\n        [<JavaScript; Inline>]\n        let cite ats ch = Doc.Element \"cite\" ats ch\n        /// Create an HTML element <code> with attributes and children.\n        [<JavaScript; Inline>]\n        let code ats ch = Doc.Element \"code\" ats ch\n        /// Create an HTML element <col> with attributes and children.\n        [<JavaScript; Inline>]\n        let col ats ch = Doc.Element \"col\" ats ch\n        /// Create an HTML element <colgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let colgroup ats ch = Doc.Element \"colgroup\" ats ch\n        /// Create an HTML element <command> with attributes and children.\n        [<JavaScript; Inline>]\n        let command ats ch = Doc.Element \"command\" ats ch\n        /// Create an HTML element <content> with attributes and children.\n        [<JavaScript; Inline>]\n        let content ats ch = Doc.Element \"content\" ats ch\n        /// Create an HTML element <data> with attributes and children.\n        [<JavaScript; Inline>]\n        let data ats ch = Doc.Element \"data\" ats ch\n        /// Create an HTML element <datalist> with attributes and children.\n        [<JavaScript; Inline>]\n        let datalist ats ch = Doc.Element \"datalist\" ats ch\n        /// Create an HTML element <dd> with attributes and children.\n        [<JavaScript; Inline>]\n        let dd ats ch = Doc.Element \"dd\" ats ch\n        /// Create an HTML element <del> with attributes and children.\n        [<JavaScript; Inline>]\n        let del ats ch = Doc.Element \"del\" ats ch\n        /// Create an HTML element <details> with attributes and children.\n        [<JavaScript; Inline>]\n        let details ats ch = Doc.Element \"details\" ats ch\n        /// Create an HTML element <dfn> with attributes and children.\n        [<JavaScript; Inline>]\n        let dfn ats ch = Doc.Element \"dfn\" ats ch\n        /// Create an HTML element <dir> with attributes and children.\n        [<JavaScript; Inline>]\n        let dir ats ch = Doc.Element \"dir\" ats ch\n        /// Create an HTML element <div> with attributes and children.\n        [<JavaScript; Inline>]\n        let div ats ch = Doc.Element \"div\" ats ch\n        /// Create an HTML element <dl> with attributes and children.\n        [<JavaScript; Inline>]\n        let dl ats ch = Doc.Element \"dl\" ats ch\n        /// Create an HTML element <dt> with attributes and children.\n        [<JavaScript; Inline>]\n        let dt ats ch = Doc.Element \"dt\" ats ch\n        /// Create an HTML element <em> with attributes and children.\n        [<JavaScript; Inline>]\n        let em ats ch = Doc.Element \"em\" ats ch\n        /// Create an HTML element <embed> with attributes and children.\n        [<JavaScript; Inline>]\n        let embed ats ch = Doc.Element \"embed\" ats ch\n        /// Create an HTML element <fieldset> with attributes and children.\n        [<JavaScript; Inline>]\n        let fieldset ats ch = Doc.Element \"fieldset\" ats ch\n        /// Create an HTML element <figcaption> with attributes and children.\n        [<JavaScript; Inline>]\n        let figcaption ats ch = Doc.Element \"figcaption\" ats ch\n        /// Create an HTML element <figure> with attributes and children.\n        [<JavaScript; Inline>]\n        let figure ats ch = Doc.Element \"figure\" ats ch\n        /// Create an HTML element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Doc.Element \"font\" ats ch\n        /// Create an HTML element <footer> with attributes and children.\n        [<JavaScript; Inline>]\n        let footer ats ch = Doc.Element \"footer\" ats ch\n        /// Create an HTML element <form> with attributes and children.\n        [<JavaScript; Inline>]\n        let form ats ch = Doc.Element \"form\" ats ch\n        /// Create an HTML element <frame> with attributes and children.\n        [<JavaScript; Inline>]\n        let frame ats ch = Doc.Element \"frame\" ats ch\n        /// Create an HTML element <frameset> with attributes and children.\n        [<JavaScript; Inline>]\n        let frameset ats ch = Doc.Element \"frameset\" ats ch\n        /// Create an HTML element <h1> with attributes and children.\n        [<JavaScript; Inline>]\n        let h1 ats ch = Doc.Element \"h1\" ats ch\n        /// Create an HTML element <h2> with attributes and children.\n        [<JavaScript; Inline>]\n        let h2 ats ch = Doc.Element \"h2\" ats ch\n        /// Create an HTML element <h3> with attributes and children.\n        [<JavaScript; Inline>]\n        let h3 ats ch = Doc.Element \"h3\" ats ch\n        /// Create an HTML element <h4> with attributes and children.\n        [<JavaScript; Inline>]\n        let h4 ats ch = Doc.Element \"h4\" ats ch\n        /// Create an HTML element <h5> with attributes and children.\n        [<JavaScript; Inline>]\n        let h5 ats ch = Doc.Element \"h5\" ats ch\n        /// Create an HTML element <h6> with attributes and children.\n        [<JavaScript; Inline>]\n        let h6 ats ch = Doc.Element \"h6\" ats ch\n        /// Create an HTML element <head> with attributes and children.\n        [<JavaScript; Inline>]\n        let head ats ch = Doc.Element \"head\" ats ch\n        /// Create an HTML element <header> with attributes and children.\n        [<JavaScript; Inline>]\n        let header ats ch = Doc.Element \"header\" ats ch\n        /// Create an HTML element <hgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let hgroup ats ch = Doc.Element \"hgroup\" ats ch\n        /// Create an HTML element <hr> with attributes and children.\n        [<JavaScript; Inline>]\n        let hr ats ch = Doc.Element \"hr\" ats ch\n        /// Create an HTML element <html> with attributes and children.\n        [<JavaScript; Inline>]\n        let html ats ch = Doc.Element \"html\" ats ch\n        /// Create an HTML element <i> with attributes and children.\n        [<JavaScript; Inline>]\n        let i ats ch = Doc.Element \"i\" ats ch\n        /// Create an HTML element <iframe> with attributes and children.\n        [<JavaScript; Inline>]\n        let iframe ats ch = Doc.Element \"iframe\" ats ch\n        /// Create an HTML element <img> with attributes and children.\n        [<JavaScript; Inline>]\n        let img ats ch = Doc.Element \"img\" ats ch\n        /// Create an HTML element <input> with attributes and children.\n        [<JavaScript; Inline>]\n        let input ats ch = Doc.Element \"input\" ats ch\n        /// Create an HTML element <ins> with attributes and children.\n        [<JavaScript; Inline>]\n        let ins ats ch = Doc.Element \"ins\" ats ch\n        /// Create an HTML element <isindex> with attributes and children.\n        [<JavaScript; Inline>]\n        let isindex ats ch = Doc.Element \"isindex\" ats ch\n        /// Create an HTML element <kbd> with attributes and children.\n        [<JavaScript; Inline>]\n        let kbd ats ch = Doc.Element \"kbd\" ats ch\n        /// Create an HTML element <keygen> with attributes and children.\n        [<JavaScript; Inline>]\n        let keygen ats ch = Doc.Element \"keygen\" ats ch\n        /// Create an HTML element <label> with attributes and children.\n        [<JavaScript; Inline>]\n        let label ats ch = Doc.Element \"label\" ats ch\n        /// Create an HTML element <legend> with attributes and children.\n        [<JavaScript; Inline>]\n        let legend ats ch = Doc.Element \"legend\" ats ch\n        /// Create an HTML element <li> with attributes and children.\n        [<JavaScript; Inline>]\n        let li ats ch = Doc.Element \"li\" ats ch\n        /// Create an HTML element <link> with attributes and children.\n        [<JavaScript; Inline>]\n        let link ats ch = Doc.Element \"link\" ats ch\n        /// Create an HTML element <main> with attributes and children.\n        [<JavaScript; Inline>]\n        let main ats ch = Doc.Element \"main\" ats ch\n        /// Create an HTML element <map> with attributes and children.\n        [<JavaScript; Inline>]\n        let map ats ch = Doc.Element \"map\" ats ch\n        /// Create an HTML element <mark> with attributes and children.\n        [<JavaScript; Inline>]\n        let mark ats ch = Doc.Element \"mark\" ats ch\n        /// Create an HTML element <menu> with attributes and children.\n        [<JavaScript; Inline>]\n        let menu ats ch = Doc.Element \"menu\" ats ch\n        /// Create an HTML element <menuitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let menuitem ats ch = Doc.Element \"menuitem\" ats ch\n        /// Create an HTML element <meta> with attributes and children.\n        [<JavaScript; Inline>]\n        let meta ats ch = Doc.Element \"meta\" ats ch\n        /// Create an HTML element <meter> with attributes and children.\n        [<JavaScript; Inline>]\n        let meter ats ch = Doc.Element \"meter\" ats ch\n        /// Create an HTML element <nav> with attributes and children.\n        [<JavaScript; Inline>]\n        let nav ats ch = Doc.Element \"nav\" ats ch\n        /// Create an HTML element <noframes> with attributes and children.\n        [<JavaScript; Inline>]\n        let noframes ats ch = Doc.Element \"noframes\" ats ch\n        /// Create an HTML element <noscript> with attributes and children.\n        [<JavaScript; Inline>]\n        let noscript ats ch = Doc.Element \"noscript\" ats ch\n        /// Create an HTML element <object> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``object`` ats ch = Doc.Element \"object\" ats ch\n        /// Create an HTML element <ol> with attributes and children.\n        [<JavaScript; Inline>]\n        let ol ats ch = Doc.Element \"ol\" ats ch\n        /// Create an HTML element <optgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let optgroup ats ch = Doc.Element \"optgroup\" ats ch\n        /// Create an HTML element <option> with attributes and children.\n        [<JavaScript; Inline>]\n        let option ats ch = Doc.Element \"option\" ats ch\n        /// Create an HTML element <output> with attributes and children.\n        [<JavaScript; Inline>]\n        let output ats ch = Doc.Element \"output\" ats ch\n        /// Create an HTML element <p> with attributes and children.\n        [<JavaScript; Inline>]\n        let p ats ch = Doc.Element \"p\" ats ch\n        /// Create an HTML element <param> with attributes and children.\n        [<JavaScript; Inline>]\n        let param ats ch = Doc.Element \"param\" ats ch\n        /// Create an HTML element <picture> with attributes and children.\n        [<JavaScript; Inline>]\n        let picture ats ch = Doc.Element \"picture\" ats ch\n        /// Create an HTML element <pre> with attributes and children.\n        [<JavaScript; Inline>]\n        let pre ats ch = Doc.Element \"pre\" ats ch\n        /// Create an HTML element <progress> with attributes and children.\n        [<JavaScript; Inline>]\n        let progress ats ch = Doc.Element \"progress\" ats ch\n        /// Create an HTML element <q> with attributes and children.\n        [<JavaScript; Inline>]\n        let q ats ch = Doc.Element \"q\" ats ch\n        /// Create an HTML element <rp> with attributes and children.\n        [<JavaScript; Inline>]\n        let rp ats ch = Doc.Element \"rp\" ats ch\n        /// Create an HTML element <rt> with attributes and children.\n        [<JavaScript; Inline>]\n        let rt ats ch = Doc.Element \"rt\" ats ch\n        /// Create an HTML element <rtc> with attributes and children.\n        [<JavaScript; Inline>]\n        let rtc ats ch = Doc.Element \"rtc\" ats ch\n        /// Create an HTML element <ruby> with attributes and children.\n        [<JavaScript; Inline>]\n        let ruby ats ch = Doc.Element \"ruby\" ats ch\n        /// Create an HTML element <s> with attributes and children.\n        [<JavaScript; Inline>]\n        let s ats ch = Doc.Element \"s\" ats ch\n        /// Create an HTML element <samp> with attributes and children.\n        [<JavaScript; Inline>]\n        let samp ats ch = Doc.Element \"samp\" ats ch\n        /// Create an HTML element <script> with attributes and children.\n        [<JavaScript; Inline>]\n        let script ats ch = Doc.Element \"script\" ats ch\n        /// Create an HTML element <section> with attributes and children.\n        [<JavaScript; Inline>]\n        let section ats ch = Doc.Element \"section\" ats ch\n        /// Create an HTML element <select> with attributes and children.\n        [<JavaScript; Inline>]\n        let select ats ch = Doc.Element \"select\" ats ch\n        /// Create an HTML element <shadow> with attributes and children.\n        [<JavaScript; Inline>]\n        let shadow ats ch = Doc.Element \"shadow\" ats ch\n        /// Create an HTML element <small> with attributes and children.\n        [<JavaScript; Inline>]\n        let small ats ch = Doc.Element \"small\" ats ch\n        /// Create an HTML element <source> with attributes and children.\n        [<JavaScript; Inline>]\n        let source ats ch = Doc.Element \"source\" ats ch\n        /// Create an HTML element <span> with attributes and children.\n        [<JavaScript; Inline>]\n        let span ats ch = Doc.Element \"span\" ats ch\n        /// Create an HTML element <strike> with attributes and children.\n        [<JavaScript; Inline>]\n        let strike ats ch = Doc.Element \"strike\" ats ch\n        /// Create an HTML element <strong> with attributes and children.\n        [<JavaScript; Inline>]\n        let strong ats ch = Doc.Element \"strong\" ats ch\n        /// Create an HTML element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Doc.Element \"style\" ats ch\n        /// Create an HTML element <sub> with attributes and children.\n        [<JavaScript; Inline>]\n        let sub ats ch = Doc.Element \"sub\" ats ch\n        /// Create an HTML element <summary> with attributes and children.\n        [<JavaScript; Inline>]\n        let summary ats ch = Doc.Element \"summary\" ats ch\n        /// Create an HTML element <sup> with attributes and children.\n        [<JavaScript; Inline>]\n        let sup ats ch = Doc.Element \"sup\" ats ch\n        /// Create an HTML element <table> with attributes and children.\n        [<JavaScript; Inline>]\n        let table ats ch = Doc.Element \"table\" ats ch\n        /// Create an HTML element <tbody> with attributes and children.\n        [<JavaScript; Inline>]\n        let tbody ats ch = Doc.Element \"tbody\" ats ch\n        /// Create an HTML element <td> with attributes and children.\n        [<JavaScript; Inline>]\n        let td ats ch = Doc.Element \"td\" ats ch\n        /// Create an HTML element <template> with attributes and children.\n        [<JavaScript; Inline>]\n        let template ats ch = Doc.Element \"template\" ats ch\n        /// Create an HTML element <textarea> with attributes and children.\n        [<JavaScript; Inline>]\n        let textarea ats ch = Doc.Element \"textarea\" ats ch\n        /// Create an HTML element <tfoot> with attributes and children.\n        [<JavaScript; Inline>]\n        let tfoot ats ch = Doc.Element \"tfoot\" ats ch\n        /// Create an HTML element <th> with attributes and children.\n        [<JavaScript; Inline>]\n        let th ats ch = Doc.Element \"th\" ats ch\n        /// Create an HTML element <thead> with attributes and children.\n        [<JavaScript; Inline>]\n        let thead ats ch = Doc.Element \"thead\" ats ch\n        /// Create an HTML element <time> with attributes and children.\n        [<JavaScript; Inline>]\n        let time ats ch = Doc.Element \"time\" ats ch\n        /// Create an HTML element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Doc.Element \"title\" ats ch\n        /// Create an HTML element <tr> with attributes and children.\n        [<JavaScript; Inline>]\n        let tr ats ch = Doc.Element \"tr\" ats ch\n        /// Create an HTML element <track> with attributes and children.\n        [<JavaScript; Inline>]\n        let track ats ch = Doc.Element \"track\" ats ch\n        /// Create an HTML element <tt> with attributes and children.\n        [<JavaScript; Inline>]\n        let tt ats ch = Doc.Element \"tt\" ats ch\n        /// Create an HTML element <u> with attributes and children.\n        [<JavaScript; Inline>]\n        let u ats ch = Doc.Element \"u\" ats ch\n        /// Create an HTML element <ul> with attributes and children.\n        [<JavaScript; Inline>]\n        let ul ats ch = Doc.Element \"ul\" ats ch\n        /// Create an HTML element <var> with attributes and children.\n        [<JavaScript; Inline>]\n        let var ats ch = Doc.Element \"var\" ats ch\n        /// Create an HTML element <video> with attributes and children.\n        [<JavaScript; Inline>]\n        let video ats ch = Doc.Element \"video\" ats ch\n        /// Create an HTML element <wbr> with attributes and children.\n        [<JavaScript; Inline>]\n        let wbr ats ch = Doc.Element \"wbr\" ats ch\n        // }}\n\n    // {{ tag normal [doc]\n    /// Create an HTML element <a> with attributes and children.\n    [<JavaScript; Inline>]\n    let a ats ch = Elt.a ats ch :> Doc\n    /// Create an HTML element <abbr> with attributes and children.\n    [<JavaScript; Inline>]\n    let abbr ats ch = Elt.abbr ats ch :> Doc\n    /// Create an HTML element <address> with attributes and children.\n    [<JavaScript; Inline>]\n    let address ats ch = Elt.address ats ch :> Doc\n    /// Create an HTML element <area> with attributes and children.\n    [<JavaScript; Inline>]\n    let area ats ch = Elt.area ats ch :> Doc\n    /// Create an HTML element <article> with attributes and children.\n    [<JavaScript; Inline>]\n    let article ats ch = Elt.article ats ch :> Doc\n    /// Create an HTML element <aside> with attributes and children.\n    [<JavaScript; Inline>]\n    let aside ats ch = Elt.aside ats ch :> Doc\n    /// Create an HTML element <audio> with attributes and children.\n    [<JavaScript; Inline>]\n    let audio ats ch = Elt.audio ats ch :> Doc\n    /// Create an HTML element <b> with attributes and children.\n    [<JavaScript; Inline>]\n    let b ats ch = Elt.b ats ch :> Doc\n    /// Create an HTML element <base> with attributes and children.\n    [<JavaScript; Inline>]\n    let ``base`` ats ch = Elt.``base`` ats ch :> Doc\n    /// Create an HTML element <bdi> with attributes and children.\n    [<JavaScript; Inline>]\n    let bdi ats ch = Elt.bdi ats ch :> Doc\n    /// Create an HTML element <bdo> with attributes and children.\n    [<JavaScript; Inline>]\n    let bdo ats ch = Elt.bdo ats ch :> Doc\n    /// Create an HTML element <blockquote> with attributes and children.\n    [<JavaScript; Inline>]\n    let blockquote ats ch = Elt.blockquote ats ch :> Doc\n    /// Create an HTML element <body> with attributes and children.\n    [<JavaScript; Inline>]\n    let body ats ch = Elt.body ats ch :> Doc\n    /// Create an HTML element <br> with attributes and children.\n    [<JavaScript; Inline>]\n    let br ats ch = Elt.br ats ch :> Doc\n    /// Create an HTML element <button> with attributes and children.\n    [<JavaScript; Inline>]\n    let button ats ch = Elt.button ats ch :> Doc\n    /// Create an HTML element <canvas> with attributes and children.\n    [<JavaScript; Inline>]\n    let canvas ats ch = Elt.canvas ats ch :> Doc\n    /// Create an HTML element <caption> with attributes and children.\n    [<JavaScript; Inline>]\n    let caption ats ch = Elt.caption ats ch :> Doc\n    /// Create an HTML element <cite> with attributes and children.\n    [<JavaScript; Inline>]\n    let cite ats ch = Elt.cite ats ch :> Doc\n    /// Create an HTML element <code> with attributes and children.\n    [<JavaScript; Inline>]\n    let code ats ch = Elt.code ats ch :> Doc\n    /// Create an HTML element <col> with attributes and children.\n    [<JavaScript; Inline>]\n    let col ats ch = Elt.col ats ch :> Doc\n    /// Create an HTML element <colgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let colgroup ats ch = Elt.colgroup ats ch :> Doc\n    /// Create an HTML element <command> with attributes and children.\n    [<JavaScript; Inline>]\n    let command ats ch = Elt.command ats ch :> Doc\n    /// Create an HTML element <datalist> with attributes and children.\n    [<JavaScript; Inline>]\n    let datalist ats ch = Elt.datalist ats ch :> Doc\n    /// Create an HTML element <dd> with attributes and children.\n    [<JavaScript; Inline>]\n    let dd ats ch = Elt.dd ats ch :> Doc\n    /// Create an HTML element <del> with attributes and children.\n    [<JavaScript; Inline>]\n    let del ats ch = Elt.del ats ch :> Doc\n    /// Create an HTML element <details> with attributes and children.\n    [<JavaScript; Inline>]\n    let details ats ch = Elt.details ats ch :> Doc\n    /// Create an HTML element <dfn> with attributes and children.\n    [<JavaScript; Inline>]\n    let dfn ats ch = Elt.dfn ats ch :> Doc\n    /// Create an HTML element <div> with attributes and children.\n    [<JavaScript; Inline>]\n    let div ats ch = Elt.div ats ch :> Doc\n    /// Create an HTML element <dl> with attributes and children.\n    [<JavaScript; Inline>]\n    let dl ats ch = Elt.dl ats ch :> Doc\n    /// Create an HTML element <dt> with attributes and children.\n    [<JavaScript; Inline>]\n    let dt ats ch = Elt.dt ats ch :> Doc\n    /// Create an HTML element <em> with attributes and children.\n    [<JavaScript; Inline>]\n    let em ats ch = Elt.em ats ch :> Doc\n    /// Create an HTML element <embed> with attributes and children.\n    [<JavaScript; Inline>]\n    let embed ats ch = Elt.embed ats ch :> Doc\n    /// Create an HTML element <fieldset> with attributes and children.\n    [<JavaScript; Inline>]\n    let fieldset ats ch = Elt.fieldset ats ch :> Doc\n    /// Create an HTML element <figcaption> with attributes and children.\n    [<JavaScript; Inline>]\n    let figcaption ats ch = Elt.figcaption ats ch :> Doc\n    /// Create an HTML element <figure> with attributes and children.\n    [<JavaScript; Inline>]\n    let figure ats ch = Elt.figure ats ch :> Doc\n    /// Create an HTML element <footer> with attributes and children.\n    [<JavaScript; Inline>]\n    let footer ats ch = Elt.footer ats ch :> Doc\n    /// Create an HTML element <form> with attributes and children.\n    [<JavaScript; Inline>]\n    let form ats ch = Elt.form ats ch :> Doc\n    /// Create an HTML element <h1> with attributes and children.\n    [<JavaScript; Inline>]\n    let h1 ats ch = Elt.h1 ats ch :> Doc\n    /// Create an HTML element <h2> with attributes and children.\n    [<JavaScript; Inline>]\n    let h2 ats ch = Elt.h2 ats ch :> Doc\n    /// Create an HTML element <h3> with attributes and children.\n    [<JavaScript; Inline>]\n    let h3 ats ch = Elt.h3 ats ch :> Doc\n    /// Create an HTML element <h4> with attributes and children.\n    [<JavaScript; Inline>]\n    let h4 ats ch = Elt.h4 ats ch :> Doc\n    /// Create an HTML element <h5> with attributes and children.\n    [<JavaScript; Inline>]\n    let h5 ats ch = Elt.h5 ats ch :> Doc\n    /// Create an HTML element <h6> with attributes and children.\n    [<JavaScript; Inline>]\n    let h6 ats ch = Elt.h6 ats ch :> Doc\n    /// Create an HTML element <head> with attributes and children.\n    [<JavaScript; Inline>]\n    let head ats ch = Elt.head ats ch :> Doc\n    /// Create an HTML element <header> with attributes and children.\n    [<JavaScript; Inline>]\n    let header ats ch = Elt.header ats ch :> Doc\n    /// Create an HTML element <hgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let hgroup ats ch = Elt.hgroup ats ch :> Doc\n    /// Create an HTML element <hr> with attributes and children.\n    [<JavaScript; Inline>]\n    let hr ats ch = Elt.hr ats ch :> Doc\n    /// Create an HTML element <html> with attributes and children.\n    [<JavaScript; Inline>]\n    let html ats ch = Elt.html ats ch :> Doc\n    /// Create an HTML element <i> with attributes and children.\n    [<JavaScript; Inline>]\n    let i ats ch = Elt.i ats ch :> Doc\n    /// Create an HTML element <iframe> with attributes and children.\n    [<JavaScript; Inline>]\n    let iframe ats ch = Elt.iframe ats ch :> Doc\n    /// Create an HTML element <img> with attributes and children.\n    [<JavaScript; Inline>]\n    let img ats ch = Elt.img ats ch :> Doc\n    /// Create an HTML element <input> with attributes and children.\n    [<JavaScript; Inline>]\n    let input ats ch = Elt.input ats ch :> Doc\n    /// Create an HTML element <ins> with attributes and children.\n    [<JavaScript; Inline>]\n    let ins ats ch = Elt.ins ats ch :> Doc\n    /// Create an HTML element <kbd> with attributes and children.\n    [<JavaScript; Inline>]\n    let kbd ats ch = Elt.kbd ats ch :> Doc\n    /// Create an HTML element <keygen> with attributes and children.\n    [<JavaScript; Inline>]\n    let keygen ats ch = Elt.keygen ats ch :> Doc\n    /// Create an HTML element <label> with attributes and children.\n    [<JavaScript; Inline>]\n    let label ats ch = Elt.label ats ch :> Doc\n    /// Create an HTML element <legend> with attributes and children.\n    [<JavaScript; Inline>]\n    let legend ats ch = Elt.legend ats ch :> Doc\n    /// Create an HTML element <li> with attributes and children.\n    [<JavaScript; Inline>]\n    let li ats ch = Elt.li ats ch :> Doc\n    /// Create an HTML element <link> with attributes and children.\n    [<JavaScript; Inline>]\n    let link ats ch = Elt.link ats ch :> Doc\n    /// Create an HTML element <mark> with attributes and children.\n    [<JavaScript; Inline>]\n    let mark ats ch = Elt.mark ats ch :> Doc\n    /// Create an HTML element <meta> with attributes and children.\n    [<JavaScript; Inline>]\n    let meta ats ch = Elt.meta ats ch :> Doc\n    /// Create an HTML element <meter> with attributes and children.\n    [<JavaScript; Inline>]\n    let meter ats ch = Elt.meter ats ch :> Doc\n    /// Create an HTML element <nav> with attributes and children.\n    [<JavaScript; Inline>]\n    let nav ats ch = Elt.nav ats ch :> Doc\n    /// Create an HTML element <noframes> with attributes and children.\n    [<JavaScript; Inline>]\n    let noframes ats ch = Elt.noframes ats ch :> Doc\n    /// Create an HTML element <noscript> with attributes and children.\n    [<JavaScript; Inline>]\n    let noscript ats ch = Elt.noscript ats ch :> Doc\n    /// Create an HTML element <ol> with attributes and children.\n    [<JavaScript; Inline>]\n    let ol ats ch = Elt.ol ats ch :> Doc\n    /// Create an HTML element <optgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let optgroup ats ch = Elt.optgroup ats ch :> Doc\n    /// Create an HTML element <output> with attributes and children.\n    [<JavaScript; Inline>]\n    let output ats ch = Elt.output ats ch :> Doc\n    /// Create an HTML element <p> with attributes and children.\n    [<JavaScript; Inline>]\n    let p ats ch = Elt.p ats ch :> Doc\n    /// Create an HTML element <param> with attributes and children.\n    [<JavaScript; Inline>]\n    let param ats ch = Elt.param ats ch :> Doc\n    /// Create an HTML element <picture> with attributes and children.\n    [<JavaScript; Inline>]\n    let picture ats ch = Elt.picture ats ch :> Doc\n    /// Create an HTML element <pre> with attributes and children.\n    [<JavaScript; Inline>]\n    let pre ats ch = Elt.pre ats ch :> Doc\n    /// Create an HTML element <progress> with attributes and children.\n    [<JavaScript; Inline>]\n    let progress ats ch = Elt.progress ats ch :> Doc\n    /// Create an HTML element <q> with attributes and children.\n    [<JavaScript; Inline>]\n    let q ats ch = Elt.q ats ch :> Doc\n    /// Create an HTML element <rp> with attributes and children.\n    [<JavaScript; Inline>]\n    let rp ats ch = Elt.rp ats ch :> Doc\n    /// Create an HTML element <rt> with attributes and children.\n    [<JavaScript; Inline>]\n    let rt ats ch = Elt.rt ats ch :> Doc\n    /// Create an HTML element <rtc> with attributes and children.\n    [<JavaScript; Inline>]\n    let rtc ats ch = Elt.rtc ats ch :> Doc\n    /// Create an HTML element <ruby> with attributes and children.\n    [<JavaScript; Inline>]\n    let ruby ats ch = Elt.ruby ats ch :> Doc\n    /// Create an HTML element <samp> with attributes and children.\n    [<JavaScript; Inline>]\n    let samp ats ch = Elt.samp ats ch :> Doc\n    /// Create an HTML element <script> with attributes and children.\n    [<JavaScript; Inline>]\n    let script ats ch = Elt.script ats ch :> Doc\n    /// Create an HTML element <section> with attributes and children.\n    [<JavaScript; Inline>]\n    let section ats ch = Elt.section ats ch :> Doc\n    /// Create an HTML element <select> with attributes and children.\n    [<JavaScript; Inline>]\n    let select ats ch = Elt.select ats ch :> Doc\n    /// Create an HTML element <shadow> with attributes and children.\n    [<JavaScript; Inline>]\n    let shadow ats ch = Elt.shadow ats ch :> Doc\n    /// Create an HTML element <small> with attributes and children.\n    [<JavaScript; Inline>]\n    let small ats ch = Elt.small ats ch :> Doc\n    /// Create an HTML element <source> with attributes and children.\n    [<JavaScript; Inline>]\n    let source ats ch = Elt.source ats ch :> Doc\n    /// Create an HTML element <span> with attributes and children.\n    [<JavaScript; Inline>]\n    let span ats ch = Elt.span ats ch :> Doc\n    /// Create an HTML element <strong> with attributes and children.\n    [<JavaScript; Inline>]\n    let strong ats ch = Elt.strong ats ch :> Doc\n    /// Create an HTML element <sub> with attributes and children.\n    [<JavaScript; Inline>]\n    let sub ats ch = Elt.sub ats ch :> Doc\n    /// Create an HTML element <summary> with attributes and children.\n    [<JavaScript; Inline>]\n    let summary ats ch = Elt.summary ats ch :> Doc\n    /// Create an HTML element <sup> with attributes and children.\n    [<JavaScript; Inline>]\n    let sup ats ch = Elt.sup ats ch :> Doc\n    /// Create an HTML element <table> with attributes and children.\n    [<JavaScript; Inline>]\n    let table ats ch = Elt.table ats ch :> Doc\n    /// Create an HTML element <tbody> with attributes and children.\n    [<JavaScript; Inline>]\n    let tbody ats ch = Elt.tbody ats ch :> Doc\n    /// Create an HTML element <td> with attributes and children.\n    [<JavaScript; Inline>]\n    let td ats ch = Elt.td ats ch :> Doc\n    /// Create an HTML element <textarea> with attributes and children.\n    [<JavaScript; Inline>]\n    let textarea ats ch = Elt.textarea ats ch :> Doc\n    /// Create an HTML element <tfoot> with attributes and children.\n    [<JavaScript; Inline>]\n    let tfoot ats ch = Elt.tfoot ats ch :> Doc\n    /// Create an HTML element <th> with attributes and children.\n    [<JavaScript; Inline>]\n    let th ats ch = Elt.th ats ch :> Doc\n    /// Create an HTML element <thead> with attributes and children.\n    [<JavaScript; Inline>]\n    let thead ats ch = Elt.thead ats ch :> Doc\n    /// Create an HTML element <time> with attributes and children.\n    [<JavaScript; Inline>]\n    let time ats ch = Elt.time ats ch :> Doc\n    /// Create an HTML element <tr> with attributes and children.\n    [<JavaScript; Inline>]\n    let tr ats ch = Elt.tr ats ch :> Doc\n    /// Create an HTML element <track> with attributes and children.\n    [<JavaScript; Inline>]\n    let track ats ch = Elt.track ats ch :> Doc\n    /// Create an HTML element <ul> with attributes and children.\n    [<JavaScript; Inline>]\n    let ul ats ch = Elt.ul ats ch :> Doc\n    /// Create an HTML element <video> with attributes and children.\n    [<JavaScript; Inline>]\n    let video ats ch = Elt.video ats ch :> Doc\n    /// Create an HTML element <wbr> with attributes and children.\n    [<JavaScript; Inline>]\n    let wbr ats ch = Elt.wbr ats ch :> Doc\n    // }}\n\n    /// HTML5 element functions.\n    module Tags =\n\n        // {{ tag colliding deprecated [doc]\n        /// Create an HTML element <acronym> with attributes and children.\n        [<JavaScript; Inline>]\n        let acronym ats ch = Elt.acronym ats ch :> Doc\n        /// Create an HTML element <applet> with attributes and children.\n        [<JavaScript; Inline>]\n        let applet ats ch = Elt.applet ats ch :> Doc\n        /// Create an HTML element <basefont> with attributes and children.\n        [<JavaScript; Inline>]\n        let basefont ats ch = Elt.basefont ats ch :> Doc\n        /// Create an HTML element <big> with attributes and children.\n        [<JavaScript; Inline>]\n        let big ats ch = Elt.big ats ch :> Doc\n        /// Create an HTML element <center> with attributes and children.\n        [<JavaScript; Inline>]\n        let center ats ch = Elt.center ats ch :> Doc\n        /// Create an HTML element <content> with attributes and children.\n        [<JavaScript; Inline>]\n        let content ats ch = Elt.content ats ch :> Doc\n        /// Create an HTML element <data> with attributes and children.\n        [<JavaScript; Inline>]\n        let data ats ch = Elt.data ats ch :> Doc\n        /// Create an HTML element <dir> with attributes and children.\n        [<JavaScript; Inline>]\n        let dir ats ch = Elt.dir ats ch :> Doc\n        /// Create an HTML element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Elt.font ats ch :> Doc\n        /// Create an HTML element <frame> with attributes and children.\n        [<JavaScript; Inline>]\n        let frame ats ch = Elt.frame ats ch :> Doc\n        /// Create an HTML element <frameset> with attributes and children.\n        [<JavaScript; Inline>]\n        let frameset ats ch = Elt.frameset ats ch :> Doc\n        /// Create an HTML element <isindex> with attributes and children.\n        [<JavaScript; Inline>]\n        let isindex ats ch = Elt.isindex ats ch :> Doc\n        /// Create an HTML element <main> with attributes and children.\n        [<JavaScript; Inline>]\n        let main ats ch = Elt.main ats ch :> Doc\n        /// Create an HTML element <map> with attributes and children.\n        [<JavaScript; Inline>]\n        let map ats ch = Elt.map ats ch :> Doc\n        /// Create an HTML element <menu> with attributes and children.\n        [<JavaScript; Inline>]\n        let menu ats ch = Elt.menu ats ch :> Doc\n        /// Create an HTML element <menuitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let menuitem ats ch = Elt.menuitem ats ch :> Doc\n        /// Create an HTML element <object> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``object`` ats ch = Elt.``object`` ats ch :> Doc\n        /// Create an HTML element <option> with attributes and children.\n        [<JavaScript; Inline>]\n        let option ats ch = Elt.option ats ch :> Doc\n        /// Create an HTML element <s> with attributes and children.\n        [<JavaScript; Inline>]\n        let s ats ch = Elt.s ats ch :> Doc\n        /// Create an HTML element <strike> with attributes and children.\n        [<JavaScript; Inline>]\n        let strike ats ch = Elt.strike ats ch :> Doc\n        /// Create an HTML element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Elt.style ats ch :> Doc\n        /// Create an HTML element <template> with attributes and children.\n        [<JavaScript; Inline>]\n        let template ats ch = Elt.template ats ch :> Doc\n        /// Create an HTML element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Elt.title ats ch :> Doc\n        /// Create an HTML element <tt> with attributes and children.\n        [<JavaScript; Inline>]\n        let tt ats ch = Elt.tt ats ch :> Doc\n        /// Create an HTML element <u> with attributes and children.\n        [<JavaScript; Inline>]\n        let u ats ch = Elt.u ats ch :> Doc\n        /// Create an HTML element <var> with attributes and children.\n        [<JavaScript; Inline>]\n        let var ats ch = Elt.var ats ch :> Doc\n        // }}\n\n    /// SVG elements.\n    module SvgElements =\n\n        module Elt =\n\n            // {{ svgtag normal [elt]\n            /// Create an SVG element <a> with attributes and children.\n            [<JavaScript; Inline>]\n            let a ats ch = Doc.SvgElement \"a\" ats ch\n            /// Create an SVG element <altglyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyph ats ch = Doc.SvgElement \"altglyph\" ats ch\n            /// Create an SVG element <altglyphdef> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyphdef ats ch = Doc.SvgElement \"altglyphdef\" ats ch\n            /// Create an SVG element <altglyphitem> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyphitem ats ch = Doc.SvgElement \"altglyphitem\" ats ch\n            /// Create an SVG element <animate> with attributes and children.\n            [<JavaScript; Inline>]\n            let animate ats ch = Doc.SvgElement \"animate\" ats ch\n            /// Create an SVG element <animatecolor> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatecolor ats ch = Doc.SvgElement \"animatecolor\" ats ch\n            /// Create an SVG element <animatemotion> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatemotion ats ch = Doc.SvgElement \"animatemotion\" ats ch\n            /// Create an SVG element <animatetransform> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatetransform ats ch = Doc.SvgElement \"animatetransform\" ats ch\n            /// Create an SVG element <circle> with attributes and children.\n            [<JavaScript; Inline>]\n            let circle ats ch = Doc.SvgElement \"circle\" ats ch\n            /// Create an SVG element <clippath> with attributes and children.\n            [<JavaScript; Inline>]\n            let clippath ats ch = Doc.SvgElement \"clippath\" ats ch\n            /// Create an SVG element <color-profile> with attributes and children.\n            [<JavaScript; Inline>]\n            let colorProfile ats ch = Doc.SvgElement \"color-profile\" ats ch\n            /// Create an SVG element <cursor> with attributes and children.\n            [<JavaScript; Inline>]\n            let cursor ats ch = Doc.SvgElement \"cursor\" ats ch\n            /// Create an SVG element <defs> with attributes and children.\n            [<JavaScript; Inline>]\n            let defs ats ch = Doc.SvgElement \"defs\" ats ch\n            /// Create an SVG element <desc> with attributes and children.\n            [<JavaScript; Inline>]\n            let desc ats ch = Doc.SvgElement \"desc\" ats ch\n            /// Create an SVG element <ellipse> with attributes and children.\n            [<JavaScript; Inline>]\n            let ellipse ats ch = Doc.SvgElement \"ellipse\" ats ch\n            /// Create an SVG element <feblend> with attributes and children.\n            [<JavaScript; Inline>]\n            let feblend ats ch = Doc.SvgElement \"feblend\" ats ch\n            /// Create an SVG element <fecolormatrix> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecolormatrix ats ch = Doc.SvgElement \"fecolormatrix\" ats ch\n            /// Create an SVG element <fecomponenttransfer> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecomponenttransfer ats ch = Doc.SvgElement \"fecomponenttransfer\" ats ch\n            /// Create an SVG element <fecomposite> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecomposite ats ch = Doc.SvgElement \"fecomposite\" ats ch\n            /// Create an SVG element <feconvolvematrix> with attributes and children.\n            [<JavaScript; Inline>]\n            let feconvolvematrix ats ch = Doc.SvgElement \"feconvolvematrix\" ats ch\n            /// Create an SVG element <fediffuselighting> with attributes and children.\n            [<JavaScript; Inline>]\n            let fediffuselighting ats ch = Doc.SvgElement \"fediffuselighting\" ats ch\n            /// Create an SVG element <fedisplacementmap> with attributes and children.\n            [<JavaScript; Inline>]\n            let fedisplacementmap ats ch = Doc.SvgElement \"fedisplacementmap\" ats ch\n            /// Create an SVG element <fedistantlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fedistantlight ats ch = Doc.SvgElement \"fedistantlight\" ats ch\n            /// Create an SVG element <feflood> with attributes and children.\n            [<JavaScript; Inline>]\n            let feflood ats ch = Doc.SvgElement \"feflood\" ats ch\n            /// Create an SVG element <fefunca> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefunca ats ch = Doc.SvgElement \"fefunca\" ats ch\n            /// Create an SVG element <fefuncb> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncb ats ch = Doc.SvgElement \"fefuncb\" ats ch\n            /// Create an SVG element <fefuncg> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncg ats ch = Doc.SvgElement \"fefuncg\" ats ch\n            /// Create an SVG element <fefuncr> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncr ats ch = Doc.SvgElement \"fefuncr\" ats ch\n            /// Create an SVG element <fegaussianblur> with attributes and children.\n            [<JavaScript; Inline>]\n            let fegaussianblur ats ch = Doc.SvgElement \"fegaussianblur\" ats ch\n            /// Create an SVG element <feimage> with attributes and children.\n            [<JavaScript; Inline>]\n            let feimage ats ch = Doc.SvgElement \"feimage\" ats ch\n            /// Create an SVG element <femerge> with attributes and children.\n            [<JavaScript; Inline>]\n            let femerge ats ch = Doc.SvgElement \"femerge\" ats ch\n            /// Create an SVG element <femergenode> with attributes and children.\n            [<JavaScript; Inline>]\n            let femergenode ats ch = Doc.SvgElement \"femergenode\" ats ch\n            /// Create an SVG element <femorphology> with attributes and children.\n            [<JavaScript; Inline>]\n            let femorphology ats ch = Doc.SvgElement \"femorphology\" ats ch\n            /// Create an SVG element <feoffset> with attributes and children.\n            [<JavaScript; Inline>]\n            let feoffset ats ch = Doc.SvgElement \"feoffset\" ats ch\n            /// Create an SVG element <fepointlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fepointlight ats ch = Doc.SvgElement \"fepointlight\" ats ch\n            /// Create an SVG element <fespecularlighting> with attributes and children.\n            [<JavaScript; Inline>]\n            let fespecularlighting ats ch = Doc.SvgElement \"fespecularlighting\" ats ch\n            /// Create an SVG element <fespotlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fespotlight ats ch = Doc.SvgElement \"fespotlight\" ats ch\n            /// Create an SVG element <fetile> with attributes and children.\n            [<JavaScript; Inline>]\n            let fetile ats ch = Doc.SvgElement \"fetile\" ats ch\n            /// Create an SVG element <feturbulence> with attributes and children.\n            [<JavaScript; Inline>]\n            let feturbulence ats ch = Doc.SvgElement \"feturbulence\" ats ch\n            /// Create an SVG element <filter> with attributes and children.\n            [<JavaScript; Inline>]\n            let filter ats ch = Doc.SvgElement \"filter\" ats ch\n            /// Create an SVG element <font> with attributes and children.\n            [<JavaScript; Inline>]\n            let font ats ch = Doc.SvgElement \"font\" ats ch\n            /// Create an SVG element <font-face> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFace ats ch = Doc.SvgElement \"font-face\" ats ch\n            /// Create an SVG element <font-face-format> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceFormat ats ch = Doc.SvgElement \"font-face-format\" ats ch\n            /// Create an SVG element <font-face-name> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceName ats ch = Doc.SvgElement \"font-face-name\" ats ch\n            /// Create an SVG element <font-face-src> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceSrc ats ch = Doc.SvgElement \"font-face-src\" ats ch\n            /// Create an SVG element <font-face-uri> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceUri ats ch = Doc.SvgElement \"font-face-uri\" ats ch\n            /// Create an SVG element <foreignobject> with attributes and children.\n            [<JavaScript; Inline>]\n            let foreignobject ats ch = Doc.SvgElement \"foreignobject\" ats ch\n            /// Create an SVG element <g> with attributes and children.\n            [<JavaScript; Inline>]\n            let g ats ch = Doc.SvgElement \"g\" ats ch\n            /// Create an SVG element <glyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let glyph ats ch = Doc.SvgElement \"glyph\" ats ch\n            /// Create an SVG element <glyphref> with attributes and children.\n            [<JavaScript; Inline>]\n            let glyphref ats ch = Doc.SvgElement \"glyphref\" ats ch\n            /// Create an SVG element <hkern> with attributes and children.\n            [<JavaScript; Inline>]\n            let hkern ats ch = Doc.SvgElement \"hkern\" ats ch\n            /// Create an SVG element <image> with attributes and children.\n            [<JavaScript; Inline>]\n            let image ats ch = Doc.SvgElement \"image\" ats ch\n            /// Create an SVG element <line> with attributes and children.\n            [<JavaScript; Inline>]\n            let line ats ch = Doc.SvgElement \"line\" ats ch\n            /// Create an SVG element <lineargradient> with attributes and children.\n            [<JavaScript; Inline>]\n            let lineargradient ats ch = Doc.SvgElement \"lineargradient\" ats ch\n            /// Create an SVG element <marker> with attributes and children.\n            [<JavaScript; Inline>]\n            let marker ats ch = Doc.SvgElement \"marker\" ats ch\n            /// Create an SVG element <mask> with attributes and children.\n            [<JavaScript; Inline>]\n            let mask ats ch = Doc.SvgElement \"mask\" ats ch\n            /// Create an SVG element <metadata> with attributes and children.\n            [<JavaScript; Inline>]\n            let metadata ats ch = Doc.SvgElement \"metadata\" ats ch\n            /// Create an SVG element <missing-glyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let missingGlyph ats ch = Doc.SvgElement \"missing-glyph\" ats ch\n            /// Create an SVG element <mpath> with attributes and children.\n            [<JavaScript; Inline>]\n            let mpath ats ch = Doc.SvgElement \"mpath\" ats ch\n            /// Create an SVG element <path> with attributes and children.\n            [<JavaScript; Inline>]\n            let path ats ch = Doc.SvgElement \"path\" ats ch\n            /// Create an SVG element <pattern> with attributes and children.\n            [<JavaScript; Inline>]\n            let pattern ats ch = Doc.SvgElement \"pattern\" ats ch\n            /// Create an SVG element <polygon> with attributes and children.\n            [<JavaScript; Inline>]\n            let polygon ats ch = Doc.SvgElement \"polygon\" ats ch\n            /// Create an SVG element <polyline> with attributes and children.\n            [<JavaScript; Inline>]\n            let polyline ats ch = Doc.SvgElement \"polyline\" ats ch\n            /// Create an SVG element <radialgradient> with attributes and children.\n            [<JavaScript; Inline>]\n            let radialgradient ats ch = Doc.SvgElement \"radialgradient\" ats ch\n            /// Create an SVG element <rect> with attributes and children.\n            [<JavaScript; Inline>]\n            let rect ats ch = Doc.SvgElement \"rect\" ats ch\n            /// Create an SVG element <script> with attributes and children.\n            [<JavaScript; Inline>]\n            let script ats ch = Doc.SvgElement \"script\" ats ch\n            /// Create an SVG element <set> with attributes and children.\n            [<JavaScript; Inline>]\n            let set ats ch = Doc.SvgElement \"set\" ats ch\n            /// Create an SVG element <stop> with attributes and children.\n            [<JavaScript; Inline>]\n            let stop ats ch = Doc.SvgElement \"stop\" ats ch\n            /// Create an SVG element <style> with attributes and children.\n            [<JavaScript; Inline>]\n            let style ats ch = Doc.SvgElement \"style\" ats ch\n            /// Create an SVG element <svg> with attributes and children.\n            [<JavaScript; Inline>]\n            let svg ats ch = Doc.SvgElement \"svg\" ats ch\n            /// Create an SVG element <switch> with attributes and children.\n            [<JavaScript; Inline>]\n            let switch ats ch = Doc.SvgElement \"switch\" ats ch\n            /// Create an SVG element <symbol> with attributes and children.\n            [<JavaScript; Inline>]\n            let symbol ats ch = Doc.SvgElement \"symbol\" ats ch\n            /// Create an SVG element <text> with attributes and children.\n            [<JavaScript; Inline>]\n            let text ats ch = Doc.SvgElement \"text\" ats ch\n            /// Create an SVG element <textpath> with attributes and children.\n            [<JavaScript; Inline>]\n            let textpath ats ch = Doc.SvgElement \"textpath\" ats ch\n            /// Create an SVG element <title> with attributes and children.\n            [<JavaScript; Inline>]\n            let title ats ch = Doc.SvgElement \"title\" ats ch\n            /// Create an SVG element <tref> with attributes and children.\n            [<JavaScript; Inline>]\n            let tref ats ch = Doc.SvgElement \"tref\" ats ch\n            /// Create an SVG element <tspan> with attributes and children.\n            [<JavaScript; Inline>]\n            let tspan ats ch = Doc.SvgElement \"tspan\" ats ch\n            /// Create an SVG element <use> with attributes and children.\n            [<JavaScript; Inline>]\n            let ``use`` ats ch = Doc.SvgElement \"use\" ats ch\n            /// Create an SVG element <view> with attributes and children.\n            [<JavaScript; Inline>]\n            let view ats ch = Doc.SvgElement \"view\" ats ch\n            /// Create an SVG element <vkern> with attributes and children.\n            [<JavaScript; Inline>]\n            let vkern ats ch = Doc.SvgElement \"vkern\" ats ch\n            // }}\n\n        // {{ svgtag normal [doc]\n        /// Create an SVG element <a> with attributes and children.\n        [<JavaScript; Inline>]\n        let a ats ch = Elt.a ats ch :> Doc\n        /// Create an SVG element <altglyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyph ats ch = Elt.altglyph ats ch :> Doc\n        /// Create an SVG element <altglyphdef> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyphdef ats ch = Elt.altglyphdef ats ch :> Doc\n        /// Create an SVG element <altglyphitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyphitem ats ch = Elt.altglyphitem ats ch :> Doc\n        /// Create an SVG element <animate> with attributes and children.\n        [<JavaScript; Inline>]\n        let animate ats ch = Elt.animate ats ch :> Doc\n        /// Create an SVG element <animatecolor> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatecolor ats ch = Elt.animatecolor ats ch :> Doc\n        /// Create an SVG element <animatemotion> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatemotion ats ch = Elt.animatemotion ats ch :> Doc\n        /// Create an SVG element <animatetransform> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatetransform ats ch = Elt.animatetransform ats ch :> Doc\n        /// Create an SVG element <circle> with attributes and children.\n        [<JavaScript; Inline>]\n        let circle ats ch = Elt.circle ats ch :> Doc\n        /// Create an SVG element <clippath> with attributes and children.\n        [<JavaScript; Inline>]\n        let clippath ats ch = Elt.clippath ats ch :> Doc\n        /// Create an SVG element <color-profile> with attributes and children.\n        [<JavaScript; Inline>]\n        let colorProfile ats ch = Elt.colorProfile ats ch :> Doc\n        /// Create an SVG element <cursor> with attributes and children.\n        [<JavaScript; Inline>]\n        let cursor ats ch = Elt.cursor ats ch :> Doc\n        /// Create an SVG element <defs> with attributes and children.\n        [<JavaScript; Inline>]\n        let defs ats ch = Elt.defs ats ch :> Doc\n        /// Create an SVG element <desc> with attributes and children.\n        [<JavaScript; Inline>]\n        let desc ats ch = Elt.desc ats ch :> Doc\n        /// Create an SVG element <ellipse> with attributes and children.\n        [<JavaScript; Inline>]\n        let ellipse ats ch = Elt.ellipse ats ch :> Doc\n        /// Create an SVG element <feblend> with attributes and children.\n        [<JavaScript; Inline>]\n        let feblend ats ch = Elt.feblend ats ch :> Doc\n        /// Create an SVG element <fecolormatrix> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecolormatrix ats ch = Elt.fecolormatrix ats ch :> Doc\n        /// Create an SVG element <fecomponenttransfer> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecomponenttransfer ats ch = Elt.fecomponenttransfer ats ch :> Doc\n        /// Create an SVG element <fecomposite> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecomposite ats ch = Elt.fecomposite ats ch :> Doc\n        /// Create an SVG element <feconvolvematrix> with attributes and children.\n        [<JavaScript; Inline>]\n        let feconvolvematrix ats ch = Elt.feconvolvematrix ats ch :> Doc\n        /// Create an SVG element <fediffuselighting> with attributes and children.\n        [<JavaScript; Inline>]\n        let fediffuselighting ats ch = Elt.fediffuselighting ats ch :> Doc\n        /// Create an SVG element <fedisplacementmap> with attributes and children.\n        [<JavaScript; Inline>]\n        let fedisplacementmap ats ch = Elt.fedisplacementmap ats ch :> Doc\n        /// Create an SVG element <fedistantlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fedistantlight ats ch = Elt.fedistantlight ats ch :> Doc\n        /// Create an SVG element <feflood> with attributes and children.\n        [<JavaScript; Inline>]\n        let feflood ats ch = Elt.feflood ats ch :> Doc\n        /// Create an SVG element <fefunca> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefunca ats ch = Elt.fefunca ats ch :> Doc\n        /// Create an SVG element <fefuncb> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncb ats ch = Elt.fefuncb ats ch :> Doc\n        /// Create an SVG element <fefuncg> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncg ats ch = Elt.fefuncg ats ch :> Doc\n        /// Create an SVG element <fefuncr> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncr ats ch = Elt.fefuncr ats ch :> Doc\n        /// Create an SVG element <fegaussianblur> with attributes and children.\n        [<JavaScript; Inline>]\n        let fegaussianblur ats ch = Elt.fegaussianblur ats ch :> Doc\n        /// Create an SVG element <feimage> with attributes and children.\n        [<JavaScript; Inline>]\n        let feimage ats ch = Elt.feimage ats ch :> Doc\n        /// Create an SVG element <femerge> with attributes and children.\n        [<JavaScript; Inline>]\n        let femerge ats ch = Elt.femerge ats ch :> Doc\n        /// Create an SVG element <femergenode> with attributes and children.\n        [<JavaScript; Inline>]\n        let femergenode ats ch = Elt.femergenode ats ch :> Doc\n        /// Create an SVG element <femorphology> with attributes and children.\n        [<JavaScript; Inline>]\n        let femorphology ats ch = Elt.femorphology ats ch :> Doc\n        /// Create an SVG element <feoffset> with attributes and children.\n        [<JavaScript; Inline>]\n        let feoffset ats ch = Elt.feoffset ats ch :> Doc\n        /// Create an SVG element <fepointlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fepointlight ats ch = Elt.fepointlight ats ch :> Doc\n        /// Create an SVG element <fespecularlighting> with attributes and children.\n        [<JavaScript; Inline>]\n        let fespecularlighting ats ch = Elt.fespecularlighting ats ch :> Doc\n        /// Create an SVG element <fespotlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fespotlight ats ch = Elt.fespotlight ats ch :> Doc\n        /// Create an SVG element <fetile> with attributes and children.\n        [<JavaScript; Inline>]\n        let fetile ats ch = Elt.fetile ats ch :> Doc\n        /// Create an SVG element <feturbulence> with attributes and children.\n        [<JavaScript; Inline>]\n        let feturbulence ats ch = Elt.feturbulence ats ch :> Doc\n        /// Create an SVG element <filter> with attributes and children.\n        [<JavaScript; Inline>]\n        let filter ats ch = Elt.filter ats ch :> Doc\n        /// Create an SVG element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Elt.font ats ch :> Doc\n        /// Create an SVG element <font-face> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFace ats ch = Elt.fontFace ats ch :> Doc\n        /// Create an SVG element <font-face-format> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceFormat ats ch = Elt.fontFaceFormat ats ch :> Doc\n        /// Create an SVG element <font-face-name> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceName ats ch = Elt.fontFaceName ats ch :> Doc\n        /// Create an SVG element <font-face-src> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceSrc ats ch = Elt.fontFaceSrc ats ch :> Doc\n        /// Create an SVG element <font-face-uri> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceUri ats ch = Elt.fontFaceUri ats ch :> Doc\n        /// Create an SVG element <foreignobject> with attributes and children.\n        [<JavaScript; Inline>]\n        let foreignobject ats ch = Elt.foreignobject ats ch :> Doc\n        /// Create an SVG element <g> with attributes and children.\n        [<JavaScript; Inline>]\n        let g ats ch = Elt.g ats ch :> Doc\n        /// Create an SVG element <glyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let glyph ats ch = Elt.glyph ats ch :> Doc\n        /// Create an SVG element <glyphref> with attributes and children.\n        [<JavaScript; Inline>]\n        let glyphref ats ch = Elt.glyphref ats ch :> Doc\n        /// Create an SVG element <hkern> with attributes and children.\n        [<JavaScript; Inline>]\n        let hkern ats ch = Elt.hkern ats ch :> Doc\n        /// Create an SVG element <image> with attributes and children.\n        [<JavaScript; Inline>]\n        let image ats ch = Elt.image ats ch :> Doc\n        /// Create an SVG element <line> with attributes and children.\n        [<JavaScript; Inline>]\n        let line ats ch = Elt.line ats ch :> Doc\n        /// Create an SVG element <lineargradient> with attributes and children.\n        [<JavaScript; Inline>]\n        let lineargradient ats ch = Elt.lineargradient ats ch :> Doc\n        /// Create an SVG element <marker> with attributes and children.\n        [<JavaScript; Inline>]\n        let marker ats ch = Elt.marker ats ch :> Doc\n        /// Create an SVG element <mask> with attributes and children.\n        [<JavaScript; Inline>]\n        let mask ats ch = Elt.mask ats ch :> Doc\n        /// Create an SVG element <metadata> with attributes and children.\n        [<JavaScript; Inline>]\n        let metadata ats ch = Elt.metadata ats ch :> Doc\n        /// Create an SVG element <missing-glyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let missingGlyph ats ch = Elt.missingGlyph ats ch :> Doc\n        /// Create an SVG element <mpath> with attributes and children.\n        [<JavaScript; Inline>]\n        let mpath ats ch = Elt.mpath ats ch :> Doc\n        /// Create an SVG element <path> with attributes and children.\n        [<JavaScript; Inline>]\n        let path ats ch = Elt.path ats ch :> Doc\n        /// Create an SVG element <pattern> with attributes and children.\n        [<JavaScript; Inline>]\n        let pattern ats ch = Elt.pattern ats ch :> Doc\n        /// Create an SVG element <polygon> with attributes and children.\n        [<JavaScript; Inline>]\n        let polygon ats ch = Elt.polygon ats ch :> Doc\n        /// Create an SVG element <polyline> with attributes and children.\n        [<JavaScript; Inline>]\n        let polyline ats ch = Elt.polyline ats ch :> Doc\n        /// Create an SVG element <radialgradient> with attributes and children.\n        [<JavaScript; Inline>]\n        let radialgradient ats ch = Elt.radialgradient ats ch :> Doc\n        /// Create an SVG element <rect> with attributes and children.\n        [<JavaScript; Inline>]\n        let rect ats ch = Elt.rect ats ch :> Doc\n        /// Create an SVG element <script> with attributes and children.\n        [<JavaScript; Inline>]\n        let script ats ch = Elt.script ats ch :> Doc\n        /// Create an SVG element <set> with attributes and children.\n        [<JavaScript; Inline>]\n        let set ats ch = Elt.set ats ch :> Doc\n        /// Create an SVG element <stop> with attributes and children.\n        [<JavaScript; Inline>]\n        let stop ats ch = Elt.stop ats ch :> Doc\n        /// Create an SVG element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Elt.style ats ch :> Doc\n        /// Create an SVG element <svg> with attributes and children.\n        [<JavaScript; Inline>]\n        let svg ats ch = Elt.svg ats ch :> Doc\n        /// Create an SVG element <switch> with attributes and children.\n        [<JavaScript; Inline>]\n        let switch ats ch = Elt.switch ats ch :> Doc\n        /// Create an SVG element <symbol> with attributes and children.\n        [<JavaScript; Inline>]\n        let symbol ats ch = Elt.symbol ats ch :> Doc\n        /// Create an SVG element <text> with attributes and children.\n        [<JavaScript; Inline>]\n        let text ats ch = Elt.text ats ch :> Doc\n        /// Create an SVG element <textpath> with attributes and children.\n        [<JavaScript; Inline>]\n        let textpath ats ch = Elt.textpath ats ch :> Doc\n        /// Create an SVG element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Elt.title ats ch :> Doc\n        /// Create an SVG element <tref> with attributes and children.\n        [<JavaScript; Inline>]\n        let tref ats ch = Elt.tref ats ch :> Doc\n        /// Create an SVG element <tspan> with attributes and children.\n        [<JavaScript; Inline>]\n        let tspan ats ch = Elt.tspan ats ch :> Doc\n        /// Create an SVG element <use> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``use`` ats ch = Elt.``use`` ats ch :> Doc\n        /// Create an SVG element <view> with attributes and children.\n        [<JavaScript; Inline>]\n        let view ats ch = Elt.view ats ch :> Doc\n        /// Create an SVG element <vkern> with attributes and children.\n        [<JavaScript; Inline>]\n        let vkern ats ch = Elt.vkern ats ch :> Doc\n        // }}\n\n    [<JavaScript; Sealed>]\n    type attr private () =\n\n        /// Create an HTML attribute \"data-name\" with the given value.\n        [<JavaScript; Inline>]\n        static member ``data-`` name value = Attr.Create (\"data-\" + name) value\n\n        // {{ attr normal colliding deprecated\n        /// Create an HTML attribute \"accept\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accept\")>]\n        static member accept value = Attr.Create \"accept\" value\n        /// Create an HTML attribute \"accept-charset\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accept-charset\")>]\n        static member acceptCharset value = Attr.Create \"accept-charset\" value\n        /// Create an HTML attribute \"accesskey\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accesskey\")>]\n        static member accesskey value = Attr.Create \"accesskey\" value\n        /// Create an HTML attribute \"action\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"action\")>]\n        static member action value = Attr.Create \"action\" value\n        /// Create an HTML attribute \"align\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"align\")>]\n        static member align value = Attr.Create \"align\" value\n        /// Create an HTML attribute \"alink\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alink\")>]\n        static member alink value = Attr.Create \"alink\" value\n        /// Create an HTML attribute \"alt\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alt\")>]\n        static member alt value = Attr.Create \"alt\" value\n        /// Create an HTML attribute \"altcode\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"altcode\")>]\n        static member altcode value = Attr.Create \"altcode\" value\n        /// Create an HTML attribute \"archive\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"archive\")>]\n        static member archive value = Attr.Create \"archive\" value\n        /// Create an HTML attribute \"async\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"async\")>]\n        static member async value = Attr.Create \"async\" value\n        /// Create an HTML attribute \"autocomplete\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autocomplete\")>]\n        static member autocomplete value = Attr.Create \"autocomplete\" value\n        /// Create an HTML attribute \"autofocus\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autofocus\")>]\n        static member autofocus value = Attr.Create \"autofocus\" value\n        /// Create an HTML attribute \"autoplay\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autoplay\")>]\n        static member autoplay value = Attr.Create \"autoplay\" value\n        /// Create an HTML attribute \"autosave\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autosave\")>]\n        static member autosave value = Attr.Create \"autosave\" value\n        /// Create an HTML attribute \"axis\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"axis\")>]\n        static member axis value = Attr.Create \"axis\" value\n        /// Create an HTML attribute \"background\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"background\")>]\n        static member background value = Attr.Create \"background\" value\n        /// Create an HTML attribute \"bgcolor\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bgcolor\")>]\n        static member bgcolor value = Attr.Create \"bgcolor\" value\n        /// Create an HTML attribute \"border\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"border\")>]\n        static member border value = Attr.Create \"border\" value\n        /// Create an HTML attribute \"bordercolor\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bordercolor\")>]\n        static member bordercolor value = Attr.Create \"bordercolor\" value\n        /// Create an HTML attribute \"buffered\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"buffered\")>]\n        static member buffered value = Attr.Create \"buffered\" value\n        /// Create an HTML attribute \"cellpadding\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cellpadding\")>]\n        static member cellpadding value = Attr.Create \"cellpadding\" value\n        /// Create an HTML attribute \"cellspacing\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cellspacing\")>]\n        static member cellspacing value = Attr.Create \"cellspacing\" value\n        /// Create an HTML attribute \"challenge\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"challenge\")>]\n        static member challenge value = Attr.Create \"challenge\" value\n        /// Create an HTML attribute \"char\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"char\")>]\n        static member char value = Attr.Create \"char\" value\n        /// Create an HTML attribute \"charoff\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"charoff\")>]\n        static member charoff value = Attr.Create \"charoff\" value\n        /// Create an HTML attribute \"charset\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"charset\")>]\n        static member charset value = Attr.Create \"charset\" value\n        /// Create an HTML attribute \"checked\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"checked\")>]\n        static member ``checked`` value = Attr.Create \"checked\" value\n        /// Create an HTML attribute \"cite\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cite\")>]\n        static member cite value = Attr.Create \"cite\" value\n        /// Create an HTML attribute \"class\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"class\")>]\n        static member ``class`` value = Attr.Create \"class\" value\n        /// Create an HTML attribute \"classid\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"classid\")>]\n        static member classid value = Attr.Create \"classid\" value\n        /// Create an HTML attribute \"clear\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clear\")>]\n        static member clear value = Attr.Create \"clear\" value\n        /// Create an HTML attribute \"code\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"code\")>]\n        static member code value = Attr.Create \"code\" value\n        /// Create an HTML attribute \"codebase\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"codebase\")>]\n        static member codebase value = Attr.Create \"codebase\" value\n        /// Create an HTML attribute \"codetype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"codetype\")>]\n        static member codetype value = Attr.Create \"codetype\" value\n        /// Create an HTML attribute \"color\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color\")>]\n        static member color value = Attr.Create \"color\" value\n        /// Create an HTML attribute \"cols\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cols\")>]\n        static member cols value = Attr.Create \"cols\" value\n        /// Create an HTML attribute \"colspan\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"colspan\")>]\n        static member colspan value = Attr.Create \"colspan\" value\n        /// Create an HTML attribute \"compact\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"compact\")>]\n        static member compact value = Attr.Create \"compact\" value\n        /// Create an HTML attribute \"content\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"content\")>]\n        static member content value = Attr.Create \"content\" value\n        /// Create an HTML attribute \"contenteditable\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contenteditable\")>]\n        static member contenteditable value = Attr.Create \"contenteditable\" value\n        /// Create an HTML attribute \"contextmenu\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contextmenu\")>]\n        static member contextmenu value = Attr.Create \"contextmenu\" value\n        /// Create an HTML attribute \"controls\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"controls\")>]\n        static member controls value = Attr.Create \"controls\" value\n        /// Create an HTML attribute \"coords\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"coords\")>]\n        static member coords value = Attr.Create \"coords\" value\n        /// Create an HTML attribute \"data\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"data\")>]\n        static member data value = Attr.Create \"data\" value\n        /// Create an HTML attribute \"datetime\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"datetime\")>]\n        static member datetime value = Attr.Create \"datetime\" value\n        /// Create an HTML attribute \"declare\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"declare\")>]\n        static member declare value = Attr.Create \"declare\" value\n        /// Create an HTML attribute \"default\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"default\")>]\n        static member ``default`` value = Attr.Create \"default\" value\n        /// Create an HTML attribute \"defer\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"defer\")>]\n        static member defer value = Attr.Create \"defer\" value\n        /// Create an HTML attribute \"dir\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dir\")>]\n        static member dir value = Attr.Create \"dir\" value\n        /// Create an HTML attribute \"disabled\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"disabled\")>]\n        static member disabled value = Attr.Create \"disabled\" value\n        /// Create an HTML attribute \"download\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"download\")>]\n        static member download value = Attr.Create \"download\" value\n        /// Create an HTML attribute \"draggable\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"draggable\")>]\n        static member draggable value = Attr.Create \"draggable\" value\n        /// Create an HTML attribute \"dropzone\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dropzone\")>]\n        static member dropzone value = Attr.Create \"dropzone\" value\n        /// Create an HTML attribute \"enctype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"enctype\")>]\n        static member enctype value = Attr.Create \"enctype\" value\n        /// Create an HTML attribute \"face\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"face\")>]\n        static member face value = Attr.Create \"face\" value\n        /// Create an HTML attribute \"for\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"for\")>]\n        static member ``for`` value = Attr.Create \"for\" value\n        /// Create an HTML attribute \"form\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"form\")>]\n        static member form value = Attr.Create \"form\" value\n        /// Create an HTML attribute \"formaction\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formaction\")>]\n        static member formaction value = Attr.Create \"formaction\" value\n        /// Create an HTML attribute \"formenctype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formenctype\")>]\n        static member formenctype value = Attr.Create \"formenctype\" value\n        /// Create an HTML attribute \"formmethod\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formmethod\")>]\n        static member formmethod value = Attr.Create \"formmethod\" value\n        /// Create an HTML attribute \"formnovalidate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formnovalidate\")>]\n        static member formnovalidate value = Attr.Create \"formnovalidate\" value\n        /// Create an HTML attribute \"formtarget\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formtarget\")>]\n        static member formtarget value = Attr.Create \"formtarget\" value\n        /// Create an HTML attribute \"frame\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"frame\")>]\n        static member frame value = Attr.Create \"frame\" value\n        /// Create an HTML attribute \"frameborder\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"frameborder\")>]\n        static member frameborder value = Attr.Create \"frameborder\" value\n        /// Create an HTML attribute \"headers\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"headers\")>]\n        static member headers value = Attr.Create \"headers\" value\n        /// Create an HTML attribute \"height\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"height\")>]\n        static member height value = Attr.Create \"height\" value\n        /// Create an HTML attribute \"hidden\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hidden\")>]\n        static member hidden value = Attr.Create \"hidden\" value\n        /// Create an HTML attribute \"high\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"high\")>]\n        static member high value = Attr.Create \"high\" value\n        /// Create an HTML attribute \"href\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"href\")>]\n        static member href value = Attr.Create \"href\" value\n        /// Create an HTML attribute \"hreflang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hreflang\")>]\n        static member hreflang value = Attr.Create \"hreflang\" value\n        /// Create an HTML attribute \"hspace\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hspace\")>]\n        static member hspace value = Attr.Create \"hspace\" value\n        /// Create an HTML attribute \"http\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"http\")>]\n        static member http value = Attr.Create \"http\" value\n        /// Create an HTML attribute \"icon\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"icon\")>]\n        static member icon value = Attr.Create \"icon\" value\n        /// Create an HTML attribute \"id\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"id\")>]\n        static member id value = Attr.Create \"id\" value\n        /// Create an HTML attribute \"ismap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ismap\")>]\n        static member ismap value = Attr.Create \"ismap\" value\n        /// Create an HTML attribute \"itemprop\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"itemprop\")>]\n        static member itemprop value = Attr.Create \"itemprop\" value\n        /// Create an HTML attribute \"keytype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keytype\")>]\n        static member keytype value = Attr.Create \"keytype\" value\n        /// Create an HTML attribute \"kind\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kind\")>]\n        static member kind value = Attr.Create \"kind\" value\n        /// Create an HTML attribute \"label\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"label\")>]\n        static member label value = Attr.Create \"label\" value\n        /// Create an HTML attribute \"lang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"lang\")>]\n        static member lang value = Attr.Create \"lang\" value\n        /// Create an HTML attribute \"language\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"language\")>]\n        static member language value = Attr.Create \"language\" value\n        /// Create an HTML attribute \"link\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"link\")>]\n        static member link value = Attr.Create \"link\" value\n        /// Create an HTML attribute \"list\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"list\")>]\n        static member list value = Attr.Create \"list\" value\n        /// Create an HTML attribute \"longdesc\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"longdesc\")>]\n        static member longdesc value = Attr.Create \"longdesc\" value\n        /// Create an HTML attribute \"loop\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"loop\")>]\n        static member loop value = Attr.Create \"loop\" value\n        /// Create an HTML attribute \"low\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"low\")>]\n        static member low value = Attr.Create \"low\" value\n        /// Create an HTML attribute \"manifest\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"manifest\")>]\n        static member manifest value = Attr.Create \"manifest\" value\n        /// Create an HTML attribute \"marginheight\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marginheight\")>]\n        static member marginheight value = Attr.Create \"marginheight\" value\n        /// Create an HTML attribute \"marginwidth\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marginwidth\")>]\n        static member marginwidth value = Attr.Create \"marginwidth\" value\n        /// Create an HTML attribute \"max\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"max\")>]\n        static member max value = Attr.Create \"max\" value\n        /// Create an HTML attribute \"maxlength\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maxlength\")>]\n        static member maxlength value = Attr.Create \"maxlength\" value\n        /// Create an HTML attribute \"media\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"media\")>]\n        static member media value = Attr.Create \"media\" value\n        /// Create an HTML attribute \"method\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"method\")>]\n        static member ``method`` value = Attr.Create \"method\" value\n        /// Create an HTML attribute \"min\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"min\")>]\n        static member min value = Attr.Create \"min\" value\n        /// Create an HTML attribute \"multiple\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"multiple\")>]\n        static member multiple value = Attr.Create \"multiple\" value\n        /// Create an HTML attribute \"name\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"name\")>]\n        static member name value = Attr.Create \"name\" value\n        /// Create an HTML attribute \"nohref\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"nohref\")>]\n        static member nohref value = Attr.Create \"nohref\" value\n        /// Create an HTML attribute \"noresize\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"noresize\")>]\n        static member noresize value = Attr.Create \"noresize\" value\n        /// Create an HTML attribute \"noshade\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"noshade\")>]\n        static member noshade value = Attr.Create \"noshade\" value\n        /// Create an HTML attribute \"novalidate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"novalidate\")>]\n        static member novalidate value = Attr.Create \"novalidate\" value\n        /// Create an HTML attribute \"nowrap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"nowrap\")>]\n        static member nowrap value = Attr.Create \"nowrap\" value\n        /// Create an HTML attribute \"object\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"object\")>]\n        static member ``object`` value = Attr.Create \"object\" value\n        /// Create an HTML attribute \"open\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"open\")>]\n        static member ``open`` value = Attr.Create \"open\" value\n        /// Create an HTML attribute \"optimum\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"optimum\")>]\n        static member optimum value = Attr.Create \"optimum\" value\n        /// Create an HTML attribute \"pattern\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pattern\")>]\n        static member pattern value = Attr.Create \"pattern\" value\n        /// Create an HTML attribute \"ping\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ping\")>]\n        static member ping value = Attr.Create \"ping\" value\n        /// Create an HTML attribute \"placeholder\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"placeholder\")>]\n        static member placeholder value = Attr.Create \"placeholder\" value\n        /// Create an HTML attribute \"poster\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"poster\")>]\n        static member poster value = Attr.Create \"poster\" value\n        /// Create an HTML attribute \"preload\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preload\")>]\n        static member preload value = Attr.Create \"preload\" value\n        /// Create an HTML attribute \"profile\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"profile\")>]\n        static member profile value = Attr.Create \"profile\" value\n        /// Create an HTML attribute \"prompt\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"prompt\")>]\n        static member prompt value = Attr.Create \"prompt\" value\n        /// Create an HTML attribute \"pubdate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pubdate\")>]\n        static member pubdate value = Attr.Create \"pubdate\" value\n        /// Create an HTML attribute \"radiogroup\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"radiogroup\")>]\n        static member radiogroup value = Attr.Create \"radiogroup\" value\n        /// Create an HTML attribute \"readonly\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"readonly\")>]\n        static member readonly value = Attr.Create \"readonly\" value\n        /// Create an HTML attribute \"rel\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rel\")>]\n        static member rel value = Attr.Create \"rel\" value\n        /// Create an HTML attribute \"required\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"required\")>]\n        static member required value = Attr.Create \"required\" value\n        /// Create an HTML attribute \"rev\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rev\")>]\n        static member rev value = Attr.Create \"rev\" value\n        /// Create an HTML attribute \"reversed\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"reversed\")>]\n        static member reversed value = Attr.Create \"reversed\" value\n        /// Create an HTML attribute \"rows\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rows\")>]\n        static member rows value = Attr.Create \"rows\" value\n        /// Create an HTML attribute \"rowspan\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rowspan\")>]\n        static member rowspan value = Attr.Create \"rowspan\" value\n        /// Create an HTML attribute \"rules\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rules\")>]\n        static member rules value = Attr.Create \"rules\" value\n        /// Create an HTML attribute \"sandbox\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"sandbox\")>]\n        static member sandbox value = Attr.Create \"sandbox\" value\n        /// Create an HTML attribute \"scheme\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scheme\")>]\n        static member scheme value = Attr.Create \"scheme\" value\n        /// Create an HTML attribute \"scope\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scope\")>]\n        static member scope value = Attr.Create \"scope\" value\n        /// Create an HTML attribute \"scoped\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scoped\")>]\n        static member scoped value = Attr.Create \"scoped\" value\n        /// Create an HTML attribute \"scrolling\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scrolling\")>]\n        static member scrolling value = Attr.Create \"scrolling\" value\n        /// Create an HTML attribute \"seamless\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"seamless\")>]\n        static member seamless value = Attr.Create \"seamless\" value\n        /// Create an HTML attribute \"selected\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"selected\")>]\n        static member selected value = Attr.Create \"selected\" value\n        /// Create an HTML attribute \"shape\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"shape\")>]\n        static member shape value = Attr.Create \"shape\" value\n        /// Create an HTML attribute \"size\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"size\")>]\n        static member size value = Attr.Create \"size\" value\n        /// Create an HTML attribute \"sizes\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"sizes\")>]\n        static member sizes value = Attr.Create \"sizes\" value\n        /// Create an HTML attribute \"span\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"span\")>]\n        static member span value = Attr.Create \"span\" value\n        /// Create an HTML attribute \"spellcheck\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"spellcheck\")>]\n        static member spellcheck value = Attr.Create \"spellcheck\" value\n        /// Create an HTML attribute \"src\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"src\")>]\n        static member src value = Attr.Create \"src\" value\n        /// Create an HTML attribute \"srcdoc\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"srcdoc\")>]\n        static member srcdoc value = Attr.Create \"srcdoc\" value\n        /// Create an HTML attribute \"srclang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"srclang\")>]\n        static member srclang value = Attr.Create \"srclang\" value\n        /// Create an HTML attribute \"standby\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"standby\")>]\n        static member standby value = Attr.Create \"standby\" value\n        /// Create an HTML attribute \"start\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"start\")>]\n        static member start value = Attr.Create \"start\" value\n        /// Create an HTML attribute \"step\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"step\")>]\n        static member step value = Attr.Create \"step\" value\n        /// Create an HTML attribute \"style\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"style\")>]\n        static member style value = Attr.Create \"style\" value\n        /// Create an HTML attribute \"subject\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"subject\")>]\n        static member subject value = Attr.Create \"subject\" value\n        /// Create an HTML attribute \"summary\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"summary\")>]\n        static member summary value = Attr.Create \"summary\" value\n        /// Create an HTML attribute \"tabindex\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"tabindex\")>]\n        static member tabindex value = Attr.Create \"tabindex\" value\n        /// Create an HTML attribute \"target\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"target\")>]\n        static member target value = Attr.Create \"target\" value\n        /// Create an HTML attribute \"text\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text\")>]\n        static member text value = Attr.Create \"text\" value\n        /// Create an HTML attribute \"title\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"title\")>]\n        static member title value = Attr.Create \"title\" value\n        /// Create an HTML attribute \"type\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"type\")>]\n        static member ``type`` value = Attr.Create \"type\" value\n        /// Create an HTML attribute \"usemap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"usemap\")>]\n        static member usemap value = Attr.Create \"usemap\" value\n        /// Create an HTML attribute \"valign\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"valign\")>]\n        static member valign value = Attr.Create \"valign\" value\n        /// Create an HTML attribute \"value\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"value\")>]\n        static member value value = Attr.Create \"value\" value\n        /// Create an HTML attribute \"valuetype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"valuetype\")>]\n        static member valuetype value = Attr.Create \"valuetype\" value\n        /// Create an HTML attribute \"version\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"version\")>]\n        static member version value = Attr.Create \"version\" value\n        /// Create an HTML attribute \"vlink\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"vlink\")>]\n        static member vlink value = Attr.Create \"vlink\" value\n        /// Create an HTML attribute \"vspace\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"vspace\")>]\n        static member vspace value = Attr.Create \"vspace\" value\n        /// Create an HTML attribute \"width\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"width\")>]\n        static member width value = Attr.Create \"width\" value\n        /// Create an HTML attribute \"wrap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"wrap\")>]\n        static member wrap value = Attr.Create \"wrap\" value\n        // }}\n\n    type on =\n\n        /// Adds a callback to be called after the element has been inserted in the DOM.\n        /// The callback is guaranteed to be called only once, even if the element is moved or removed and reinserted.\n        static member afterRender ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> unit>) = Attr.OnAfterRenderImpl(f)\n\n        // {{ event\n        /// Create a handler for the event \"abort\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member abort ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"abort\", f)\n        /// Create a handler for the event \"afterprint\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member afterPrint ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"afterprint\", f)\n        /// Create a handler for the event \"animationend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationend\", f)\n        /// Create a handler for the event \"animationiteration\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationIteration ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationiteration\", f)\n        /// Create a handler for the event \"animationstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationstart\", f)\n        /// Create a handler for the event \"audioprocess\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member audioProcess ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"audioprocess\", f)\n        /// Create a handler for the event \"beforeprint\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beforePrint ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beforeprint\", f)\n        /// Create a handler for the event \"beforeunload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beforeUnload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beforeunload\", f)\n        /// Create a handler for the event \"beginEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beginEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beginEvent\", f)\n        /// Create a handler for the event \"blocked\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member blocked ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"blocked\", f)\n        /// Create a handler for the event \"blur\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member blur ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.FocusEvent -> unit>) = Attr.HandlerImpl(\"blur\", f)\n        /// Create a handler for the event \"cached\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member cached ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"cached\", f)\n        /// Create a handler for the event \"canplay\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member canPlay ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"canplay\", f)\n        /// Create a handler for the event \"canplaythrough\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member canPlayThrough ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"canplaythrough\", f)\n        /// Create a handler for the event \"change\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member change ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"change\", f)\n        /// Create a handler for the event \"chargingchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member chargingChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"chargingchange\", f)\n        /// Create a handler for the event \"chargingtimechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member chargingTimeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"chargingtimechange\", f)\n        /// Create a handler for the event \"checking\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member checking ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"checking\", f)\n        /// Create a handler for the event \"click\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member click ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"click\", f)\n        /// Create a handler for the event \"close\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member close ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"close\", f)\n        /// Create a handler for the event \"complete\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member complete ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"complete\", f)\n        /// Create a handler for the event \"compositionend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionend\", f)\n        /// Create a handler for the event \"compositionstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionstart\", f)\n        /// Create a handler for the event \"compositionupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionupdate\", f)\n        /// Create a handler for the event \"contextmenu\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member contextMenu ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"contextmenu\", f)\n        /// Create a handler for the event \"copy\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member copy ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"copy\", f)\n        /// Create a handler for the event \"cut\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member cut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"cut\", f)\n        /// Create a handler for the event \"dblclick\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dblClick ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"dblclick\", f)\n        /// Create a handler for the event \"devicelight\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceLight ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"devicelight\", f)\n        /// Create a handler for the event \"devicemotion\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceMotion ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"devicemotion\", f)\n        /// Create a handler for the event \"deviceorientation\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceOrientation ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"deviceorientation\", f)\n        /// Create a handler for the event \"deviceproximity\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceProximity ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"deviceproximity\", f)\n        /// Create a handler for the event \"dischargingtimechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dischargingTimeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dischargingtimechange\", f)\n        /// Create a handler for the event \"DOMActivate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMActivate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"DOMActivate\", f)\n        /// Create a handler for the event \"DOMAttributeNameChanged\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMAttributeNameChanged ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMAttributeNameChanged\", f)\n        /// Create a handler for the event \"DOMAttrModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMAttrModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMAttrModified\", f)\n        /// Create a handler for the event \"DOMCharacterDataModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMCharacterDataModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMCharacterDataModified\", f)\n        /// Create a handler for the event \"DOMContentLoaded\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMContentLoaded ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMContentLoaded\", f)\n        /// Create a handler for the event \"DOMElementNameChanged\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMElementNameChanged ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMElementNameChanged\", f)\n        /// Create a handler for the event \"DOMNodeInserted\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeInserted ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeInserted\", f)\n        /// Create a handler for the event \"DOMNodeInsertedIntoDocument\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeInsertedIntoDocument ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeInsertedIntoDocument\", f)\n        /// Create a handler for the event \"DOMNodeRemoved\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeRemoved ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeRemoved\", f)\n        /// Create a handler for the event \"DOMNodeRemovedFromDocument\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeRemovedFromDocument ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeRemovedFromDocument\", f)\n        /// Create a handler for the event \"DOMSubtreeModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMSubtreeModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMSubtreeModified\", f)\n        /// Create a handler for the event \"downloading\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member downloading ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"downloading\", f)\n        /// Create a handler for the event \"drag\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member drag ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"drag\", f)\n        /// Create a handler for the event \"dragend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragend\", f)\n        /// Create a handler for the event \"dragenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragenter\", f)\n        /// Create a handler for the event \"dragleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragleave\", f)\n        /// Create a handler for the event \"dragover\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragOver ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragover\", f)\n        /// Create a handler for the event \"dragstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragstart\", f)\n        /// Create a handler for the event \"drop\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member drop ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"drop\", f)\n        /// Create a handler for the event \"durationchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member durationChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"durationchange\", f)\n        /// Create a handler for the event \"emptied\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member emptied ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"emptied\", f)\n        /// Create a handler for the event \"ended\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member ended ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"ended\", f)\n        /// Create a handler for the event \"endEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member endEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"endEvent\", f)\n        /// Create a handler for the event \"error\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member error ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"error\", f)\n        /// Create a handler for the event \"focus\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member focus ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.FocusEvent -> unit>) = Attr.HandlerImpl(\"focus\", f)\n        /// Create a handler for the event \"fullscreenchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member fullScreenChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"fullscreenchange\", f)\n        /// Create a handler for the event \"fullscreenerror\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member fullScreenError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"fullscreenerror\", f)\n        /// Create a handler for the event \"gamepadconnected\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member gamepadConnected ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"gamepadconnected\", f)\n        /// Create a handler for the event \"gamepaddisconnected\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member gamepadDisconnected ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"gamepaddisconnected\", f)\n        /// Create a handler for the event \"hashchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member hashChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"hashchange\", f)\n        /// Create a handler for the event \"input\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member input ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"input\", f)\n        /// Create a handler for the event \"invalid\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member invalid ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"invalid\", f)\n        /// Create a handler for the event \"keydown\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyDown ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keydown\", f)\n        /// Create a handler for the event \"keypress\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyPress ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keypress\", f)\n        /// Create a handler for the event \"keyup\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyUp ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keyup\", f)\n        /// Create a handler for the event \"languagechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member languageChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"languagechange\", f)\n        /// Create a handler for the event \"levelchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member levelChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"levelchange\", f)\n        /// Create a handler for the event \"load\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member load ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"load\", f)\n        /// Create a handler for the event \"loadeddata\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadedData ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadeddata\", f)\n        /// Create a handler for the event \"loadedmetadata\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadedMetadata ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadedmetadata\", f)\n        /// Create a handler for the event \"loadend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadend\", f)\n        /// Create a handler for the event \"loadstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadstart\", f)\n        /// Create a handler for the event \"message\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member message ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"message\", f)\n        /// Create a handler for the event \"mousedown\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseDown ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mousedown\", f)\n        /// Create a handler for the event \"mouseenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseenter\", f)\n        /// Create a handler for the event \"mouseleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseleave\", f)\n        /// Create a handler for the event \"mousemove\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseMove ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mousemove\", f)\n        /// Create a handler for the event \"mouseout\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseOut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseout\", f)\n        /// Create a handler for the event \"mouseover\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseOver ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseover\", f)\n        /// Create a handler for the event \"mouseup\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseUp ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseup\", f)\n        /// Create a handler for the event \"noupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member noUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"noupdate\", f)\n        /// Create a handler for the event \"obsolete\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member obsolete ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"obsolete\", f)\n        /// Create a handler for the event \"offline\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member offline ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"offline\", f)\n        /// Create a handler for the event \"online\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member online ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"online\", f)\n        /// Create a handler for the event \"open\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member ``open`` ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"open\", f)\n        /// Create a handler for the event \"orientationchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member orientationChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"orientationchange\", f)\n        /// Create a handler for the event \"pagehide\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pageHide ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pagehide\", f)\n        /// Create a handler for the event \"pageshow\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pageShow ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pageshow\", f)\n        /// Create a handler for the event \"paste\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member paste ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"paste\", f)\n        /// Create a handler for the event \"pause\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pause ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pause\", f)\n        /// Create a handler for the event \"play\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member play ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"play\", f)\n        /// Create a handler for the event \"playing\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member playing ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"playing\", f)\n        /// Create a handler for the event \"pointerlockchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pointerLockChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pointerlockchange\", f)\n        /// Create a handler for the event \"pointerlockerror\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pointerLockError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pointerlockerror\", f)\n        /// Create a handler for the event \"popstate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member popState ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"popstate\", f)\n        /// Create a handler for the event \"progress\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member progress ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"progress\", f)\n        /// Create a handler for the event \"ratechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member rateChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"ratechange\", f)\n        /// Create a handler for the event \"readystatechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member readyStateChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"readystatechange\", f)\n        /// Create a handler for the event \"repeatEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member repeatEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"repeatEvent\", f)\n        /// Create a handler for the event \"reset\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member reset ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"reset\", f)\n        /// Create a handler for the event \"resize\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member resize ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"resize\", f)\n        /// Create a handler for the event \"scroll\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member scroll ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"scroll\", f)\n        /// Create a handler for the event \"seeked\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member seeked ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"seeked\", f)\n        /// Create a handler for the event \"seeking\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member seeking ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"seeking\", f)\n        /// Create a handler for the event \"select\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member select ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"select\", f)\n        /// Create a handler for the event \"show\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member show ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"show\", f)\n        /// Create a handler for the event \"stalled\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member stalled ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"stalled\", f)\n        /// Create a handler for the event \"storage\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member storage ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"storage\", f)\n        /// Create a handler for the event \"submit\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member submit ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"submit\", f)\n        /// Create a handler for the event \"success\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member success ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"success\", f)\n        /// Create a handler for the event \"suspend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member suspend ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"suspend\", f)\n        /// Create a handler for the event \"SVGAbort\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGAbort ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGAbort\", f)\n        /// Create a handler for the event \"SVGError\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGError\", f)\n        /// Create a handler for the event \"SVGLoad\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGLoad ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGLoad\", f)\n        /// Create a handler for the event \"SVGResize\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGResize ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGResize\", f)\n        /// Create a handler for the event \"SVGScroll\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGScroll ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGScroll\", f)\n        /// Create a handler for the event \"SVGUnload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGUnload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGUnload\", f)\n        /// Create a handler for the event \"SVGZoom\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGZoom ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGZoom\", f)\n        /// Create a handler for the event \"timeout\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member timeOut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"timeout\", f)\n        /// Create a handler for the event \"timeupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member timeUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"timeupdate\", f)\n        /// Create a handler for the event \"touchcancel\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchCancel ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchcancel\", f)\n        /// Create a handler for the event \"touchend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchend\", f)\n        /// Create a handler for the event \"touchenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchenter\", f)\n        /// Create a handler for the event \"touchleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchleave\", f)\n        /// Create a handler for the event \"touchmove\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchMove ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchmove\", f)\n        /// Create a handler for the event \"touchstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchstart\", f)\n        /// Create a handler for the event \"transitionend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member transitionEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"transitionend\", f)\n        /// Create a handler for the event \"unload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member unload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"unload\", f)\n        /// Create a handler for the event \"updateready\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member updateReady ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"updateready\", f)\n        /// Create a handler for the event \"upgradeneeded\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member upgradeNeeded ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"upgradeneeded\", f)\n        /// Create a handler for the event \"userproximity\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member userProximity ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"userproximity\", f)\n        /// Create a handler for the event \"versionchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member versionChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"versionchange\", f)\n        /// Create a handler for the event \"visibilitychange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member visibilityChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"visibilitychange\", f)\n        /// Create a handler for the event \"volumechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member volumeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"volumechange\", f)\n        /// Create a handler for the event \"waiting\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member waiting ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"waiting\", f)\n        /// Create a handler for the event \"wheel\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member wheel ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.WheelEvent -> unit>) = Attr.HandlerImpl(\"wheel\", f)\n        // }}\n\n    /// SVG attributes.\n    module SvgAttributes =\n\n        // {{ svgattr normal\n        /// Create an SVG attribute \"accent-height\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accent-height\")>]\n        let accentHeight value = Attr.Create \"accent-height\" value\n        /// Create an SVG attribute \"accumulate\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accumulate\")>]\n        let accumulate value = Attr.Create \"accumulate\" value\n        /// Create an SVG attribute \"additive\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"additive\")>]\n        let additive value = Attr.Create \"additive\" value\n        /// Create an SVG attribute \"alignment-baseline\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alignment-baseline\")>]\n        let alignmentBaseline value = Attr.Create \"alignment-baseline\" value\n        /// Create an SVG attribute \"ascent\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ascent\")>]\n        let ascent value = Attr.Create \"ascent\" value\n        /// Create an SVG attribute \"attributeName\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"attributeName\")>]\n        let attributeName value = Attr.Create \"attributeName\" value\n        /// Create an SVG attribute \"attributeType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"attributeType\")>]\n        let attributeType value = Attr.Create \"attributeType\" value\n        /// Create an SVG attribute \"azimuth\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"azimuth\")>]\n        let azimuth value = Attr.Create \"azimuth\" value\n        /// Create an SVG attribute \"baseFrequency\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"baseFrequency\")>]\n        let baseFrequency value = Attr.Create \"baseFrequency\" value\n        /// Create an SVG attribute \"baseline-shift\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"baseline-shift\")>]\n        let baselineShift value = Attr.Create \"baseline-shift\" value\n        /// Create an SVG attribute \"begin\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"begin\")>]\n        let ``begin`` value = Attr.Create \"begin\" value\n        /// Create an SVG attribute \"bias\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bias\")>]\n        let bias value = Attr.Create \"bias\" value\n        /// Create an SVG attribute \"calcMode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"calcMode\")>]\n        let calcMode value = Attr.Create \"calcMode\" value\n        /// Create an SVG attribute \"class\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"class\")>]\n        let ``class`` value = Attr.Create \"class\" value\n        /// Create an SVG attribute \"clip\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip\")>]\n        let clip value = Attr.Create \"clip\" value\n        /// Create an SVG attribute \"clip-path\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip-path\")>]\n        let clipPath value = Attr.Create \"clip-path\" value\n        /// Create an SVG attribute \"clipPathUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clipPathUnits\")>]\n        let clipPathUnits value = Attr.Create \"clipPathUnits\" value\n        /// Create an SVG attribute \"clip-rule\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip-rule\")>]\n        let clipRule value = Attr.Create \"clip-rule\" value\n        /// Create an SVG attribute \"color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color\")>]\n        let color value = Attr.Create \"color\" value\n        /// Create an SVG attribute \"color-interpolation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-interpolation\")>]\n        let colorInterpolation value = Attr.Create \"color-interpolation\" value\n        /// Create an SVG attribute \"color-interpolation-filters\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-interpolation-filters\")>]\n        let colorInterpolationFilters value = Attr.Create \"color-interpolation-filters\" value\n        /// Create an SVG attribute \"color-profile\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-profile\")>]\n        let colorProfile value = Attr.Create \"color-profile\" value\n        /// Create an SVG attribute \"color-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-rendering\")>]\n        let colorRendering value = Attr.Create \"color-rendering\" value\n        /// Create an SVG attribute \"contentScriptType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contentScriptType\")>]\n        let contentScriptType value = Attr.Create \"contentScriptType\" value\n        /// Create an SVG attribute \"contentStyleType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contentStyleType\")>]\n        let contentStyleType value = Attr.Create \"contentStyleType\" value\n        /// Create an SVG attribute \"cursor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cursor\")>]\n        let cursor value = Attr.Create \"cursor\" value\n        /// Create an SVG attribute \"cx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cx\")>]\n        let cx value = Attr.Create \"cx\" value\n        /// Create an SVG attribute \"cy\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cy\")>]\n        let cy value = Attr.Create \"cy\" value\n        /// Create an SVG attribute \"d\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"d\")>]\n        let d value = Attr.Create \"d\" value\n        /// Create an SVG attribute \"diffuseConstant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"diffuseConstant\")>]\n        let diffuseConstant value = Attr.Create \"diffuseConstant\" value\n        /// Create an SVG attribute \"direction\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"direction\")>]\n        let direction value = Attr.Create \"direction\" value\n        /// Create an SVG attribute \"display\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"display\")>]\n        let display value = Attr.Create \"display\" value\n        /// Create an SVG attribute \"divisor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"divisor\")>]\n        let divisor value = Attr.Create \"divisor\" value\n        /// Create an SVG attribute \"dominant-baseline\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dominant-baseline\")>]\n        let dominantBaseline value = Attr.Create \"dominant-baseline\" value\n        /// Create an SVG attribute \"dur\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dur\")>]\n        let dur value = Attr.Create \"dur\" value\n        /// Create an SVG attribute \"dx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dx\")>]\n        let dx value = Attr.Create \"dx\" value\n        /// Create an SVG attribute \"dy\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dy\")>]\n        let dy value = Attr.Create \"dy\" value\n        /// Create an SVG attribute \"edgeMode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"edgeMode\")>]\n        let edgeMode value = Attr.Create \"edgeMode\" value\n        /// Create an SVG attribute \"elevation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"elevation\")>]\n        let elevation value = Attr.Create \"elevation\" value\n        /// Create an SVG attribute \"end\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"end\")>]\n        let ``end`` value = Attr.Create \"end\" value\n        /// Create an SVG attribute \"externalResourcesRequired\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"externalResourcesRequired\")>]\n        let externalResourcesRequired value = Attr.Create \"externalResourcesRequired\" value\n        /// Create an SVG attribute \"fill\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill\")>]\n        let fill value = Attr.Create \"fill\" value\n        /// Create an SVG attribute \"fill-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill-opacity\")>]\n        let fillOpacity value = Attr.Create \"fill-opacity\" value\n        /// Create an SVG attribute \"fill-rule\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill-rule\")>]\n        let fillRule value = Attr.Create \"fill-rule\" value\n        /// Create an SVG attribute \"filter\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filter\")>]\n        let filter value = Attr.Create \"filter\" value\n        /// Create an SVG attribute \"filterRes\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filterRes\")>]\n        let filterRes value = Attr.Create \"filterRes\" value\n        /// Create an SVG attribute \"filterUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filterUnits\")>]\n        let filterUnits value = Attr.Create \"filterUnits\" value\n        /// Create an SVG attribute \"flood-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"flood-color\")>]\n        let floodColor value = Attr.Create \"flood-color\" value\n        /// Create an SVG attribute \"flood-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"flood-opacity\")>]\n        let floodOpacity value = Attr.Create \"flood-opacity\" value\n        /// Create an SVG attribute \"font-family\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-family\")>]\n        let fontFamily value = Attr.Create \"font-family\" value\n        /// Create an SVG attribute \"font-size\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-size\")>]\n        let fontSize value = Attr.Create \"font-size\" value\n        /// Create an SVG attribute \"font-size-adjust\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-size-adjust\")>]\n        let fontSizeAdjust value = Attr.Create \"font-size-adjust\" value\n        /// Create an SVG attribute \"font-stretch\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-stretch\")>]\n        let fontStretch value = Attr.Create \"font-stretch\" value\n        /// Create an SVG attribute \"font-style\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-style\")>]\n        let fontStyle value = Attr.Create \"font-style\" value\n        /// Create an SVG attribute \"font-variant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-variant\")>]\n        let fontVariant value = Attr.Create \"font-variant\" value\n        /// Create an SVG attribute \"font-weight\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-weight\")>]\n        let fontWeight value = Attr.Create \"font-weight\" value\n        /// Create an SVG attribute \"from\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"from\")>]\n        let from value = Attr.Create \"from\" value\n        /// Create an SVG attribute \"gradientTransform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"gradientTransform\")>]\n        let gradientTransform value = Attr.Create \"gradientTransform\" value\n        /// Create an SVG attribute \"gradientUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"gradientUnits\")>]\n        let gradientUnits value = Attr.Create \"gradientUnits\" value\n        /// Create an SVG attribute \"height\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"height\")>]\n        let height value = Attr.Create \"height\" value\n        /// Create an SVG attribute \"image-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"image-rendering\")>]\n        let imageRendering value = Attr.Create \"image-rendering\" value\n        /// Create an SVG attribute \"in\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"in\")>]\n        let ``in`` value = Attr.Create \"in\" value\n        /// Create an SVG attribute \"in2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"in2\")>]\n        let in2 value = Attr.Create \"in2\" value\n        /// Create an SVG attribute \"k1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k1\")>]\n        let k1 value = Attr.Create \"k1\" value\n        /// Create an SVG attribute \"k2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k2\")>]\n        let k2 value = Attr.Create \"k2\" value\n        /// Create an SVG attribute \"k3\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k3\")>]\n        let k3 value = Attr.Create \"k3\" value\n        /// Create an SVG attribute \"k4\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k4\")>]\n        let k4 value = Attr.Create \"k4\" value\n        /// Create an SVG attribute \"kernelMatrix\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kernelMatrix\")>]\n        let kernelMatrix value = Attr.Create \"kernelMatrix\" value\n        /// Create an SVG attribute \"kernelUnitLength\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kernelUnitLength\")>]\n        let kernelUnitLength value = Attr.Create \"kernelUnitLength\" value\n        /// Create an SVG attribute \"kerning\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kerning\")>]\n        let kerning value = Attr.Create \"kerning\" value\n        /// Create an SVG attribute \"keySplines\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keySplines\")>]\n        let keySplines value = Attr.Create \"keySplines\" value\n        /// Create an SVG attribute \"keyTimes\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keyTimes\")>]\n        let keyTimes value = Attr.Create \"keyTimes\" value\n        /// Create an SVG attribute \"letter-spacing\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"letter-spacing\")>]\n        let letterSpacing value = Attr.Create \"letter-spacing\" value\n        /// Create an SVG attribute \"lighting-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"lighting-color\")>]\n        let lightingColor value = Attr.Create \"lighting-color\" value\n        /// Create an SVG attribute \"limitingConeAngle\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"limitingConeAngle\")>]\n        let limitingConeAngle value = Attr.Create \"limitingConeAngle\" value\n        /// Create an SVG attribute \"local\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"local\")>]\n        let local value = Attr.Create \"local\" value\n        /// Create an SVG attribute \"marker-end\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-end\")>]\n        let markerEnd value = Attr.Create \"marker-end\" value\n        /// Create an SVG attribute \"markerHeight\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerHeight\")>]\n        let markerHeight value = Attr.Create \"markerHeight\" value\n        /// Create an SVG attribute \"marker-mid\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-mid\")>]\n        let markerMid value = Attr.Create \"marker-mid\" value\n        /// Create an SVG attribute \"marker-start\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-start\")>]\n        let markerStart value = Attr.Create \"marker-start\" value\n        /// Create an SVG attribute \"markerUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerUnits\")>]\n        let markerUnits value = Attr.Create \"markerUnits\" value\n        /// Create an SVG attribute \"markerWidth\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerWidth\")>]\n        let markerWidth value = Attr.Create \"markerWidth\" value\n        /// Create an SVG attribute \"mask\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"mask\")>]\n        let mask value = Attr.Create \"mask\" value\n        /// Create an SVG attribute \"maskContentUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maskContentUnits\")>]\n        let maskContentUnits value = Attr.Create \"maskContentUnits\" value\n        /// Create an SVG attribute \"maskUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maskUnits\")>]\n        let maskUnits value = Attr.Create \"maskUnits\" value\n        /// Create an SVG attribute \"max\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"max\")>]\n        let max value = Attr.Create \"max\" value\n        /// Create an SVG attribute \"min\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"min\")>]\n        let min value = Attr.Create \"min\" value\n        /// Create an SVG attribute \"mode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"mode\")>]\n        let mode value = Attr.Create \"mode\" value\n        /// Create an SVG attribute \"numOctaves\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"numOctaves\")>]\n        let numOctaves value = Attr.Create \"numOctaves\" value\n        /// Create an SVG attribute \"opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"opacity\")>]\n        let opacity value = Attr.Create \"opacity\" value\n        /// Create an SVG attribute \"operator\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"operator\")>]\n        let operator value = Attr.Create \"operator\" value\n        /// Create an SVG attribute \"order\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"order\")>]\n        let order value = Attr.Create \"order\" value\n        /// Create an SVG attribute \"overflow\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"overflow\")>]\n        let overflow value = Attr.Create \"overflow\" value\n        /// Create an SVG attribute \"paint-order\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"paint-order\")>]\n        let paintOrder value = Attr.Create \"paint-order\" value\n        /// Create an SVG attribute \"pathLength\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pathLength\")>]\n        let pathLength value = Attr.Create \"pathLength\" value\n        /// Create an SVG attribute \"patternContentUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternContentUnits\")>]\n        let patternContentUnits value = Attr.Create \"patternContentUnits\" value\n        /// Create an SVG attribute \"patternTransform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternTransform\")>]\n        let patternTransform value = Attr.Create \"patternTransform\" value\n        /// Create an SVG attribute \"patternUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternUnits\")>]\n        let patternUnits value = Attr.Create \"patternUnits\" value\n        /// Create an SVG attribute \"pointer-events\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointer-events\")>]\n        let pointerEvents value = Attr.Create \"pointer-events\" value\n        /// Create an SVG attribute \"points\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"points\")>]\n        let points value = Attr.Create \"points\" value\n        /// Create an SVG attribute \"pointsAtX\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtX\")>]\n        let pointsAtX value = Attr.Create \"pointsAtX\" value\n        /// Create an SVG attribute \"pointsAtY\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtY\")>]\n        let pointsAtY value = Attr.Create \"pointsAtY\" value\n        /// Create an SVG attribute \"pointsAtZ\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtZ\")>]\n        let pointsAtZ value = Attr.Create \"pointsAtZ\" value\n        /// Create an SVG attribute \"preserveAlpha\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preserveAlpha\")>]\n        let preserveAlpha value = Attr.Create \"preserveAlpha\" value\n        /// Create an SVG attribute \"preserveAspectRatio\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preserveAspectRatio\")>]\n        let preserveAspectRatio value = Attr.Create \"preserveAspectRatio\" value\n        /// Create an SVG attribute \"primitiveUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"primitiveUnits\")>]\n        let primitiveUnits value = Attr.Create \"primitiveUnits\" value\n        /// Create an SVG attribute \"r\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"r\")>]\n        let r value = Attr.Create \"r\" value\n        /// Create an SVG attribute \"radius\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"radius\")>]\n        let radius value = Attr.Create \"radius\" value\n        /// Create an SVG attribute \"repeatCount\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"repeatCount\")>]\n        let repeatCount value = Attr.Create \"repeatCount\" value\n        /// Create an SVG attribute \"repeatDur\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"repeatDur\")>]\n        let repeatDur value = Attr.Create \"repeatDur\" value\n        /// Create an SVG attribute \"requiredFeatures\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"requiredFeatures\")>]\n        let requiredFeatures value = Attr.Create \"requiredFeatures\" value\n        /// Create an SVG attribute \"restart\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"restart\")>]\n        let restart value = Attr.Create \"restart\" value\n        /// Create an SVG attribute \"result\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"result\")>]\n        let result value = Attr.Create \"result\" value\n        /// Create an SVG attribute \"rx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rx\")>]\n        let rx value = Attr.Create \"rx\" value\n        /// Create an SVG attribute \"ry\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ry\")>]\n        let ry value = Attr.Create \"ry\" value\n        /// Create an SVG attribute \"scale\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scale\")>]\n        let scale value = Attr.Create \"scale\" value\n        /// Create an SVG attribute \"seed\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"seed\")>]\n        let seed value = Attr.Create \"seed\" value\n        /// Create an SVG attribute \"shape-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"shape-rendering\")>]\n        let shapeRendering value = Attr.Create \"shape-rendering\" value\n        /// Create an SVG attribute \"specularConstant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"specularConstant\")>]\n        let specularConstant value = Attr.Create \"specularConstant\" value\n        /// Create an SVG attribute \"specularExponent\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"specularExponent\")>]\n        let specularExponent value = Attr.Create \"specularExponent\" value\n        /// Create an SVG attribute \"stdDeviation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stdDeviation\")>]\n        let stdDeviation value = Attr.Create \"stdDeviation\" value\n        /// Create an SVG attribute \"stitchTiles\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stitchTiles\")>]\n        let stitchTiles value = Attr.Create \"stitchTiles\" value\n        /// Create an SVG attribute \"stop-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stop-color\")>]\n        let stopColor value = Attr.Create \"stop-color\" value\n        /// Create an SVG attribute \"stop-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stop-opacity\")>]\n        let stopOpacity value = Attr.Create \"stop-opacity\" value\n        /// Create an SVG attribute \"stroke\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke\")>]\n        let stroke value = Attr.Create \"stroke\" value\n        /// Create an SVG attribute \"stroke-dasharray\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-dasharray\")>]\n        let strokeDasharray value = Attr.Create \"stroke-dasharray\" value\n        /// Create an SVG attribute \"stroke-dashoffset\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-dashoffset\")>]\n        let strokeDashoffset value = Attr.Create \"stroke-dashoffset\" value\n        /// Create an SVG attribute \"stroke-linecap\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-linecap\")>]\n        let strokeLinecap value = Attr.Create \"stroke-linecap\" value\n        /// Create an SVG attribute \"stroke-linejoin\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-linejoin\")>]\n        let strokeLinejoin value = Attr.Create \"stroke-linejoin\" value\n        /// Create an SVG attribute \"stroke-miterlimit\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-miterlimit\")>]\n        let strokeMiterlimit value = Attr.Create \"stroke-miterlimit\" value\n        /// Create an SVG attribute \"stroke-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-opacity\")>]\n        let strokeOpacity value = Attr.Create \"stroke-opacity\" value\n        /// Create an SVG attribute \"stroke-width\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-width\")>]\n        let strokeWidth value = Attr.Create \"stroke-width\" value\n        /// Create an SVG attribute \"style\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"style\")>]\n        let style value = Attr.Create \"style\" value\n        /// Create an SVG attribute \"surfaceScale\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"surfaceScale\")>]\n        let surfaceScale value = Attr.Create \"surfaceScale\" value\n        /// Create an SVG attribute \"targetX\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"targetX\")>]\n        let targetX value = Attr.Create \"targetX\" value\n        /// Create an SVG attribute \"targetY\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"targetY\")>]\n        let targetY value = Attr.Create \"targetY\" value\n        /// Create an SVG attribute \"text-anchor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-anchor\")>]\n        let textAnchor value = Attr.Create \"text-anchor\" value\n        /// Create an SVG attribute \"text-decoration\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-decoration\")>]\n        let textDecoration value = Attr.Create \"text-decoration\" value\n        /// Create an SVG attribute \"text-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-rendering\")>]\n        let textRendering value = Attr.Create \"text-rendering\" value\n        /// Create an SVG attribute \"to\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"to\")>]\n        let ``to`` value = Attr.Create \"to\" value\n        /// Create an SVG attribute \"transform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"transform\")>]\n        let transform value = Attr.Create \"transform\" value\n        /// Create an SVG attribute \"type\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"type\")>]\n        let ``type`` value = Attr.Create \"type\" value\n        /// Create an SVG attribute \"values\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"values\")>]\n        let values value = Attr.Create \"values\" value\n        /// Create an SVG attribute \"viewBox\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"viewBox\")>]\n        let viewBox value = Attr.Create \"viewBox\" value\n        /// Create an SVG attribute \"visibility\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"visibility\")>]\n        let visibility value = Attr.Create \"visibility\" value\n        /// Create an SVG attribute \"width\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"width\")>]\n        let width value = Attr.Create \"width\" value\n        /// Create an SVG attribute \"word-spacing\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"word-spacing\")>]\n        let wordSpacing value = Attr.Create \"word-spacing\" value\n        /// Create an SVG attribute \"writing-mode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"writing-mode\")>]\n        let writingMode value = Attr.Create \"writing-mode\" value\n        /// Create an SVG attribute \"x\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x\")>]\n        let x value = Attr.Create \"x\" value\n        /// Create an SVG attribute \"x1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x1\")>]\n        let x1 value = Attr.Create \"x1\" value\n        /// Create an SVG attribute \"x2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x2\")>]\n        let x2 value = Attr.Create \"x2\" value\n        /// Create an SVG attribute \"xChannelSelector\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"xChannelSelector\")>]\n        let xChannelSelector value = Attr.Create \"xChannelSelector\" value\n        /// Create an SVG attribute \"y\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y\")>]\n        let y value = Attr.Create \"y\" value\n        /// Create an SVG attribute \"y1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y1\")>]\n        let y1 value = Attr.Create \"y1\" value\n        /// Create an SVG attribute \"y2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y2\")>]\n        let y2 value = Attr.Create \"y2\" value\n        /// Create an SVG attribute \"yChannelSelector\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"yChannelSelector\")>]\n        let yChannelSelector value = Attr.Create \"yChannelSelector\" value\n        /// Create an SVG attribute \"z\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"z\")>]\n        let z value = Attr.Create \"z\" value\n        // }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Sitelets\n\n[<CompiledName \"InstallRouter\">]\n[<JavaScript>]\nmodule Router =\n\n    let private getCurrent parse onParseError =\n        let loc = JS.Window.Location\n        let p = loc.Pathname + loc.Search |> Route.FromUrl\n        match parse p with\n        | Some a -> a\n        | None ->\n            printfn \"Failed to parse route: %s\" (p.ToLink()) \n            onParseError\n\n    /// Trim the #fragment, if any, from a URL.\n    let private trimFragment (url: string) =\n        match url.IndexOf('#') with\n        | -1 -> url\n        | i -> url.[..i-1]\n\n    /// Transform the url from an <a href=\"XYZ\"> tag into an absolute path+query,\n    /// if it is indeed a URL that Install wants to handle.\n    let private hrefToAbsolute (href: string) =\n        if href.StartsWith(\"?\") then\n            // Query only, just add it to the current path\n            Some (JS.Window.Location.Pathname + href |> trimFragment)\n        elif href.StartsWith(\"#\") then\n            // Fragment only, Install doesn't handle it\n            None\n        elif href.StartsWith(\"/\") then\n            // Absolute path, just use it\n            Some (href |> trimFragment)\n        elif RegExp(\"^[a-zA-Z0-9]:\").Test(href) then\n            // Full URL (eg: \"http://foo.bar\"), we don't handle it\n            None\n        else\n            // Relative URL, combine it with the current path\n            let s = JS.Window.Location.Pathname\n            Some (s.[..s.LastIndexOf('/')] + href |> trimFragment)\n\n    let rec private findLinkHref (n: Dom.Element) =\n        if n.TagName = \"A\" then\n            n.GetAttribute(\"href\") |> Option.ofObj\n        elif n ===. JS.Document.Body then\n            None\n        else\n            findLinkHref (n.ParentNode :?> Dom.Element)\n\n    /// Installs client-side routing on the full URL. \n    /// If initials URL parse fails, value is left as the initial value of `var`.\n    let InstallInto (var: Var<'T>) onParseError (router: Router<'T>) : unit =\n        let parse p = Router.Parse router p\n        let cur() : 'T = getCurrent parse onParseError\n\n        let set value =\n            if var.Value <> value then\n                var.Value <- value\n        \n        JS.Window.AddEventListener(\"popstate\", (fun () -> set (cur())), false)\n\n        JS.Document.Body.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            findLinkHref (As ev.Target)\n            |> Option.bind hrefToAbsolute\n            |> Option.bind (Route.FromUrl >> parse)\n            |> Option.iter (fun a ->\n                set a\n                ev.PreventDefault()\n            )\n        ), false)\n        \n        var.View\n        |> View.Sink (fun value ->\n            if value <> cur() then \n                let url = Router.Link router value\n                JS.Window.History.PushState(null, null, url)\n        )\n\n    /// Installs client-side routing on the full URL. \n    /// If initials URL parse fails, value is set to `onParseError`. \n    let Install onParseError (router: Router<'T>) : Var<'T> =\n        let parse p = Router.Parse router p\n        let var = Var.Create (getCurrent parse onParseError)\n        InstallInto var onParseError router\n        var\n\n    let private getCurrentHash parse onParseError =\n        let h = JS.Window.Location.Hash\n        match parse h with\n        | Some a -> \n            a\n        | None ->\n            printfn \"Failed to parse route: %s\" h \n            onParseError\n\n    /// Installs client-side routing on the hash part of the URL. \n    /// If initials URL parse fails, value is left as the initial value of `var`.\n    let InstallHashInto (var: Var<'T>) onParseError (router: Router<'T>) =\n        let parse h = \n            let p = Route.FromHash(h, true)\n            Router.Parse router p\n        let cur() : 'T = getCurrentHash parse onParseError\n        let set value =\n            if var.Value <> value then\n                var.Value <- value\n       \n        JS.Window.AddEventListener(\"popstate\", (fun () -> set (cur())), false)\n        JS.Window.AddEventListener(\"hashchange\", (fun () -> set (cur())), false)\n\n        JS.Document.Body.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            findLinkHref (As ev.Target)\n            |> Option.bind (fun href -> if href.StartsWith \"#\" then parse href else None)\n            |> Option.iter (fun a ->\n                set a\n                ev.PreventDefault()\n            )\n        ), false)\n\n        var.View\n        |> View.Sink (fun value ->\n            if value <> cur() then \n                let url = Router.HashLink router value\n                JS.Window.History.PushState(null, null, url)\n        )\n\n    /// Installs client-side routing on the hash part of the URL. \n    /// If initials URL parse fails, value is set to `onParseError`. \n    let InstallHash onParseError (router: Router<'T>) =\n        let parse h = \n            let p = Route.FromHash(h, true)\n            Router.Parse router p\n        let cur() : 'T = getCurrentHash parse onParseError\n        let var = Var.Create (cur())\n        InstallHashInto var onParseError router\n        var\n\nopen System.Runtime.CompilerServices\n\n[<Extension; JavaScript>]\ntype RouterExtensions =\n\n    [<Extension; Inline>]\n    static member Install(router, onParseError) =\n        Router.Install onParseError router\n\n    [<Extension; Inline>]\n    static member InstallHash(router, onParseError) =\n        Router.InstallHash onParseError router\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n// NOTES: need better facilities for the user to construct routers. In particular,\n// should be possible to encode numbers, semi-automatically provide bijections,\n// and so on.\n\nopen WebSharper\nopen WebSharper.JavaScript\nmodule A = AppendList\nmodule T = Trie\n\ntype RouteMap<'T> =\n    {\n        Des : (list<string> * Map<string, string>) -> 'T\n        Ser : 'T -> (list<string> * Map<string, string>)\n    }\n\n[<JavaScript>]\nmodule Route =\n\n    let private NoHash (s: string) =\n        if s.StartsWith(\"#\") then s.Substring(1) else s\n\n    [<Inline \"decodeURIComponent($x)\">]\n    let private Decode (x: string) : string = JS.Undefined\n\n    [<Inline \"encodeURIComponent($x)\">]\n    let private Encode (x: string) : string = JS.Undefined\n\n    type T =\n        private\n        | Route of AppendList<string> * Map<string, string>\n\n    let ParseHash (hash: string) =\n        let hash = NoHash hash\n        let path, query =\n            match hash.IndexOf '?' with\n            | -1 -> hash, \"\"\n            | i -> hash.[..i-1], hash.[i+1..]\n        let path =\n            if path = \"\" then [||] \n            else path.Split('/') |> Array.map Decode\n            |> A.FromArray\n        let query =\n            query.Split('&')\n            |> Array.map (fun s ->\n                match s.IndexOf '=' with\n                | -1 -> Decode s, \"\"\n                | i -> Decode (s.[..i-1]), Decode (s.[i+1..]))\n            |> Map.ofArray\n        Route (path, query)\n\n    let MakeHash (Route (path, query)) =\n        let path =\n            A.ToArray path\n            |> Array.map Encode\n            |> String.concat \"/\"\n        if Map.isEmpty query then\n            path\n        else\n            path + \"?\" +\n            (query\n            |> Seq.map (fun (KeyValue(k, v)) -> Encode k + \"=\" + Encode v)\n            |> String.concat \"&\")\n\n    let SameHash a b =\n        NoHash a = NoHash b\n\n    let ToList (Route (rt, q)) =\n        let path =\n            A.ToArray rt\n            |> Array.toList\n        path, q\n\n    let FromList (xs, q) =\n        let a =\n            List.toArray xs\n            |> A.FromArray\n        Route(a, q)\n\n    let Append (Route (pa, qa)) (Route (pb, qb)) =\n        Route (A.Append pa pb, Map.foldBack Map.add qa qb)\n\n[<JavaScript>]\nmodule Routing =\n\n    let InstallMap (rt: RouteMap<'T>) : Var<'T> =\n        let win = JS.Window\n        let same a b = rt.Ser a = rt.Ser b\n        let cur () =\n            Route.ParseHash win.Location.Hash\n            |> Route.ToList\n            |> rt.Des\n        let var = Var.Create (cur ())\n        let set value =\n            if not (same var.Value value) then\n                var.Value <- value\n        let onUpdate = System.Action<_>(fun (evt: Dom.Event) -> set (cur ()))\n        win.Onpopstate <- onUpdate\n        win.Onhashchange <- onUpdate\n        var.View\n        |> View.Sink (fun loc ->\n            let ha = Route.MakeHash (Route.FromList (rt.Ser loc))\n            if not (Route.SameHash win.Location.Hash ha) then\n                win.Location.Replace (\"#\" + ha))\n        var\n\n    let DoRoute map route =\n        map.Des (Route.ToList route)\n\n    let DoLink map va =\n        Route.FromList (map.Ser va)\n\n[<JavaScript>]\n[<Sealed>]\ntype RouteMap =\n\n    static member CreateWithQuery ser des =\n        { Ser = ser; Des = des }\n\n    static member Create ser des =\n        { Ser = (fun x -> ser x, Map.empty); Des = fst >> des }\n\n    static member Install map =\n        Routing.InstallMap map\n", "namespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Notation\nopen WebSharper.JQuery\n\n[<JavaScript>]\nmodule Input =\n\n    type MousePosSt =\n        {\n            mutable Active : bool\n            PosV : Var<int * int>\n        }\n\n    type MouseBtnSt =\n        {\n            mutable Active : bool\n            Left : Var<bool>\n            Middle : Var<bool>\n            Right : Var<bool>\n        }\n\n    let MousePosSt = { Active = false; PosV = Var.Create (0, 0) }\n    let MouseBtnSt =\n        {\n            Active = false;\n            Left = Var.Create false\n            Middle = Var.Create false\n            Right = Var.Create false\n        }\n\n    // Add the button listener if it hasn't been added already.\n    // Button listener adds mousedown and mouseup events, which modify\n    // MouseBtnSt vars.\n    let ActivateButtonListener =\n        let buttonListener (evt: Dom.MouseEvent) down =\n            match evt.Button with\n            | 0 -> Var.Set MouseBtnSt.Left down\n            | 1 -> Var.Set MouseBtnSt.Middle down\n            | 2 -> Var.Set MouseBtnSt.Right down\n            | _ -> ()\n\n        if not MouseBtnSt.Active then\n            MouseBtnSt.Active <- true\n            JS.Document.AddEventListener(\"mousedown\",\n                (fun (evt: Dom.Event) -> buttonListener (evt :?> Dom.MouseEvent) true), false)\n            JS.Document.AddEventListener(\"mouseup\",\n                (fun (evt: Dom.Event) -> buttonListener (evt :?> Dom.MouseEvent) false), false)\n\n    [<Sealed>]\n    type Mouse =\n\n        static member Position =\n\n            let onMouseMove (evt: Dom.Event) =\n                // We know this is a mouse event, so safe to downcast\n                let mEvt = evt :?> Dom.MouseEvent\n                Var.Set MousePosSt.PosV (mEvt.ClientX, mEvt.ClientY)\n\n            // Add the mouse movement event if it's not there already.\n            if not MousePosSt.Active then\n                JS.Document.AddEventListener(\"mousemove\", onMouseMove, false)\n                MousePosSt.Active <- true\n\n            View.FromVar MousePosSt.PosV\n\n        static member LeftPressed =\n            ActivateButtonListener\n            MouseBtnSt.Left.View\n\n        static member MiddlePressed =\n            ActivateButtonListener\n            MouseBtnSt.Middle.View\n\n        static member RightPressed =\n            ActivateButtonListener\n            MouseBtnSt.Right.View\n\n        static member MousePressed =\n            ActivateButtonListener\n            // True if any button is pressed\n            View.Const (fun l m r -> l || m || r)\n            <*> MouseBtnSt.Left.View\n            <*> MouseBtnSt.Middle.View\n            <*> MouseBtnSt.Right.View\n\n    type Key = int\n\n    // State for keyboard listener: which keys are pressed, whether the listener\n    // is active, and the last key that has been presed\n    type KeyListenerSt =\n        {\n            KeysPressed : Var<Key list>\n            mutable KeyListenerActive : bool\n            LastPressed : Var<Key>\n        }\n\n    let KeyListenerState =\n        {\n            KeysPressed = Var.Create []\n            KeyListenerActive = false\n            LastPressed = Var.Create (-1)\n        }\n\n    let ActivateKeyListener =\n        if not KeyListenerState.KeyListenerActive then\n            // Using JQuery for cross-compatibility.\n            JQuery.Of(JS.Document).Keydown(fun el evt ->\n                let keyCode = evt.Which\n                Var.Set KeyListenerState.LastPressed keyCode\n                let xs = Var.Get KeyListenerState.KeysPressed\n                if not (List.exists (fun x -> x = keyCode) xs) then\n                    KeyListenerState.KeysPressed.Value <- xs @ [keyCode]\n            ) |> ignore\n\n            JQuery.Of(JS.Document).Keyup(fun el evt ->\n                let keyCode = evt.Which\n                Var.Update KeyListenerState.KeysPressed\n                    (List.filter (fun x -> x <> keyCode))\n            ) |> ignore\n\n    [<Sealed>]\n    type Keyboard =\n\n        static member KeysPressed =\n            ActivateKeyListener\n            KeyListenerState.KeysPressed.View\n\n        static member LastPressed =\n            ActivateKeyListener\n            KeyListenerState.LastPressed.View\n\n        static member IsPressed key =\n            ActivateKeyListener\n            View.Map (List.exists (fun x -> x = key))\n                KeyListenerState.KeysPressed.View\n"],
"names": [],
"mappings": "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"
}
