<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpLint.Core</name></assembly>
<members>
<member name="T:FSharpLint.Application.ConfigurationManagement.ConfigFailure.RunTimeConfigError">
<summary>
 Failed to analyse a loaded FSharpLint configuration at runtime e.g. invalid hint.
</summary>
</member>
<member name="T:FSharpLint.Application.ConfigurationManagement.ConfigFailure.FailedToLoadConfig">
<summary>
 Failed to load a FSharpLint configuration file.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManagement.loadConfigurationForProject(System.String)">
<summary>
 Loads the FSharpLint configuration for a project given the path to the `.fsproj` file.
 It picks up configurations in any directory between the root directory and the project&apos;s directory.
 The closer they are to the project directory the higher precedence they have.
 e.g. if the project directory is C:\User\Matt\Project then a config file found in 
 C:\User\ will be loaded before and overridden by a config file found in C:\User\Matt\.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManagement.overrideDefaultConfiguration(FSharpLint.Framework.Configuration.Configuration)">
<summary>
 Overrides the default FSharpLint configuration.
 The default FSharpLint configuration contains all required elements, so
 by overriding it any missing required elements will be added to the returned configuration.
 If you&apos;re loading your own configuration you should make sure that it overrides the default 
 configuration/overrides a configuration that has overriden the default configuration.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManagement.overrideConfigurationFile(FSharpLint.Framework.Configuration.Configuration,FSharpLint.Framework.Configuration.Configuration)">
<summary>
 Overrides a given FSharpLint configuration file with another.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManagement.loadConfigurationFile(System.String)">
<summary>
 Load a FSharpLint configuration file from the contents (string) of the file.
</summary>
</member>
<member name="T:FSharpLint.Application.ConfigurationManagement">
<summary>
 Provides an API to manage/load FSharpLint configuration files.
 &lt;see cref=&quot;FSharpLint.Framework.Configuration&quot; /&gt; for more information on
 the default configuration and overriding configurations.
</summary>
</member>
<member name="T:FSharpLint.Application.ConfigurationManager.ConfigurationManager">
<summary>
 Loads and stores configurations in memory so that they can easily be modified
 and written back out to disk.
 Intended to allow for all the configuration files for all the projects in a solution
 to be grouped in a single place where they can be modified.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManager.tryLoadConfig(System.String)">
<summary>
 Tries to load a config from disk.
 If it fails to load the config any exception will be swallowed and `None` returned.
 If the file does not exist `None` will be returned.
</summary>
</member>
<member name="M:FSharpLint.Application.ConfigurationManager.getParentDirectories(System.String)">
<summary>
 Gets all the parent directories of a given path - includes the original path directory too.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintResult">
<summary>
 Result of running the linter.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.FailedToParseFilesInProject">
<summary>
 `FSharp.Compiler.Services` failed when trying to parse one or more files in a project.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.FailedToParseFile">
<summary>
 `FSharp.Compiler.Services` failed when trying to parse a file.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.RunTimeConfigError">
<summary>
 Failed to analyse a loaded FSharpLint configuration at runtime e.g. invalid hint.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.FailedToLoadConfig">
<summary>
 Failed to load a FSharpLint configuration file.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.MSBuildFailedToLoadProjectFile">
<summary>
 Received exception when trying to get the list of F# file from the project file.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure.ProjectFileCouldNotBeFound">
<summary>
 Project file path did not exist on the local filesystem.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.LintFailure">
<summary>
 Reason for the linter failing.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.ParsedFileInformation.FSharpVersion">
<summary>
 Version of F# the source code of the file was written in.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.ParsedFileInformation.TypeCheckResults">
<summary>
 Optional results of inferring the types on the AST (allows for a more accurate lint).
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.ParsedFileInformation.Source">
<summary>
 Contents of the file.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.ParsedFileInformation.Ast">
<summary>
 File represented as an AST.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.ParsedFileInformation">
<summary>
 If your application has already parsed the F# source files using `FSharp.Compiler.Services` 
 you want to lint then this can be used to provide the parsed information to prevent the 
 linter from parsing the file again.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.OptionalLintParameters.ReceivedWarning">
<summary>
 This function will be called every time the linter finds a broken rule.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.OptionalLintParameters.Configuration">
<summary>
 Provide your own FSharpLint configuration to the linter.
 If not provided the default configuration will be used.
</summary>
</member>
<member name="P:FSharpLint.Application.Lint.OptionalLintParameters.CancellationToken">
<summary>
 Cancels a lint in progress.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.OptionalLintParameters">
<summary>
 Optional parameters that can be provided to the linter.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.ProjectProgress.Failed">
<summary>
 Failed to parse a file (file path, exception that caused failure).
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.ProjectProgress.ReachedEnd">
<summary>
 Finished parsing a file (file path).
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.ProjectProgress.Starting">
<summary>
 Started parsing a file (file path).
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.ProjectProgress.FilePath">
<summary>
 Path of the F# file the progress information is for.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint.ProjectProgress">
<summary>
 Provides information on what the linter is currently doing.
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.lintParsedFile(FSharpLint.Application.Lint.OptionalLintParameters,FSharpLint.Application.Lint.ParsedFileInformation,System.String)">
<summary>
 Lints an F# file that has already been parsed using 
 `FSharp.Compiler.Services` in the calling application. 
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.lintFile(FSharpLint.Application.Lint.OptionalLintParameters,System.String,System.Version)">
<summary>
 Lints an F# file from a given path to the `.fs` file.
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.lintParsedSource(FSharpLint.Application.Lint.OptionalLintParameters,FSharpLint.Application.Lint.ParsedFileInformation)">
<summary>
 Lints F# source code that has already been parsed using 
 `FSharp.Compiler.Services` in the calling application.
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.lintSource(FSharpLint.Application.Lint.OptionalLintParameters,System.String,System.Version)">
<summary>
 Lints F# source code.
</summary>
</member>
<member name="M:FSharpLint.Application.Lint.lintProject(FSharpLint.Application.Lint.OptionalLintParameters,System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharpLint.Application.Lint.ProjectProgress,Microsoft.FSharp.Core.Unit}})">
<summary>
 Lints an entire F# project by retrieving the files from a given 
 path to the `.fsproj` file.
</summary>
</member>
<member name="T:FSharpLint.Application.Lint">
<summary>
 Provides an API for running FSharpLint from within another application. 
</summary>
</member>
<member name="P:FSharpLint.Application.LintWarning.Warning.Fix">
<summary>
 Suggested fix for the warning.
</summary>
</member>
<member name="P:FSharpLint.Application.LintWarning.Warning.Input">
<summary>
 Entire input file, needed to display where in the file the error occurred.
</summary>
</member>
<member name="P:FSharpLint.Application.LintWarning.Warning.Range">
<summary>
 Location of the warning.
</summary>
</member>
<member name="P:FSharpLint.Application.LintWarning.Warning.Info">
<summary>
 Warning to display to the user.
</summary>
</member>
<member name="T:FSharpLint.Application.LintWarning.Warning">
<summary>
 A lint warning - information on where a lint rule was found to be broken.
</summary>
</member>
<member name="P:FSharpLint.Application.LintWarning.getWarningWithLocation">
<summary>
 Generates a message including highlighting where in the code the warning was found along with
 stating the location of where the warning occurred. (warningInfoLine and getWarningMessage) combined.
</summary>
</member>
<member name="M:FSharpLint.Application.LintWarning.warningInfoLine(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.String},Microsoft.FSharp.Compiler.Range.range,System.String)">
<summary>
 Generates a message including highlighting where in the code the warning was found.
</summary>
</member>
<member name="M:FSharpLint.Application.LintWarning.getWarningMessage(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Gets a message stating where a lint warning occured.
</summary>
</member>
<member name="T:FSharpLint.Application.LintWarning">
<summary>
 Contains functionality to help report lint warnings.
</summary>
</member>
<member name="M:FSharpLint.Framework.Resources.GetString(System.String,System.Globalization.CultureInfo)">
<summary>
 Returns the value of the specified string resource for a given culture.
</summary>
</member>
<member name="M:FSharpLint.Framework.Resources.GetString(System.String)">
<summary>
 Returns the value of the specified string resource for the current culture.
</summary>
</member>
<member name="T:FSharpLint.Framework.Resources">
<summary>
 Provides a way of getting string values from the framework&apos;s resource files (files in src/FSharpLint.Framework/Resources/).
 Used to retrieve multi-lingual strings inside of the app.
</summary>
</member>
<member name="P:FSharpLint.Framework.AbstractSyntaxArray.CurrentNode.SuppressedMessages">
<summary>
 Suppressed message attributes that have been applied to the block of code 
 the current node is within.
</summary>
</member>
<member name="P:FSharpLint.Framework.AbstractSyntaxArray.CurrentNode.Breadcrumbs">
<summary>
 A list of parent nodes e.g. parent, grand parent, grand grand parent.
</summary>
</member>
<member name="M:FSharpLint.Framework.AbstractSyntaxArray.CurrentNode.IsSuppressed(System.String,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Has a given rule been suppressed by SuppressMessageAttribute?
</summary>
</member>
<member name="T:FSharpLint.Framework.AbstractSyntaxArray.CurrentNode">
<summary>
 Contains information on the current node being visited.
</summary>
</member>
<member name="T:FSharpLint.Framework.AbstractSyntaxArray.TempSkip">
<summary>
 Keep index of position so skip array can be created in the correct order.
</summary>
</member>
<member name="M:FSharpLint.Framework.AbstractSyntaxArray.getHashCode(FSharpLint.Framework.Ast.AstNode)">
<summary>
 Get hash code of an ast node to be used for the fuzzy match of hints against the ast.
</summary>
</member>
<member name="M:FSharpLint.Framework.AbstractSyntaxArray.getIdentHash``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 We just want a hash of the last identifier.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.AnalyserInfo.Text">
<summary>
 Source of the current file being analysed.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.AnalyserInfo.Suggest">
<summary>
 Used by visitors to report warnings.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.AnalyserInfo.Config">
<summary>
 The current lint config to be used by visitors.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.AnalyserInfo.FSharpVersion">
<summary>
 Version of F# the source that&apos;s being analysed was written in.
</summary>
</member>
<member name="M:FSharpLint.Framework.Analyser.AnalyserInfo.TryFindTextOfRange(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Tries to find the source code within a given range.
</summary>
</member>
<member name="T:FSharpLint.Framework.Analyser.AnalyserInfo">
<summary>
 Passed to each analyser to provide them with access to the configuration and a way of reporting errors.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.LintSuggestion.TypeChecks">
<summary>
 Async type checks to be performed to confirm this suggestion is valid.
 Suggestion is only considered valid when all type checks resolve to true.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.LintSuggestion.SuggestedFix">
<summary>
 Information to provide an automated fix.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.LintSuggestion.Message">
<summary>
 Suggestion message to describe the possible problem to the user.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.LintSuggestion.Range">
<summary>
 Location of the code that prompted the suggestion.
</summary>
</member>
<member name="T:FSharpLint.Framework.Analyser.LintSuggestion">
<summary>
 A lint &quot;warning&quot;, sources the location of the warning with a suggestion on how it may be fixed.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.SuggestedFix.ToText">
<summary>
 Text to replace the `FromText`, i.e. the fix.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.SuggestedFix.FromRange">
<summary>
 Location of the text to be replaced.
</summary>
</member>
<member name="P:FSharpLint.Framework.Analyser.SuggestedFix.FromText">
<summary>
 Text to be replaced.
</summary>
</member>
<member name="T:FSharpLint.Framework.Analyser.SuggestedFix">
<summary>
 Information for consuming applications to provide an automated fix for a lint suggestion.
</summary>
</member>
<member name="T:FSharpLint.Framework.Ast.AstNode">
<summary>
 Nodes in the AST to be visited.
</summary>
</member>
<member name="P:FSharpLint.Framework.Ast.SuppressedMessage.Rule">
<summary>
 CheckId property of the SuppressedMessageAttribute. (The name of the rule to be suppressed).
</summary>
</member>
<member name="P:FSharpLint.Framework.Ast.SuppressedMessage.Category">
<summary>
 Category property of the SuppressedMessageAttribute. (The name of the analyser to be suppressed).
</summary>
</member>
<member name="T:FSharpLint.Framework.Ast.SuppressedMessage">
<summary>
 Represents a SuppressedMessageAttribute found in the AST.
</summary>
</member>
<member name="M:FSharpLint.Framework.Ast.traverseNode(FSharpLint.Framework.Ast.AstNode,Microsoft.FSharp.Core.FSharpFunc{FSharpLint.Framework.Ast.Node,Microsoft.FSharp.Core.Unit})">
<summary>
 Extracts the child nodes to be visited from a given node.
</summary>
</member>
<member name="M:FSharpLint.Framework.Ast.|StringLiteral|_|(FSharpLint.Framework.Ast.AstNode)">
<summary>
 Gets a string literal from the AST.
</summary>
</member>
<member name="M:FSharpLint.Framework.Ast.|FuncApp|_|(FSharpLint.Framework.Ast.AstNode)">
<summary>
 Inlines pipe operators to give a flat function application expression
 e.g. `x |&gt; List.map id` to `List.map id x`. 
</summary>
</member>
<member name="M:FSharpLint.Framework.Ast.removeParens(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Extracts an expression from parentheses e.g. ((x + 4)) -&gt; x + 4
</summary>
</member>
<member name="M:FSharpLint.Framework.Ast.getSuppressMessageAttributes(FSharpLint.Framework.Ast.AstNode)">
<summary>
 Gets any SuppressMessageAttributes that are applied to a given node in the AST.
</summary>
</member>
<member name="T:FSharpLint.Framework.Ast">
<summary>
 Used to walk the FSharp Compiler&apos;s abstract syntax tree,
 so that each node can be visited by a list of visitors.
</summary>
</member>
<member name="M:FSharpLint.Framework.AstInfo.isOperator(System.String)">
<summary>
 Is an identifier an operator overload?
</summary>
</member>
<member name="P:FSharpLint.Framework.AstInfo.operators">
<summary>
 Operator identifiers can be made up of &quot;op_&quot; followed by a sequence of operators from this list.
</summary>
</member>
<member name="T:FSharpLint.Framework.Configuration.Analyser">
<summary>
 An analyser groups together related rules in the configuration file.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.isRuleEnabled(FSharpLint.Framework.Configuration.Configuration,System.String,System.String)">
<summary>
 Checks if a rule in the configuration is enabled and the analyser it&apos;s within is also enabled.
 Returns the analyser settings and rule settings if the rule was enabled; None otherwise.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.isAnalyserEnabled(FSharpLint.Framework.Configuration.Configuration,System.String)">
<summary>
 Checks if a analyser in the configuration is enabled.
 Returns the analyser settings if the analyser was enabled; None otherwise.
</summary>
</member>
<member name="P:FSharpLint.Framework.Configuration.defaultConfiguration">
<summary>
 A default configuration specifying every analyser and rule is included as a resource file in the framework.
 This function loads and returns this default configuration.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.updateConfigMap(FSharpLint.Framework.Configuration.Configuration,FSharpLint.Framework.Configuration.Configuration,FSharpLint.Framework.Configuration.Configuration)">
<summary>
 Updates a partial config adding only changes - so only what is needed is added to the config.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.mergeRules``1(Microsoft.FSharp.Collections.FSharpMap{``0,FSharpLint.Framework.Configuration.Rule},Microsoft.FSharp.Collections.FSharpMap{``0,FSharpLint.Framework.Configuration.Rule},Microsoft.FSharp.Collections.FSharpMap{``0,FSharpLint.Framework.Configuration.Rule})">
<summary>
 Merges rules from `diff` and `partial` with rules and settings
 within rules from `diff` taking precedence.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.mergeSettings``3(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``2},Microsoft.FSharp.Collections.FSharpMap{``0,``2})">
<summary>
 Merges settings from `diff` and `partial` with settings from
 `diff` taking precedence.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.overrideConfiguration(FSharpLint.Framework.Configuration.Configuration,FSharpLint.Framework.Configuration.Configuration)">
 <summary>
 Loads a "higher precedence" configuration file. All the properties in the file we're loading overwrite
 the same properties in our previous configuration with the new values, any properties that don't exist
 in the previous configuration are added, and any properties that don't exist in the configuration being
 loaded are left alone.
 </summary>
 <param name="file">Path of the configuration file that will override the existing configuration</param>
</member>
<member name="M:FSharpLint.Framework.Configuration.configuration(System.String)">
<summary>
 Parse a configuration file.
</summary>
</member>
<member name="P:FSharpLint.Framework.Configuration.Management.LoadedConfigs.GlobalConfigs">
<summary>
 Global configuration files in order of precedence.
 All PathsAdded will override these files.
</summary>
</member>
<member name="P:FSharpLint.Framework.Configuration.Management.LoadedConfigs.PathsAdded">
<summary>
 Full paths added, there could be multiple &lt;see cref=&quot;LoadedConfigs.LoadedConfigs&quot; /&gt;
 for each full path. If you wanted to load the configurations for a solution
 this should be a list of absolute paths to the project directories.
</summary>
</member>
<member name="P:FSharpLint.Framework.Configuration.Management.LoadedConfigs.LoadedConfigs">
<summary>
 Cached configurations for each path.
</summary>
</member>
<member name="T:FSharpLint.Framework.Configuration.Management.LoadedConfigs">
<summary>
 Keeps configuration files loaded for a list of paths so that
 they can be quickly retrieved and updated
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.normalisePath(System.String)">
<summary>
 Tries to normalise paths to a format that can be used as a path in &lt;see cref=&quot;LoadedConfigs&quot; /&gt;.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.updateConfig(FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{FSharpLint.Framework.Configuration.Configuration})">
<summary>
 Updates a configuration file at a given path.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.getConfig(FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Gets the complete configuration file located at a given path.
 &quot;complete&quot; configuration means that it has overridden any previous
 configuration files.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.getPartialConfig(FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Gets the configuration file located at a given path.
 The configuration file returned may be incomplete as it
 will not have overrided any previous configuration files.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.refresh(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{FSharpLint.Framework.Configuration.Configuration}},FSharpLint.Framework.Configuration.Management.LoadedConfigs)">
<summary>
 Tries to reload the configuration for all paths.
 Call when the user has edited a configuration file on disk.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.commonPath(FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Attempts to get a path that is common to all paths
 that have been added to a node.
 If a given preferred path is found to be a common path then
 that path will always be returned, useful if you want to prefer
 the solution directory for example.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.updatePaths(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{FSharpLint.Framework.Configuration.Configuration}},FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 With a given list of paths, any paths loaded not in the list will be removed
 and any in the list but not loaded will be added.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.removePath(FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Removes a loaded path and all cached configurations that aren&apos;t used by any other paths.
</summary>
</member>
<member name="M:FSharpLint.Framework.Configuration.Management.addPath(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{FSharpLint.Framework.Configuration.Configuration}},FSharpLint.Framework.Configuration.Management.LoadedConfigs,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Loads all configurations needed to form a complete configuration for a given path.
 A `complete configuration` is one that has overridden every configuration file in ancestor directories.
</summary>
</member>
<member name="T:FSharpLint.Framework.Configuration.Management">
<summary>
 Module to manage the loading and updating of configuration files.
 Keeps loaded configurations cached in memory so they can be quickly retrieved.
</summary>
</member>
<member name="P:FSharpLint.Framework.Configuration.IgnoreFiles.IgnoreFilesConfig.Content">
<summary>
 Unparsed value from the configuration XML file.
 Stored so it can be written back out to a file.
</summary>
</member>
<member name="T:FSharpLint.Framework.Configuration">
<summary>
 Loads configuration files from xml into an object.
 When a configuration file has already been loaded, loading another one overwrites the existing configuration.
 The overwrite works by only changing existing properties with properties from the new file,
 so properties in the original configuration file not in the new configuration file will remain.
</summary>
</member>
<member name="M:FSharpLint.Framework.ExpressionUtilities.findPos(Microsoft.FSharp.Compiler.Range.pos,System.String)">
<summary>
 Finds index of a given (line number, column) position in a string.
</summary>
</member>
<member name="M:FSharpLint.Framework.ExpressionUtilities.removeParens(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Extracts an expression from parentheses e.g. ((x + 4)) -&gt; x + 4
</summary>
</member>
<member name="M:FSharpLint.Framework.ExpressionUtilities.identAsDecompiledOpName(Microsoft.FSharp.Compiler.Ast.Ident)">
<summary>
 Converts an operator name e.g. op_Add to the operator symbol e.g. +
</summary>
</member>
<member name="M:FSharpLint.Framework.FuzzyHintMatcher.possibleMatches(FSharpLint.Framework.AbstractSyntaxArray.Node[],FSharpLint.Framework.AbstractSyntaxArray.Skip[],FSharpLint.Framework.HintParser.MergeSyntaxTrees.Edges,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharpLint.Framework.HintParser.Hint,Microsoft.FSharp.Core.Unit}})">
<summary>
 Searches the abstract syntax array for possible hint matches using the hint trie.
 Any possible matches that are found will be given to the callback function `notify`,
 any matches found are not guaranteed and it&apos;s expected that the caller verify the match.
</summary>
</member>
<member name="M:FSharpLint.Framework.FuzzyHintMatcher.checkTrie(System.Int32,FSharpLint.Framework.HintParser.MergeSyntaxTrees.Node,FSharpLint.Framework.AbstractSyntaxArray.Node[],FSharpLint.Framework.AbstractSyntaxArray.Skip[],System.Collections.Generic.Dictionary{System.Char,System.Int32},Microsoft.FSharp.Core.FSharpFunc{FSharpLint.Framework.HintParser.Hint,Microsoft.FSharp.Core.Unit})">
<summary>
 Compares the hint trie against a given location in the abstract syntax array.
</summary>
</member>
<member name="M:FSharpLint.Framework.FuzzyHintMatcher.isMatch(System.Int32,System.Int32,FSharpLint.Framework.AbstractSyntaxArray.Node[],FSharpLint.Framework.AbstractSyntaxArray.Skip[])">
<summary>
 Confirms if two parts of the ast look alike.
 This is required as hints can bind variables: the bound location needs to be compared to
 parts of the ast that the hint covers with the same variable.
</summary>
</member>
<member name="T:FSharpLint.Framework.FuzzyHintMatcher">
<summary>
 Matching hints is done in two passes: fuzzy match, and an untyped ast match.
 The untyped ast match attempts to match a single hint against a given node in the ast,
 to avoid attempting every hint against every node, an initial pass (the fuzzy match) is done
 to eliminate as many cases where there&apos;ll never be a match as quickly as possible, so that the
 ast match is run against as few hints and ast nodes as possible.
 
 The fuzzy match requires two structures to be computed before hand: an abstract syntax array 
 constructed from the ast, and a trie of hints. Both of these structures contain hash codes of the 
 nodes, the hash codes are expected to match when the nodes are equivalent. The matching is done using these
 hash codes so we end up with a trie of integers searching against an array of integers -
 which is pretty fast.
</summary>
</member>
<member name="T:FSharpLint.Framework.HintParser.NumericLiterals">
<summary>
 Not supporting hex single and hex float right now.
 Decimal float currently will lose precision.
</summary>
</member>
<member name="T:FSharpLint.Framework.HintParser.Identifiers">
<summary>
 Need to change isLetter so that it&apos;s using unicode character classes.
</summary>
</member>
<member name="M:FSharpLint.Framework.HintParser.MergeSyntaxTrees.transposeHead(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharpLint.Framework.HintParser.HintNode,System.Int32}},FSharpLint.Framework.HintParser.Hint}})">
<summary>
 Gets the head of each given list
</summary>
</member>
<member name="T:FSharpLint.Framework.HintParser.MergeSyntaxTrees">
<summary>
 Provides a way of creating a single list from any number of hint ASTs.
 Means we can simply iterate over a single list for each node in the F# tree
 when matching hints rather than check each hint AST for each node.
</summary>
</member>
<member name="P:FSharpLint.Framework.ParseFile.FileParseInfo.File">
<summary>
 Path to the file.
</summary>
</member>
<member name="P:FSharpLint.Framework.ParseFile.FileParseInfo.TypeCheckResults">
<summary>
 Optional results of inferring the types on the AST (allows for a more accurate lint).
</summary>
</member>
<member name="P:FSharpLint.Framework.ParseFile.FileParseInfo.Ast">
<summary>
 File represented as an AST.
</summary>
</member>
<member name="P:FSharpLint.Framework.ParseFile.FileParseInfo.Text">
<summary>
 Contents of the file.
</summary>
</member>
<member name="T:FSharpLint.Framework.ParseFile.FileParseInfo">
<summary>
 Information for a file to be linted that is given to the analysers.
</summary>
</member>
<member name="M:FSharpLint.Framework.ParseFile.parseSource``1(System.String,``0,Microsoft.FSharp.Compiler.SourceCodeServices.FSharpChecker)">
<summary>
 Parses source code using `FSharp.Compiler.Service`.
</summary>
</member>
<member name="M:FSharpLint.Framework.ParseFile.parseFile``1(System.String,``0,Microsoft.FSharp.Compiler.SourceCodeServices.FSharpChecker,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.SourceCodeServices.FSharpProjectOptions})">
<summary>
 Parses a file using `FSharp.Compiler.Service`.
</summary>
</member>
<member name="M:FSharpLint.Framework.ParseFile.getProjectOptionsFromScript(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpChecker,System.String,System.String)">
<summary>
 Todo: Remove this when fsharp.core is updated to version that no longer requires sigdata/optdata
 Added this as FSharp.Core was resolving to GAC where there&apos;s no sigdata/optdata
</summary>
</member>
<member name="T:FSharpLint.Framework.ParseFile">
<summary>
 Provides functionality to parse F# files using `FSharp.Compiler.Service`.
</summary>
</member>
<member name="M:FSharpLint.Framework.Utilities.hash2``2(``0,``1)">
<summary>
 Fast hash of two objects without having to allocate 
 (e.g. a common approach would be to take the hash code of a tuple of the two objects).
</summary>
</member>
<member name="M:FSharpLint.Rules.Binding.checkForBindingToAWildcard(FSharpLint.Framework.Analyser.AnalyserArgs,Microsoft.FSharp.Compiler.Ast.SynPat,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean})">
<summary>
 Checks if any code uses &apos;let _ = ...&apos; and suggests to use the ignore function.
</summary>
</member>
<member name="T:FSharpLint.Rules.FunctionReimplementation">
<summary>
 Checks a lambda function is not simply an &apos;abbreviation&apos; of another function.
 For example it will warn when it finds a lambda such as: fun a b -&gt; a * b as it is exactly the same as (*).
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.|RequiresCheck|CanBeReplaced|CannotBeReplaced|(Microsoft.FSharp.Collections.FSharpList{FSharpLint.Framework.Ast.AstNode},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check if lambda can be replaced with an identifier (cannot in the case when is a parameter with the type of a delegate).
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.canReplaceLambdaWithFunction(Microsoft.FSharp.Compiler.SourceCodeServices.FSharpCheckFileResults,Microsoft.FSharp.Compiler.Ast.LongIdentWithDots,System.Int32)">
<summary>
 Check a lambda function can be replaced with a function,
 it will not be if the lambda is automatically getting
 converted to a delegate type e.g. Func&lt;T&gt;.
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.matchConst(Microsoft.FSharp.Compiler.Ast.SynConst)">
<summary>
 Converts a SynConst (FSharp AST) into a Constant (hint AST).
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.MatchPattern.removeParens(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Extracts a pattern from parentheses e.g. ((x)) -&gt; x
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.MatchExpression.matchHintExpr(FSharpLint.Rules.HintMatcher.MatchExpression.Arguments)">
<summary>
 Check if in `new` expr or function application (either could be a constructor).
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.MatchExpression.notPropertyInitialisationOrNamedParameter(FSharpLint.Rules.HintMatcher.MatchExpression.Arguments,Microsoft.FSharp.Compiler.Ast.SynExpr,Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Check that an infix equality operation is not actually the assignment of a value to a property in a constructor
 or a named parameter in a method call.
</summary>
</member>
<member name="M:FSharpLint.Rules.HintMatcher.MatchExpression.removeParens(FSharpLint.Framework.Ast.AstNode)">
<summary>
 Extracts an expression from parentheses e.g. ((x + 4)) -&gt; x + 4
</summary>
</member>
<member name="M:FSharpLint.Rules.NameConventions.isAttribute(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynAttribute})">
<summary>
 Is an attribute with a given name?
 e.g. check for Literal attribute.
</summary>
</member>
<member name="P:FSharpLint.Rules.NameConventions.isNotDoubleBackTickedIdent">
<summary>
 Is an identifier not surrounded by double backticks? e.g. not `let ``some identifier`` = 0`.
 Unfortunately it&apos;s having to compare the length of the identifier in the source vs identifier length in AST,
 the information as to whether the identifier was backticked doesn&apos;t appear to be in the AST.
</summary>
</member>
<member name="T:FSharpLint.Rules.NameConventions">
<summary>
 Checks whether any code in an F# program violates best practices for naming identifiers.
</summary>
</member>
<member name="M:FSharpLint.Rules.NestedStatements.isCompilerGeneratedMatch(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Lambda wildcard arguments are named internally as _argN, a match is then generated for them in the AST.
 e.g. fun _ -&gt; () is represented in the AST as fun _arg1 -&gt; match _arg1 with | _ -&gt; ().
 This function returns true if the given match statement is compiler generated for a lmabda wildcard argument.
</summary>
</member>
<member name="T:FSharpLint.Rules.NumberOfItems">
<summary>
 Checks if a function is declared with more than a configurable number of parameters.
</summary>
</member>
</members>
</doc>
