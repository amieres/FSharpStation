{
"version": 3,
"sourceRoot": "Source",
"sources": ["testing/testing.fs", "WebSharper.Collections/BalancedTree.fs", "WebSharper.Collections/Pair.fs", "WebSharper.Collections/Map.fs", "WebSharper.Collections/MapModule.fs", "WebSharper.Collections/Set.fs", "WebSharper.Collections/SetModule.fs", "WebSharper.Collections/ResizeArray.fs", "WebSharper.Collections/LinkedList.fs", "WebSharper.Collections/Linq.fs", "WebSharper.Collections/Query.fs", "WebSharper.Main/Promise.fs", "WebSharper.Main/JavaScript.Pervasives.fs", "WebSharper.Main/Json.fs", "WebSharper.Main/Remoting.fs", "WebSharper.Main/Html.fs", "WebSharper.Main/Comparers.fs", "WebSharper.Main/Utils.fs", "WebSharper.Main/Concurrency.fs", "WebSharper.Main/Enumerator.fs", "WebSharper.Main/CollectionInternals.fs", "WebSharper.Main/Object.fs", "WebSharper.Main/IntrinsicFunctions.fs", "WebSharper.Main/Array.fs", "WebSharper.Main/ArrayModule.fs", "WebSharper.Main/Array2DModule.fs", "WebSharper.Main/Async.fs", "WebSharper.Main/Char.fs", "WebSharper.Main/CommonExtensions.fs", "WebSharper.Main/DateTime.fs", "WebSharper.Main/Delegate.fs", "WebSharper.Main/Dictionary.fs", "WebSharper.Main/Exception.fs", "WebSharper.Main/ExtraTopLevelOperators.fs", "WebSharper.Main/Guid.fs", "WebSharper.Main/HashSet.fs", "WebSharper.Main/Interfaces.fs", "WebSharper.Main/LazyExtensions.fs", "WebSharper.Main/List.fs", "WebSharper.Main/ListModule.fs", "WebSharper.Main/Nullable.fs", "WebSharper.Main/Operators.fs", "WebSharper.Main/OperatorIntrinsics.fs", "WebSharper.Main/OptionModule.fs", "WebSharper.Main/Queue.fs", "WebSharper.Main/Random.fs", "WebSharper.Main/ResultModule.fs", "WebSharper.Main/RuntimeHelpers.fs", "WebSharper.Main/SeqModule.fs", "WebSharper.Main/Stack.fs", "WebSharper.Main/String.fs", "WebSharper.Main/Task.fs", "WebSharper.Main/Unchecked.fs", "WebSharper.Main/ValueOption.fs", "WebSharper.Main/Primitives.fs", "WebSharper.Web/ClientSideJson.fs", "WebSharper.Web/Control.fs", "WebSharper.Sitelets/Router.fs", "WebSharper.Control/Observer.fs", "WebSharper.Control/HotStream.fs", "WebSharper.Control/Observable.fs", "WebSharper.Control/ObservableModule.fs", "WebSharper.Control/Event.fs", "WebSharper.Control/FSharpEvent.fs", "WebSharper.Control/EventModule.fs", "WebSharper.Control/MailboxProcessor.fs", "WebSharper.UI/Abbrev.fs", "WebSharper.UI/AppendList.fs", "WebSharper.UI/DomUtility.fs", "WebSharper.UI/Trie.fs", "WebSharper.UI/Snap.fs", "WebSharper.UI/Reactive.fs", "WebSharper.UI/Models.fs", "WebSharper.UI/ReactiveExtensions.fs", "WebSharper.UI/Animation.fs", "WebSharper.UI/Attr.fs", "WebSharper.UI/Attr.Client.fs", "WebSharper.UI/Doc.Proxy.fs", "WebSharper.UI/Templates.fs", "WebSharper.UI/Flow.fs", "WebSharper.UI/HTML.fs", "WebSharper.UI/Router.fs", "WebSharper.UI/Routing.fs", "WebSharper.UI/Input.fs"],
"sourcesContent": ["#nowarn \"1182\"\n#nowarn \"1178\"\n////-d:FSharpStation1547097944900 -d:WEBSHARPER\n//#I @\"..\\packages\\WebSharper\\lib\\net461\"\n//#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n//#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n//#nowarn \"1182\"\n//#nowarn \"1178\"\n/// Root namespace for all code\n//#define FSharpStation1547097944900\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        /// Essentials that can be converted to JavaScript with WebSharper\n        [< JavaScript ; AutoOpen >]\n        module Library =\n            let Error = Result.Error\n            /// call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\n            let [<Inline>] inline tee f v = f v ; v\n            \n            /// tee: call a function but return the input value\n            /// for logging, debugging\n            /// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\n            let [<Inline>] inline  (|>!) v f   = f v ; v\n            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n            \n            let inline print v = \n                match box v with\n                | :? string as s -> printfn \"%s\" s\n                | __             -> printfn \"%A\" v\n            \n            type System.String with\n                member this.Substring2(from, n) = \n                    if   n    <= 0           then \"\"\n                    elif from <  0           then this.Substring2(0, n + from)\n                    elif from >= this.Length then \"\"\n                    else this.Substring(from, min n (this.Length - from))\n                member this.Left             n  = this.Substring2(0, n)\n                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n            \n            module String =\n                let splitByChar (c: char) (s: string) = s.Split c\n                let splitInTwoO spl txt = \n                    let i = (txt:string).IndexOf (spl:string)\n                    if  i = -1 then None else\n                    (txt.Left(i), txt.Substring (i + spl.Length) )\n                    |> Some\n                let delimitedO  op cl txt =\n                    splitInTwoO op txt\n                    |> Option.bind(fun (bef, sec) ->\n                        splitInTwoO cl sec\n                        |> Option.map(fun (mid, aft) -> bef, mid, aft)\n                    )\n                let contains     sub  (whole: string) = whole.Contains sub\n                let trim                  (s: string) = s.Trim()\n                let append     (a: string)(b: string) =  a + b\n                let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n                let unindent (s:string) =\n                    let lines = s.Split '\\n'\n                    let n     = lines \n                                |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                                |> Option.defaultValue \"\"\n                                |> Seq.tryFindIndex ((<>) ' ') \n                                |> Option.defaultValue 0\n                    lines \n                    |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n                    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n                let indent n (s:string) =\n                    s.Split '\\n'\n                    |> Seq.map ((+) (String.replicate n \" \"))\n                let unindentStr = unindent >> String.concat \"\\n\"\n                let indentStr i = indent i >> String.concat \"\\n\" \n                let skipLastLine =\n                       splitByChar '\\n' \n                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n                    >> String.concat \"\\n\"\n                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n                \n            \n        /// Essentials that run in Javascript (WebSharper)\n        //#define WEBSHARPER\n        [< JavaScript ; AutoOpen >]\n        module LibraryJS =\n            module GenEditor =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    line : int\n                    col  : int\n                }\n            \n                type AnnotationType =\n                | Error   \n                | Warning \n                | Info    \n                | Hint\n                | Other of string\n            \n                type Annotation = {\n                    startP        : Position\n                    endP          : Position\n                    severity      : AnnotationType\n                    message       : string\n                }\n            \n                type Completion = {\n                    kind                : string\n                    label               : string\n                    detail              : string\n                    replace             : Position * Position\n                }\n            \n                type GenEditorHook<'T> = {\n                    generateDoc       :  unit            -> Doc\n                    getValue          :  unit            -> string\n                    setValue          :  string          -> unit\n                    setDisabled       :  bool            -> unit\n                    hookOnRender      : ('T     -> unit) -> unit\n                    hookOnChange      : (string -> unit) -> unit\n                    showAnnotations   :  Annotation seq  -> unit\n                }\n            \n                [<NoComparison ; NoEquality>]\n                type GenEditor<'T> = {\n                    var             : Var< string        >\n                    disabled        : View<bool          >\n                    annotations     : View<Annotation seq>\n                    onChange        : (string      -> unit                )\n                    onRender        : ('T          -> unit                )\n                    autoCompletion  : (Position    -> Async<Completion []>) option\n                    toolTip         : (Position    -> Async<string       >) option\n                    declaration     : (Position    -> Async<Position     >) option\n                    mutable editorO :  'T option\n            \n                    editorHook      : GenEditorHook<'T>\n                }\n                \n                let inline setVar   v   genE = { genE with var      = v   }\n                let inline onChange f   genE = { genE with onChange = f   }\n                let inline onRender f   genE = { genE with onRender = f   }\n                let inline disabled dis genE = { genE with disabled = dis }\n            \n                let inline var          genE = genE.var\n            \n                let newVar edh var = {\n                    var            = var \n                    disabled       = V false\n                    annotations    = V Seq.empty\n                    onChange       = ignore\n                    onRender       = ignore\n                    editorHook     = edh\n                    autoCompletion = None\n                    toolTip        = None\n                    declaration    = None\n                    editorO        = None\n                }\n            \n                let newText edh (v:string)             = newVar edh (Var.Create v)\n                let newVarO edh (v:Var<string option>) = \n                    Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                    |> newVar edh\n                    |> disabled(V (Option.isNone v.V))\n            \n                /// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\n                /// onChange gets called when the editor changes but not when the var changes\n                let bindVarEditor setEvent getVal setVal onChange (var:Var<_>) =\n                    let editorChanged = ref 0L\n                    let varChanged    = ref 0L\n                    setEvent(fun _ ->\n                        let v = getVal() \n                        if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange v \n                    )\n                    var.View |> View.Sink (fun _ ->\n                        if  !editorChanged > !varChanged then varChanged := !editorChanged\n                        elif getVal() <> var.Value then setVal var.Value\n                    )\n            \n                let generateDoc genE = \n                    genE                                         .editorHook.hookOnRender (fun ed ->\n                        genE.editorO        <- Some ed\n                        genE.var            |> bindVarEditor genE.editorHook.hookOnChange    \n                                                             genE.editorHook.getValue \n                                                             genE.editorHook.setValue \n                                                             genE.onChange\n                        genE.annotations    |> View.Sink     genE.editorHook.showAnnotations\n                        genE.disabled       |> View.Sink     genE.editorHook.setDisabled\n                        genE.onRender ed\n                    )\n                    genE                                         .editorHook.generateDoc()\n            \n            [< Inline \"\"\"(!$v)\"\"\">]\n            let isUndefined v = v.GetType() = v.GetType()\n                \n            \n            module LoadFiles =\n            \n                let createScript fn =\n                    let fileRef = JS.Document.CreateElement(\"script\")\n                    fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n                    fileRef.SetAttribute(\"src\" , fn                 )\n                    fileRef\n                \n                let createCss fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n                    fileRef.SetAttribute(\"type\", \"text/css\"       )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let createHtml fn =\n                    let fileRef = JS.Document.CreateElement(\"link\")\n                    fileRef.SetAttribute(\"rel\" , \"import\"         )\n                    fileRef.SetAttribute(\"type\", \"text/html\"      )\n                    fileRef.SetAttribute(\"href\", fn               )\n                    fileRef\n                \n                let LoadFile(file: string) =\n                    let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n                    match file with\n                    | EndsWith \".js\"   ()\n                    | EndsWith \".fsx\"  ()\n                    | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                            createScript file |> Some\n                    | EndsWith \".css\"  ()-> createCss    file |> Some\n                    | EndsWith \".html\" ()-> createHtml   file |> Some\n                    | _                  -> None\n                    |> Option.map         (fun ref -> \n                        Async.FromContinuations <| \n                            fun (cont, econt, _ccont) -> \n                                try \n                                    ref?onload <- cont\n                                    JS.Document.Head.AppendChild ref |> ignore\n                                with e -> econt e\n                    )\n                    |> Option.defaultWith (fun ()  -> async { return () })\n                \n                let LoadFilesAsync(files: string []) =\n                    async {\n                        if IsClient then\n                            for file in files do\n                                do! LoadFile file\n                    }\n                \n            let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n                if value = null then None else\n                match JavaScript.String(value).Match(RegExp(expr, opt)) with\n                | null         -> None\n                | [| |]        -> None\n                | m            -> Some m\n            \n            let rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n            \n            module REGEX =\n                let getStartWord (line:string) ch =\n                    match line.Substring(0, ch) with\n                    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n                \n                let getEndWord (line:string) ch =\n                    match line.Substring(ch) with\n                    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n                    | _                                      -> \"\"          \n            \n                let (|Identifier|_|) =\n                    function\n                    | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\n                    | _                                                  -> None\n            \n            [< JavaScript >]\n            module ResizeObserver =\n            \n                [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n                let implementedResizeObserver() = false\n                \n                [< Inline \"new ResizeObserver($_f)\" >]\n                let newResizeObserver (_f: unit->unit) = X<_> \n                \n                [< Inline \"$_ro.observe($_el)\" >]\n                let RObserve _ro (_el:Dom.Element) = X<_> \n                \n                let mutable observers : obj list = []\n                \n                let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n                \n                let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n                \n                let dimsChanged (el:Dom.Element) = \n                    let dims = ref <| el.GetBoundingClientRect()\n                    fun () ->\n                        let ndims = el.GetBoundingClientRect()\n                        if domRect2Tuple !dims = domRect2Tuple ndims then false\n                        else dims := ndims    ; true\n                \n                let addResizeObserver f el =\n                    if implementedResizeObserver() then\n                        let ro =  newResizeObserver f\n                        observers <- ro::observers\n                        RObserve ro el\n                    else\n                        let changed = dimsChanged el\n                        async {\n                            while isValidElement el do\n                                do! Async.Sleep 110\n                                if changed() then f()\n                        } |> Async.Start\n                        \n            [< JavaScriptExport >]\n            module Monaco =\n                open WebSharper.UI.Html\n            \n                type Position = {\n                    column     : int\n                    lineNumber : int\n                }\n                type Range = {\n                    startColumn     : int\n                    endColumn       : int\n                    startLineNumber : int\n                    endLineNumber   : int\n                }\n                type Uri = {\n                    authority : string\n                    fragment  : string\n                    fsPath    : unit->string\n                    path      : string\n                    query     : string\n                    scheme    : string\n                }  with\n                    [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri   = X<_>\n                    [< Inline \"$global.monaco.Uri.file($_f)\"  >] static member File(_f)       : Uri   = X<_>\n                type Location = {\n                    range : Range\n                    uri   : Uri\n                }\n                type FindMatch = {\n                    matches : string []\n                    range   : Range\n                }\n                type WordAtPosition = {\n                    endColumn   : int\n                    startColumn : int\n                    word        : string\n                }\n                type Model = {\n                    uri         : Uri\n                }\n                  with\n                    [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n                    [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n                    [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n                    [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n                    [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n                    [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n                    \n                type MarkDownString = {\n                    value      : string\n                    isTrusted  : bool\n                }\n                type MarkerSeverity =\n                | Error   = 8\n                | Hint    = 1\n                | Info    = 2\n                | Warning = 4\n                type MarkerData = {\n                    startColumn        : int\n                    endColumn          : int\n                    startLineNumber    : int\n                    endLineNumber      : int\n                    severity           : MarkerSeverity\n                    message            : string\n                    //code : string\n                    //relatedInformation : string\n                    //source             : string\n                    //tags               : MarkerTag[]\n                }\n                type CompletionItemKind =\n                | Class       = 6\n                | Color       = 15\n                | Constructor = 3\n                | Enum        = 12\n                | Field       = 4\n                | File        = 16\n                | Folder      = 18\n                | Function    = 2\n                | Interface   = 7\n                | Keyword     = 13\n                | Method      = 1\n                | Module      = 8\n                | Property    = 9\n                | Reference   = 17\n                | Snippet     = 14\n                | Text        = 0\n                | Unit        = 10\n                | Value       = 11\n                | Variable    = 5\n                type CompletionItem = {\n                    kind                : CompletionItemKind\n                    label               : string\n                    //additionalTextEdits : string\n                    //command             : string\n                    //commitCharacters    : string\n                    detail              : string\n                    //documentation       : string\n                    //filterText          : string\n                    //insertText          : string\n                    //range               : string\n                    //sortText            : string\n                    //textEdit            : string\n                }\n                type Hover = {\n                    contents   : MarkDownString []\n                    range      : Range\n                }\n                \n                open WebSharper.Core.Resources\n            \n                type MonacoResources() =\n                    inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n            \n                [< Require(typeof<MonacoResources>) >]\n                type Editor() =\n                    do ()\n                  with\n                    [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n                    [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n                    [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n                    [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n                    [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n                    [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n                    [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n                    [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n                    \n                    [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n                    [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n                    [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n                    [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n                    [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n                    [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n                    [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n                    [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n                    [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n                    \n            //        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n            //        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n            //        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n            //        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n            //        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n            //        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n            //        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n            //        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n            //        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n            //        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n            //        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n            //        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n            //        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n            //        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n            //        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n                \n                [<NoComparison ; NoEquality>]\n                type MonacoConfig = {\n                    var             : Var<string>\n                    onChange        : (string -> unit)\n                    onRender        : (Editor -> unit) option\n                    mutable editorO :  Editor option\n                    disabled        : View<bool>\n                    options         : obj\n                    overrides       : obj\n                }\n                \n                [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n                let newImmortalReference _v = X<_>\n                \n                let newVar var    = \n                    { var         = var \n                      onChange    = ignore\n                      onRender    = None\n                      editorO     = None\n                      disabled    = V false\n                      options     = null\n                      overrides   = null\n                    }\n                //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n                let loader = async {\n                    if IsClient then\n                        //do! LoadFiles.LoadFilesAsync includes\n                        Editor.RequireConfig()\n                        do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n                }\n                let render monc             = \n                    async {\n                      do! loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                 let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                                 ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                 elchild.ParentNode.RemoveChild elchild |> ignore\n                                 monc.editorO     <- Some editor\n                                 monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                                 monc.var |> GenEditor.bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                                 //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                          )    \n                        ] []\n                    } |> Doc.Async\n                let inline setVar   v   monc = { monc with var       = v      }\n                let inline onChange f   monc = { monc with onChange  = f      }\n                let inline onRender f   monc = { monc with onRender  = Some f }\n                let inline disabled dis monc = { monc with disabled  = dis    }\n                let inline var          monc = monc.var\n                let newText(v:string)             = newVar (Var.Create v)\n                let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                                    |> newVar\n                                                    |> disabled(V (Option.isNone v.V))\n            \n            module MonacoGenAdapter =\n                open GenEditor\n                open Monaco\n                open WebSharper.UI.Html\n            \n                type MonacoRT = {\n                    mutable editorO  : Monaco.Editor option\n                    mutable onRender : Monaco.Editor -> unit\n                    mutable onChange : obj -> unit\n                    options          : obj\n                    overrides        : obj\n                }\n            \n                let generateDoc monRT =\n                    async {\n                      do! Monaco.loader\n                      return\n                          div [ on.afterRender (fun elchild ->\n                                let editor        = Monaco.Editor.Create elchild.ParentElement monRT.options monRT.overrides\n                                ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                                elchild.ParentNode.RemoveChild elchild |> ignore\n                                monRT.editorO     <- Some editor\n                                monRT.onRender    <| unbox (box editor)\n                                editor.OnDidChangeModelContent monRT.onChange\n                          )    \n                        ] []\n                    } |> Doc.Async\n            \n                let getValue monRT     = monRT.editorO |> Option.map( fun ed -> ed.GetValue()   ) |> Option.defaultValue \"\" \n                let setValue monRT txt = monRT.editorO |> Option.iter(fun ed -> ed.SetValue txt )\n            \n                let showAnnotations monRT ans =\n                    match monRT.editorO with\n                    | None    -> ()\n                    | Some ed ->\n                    let ms =\n                        ans\n                        |> Seq.map (fun (an:Annotation) ->\n                            {   message         = an.message\n                                severity        = match an.severity with \n                                                  | Error   -> MarkerSeverity.Error \n                                                  | Warning -> MarkerSeverity.Warning  \n                                                  | Hint    -> MarkerSeverity.Hint \n                                                  | _       -> MarkerSeverity.Info\n                                startColumn     = an.startP.col\n                                startLineNumber = an.startP.line\n                                endColumn       = an.endP  .col\n                                endLineNumber   = an.endP  .line\n                            }\n                        )\n                        |> Seq.toArray\n                    Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)\n            \n                let newHook monRT = {\n                    generateDoc       = fun ()  -> generateDoc monRT \n                    getValue          = fun ()  -> getValue    monRT\n                    setValue          =            setValue    monRT\n                    showAnnotations   = showAnnotations        monRT\n                    setDisabled       = ignore //  bool                              -> unit\n                    hookOnRender      = fun f   -> monRT.onRender <- f\n                    hookOnChange      = fun f   -> monRT.onChange <- (fun _ -> f <| getValue monRT)\n                }\n            \n                let newRT options overrides = {\n                    editorO   = None\n                    onRender  = ignore\n                    onChange  = ignore\n                    options   = options   \n                    overrides = overrides \n                }\n            \n                let newVar options overrides v =\n                    newRT options overrides\n                    |> newHook\n                    |> GenEditor.newVar <| v\n            \n    \n        //#define WEBSHARPER\n        \n        [< JavaScriptExport >]\n        module TestingJS =\n        \n        \n            //#nowarn \"1182\"\n            //#nowarn \"1178\"\n            module Monaco =\n                open WebSharper.UI\n                open WebSharper.UI.Html\n                open Monaco\n                \n                type HoverProvider(ed:Editor) =\n                    do()\n                   with\n                      member __.provideHover(model:Model, pos:Position, token:obj) =\n                          let word = model.GetWordAtPosition pos\n                          if isUndefined word then box null |> unbox else\n                          {\n                              contents = { value = word?word |> sprintf \"The word is: %s\" ; isTrusted = true } |> Array.singleton\n                              range    = {\n                                            startLineNumber = pos.lineNumber\n                                            endLineNumber   = pos.lineNumber\n                                            startColumn     = word.startColumn\n                                            endColumn       = word.endColumn\n                                         }\n                          }\n            \n                type CompletionItemProvider(ed:Editor) =\n                    do()\n                   with\n                      member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj): CompletionItem[] =\n                          let word = model.GetWordAtPosition pos\n                          if isUndefined word then box null |> unbox else\n                          [|\n                            { kind = CompletionItemKind.Function ; label = \"Hello\"   ; detail = \"\"}\n                            { kind = CompletionItemKind.Function ; label = \"How\"     ; detail = \"\"}\n                            { kind = CompletionItemKind.Function ; label = \"Are\"     ; detail = \"\"}\n                            { kind = CompletionItemKind.Function ; label = \"You\"     ; detail = \"\"}\n                            { kind = CompletionItemKind.Function ; label = word?word ; detail = \"\"}\n            \n                          |]\n                      member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n                type DefinitionProvider(ed:Editor) =\n                    do()\n                   with\n                      member __.provideDefinition(model: Model, pos: Position, token: obj): Location =\n                          let word = model.GetWordAtPosition pos\n                          if isUndefined word then box null |> unbox else\n                          let ms = model.FindMatches(word.word, false, false, true, \" <>()+-=.,/#@$%^&*\\\"\", false, 1)\n                          if ms.Length = 0    then box null |> unbox else\n                          { range = ms.[0].range\n                            uri = model.uri\n                          }\n            \n                open GenEditor\n            \n                let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\\nHint (4, 7) - (4, 12): \\\"This shows over there as a hint\\\".\"\n                let transformAnnotations msgs =\n                    let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n                    match msgs with\n                    | REGEX rex \"g\" m -> m\n                    | _               -> [||]\n                    |> Seq.choose (fun v ->\n                        match v with\n                        | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                                 -> Some (ty, int fl, int fc, int tl, int tc, msg)\n                        | _      -> None\n                    )\n                    |> Seq.map (fun (ty, fl, fc, tl, tc, msg) ->\n                            { message  = msg\n                              severity = match ty with \"Err\" -> Error | \"Warn\" -> Warning  | \"Hint\" -> Hint | s -> Other s\n                              startP   = { col = fc ; line = fl }\n                              endP     = { col = tc ; line = tl }\n                            }\n                      )\n                    \n                let monacoNew (var : Var<string> ) =\n                    MonacoGenAdapter.newVar JSObject JSObject var\n                    |> GenEditor.onRender(fun ed ->\n                        Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n                        Editor.SetTheme(\"vs-dark\")\n                        //let hp = new HoverProvider         (ed)\n                        //let cp = new CompletionItemProvider(ed)\n                        //let dp = new DefinitionProvider    (ed)\n                        //hp.provideHover |> print\n                        //cp.provideCompletionItems |> print\n                        //cp.resolveCompletionItem  |> print\n                        //dp.provideDefinition      |> print\n                        //Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n                        //Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n                        //Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n                    )\n            \n                [< SPAEntryPoint >]\n                let main() =\n                    let var    = Var.Create \"Hello there.\\nHello there.\\nHello there.\\nHello there.\\n\"\n                    let monaco = { monacoNew var with annotations = V (transformAnnotations annotationsV.V) }\n                    div [] [\n                        div [ attr.style \"height: 400px; width: 800px\" ] [ monaco |> GenEditor.generateDoc ]\n                        div [] [ text \"These are the annotations that create tooltips, warnings and errors:\" ]\n                        Doc.InputAreaV [ attr.style \"height: 100px; width: 600px\" ] annotationsV.V\n                        div [] [ text var.V           ]\n                    ]\n                    |> Doc.Run JS.Document.Body\n                    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Provides balanced binary search tree operations.\n[<JavaScript>]\nmodule internal BalancedTree =\n\n    /// Represents a binary balanced search tree, preserving the balance\n    /// invariant: the heights of the branches differ by at most 1.\n    type Tree<'T when 'T : comparison> =\n        private {\n            Node    : 'T\n            Left    : Tree<'T>\n            Right   : Tree<'T>\n            Height  : int\n            Count   : int\n        }\n\n    [<Inline \"null\">]\n    let Empty<'T when 'T : comparison> = X<Tree<'T>>\n\n    [<Inline \"$tree == null\">]\n    let IsEmpty (tree: Tree<'T>) = X<bool>\n\n    [<Inline \"$tree == null ? 0 : $tree.Height\">]\n    let Height (tree: Tree<'T>) = X<int>\n            \n    [<Inline \"$tree == null ? 0 : $tree.Count\">]\n    let Count (tree: Tree<'T>) = X<int>\n\n    [<Inline \"$t.Left\">]\n    let Left (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Right\">]\n    let Right (t: Tree<'T>) = X<Tree<'T>>\n\n    [<Inline \"$t.Node\">]\n    let Node (t: Tree<'T>) = X<'T>\n\n    let Branch node left right =\n        {\n            Node    = node\n            Left    = left\n            Right   = right\n            Height  = 1 + max (Height left) (Height right)\n            Count   = 1 + Count left + Count right\n        }\n\n    let Enumerate flip (t: Tree<'T>) : seq<'T> =\n        let rec gen (t, spine: list<'T * Tree<'T>>) =\n            if IsEmpty t then\n                match spine with\n                | []                    -> None\n                | (t, other) :: spine   -> Some (t, (other, spine))\n            else\n                if flip\n                then gen (Right t, (Node t, Left t) :: spine)\n                else gen (Left t, (Node t, Right t) :: spine)\n        Seq.unfold gen (t, [])\n\n    /// Traverses the tree in ascending order.\n    [<Inline>]\n    let Ascend t = Enumerate false t\n\n    /// Traverses the tree in descending order.\n    [<Inline>]\n    let Descend t = Enumerate true t\n\n    /// Builds a tree from sorted input and the indices of the\n    /// first and the last elements to include.\n    let rec private Build (data: 'T []) min max : Tree<'T> =\n        let sz = max - min + 1\n        if sz <= 0 then\n            Empty\n        else\n            let center = (min + max) / 2\n            let left   = Build data min (center - 1)\n            let right  = Build data (center + 1) max\n            Branch data.[center] left right\n\n    /// Quickly constructs a tree from a sorted, distinct array.\n    [<Inline>]\n    let OfSorted (data: 'T []) : Tree<'T> =\n        Build data 0 (Array.length data - 1)\n\n    let OfSeq (data: seq<'T>) : Tree<'T> =\n        let a = Seq.toArray (Seq.distinct data)\n        Array.sortInPlace a\n        OfSorted a\n\n    [<Inline \"$x.unshift($y)\">]\n    let private unshift (x: 'T) y = X<unit>\n\n    /// Unzips a tree into a matching node and a spine.\n    let Lookup (k: 'T) (t: Tree<'T>) =\n        let mutable spine = [||]\n        let mutable t = t\n        let mutable loop = true\n        while loop do\n            if IsEmpty t then loop <- false else\n                match compare k t.Node with\n                | 0 -> loop <- false\n                | 1 ->\n                    unshift spine (true, t.Node, t.Left)\n                    t <- t.Right\n                | _ ->\n                    unshift spine (false, t.Node, t.Right)\n                    t <- t.Left\n        (t, spine)\n\n    /// Rebuilds an unzipped tree by going up the spine and performing\n    /// rotations where necessary for balance.\n    let private Rebuild<'T when 'T : comparison>\n            (spine: (bool * 'T * Tree<'T>) []) (t: Tree<'T>) : Tree<'T> =\n        let h (x: Tree<'T>) = Height x\n        let mutable t = t\n        for i = 0 to spine.Length - 1 do\n            t <- (\n                match spine.[i] with\n                | false, x, r ->\n                    if h t > h r + 1 then\n                        if h t.Right = h t.Left + 1 then\n                            // Double rotation:\n                            let m = t.Right\n                            Branch  m.Node\n                                    (Branch t.Node t.Left m.Left)\n                                    (Branch x m.Right r)\n                        else\n                            // Single rotation:\n                            Branch  t.Node\n                                    t.Left\n                                    (Branch x t.Right r)\n                    else\n                        // No rotation:\n                        Branch x t r\n                | true, x, l ->\n                    if h t > h l + 1 then\n                        if h t.Left = h t.Right + 1 then\n                            // Double rotation:\n                            let m = t.Left\n                            Branch m.Node\n                                    (Branch x l m.Left)\n                                    (Branch t.Node m.Right t.Right)\n                        else\n                            // Single rotation:\n                            Branch t.Node\n                                    (Branch x l t.Left)\n                                    t.Right\n                    else\n                        // No rotation:\n                        Branch x l t\n            )\n        t\n\n    /// Inserts or updates a node in the tree. If a matching node is found,\n    /// it is replaced with the value of \"combine old new\".\n    let Put<'T when 'T : comparison> combine k (t: Tree<'T>) : Tree<'T> =\n        let (t, spine) = Lookup k t\n        if IsEmpty t then\n            Rebuild spine (Branch k Empty Empty)\n        else\n            Rebuild spine (Branch (combine t.Node k) t.Left t.Right)\n\n    /// Removes a node from the tree.\n    let Remove k (src: Tree<'T>) =\n        let (t, spine) = Lookup k src\n        if IsEmpty t then\n            src\n        else\n            if IsEmpty t.Right then\n                Rebuild spine t.Left\n            elif IsEmpty t.Left then\n                Rebuild spine t.Right\n            else\n                Seq.append (Ascend t.Left) (Ascend t.Right)\n                |> Seq.toArray\n                |> OfSorted\n                |> Rebuild spine\n\n    /// Adds a node into the tree, replacing an existing one if found.\n    let Add<'T when 'T : comparison> (x: 'T) (t: Tree<'T>) : Tree<'T> =\n        Put (fun _ x -> x) x t\n\n    /// Checks if a tree contains a given key.\n    let rec Contains (v: 'T) (t: Tree<'T>) : bool =\n        not (IsEmpty (fst (Lookup v t)))\n\n    /// Looks up a node by key.\n    let TryFind (v: 'T) (t: Tree<'T>) =\n        let x = fst (Lookup v t)\n        if IsEmpty x then None else Some x.Node\n\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\n\n/// Represents a key-value pair with comparison and equality\n/// ignoring the value and using only the key.\n[<CustomComparison>]\n[<CustomEquality>]\n[<JavaScript>]\ntype internal Pair<'K,'V when 'K : comparison> =\n    {\n        Key     : 'K\n        Value   : 'V\n    }\n\n    override this.GetHashCode() = hash this.Key\n\n    override this.Equals(other: obj) =\n        this.Key = (other :?> Pair<'K,'V>).Key\n\n    interface System.IComparable with\n        member this.CompareTo(other: obj) =\n            compare this.Key (other :?> Pair<'K,'V>).Key\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Collections\nmodule T = BalancedTree\n\n[<JavaScript>]\n[<AutoOpen>]\nmodule private MapUtil =\n\n    let fromSeq(s: seq<_>) =\n        let a : Pair<_,_> [] =\n            [| for (k, v) in Seq.distinctBy fst s ->\n                { Key = k; Value = v } |]\n        Array.sortInPlace a\n        T.OfSorted a\n\n/// Implements a proxy for the F# Map type.\n[<Name \"FSharpMap\">]\n[<Proxy(typeof<Map<_,_>>)>]\ntype internal FSharpMap<'K,'V when 'K : comparison>\n\n    (tree: T.Tree<Pair<'K,'V>>) =\n\n        new (s: seq<_>) = new FSharpMap<_,_>(fromSeq s)\n\n        member this.Tree = tree\n\n        member this.Add(k: 'K, v: 'V) : Map<'K,'V> =\n            As (FSharpMap<'K,'V>(tree |> T.Add {Key=k; Value=v}))\n\n        member this.ContainsKey k = \n            tree |> T.Contains {Key=k; Value = JS.Undefined}\n\n        member this.TryGetValue (k: 'K, r: byref<'V>) = \n            match this.TryFind k with\n            | Some v ->\n                r <- v\n                true\n            | _ ->\n                false\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member this.Item \n            with get (k: 'K) : 'V =\n                match this.TryFind k with\n                | Some v    ->v\n                | None      ->\n                    failwith \"The given key was not present in the dictionary.\"\n\n        member this.Remove(k: 'K) : Map<'K,'V> =\n            As (FSharpMap(tree |> T.Remove {Key=k; Value=JS.Undefined}))\n\n        member this.TryFind(k: 'K) =\n            tree\n            |> T.TryFind {Key=k; Value=JS.Undefined}\n            |> Option.map (fun kv -> kv.Value)\n\n        member this.GetEnumerator() =\n            let s =\n                T.Ascend tree\n                |> Seq.map (fun kv ->\n                    new KeyValuePair<_,_>(kv.Key, kv.Value))\n            s.GetEnumerator()\n\n        override this.GetHashCode() =\n            hash (Seq.toArray this)\n\n        override this.Equals(other) =\n            let other = As<FSharpMap<'K,'V>> other\n            this.Count = other.Count\n            && Seq.forall2 ( = ) this other\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith (fun x y ->\n                    compare (As<Pair<'K,'V>> x) (As<Pair<'K,'V>> y))\n                    this\n                    (As<Map<'K,'V>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Map module.\n[<Proxy \"Microsoft.FSharp.Collections.MapModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Map\">]\nmodule internal MapModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (m: Map<'K,'V>) =\n        (As<FSharpMap<'K,'V>> m).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<_>) : Map<'K,'V> =\n        As (new FSharpMap<'K,'V>(t))\n\n    [<Inline>]\n    let Add k v (m: Map<'K,'V>) : Map<'K,'V> = m.Add(k, v)\n\n    [<Inline>]\n    let ContainsKey k (m: Map<'K,'V>) : bool = m.ContainsKey k\n\n    [<Inline>]\n    let Empty<'K,'V when 'K : comparison> : Map<'K,'V> = new Map<_,_>([||])\n\n    let Exists (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : bool =\n        m |> Seq.exists (fun kv -> f kv.Key kv.Value)\n\n    let Filter (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> =\n        T.Ascend (ToTree m)\n        |> Seq.filter (fun kv -> f kv.Key kv.Value)\n        |> Seq.toArray\n        |> T.OfSorted\n        |> OfTree\n\n    [<Inline>]\n    let Find (k: 'K) (m: Map<'K,'V>) : 'V = m.[k]\n\n    let FindKey (f: 'K -> 'T -> bool) (m: Map<'K,'T>) : 'K =\n        m \n        |> Seq.pick (fun kv -> \n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec Fold<'K,'V,'S when 'K : comparison>\n        (f: 'S -> 'K -> 'V -> 'S) (s: 'S) (m: Map<'K,'V>) : 'S =\n            T.Ascend (ToTree m)\n            |> Seq.fold (fun s kv -> f s kv.Key kv.Value) s\n\n    let rec FoldBack (f: 'K -> 'V -> 'S -> 'S) (m: Map<'K,'V>) (s: 'S) : 'S =\n        T.Descend (ToTree m)\n        |> Seq.fold (fun s kv -> f kv.Key kv.Value s) s\n\n    let rec ForAll (f: 'K -> 'V -> bool) (m: Map<'K, 'V>) : bool =\n        m |> Seq.forall (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let IsEmpty (m: Map<'K, 'V>) : bool = m.IsEmpty\n\n    let rec Iterate (f: 'K -> 'V -> unit) (m: Map<'K, 'V>) : unit =\n        m |> Seq.iter (fun kv -> f kv.Key kv.Value)\n\n    let OfArray (a: ('K * 'V) []) : Map<'K,'V> =\n        a\n        |> Seq.map (fun (k, v) -> {Key = k; Value = v} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n    [<Inline>]\n    let OfList (kvs: list<'K * 'V>) : Map<'K,'V> = Map.ofSeq kvs\n\n    [<Inline>]\n    let OfSeq (s: seq<'K * 'V>) : Map<'K, 'V> =\n        Map.ofArray (Seq.toArray s)\n\n    let Partition (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : Map<'K,'V> * Map<'K,'V> =\n        let (x, y) =\n            Seq.toArray (T.Ascend (ToTree m))\n            |> Array.partition (fun kv -> f kv.Key kv.Value)\n        (OfTree (T.OfSorted x), OfTree (T.OfSorted y))\n\n    let Pick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : 'T =\n        m |> Seq.pick (fun kv -> f kv.Key kv.Value)\n\n    [<Inline>]\n    let Remove (k: 'K) (m: Map<'K, 'V>) : Map<'K, 'V> = m.Remove k\n\n    [<Inline>]\n    let ToArray (m: Map<'K, 'V>) : array<'K * 'V> = Seq.toArray (Map.toSeq m)\n\n    [<Inline>]\n    let ToList (m: Map<'K, 'V>) : list<'K * 'V> = Seq.toList (Map.toSeq m)\n\n    let ToSeq (m: Map<'K, 'V>) : seq<'K * 'V> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> (kv.Key, kv.Value))\n\n    let TryFind (k: 'K) (m: Map<'K, 'V>) : option<'V> = m.TryFind k\n\n    let TryFindKey (f: 'K -> 'V -> bool) (m: Map<'K,'V>) : option<'K> =\n        m |> Seq.tryPick (fun kv ->\n            if f kv.Key kv.Value then Some kv.Key else None)\n\n    let rec TryPick (f: 'K -> 'V -> option<'T>) (m: Map<'K, 'V>) : option<'T> =\n        m |> Seq.tryPick (fun kv -> f kv.Key kv.Value)\n         \n    let rec Map (f: 'K -> 'V -> 'T) (m: Map<'K,'V>) : Map<'K,'T> =\n        T.Ascend (ToTree m)\n        |> Seq.map (fun kv -> \n            {Key = kv.Key; Value = f kv.Key kv.Value} : Pair<_,_>)\n        |> T.OfSeq\n        |> OfTree\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nmodule T = BalancedTree\n\n/// Implements a proxy for the F# Set type.\n[<Name \"FSharpSet\">]\n[<Proxy(typeof<Set<_>>)>]\ntype private FSharpSet<'T when 'T : comparison>\n\n    internal (tree: T.Tree<'T>) =\n\n        new (s: seq<'T>) = new FSharpSet<'T>(T.OfSeq s)\n\n        member this.add(x: Set<'T>) =\n            Set.union (As this) x\n\n        member this.sub(x: Set<'T>) =\n            Set.difference (As this) x\n\n        member this.Add x : Set<'T> =\n            As (FSharpSet<'T>(T.Add x tree))\n\n        member this.Contains v = T.Contains v tree\n\n        member this.Count = T.Count tree\n\n        member this.IsEmpty = T.IsEmpty tree\n\n        member internal this.Tree = tree\n\n        member this.IsProperSubsetOf(s: Set<'T>) =\n            this.IsSubsetOf s && this.Count < s.Count\n\n        member this.IsProperSupersetOf(s: Set<'T>) =\n            this.IsSupersetOf s && this.Count > s.Count\n\n        member this.IsSubsetOf(s: Set<'T>) =\n            Seq.forall s.Contains this\n\n        member this.IsSupersetOf(s: Set<'T>) =\n            Seq.forall this.Contains s\n\n        member this.MaximumElement = Seq.head (T.Descend tree)\n\n        member this.MinimumElement = Seq.head (T.Ascend tree)\n\n        member this.Remove v : Set<'T> =\n            As (FSharpSet<'T>(T.Remove v tree))\n\n        member this.GetEnumerator() =\n            (T.Ascend tree).GetEnumerator()\n\n        static member (+) (x, y) : Set<'T> =\n            Set.union x y        \n\n        static member (-) (x, y) : Set<'T> =\n            Set.difference x y        \n\n        override this.GetHashCode() =\n            -1741749453 + ((Seq.toArray this).GetHashCode())\n\n        override this.Equals(other: obj) =\n            this.Count = (As<FSharpSet<'T>> other).Count\n            && Seq.forall2 ( = ) this (As<FSharpSet<'T>> other)\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator()\n\n        interface System.IComparable with\n            member this.CompareTo other =\n                Seq.compareWith compare this (As<FSharpSet<'T>> other)\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Implements a proxy for the F# Set module.\n[<Proxy \"Microsoft.FSharp.Collections.SetModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\n[<Name \"Set\">]\nmodule internal SetModule =\n    module T = BalancedTree\n\n    [<Inline>]\n    let private ToTree (s: Set<'T>) =\n        (As<FSharpSet<'T>> s).Tree\n\n    [<Inline>]\n    let private OfTree (t: T.Tree<'T>) =\n        As<Set<'T>> (new FSharpSet<'T>(t))\n\n    [<Inline>]\n    let Add v (s: Set<_>) = s.Add v\n\n    [<Inline>]\n    let Contains v (s: Set<_>) = s.Contains v\n\n    [<Inline>]\n    let Count (s: Set<_>) = s.Count\n\n    [<Inline>]\n    let Difference (s1: Set<_>) (s2: Set<_>) =\n        Set.filter (fun x -> not (s2.Contains x)) s1\n\n    [<Inline>]\n    let Empty<'T when 'T : comparison> : Set<'T> = OfTree T.Empty\n\n    [<Inline>]\n    let Exists f (s: Set<'T>) = Seq.exists f s\n\n    let Filter f (s: Set<'T>) =\n        OfTree (T.OfSorted (Seq.toArray (Seq.filter f s)))\n\n    [<Inline>]\n    let Fold<'T,'S when 'T : comparison>\n        (f: 'S -> 'T -> 'S) (x: 'S) (a: Set<'T>) =\n            Seq.fold f x a\n\n    let FoldBack (f: 'T -> 'S -> 'S) (a: Set<'T>) (s: 'S) : 'S =\n        Seq.fold (fun s x -> f x s) s (T.Descend (ToTree a))\n\n    [<Inline>]\n    let ForAll f (a: Set<_>) = Seq.forall f a\n\n    [<Inline>]\n    let Intersect (s1: Set<'T>) (s2: Set<'T>) = Set.filter s2.Contains s1\n\n    [<Inline>]\n    let IntersectMany (s: seq<Set<_>>) = Seq.reduce Set.intersect s\n\n    [<Inline>]\n    let IsEmpty (a: Set<_>) = a.IsEmpty\n\n    [<Inline>]\n    let IsProperSubset (a: Set<_>) b = a.IsProperSubsetOf b\n\n    [<Inline>]\n    let IsProperSuperset (a: Set<_>) b = a.IsProperSupersetOf b\n\n    [<Inline>]\n    let IsSubset (a: Set<_>) b = a.IsSubsetOf b\n\n    [<Inline>]\n    let IsSuperset (a: Set<_>) b = a.IsSupersetOf b\n\n    [<Inline>]\n    let Iterate f (s: Set<_>) = Seq.iter f s\n\n    [<Inline>]\n    let Map f (s: Set<_>) = Set.ofSeq (Seq.map f s)\n\n    [<Inline>]\n    let MaxElement (s: Set<_>) = s.MaximumElement\n\n    [<Inline>]\n    let MinElement (s: Set<_>) = s.MinimumElement\n\n    [<Inline>]\n    let OfArray (a: 'T []) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfList (a: list<'T>) = OfTree (T.OfSeq a)\n\n    [<Inline>]\n    let OfSeq (a: seq<'T>) = OfTree (T.OfSeq a)\n\n    let Partition f (a: Set<_>) =\n        let (x, y) = Array.partition f (Seq.toArray a)\n        (Set.ofArray x, Set.ofArray y)\n\n    [<Inline>]\n    let Remove v (a: Set<_>) = a.Remove v\n\n    [<Inline>]\n    let Singleton x = Set.add x Set.empty\n\n    [<Inline>]\n    let ToArray (a: Set<_>) = Seq.toArray a\n\n    [<Inline>]\n    let ToList (a: Set<_>) = Seq.toList a\n\n    [<Inline>]\n    let ToSeq (a: Set<_>) : seq<_> = a :> _\n\n    [<Inline>]\n    let Union (s1: Set<_>) (s2: Set<_>) =\n        Set.ofSeq (Seq.append s1 s2)\n\n    [<Inline>]\n    let UnionMany (sets: seq<Set<_>>) =\n        Set.ofSeq (Seq.concat sets)\n\n\n\n\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.ResizeArray\n\nopen WebSharper\nopen WebSharper.JavaScript\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\n\n[<Name \"WebSharper.Collections.ListEnumerator\">]\n[<Proxy(typeof<System.Collections.Generic.List.Enumerator<_>>)>]\ntype ResizeArrayEnumeratorProxy<'T> [<JavaScript>] (arr: 'T[]) =\n    let mutable i = -1\n\n    [<JavaScript>] \n    member this.MoveNext() =\n        i <- i + 1\n        i < arr.Length\n\n    [<JavaScript>] \n    member this.Current with get() = arr.[i]\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = this.MoveNext()\n        [<JavaScript>]\n        member this.Current with get() = box (arr.[i])\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = arr.[i]\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = ()\n\n[<Proxy(typeof<System.Collections.Generic.List<_>>)>]\n[<Name \"WebSharper.Collections.List\">]\n[<Prototype false>]\ntype ResizeArrayProxy<'T> [<Inline \"$_arr\">] (_arr: 'T []) =\n\n    [<Inline \"[]\">]\n    new () =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline \"[]\">]\n    new (size: int) =\n        new ResizeArrayProxy<'T>([||])\n\n    [<Inline>]\n    new (el: seq<'T>) =\n        new ResizeArrayProxy<'T>(Seq.toArray el)\n\n    [<Inline>]\n    member this.GetEnumerator() =\n        As<System.Collections.Generic.List.Enumerator<'T>>(new ResizeArrayEnumeratorProxy<'T>(As<'T[]> this))\n\n    interface 'T seq with\n        member this.GetEnumerator() = (As<System.Collections.IEnumerable> this).GetEnumerator()\n        member this.GetEnumerator() = (As<seq<'T>> this).GetEnumerator()\n\n    [<Inline>]\n    member this.Add(x: 'T) : unit =\n        As<'T[]>(this).JS.Push(x) |> ignore\n\n    [<Inline>]\n    member this.AddRange(x: seq<'T>) : unit =\n        Seq.iter this.Add x\n\n    [<Inline>]\n    member this.AsReadOnly() : System.Collections.ObjectModel.ReadOnlyCollection<'T> =\n        System.Array.AsReadOnly(As<'T[]> this)\n\n    [<Inline>]\n    member this.BinarySearch(start: int, length: int, item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, start, length, item, comparer)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T) : int =\n        System.Array.BinarySearch(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.BinarySearch(item: 'T, comparer: IComparer<'T>) : int =\n        System.Array.BinarySearch(As<'T[]> this, item, comparer)\n\n    [<Inline>]\n    member this.Clear() : unit =\n        (As<'T[]> this).JS.Splice(0, this.Count) |> ignore\n\n    [<Inline>]\n    member this.Contains(item: 'T) : bool =\n        System.Array.Exists(As<'T[]> this, fun x -> System.Collections.Generic.EqualityComparer.Default.Equals(item, x))\n\n    [<Inline>]\n    member this.ConvertAll<'U>(conv: System.Converter<'T, 'U>) : ResizeArray<'U> =\n        ResizeArray<'U>(System.Array.ConvertAll(As<'T[]> this, conv))\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[]) : unit =\n        this.CopyTo(arr, 0)\n\n    [<Inline>]\n    member this.CopyTo(arr: 'T[], offset: int) : unit =\n        this.CopyTo(0, arr, offset, this.Count)\n\n    [<Inline>]\n    member this.CopyTo(index: int, target: 'T[], offset: int, count: int) : unit =\n        Array.blit (As<'T[]> this) index target offset count\n\n    [<Inline>]\n    member this.Count : int = (As<'T[]> this).Length\n\n    [<Inline>]\n    member this.Exists(pred: System.Predicate<'T>) : bool =\n        System.Array.Exists(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.Find(pred: System.Predicate<'T>) : 'T =\n        System.Array.Find(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindAll(pred: System.Predicate<'T>) : ResizeArray<'T> =\n        ResizeArray<'T>(System.Array.FindAll(As<'T[]> this, pred))\n\n    [<Inline>]\n    member this.FindIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.FindLast(pred: System.Predicate<'T>) : 'T =\n        System.Array.FindLast(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, pred)\n\n    [<Inline>]\n    member this.FindLastIndex(start: int, count: int, pred: System.Predicate<'T>) : int =\n        System.Array.FindLastIndex(As<'T[]> this, start, count, pred)\n\n    [<Inline>]\n    member this.ForEach(action: System.Action<'T>) : unit =\n        System.Array.ForEach(As<'T[]> this, action)\n\n    [<Inline>]\n    member this.GetRange(index: int, count: int) : ResizeArray<'T> =\n        As (ResizeArrayProxy<'T>(Array.sub (As<'T[]> this) index count))\n\n    [<Inline>]\n    member this.IndexOf(item: 'T) : int =\n        System.Array.IndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.IndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.IndexOf(As<'T[]> this, item, start, count)\n\n    [<Inline>]\n    member this.Insert(index: int, item: 'T) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, item) |> ignore\n\n    [<Inline>]\n    member this.InsertRange(index: int, items: seq<'T>) : unit =\n        (As<'T[]> this).JS.Splice(index, 0, Array.ofSeq items) |> ignore\n\n    member this.Item\n        with [<Inline>] get (x: int) : 'T = (As<'T[]> this).[x]\n        and [<Inline>] set (x: int) (v: 'T) = (As<'T[]> this).[x] <- v\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start)\n\n    [<Inline>]\n    member this.LastIndexOf(item: 'T, start: int, count: int) : int =\n        System.Array.LastIndexOf(As<'T[]> this, item, start, count)\n\n    member this.Remove(item: 'T) : bool =\n        match this.IndexOf(item) with\n        | -1 -> false\n        | n -> this.RemoveAt(n); true\n\n    member this.RemoveAll(pred: System.Predicate<'T>) : int =\n        let mutable removed = 0\n        let mutable i = 0\n        while i < this.Count do\n            if pred.Invoke((As<'T[]> this).JS.[i]) then\n                let mutable j = i + 1\n                while j < this.Count && pred.Invoke((As<'T[]> this).JS.[j]) do\n                    j <- j + 1\n                removed <- removed + j - i\n                (As<'T[]> this).JS.Splice(i, j - i) |> ignore\n            else\n                i <- i + 1\n        removed\n\n    [<Inline>]\n    member this.RemoveAt(x: int) : unit =\n        (As<'T[]> this).JS.Splice(x, 1) |> ignore\n\n    [<Inline>]\n    member this.RemoveRange(index: int, count: int) : unit =\n        (As<'T[]> this).JS.Splice(index, count) |> ignore\n\n    [<Inline>]\n    member this.Reverse() : unit =\n        System.Array.Reverse(As<'T[]> this)\n\n    [<Inline>]\n    member this.Reverse(index: int, count: int) : unit =\n        System.Array.Reverse(As<'T[]> this, index, count)\n\n    [<Inline>]\n    member this.Sort() : unit =\n        System.Array.Sort(As<'T[]> this)\n\n    [<Inline>]\n    member this.Sort(comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.Sort(start: int, length: int, comp: IComparer<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, start, length, comp)\n\n    [<Inline>]\n    member this.Sort(comp: System.Comparison<'T>) : unit =\n        System.Array.Sort(As<'T[]> this, comp)\n\n    [<Inline>]\n    member this.ToArray() : 'T [] =\n        Array.copy (As<'T[]> this)\n\n    [<Inline>]\n    member this.TrimExcess() = ()\n\n    [<Inline>]\n    member this.TrueForAll(pred: System.Predicate<'T>) : bool =\n        System.Array.TrueForAll(As<'T[]> this, pred)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule private WebSharper.Collections.LinkedList\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype LL<'T> = LinkedList<'T>\ntype LLN<'T> = LinkedListNode<'T>\ntype LLE<'T> = LinkedList<'T>.Enumerator\n\n[<Proxy(typeof<LLN<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListNode\">]\ntype NodeProxy<'T> =\n    member this.Previous with [<Inline \"$this.p\">] get () = X<LLN<'T>>\n    member this.Next     with [<Inline \"$this.n\">] get () = X<LLN<'T>>\n    member this.Value    with [<Inline \"$this.v\">] get () = X<'T>\n\n[<Inline \"{p: $p, n: $n, v: $v}\">]\nlet newNode<'T> (p: LLN<'T>) (n: LLN<'T>) (v: 'T) = X<LLN<'T>>\n\n[<Inline \"$node.p = $p\" >]\nlet setPrev (node: LLN<'T>) (p: LLN<'T>) = ()\n\n[<Inline \"$node.n = $n\" >]\nlet setNext (node: LLN<'T>) (n: LLN<'T>) = ()\n\n[<Proxy(typeof<LLE<_>>)>]\n[<Name \"WebSharper.Collections.LinkedListEnumerator\">]\ntype EnumeratorProxy<'T> [<JavaScript>] (l: LLN<'T>) =\n    let mutable c = l\n\n    interface IEnumerator<'T> with\n        member this.Current = c.Value\n        \n        member this.Current = c.Value |> box\n\n        member this.MoveNext() =\n            c <- c.Next\n            c <> null\n\n        member this.Dispose() = ()\n\n        member this.Reset() = ()\n\n[<Proxy(typeof<LL<_>>)>]\n[<Name \"WebSharper.Collections.LinkedList\">]\ntype ListProxy<'T> [<JavaScript>] (coll: 'T seq) =\n    let mutable c = 0\n    let mutable n = null\n    let mutable p = null\n\n    do  let ie = coll.GetEnumerator()\n        if ie.MoveNext() then\n            n <- newNode null null ie.Current\n            p <- n\n            c <- 1\n        while ie.MoveNext() do\n            let node = newNode p null ie.Current\n            setNext p node\n            p <- node\n            c <- c + 1\n            \n    new () = ListProxy(Seq.empty)          \n\n    [<Inline>]\n    member this.Count = c\n\n    [<Inline>]\n    member this.First = n\n\n    [<Inline>]\n    member this.Last = p\n\n    member this.AddAfter(after: LLN<'T>, value) =\n        let before = after.Next\n        let node = newNode after before value\n        if after.Next = null then p <- node\n        setNext after node\n        if before <> null then setPrev before node\n        c <- c + 1\n        node\n\n    member this.AddBefore(before: LLN<'T>, value) =\n        let after = before.Previous\n        let node = newNode after before value\n        if before.Previous = null then n <- node \n        setPrev before node\n        if after <> null then setNext after node\n        c <- c + 1\n        node\n\n    member this.AddFirst(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddBefore(n, value)\n\n    member this.AddLast(value) =\n        if c = 0 then\n            let node = newNode null null value\n            n <- node\n            p <- n \n            c <- 1\n            node\n        else this.AddAfter(p, value)\n\n    member this.Clear() =\n        c <- 0\n        n <- null\n        p <- null\n\n    member this.Contains(value: 'T) =\n        let mutable found = false\n        let mutable node = n\n        while node <> null && not found do\n            if node.Value ==. value then found <- true \n            else node <- node.Next\n        found\n            \n    member this.Find(value: 'T) =\n        let mutable node = n\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Next\n        if notFound then null else node\n\n    member this.FindLast(value: 'T) = \n        let mutable node = p\n        let mutable notFound = true\n        while notFound && node <> null do\n            if node.Value ==. value then\n                notFound <- false    \n            else\n                node <- node.Previous\n        if notFound then null else node\n                \n    member this.GetEnumerator(): LinkedList<'T>.Enumerator =\n        As (new EnumeratorProxy<_>(As this))\n\n    interface IEnumerable with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    interface IEnumerable<'T> with\n        member this.GetEnumerator() = this.GetEnumerator() :> _\n\n    member this.Remove(node: LLN<'T>) =\n        let before = node.Previous\n        let after = node.Next\n        if before = null then n <- after else setNext before after\n        if after = null then p <- before else setPrev after before\n        c <- c - 1\n        \n    member this.Remove(value) = \n        let node = this.Find(value)\n        if node = null then false\n        else\n            this.Remove(node)\n            true\n\n    member this.RemoveFirst() = this.Remove(n)\n\n    member this.RemoveLast() = this.Remove(p)\n               \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<IGrouping<_, _>>)>]\ntype internal IGroupingProxy<'K, 'T> =\n    abstract Key : 'K\n\n[<JavaScript>]\ntype internal Grouping<'K, 'T> (k: 'K, v: seq<'T>) =\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            v.GetEnumerator()\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() =\n            (v :> System.Collections.IEnumerable).GetEnumerator()\n\n    interface System.Linq.IGrouping<'K, 'T> with\n        member this.Key = k\n\n[<Proxy(typeof<IOrderedEnumerable<_>>)>]\ntype internal IOrderedEnumerableProxy<'T> =\n    inherit seq<'T>\n    abstract CreateOrderedEnumerable<'K>\n        : keySelector: Func<'T, 'K>\n        * comparer: IComparer<'K>\n        * descending: bool\n        -> IOrderedEnumerable<'T>\n\n[<JavaScript>]\ntype internal FsComparer<'T when 'T : comparison>() =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            compare x y\n\n[<JavaScript>]\ntype internal ProjectionComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke x, projection.Invoke y)\n\n[<JavaScript>]\ntype internal CompoundComparer<'T>(primary: IComparer<'T>, secondary: IComparer<'T>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            match primary.Compare(x, y) with\n            | 0 -> secondary.Compare(x, y)\n            | n -> n\n\n[<JavaScript>]\ntype internal ReverseComparer<'T, 'K>(primary: IComparer<'K>, projection: Func<'T, 'K>) =\n    interface IComparer<'T> with\n        member this.Compare(x, y) =\n            primary.Compare(projection.Invoke y, projection.Invoke x)\n\n[<JavaScript>]\ntype internal OrderedEnumerable<'T>(source: seq<'T>, primary: IComparer<'T>) =\n    interface IOrderedEnumerable<'T> with\n        member this.CreateOrderedEnumerable(keySelector, secondary, descending) =\n            let secondary =\n                if descending then\n                    ReverseComparer(secondary, keySelector) :> IComparer<'T>\n                else\n                    ProjectionComparer(secondary, keySelector) :> IComparer<'T>\n            OrderedEnumerable<'T>(source, CompoundComparer(primary, secondary)) :> _\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let a = Array.ofSeq source\n            Array.sortInPlaceWith (fun x y -> primary.Compare(x, y)) a\n            (a :> seq<'T>).GetEnumerator()\n    interface IEnumerable with\n        member this.GetEnumerator() =\n            (this :> IEnumerable<'T>).GetEnumerator() :> _\n\n//[<Proxy(typeof<ILookup<_, _>>)>]\n//type internal ILookupProxy<'K, 'E> =\n//    inherit seq<IGrouping<'K, 'E>>\n//    inherit IEnumerable\n//    abstract Item : 'K -> 'E with get\n//    abstract Count : int with get\n//    abstract Contains : 'K -> bool\n//\n//[<JavaScript>]\n//type internal Lookup<'K, 'T, 'E>(source: seq<'T>, key: Func<'T, 'K>, elt: Func<'T, 'E>, comparer: IEqualityComparer<'K>) =\n//\n//    let dc = lazy (\n//        let d = Dictionary<'K, ResizeArray<'E>>(comparer)\n//        let count = ref 0\n//        source |> Seq.iter (fun e ->\n//            incr count\n//            let k = key.Invoke e\n//            let v = elt.Invoke e\n//            if d.ContainsKey k then\n//                d.[k].Add(v)\n//            else\n//                d.Add(k, ResizeArray([|v|]))\n//        )\n//        d, !count\n//    )\n//\n//    let s = lazy (\n//        fst dc.Value |> Seq.map (fun (KeyValue(k, v)) ->\n//            Grouping(k, v) :> IGrouping<_,_>)\n//    )\n//\n//    interface seq<IGrouping<'K, 'E>> with\n//        member this.GetEnumerator() = s.Value.GetEnumerator()\n//    interface IEnumerable with\n//        member this.GetEnumerator() = (s.Value :> IEnumerable).GetEnumerator()\n//    interface ILookup<'K, 'E> with\n//        member this.Item with get k = (fst dc.Value).[k] :> seq<_>\n//        member this.Count = snd dc.Value\n//        member this.Contains(k) = (fst dc.Value).ContainsKey(k)\n\ntype private LinqMacro() =\n    inherit Macro()\n\n    override this.TranslateCall(c) = //e, t, m, a, _) =\n        let targ = c.Method.Generics.[0]\n        WebSharper.Core.Macros.EqualityComparer.GetDefault(c.Compilation, targ)\n        |> MacroResult.Map (fun ec ->\n            let m' =\n                let t =\n                    AST.Type.ConcreteType {\n                        Generics = [targ]\n                        Entity =\n                            typedefof<IEqualityComparer<int>>\n                            |> AST.Reflection.ReadTypeDefinition\n                    }\n                let m = c.Method.Entity.Value\n                { m with Parameters = m.Parameters @ [t] }\n            let m = { c.Method with Entity = Hashed m' }\n            AST.Call(c.This, c.DefiningType, c.Method, c.Arguments @ [ec]))\n\n[<Name \"WebSharper.Linq\">]\n[<Proxy(typeof<System.Linq.Enumerable>)>]\n[<JavaScript>]\ntype private LinqProxy =\n\n    [<Inline>]\n    static member Aggregate<'T>(this: seq<'T>, func: Func<'T, 'T, 'T>) : 'T =\n        Seq.reduce (fun x y -> func.Invoke(x, y)) this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>) : 'U =\n        Seq.fold (fun x y -> func.Invoke(x, y)) seed this\n\n    [<Inline>]\n    static member Aggregate<'T, 'U, 'R>(this: seq<'T>, seed: 'U, func: Func<'U, 'T, 'U>, resultSelector: Func<'U, 'R>) : 'R =\n        resultSelector.Invoke(Seq.fold (fun x y -> func.Invoke(x, y)) seed this)\n\n    [<Inline>]\n    static member All<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.forall predicate.Invoke this\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>) : bool =\n        not (Seq.isEmpty this)\n\n    [<Inline>]\n    static member Any<'T>(this: seq<'T>, predicate: Func<'T, bool>) : bool =\n        Seq.exists predicate.Invoke this\n\n    [<Inline>]\n    static member AsEnumerable<'T>(this: seq<'T>) : seq<'T> =\n        this\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    [<Inline>]\n    static member Average(this: seq<Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average(Seq.cast<Nullable<float>> this)\n\n    static member Average(this: seq<Nullable<float>>) : Nullable<float> =\n        let mutable x = [||]\n        use e = this.GetEnumerator()\n        while e.MoveNext() do\n            if e.Current.HasValue then\n                x.JS.Push e.Current.Value |> ignore\n        if x.Length = 0 then\n            Nullable()\n        else\n            Nullable(Seq.sum x / float x.Length)\n\n    [<Inline>]\n    static member Average(this: seq<float>) : float =\n        Seq.average this\n\n    [<Inline>]\n    static member Average(this: seq<int64>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average(this: seq<int>) : float =\n        Seq.average (Seq.cast<float> this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int64>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<float> =\n        LinqProxy.Average (Seq.cast<Nullable<float>> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        Seq.average (Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Average<'T>(this: seq<'T>, selector: Func<'T, int>) : float =\n        Seq.average (Seq.cast<float> (Seq.map selector.Invoke this))\n\n    [<Inline>]\n    static member Cast<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast this\n\n    [<Inline>]\n    static member Concat<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        Seq.append this second\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T) : bool =\n        LinqProxy.Contains(this, value, EqualityComparer.Default)\n\n    [<Inline>]\n    static member Contains<'T>(this: seq<'T>, value: 'T, comparer: IEqualityComparer<'T>) : bool =\n        Seq.exists (fun x -> comparer.Equals(value, x)) this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>) : int =\n        Seq.length this\n\n    [<Inline>]\n    static member Count<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int =\n        Seq.length (Seq.filter predicate.Invoke this)\n\n    [<Inline>]\n    static member DefaultIfEmpty<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.DefaultIfEmpty(this, Unchecked.defaultof<'T>)\n\n    static member DefaultIfEmpty<'T>(this: seq<'T>, defaultValue: 'T) : seq<'T> =\n        if Seq.isEmpty this then\n            Seq.singleton defaultValue\n        else this\n\n    [<Inline>]\n    static member Distinct<'T>(this: seq<'T>) : seq<'T> =\n        LinqProxy.Distinct(this, EqualityComparer.Default)\n\n    static member Distinct<'T>(this: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let tbl = HashSet(comparer)\n            while e.MoveNext() do\n                if tbl.Add(e.Current) then\n                    yield e.Current\n        }\n\n    [<Inline>]\n    static member ElementAt<'T>(this: seq<'T>, index: int): 'T =\n        Seq.item index this\n\n    [<Inline>]\n    static member ElementAtOrDefault<'T>(this: seq<'T>, index: int) =\n        LinqProxy.JSElementAtOrDefault(this, index, Unchecked.defaultof<'T>)\n\n    [<Name \"ElementAtOrDefault\">]\n    static member JSElementAtOrDefault<'T>(this: seq<'T>, index: int, defaultValue: 'T) : 'T =\n        try Seq.item index this\n        with _ -> defaultValue\n\n    [<Inline>]\n    static member Empty<'T>() : seq<'T> =\n        Seq.empty\n\n    [<Inline>]\n    static member Except<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Except(this, second, EqualityComparer.Default)\n\n    static member Except<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for x in second do tbl.Remove(x) |> ignore\n        tbl :> _\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>) : 'T =\n        Seq.head this\n\n    [<Inline>]\n    static member First<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        Seq.find predicate.Invoke this\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        if e.MoveNext() then e.Current else defaultValue\n\n    [<Inline>]\n    static member FirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSFirstOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"FirstOrDefault$1\">]\n    static member JSFirstOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match Seq.tryFind predicate.Invoke this with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'T>> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, resultSelector, EqualityComparer.Default)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : seq<IGrouping<'K, 'E>> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : seq<IGrouping<'K, 'E>> =\n        Seq.delay (fun () ->\n            // Using an array instead of a seq is important here: the returned groupings\n            // use a ResizeArray that is filled here, so this enumeration must be finished\n            // before the user can enumerate any of the groupings.\n            [|\n                let t = Dictionary<'K, ResizeArray<'E>>(comparer)\n                for x in this do\n                    let k = keySelector.Invoke x\n                    let e = elementSelector.Invoke x\n                    match t.TryGetValue k with\n                    | true, a -> a.Add(e)\n                    | false, _ ->\n                        let a = ResizeArray<'E>()\n                        a.Add(e)\n                        t.[k] <- a\n                        yield Grouping(k, a) :> IGrouping<_,_>\n            |] :> _\n        )\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, resultSelector: Func<'K, seq<'T>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, (fun x -> x), resultSelector, comparer)\n\n    [<Inline>]\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupBy<'T, 'K, 'E, 'R when 'K : equality>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, resultSelector: Func<'K, seq<'E>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        LinqProxy.GroupBy(this, keySelector, elementSelector, comparer)\n        |> Seq.map (fun g -> resultSelector.Invoke(g.Key, g))\n\n    [<Inline>]\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>) : seq<'R> =\n        LinqProxy.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member GroupJoin<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, seq<'I>, 'R>, comparer: IEqualityComparer<'K>) : seq<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            a |> Array.iteri (fun i (o, is) ->\n                a.[i] <- As (resultSelector.Invoke(o, is)))\n            As a\n        )\n\n    [<Inline>]\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Intersect(this, second, EqualityComparer.Default)\n\n    static member Intersect<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let t1 = HashSet(this, comparer)\n        seq {\n            let t2 = HashSet(comparer)\n            for x in second do\n                if t1.Contains(x) && t2.Add(x) then\n                    yield x\n        }\n\n    [<Inline>]\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>) : IEnumerable<'R> =\n        LinqProxy.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, EqualityComparer.Default)\n\n    static member Join<'O, 'I, 'K, 'R>(outer: seq<'O>, inner: seq<'I>, outerKeySelector: Func<'O, 'K>, innerKeySelector: Func<'I, 'K>, resultSelector: Func<'O, 'I, 'R>, comparer: IEqualityComparer<'K>) : IEnumerable<'R> =\n        Seq.delay (fun () ->\n            let t = Dictionary<'K, 'O * ResizeArray<'I>>(comparer)\n            let a = [|\n                for o in outer do\n                    let k = outerKeySelector.Invoke o\n                    match t.TryGetValue k with\n                    | true, _ -> ()\n                    | false, _ ->\n                        let pair = (o, ResizeArray())\n                        t.Add(k, pair)\n                        yield pair\n            |]\n            for i in inner do\n                let k = innerKeySelector.Invoke i\n                match t.TryGetValue k with\n                | true, (_, a) -> a.Add(i)\n                | false, _ -> ()\n            [|\n                for (o, is) in a do\n                    for i in is do\n                        yield resultSelector.Invoke(o, i)\n            |] :> _\n        )\n\n    [<Inline>]\n    static member Last<'T>(this: seq<'T>) : 'T =\n        Seq.last this\n\n    static member LastPred(this: seq<'T>, predicate: Func<'T, bool>) : option<'T> =\n        (None, this)\n        ||> Seq.fold (fun acc elt ->\n            if predicate.Invoke elt then Some elt else acc)\n\n    static member Last<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> invalidOp \"Sequence contains no matching element\"\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>) : 'T =\n        Enumerable.LastOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member LastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSLastOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"LastOrDefault\">]\n    static member JSLastOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        match LinqProxy.LastPred(this, predicate) with\n        | Some x -> x\n        | None -> defaultValue\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>) : int64 =\n        As(Enumerable.Count(this))\n\n    [<Inline>]\n    static member LongCount<'T>(this: seq<'T>, predicate: Func<'T, bool>) : int64 =\n        As(Enumerable.Count(this, predicate))\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<float>) : float =\n        Seq.max this\n\n    [<Inline>]\n    static member Max(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Max(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Max(this: seq<int64>) : int64 =\n        Seq.max this\n\n    static member Max(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.max s)\n\n    [<Inline>]\n    static member Max(this: seq<int>) : int =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.max this\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Max<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Max(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<float>) : float =\n        Seq.min this\n\n    [<Inline>]\n    static member Min(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Min(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Min(this: seq<int64>) : int64 =\n        Seq.min this\n\n    static member Min(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.min s)\n\n    [<Inline>]\n    static member Min(this: seq<int>) : int =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T when 'T : comparison>(this: seq<'T>) : 'T =\n        Seq.min this\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Min<'T, 'R when 'R : comparison>(this: seq<'T>, selector: Func<'T, 'R>) : 'R =\n        LinqProxy.Min(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member OfType<'T>(this: IEnumerable) : seq<'T> =\n        Seq.cast<'T> this\n\n    [<Inline>]\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderBy(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderBy<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ProjectionComparer(comparer, keySelector)) :> _\n\n    [<Inline>]\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        LinqProxy.OrderByDescending(this, keySelector, Comparer<'K>.Default)\n\n    static member OrderByDescending<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        OrderedEnumerable(this, ReverseComparer(comparer, keySelector)) :> _\n\n    static member Range(start: int, count: int) : seq<int> =\n        Seq.init count ((+) start)\n\n    static member Repeat<'T>(element: 'T, count: int) : seq<'T> =\n        Seq.init count (fun _ -> element)\n\n    static member Reverse<'T>(this: seq<'T>) : seq<'T> =\n        Array.rev (Array.ofSeq this) :> _\n\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, int, 'R>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this\n\n    [<Inline>]\n    static member Select<'T, 'R>(this: seq<'T>, selector: Func<'T, 'R>) : seq<'R> =\n        Seq.map selector.Invoke this\n\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'R>>) : seq<'R> =\n        Seq.mapi (fun i x -> selector.Invoke(x, i)) this |> Seq.concat\n\n    [<Inline>]\n    static member SelectMany<'T, 'R>(this: seq<'T>, selector: Func<'T, seq<'R>>) : seq<'R> =\n        Seq.collect selector.Invoke this\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.map (fun t -> t, selector.Invoke t)\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    static member SelectMany<'T, 'C, 'R>(this: seq<'T>, selector: Func<'T, int, seq<'C>>, collectionSelector: Func<'T, 'C, 'R>) : seq<'R> =\n        this\n        |> Seq.mapi (fun i t -> t, selector.Invoke(t, i))\n        |> Seq.collect (fun (t, cs) ->\n            cs |> Seq.map (fun c -> collectionSelector.Invoke(t, c)))\n\n    [<Inline>]\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>) : bool =\n        LinqProxy.SequenceEqual(this, second, EqualityComparer.Default)\n\n    static member SequenceEqual<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : bool =\n        use e1 = this.GetEnumerator()\n        use e2 = this.GetEnumerator()\n        let rec go() =\n            if e1.MoveNext() then\n                e2.MoveNext() && comparer.Equals(e1.Current, e2.Current) && go()\n            else\n                not (e2.MoveNext())\n        go()\n\n    [<Inline>]\n    static member Single<'T>(this: seq<'T>) : 'T =\n        Seq.exactlyOne this\n\n    static member Single<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        let x =\n            (None, this)\n            ||> Seq.fold (fun state cur ->\n                if predicate.Invoke cur then\n                    if state.IsSome then\n                        invalidOp \"Sequence contains more than one matching element\"\n                    else Some cur\n                else state\n            )\n        match x with\n        | None -> invalidOp \"Sequence contains no elements\"\n        | Some x -> x\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>) : 'T =\n        LinqProxy.SingleOrDefault(this, fun _ -> true)\n\n    [<Inline>]\n    static member SingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>) : 'T =\n        LinqProxy.JSSingleOrDefault(this, predicate, Unchecked.defaultof<'T>)\n\n    [<Name \"SingleOrDefault\">]\n    static member JSSingleOrDefault<'T>(this: seq<'T>, predicate: Func<'T, bool>, defaultValue: 'T) : 'T =\n        use e = this.GetEnumerator()\n        let mutable found = None\n        while e.MoveNext() do\n            if predicate.Invoke e.Current then\n                match found with\n                | None -> found <- Some e.Current\n                | Some _ -> invalidOp \"Sequence contains more than one element\"\n        match found with\n        | Some x -> x\n        | None -> defaultValue\n\n    static member Skip<'T>(this: seq<'T>, count: int) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do i <- i + 1\n            while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    i <- i + 1\n                else\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    static member SkipWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable predWasTrue = true\n            while predWasTrue && e.MoveNext() do\n                if not (predicate.Invoke e.Current) then\n                    predWasTrue <- false\n            if not predWasTrue then\n                yield e.Current\n                while e.MoveNext() do yield e.Current\n        }\n\n    [<Inline>]\n    static member Sum(this: seq<int64>) : int64 =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int64>>) : Nullable<int64> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<float>) : float =\n        Seq.sum this\n\n    static member Sum(this: seq<Nullable<float>>) : Nullable<float> =\n        let s = this |> Seq.choose (fun x -> if x.HasValue then Some x.Value else None)\n        if Seq.isEmpty s then Nullable() else Nullable(Seq.sum s)\n\n    [<Inline>]\n    static member Sum(this: seq<Nullable<int>>) : Nullable<int> =\n        As(LinqProxy.Sum(Seq.cast<Nullable<float>> this))\n\n    [<Inline>]\n    static member Sum(this: seq<int>) : int =\n        Seq.sum this\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int64>) : int64 =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, float>) : float =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<float>>) : Nullable<float> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int64>>) : Nullable<int64> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, Nullable<int>>) : Nullable<int> =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    [<Inline>]\n    static member Sum<'T>(this: seq<'T>, selector: Func<'T, int>) : int =\n        LinqProxy.Sum(Seq.map selector.Invoke this)\n\n    static member Take<'T>(this: seq<'T>, count: int) =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while i < count && e.MoveNext() do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() && predicate.Invoke(e.Current, i) do\n                i <- i + 1\n                yield e.Current\n        }\n\n    static member TakeWhile<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            while e.MoveNext() && predicate.Invoke(e.Current) do\n                yield e.Current\n        }\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, false)\n\n    [<Inline>]\n    static member ThenBy<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, false)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, Comparer<_>.Default, true)\n\n    [<Inline>]\n    static member ThenByDescending<'T, 'K>(this: IOrderedEnumerable<'T>, keySelector: Func<'T, 'K>, comparer: IComparer<'K>) : IOrderedEnumerable<'T> =\n        this.CreateOrderedEnumerable(keySelector, comparer, true)\n\n    [<Inline>]\n    static member ToArray<'T>(this: seq<'T>) : 'T[] =\n        Seq.toArray this\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>) : Dictionary<'K, 'T> =\n        LinqProxy.ToDictionary(this, keySelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K> (this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'T> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, x)) this\n        d\n\n    [<Inline>]\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : Dictionary<'K, 'E> =\n        LinqProxy.ToDictionary(this, keySelector, elementSelector, EqualityComparer.Default)\n\n    static member ToDictionary<'T, 'K, 'E> (this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : Dictionary<'K, 'E> =\n        let d = Dictionary(comparer)\n        Seq.iter (fun x -> d.Add(keySelector.Invoke x, elementSelector.Invoke x)) this\n        d\n\n    [<Inline>]\n    static member ToList<'T>(this: seq<'T>) : List<'T> =\n        List<'T>(this)\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K>(this: seq<'T>, keySelector: Func<'T, 'K>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'T> =\n//        Lookup<'K, 'T, 'T>(this, keySelector, Func<'T,'T>(id), comparer) :> _\n\n    //[<Macro(typeof<LinqMacro>)>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, EqualityComparer<'K>.Default) :> _\n\n//    [<Inline>]\n//    static member ToLookup<'T, 'K, 'E>(this: seq<'T>, keySelector: Func<'T, 'K>, elementSelector: Func<'T, 'E>, comparer: IEqualityComparer<'K>) : ILookup<'K, 'E> =\n//        Lookup<'K, 'T, 'E>(this, keySelector, elementSelector, comparer) :> _\n\n    [<Inline>]\n    static member Union<'T>(this: seq<'T>, second: seq<'T>) : seq<'T> =\n        LinqProxy.Union(this, second, EqualityComparer<'T>.Default)\n\n    static member Union<'T>(this: seq<'T>, second: seq<'T>, comparer: IEqualityComparer<'T>) : seq<'T> =\n        let tbl = HashSet(this, comparer)\n        for e in second do tbl.Add(e) |> ignore\n        tbl :> _\n\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, int, bool>) : seq<'T> =\n        seq {\n            use e = this.GetEnumerator()\n            let mutable i = 0\n            while e.MoveNext() do\n                if predicate.Invoke(e.Current, i) then\n                    yield e.Current\n                i <- i + 1\n        }\n\n    [<Inline>]\n    static member Where<'T>(this: seq<'T>, predicate: Func<'T, bool>) : seq<'T> =\n        Seq.filter predicate.Invoke this\n\n    [<Inline>]\n    static member Zip<'T, 'U, 'R>(this: seq<'T>, second: seq<'U>, resultSelector: Func<'T, 'U, 'R>) : seq<'R> =\n        Seq.map2 (fun x y -> resultSelector.Invoke(x, y)) this second\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen System.Linq\nopen System.Collections\nopen System.Collections.Generic\nopen WebSharper.Core\nopen WebSharper.JavaScript\nopen FSharp.Quotations\n\nopen FSharp.Linq\n\n[<Proxy(typeof<QuerySource<_,_>>)>]\ntype internal QuerySourceProxy<'T, 'Q> [<Inline \"$source\">] (source: IEnumerable<'T>) =\n\n    [<Inline \"$this\">]\n    member this.Source = source\n                                \n[<Proxy(typeof<QueryBuilder>)>]\n[<Name \"WebSharper.Query\">]\ntype internal QueryBuilderProxy() =\n    [<Inline>]\n    member this.All(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.forall predicate source.Source\n\n    [<Inline>]\n    member inline this.AverageBy\n            (source: QuerySource<'T, 'Q>, projection: 'T -> ^Value) =\n        Seq.averageBy projection source.Source\n\n    [<Name \"averageByNullable\">]\n    static member inline AverageByNullableImpl \n            (source: QuerySource<'T, 'Q>, projection: 'T -> Nullable< ^TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        if filtered.Length = 0 then Nullable() else Nullable(Array.average filtered) \n\n    [<Inline>]\n    member inline this.AverageByNullable (source, projection) = QueryBuilderProxy.AverageByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Contains(source: QuerySource<'T, 'Q>, key: 'T) =\n        Seq.contains key source.Source\n\n    [<Inline>]\n    member this.Count(source: QuerySource<'T, 'Q>) =\n        Seq.length source.Source\n\n    [<Inline>]\n    member this.Distinct(source: QuerySource<'T, 'Q>) =\n        Seq.distinct source.Source |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ExactlyOne(source: QuerySource<'T, 'Q>) =\n        Seq.exactlyOne source.Source\n     \n    [<Inline>]\n    member this.ExactlyOneOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.SingleOrDefault()\n\n    [<Inline>]\n    member this.Exists(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.exists predicate source.Source\n     \n    [<Inline>]\n    member this.Find(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        Seq.find predicate source.Source\n\n    [<Inline>]\n    member this.For(source: QuerySource<'T, 'Q>, body: 'T -> QuerySource<'TResult, 'Q2>) =\n        Seq.collect (fun x -> (body x).Source) source.Source |> QuerySource<'TResult, 'Q>\n     \n    [<Inline>]\n    member this.GroupBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy(fun x -> keySelector x) |> QuerySource<IGrouping<'TKey, 'T>, 'Q>\n\n    [<Inline>]\n    member this.GroupJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.GroupValBy<'T, 'TKey, 'TValue, 'Q>(source: QuerySource<'T, 'Q>, resultSelector: 'T -> 'TValue, keySelector: 'T -> 'TKey) =\n        source.Source.GroupBy((fun x -> keySelector x), (fun x -> resultSelector x)) |> QuerySource<IGrouping<'TKey, 'TValue>, 'Q>\n\n    [<Inline>]\n    member this.Head(source: QuerySource<'T, 'Q>) =\n        Seq.head source.Source\n\n    [<Inline>]\n    member this.HeadOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.FirstOrDefault()\n    \n    [<Inline>]\n    member this.Join\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> 'TInner -> 'TResult\n      ) =\n        outerSource.Source.Join(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x y)\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Last(source: QuerySource<'T, 'Q>) =\n        Seq.last source.Source\n \n    [<Inline>]\n    member this.LastOrDefault(source: QuerySource<'T, 'Q>) =\n        source.Source.LastOrDefault()\n\n    [<Inline>]\n    member this.LeftOuterJoin\n      (\n        outerSource: QuerySource<'TOuter, 'Q>, innerSource: QuerySource<'TInner, 'Q>, \n        outerKeySelector: 'TOuter -> 'TKey, innerKeySelector: 'TInner -> 'TKey,\n        resultSelector: 'TOuter -> seq<'TInner> -> 'TResult\n      ) =\n        outerSource.Source.GroupJoin(\n            innerSource.Source, \n            (fun x -> outerKeySelector x), \n            (fun x -> innerKeySelector x), \n            (fun x y -> resultSelector x (y.DefaultIfEmpty()))\n        ) |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.MaxBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Max(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MaxByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Max(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.MinBy(source: QuerySource<'T, 'Q>, valueSelector: 'T -> 'TValue) =\n        source.Source.Min(fun x -> valueSelector x)\n    \n    [<Inline>]\n    member this.MinByNullable(source: QuerySource<'T, 'Q>, valueSelector: 'T -> Nullable<'TValue>) =\n        source.Source.Min(fun x -> valueSelector x)\n\n    [<Inline>]\n    member this.Nth(source: QuerySource<'T, 'Q>, index: int) =\n        Seq.item index source.Source\n\n    [<Inline>]\n    member this.Quote(q: Expr<'T>) = q\n\n    [<Inline>]\n    member this.Run(q: Expr<QuerySource<'T, IQueryable>>) =\n        (As<QuerySource<'T, obj>> q).Source |> As<IQueryable<'T>>      \n           \n    [<Inline>]\n    member this.Select(source: QuerySource<'T, 'Q>, projection: 'T -> 'TResult) =\n        source.Source |> Seq.map projection |> QuerySource<'TResult, 'Q>\n\n    [<Inline>]\n    member this.Skip(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Skip(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SkipWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.SkipWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    [<Inline>]\n    member this.SortBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.SortByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        source.Source.OrderByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Source(source: seq<'T>) = \n        QuerySource<'T,  System.Collections.IEnumerable>(source)\n\n    [<Inline>]\n    member this.Source(source: IQueryable<'T>) = \n        QuerySource<'T, 'Q>(source)\n\n    [<Inline>]                                                              \n    member inline this.SumBy(source: QuerySource<'T, 'Q>, projection: 'T -> ^TValue) =\n        Seq.sumBy projection source.Source\n\n    [<Name \"sumByNullable\">]                                                              \n    static member inline SumByNullableImpl(source: QuerySource<'T, 'Q>, projection: 'T -> Nullable<'TValue>) =\n        let filtered =\n            source.Source |> Seq.choose (fun x ->\n                Option.ofNullable (projection x) \n            ) |> Array.ofSeq\n        Nullable(Array.sum filtered) \n\n    [<Inline>]\n    member inline this.SumByNullable(source, projection) = QueryBuilderProxy.SumByNullableImpl(source, projection)\n\n    [<Inline>]\n    member this.Take(source: QuerySource<'T, 'Q>, count: int) =\n        source.Source.Take(count) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.TakeWhile(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.TakeWhile(fun x -> predicate x) |> QuerySource<'T, 'Q>\n    \n    static member CheckThenBySource(source: IEnumerable<'T>) =\n        match source with\n        | :? IOrderedEnumerable<'T> as e ->\n            e\n        | _ ->\n            failwith \"'thenBy' and 'thenByDescending' may only be used with an ordered input\"\n\n    [<Inline>]\n    member this.ThenBy(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> 'TKey) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullable(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenBy(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.ThenByNullableDescending(source: QuerySource<'T, 'Q>, keySelector: 'T -> Nullable<'TKey>) =\n        QueryBuilderProxy.CheckThenBySource(source.Source).ThenByDescending(fun x -> keySelector x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Where(source: QuerySource<'T, 'Q>, predicate: 'T -> bool) =\n        source.Source.Where(fun x -> predicate x) |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.Yield(value: 'T) =\n        Seq.singleton value |> QuerySource<'T, 'Q>\n\n    [<Inline>]\n    member this.YieldFrom(computation: QuerySource<'T, 'Q>) =\n        computation\n    \n    [<Inline>]\n    member this.Zero() =\n        Seq.empty |> QuerySource<'T, 'Q>\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Core.ExtraTopLevelOperators, FSharp.Core\">]\nmodule internal ExtraTopLevelOperatorsQueryProxy =\n    \n    [<Inline \"null\">]\n    let query = query\n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority, FSharp.Core\">]\nmodule internal HighPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsEnumerable (this: QueryBuilder) (q: Expr<QuerySource<'T, IEnumerable>>) =\n        (As<QuerySource<'T, IEnumerable>> q).Source   \n\n[<WebSharper.Proxy \"Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority, FSharp.Core\">]\nmodule internal LowPriorityProxy =                          \n    \n    [<Inline>]\n    let RunQueryAsValue (this: QueryBuilder) (q: Expr<'T>) =\n        As<'T> q\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.JavaScript\n\nopen System\nopen System.Runtime.CompilerServices\nopen System.Threading.Tasks\nopen WebSharper\n\n[<JavaScript>]\ntype NonStandardPromiseRejectionException(reason: obj) =\n    inherit Exception(\"Promise rejected\")\n\n    member this.Reason = reason\n\n[<JavaScript>]\nmodule Promise =\n\n    let private unwrapExn (x: obj) : exn =\n        match x with\n        | :? exn as e -> e\n        | x -> NonStandardPromiseRejectionException x :> exn\n\n    let OfAsync (a: Async<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            Async.StartWithContinuations(a, resolve, reject, reject)\n        )\n\n    let OfTask (t: Task<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            t.ContinueWith(fun (t: Task<'T>) ->\n                if t.IsCanceled then\n                    reject (TaskCanceledException())\n                elif t.IsFaulted then\n                    reject t.Exception\n                else // RanToCompletion\n                    resolve t.Result\n            )\n            |> ignore\n        )\n\n    let AsAsync (p: Promise<'T>) : Async<'T> =\n        Async.FromContinuations(fun (ok, ko, _) ->\n            p.Then(ok, fun (err: obj) ->\n                ko (unwrapExn err)\n            )\n            |> ignore\n        )\n\n    let AsTask (p: Promise<'T>) : Task<'T> =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n        p.Then(tcs.SetResult, fun (err: obj) ->\n            tcs.SetException(unwrapExn err)\n        )\n        |> ignore\n        tcs.Task\n\n    let private For (xs: seq<'T>) (f: 'T -> Promise<unit>) : Promise<unit> =\n        let e = xs.GetEnumerator()\n        let rec run() : Promise<unit> =\n            if e.MoveNext() then\n               (f e.Current).Then<unit>(run)\n            else\n                Promise.Resolve(())\n        // Call run() in a Promise rather than immediately,\n        // or .Finally wouldn't catch an exception when enumerating the first item.\n        Promise<unit>(fun (resolve, reject) -> resolve (unbox<unit>(run())))\n            .Finally(fun () -> e.Dispose())\n\n    type Builder [<Inline \"null\">] internal () =\n\n        [<Inline>]\n        member this.Bind(p: Promise<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            p.Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Async<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfAsync a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Task<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfTask a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Return(x: 'T) : Promise<'T> =\n            Promise<'T>.Resolve(x)\n\n        [<Inline>]\n        member this.ReturnFrom(x: Promise<'T>) : Promise<'T> =\n            x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Async<'T>) : Promise<'T> =\n            OfAsync x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Task<'T>) : Promise<'T> =\n            OfTask x\n\n        [<Inline>]\n        member this.Using(x: 'T when 'T :> IDisposable, f: 'T -> Promise<'U>) : Promise<'U> =\n            Promise(fun (resolve, reject) -> resolve (unbox<'U> (f x)))\n                .Finally(fun () -> x.Dispose())\n\n        [<Inline>]\n        member this.For(xs: seq<'T>, f: 'T -> Promise<unit>) : Promise<unit> =\n            For xs f\n\n        [<Inline>]\n        member this.Zero() : Promise<unit> =\n            Promise.Resolve(())\n\n        [<Inline>]\n        member this.Combine(p1: Promise<'T>, p2: Promise<'T>) : Promise<'T> =\n            p1.Then<'T>(fun _ -> p2)\n\n        [<Inline>]\n        member this.TryWith(p: Promise<'T>, f: exn -> Promise<'T>) : Promise<'T> =\n            p.Catch<'T>(unwrapExn >> f)\n\n        [<Inline>]\n        member this.TryFinally(p: Promise<'T>, f: unit -> unit) : Promise<'T> =\n            p.Finally(fun () -> f())\n\n        [<Inline>]\n        member this.Delay(f: unit -> Promise<'T>) : Promise<'T> =\n            Promise<'T>(fun (resolve, _) -> resolve (unbox<'T> (f())))\n\n    [<Inline>]\n    let Do = Builder()\n\n[<Extension; JavaScript>]\ntype PromiseExtensions =\n\n    [<Extension; Inline>]\n    static member AsAsync this = Promise.AsAsync this\n\n    [<Extension; Inline>]\n    static member AsTask this = Promise.AsTask this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfAsync this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfTask this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines operators and functions that are automatically available whenever\n/// `WebSharper` is open.\n[<AutoOpen>]\nmodule WebSharper.JavaScript.Pervasives\n\nopen WebSharper\nmodule M = WebSharper.Core.Macros\n\n/// Casts an object to the desired type.\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"$x * $y\">]\nlet ( *. ) x y = X<obj>\n\n[<Inline \"$x / $y\">]\nlet ( /. ) x y = X<obj>\n\n[<Inline \"$x % $y\">]\nlet ( %. ) x y = X<obj>\n\n[<Inline \"$x + $y\">]\nlet ( +. ) x y = X<obj>\n\n[<Inline \"$x - $y\">]\nlet ( -. ) x y = X<obj>\n\n[<Inline \"$x << $y\">]\nlet ( <<. ) x y = X<obj>\n\n[<Inline \"$x >> $y\">]\nlet ( >>. ) x y = X<obj>\n\n[<Inline \"$x >>> $y\">]\nlet ( >>>. ) x y = X<obj>\n\n[<Inline \"$x < $y\">]\nlet ( <. ) x y = X<bool>\n\n[<Inline \"$x > $y\">]\nlet ( >. ) x y = X<bool>\n\n[<Inline \"$x >= $y\">]\nlet ( >=. ) x y = X<bool>\n\n[<Inline \"$x <= $y\">]\nlet ( <=. ) x y = X<bool>\n\n[<Inline \"$x == $y\">]\nlet ( ==. ) x y = X<bool>\n\n[<Inline \"$x === $y\">]\nlet ( ===. ) x y = X<bool>\n\n[<Inline \"$x != $y\">]\nlet ( !=. ) x y = X<bool>\n\n[<Inline \"$x !== $y\">]\nlet ( !==. ) x y = X<bool>\n\n[<Inline \"$x | $y\">]\nlet ( |. ) x y = X<obj>\n\n[<Inline \"$x & $y\">]\nlet ( &. ) x y = X<obj>\n\n[<Inline \"$x ^ $y\">]\nlet ( ^. ) x y = X<obj>\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"[$x,$y]\">]\nlet ( => ) (x: string) (y: obj) = (x, y)\n\n[<JavaScript>]\nlet private NewFromSeq<'T> (fields: seq<string * obj>) : 'T =\n    let r = JS.Inline \"{}\"\n    for (k, v) in fields do\n        (?<-) r k v\n    As r\n\n/// Constructs a new object as if an object literal was used.\n[<Macro(typeof<M.New>); Inline>]\nlet New<'T> (fields: seq<string * obj>) = NewFromSeq<'T> fields\n\n/// Constructs an proxy to a remote object instance.\n[<Constant null>]\nlet Remote<'T> = X<'T>\n\n/// Gets JavaScript properties in sequence dynamically from an object.\n[<JavaScript; Macro(typeof<M.GetJS>)>]\nlet GetJS<'T> (x: obj) (items: seq<string>) =\n    let mutable x = x\n    for i in items do\n        x <- x?(i)\n    As<'T> x    \n\n/// Erases generic parameters inside this expression during WebSharper translation.\n/// You can get use this to translate `defaultof` inside a generic function.\n[<Macro(typeof<M.DefaultToUndefined>)>]\nlet DefaultToUndefined<'T> (x: 'T) = x\n\nmodule Optional =\n    /// Converts an F# option value to a JavaScript erased option\n    [<Inline>]\n    let ofOption x =\n        match x with\n        | None -> Undefined\n        | Some v -> Defined v\n\n    /// Converts a JavaScript erased option to an F# option value\n    [<Inline>]\n    let toOption x =\n        match x with\n        | Undefined -> None\n        | Defined v -> Some v\n\n    [<Inline \"$x !== undefined\">]\n    let isDefined x =\n        match x with\n        | Undefined -> false\n        | Defined _ -> true\n\n    [<Inline \"$x === undefined\">]\n    let isUndefined x =\n        match x with\n        | Undefined -> true\n        | Defined _ -> false\n\nmodule Union =\n// {{ generated by genInterop.fsx, do not modify\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice2 (x: Choice<'T1, 'T2>) = X<Union<'T1, 'T2>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice2 x =\n        match x with\n        | Union1Of2 v -> Choice1Of2 v\n        | Union2Of2 v -> Choice2Of2 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice3 (x: Choice<'T1, 'T2, 'T3>) = X<Union<'T1, 'T2, 'T3>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice3 x =\n        match x with\n        | Union1Of3 v -> Choice1Of3 v\n        | Union2Of3 v -> Choice2Of3 v\n        | Union3Of3 v -> Choice3Of3 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice4 (x: Choice<'T1, 'T2, 'T3, 'T4>) = X<Union<'T1, 'T2, 'T3, 'T4>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice4 x =\n        match x with\n        | Union1Of4 v -> Choice1Of4 v\n        | Union2Of4 v -> Choice2Of4 v\n        | Union3Of4 v -> Choice3Of4 v\n        | Union4Of4 v -> Choice4Of4 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice5 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice5 x =\n        match x with\n        | Union1Of5 v -> Choice1Of5 v\n        | Union2Of5 v -> Choice2Of5 v\n        | Union3Of5 v -> Choice3Of5 v\n        | Union4Of5 v -> Choice4Of5 v\n        | Union5Of5 v -> Choice5Of5 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice6 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice6 x =\n        match x with\n        | Union1Of6 v -> Choice1Of6 v\n        | Union2Of6 v -> Choice2Of6 v\n        | Union3Of6 v -> Choice3Of6 v\n        | Union4Of6 v -> Choice4Of6 v\n        | Union5Of6 v -> Choice5Of6 v\n        | Union6Of6 v -> Choice6Of6 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice7 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice7 x =\n        match x with\n        | Union1Of7 v -> Choice1Of7 v\n        | Union2Of7 v -> Choice2Of7 v\n        | Union3Of7 v -> Choice3Of7 v\n        | Union4Of7 v -> Choice4Of7 v\n        | Union5Of7 v -> Choice5Of7 v\n        | Union6Of7 v -> Choice6Of7 v\n        | Union7Of7 v -> Choice7Of7 v\n// }}\n\n/// The computation expression for JavaScript Promises.\n[<Inline>]\nlet promise = Promise.Builder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen WebSharper.JavaScript\nmodule Js = WebSharper.Core.Json\nmodule Re = WebSharper.Core.Resources\n\ntype Resource() =\n    interface Re.IResource with\n        member this.Render ctx =\n            let name = if ctx.DebuggingEnabled then \"Json.js\" else \"Json.min.js\"\n            let ren = Re.Rendering.GetWebResourceRendering(ctx, typeof<Resource>, name)\n            fun html ->\n                let html = html Re.Scripts\n                html.WriteLine \"<!--[if lte IE 7.0]>\"\n                ren.Emit(html, Re.Js)\n                html.WriteLine \"<![endif]-->\"\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"JSON.parse($json)\">]\n[<Require(typeof<Resource>)>]\nlet Parse (json: string) = X<obj>\n\n[<Inline \"JSON.stringify($obj)\">]\n[<Require(typeof<Resource>)>]\nlet Stringify (obj: obj) = X<string>\n\n/// Lookups an object by its FQN.\n[<JavaScript>]\nlet lookup<'T> (x: string []) : obj =\n    let k = x.Length\n    let mutable r = JS.Global\n    let mutable i = 0\n    while i < k do\n        let n  = x.[i]\n        let rn = (?) r n\n        if JS.TypeOf rn <> JS.Undefined then\n            r <- rn\n            i <- i + 1\n        else\n            failwith (\"Invalid server reply. Failed to find type: \" + n)\n    r\n\n/// Does a shallow generic mapping over an object.\n[<JavaScript>]\nlet shallowMap (f: obj -> obj) (x: obj) : obj =\n    if x :? System.Array then\n        As (Array.map f (As x))\n    else\n        match JS.TypeOf x with\n        | JS.Object ->\n            let r = New []\n            JS.ForEach x (fun y -> (?<-) r y (f ((?) x y)); false)\n            r\n        | _ ->\n            x\n\ntype SpecialTypes =\n    | List = 1\n    | Decimal = 2\n\n[<JavaScript>]\n[<Require(typeof<Resource>)>]\nlet Activate<'T> (json: obj) : 'T =\n    let types = if As json then json?(\"$TYPES\") : obj[] else JS.Undefined\n    let data =\n        if types ===. JS.Undefined then\n            json\n        else\n            for i = 0 to types.Length - 1 do\n                types.[i] <- \n                    match As<string[]> types.[i] with\n                    | [| \"WebSharper\"; \"List\"; \"T\" |] -> box SpecialTypes.List\n                    | [| \"WebSharper\"; \"Decimal\" |] -> box SpecialTypes.Decimal\n                    | t -> lookup t\n            json?(\"$DATA\")\n    let rec decode (x: obj) : obj =\n        if x = null then x else\n            match JS.TypeOf x with\n            | JS.Object ->\n                if x :? System.Array then\n                    shallowMap decode x\n                else\n                    let o  = shallowMap decode (x?(\"$V\"))\n                    let ti = x?(\"$T\")\n                    if ti ===. JS.Undefined then o else\n                        let t = types.[ti]\n                        if t ===. SpecialTypes.List then\n                            box (List.ofArray (As<obj[]> o))\n                        elif t ===. SpecialTypes.Decimal then\n                            box (JS.Global?WebSharper?Decimal?CreateDecimalBits(o))\n                        else\n                            let r = JS.New types.[ti]\n                            JS.ForEach o (fun k -> (?<-) r k ((?) o k); false)\n                            r\n            | _ ->\n                x\n    As (decode data)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Remoting\n\nopen WebSharper.JavaScript\n\nmodule R = WebSharper.Core.Remoting\n\n[<JavaScript>]\nlet mutable EndPoint = \"?\"\n\n[<JavaScript>]\nlet UseHttps() =\n    try\n        if not (JS.Window.Location.Href.StartsWith \"https://\") then\n            EndPoint <- JS.Window.Location.Href.Replace(\"http://\", \"https://\")\n            true\n        else false\n    with _ ->\n        // This function is intended to be callable from the top-level in a module,\n        // which means that it will be (unnecessarily) called on the server too\n        // and throw NotImplementedException. Just silence it.\n        false\n\ntype Data = string\ntype Headers = obj\ntype Url = string\n\n[<JavaScript>]\ntype IAjaxProvider =\n    [<Name \"Async\">]\n    abstract member Async : Url -> Headers -> Data -> (Data -> unit) -> (exn -> unit) -> unit\n\n    [<Name \"Sync\">]\n    abstract member Sync : Url -> Headers -> Data -> Data\n\n[<Direct @\"\n    var xhr = new XMLHttpRequest();\n    var csrf = document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*csrftoken\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1');\n    xhr.open('POST', $url, $async);\n    if ($async == true) {\n        xhr.withCredentials = true;\n    }\n    for (var h in $headers) {\n        xhr.setRequestHeader(h, $headers[h]);\n    }\n    if (csrf) {\n        xhr.setRequestHeader('x-csrftoken', csrf);\n    }\n    function k() {\n        if (xhr.status == 200) {\n            $ok(xhr.responseText)\n        } else if ($csrf && xhr.status == 403 && xhr.responseText == 'CSRF') {\n            $csrf();\n        } else {\n            var msg = 'Response status is not 200: ';\n            $err(new Error(msg + xhr.status));\n        }\n    }\n    if ('onload' in xhr) {\n        xhr.onload = xhr.onerror = xhr.onabort = k;\n    } else {\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                k();\n            }\n        };\n    }\n    xhr.send($data);\n\">]\nlet private ajax (async: bool) (url: Url) (headers: Headers) (data: Data)\n    (ok: Data -> unit) (err: exn -> unit) (csrf: unit -> unit) = ()\n\ntype XhrProvider [<JavaScript>] () =\n    interface IAjaxProvider with\n\n        [<JavaScript>]\n        member this.Async url headers data ok err =\n            ajax true url headers data ok err\n                (fun () -> ajax true url headers data ok err JS.Undefined)\n\n        [<JavaScript>]\n        member this.Sync url headers data =\n            let res = ref Unchecked.defaultof<_>\n            ajax false url headers data\n                (fun x -> res := x)\n                (fun e -> raise e)\n                (fun () ->\n                    ajax false url headers data\n                        (fun x -> res := x)\n                        (fun e -> raise e)\n                        JS.Undefined)\n            !res\n\n[<JavaScript>]\nlet mutable AjaxProvider = XhrProvider() :> IAjaxProvider\n\n[<JavaScript>]\nlet private makeHeaders (m: string) =\n    New [\n        \"content-type\" => \"application/json\"   \n        \"x-websharper-rpc\" => m\n    ]\n\n[<JavaScript>]\nlet private makePayload (data: obj []) =\n    Json.Stringify data\n\n[<JavaScript>]\ntype IRemotingProvider =\n    [<Name \"Sync\">]\n    abstract member Sync : string -> obj[] -> obj\n    [<Name \"Async\">]\n    abstract member Async : string -> obj[] -> Async<obj>\n    [<Name \"Task\">]\n    abstract member Task : string -> obj[] -> System.Threading.Tasks.Task<obj>\n    [<Name \"Send\">]\n    abstract member Send : string -> obj[] -> unit\n\n[<JavaScript>]\n[<Name \"WebSharper.Remoting.AjaxRemotingProvider\">]\ntype AjaxRemotingProvider() =\n    abstract EndPoint : string\n    override this.EndPoint = EndPoint\n\n    abstract AsyncBase : string * obj[] -> Async<obj> \n    override this.AsyncBase(m, data) = \n        async {\n            let headers = makeHeaders m\n            let payload = makePayload data\n            let! token = Async.CancellationToken\n            return! Async.FromContinuations (fun (ok, err, cc) ->\n                let waiting = ref true\n                let reg =\n                    token.Register(fun () ->\n                        if !waiting then\n                            waiting := false\n                            cc (new System.OperationCanceledException(token))\n                    )\n                let ok (x: Data) = \n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        ok (Json.Activate (Json.Parse x))\n                let err (e: exn) =\n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        err e\n                AjaxProvider.Async this.EndPoint headers payload ok err)\n        }\n\n    interface IRemotingProvider with\n        member this.Sync m data : obj =\n            let data = AjaxProvider.Sync this.EndPoint (makeHeaders m) (makePayload data)\n            Json.Activate (Json.Parse data)\n\n        member this.Async m data : Async<obj> =\n            this.AsyncBase(m, data)\n\n        member this.Task m data : System.Threading.Tasks.Task<obj> =\n            this.AsyncBase(m, data) |> Async.StartAsTask   \n\n        member this.Send m data =\n            Async.Start (Async.Ignore (this.AsyncBase(m, data)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nmodule M = WebSharper.Core.Metadata\nmodule J = WebSharper.Core.Json\n\n/// An interface that has to be implemented by controls\n/// that depend on resources.\ntype IRequiresResources =\n    abstract member Requires : M.Info -> seq<M.Node>\n    abstract member Encode : M.Info * J.Provider -> list<string * J.Encoded>\n\n/// HTML content that can be used as the Body of a web Control.\n/// Can be zero, one or many DOM nodes.\ntype IControlBody =\n    /// Replace the given node with the HTML content.\n    /// The node is guaranteed to be present in the DOM.\n    /// Called exactly once on startup on an IControl's Body.\n    [<JavaScript; Name \"ReplaceInDom\">]\n    abstract ReplaceInDom : Dom.Node -> unit\n\n/// An interface that has to be implemented by controls that\n/// are subject to activation, ie. server-side controls that\n/// contain client-side elements.\ntype IControl =\n    inherit IRequiresResources\n    [<JavaScript; Name \"Body\">]\n    abstract member Body : IControlBody\n    abstract member Id : string\n\n[<AutoOpen>]\nmodule HtmlContentExtensions =\n\n    [<JavaScript>]\n    type private SingleNode(node: Dom.Node) =\n        interface IControlBody with\n            member this.ReplaceInDom(old) =\n                node.ParentNode.ReplaceChild(node, old) |> ignore\n\n    [<JavaScript>]\n    type IControlBody with\n        /// Create HTML content comprised of a single DOM node.\n        static member SingleNode (node: Dom.Node) =\n            new SingleNode(node) :> IControlBody\n\n[<JavaScript>]\nmodule Activator =\n\n    /// The identifier of the meta tag holding the controls.\n    [<Literal>]\n    let META_ID = \"websharper-data\"\n\n    let mutable Instances : obj = null\n\n    let private onReady (f: unit -> unit) =\n        let mutable readyFired = false\n        let rec ready() =\n            if not readyFired then\n                readyFired <- true\n                f()\n                JS.Document.RemoveEventListener(\"DOMContentLoaded\", ready, false)\n                JS.Window.RemoveEventListener(\"load\", ready, false)\n        if JS.Document?readyState = \"complete\" then\n            ready()\n        else\n            JS.Document.AddEventListener(\"DOMContentLoaded\", ready, false)\n            JS.Window.AddEventListener(\"load\", ready, false)\n\n    let private Activate() =\n        if As JS.Document then\n            let meta = JS.Document.GetElementById(META_ID)\n            if (As meta) then\n                onReady <| fun () ->\n                    let text = meta.GetAttribute(\"content\")\n                    let obj = Json.Activate (Json.Parse text)\n                    JS.GetFields obj\n                    |> Array.iter (fun (k, v) ->\n                        match v with\n                        | :? IControl as v ->\n                            let p = v.Body\n                            let old = JS.Document.GetElementById k\n                            p.ReplaceInDom old\n                        | _ -> ()\n                    )\n                    Instances <- obj\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Comparers\n\nopen WebSharper\n\n[<JavaScript>]\ntype private EquatableEqualityComparer<'T when 'T :> System.IEquatable<'T>>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = (x :> System.IEquatable<_>).Equals(y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private BaseEqualityComparer<'T>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = obj.Equals(box x, box y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private ComparableComparer<'T when 'T :> System.IComparable<'T>>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = (x :> System.IComparable<'T>).CompareTo(y)\n\n[<JavaScript>]\ntype private BaseComparer<'T when 'T : comparison>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = compare x y\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\nmodule private WebSharper.Utils\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nlet toSafe (s: string) =\n    if s ==. null then \"\" else s  \n\n[<JavaScript>]\nlet plusForPos (n: obj, s) =\n    if 0 <=. n then \"+\" + s else s     \n\n[<JavaScript>]\nlet spaceForPos (n: obj, s) =\n    if 0 <=. n then \" \" + s else s      \n\n[<Inline \"$s.substr(1)\">]\nlet skip1 (s: string) = X<string>\n\n[<JavaScript>]\nlet padNumLeft (s: string, l) =\n    let f = (As<string[]> s).[0]\n    if f = \" \" || f = \"+\" || f = \"-\" then\n        f + (skip1 s).PadLeft(l - 1, '0')\n    else s.PadLeft(l, '0')\n\n[<JavaScript>]\nlet printList (p: obj -> string, o: obj list) =\n    \"[\" + (o |> Seq.map p |> String.concat \"; \") + \"]\" \n\n[<JavaScript>]\nlet printArray (p: obj -> string, o: obj[]) =\n    if o ===. null then \"null\" else\n    \"[|\" + (o |> Array.map p |> String.concat \"; \") + \"|]\" \n\n[<JavaScript>]\nlet printArray2D (p: obj -> string, o: obj[,]) =\n    if o ===. null then \"null\" else\n     \"[[\" + (\n        seq {\n            let l2 = Array2D.length2 o\n            for i in 0 .. Array2D.length1 o - 1 ->\n                seq { for j in 0 .. l2 - 1 -> p o.[i, j] } \n                |> String.concat \"; \"\n        }\n        |> String.concat \"][\"\n     ) + \"]]\" \n\n[<JavaScript>]\nlet rec prettyPrint (o: obj) =\n    let printObject (o: obj) =\n        let s = string o\n        if s = \"[object Object]\" then\n            \"{\" + (JS.GetFields o |> Array.map (fun (k, v) -> k + \" = \" + prettyPrint v) |> String.concat \"; \") + \"}\"\n        else s\n    if o ===. null then \"null\" else\n    let t = JS.TypeOf o\n    if t  ==. JS.String then\n        \"\\\"\" + As o + \"\\\"\"\n    elif t  ==. JS.Object then\n        if o :? System.Array then\n            \"[|\" + (As o |> Array.map prettyPrint |> String.concat \"; \") + \"|]\"\n        else printObject o\n    else string o\n\n[<JavaScript>]\n[<Name \"WebSharper.Operators.charRange\">]\nlet charRange (min: char) (max: char) : seq<char> =\n    let minv = int min\n    let count = 1 + int max - minv\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> char (x + minv))\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.op\">]\nlet nullableOp (a: obj) (b: obj) f = if a ==. null || b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opL\">]\nlet nullableOpL (a: obj) (b: obj) f = if a ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opR\">]\nlet nullableOpR (a: obj) (b: obj) f = if b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmp\">]\nlet nullableCmp (a: obj) (b: obj) f = if a ==. null || b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpE\">]\nlet nullableCmpE (a: obj) (b: obj) f =\n    if a ==. null then\n        b ==. null\n    elif b ==. null then \n        false \n    else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpL\">]\nlet nullableCmpL (a: obj) (b: obj) f = if a ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpR\">]\nlet nullableCmpR (a: obj) (b: obj) f = if b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.conv\">]\nlet nullableConv (a: obj) f = if a ==. null then null else f a", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements concurrency primitives.\nmodule internal WebSharper.Concurrency\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype private OCE = System.OperationCanceledException\n\n[<JavaScript; Prototype false>]\ntype Result<'T> =\n    | Ok of 'T\n    | No of exn\n    | Cc of OCE\n  \n[<JavaScript; Prototype false>]\ntype CT =\n    { \n        [<Name \"c\">] mutable IsCancellationRequested : bool \n        [<Name \"r\">] Registrations : (unit -> unit)[]\n    }\n\n[<Inline \"$arr.push($item)\">]\nlet private push arr item = X<int>\n\n[<JavaScript>]\nlet internal noneCT =           \n    { \n        IsCancellationRequested = false\n        Registrations = [||]\n    }\n\n[<JavaScript>]\nlet internal Register (ct: CT) (callback: unit -> unit) =\n    if ct ===. noneCT then\n        { new System.IDisposable with\n            member this.Dispose() = ()\n        }\n    else\n        let i = push ct.Registrations callback - 1\n        { new System.IDisposable with\n            member this.Dispose() = ct.Registrations.[i] <- ignore\n        }\n\n[<JavaScript; Prototype false>]\ntype AsyncBody<'T> =\n    {\n        k  : Result<'T> -> unit\n        ct : CT\n    }\n\ntype Concurrent<'T>     = AsyncBody<'T> -> unit\nand private C<'T>       = Concurrent<'T>\n\ntype private Queue<'T>  = System.Collections.Generic.Queue<'T>\ntype Milliseconds       = int\n\ntype private Scheduler [<JavaScript>]() =\n    let mutable idle    = true\n    let robin           = Queue<unit->unit>()\n\n    [<JavaScript>]\n    let rec tick () =\n        let t = System.DateTime.Now\n        let mutable loop = true\n        while loop do\n            match robin.Count with\n            | 0 ->\n                idle <- true\n                loop <- false\n            | _ ->\n                robin.Dequeue()()\n                if System.DateTime.Now - t > System.TimeSpan.FromMilliseconds 40. then\n                    JS.SetTimeout tick 0 |> ignore\n                    loop <- false\n\n    [<JavaScript>]\n    member this.Fork(action: unit -> unit) =\n        robin.Enqueue action\n        if idle then\n            idle <- false\n            JS.SetTimeout tick 0 |> ignore\n\n[<JavaScript>]\nlet private scheduler = Scheduler()\n\n[<JavaScript>]\nlet internal defCTS = ref(new System.Threading.CancellationTokenSource())\n\n[<Inline>]\nlet fork action = scheduler.Fork action\n\n[<JavaScript>]\nlet private cancel c = c.k (Cc (new OCE(As<System.Threading.CancellationToken> c.ct)))\n\n[<JavaScript>]\nlet private checkCancel r =\n    ()\n    fun c -> if c.ct.IsCancellationRequested then cancel c else r c\n\n[<JavaScript; Pure>]\nlet Return (x: 'T) : C<'T> =\n    ()\n    fun c -> c.k (Ok x)\n\n[<JavaScript; Pure>]\nlet Zero =\n    Return ()\n\n[<JavaScript; Pure>]\nlet Bind (r: C<'T>, f: 'T -> C<'R>) =\n    checkCancel <| fun c ->\n        r { \n            k = function \n                | Ok x -> fork (fun () -> try f x c with e -> c.k (No e))\n                | res  -> fork (fun () -> c.k (As res)) // error or cancellation\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Combine (a: C<unit>, b: C<'T>) : C<'T> = \n    Bind (a, fun _ -> b)\n\n[<Inline>]\nlet Ignore (r: C<'T>): C<unit> = As<C<unit>> r\n\n[<JavaScript; Pure>]\nlet Delay (mk: unit -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        try mk () c with e -> c.k (No e)\n\n[<JavaScript; Pure>]\nlet TryFinally (run: C<'T>, f: unit -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = fun r -> \n                try f ()\n                    c.k r \n                with e -> c.k (No e)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet TryWith (r: C<'T>, f: exn -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        r {\n            k = function\n                | Ok x -> c.k (Ok x)\n                | No e as res -> try f e c with e -> c.k (As res)\n                | res -> c.k (As res)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Catch (r : C<'T>) : C<Choice<'T, exn>> =\n    ()\n    fun c ->\n        try r {\n                k = function \n                    | Ok x -> c.k (Ok (Choice1Of2 x))\n                    | No e -> c.k (Ok (Choice2Of2 e))\n                    | res  -> c.k (As res)\n                ct = c.ct\n            }\n        with e -> c.k (Ok (Choice2Of2 e))\n\n[<JavaScript; Pure>]\nlet GetCT : C<CT> =\n    ()\n    fun c -> c.k (Ok c.ct)\n\n[<JavaScript; Pure>]\nlet FromContinuations (subscribe: ('T -> unit) * (exn -> unit) * (OCE -> unit) -> unit) : C<'T> =\n    ()\n    fun c ->\n        let continued = ref false\n        let once cont : unit =\n            if !continued then failwith \"A continuation provided by Async.FromContinuations was invoked multiple times\" else\n            continued := true\n            fork cont   \n        subscribe (\n            fun a -> once (fun () -> c.k (Ok a))\n        ,   fun e -> once (fun () -> c.k (No e))\n        ,   fun e -> once (fun () -> c.k (Cc e))\n        )\n\n[<JavaScript>]\nlet StartWithContinuations (c: C<'T>, s: 'T -> unit, f: exn -> unit, cc: OCE -> unit, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | Ok x -> s x\n                | No e -> f e\n                | Cc e -> cc e\n            ct = ct\n        }\n\n[<JavaScript>]\nlet UncaughtAsyncError (e: exn) =\n    Console.Log (\"WebSharper: Uncaught asynchronous exception\", e)\n\n[<JavaScript>]\nlet Start (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    fork (fun () -> \n        if not ct.IsCancellationRequested then\n            c {\n                k = function\n                    | No e -> UncaughtAsyncError e\n                    | _ -> ()\n                ct = ct\n            }\n    )\n\n[<JavaScript>]\nlet StartImmediate (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | No e -> UncaughtAsyncError e\n                | _ -> ()\n            ct = ct\n        }\n\n#nowarn \"40\"\n\n[<JavaScript; Pure>]\nlet AwaitEvent (e: IEvent<'T>, ca: option<unit -> unit>) : C<'T> =\n    ()\n    fun c ->\n        let mutable sub = JS.Undefined<System.IDisposable>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        sub <-\n            e.Subscribe (fun x -> \n                sub.Dispose()\n                creg.Dispose()\n                fork (fun () -> c.k (Ok x))        \n            )\n        creg <-\n            Register c.ct (fun () -> \n                match ca with\n                | Some ca ->\n                    ca()\n                | _ ->\n                    sub.Dispose()\n                    fork (fun () -> cancel c)    \n            ) \n\n[<JavaScript; Pure>]\nlet AwaitTask (t: System.Threading.Tasks.Task) : C<unit> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun t ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok()   \n        ) |> ignore\n    )\n\n[<JavaScript; Pure>]\nlet AwaitTask1 (t: System.Threading.Tasks.Task<'T>) : C<'T> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun (t: System.Threading.Tasks.Task<'T>) ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok t.Result  \n        ) |> ignore\n    )\n\n[<JavaScript>]\nlet StartAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    fork (fun () ->\n        StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    )\n    tcs.Task\n\n[<JavaScript>]\nlet StartImmediateAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    tcs.Task\n\n[<JavaScript; Pure>]\nlet Sleep (ms: Milliseconds) : C<unit> =\n    ()\n    fun c ->\n        let mutable pending = JS.Undefined<JS.Handle>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        pending <-\n            JS.SetTimeout (fun () -> \n                creg.Dispose()\n                fork (fun () -> c.k (Ok ()))\n            ) ms\n        creg <-\n            Register c.ct (fun () -> \n                JS.ClearTimeout pending\n                fork (fun () -> cancel c)\n            )\n\n[<JavaScript; Pure>]\nlet Parallel (cs: seq<C<'T>>) : C<'T[]> =\n    let cs = Array.ofSeq cs\n    if cs.Length = 0 then Return [||] else\n    fun c ->\n        let n = Array.length cs\n        let o = ref n\n        let a = As<'T[]>(JavaScript.Array(n))\n        let accept i x =\n            match !o, x with\n            | 0, _     -> ()\n            | 1, Ok x  -> a.[i] <- x; o := 0; c.k (Ok a)\n            | n, Ok x  -> a.[i] <- x; o := n - 1\n            | n, res   -> o := 0; c.k (As res)\n        Array.iteri (fun i run ->\n            fork (fun () -> run { k = accept i; ct = c.ct }))\n            cs\n\n[<JavaScript; Pure>]\nlet StartChild (r : C<'T>, t: Milliseconds option) : C<C<'T>> =\n    ()\n    fun c ->\n        let inTime = ref true\n        let cached = ref None\n        let queue  = Queue()\n        let tReg =\n            match t with\n            | Some timeout ->\n                JS.SetTimeout (fun () ->\n                    inTime := false\n                    let err = No (System.TimeoutException())\n                    while queue.Count > 0 do\n                        queue.Dequeue() err\n                ) timeout |> Some     \n            | _ -> None\n        fork (fun _ ->\n            if not c.ct.IsCancellationRequested then\n                r {\n                    k = fun res ->\n                        if !inTime then\n                            cached := Some res\n                            match tReg with\n                            | Some r -> JS.ClearTimeout r\n                            | _ -> ()\n                            while queue.Count > 0 do\n                                queue.Dequeue() res\n                    ct = c.ct\n                }\n        )\n        let r2 c2 =            \n            if !inTime then\n                match cached.Value with\n                | Some x    -> c2.k x\n                | None      -> queue.Enqueue c2.k\n            else c2.k (No (System.TimeoutException()))\n        c.k (Ok r2)\n\n[<JavaScript>]\nlet StartChildAsTask (r : C<'T>) =\n    ()\n    fun c ->\n        let ch = StartChild(r, None)\n        ch {\n            k = function\n                | Ok r2 -> c.k (Ok (StartImmediateAsTask(r2, Some c.ct)))\n                | _ -> ()\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet OnCancel (action: unit -> unit) : C<System.IDisposable> =\n    ()\n    fun c -> c.k (Ok (Register c.ct action))\n\n[<JavaScript; Pure>]\nlet TryCancelled (run: C<'T>, comp: OCE -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = function\n                | Cc e as res ->\n                    comp e\n                    c.k res\n                | res -> c.k res\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Using (x: 'U, f: 'U -> C<'T>) =\n    TryFinally (f x, fun () -> (x :> System.IDisposable).Dispose())\n\n[<JavaScript; Pure>]\nlet rec While (g: unit -> bool, c: C<unit>) : C<unit> = \n    if g() then \n        Bind (c, fun () -> While (g, c)) \n    else\n        Return ()\n\n[<JavaScript; Pure>]\nlet rec For (s: seq<'T>, b: 'T -> C<unit>) =\n    Using (s.GetEnumerator(), fun ie -> \n        While ((fun () -> ie.MoveNext()), \n            Delay (fun () -> b ie.Current)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides an `IEnumerator` implementation.\nmodule private WebSharper.Enumerator\n\nopen WebSharper.JavaScript\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n/// Represents an unfolding enumerator.\n[<Sealed>]\ntype T<'S,'T> [<JavaScript>] (s: 'S, c: 'T, n: T<'S,'T> -> bool, d: T<'S,'T> -> unit) =\n    [<Inline; JavaScript>] \n    member this.MoveNext() = n this\n    member this.State with [<Inline; JavaScript>] get() = s and [<Inline; JavaScript>] set (v: 'S) = this?s <- v\n    member this.Current with [<Inline; JavaScript>] get() = c and [<Inline; JavaScript>] set (v: 'T) = this?c <- v\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = n this\n        [<JavaScript>]\n        member this.Current with get() = box c\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = c\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = if As d then d this\n\n/// Constructs a new `IEnumerator` by unfolding a function.\n[<Inline>]\n[<JavaScript>]\nlet New<'S,'T> (state: 'S) (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, As JS.Undefined)) \n\n[<Inline>]\n[<JavaScript>]\nlet NewDisposing<'S,'T> (state: 'S) dispose (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, dispose))\n\n[<Inline \"$x.GetEnumerator()\">]\nlet getEnumerator (x: obj) : IE<'T> = X\n\n[<JavaScript>]\nlet ArrayEnumerator (s: obj[]) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet StringEnumerator (s: string) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet Get (x: seq<'T>) : IE<'T> =\n    if x :? System.Array then\n        ArrayEnumerator (As x)\n    elif JS.TypeOf x = JS.String then\n        StringEnumerator (As x)\n    else\n        getEnumerator x\n\n[<Inline \"'GetEnumerator0' in $x ? $x.GetEnumerator0() : $x.GetEnumerator()\">]\nlet getEnumerator0 (x: obj) : System.Collections.IEnumerator = X\n\n[<JavaScript>]\nlet Get0 (x: System.Collections.IEnumerable) : System.Collections.IEnumerator =\n    if x :? System.Array then\n        As (ArrayEnumerator (As x))\n    elif JS.TypeOf x = JS.String then\n        As (StringEnumerator (As x))\n    else\n        getEnumerator0 x\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides seq/list/array proxies\n[<JavaScript>]\nmodule internal WebSharper.CollectionInternals\n\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Arrays.splitInto\">]\nlet ArraySplitInto count (arr: 'T[]) =\n    if count <= 0 then failwith \"Count must be positive\"\n    let len = arr.Length\n    if len = 0 then\n        [| |]\n    else\n        let count = min count len\n        let res = Array.zeroCreate count : 'T[][]\n        let minChunkSize = len / count\n        let mutable startIndex = 0\n        for i = 0 to len % count - 1 do\n            res.JS.[i] <- Array.sub arr startIndex (minChunkSize + 1)\n            startIndex <- startIndex + minChunkSize + 1\n        for i = len % count to count - 1 do\n            res.JS.[i] <-  Array.sub arr startIndex minChunkSize\n            startIndex <- startIndex + minChunkSize\n        res\n\n[<Name \"WebSharper.Arrays.contains\">]\nlet ArrayContains (item: 'T) (arr: 'T[])  =\n    let mutable c = true\n    let mutable i = 0\n    let l = arr.Length\n    while c && i < l do\n        if arr.JS.[i] = item then\n            c <- false\n        else\n            i <- i + 1\n    not c\n\n[<Name \"WebSharper.Arrays.tryFindBack\">]\nlet ArrayTryFindBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        let r = arr.JS.[i]\n        if f r then res <- Some r\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.tryFindIndexBack\">]\nlet ArrayTryFindIndexBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        if f arr.[i] then res <- Some i\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.mapFold\">]\nlet ArrayMapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) (zero: 'S) (arr: 'T[]) : 'R[] * 'S =\n    let r = JavaScript.Array(Array.length arr)\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        let a, b = f acc arr.JS.[i]\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapFoldBack\">]\nlet ArrayMapFoldBack<'T,'S,'R> (f: 'T -> 'S -> 'R * 'S) (arr: 'T[]) (zero: 'S) : 'R[] * 'S =\n    let r = JavaScript.Array<'R>(Array.length arr)\n    let mutable acc = zero\n    let len = Array.length arr\n    for j = 1 to len do\n        let i = len - j\n        let a, b = f arr.JS.[i] acc\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapInPlace\">]\nlet mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f arr.JS.[i])\n\n[<Name \"WebSharper.Arrays.mapiInPlace\">]\nlet mapiInPlace (f: int -> 'T1 -> 'T2) (arr: 'T1 []) : 'T2[] =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f i arr.JS.[i])\n    As arr\n\n[<Name \"WebSharper.Arrays.sortInPlaceByDescending\">]\nlet ArraySortInPlaceByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"WebSharper.Seq.tryHead\">]\nlet SeqTryHead (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryItem\">]\nlet SeqTryItem i (s: seq<'T>) =\n    if i < 0 then None else\n    let mutable j = 0\n    use e = Enumerator.Get s\n    let mutable go = true\n    while go && j <= i do\n        if e.MoveNext() then\n            j <- j + 1\n        else\n            go <- false\n    if go then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryLast\">]\nlet SeqTryLast (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then \n        while e.MoveNext() do ()\n        Some e.Current \n    else None\n\n[<Name \"WebSharper.Seq.chunkBySize\">]\nlet SeqChunkBySize (size: int) (s: seq<'T>) =\n    if size <= 0 then failwith \"Chunk size must be positive\"\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) <| fun e ->\n            if e.State && o.MoveNext() then\n                let res = [|o.Current|]\n                while e.State && res.Length < size do\n                    if o.MoveNext() then\n                        res.JS.Push o.Current |> ignore\n                    else \n                        e.State <- false\n                e.Current <- res\n                true\n            else false\n\n[<Name \"WebSharper.Arrays.countBy\">]\nlet ArrayCountBy (f: 'T -> 'K) (a: 'T[]) : ('K * int)[] =\n    let d = System.Collections.Generic.Dictionary<'K, int>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k] <- d.[k] + 1 \n        else\n            keys.Push(k) |> ignore\n            d.Add(k, 1)\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.except\">]\nlet SeqExcept (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet(itemsToExclude)\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"WebSharper.List.skip\">]\nlet ListSkip i (l : list<'T>) =\n    let mutable res = l\n    for j = 1 to i do\n        match res with \n        | _ :: t ->\n            res <- t\n        | [] -> failwith \"Input list too short.\"\n    res\n\n[<Name \"WebSharper.Arrays.groupBy\">]\nlet ArrayGroupBy (f: 'T -> 'K when 'K : equality) (a: 'T[]) : ('K * 'T[])[] =\n    let d = System.Collections.Generic.Dictionary<'K, 'T[]>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k].JS.Push(c) |> ignore\n        else\n            keys.Push(k) |> ignore\n            d.Add(k, [| c |])\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.insufficient\">]\nlet InsufficientElements() =\n    failwith \"The input sequence has an insufficient number of elements.\"\n\n[<Name \"WebSharper.Seq.last\">]\nlet SeqLast (s: seq<_>) =\n    use e = Enumerator.Get s\n    if not <| e.MoveNext() then InsufficientElements()\n    else \n        while e.MoveNext() do ()\n        e.Current\n\n[<Name \"WebSharper.Seq.contains\">]\nlet SeqContains (el: 'T) (s: seq<'T>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- e.Current = el\n    r\n\n[<Name \"WebSharper.List.skipWhile\">]\nlet rec ListSkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    let mutable rest = list\n    while not (List.isEmpty rest) && predicate (List.head rest) do\n        rest <- List.tail rest \n    rest\n\n[<Name \"WebSharper.Seq.nonNegative\">]\nlet InputMustBeNonNegative() =\n    failwith \"The input must be non-negative.\"\n\n[<Name \"WebSharper.Arrays.transposeArray\">]\nlet ArrayTranspose (array:'T[][]) : 'T[][] =\n    let len = array.Length\n    if len = 0 then [||] else\n    let lenInner = array.[0].Length\n\n    for j in 1..len-1 do\n        if lenInner <> array.[j].Length then\n            failwith \"The arrays have different lengths.\"\n\n    let result = Array lenInner\n    for i in 0..lenInner-1 do\n        result.[i] <- Array len\n        for j in 0..len-1 do\n            result.[i].[j] <- array.[j].[i]\n    As result", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\n#nowarn \"864\"\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.Object>)>]\n[<Name \"WebSharper.Obj\">]\ntype private ObjectProxy() =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Name \"GetHashCode\">]\n    member this.GetHashCodeImpl() = -1\n\n    [<Name \"Equals\">]\n    member this.EqualsImpl(obj: obj) = this ===. obj\n\n    [<Inline>]\n    static member Equals(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member ReferenceEquals(a: obj, b: obj) = a ===. b\n\n    [<Inline>]\n    static member op_Equality(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member op_Inequality(a: obj, b: obj) = not (Unchecked.equals a b)\n\n    [<Inline>]\n    override this.ToString() = string this\n\n[<Proxy(typeof<System.ValueType>)>]\ntype private ValueTypeProxy =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Inline>]\n    override this.ToString() = string this", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.IntrinsicFunctionProxy\n\nopen System\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$value\">]\nlet UnboxGeneric<'T> (value: obj) = X<'T>\n\n[<Inline \"$value\">]\nlet UnboxFast<'T> (value: obj) = X<'T>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestGeneric<'T> (value: obj) = X<bool>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestFast<'T> (value: obj) = X<bool>\n\n[<Inline \"$arr.length\">]\nlet GetArray2DLength1 (arr: 'T[,]) = X<int>\n\n[<Inline \"$arr.length ? $arr[0].length : 0\">]\nlet GetArray2DLength2 (arr: 'T[,]) =  X<int>\n\n[<Name \"WebSharper.Arrays.checkBounds\">]\nlet checkBounds (arr: 'T[]) (n: int) =\n    if n < 0 || n >= Array.length arr then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Name \"WebSharper.Arrays.checkBounds2D\">]\nlet checkBounds2D<'T> (arr: 'T[,]) (n1: int) (n2: int) =\n    if n1 < 0 || n2 < 0 || n1 >= GetArray2DLength1 arr\n        || n2 >= GetArray2DLength2 arr then\n        raise (new IndexOutOfRangeException())\n\n[<Name \"WebSharper.Arrays.checkRange\">]\n\nlet checkRange (arr: 'T []) (start: int) (size: int) : unit =\n    if (size < 0) || (start < 0) || (Array.length arr < start + size) then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Inline \"$arr[$n]\">]\nlet GetArrayInternal<'T> (arr: 'T[]) (n:int) = X<'T>\n\n[<Inline \"void ($arr[$n] = $x)\">]\nlet SetArrayInternal<'T> (arr: 'T[]) (n:int) (x:'T) = ()\n\n[<Name \"WebSharper.Arrays.set\">]\nlet SetArray<'T> (arr: 'T[]) (n: int) (x: 'T) =\n    checkBounds arr n\n    SetArrayInternal arr n x\n\n[<Inline \"$s[$ix]\">]\n[<Name \"WebSharper.Strings.get\">]\nlet GetString (s: string) (ix: int) = X<char>\n\n[<Name \"WebSharper.Arrays.get\">]\nlet GetArray<'T> (arr: 'T[]) (n: int) =\n    checkBounds arr n\n    GetArrayInternal arr n\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Name \"WebSharper.Arrays.sub\">]\nlet GetArraySub<'T> (arr: 'T[]) start length =\n    checkRange arr start length\n    subArray arr start length\n\n[<Name \"WebSharper.Arrays.setSub\" >]\nlet SetArraySub<'T> (arr: 'T[]) start len (src: 'T[]) =\n    for i = 0 to len - 1 do\n        arr.[start+i] <- src.[i]\n\n[<Inline \"$arr[$n1][$n2]\">]\nlet GetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) = X<'T>\n\n[<Name \"WebSharper.Arrays.get2D\" >]\nlet GetArray2D (arr: 'T[,]) (n1: int) (n2: int) =\n    checkBounds2D arr n1 n2\n    GetArray2DInternal arr n1 n2\n\n[<Inline \"void ($arr[$n1][$n2] = $x)\">]\nlet SetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) (x:'T) = ()\n\n\n[<Name \"WebSharper.Arrays.set2D\" >]\nlet SetArray2D (arr: 'T[,]) (n1: int) (n2: int) (x: 'T) =\n    checkBounds2D arr n1 n2\n    SetArray2DInternal arr n1 n2 x\n\n[<Name \"WebSharper.Arrays.zeroCreate2D\" >]\nlet Array2DZeroCreate<'T> (n:int) (m:int) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.zeroCreate m))\n    arr?dims <- 2\n    arr\n\n[<Name \"WebSharper.Arrays.sub2D\" >]\nlet GetArray2DSub<'T> (src: 'T[,]) src1 src2 len1 len2 =\n    let len1 = (if len1 < 0 then 0 else len1)\n    let len2 = (if len2 < 0 then 0 else len2)\n    let dst = Array2DZeroCreate len1 len2\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[i,j] <- src.[src1 + i, src2 + j]\n    dst\n\n[<Name \"WebSharper.Arrays.setSub2D\" >]\nlet SetArray2DSub<'T> (dst: 'T[,]) src1 src2 len1 len2 (src: 'T[,]) =\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[src1+i, src2+j] <- src.[i, j]\n\n[<Name \"WebSharper.Arrays.length\" >]\nlet GetLength<'T> (arr: System.Array) =\n    match arr?dims with\n    | 2 -> GetArray2DLength1 (As arr) * GetArray2DLength1 (As arr)\n    | _ -> Array.length (As arr)\n\n[<Name \"WebSharper.checkThis\">]\nlet CheckThis (this: 'T) =\n    if this = null then\n        invalidOp \"The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.\"\n    else this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\ntype private IComparer = System.Collections.IComparer\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\ntype private JSArray<'T> = WebSharper.JavaScript.Array<'T>\ntype private Comparer<'T> = System.Collections.Generic.Comparer<'T>\n\n[<AutoOpen; JavaScript>]\nmodule ArrayProxy =\n\n    [<Name \"WebSharper.Arrays.binarySearch\">]\n    let binarySearch (haystack: 'T[]) (comparer: 'T -> int) start finish =\n        if start < 0 then raise (ArgumentOutOfRangeException(\"index\", \"Non-negative number required.\"))\n        if finish > haystack.Length then raise (ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\"))\n        if finish < start then raise (ArgumentOutOfRangeException(\"length\", \"Non-negative number required.\"))\n        let rec search left right =\n            if left > right then\n                ~~~left\n            else\n                let pivot = (left + right) / 2\n                let cmp = comparer haystack.[pivot]\n                if left = right then\n                    if cmp = 0 then left\n                    elif cmp > 0 then ~~~(left + 1)\n                    else ~~~left\n                elif cmp <= 0 then\n                    search left pivot\n                else\n                    search (pivot + 1) right\n        search start (finish - 1)\n\n    [<Name \"WebSharper.Arrays.binarySearchComparer\">]\n    let objBinarySearchComparer (needle: obj) =\n       // Check for an implementation of IComparable\n       if needle?CompareTo0 then\n           As<IComparable>(needle).CompareTo\n       else\n           fun x ->\n               if x?CompareTo0 then\n                   -As<IComparable>(x).CompareTo(needle)\n               else\n                   InvalidOperationException(\n                       \"Failed to compare two elements in the array.\",\n                       ArgumentException(\"At least one object must implement IComparable.\"))\n                   |> raise\n\n    [<Name \"WebSharper.Arrays.sortInternal\">]\n    let sortInternal (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) (swap: int -> int -> unit) : unit =\n        let partition l r =\n            let pivot = keys.JS.[r]\n            let mutable i = l - 1\n            for j = l to r - 1 do\n                if comp(keys.JS.[j], pivot) < 0 then\n                    i <- i + 1\n                    swap i j\n            if comp(keys.JS.[r], keys.JS.[i + 1]) < 0 then\n                swap (i + 1) r\n            i + 1\n        let rec quicksort l r =\n            if l < r then\n                let p = partition l r\n                quicksort l (p - 1)\n                quicksort (p + 1) r\n        quicksort index (index + length - 1)\n\n    [<Name \"WebSharper.Arrays.sortSub\">]\n    let sortSub (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n        sortInternal keys index length comp swap\n\n    [<Name \"WebSharper.Arrays.sortByKeys\">]\n    let sortByKeys (keys: 'K[]) (items: 'V[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n            let v = items.JS.[i]\n            items.JS.[i] <- items.JS.[j]\n            items.JS.[j] <- v\n        sortInternal keys index length comp swap\n\n[<Proxy(typeof<System.Array>)>]\ntype private ArrayProxy =\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Name \"WebSharper.Arrays.clear\">]\n    static member Clear(array: System.Array, index: int, length: int) : unit =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if index < 0 || length < 0 || index + length > array.Length then raise (IndexOutOfRangeException())\n        for i = index to index + length - 1 do\n            (As<JSArray<obj>> array).[i] <-\n                match JS.TypeOf (As<JSArray<obj>> array).[i] with\n                | JS.Number -> box 0\n                | _ -> null\n\n    [<Inline>]\n    member this.Clone() =\n        Array.copy (As<obj[]> this) :> obj\n\n    [<Name \"WebSharper.Arrays.constrainedCopy\">]\n    static member ConstrainedCopy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        if src ===. dst && dstIndex <= srcIndex + length then\n            let tmp = Array.init length (fun i -> (As<obj[]> src).[srcIndex + i])\n            Array.blit tmp 0 (As<obj[]> dst) dstIndex length\n        else\n            Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    static member Copy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    member this.CopyTo(dst: System.Array, index: int) =\n        if this.Length + index < dst.Length then raise (ArgumentException(\"array\"))\n        Array.blit (As<obj[]> this) 0 (As<obj[]> dst) index this.Length\n\n    [<Inline>]\n    static member Copy(src: System.Array, dst: System.Array, length: int) =\n        Array.blit (As<obj[]> src) 0 (As<obj[]> dst) 0 length\n\n    [<Inline>]\n    static member ConvertAll<'T, 'U>(array: 'T[], converter: Converter<'T, 'U>) : 'U[] =\n        Array.map converter.Invoke array\n\n    [<Inline>]\n    static member Empty<'T>() : 'T[] =\n        Array.empty\n\n    [<Inline>]\n    static member Exists<'T>(array: 'T[], predicate: Predicate<'T>) : bool =\n        Array.exists predicate.Invoke array\n\n    [<Inline>]\n    static member Find<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFind predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    static member FindAll<'T>(array: 'T[], predicate: Predicate<'T>) : 'T[] =\n        Array.filter predicate.Invoke array\n\n    [<Name \"WebSharper.Arrays.findIndexBound\">]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f finish i =\n            if i = finish then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f finish (i + 1)\n        f (startIndex + count) startIndex\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member FindLast<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFindBack predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Name \"WebSharper.Arrays.findLastIndexBound\">]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f i =\n            if i < startIndex then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f (i - 1)\n        f (startIndex + count - 1)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member ForEach<'T>(array: 'T[], action: Action<'T>) : unit =\n        Array.iter action.Invoke array\n\n    [<Inline>]\n    member this.GetValue(i: int) =\n        (As<obj[]> this).[i]\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member Resize<'T>(array: byref<'T[]>, newSize: int) =\n        let a = Array.zeroCreate newSize\n        if not (isNull array) then\n            Array.blit array 0 a 0 (min newSize array.Length)\n        array <- a\n\n    [<Inline \"$array.reverse()\">]\n    static member Reverse(array: System.Array) = X<unit>\n\n    [<Name \"WebSharper.Arrays.reverse\">]\n    static member Reverse(array: System.Array, offset: int, length: int) =\n        let a = Array.rev (Array.sub (As array) offset length)\n        Array.blit a 0 (As array) offset a.Length\n\n    [<Inline>]\n    member this.SetValue(v: obj, index: int) =\n        (As<obj[]> this).[index] <- v\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int, comp: IComparer<'K>) : unit =\n        sortByKeys keys items index length comp.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int) : unit =\n        sortByKeys keys items index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], comparer: IComparer<'K>) : unit =\n        sortByKeys keys items 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[]) : unit =\n        sortByKeys keys items 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int, comparer: IComparer<'K>) : unit =\n        sortSub keys index length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int) : unit =\n        sortSub keys index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparer: IComparer<'K>) : unit =\n        sortSub keys 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[]) : unit =\n        sortSub keys 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparison: Comparison<'K>) =\n        sortSub keys 0 keys.Length comparison.Invoke\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) index length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int) : unit =\n        sortSub (As<obj[]> keys) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member TrueForAll<'T>(array : 'T[], predicate: Predicate<'T>) : bool =\n        Array.forall predicate.Invoke array\n\n    member this.Length\n        with [<Inline>] get() = F.GetLength (As this)   \n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get0 (As this)         \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ArrayModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ArrayModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\nlet checkLength (arr1: 'T1[]) (arr2: 'T2[]) =\n    if Array.length arr1 <> Array.length arr2 then\n        failwith \"The arrays have different lengths.\"\n\n[<Inline \"$x.push($y)\">]\nlet push (x: obj) (y: obj) = ()\n\n[<Inline \"$arr1.concat($arr2)\">]\nlet Append<'T> (arr1: 'T []) (arr2: 'T []) : 'T [] = arr1\n\n[<Name \"allPairs\">]\nlet AllPairs (array1: 'T1 []) (array2: 'T2 []) =\n    let len1 = Array.length array1\n    let len2 = Array.length array2\n    let res = JavaScript.Array (len1 * len2)\n    for i = 0 to len1-1 do\n        for j = 0 to len2-1 do\n            res.[i * len2 + j] <- (array1.JS.[i],array2.JS.[j])\n    res |> As<('T1 * 'T2) []>\n\n[<Name \"average\">]\nlet inline Average (arr: 'T []): 'T = As (float (Array.sum arr) / float (Array.length arr))\n\n[<Name \"averageBy\">]\nlet inline AverageBy (f: 'T -> 'U) (arr: 'T []) : 'U = As (float (Array.sumBy f arr) / float (Array.length arr))\n\n[<Name \"blit\">]\nlet CopyTo<'T> (arr1: 'T [], start1, arr2: 'T [], start2, length) =\n    F.checkRange arr1 start1 length\n    F.checkRange arr2 start2 length\n    for i = 0 to length - 1 do\n        arr2.JS.[start2 + i] <- arr1.JS.[start1 + i]\n\n[<Name \"choose\">]\nlet Choose<'T,'U> (f: 'T -> option<'U>) (arr: 'T []) : 'U [] =\n    let q : 'U [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match f arr.JS.[i] with\n        | Some x -> push q x\n        | None   -> ()\n    q\n\n[<Inline \"Array.prototype.concat.apply([], $x)\"; Pure>]\nlet concatArray (x: 'T[][]) = X<'T[]>\n\n[<Name \"collect\">]\nlet Collect<'T,'U> (f: 'T -> 'U[]) (x: 'T []) : 'U[] =\n    concatArray (Array.map f x)\n\n[<Name \"concat\">]\nlet Concat<'T> (xs: seq<'T []>) : 'T [] =\n    concatArray (Array.ofSeq xs)\n\n[<Inline>]\nlet SplitInto count (arr: 'T[]) = ArraySplitInto count arr\n\n[<Inline \"$x.slice()\">]\nlet Copy (x: 'T []) = X<'T []>\n\n[<Name \"create\">]\nlet Create (size: int) value =\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- value\n    r.Self\n\n[<Inline \"[]\">]\nlet Empty () = X<'T []>\n\n[<Name \"exists\">]\nlet Exists<'T> (f: 'T -> bool) (x: 'T []) =\n    let mutable e = false\n    let mutable i = 0\n    let l = x.Length\n    while not e && i < l do\n        if f x.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n    e\n\n[<Name \"exists2\">]\nlet Exists2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable e = false\n    let mutable i = 0\n    let l = x1.Length\n    while not e && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n\n    e\n\n[<Name \"fill\">]\nlet Fill<'T> (arr: 'T []) (start: int) (length: int) (value: 'T) =\n    F.checkRange arr start length\n    for i = start to start + length - 1 do\n        arr.JS.[i] <- value\n\n[<Name \"filter\">]\nlet Filter<'T> f (arr: 'T []) : 'T [] =\n    let r : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push r arr.JS.[i]\n    r\n\n[<Name \"find\">]\nlet Find f (arr: _ []) =\n    match Array.tryFind f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex f (arr: _ []) =\n    match Array.tryFindIndex f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S =\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> f (zero: 'S) (arr1: 'T1 []) (arr2: 'T2 []) : 'S =\n    checkLength arr1 arr2\n    let mutable accum = zero\n    for i in 0 .. Array.length arr1 - 1 do\n        accum <- f accum arr1.JS.[i] arr2.JS.[i]\n    accum\n\n[<Name \"foldBack\">]\nlet FoldBack f (arr: _ []) zero =\n    let mutable acc = zero\n    let len = Array.length arr\n    for i = 1 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (arr1: _ []) (arr2: _ []) zero =\n    checkLength arr1 arr2\n    let len = Array.length arr1\n    let mutable accum = zero\n    for i in 1 .. len do\n        accum <- f arr1.JS.[len - i] arr2.JS.[len - i] accum\n    accum\n\n[<Name \"forall\">]\nlet ForAll f (x: _ []) =\n    let mutable a = true\n    let mutable i = 0\n    let l = x.Length\n    while a && i < l do\n        if f x.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable a = true\n    let mutable i = 0\n    let l = x1.Length\n    while a && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Inline>]\nlet Get (arr: _ []) index =\n    F.GetArray arr index\n\n[<Inline>]\nlet Item index (arr: _ []) =\n    F.GetArray arr index\n\n[<Name \"init\">]\nlet Initialize (size: int) f =\n    if size < 0 then\n        failwith \"Negative size given.\"\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- f i\n    r.Self\n\n[<Inline \"$arr.length == 0\">]\nlet IsEmpty (arr: _ []) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f arr.JS.[i]\n\n[<Name \"iter2\">]\nlet Iterate2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f arr1.JS.[i] arr2.JS.[i]\n\n[<Name \"iteri\">]\nlet IterateIndexed f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f i arr.JS.[i]\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f i arr1.JS.[i] arr2.JS.[i]\n\n[<Inline \"$arr.length\">]\nlet Length<'T> (arr: 'T []) = X<int>\n\n[<Name \"map\">]\nlet Map<'T1,'T2> (f: 'T1 -> 'T2) (arr: 'T1 []) : 'T2 [] =\n    let r = JavaScript.Array<'T2>(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        r.[i] <- f arr.JS.[i]\n    r.Self\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (arr1: 'T1 []) (arr2: 'T2 []) : 'T3 [] =\n    checkLength arr1 arr2\n    let r = JavaScript.Array<'T3>(Array.length arr2)\n    for i = 0 to Array.length arr2 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i]\n    r.Self\n\n[<Name \"mapi\">]\nlet MapIndexed f (arr: _ []) =\n    let y = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        y.[i] <- f i arr.JS.[i]\n    y.Self\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (arr1: 'T1 []) (arr2: 'T2 []): 'U[] =\n    checkLength arr1 arr2\n    let res = JavaScript.Array(Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.[i] <- f i arr1.JS.[i] arr2.JS.[i]\n    res.Self\n\n[<Inline>]\nlet MapFold<'T,'S,'R> f zero arr = ArrayMapFold<'T, 'S, 'R> f zero arr\n\n[<Inline>]\nlet MapFoldBack f arr zero = ArrayMapFoldBack f arr zero\n\nlet private nonEmpty (arr: _ []) =\n    if Array.length arr = 0 then\n        failwith \"The input array was empty.\"\n\n[<Name \"max\">]\nlet Max arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x > m then\n            m <- x\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"min\">]\nlet Min arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x < m then\n            m <- x\n    m\n\n\n[<Name \"minBy\">]\nlet MinBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"ofList\">]\nlet OfList<'T> (xs: list<'T>) =\n    let q : 'T [] = [||]\n    let mutable l = xs\n    while not (List.isEmpty l) do\n        push q l.Head\n        l <- l.Tail\n    q\n\n[<Name \"ofSeq\">]\nlet OfSeq<'T> (xs: seq<'T>) : 'T [] =\n    if xs :? System.Array then\n        Array.copy (As<'T[]> xs)\n    elif xs :? _ list then\n        Array.ofList (As<'T list> xs)\n    else\n        let q : 'T [] = [||]\n        use o = Enumerator.Get xs\n        while o.MoveNext() do\n            push q o.Current\n        q\n\n[<Name \"partition\">]\nlet Partition f (arr: 'T []) : 'T [] * 'T [] =\n    let ret1 : 'T [] = [||]\n    let ret2 : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push ret1 arr.JS.[i]\n        else\n            push ret2 arr.JS.[i]\n    (ret1, ret2)\n\n[<Name \"permute\">]\nlet Permute f (arr: 'T []) =\n    let ret = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        ret.[f i] <- arr.JS.[i]\n    ret.Self\n\n[<Name \"pick\">]\nlet Pick f (arr: _ []) =\n    match Array.tryPick f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"reduce\">]\nlet Reduce f (arr: _ []) =\n    nonEmpty arr\n    let mutable acc = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (arr: _ []) =\n    nonEmpty arr\n    let len = Array.length arr\n    let mutable acc = arr.JS.[len - 1]\n    for i = 2 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Inline \"$x.slice().reverse()\">]\nlet Reverse (x: 'T []) = X<'T []>\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S [] =\n    let ret = JavaScript.Array(1 + Array.length arr)\n    ret.[0] <- zero\n    for i = 0 to Array.length arr - 1 do\n        ret.[i + 1] <- f ret.[i] arr.JS.[i]\n    ret.Self\n\n[<Name \"scanBack\">]\nlet ScanBack (f: 'T -> 'S -> 'S) (arr: 'T []) (zero: 'S) : 'S [] =\n    let len = Array.length arr\n    let ret = JavaScript.Array(1 + len)\n    ret.[len] <- zero\n    for i = 0 to len - 1 do\n        ret.[len - i - 1] <- f arr.JS.[len - i - 1] ret.[len - i]\n    ret.Self\n\n[<Inline>]\nlet Set (arr: _ []) i v =\n    F.SetArray arr i v\n\n[<Name \"sort\">]\nlet Sort<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> Array.map fst\n\n[<Name \"sortBy\">]\nlet SortBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortInPlace\">]\nlet SortInPlace<'T when 'T: comparison> (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> mapInPlace fst\n\n[<Name \"sortInPlaceBy\">]\nlet SortInPlaceBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"sortInPlaceWith\">]\nlet SortInPlaceWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) =\n    arr.JS.Sort(fun (x, y) -> comparer x y) |> ignore\n\n[<Name \"sortWith\">]\nlet SortWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) : 'T [] =\n    (Array.copy arr).JS.Sort(fun (x, y) -> comparer x y)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> - compare x y) |> Array.map fst\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Inline>]\nlet GetSubArray (arr: 'T []) (start: int) (length: int) : 'T []=\n    F.GetArraySub arr start length\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $arr[i]; return sum\">]\n[<Name \"sum\">]\nlet Sum (arr: 'T []) : 'T = X<'T>\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $f($arr[i]); return sum\">]\n[<Name \"sumBy\">]\nlet SumBy (f: 'T -> 'U) (arr: 'T []) : 'U =  X<'U>\n\n[<Name \"transpose\">]\nlet Transpose (x: 'T[] seq) : 'T[][] =\n    match x with\n    | :? System.Array -> ArrayTranspose (As<'T[][]> x)\n    | _ -> ArrayTranspose (Array.ofSeq x)\n\n[<Inline>]\nlet ToList arr = List.ofArray arr\n\n[<Inline \"$arr\">]\nlet ToSeq (arr: _ []) = arr :> seq<_>\n\n[<Name \"tryFind\">]\nlet TryFind f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some arr.JS.[i]\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindBack f (arr: _ []) = ArrayTryFindBack f arr\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some i\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindIndexBack f (arr: _ []) = ArrayTryFindIndexBack f arr\n\n[<Name \"tryHead\">]\nlet TryHead (arr: 'T[]) =\n    if Array.length arr = 0 then None else Some arr.JS.[0]\n\n[<Name \"tryItem\">]\nlet TryItem i (arr: 'T[]) =\n    if Array.length arr <= i || i < 0 then None else Some arr.JS.[i]\n\n[<Name \"tryLast\">]\nlet TryLast (arr: 'T[]) =\n    let len = Array.length arr\n    if len = 0 then None else Some arr.JS.[len - 1]\n\n[<Name \"tryPick\">]\nlet TryPick f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        match f arr.JS.[i] with\n        | Some _ as r -> res <- r\n        | _ -> ()\n        i <- i + 1\n    res\n\n[<Name \"unzip\">]\nlet Unzip<'T1,'T2> (arr: ('T1 * 'T2) []) : 'T1 [] * 'T2 [] =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        let (a, b) = arr.JS.[i]\n        push x a\n        push y b\n    (x, y)\n\n[<Name \"unzip3\">]\nlet Unzip3<'T1,'T2,'T3> (arr: ('T1 * 'T2 * 'T3) []) =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    let z : 'T3 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match arr.JS.[i] with\n        | (a, b, c) ->\n            push x a\n            push y b\n            push z c\n    (x, y, z)\n\n[<Inline>]\n[<Name \"zeroCreate\">]\nlet ZeroCreate<'T> (size: int) =\n    Create size Unchecked.defaultof<'T>\n\n[<Name \"zip\">]\nlet Zip (arr1: 'T1 []) (arr2: 'T2 []) =\n    checkLength arr1 arr2\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i])\n    res\n\n[<Name \"zip3\">]\nlet Zip3 (arr1: _ [], arr2: _ [], arr3: _ []) =\n    checkLength arr1 arr2\n    checkLength arr2 arr3\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i], arr3.JS.[i])\n    res\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size array =\n    SeqChunkBySize size (Array.toSeq array)\n    |> Seq.toArray\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (a1: 'T []) (a2: 'T []) : int =\n    Seq.compareWith f (Array.toSeq a1) (Array.toSeq a2)\n\n[<Inline>]\nlet CountBy (f: 'T -> 'K) (a: 'T []) : ('K * int) [] =\n    ArrayCountBy f a\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: 'T []) : 'T [] =\n    Seq.distinct (Array.toSeq l)\n    |> Seq.toArray\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (a: 'T []) : 'T [] =\n    Seq.distinctBy f (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (a: 'T []) =\n    SeqExcept itemsToExclude (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"findBack\">]\nlet FindBack p (s: _ []) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: _ []) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (a: 'T []) : ('K * 'T []) [] =\n    ArrayGroupBy f a\n\n[<Name \"head\">]\nlet Head (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[0]\n\n[<Name \"last\">]\nlet Last (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[Array.length arr - 1]\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (arr1: 'T1 []) (arr2: 'T2 []) (arr3: 'T3 []) : 'T4 [] =\n    checkLength arr1 arr2\n    checkLength arr1 arr3\n    let r = JavaScript.Array<'T4>(Array.length arr3)\n    for i = 0 to Array.length arr3 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i] arr3.JS.[i]\n    r.Self\n\n[<Inline>]\nlet Contains (el: 'T) (a: 'T []) =\n    ArrayContains el a\n\n[<Name \"pairwise\">]\nlet Pairwise (a: 'T []) : ('T * 'T) [] =\n    Seq.pairwise (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    Array.create size value\n\n[<Name \"indexed\">]\nlet Indexed (ar : 'T []) : (int * 'T) [] =\n    Array.mapi (fun a b -> (a, b)) ar\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [| x |]\n\n[<Name \"skip\">]\nlet Skip<'T> i (ar : 'T []) =\n    if i < 0 then InputMustBeNonNegative() else\n    if i > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(i)\n\n[<Name \"skipWhile\">]\nlet SkipWhile<'T> (predicate : 'T -> bool) (ar : 'T []) : 'T [] =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(i)\n\n[<Name \"tail\">]\nlet Tail<'T> (ar : 'T []) : 'T [] =\n    Skip 1 ar\n\n[<Name \"take\">]\nlet Take<'T> n (ar: 'T []) =\n    if n < 0 then InputMustBeNonNegative() else\n    if n > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(0, n)\n\n[<Name \"takeWhile\">]\nlet TakeWhile<'T> (predicate : 'T -> bool) (ar: 'T []) =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(0, i)\n\n[<Inline>]\nlet Truncate<'T> n (ar: 'T []) =\n    ar.JS.Slice(0, n)\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (ar : 'T []) =\n    if Array.length ar = 1 then\n        ar.JS.[0]\n    else\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : 'T [] =\n    Seq.unfold f s\n    |> Seq.toArray\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T []) : 'T [] =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T []) : array<'T []> =\n    Seq.windowed windowSize (Array.toSeq s)\n    |> Seq.toArray\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (ar: 'T []) =\n    Take n ar, Skip n ar\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays2D\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.Array2DModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.Array2DModuleProxy\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Inline>]\nlet Length1 (arr: 'T[,]) = F.GetArray2DLength1 arr\n\n[<Inline>]\nlet Length2 (arr: 'T[,]) = F.GetArray2DLength2 arr\n\n[<Inline>]\nlet Get (array: 'T[,]) (n:int) (m:int) = F.GetArray2D array n m\n\n[<Inline>]\nlet Set (array: 'T[,]) (n:int) (m:int) (x:'T) = F.SetArray2D array n m x\n\n[<Inline>]\nlet ZeroCreate (n:int) (m:int) = F.Array2DZeroCreate n m\n    \n[<Inline>]\nlet Create n m (x:'T) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.create m x))\n    arr?dims <- 2\n    arr\n     \n[<Name \"init\">]\nlet Initialize n m f = \n    let array = ZeroCreate n m : 'T[,]  \n    for i = 0 to n - 1 do \n        for j = 0 to m - 1 do \n            array.[i, j] <- f i j\n    array\n\n[<Name \"iter\">]\nlet Iterate f array = \n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f array.[i,j]\n\n[<Name \"iteri\">]\nlet IterateIndexed (f : int -> int -> 'T -> unit) (array:'T[,]) =\n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f i j array.[i,j]\n\n[<Name \"map\">]\nlet Map f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f array.[i,j])\n\n[<Name \"mapi\">]\nlet MapIndexed f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f i j array.[i,j])\n\n[<Name \"copy\">]\nlet Copy array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> array.[i,j])\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\ntype private CT  = System.Threading.CancellationToken\ntype private CTS  = System.Threading.CancellationTokenSource\ntype private CTR  = System.Threading.CancellationTokenRegistration\ntype private OCE = System.OperationCanceledException\nmodule C = WebSharper.Concurrency\n\n[<Proxy(typeof<Async>)>]\ntype private AsyncProxy =\n\n    [<Inline>]\n    static member Catch(a: Async<'T>) : Async<Choice<'T,exn>>  =\n        As (C.Catch (As a))\n\n    [<Inline>]\n    static member Start(computation: Async<unit>, ?t: CT) : unit =\n        C.Start (As computation, As t)\n\n    [<Inline>]\n    static member Ignore (computation: Async<'T>) : Async<unit> =\n        As (C.Ignore (As computation))\n\n    [<Inline>]\n    static member Sleep milliseconds : Async<unit> =\n        As (C.Sleep milliseconds)\n\n    [<Inline>]\n    static member StartWithContinuations(op: Async<'T>,\n                                         c1: 'T -> unit,\n                                         c2: exn -> unit,\n                                         c3: OCE -> unit,\n                                         ?t: CT) : unit =\n        C.StartWithContinuations (As op, c1, c2, c3, As t)\n\n    [<Inline>]\n    static member FromContinuations(callback: (('T -> unit) *\n                                               (exn -> unit) *\n                                               (OCE -> unit)) -> unit)\n                                    : Async<'T> =\n        As (C.FromContinuations callback)\n\n    [<Inline>]\n    static member AwaitEvent(ev: IEvent<'D,'T>, ?t: unit -> unit) : Async<'T> =\n        As (C.AwaitEvent (As ev, t))\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task) : Async<unit> =\n        As (C.AwaitTask t)\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task<'T>) : Async<'T> =\n        As (C.AwaitTask1 t)\n\n    [<Inline>]\n    static member StartChild(a: Async<'T>, ?timeOut: int) : Async<Async<'T>> =\n        As (C.StartChild (As a, timeOut))\n\n    [<Inline>]\n    static member StartChildAsTask(a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions) \n        : Async<System.Threading.Tasks.Task<'T>> =\n        As (C.StartChildAsTask (As a))\n\n    [<Inline>]\n    static member Parallel(cs: seq<Async<'T>>) : Async<'T []> =\n        As (C.Parallel (As cs))\n\n    [<Inline>]\n    static member StartImmediate(c: Async<unit>, ?t: CT) : unit =\n        C.StartImmediate (As c, As t)\n\n    [<Inline>]\n    static member StartAsTask (a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartAsTask(As a, As t)        \n\n    [<Inline>]\n    static member StartImmediateAsTask (a: Async<'T>, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartImmediateAsTask(As a, As t)        \n\n    [<Inline>]\n    static member DefaultCancellationToken : CT =\n        As !C.defCTS\n\n    [<Inline>]\n    static member CancelDefaultToken() : unit =\n        let cts = !C.defCTS\n        C.defCTS := new CTS()\n        cts.Cancel()    \n\n    [<Inline>]\n    static member CancellationToken : Async<CT> =\n        As C.GetCT\n\n    [<Inline>]\n    static member OnCancel(action: unit -> unit) : Async<System.IDisposable> =\n        As (C.OnCancel action)\n    \n    [<Inline>]\n    static member TryCancelled(p: Async<'T>, f: OCE -> unit) : Async<'T> =\n        As (C.TryCancelled(As p, f))\n\n[<Proxy(typeof<CT>)>]\ntype private CancellationTokenProxy =\n    [<Inline \"$this.c\">]\n    member this.IsCancellationRequested = X<bool>\n\n    [<Inline>]\n    member this.Register(callback: System.Action) =\n        As<CTR> (C.Register (As this) callback.Invoke)\n\n    [<Inline>]\n    member this.ThrowIfCancellationRequested() =\n        if this.IsCancellationRequested then raise (OCE(As<CT> this)) \n\n    [<Inline>]\n    static member None = As<CT> C.noneCT\n        \n[<Proxy(typeof<CTS>)>]\n[<Name \"CancellationTokenSource\">]\ntype private CancellationTokenSourceProxy () =\n    let mutable c = false\n\n    let mutable pending = None\n\n    let r = [||] : (unit -> unit)[]\n\n    [<Inline>]\n    new (delay: int) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    new (delay: System.TimeSpan) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    member this.IsCancellationRequested = c\n\n    member this.Token \n        with [<Inline \"$this\">] get() = X<CT>\n\n    member this.Cancel() =\n        if not c then\n            c <- true\n            let errors = \n                r |> Array.choose (fun a -> \n                    try a()\n                        None\n                    with e -> Some e\n                )\n            if errors.Length > 0 then\n                raise (System.AggregateException(errors))    \n            \n    member this.Cancel(throwOnFirstException) =\n        if not throwOnFirstException then\n            this.Cancel()\n        else\n            if not c then\n                c <- true\n                r |> Array.iter (fun a -> a())   \n \n    member this.CancelAfter(delay: int) =\n        if not c then\n            pending |> Option.iter JS.ClearTimeout\n            pending <- Some <| JS.SetTimeout this.Cancel delay\n\n    [<Inline>]\n    member this.CancelAfter(delay: System.TimeSpan) = this.CancelAfter(As<int> delay)\n\n    static member CreateLinkedTokenSource(tokens: CT[]) =\n        let cts = new CTS()\n        tokens |> Array.iter (fun t -> t.Register(fun () -> cts.Cancel()) |> ignore)\n        cts\n\n    static member CreateLinkedTokenSource(t1: CT, t2: CT) =\n        CancellationTokenSourceProxy.CreateLinkedTokenSource [| t1; t2 |]\n\n[<Proxy(typeof<System.Threading.CancellationTokenRegistration>)>]\ntype private CancellationTokenRegistrationProxy =\n    [<Inline>]\n    member this.Dispose() = (this :> System.IDisposable).Dispose() \n    \n    interface System.IDisposable with\n        [<JavaScript false>]\n        member this.Dispose() = ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name \"Char\">]\n[<Proxy(typeof<System.Char>)>]\ntype private CharProxy =\n\n    [<Inline \"'\\u0000'\">]\n    new () = {}\n\n    [<Inline>]\n    member this.CompareTo(s: char) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: char) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    static member GetNumericValue(c: char) : float =\n        if c >= '0' && c <= '9' then float c - float '0' else -1.\n\n    [<Inline>]\n    static member GetNumericValue(s: string, i: int) = CharProxy.GetNumericValue(s.[i])\n\n    static member IsControl(c: char) : bool =\n        c >= '\\u0000' && c <= '\\u001f'\n        || c >= '\\u0080' && c <= '\\u009f'\n\n    [<Inline>]\n    static member IsControl(s: string, i: int) = CharProxy.IsControl(s.[i])\n\n    static member IsDigit(c: char) : bool =\n        c >= '0' && c <= '9'\n\n    [<Inline>]\n    static member IsDigit(s: string, i: int) = CharProxy.IsDigit(s.[i])\n\n    static member IsLetter(c: char) : bool =\n        c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLetter(s: string, i: int) = CharProxy.IsLetter(s.[i])\n\n    static member IsLetterOrDigit(c: char) : bool =\n        System.Char.IsLetter c || System.Char.IsDigit c\n\n    [<Inline>]\n    static member IsLetterOrDigit(s: string, i: int) = CharProxy.IsLetterOrDigit(s.[i])\n\n    static member IsLower(c: char) : bool =\n        c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLower(s: string, i: int) = CharProxy.IsLower(s.[i])\n\n    static member IsUpper(c: char) : bool =\n        c >= 'A' && c <= 'Z'\n\n    [<Inline>]\n    static member IsUpper(s: string, i: int) = CharProxy.IsUpper(s.[i])\n\n    [<Direct @\"$c.match(/\\s/) !== null\">]\n    static member IsWhiteSpace(c: char) = X<bool>\n\n    [<Inline>]\n    static member IsWhiteSpace(s: string, i: int) = CharProxy.IsWhiteSpace(s.[i])\n\n    static member Parse(s: string) =\n        if s.Length = 1 then As<char> s else\n            failwith \"String must be exactly one character long.\"\n\n    [<Inline \"String.fromCharCode($x.charCodeAt() + $y.charCodeAt())\">]\n    static member (+) (x: char, y: char) : char = x + y\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Util\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.CommonExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.CommonExtensionsProxy\n\nopen WebSharper.JavaScript\n\nlet observer (h: 'T -> unit) : System.IObserver<'T> =\n    { new System.IObserver<'T> with \n        member this.OnCompleted() = ()\n        member this.OnError _ = ()\n        member this.OnNext args = h args\n    }\n\n[<Inline>]\nlet AddToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h) |> ignore\n\n[<Inline>]\nlet SubscribeToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\nopen System\n\ntype private D = System.DateTime\ntype private K = System.DateTimeKind\ntype internal TS = System.TimeSpan\ntype private DO = System.DateTimeOffset\n\n[<JavaScript>]\n[<Name \"DateUtil\">]\nmodule private DateTimeHelpers =\n    let DatePortion (d: int) =\n        let e = Date(d)\n        Date(       \n            e.GetFullYear(),\n            e.GetMonth(),\n            e.GetDate()\n        ).GetTime()\n        |> As<D>        \n\n    let TimePortion (d: int) =\n        let e = Date(d)\n        TS(\n            0,\n            e.GetHours(), \n            e.GetMinutes(), \n            e.GetSeconds(), \n            e.GetMilliseconds()\n        )        \n        |> As<TS>        \n\n    let AddYears(d: int, years) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear() + years,\n            e.GetMonth(),\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()\n        |> As<D>        \n\n    let AddMonths(d: int, months: int) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear(),\n            e.GetMonth() + months,\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()    \n        |> As<D>        \n\n    let TryParse (s: string) =\n        let d = Date.Parse(s)   \n        if JS.IsNaN(d) then\n            None\n        else Some d\n\n    let Parse (s: string) =\n        match TryParse s with\n        | Some d -> d\n        | _ ->\n            failwith \"Failed to parse date string.\"\n\n    [<Direct \"(new Date($d)).toLocaleDateString({}, {year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'})\">]\n    let LongDate (d: obj) = X<string>\n     \n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', hour12: false})\">]\n    let ShortTime (d: obj) = X<string>\n\n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})\">]\n    let LongTime (d: obj) = X<string>\n                \n// DateTime is represented as an UTC epoch for remoting purposes.\n// Properties for getting sub-dates/times like Day or Hour convert it to local time on the client for easier display purposes.\n// This is inconsistent, but covers most common uses.\n// If you need UTC time details, use .JS and its UTC methods.\n[<Proxy(typeof<System.DateTime>)>]\ntype private DateTimeProxy =\n    [<Inline \"0\">]\n    new () = {}\n\n    [<Inline \"new Date($y,$mo-1,$d).getTime()\">]\n    new (y: int, mo: int, d: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s,$ms).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int, ms: int) = {}\n    \n    static member Now\n        with [<Inline \"Date.now()\">] get() = X<D>\n\n    static member UtcNow\n        with [<Inline \"Date.now()\">] get() = X<D>\n    \n    [<Inline \"1\">]\n    member this.Kind = X<System.DateTimeKind>\n\n    member this.Date \n        with [<Inline; JavaScript>] get() : D = DateTimeHelpers.DatePortion(As this)\n\n    static member Today\n        with [<Inline; JavaScript>] get() = DateTimeProxy.Now.Date  \n\n    member this.TimeOfDay \n        with [<Inline; JavaScript>] get() = DateTimeHelpers.TimePortion(As this)\n\n    member this.Year\n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetFullYear()\n\n    member this.Month \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMonth() + 1\n\n    member this.Day \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetDate()\n\n    member this.Hour \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetHours()\n                                                  \n    member this.Minute \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMinutes()\n    \n    member this.Second \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetSeconds()\n\n    member this.Millisecond \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMilliseconds()\n    \n    member this.DayOfWeek \n        with [<Inline; JavaScript>] get() = As<System.DayOfWeek>(Date(As<int> this).GetDay())\n\n    member this.Ticks\n        with [<Inline \"$this * 1E4\">] get() = X<int64>\n\n    [<Inline \"$this + $t\">]\n    member this.Add(t: TS) = X<D>\n                            \n    [<Inline \"$this - $t\">]\n    member this.Subtract(t: TS) = X<D>\n\n    [<Inline \"$this - $d\">]\n    member this.Subtract(d: D) = X<TS>\n\n    [<Inline; JavaScript>]\n    member this.AddYears(years: int) : D = DateTimeHelpers.AddYears(As this, years)\n\n    [<Inline; JavaScript>]\n    member this.AddMonths(months: int) : D = DateTimeHelpers.AddMonths(As this, months)\n\n    [<Inline; JavaScript>]\n    member this.AddDays(days: float) : D =\n        this.Add(TS.FromDays days)\n\n    [<Inline; JavaScript>]\n    member this.AddHours(hours: float) : D =\n        this.Add(TS.FromHours hours)\n\n    [<Inline; JavaScript>]\n    member this.AddMinutes(minutes: float) : D =\n        this.Add (TS.FromMinutes minutes)\n\n    [<Inline; JavaScript>]\n    member this.AddSeconds(seconds: float) : D =\n        this.Add (TS.FromSeconds seconds)\n\n    [<Inline; JavaScript>]\n    member this.AddMilliseconds(msec: float) : D =\n        this.Add (TS.FromMilliseconds msec)\n\n    [<Inline; JavaScript>]\n    member this.AddTicks(ticks: int64) : D =\n        this.Add (TS.FromTicks ticks)\n\n    [<Inline \"new Date($this).toLocaleDateString()\">]\n    member this.ToShortDateString() = X<string>\n    \n    [<Inline; JavaScript>]\n    member this.ToLongDateString() = DateTimeHelpers.LongDate(this)\n    \n    [<Inline; JavaScript>]\n    member this.ToShortTimeString() = DateTimeHelpers.ShortTime(this)\n\n    [<Inline; JavaScript>]\n    member this.ToLongTimeString() = DateTimeHelpers.LongTime(this)\n\n    [<Inline; JavaScript>]\n    static member Parse(s) = As<D>(DateTimeHelpers.Parse(s))\n\n    [<Inline; JavaScript>]\n    static member TryParse(s, [<Out>] res: byref<D>) =\n        match DateTimeHelpers.TryParse s with\n        | Some d ->\n            res <- As<D> d   \n            true\n        | _ -> false    \n\n    static member MaxValue\n        with [<Inline \"8640000000000000\">] get () = X<int>\n\n    static member MinValue\n        with [<Inline \"-8640000000000000\">] get () = X<int>\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: D) = X<TS>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a > $b\">]\n    static member op_GreaterThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a < $b\">]\n    static member op_LessThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a >= $b\">]\n    static member op_GreaterThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"$a <= $b\">]\n    static member op_LessThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"new Date($y, $mo, 0).getDate()\">]\n    static member DaysInMonth (y: int, mo: int) = X<int>\n\n    [<Inline \"new Date($y, 1, 29).getDate() == 29\">]\n    static member IsLeapYear (y: int) = X<bool>\n\n[<Proxy(typeof<System.DateTimeOffset>)>]\n[<Prototype false>]\n[<Name \"DateTimeOffset\">]\n// \"d\" contains UTC epoch time\n// \"o\" contains time zone offset in minutes\ntype private DateTimeOffsetProxy [<Inline \"{d: $d, o: $o}\">] (d: D, o: int) =\n\n    [<Inline>]\n    new (d: D, o: TS) = DateTimeOffsetProxy(d, int o.TotalMinutes) \n\n    [<Inline>]\n    new (d: D) = DateTimeOffsetProxy(d, 0) \n\n    member this.DateTime = d\n\n    [<Inline \"$this.o * 60000\">]\n    member this.Offset = X<TS>\n\n    [<Direct \"var d = new Date(); return { d: d.getTime(), o: -d.getTimezoneOffset() } \">]\n    static member Now = X<DO>\n\n    [<Inline \"{ d: Date.now(), o: 0 }\">]\n    static member UtcNow = X<DO>\n        \n    [<Inline>]\n    member this.ToLocalTime() =\n        DO(d, As<TS>(Date().GetTimezoneOffset()))\n        \n    [<Inline>]\n    member this.ToUniversalTime() =\n        DO(d, TS.Zero)\n\n    [<Inline>]\n    member this.UtcDateTime = d\n\n    [<Inline>]\n    member this.TimeOfDay = d.TimeOfDay\n\n    [<Inline>]\n    member this.Year = d.Year\n\n    [<Inline>]\n    member this.Month = d.Month\n\n    [<Inline>]\n    member this.Day = d.Day\n\n    [<Inline>]\n    member this.Hour = d.Hour\n                                                  \n    [<Inline>]\n    member this.Minute = d.Minute\n    \n    [<Inline>]\n    member this.Second = d.Second\n\n    [<Inline>]\n    member this.Millisecond = d.Millisecond\n    \n    [<Inline>]\n    member this.DayOfWeek = d.DayOfWeek\n\n    [<Inline>]\n    member this.Ticks = d.Ticks\n\n    [<Inline>]\n    member this.Add(t: TS) = DateTimeOffsetProxy(d.Add(t), o)\n                            \n    [<Inline>]\n    member this.Subtract(t: TS) = DateTimeOffsetProxy(d.Subtract(t), o)\n\n    [<Inline>]\n    member this.Subtract(o: DO) = d.Subtract(o?d: D)\n\n    [<Inline>]\n    member this.AddYears(years: int) = DateTimeOffsetProxy(d.AddYears(years), o)\n\n    [<Inline>]\n    member this.AddMonths(months: int) = DateTimeOffsetProxy(d.AddMonths(months), o)\n\n    [<Inline>]\n    member this.AddDays(days: float) = DateTimeOffsetProxy(d.AddDays(days), o)\n\n    [<Inline>]\n    member this.AddHours(hours: float) = DateTimeOffsetProxy(d.AddHours(hours), o)\n\n    [<Inline>]\n    member this.AddMinutes(minutes: float) = DateTimeOffsetProxy(d.AddMinutes(minutes), o)\n\n    [<Inline>]\n    member this.AddSeconds(seconds: float) = DateTimeOffsetProxy(d.AddSeconds(seconds), o)\n\n    [<Inline>]\n    member this.AddMilliseconds(msec: float) = DateTimeOffsetProxy(d.AddMilliseconds(msec), o)\n\n    [<Inline>]\n    member this.AddTicks(ticks: int64) = DateTimeOffsetProxy(d.AddTicks(ticks), o)\n\n    [<Inline>]\n    static member (+) (a: DO, b: TS) = a.Add(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: TS) = a.Subtract(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: DO) = a.Subtract(b)\n\n    [<Inline \"$a.d == $b.d\">]\n    static member op_Equality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d != $b.d\">]\n    static member op_Inequality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d > $b.d\">]\n    static member op_GreaterThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d < $b.d\">]\n    static member op_LessThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d >= $b.d\">]\n    static member op_GreaterThanOrEqual (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d <= $b.d\">]\n    static member op_LessThanOrEqual (a: DO, b: DO) = X<bool>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Delegate\">]\n[<Proxy(typeof<Delegate>)>]\ntype internal DelegateProxy =\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline \"$this.apply(null, $args)\">]\n    member this.DynamicInvoke(args: obj[]) = X<obj>\n\n    [<Direct \"$0.$Invokes || [$0]\">]\n    static member InvocationList(del: Delegate) = X<Delegate[]> \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n    \n    static member DelegateTarget(del) =\n        if (JS.Not del) then null\n        elif (JS.In \"$Target\" del) then del?``$Target``\n        elif (JS.In \"$Invokes\" del) then \n            let inv = del?``$Invokes`` : (_ * _)[]\n            snd inv.[inv.Length - 1]\n        else null\n\n    [<Inline>]\n    member this.Target =\n        DelegateProxy.DelegateTarget this\n\n    [<Inline \"$wsruntime.CreateDelegate($0)\">]\n    static member JSCreateDelegate(invokes: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates([$0, $1])\">]\n    static member Combine(a: Delegate, b: Delegate) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates($0)\">]\n    static member Combine(delegates: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member DelegateEqual(d1: Delegate, d2: Delegate) = X<bool>\n                           \n    static member Remove(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        let resInv = [||]\n        let mutable found = false\n        for i = sourceInv.Length - 1 downto 0 do\n            let it = sourceInv.[i]\n            if not found && DelegateProxy.DelegateEqual(it, value) then\n                found <- true\n            else\n                resInv.JS.Unshift(it) |> ignore\n        DelegateProxy.JSCreateDelegate(resInv)         \n\n    static member RemoveAll(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        DelegateProxy.JSCreateDelegate(sourceInv |> Array.filter (fun i -> not (i.Equals(value))))         \n\n[<Proxy(typeof<MulticastDelegate>)>]\ntype internal MulticastDelegateProxy =\n    \n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Collections\nopen System.Collections.Generic\n\ntype private KVP<'K,'V> = KeyValuePair<'K,'V>\ntype private D<'K,'V> = Dictionary<'K,'V>\n\n[<JavaScript>]\nmodule internal DictionaryUtil =\n\n    let notPresent () =\n        failwith \"The given key was not present in the dictionary.\"\n\n    let alreadyAdded () =\n        failwith \"An item with the same key has already been added.\"\n\n    let equals (c: IEqualityComparer<'T>) =\n        FuncWithArgs(fun (x, y) -> c.Equals(x, y))\n\n    [<Inline>]\n    let genEquals<'T when 'T : equality> () = \n        FuncWithArgs(fun (x :'T, y) -> x = y)\n\n    let getHashCode (c: IEqualityComparer<'T>) x =\n        c.GetHashCode x\n\nopen DictionaryUtil\nopen System.Runtime.InteropServices\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.KeyCollection.Enumerator>)>]\n[<Stub>]\ntype private KeyCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'K> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.ValueCollection.Enumerator>)>]\n[<Stub>]\ntype private ValueCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'V> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Name \"WebSharper.Collections.KeyCollection\">]\n[<Proxy(typeof<D<_,_>.KeyCollection>)>]\ntype private KeyCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.KeyCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Key)).GetEnumerator())\n            \n    interface IEnumerable<'K> with\n        member this.GetEnumerator() = As<IEnumerator<'K>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Name \"WebSharper.Collections.ValueCollection\">]\n[<Proxy(typeof<D<_,_>.ValueCollection>)>]\ntype private ValueCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.ValueCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Value)).GetEnumerator())\n            \n    interface IEnumerable<'V> with\n        member this.GetEnumerator() = As<IEnumerator<'V>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Proxy(typeof<D<_,_>.Enumerator>)>]\n[<Stub>]\ntype private DictionaryEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<KVP<'K,'V>> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n/// Implements a proxy for the .NET dictionary.\n[<Name \"WebSharper.Collections.Dictionary\">]\n[<Proxy(typeof<D<_,_>>)>]\ntype internal Dictionary<'K,'V when 'K : equality>\n\n    private (init   : seq<KVP<'K,'V>>,\n             equals : FuncWithArgs<'K * 'K, bool>,\n             hash   : 'K -> int) =\n\n        let mutable count = 0\n        let mutable data  = As<Array<Array<KVP<'K, 'V>>>> [||]\n\n        let get k =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                notPresent()\n            else\n                d.Self |> Array.pick (fun (KeyValue(dk, v)) -> \n                    if equals.Call(dk, k) then Some v else None\n                ) \n\n        let set k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==.null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                match d.Self |> Array.tryFindIndex (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) with\n                | Some i ->\n                    d.[i] <- KVP(k, v) \n                | None ->\n                    count <- count + 1\n                    d.Push(KVP(k, v)) |> ignore\n                    \n        let add k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                if d.Self |> Array.exists (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) then\n                    alreadyAdded()                    \n                count <- count + 1\n                d.Push(KVP(k, v)) |> ignore\n                    \n        let remove k =\n            let h = hash k \n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let r = d.Self |> Array.filter (fun (KeyValue(dk, _)) -> not (equals.Call(dk, k)))\n                if r.Length < d.Length then                  \n                    count <- count - 1\n                    data.[h] <- r.JS\n                    true\n                else\n                    false\n\n        do for x in init do\n            set x.Key x.Value\n\n        new () = new Dictionary<'K,'V>([||], genEquals<'K>(), hash)\n\n        new (capacity: int) = new Dictionary<'K,'V>()\n\n        new (comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>([||], equals comparer, getHashCode comparer)\n\n        new (capacity: int, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(comparer)\n\n        new (dictionary: IDictionary<'K,'V>) =\n            new Dictionary<'K,'V>(dictionary, genEquals<'K>(), hash)\n\n        new (dictionary: IDictionary<'K,'V>, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(\n                dictionary,\n                equals comparer,\n                getHashCode comparer\n            )\n\n        member this.Add(k: 'K, v: 'V) =\n            add k v\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member this.ContainsKey(k: 'K) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                d.Self |> Array.exists (fun (KeyValue(dk, _)) -> \n                    equals.Call(dk, k)\n                ) \n\n        member this.Count with [<Inline>] get () = count\n\n        member this.Item\n            with get (k: 'K) : 'V = get k\n            and set (k: 'K) (v: 'V) = set k v\n\n        member this.GetEnumerator() = As<D<'K,'V>.Enumerator> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        interface System.Collections.IEnumerable with\n            member this.GetEnumerator() = \n                let s = JS.GetFieldValues data\n                (As<KeyValuePair<'K,'V>[][]> s |> Array.concat).GetEnumerator()\n            \n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = As<IEnumerator<KeyValuePair<'K,'V>>> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        member this.Remove(k: 'K) =\n            remove k\n\n        member this.TryGetValue(k: 'K, [<Out>] res : byref<'V>) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let v =\n                    d.Self |> Array.tryPick (fun (KeyValue(dk, v)) -> \n                        if equals.Call(dk, k) then Some v else None\n                    ) \n                match v with \n                | Some v -> \n                    res <- v\n                    true\n                | _ -> false\n\n        member this.Values =\n            As<D<'K,'V>.ValueCollection>(ValueCollectionProxy(As<D<'K,'V>>this))\n\n        member this.Keys =\n            As<D<'K,'V>.KeyCollection>(KeyCollectionProxy(As<D<'K,'V>>this))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Exception =\n    let withInner (msg, inner) =\n        let e = Error(msg)\n        e?inner <- inner\n        e\n\n[<Name [| \"Error\" |]>]\n[<Proxy(typeof<System.Exception>)>]\ntype private ExceptionProxy =\n    [<Inline \"new Error()\">]\n    new () = { }\n\n    [<Inline \"new Error($message)\">]\n    new (message: string) = { }\n\n    [<Inline>]\n    static member CtorProxy (message: string, inner: exn) = Exception.withInner (message, inner)\n\n    member this.Message with [<Inline \"$this.message\">] get () = X<string>\n    member this.InnerException with [<Inline \"$this.inner\">] get () = X<System.Exception>\n    member this.StackTrace with [<Inline \"$this.stack\">] get () = X<string>\n\n[<Proxy(typeof<MatchFailureException>)>]\n[<Name \"MatchFailureException\">]\ntype private MatchFailureExceptionProxy (message: string, line: int, column: int) =\n    inherit exn(message + \" at \" + string line + \":\" + string column)\n\n[<Proxy(typeof<System.IndexOutOfRangeException>)>]\n[<Name \"IndexOutOfRangeException\">]\ntype private IndexOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n\n    new () = IndexOutOfRangeExceptionProxy \"Index was outside the bounds of the array.\"\n\n[<Proxy(typeof<System.OperationCanceledException>)>]\n[<Name \"OperationCanceledException\">]\ntype private OperationCanceledExceptionProxy(message: string, inner: exn, ct: CT) =\n    inherit exn(message, inner)\n\n    new (ct) = OperationCanceledExceptionProxy (\"The operation was canceled.\", null, ct)\n    \n    [<Inline>]\n    new () = OperationCanceledExceptionProxy (CT.None)\n    [<Inline>]\n    new (message) = OperationCanceledExceptionProxy (message, null, CT.None)\n    [<Inline>]\n    new (message, ct) = OperationCanceledExceptionProxy (message, null, ct)\n    [<Inline>]\n    new (message, inner) = OperationCanceledExceptionProxy (message, inner, CT.None)\n\n    [<Inline>]\n    member this.CancellationToken = ct\n\n[<Proxy(typeof<System.ArgumentException>)>]\n[<Name \"ArgumentException\">]\ntype private ArgumentExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentExceptionProxy \"Value does not fall within the expected range.\"\n\n    new (argumentName: string, message: string) =\n        ArgumentExceptionProxy (message + \"\\nParameter name: \" + argumentName)\n\n[<Proxy(typeof<System.ArgumentOutOfRangeException>)>]\n[<Name \"ArgumentOutOfRangeException\">]\ntype private ArgumentOutOfRangeExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Specified argument was out of the range of valid values.\") }\n\n    new (argumentName: string) =\n        new ArgumentOutOfRangeExceptionProxy(argumentName, \"Specified argument was out of the range of valid values.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.ArgumentNullException>)>]\n[<Name \"ArgumentNullException\">]\ntype private ArgumentNullExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Value cannot be null.\") }\n\n    new (argumentName: string) =\n        new ArgumentNullExceptionProxy(argumentName, \"Value cannot be null.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.InvalidOperationException>)>]\n[<Name \"InvalidOperationException\">]\ntype private InvalidOperationExceptionProxy(message: string, innerExn: exn) =\n    inherit exn(message, innerExn)\n    \n    new () = InvalidOperationExceptionProxy \"Operation is not valid due to the current state of the object.\"\n\n    new (message) =\n        new InvalidOperationExceptionProxy(message, null)\n\n[<Proxy(typeof<System.AggregateException>)>]\n[<Name \"AggregateException\">]\ntype private AggregateExceptionProxy(message: string, innerExceptions: exn[]) =\n    inherit exn(message)\n\n    new (innerExceptions: exn[]) = AggregateExceptionProxy(\"One or more errors occurred.\", innerExceptions)\n\n    new (innerExceptions: seq<exn>) = AggregateExceptionProxy(\"One or more errors occurred.\", Array.ofSeq innerExceptions)\n\n    new (message, innerExceptions: seq<exn>) = AggregateExceptionProxy(message, Array.ofSeq innerExceptions)\n\n    new (message, innerException: exn) = AggregateExceptionProxy(message, [| innerException |])\n\n    [<Inline>]\n    member this.InnerExceptions \n        with get() = As<System.Collections.ObjectModel.ReadOnlyCollection<exn>> innerExceptions\n\n[<Proxy(typeof<System.TimeoutException>)>]\n[<Name \"TimeoutException\">]\ntype private TimeoutExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = TimeoutExceptionProxy \"The operation has timed out.\"\n\n[<Proxy(typeof<System.FormatException>)>]\n[<Name \"FormatException\">]\ntype private FormatException(message: string) =\n    inherit exn(message)\n\n    new () = FormatException \"One of the identified items was in an invalid format.\"\n\n[<Proxy(typeof<System.OverflowException>)>]\n[<Name \"OverflowException\">]\ntype private OverflowException(message: string) =\n    inherit exn(message)\n\n    new () = OverflowException \"Arithmetic operation resulted in an overflow.\"\n\n[<Proxy(typeof<System.Threading.Tasks.TaskCanceledException>)>]\n[<Name \"TaskCanceledException\">]\ntype private TaskCanceledException(message: string) =\n    inherit exn(message)\n\n    new () = TaskCanceledException \"A task was canceled.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ExtraTopLevelOperators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ExtraTopLevelOperatorsProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"null\">]\nlet DefaultAsyncBuilder : Control.AsyncBuilder =\n    As (AsyncBuilderProxy())\n\n[<Name \"WebSharper.Arrays.create2D\" >]\nlet CreateArray2D (rows : seq<#seq<'T>>) =\n    let arr = rows |> Seq.map (Array.ofSeq) |> Array.ofSeq |> As<'T[,]>\n    arr?dims <- 2\n    arr\n\n[<Inline \"+$0\">]\nlet ToDouble<'T> (x: 'T) : double = X\n\n[<Inline \"$f(function(x){return x;})\">]\nlet PrintFormatToString (f: Printf.StringFormat<'T>) = X<'T>\n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThen k f = Printf.ksprintf k f \n\n[<Inline; JavaScript>]\nlet PrintFormatLine f = Printf.printfn f \n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThenFail f = Printf.failwithf f \n\n[<Inline; JavaScript>]\nlet SpliceExpression (e: Microsoft.FSharp.Quotations.Expr<'T>) =\n    As<'T> e\n\n[<Inline; JavaScript>]\nlet SpliceUntypedExpression<'T> (e: Microsoft.FSharp.Quotations.Expr) =\n    As<'T> e\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen Concurrency\nopen System.Runtime.InteropServices\n\n[<Proxy(typeof<System.Guid>)>]\n[<Prototype(false)>]\ntype internal GuidProxy =\n    \n    [<Inline \"$g\">]\n    new (g: string) = {}\n    \n    [<Direct \"return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&3|8);\n        return v.toString(16); });\">]\n    static member NewGuid() = X<System.Guid>\n\n    [<Constant \"00000000-0000-0000-0000-000000000000\">]\n    static member Empty = X<System.Guid>\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline>]\n    member this.CompareTo(s: System.Guid) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    static member FormatError() =\n        raise (FormatException \"\"\"Format String can be only \"D\", \"d\", \"N\", \"n\", \"P\", \"p\", \"B\", \"b\", \"X\" or \"x\".\"\"\")\n\n    static member HexaError() =\n        raise (FormatException \"Hexadecimal Guid printing not implemented by WebSharper.\")\n\n    static member ShapeError() =\n        raise (FormatException \"Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\")\n\n    static member ParseError() =\n        raise (FormatException \"Unrecognized Guid format.\")\n\n    member this.ToString(format: string) =\n        match format.ToUpper() with\n        | \"N\" -> (As<string> this).Replace(\"-\", \"\")\n        | \"D\" -> As<string> this\n        | \"B\" -> \"{\" + As<string> this + \"}\"\n        | \"P\" -> \"(\" + As<string> this + \")\"\n        | \"X\" ->\n            let s = As<string> this\n            \"{0x\" + s.Substring(0, 8) + \",0x\" + s.Substring(9, 4) + \",0x\" + s.Substring(14, 4) + \",{0x\"\n            + s.Substring(19, 2) + \",0x\" + s.Substring(21, 2) + \",0x\" + s.Substring(24, 2) + \",0x\"\n            + s.Substring(26, 2) + \",0x\" + s.Substring(28, 2) + \",0x\" + s.Substring(30, 2) + \",0x\" \n            + s.Substring(32, 2) + \",0x\" + s.Substring(34, 2) + \"}}\"\n        | _ -> GuidProxy.FormatError()\n    \n    static member Parse(input: string) =\n        try GuidProxy.ParseExact(input, \"D\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"B\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"P\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"N\") \n        with _ ->\n            GuidProxy.ParseExact(input, \"X\") \n\n    static member ParseExact(input: string, format: string) =\n        let parseD (s: string) =\n            for i = 0 to 35 do\n                match i with \n                | 8 | 13 | 18 | 23 -> if s.[i] <> '-' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            As<System.Guid> s    \n\n        match format.ToUpper() with\n        | \"N\" -> \n            let s = input.Trim().ToLower()\n            if s.Length <> 32 then GuidProxy.ShapeError()\n            for i = 0 to 31 do\n                let c = s.[i]\n                if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            s.Substring(0, 8) + \"-\" + s.Substring(8, 4) + \"-\" + s.Substring(12, 4) + \"-\" \n            + s.Substring(16, 4) + \"-\" + s.Substring(20)\n            |> As<System.Guid>\n        | \"D\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 36 then GuidProxy.ShapeError()\n            parseD s\n        | \"B\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '{' || s.[17] <> '}' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"P\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '(' || s.[17] <> ')' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"X\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 68 then GuidProxy.ShapeError()\n            for i = 0 to 67 do\n                match i with \n                | 0 | 26 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | 1 | 12 | 19 | 27 | 32 | 37 | 42 | 47 | 52 | 57 | 62 -> if s.[i] <> '0' then GuidProxy.ShapeError()\n                | 2 | 13 | 20 | 28 | 33 | 38 | 43 | 48 | 53 | 58 | 63 -> if s.[i] <> 'x' then GuidProxy.ShapeError()\n                | 11 | 18 | 25 | 31 | 36 | 41 | 46 | 51 | 56 | 61 -> if s.[i] <> ',' then GuidProxy.ShapeError()\n                | 66 | 67 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError() \n            s.Substring(3, 8) + \"-\" + s.Substring(14, 4) + \"-\" + s.Substring(21, 4) + \"-\" + s.Substring(29, 2) \n            + s.Substring(34, 2) + \"-\" + s.Substring(39, 2) + s.Substring(44, 2) + s.Substring(49, 2) \n            + s.Substring(54, 2) + s.Substring(59, 2) + s.Substring(64, 2)\n            |> As<System.Guid>\n        | _ -> GuidProxy.FormatError()\n\n    static member TryParse(input: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.Parse(input)\n            true\n        with _ -> false\n\n    static member TryParseExact(input: string, format: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.ParseExact(input, format)\n            true\n        with _ -> false\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule private HashSetUtil =\n    [<Direct \"var r=[]; for(var k in $o) { r.push.apply(r, $o[k]) }; return r\">]\n    let concat (o: Array<Array<'T>>) = X<Array<'T>>\n    \nopen DictionaryUtil\n\n// not really used, an array enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<HashSet<_>.Enumerator>)>]\n[<Stub>]\ntype private HashSetEnumeratorProxy<'T> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'T> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Proxy(typeof<HashSet<_>>)>]\n[<Name \"HashSet\">]\ntype internal HashSetProxy<'T when 'T : equality>\n\n    private (init   : seq<'T>,\n             equals : FuncWithArgs<'T * 'T, bool>,\n             hash   : 'T -> int) =\n\n        let mutable data  = Array<Array<'T>>()\n        let mutable count = 0\n\n        let arrContains (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let arrRemove (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    arr.Splice(i, 1) |> ignore\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let add (item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then\n                data.[h] <- As [| item |]\n                count <- count + 1\n                true\n            else\n                if arrContains item arr then false else    \n                    arr.Push item |> ignore\n                    count <- count + 1\n                    true\n\n        do for x in init do add x |> ignore\n\n        new () = HashSetProxy<'T>(Seq.empty, genEquals<'T>(), hash)\n\n        new (init: seq<'T>) = new HashSetProxy<'T>(init, genEquals<'T>(), hash)\n\n        new (comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(Seq.empty, equals comparer, getHashCode comparer)\n\n        new (init: seq<'T>, comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(init, equals comparer, getHashCode comparer)\n\n        member this.Add(item: 'T) = add item\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member x.Contains(item: 'T) =\n            let arr = data.[hash item]\n            if arr ==. null then false else arrContains item arr\n\n        member x.CopyTo(arr: 'T[]) =\n            let mutable i = 0\n            let all = concat data \n            for i = 0 to all.Length - 1 do \n                arr.[i] <- all.[i]\n\n        member x.Count = count\n\n        member x.ExceptWith(xs: seq<'T>) =\n            for item in xs do\n                x.Remove(item) |> ignore\n\n        [<Inline>]\n        member this.GetEnumerator() =\n           As<HashSet<'T>.Enumerator>((As<seq<'T>>(concat data)).GetEnumerator())\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n        \n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        // TODO: optimize methods by checking if other collection\n        // is a HashSet with the same IEqualityComparer\n        \n        member x.IntersectWith(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash) \n            let all = concat data\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if other.Contains(item) |> not then\n                    x.Remove(item) |> ignore\n\n        member x.IsProperSubsetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count < other.Length && x.IsSubsetOf(other)\n\n        member x.IsProperSupersetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count > other.Length && x.IsSupersetOf(other)\n\n        member x.IsSubsetOf(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            As<_[]>(concat data) |> Array.forall other.Contains\n\n        member x.IsSupersetOf(xs: seq<'T>) =\n            xs |> Seq.forall x.Contains\n\n        member x.Overlaps(xs: seq<'T>) =\n            xs |> Seq.exists x.Contains\n\n        member x.Remove(item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then false else\n                if arrRemove item arr then\n                    count <- count - 1\n                    true\n                else false\n\n        member x.RemoveWhere(cond: System.Predicate<'T>) =\n            let all = concat data\n            let mutable res = 0\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if cond.Invoke item then\n                    if x.Remove(item) then\n                        res <- res + 1\n            res\n\n        member x.SetEquals(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            x.Count = other.Count && x.IsSupersetOf(other)\n\n        member x.SymmetricExceptWith(xs: seq<'T>) =\n            for item in xs do\n                if x.Contains item then\n                    x.Remove(item) |> ignore\n                else\n                    x.Add(item) |> ignore\n\n        member x.UnionWith(xs: seq<'T>) =\n            for item in xs do\n                x.Add(item) |> ignore\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Proxy(typeof<System.IComparable>)>]\ntype private IComparableProxy =\n    [<Name \"CompareTo0\">]\n    abstract CompareTo : obj -> int\n\n[<Proxy(typeof<System.IComparable<_>>)>]\ntype private IComparableProxy<'T> =\n    [<Name \"CompareTo\">]\n    abstract CompareTo : 'T -> int\n\n[<Proxy(typeof<System.Collections.IEqualityComparer>)>]\ntype private IEqualityComparerProxy =\n    [<Name \"CEquals0\">]\n    abstract Equals : obj * obj -> bool \n    [<Name \"CGetHashCode0\">]\n    abstract GetHashCode : obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IEqualityComparer<_>>)>]\ntype private IEqualityComparerProxy<'T> =\n    [<Name \"CEquals\">]\n    abstract Equals : 'T * 'T -> bool \n    [<Name \"CGetHashCode\">]\n    abstract GetHashCode : 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.EqualityComparer<_>>)>]\n[<Name \"WebSharper.Collections.EqualityComparer\">]\n[<AbstractClass>]\ntype private EqualityComparerProxy<'T>() =\n    abstract Equals : 'T * 'T -> bool \n    abstract GetHashCode : 'T -> int\n    interface System.Collections.Generic.IEqualityComparer<'T> with\n        member this.Equals(x, y) = this.Equals(x, y)\n        member this.GetHashCode(x) = this.GetHashCode(x)\n    interface System.Collections.IEqualityComparer with\n        member this.Equals(x, y) = this.Equals(As x, As y)\n        member this.GetHashCode(x) = this.GetHashCode(As x)\n    [<Macro(typeof<M.EqualityComparer>)>]\n    static member Default = X<System.Collections.Generic.EqualityComparer<'T>>\n\n[<Proxy(typeof<System.Collections.IComparer>)>]\ntype private IComparerProxy =\n    [<Name \"Compare0\">]\n    abstract Compare : obj * obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IComparer<_>>)>]\ntype private IComparerProxy<'T> =\n    [<Name \"Compare\">]\n    abstract Compare : 'T * 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.Comparer<_>>)>]\n[<Name \"WebSharper.Collections.Comparer\">]\n[<AbstractClass>]\ntype private ComparerProxy<'T>() =\n    abstract Compare : 'T * 'T -> int\n    interface System.Collections.Generic.IComparer<'T> with\n        member this.Compare(x, y) = this.Compare(x, y)\n    interface System.Collections.IComparer with\n        member this.Compare(x, y) = this.Compare(As x, As y)\n    [<Macro(typeof<M.Comparer>)>]\n    static member Default = X<System.Collections.Generic.Comparer<'T>>\n\n[<Proxy(typeof<System.IEquatable<_>>)>]\ntype private IEquatableProxy<'T> =\n    [<Name \"EEquals\">]\n    abstract Equals : 'T -> bool\n\n[<Proxy(typeof<System.Collections.IStructuralEquatable>)>]\ntype private IStructuralEquatableProxy =\n    [<Name \"SEquals\">]\n    abstract Equals : obj * System.Collections.IEqualityComparer -> bool \n    [<Name \"SGetHashCode\">]\n    abstract GetHashCode : System.Collections.IEqualityComparer -> int\n\n[<Proxy(typeof<System.Collections.IStructuralComparable>)>]\ntype private IStructuralComparableProxy =\n    [<Name \"SCompareTo\">]\n    abstract CompareTo : obj * System.Collections.IComparer -> int \n\n[<Proxy(typeof<System.IDisposable>)>]\ntype private IDisposableProxy =\n    [<Name \"Dispose\">]\n    abstract member Dispose : unit -> unit\n\n[<Proxy(typeof<System.Collections.IEnumerable>)>]  \ntype private IEnumerableProxy =\n\n    [<Name \"GetEnumerator0\">]\n    abstract GetEnumerator : unit -> System.Collections.IEnumerator\n\n[<Proxy(typeof<seq<_>>)>]  \ntype private IEnumerableProxy<'T> =\n    inherit System.Collections.IEnumerable \n    \n    [<Name \"GetEnumerator\">]\n    abstract GetEnumerator : unit -> System.Collections.Generic.IEnumerator<'T>\n    \n[<Proxy(typeof<System.Collections.IEnumerator>)>]\n[<Name \"WebSharper.IEnumerator\">]\ntype private IEnumeratorProxy =\n    [<Name \"Current0\">]\n    abstract member Current  : obj\n    [<Name \"MoveNext\">]\n    abstract member MoveNext : unit -> bool\n    [<Name \"Reset\">]\n    abstract member Reset    : unit -> unit\n\n[<Proxy(typeof<System.Collections.Generic.IEnumerator<_>>)>]\n[<Name \"WebSharper.IEnumerator1\">]\ntype private IEnumeratorProxy<'T> =\n    [<Name \"Current\">]\n    abstract member Current : 'T\n\n[<Proxy(typeof<System.IObservable<_>>)>]\ntype private IObservableProxy<'T> =\n    [<Name \"Subscribe\">]\n    abstract member Subscribe : System.IObserver<'T> -> System.IDisposable\n\n[<Proxy(typeof<System.IObserver<_>>)>]\ntype private IObserverProxy<'T> =\n    [<Name \"OnCompleted\">]\n    abstract member OnCompleted : unit -> unit\n    [<Name \"OnError\">]\n    abstract member OnError : exn -> unit\n    [<Name \"OnNext\">]\n    abstract member OnNext : 'T -> unit\n\n[<Proxy(typeof<IDelegateEvent<_>>)>]\ntype private IDelegateEventProxy<'D> =\n    [<Name \"AddHandler\">]\n    abstract AddHandler : 'D -> unit\n    [<Name \"RemoveHandler\">]\n    abstract RemoveHandler : 'D -> unit\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Lazy\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.LazyExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.LazyExtensionsProxy\n\nopen WebSharper.JavaScript\n\n[<JavaScript; Prototype false>]\ntype LazyRecord<'T> =\n    {\n        [<Name \"c\">] mutable created : bool\n        [<Name \"v\">] mutable evalOrVal : obj\n        [<Name \"f\">] mutable force : unit -> 'T\n    }\n\nlet cachedLazy<'T> () =\n    JS.This.evalOrVal\n\nlet forceLazy<'T> () =\n    let v = (As JS.This.evalOrVal)()\n    JS.This.created <- true\n    JS.This.evalOrVal <- v\n    JS.This.force <- As cachedLazy\n    v\n\nlet Create (f: unit -> 'T) : Lazy<'T> =\n    As {\n        created = false\n        evalOrVal = f\n        force = As forceLazy\n    }\n\nlet CreateFromValue (v: 'T) : Lazy<'T> =\n    As {\n        created = true\n        evalOrVal = v\n        force = As cachedLazy\n    }\n\nlet Force (x: Lazy<'T>) : 'T =\n    As<LazyRecord<'T>>(x).force()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<list<_>>)>]\n[<Name \"WebSharper.List.T\">]\n[<DefaultAugmentation(false)>]\ntype private ListProxy<'T> =\n    | Empty\n    | Cons of Head: 'T * Tail: List<'T>\n\n    [<Inline; Pure>]\n    static member Cons(head: 'T, tail: list<'T>) = head :: tail\n\n    [<Inline; Pure>]\n    static member Empty : list<'T> = []\n\n    member this.Head with [<Inline>] get () = List.head (As this) : 'T\n    member this.Tail with [<Inline>] get () = List.tail (As this) : list<'T>\n    member this.IsEmpty with [<Inline \"$this.$ == 0\">] get () = X<bool>\n\n    member this.Length with get () = List.length (As this)\n\n    member this.Item with get (x: int) : 'T = List.item x (As this)\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() = (this :> _ seq).GetEnumerator() :> _\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let data = As<list<'T>> this\n            Enumerator.New data (fun e ->\n                match e.State with\n                | x :: xs ->\n                    e.Current <- x\n                    e.State <- xs\n                    true\n                | [] ->\n                    false)\n\n    member this.GetSlice(start, finish) : list<'T> =\n        match start, finish with\n        | None, None -> As this\n        | Some i, None -> As this |> CollectionInternals.ListSkip i\n        | None, Some j -> As this |> Seq.take (j + 1) |> List.ofSeq  \n        | Some i, Some j -> As this |> CollectionInternals.ListSkip i |> Seq.take (j - i + 1) |> List.ofSeq        \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"List\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ListModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ListModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nlet badLengths() =\n    failwith \"The lists have different lengths.\"\n\nlet listEmpty() =\n    failwith \"The input list was empty.\"\n\n[<Inline \"$l.$0\">]\nlet unsafeHead (l: list<'T>) = X<'T> \n\n[<Inline \"$l.$1\">]\nlet unsafeTail (l: list<'T>) = X<list<'T>> \n\n[<Inline>]\nlet setValue (l: list<'T>) (v: 'T) =\n    JS.Set l \"$0\" v\n\n[<Inline>]\nlet setTail (l: list<'T>) (t: list<'T>) =\n    JS.Set l \"$1\" t\n\n[<Inline \"new WebSharper.List.T({$: 1})\"; Pure>]\nlet freshEmptyList() = X<list<'T>>\n\n[<Inline>]\nlet freshTail (l: list<'T>) =\n    let t = freshEmptyList()\n    setTail l t\n    t\n\n[<Inline \"$l.$ == 1\">]\nlet notEmpty (l: list<_>) = X<bool>\n\n[<Name \"allPairs\">]\nlet AllPairs (l1: list<_>) (l2: list<_>) =\n    let arr1 = Array.ofList l1\n    let arr2 = Array.ofList l2\n    let res = Array.allPairs arr1 arr2\n    List.ofArray res\n\n[<Name \"append\">]\nlet Append (x: list<'T>) (y: list<'T>) = \n    if List.isEmpty x then y\n    elif List.isEmpty y then x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (unsafeHead l)\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r y |> ignore\n    res\n\n[<Inline>]\nlet inline Average (l: list<_>) = Seq.average l\n\n[<Inline>]\nlet inline AverageBy f (l: list<_>) = Seq.averageBy f l\n\n[<Name \"choose\">]\nlet Choose f (l: list<_>) = List.ofSeq (Seq.choose f l)\n\n[<Name \"collect\">]\nlet Collect (f: _ -> list<_>) (l: list<_>) = List.ofSeq (Seq.collect f l)\n\n[<Name \"concat\">]\nlet Concat (s: seq<list<_>>) = List.ofSeq (Seq.concat s)\n\n[<Inline>]\nlet Empty<'T> : list<'T> = []\n\n[<Name \"exists\">]\nlet Exists<'T> (p: 'T -> bool) (x: list<'T>) =\n    let mutable e = false\n    let mutable l = x\n    while not e && notEmpty l do\n        e <- p (unsafeHead l)\n        l <- unsafeTail l\n    e\n\n[<Name \"exists2\">]\nlet Exists2<'T1,'T2> (p : 'T1 -> 'T2 -> bool)\n                        (x1: list<'T1>)\n                        (x2: list<'T2>) =\n    let mutable e = false\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while not e && notEmpty l1 && notEmpty l2 do\n        e <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if not e && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    e\n\n[<Name \"filter\">]\nlet Filter<'T> (p: 'T -> bool) (l: list<'T>) =\n    List.ofSeq (Seq.filter p l)\n\n[<Inline>]\nlet Find p (l: list<_>) = Seq.find p l\n\n[<Inline>]\nlet FindIndex p (l: list<_>) = Seq.findIndex p l\n\n[<Inline>]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : 'S =\n    Seq.fold f s l\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (l1: list<'T1>)\n                        (l2: list<'T2>) : 'S =\n    Array.fold2 f s (Array.ofList l1) (Array.ofList l2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (l: list<_>) s =\n    Array.foldBack f (Array.ofList l) s\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (l1: list<_>) (l2: list<_>) s =\n    Array.foldBack2 f (Array.ofList l1) (Array.ofList l2) s\n\n[<Name \"forAll\">]\nlet ForAll p (x: list<_>) =\n    let mutable a = true\n    let mutable l = x\n    while a && notEmpty l do\n        a <- p (unsafeHead l)\n        l <- unsafeTail l\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 p (x1: list<_>) (x2: list<_>) =\n    let mutable a = true\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while a && notEmpty l1 && notEmpty l2 do\n        a <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if a && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    a\n\n[<Name \"head\">]\nlet Head (l: list<'T>) =\n    match l with \n    | h :: _ -> h\n    | _ -> listEmpty()\n\n[<Name \"init\">]\nlet Initialize s f = List.ofArray (Array.init s f)\n\n[<Inline \"$l.$ == 0\">]\nlet IsEmpty (l: list<_>) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (l: list<_>) =\n    let mutable r = l\n    while notEmpty r do\n        f r.Head\n        r <- r.Tail\n\n[<Name \"iter2\">]\nlet Iterate2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"iteri\">]\nlet IterateIndexed f (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        f i r.Head\n        r <- r.Tail\n        i <- i + 1\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    let mutable i = 0\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f i r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n        i <- i + 1\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"length\">]\nlet Length (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        r <- r.Tail\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T1 -> 'T2) (x: list<'T1>) = \n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (f (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r []\n    res\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (x1: list<'T1>) (x2: list<'T2>) (x3: list<'T3>) =\n    let mutable go = notEmpty x1 && notEmpty x2 && notEmpty x3\n    if not go then \n        if notEmpty x1 || notEmpty x2 || notEmpty x3 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable l3 = x3\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2) (unsafeHead l3))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        l3 <- unsafeTail l3\n        if notEmpty l1 && notEmpty l2 && notEmpty l3 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 || notEmpty l3 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T1 -> 'T2) (x: list<'T1>) =\n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable i = 0\n    let mutable go = true\n    while go do\n        setValue r (f i (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then \n            go <- false\n        else\n            r <- freshTail r\n            i <- i + 1\n    setTail r []\n    res\n\n[<Name \"mapi2\">]\nlet MapIndexed2 (f: int -> 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable i = 0\n    while go do\n        setValue r (f i (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n            i <- i + 1\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\nlet private nonEmpty (l: list<_>) =\n    if List.isEmpty l then\n        listEmpty()\n\n[<Name \"max\">]\nlet Max (list: list<_>) = \n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x > m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Name \"min\">]\nlet Min (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x < m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"minBy\">]\nlet MinBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Inline>]\nlet Get (l: list<_>) ix = Seq.item ix l\n\n[<Inline>]\nlet Item ix (l: list<_>) = Seq.item ix l\n\n[<Name \"ofArray\">]\nlet OfArray<'T> (arr: 'T []) =\n    let mutable r = []\n    for i = arr.Length - 1 downto 0 do\n        r <- arr.[i] :: r\n    r\n\n[<Name \"ofSeq\">]\nlet OfSeq (s: seq<'T>) =\n    if s :? _ list then\n        As<'T list> s\n    elif s :? System.Array then\n        List.ofArray (As<'T[]> s)\n    else\n        use e = Enumerator.Get s\n        let mutable go = e.MoveNext()\n        if not go then [] else\n        let res = freshEmptyList()\n        let mutable r = res\n        while go do\n            setValue r e.Current\n            if e.MoveNext() then\n                r <- freshTail r\n            else    \n                go <- false\n        setTail r []\n        res\n\n[<Name \"partition\">]\nlet Partition p (l: list<_>) =\n    let (a, b) = Array.partition p (Array.ofList l)\n    (List.ofArray a, List.ofArray b)\n\n[<Name \"permute\">]\nlet Permute f (l: list<_>) =\n    List.ofArray (Array.permute f (Array.ofList l))\n\n[<Inline>]\nlet Pick f (l: list<_>) = Seq.pick f l\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (list: list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        r <- f r (unsafeHead l)\n        l <- unsafeTail l\n    r\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (l: list<_>) =\n    Array.reduceBack f (Array.ofList l)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    List.ofArray (Array.create size value)\n\n[<Name \"rev\">]\nlet Reverse (l: list<'T>) =\n    let mutable res = []\n    let mutable r = l\n    while notEmpty r do\n        res <- unsafeHead r :: res\n        r <- unsafeTail r\n    res\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : list<'S> =\n    List.ofSeq (Seq.scan f s l)\n\n[<Name \"scanBack\">]\nlet ScanBack f (l: list<_>) s =\n    List.ofArray (Array.scanBack f (Array.ofList l) s)\n\n[<Name \"sort\">]\nlet Sort (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlace a\n    List.ofArray a\n\n[<Name \"sortBy\">]\nlet SortBy f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceBy f a\n    List.ofArray a\n\n[<Name \"sortByDescending\">]\nlet SortByDescending f (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending f a\n    List.ofArray a\n\n[<Name \"sortDescending\">]\nlet SortDescending (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending id a\n    List.ofArray a\n\n[<Name \"sortWith\">]\nlet SortWith f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceWith f a\n    List.ofArray a\n\n[<Inline>]\nlet inline Sum (l: list<'T>) : 'T = Seq.sum l\n\n[<Inline>]\nlet inline SumBy (f: 'T -> 'U) (l: list<'T>) : 'U = Seq.sumBy f l\n\n[<Name \"tail\">]\nlet Tail (l: list<'T>) = \n    match l with \n    | _ :: t -> t\n    | _ -> listEmpty()\n\n[<Inline>]\nlet ToArray (l: list<_>) = Array.ofList l\n\n[<Inline \"$x\">]\nlet ToSeq<'T> (x: list<'T>) : seq<'T> = x :> _\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<list<'T>>) : list<list<'T>> =\n    ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofList))\n    |> Seq.map List.ofArray |> List.ofSeq\n\n[<Inline>]\nlet TryFind p (l: list<_>) = Seq.tryFind p l\n\n[<Inline>]\nlet TryFindIndex p (l: list<_>) = Seq.tryFindIndex p l\n\n[<Inline>]\nlet TryPick p (l: list<_>) = Seq.tryPick p l\n\n[<Name \"unzip\">]\nlet Unzip (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    for (a, b) in l do\n        x.Enqueue a\n        y.Enqueue b\n    (List.ofArray (x.ToArray()), List.ofArray (y.ToArray()))\n\n[<Name \"unzip3\">]\nlet Unzip3 (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    let z = System.Collections.Generic.Queue<_>()\n    for (a, b, c) in l do\n        x.Enqueue a\n        y.Enqueue b\n        z.Enqueue c\n    (\n        List.ofArray (x.ToArray()),\n        List.ofArray (y.ToArray()),\n        List.ofArray (z.ToArray())\n    )\n\n[<Name \"zip\">]\nlet Zip (l1: list<_>) (l2: list<_>) =\n    List.map2 (fun x y -> x, y) l1 l2\n\n[<Name \"zip3\">]\nlet Zip3 (l1: list<_>) (l2: list<_>) (l3: list<_>) =\n    Map3 (fun x y z -> (x, y, z)) l1 l2 l3\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size list =\n    SeqChunkBySize size (List.toSeq list)\n    |> Seq.toList\n    |> List.map Array.toList\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (l1: list<'T>) (l2: list<'T>) : int =\n    Seq.compareWith f (List.toSeq l1) (List.toSeq l2)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (l: list<'T>) : list<'K * int> =\n    ArrayCountBy f (List.toArray l)\n    |> Array.toList\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: list<'T>) : list<'T> =\n    Seq.distinct (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (l: list<'T>) : list<'T> =\n    Seq.distinctBy f (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"splitInto\">]\nlet SplitInto count (list: list<'T>) =\n    ArraySplitInto count (List.toArray list)\n    |> Array.toList\n    |> List.map Array.toList\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (l: list<'T>) =\n    SeqExcept itemsToExclude l\n    |> Seq.toList\n\n[<Name \"tryFindBack\">]\nlet TryFindBack ok (l: list<_>) =\n    ArrayTryFindBack ok (Array.ofList l)\n\n[<Name \"findBack\">]\nlet FindBack p (s: list<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet TryFindIndexBack ok (l: list<_>) =\n    ArrayTryFindIndexBack ok (Array.ofList l) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: list<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (l: list<'T>) : list<'K * list<'T>> =\n    let arr = ArrayGroupBy f (List.toArray l)\n    arr |> mapInPlace (fun (k, s) -> (k, Array.toList s))\n    Array.toList (As arr)\n\n[<Name \"last\">]\nlet Last (list : list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = list\n    let mutable t = unsafeTail r\n    while notEmpty t do\n        r <- t\n        t <- unsafeTail r\n    unsafeHead r\n\n[<Name \"contains\">]\nlet Contains (el: 'T) (x: list<'T>) =\n    let mutable c = false\n    let mutable l = x\n    while not c && notEmpty l do\n        c <- el = unsafeHead l\n        l <- unsafeTail l\n    c\n\n[<Name \"mapFold\">]\nlet MapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) zero list =\n    ArrayMapFold f zero (List.toArray list)\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T, 'S, 'R> f list zero =\n    ArrayMapFoldBack<'T, 'S, 'R> f (List.toArray list) zero\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"pairwise\">]\nlet Pairwise (l: list<'T>) : list<'T * 'T> =\n    Seq.pairwise (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"indexed\">]\nlet Indexed (list : list<'T>) : list<int * 'T> =\n    List.mapi (fun a b -> (a, b)) list\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [x]\n\n[<Inline>]\nlet Skip<'T> i (l : list<'T>) = ListSkip i l\n\n[<Inline>]\nlet SkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    ListSkipWhile predicate list\n\n[<Inline>]\nlet Take<'T> n (list: list<'T>) =\n    Seq.take n list |> List.ofSeq\n\n[<Inline>]\nlet TakeWhile<'T> (predicate : 'T -> bool) (list: list<'T>) =\n    Seq.takeWhile predicate list |> List.ofSeq\n\n[<Inline>]\nlet Truncate<'T> n (list: list<'T>) =\n    Seq.truncate n list |> List.ofSeq\n\n[<Name \"tryHead\">]\nlet TryHead<'T> (list: list<'T>) =\n    match list with\n    | head :: _ ->\n        Some head\n    | [] ->\n        None\n\n[<Inline>]\nlet TryItem<'T> n (list: list<'T>) =\n    SeqTryItem n list \n\n[<Inline>]\nlet TryLast<'T> (list: list<'T>) =\n    SeqTryLast list\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (list : 'T list) =\n    match list with\n    | head :: [] ->\n        head\n    | _ ->\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : list<'T> =\n    Seq.unfold f s\n    |> Seq.toList\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T list) : 'T list =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T list) : list<list<'T>> =\n    Seq.windowed windowSize (List.toSeq s)\n    |> Seq.map List.ofArray |> Seq.toList\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (list: 'T list) =\n    (Take n list, Skip n list)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Nullable =\n    let get (x: obj) =\n        if x ===. null then failwith \"Nullable object must have a value.\" else x\n\n////    let getOrDefault<'T> (x: 'T) =\n//        if x ==. null then Unchecked.defaultof<'T> else x     \n\n    let getOrValue<'T> (x: 'T) (v: 'T)  =\n        if x ===. null then v else x     \n\n[<Proxy(typeof<System.Nullable<_>>)>]\ntype private NullableProxy<'T> =\n    \n    [<Inline \"null\">]\n    new () = {}\n\n    [<Inline \"$v\">]\n    new (v: 'T) = {}\n\n    member this.Value \n        with [<JavaScript; Inline>] get(): 'T = As<'T>(Nullable.get this)\n\n    member this.HasValue\n        with [<JavaScript; Inline>] get() = this !=. null\n\n    [<Inline>]\n    member this.GetValueOrDefault() : 'T = Nullable.getOrValue (As<'T> this) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    member this.GetValueOrDefault(v: 'T) : 'T = Nullable.getOrValue (As<'T> this) v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Operators\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorsProxy\n\n#nowarn \"86\"\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"range\">]\n[<Macro(typeof<M.Range>)>]\nlet ( .. ) (min: 'T) (max: 'T) : seq<'T> =\n    let count = 1 + As max - As min\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> As (x + As min))\n\n[<Name \"step\">]\nlet ( .. .. ) (min: 'T1) (step: 'T2) (max: 'T1) : seq<'T1> =\n    let s = sign (As<int> step)\n    Seq.initInfinite (fun k -> As<int> min + k * As<int> step)\n    |> Seq.takeWhile (fun k -> s * (As<int> max - As<int> k) >= 0)\n    |> As\n\n[<Inline \"$r[0]\">]\nlet ( ! ) (r: ref<'T>) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( % ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"$a & $b\">]\nlet ( &&& ) (a: 'T1) (b: 'T1) = X<'T1>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( * ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"Math.pow($a, $b)\">]\nlet ( ** ) (a: 'T1) (b: 'T2) = X<'T1>\n\n[<Inline \"Math.pow($a, $p)\">]\nlet PowInteger (a: 'T, p: int) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( + ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( - ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( / ) (x: 'T1) (y: 'T2) = X<'T3>\n\n[<Inline \"void ($a[0] = $b)\">]\nlet ( := ) (a: ref<'T>) (b: 'T) = X<unit>\n\n[<Inline>]\nlet ( << ) (f: 'T1 -> 'T2) (g: 'T3 -> 'T1) : 'T3 -> 'T2 = \n    ()\n    fun x -> f (g x)\n\n[<Inline \"$a << $b\">]\nlet inline ( <<< ) (a: 'T) (b: int) = X<'T>\n\n[<Inline>]\nlet ( <| ) (f: 'T -> 'TR) (x: 'T) : 'TR = f x\n\n[<Inline>]\nlet ( <|| ) (f: 'T1 -> 'T2 -> 'TR) (x: 'T1, y: 'T2) : 'TR = f x y\n\n[<Inline>]\nlet ( <||| ) (f: 'T1 -> 'T2 -> 'T3 -> 'TR)\n             (x: 'T1, y: 'T2, z: 'T3) : 'TR = f x y z\n\n[<Macro(typeof<M.Comp>)>]\nlet ( = ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <> ) (a: 'T) (b: 'T) =  X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( < ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( > ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( >= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Inline>]\nlet ( >> ) (f: 'T1 -> 'T2) (g: 'T2 -> 'T3): 'T1->'T3 = \n    ()\n    fun x -> g (f x)\n\n[<Inline \"$a >> $b\">]\nlet inline ( >>> ) (a: 'T) (b: int) : 'T = a >>> b\n\n[<Inline>]\nlet ( @ ) a b = List.append a b\n\n[<Inline \"$a + $b\">]\nlet ( ^ ) (a: string) (b: string) : string = a + b\n\n[<Inline \"$a ^ $b\">]\nlet ( ^^^ ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |> ) (x: 'T1) (f: 'T1 -> 'T2) : 'T2 = f x\n\n[<Inline>]\nlet ( ||> ) (x: 'T1, y: 'T2) (f: 'T1 -> 'T2 -> 'TR) : 'TR = f x y\n\n[<Inline \"$a | $b\">]\nlet ( ||| ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |||> ) (x: 'T1, y: 'T2, z: 'T3)\n             (f: 'T1 -> 'T2 -> 'T3 -> 'TR) : 'TR = f x y z\n\n[<Inline \"+ $x\">]\nlet ( ~+ ) (x: 'T) = X<'T>\n\n[<Inline \"- $x\">]\nlet ( ~- ) (x: 'T) = X<'T>\n\n[<Inline \"~ $x\">]\nlet ( ~~~ ) (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Abs>)>]\n[<Inline \"Math.abs($x)\">]\nlet Abs (x: 'T) = X<'T>\n\n[<Inline \"Math.acos($x)\">]\nlet Acos (x: 'T) = X<'T>\n\n[<Inline \"Math.asin($x)\">]\nlet Asin (x: 'T) = X<'T>\n\n[<Inline \"Math.atan($x)\">]\nlet Atan (x: 'T) = X<'T>\n\n[<Inline \"Math.atan2($x, $y)\">]\nlet Atan2 (x: 'T1) (y: 'T1) = X<'T2>\n\n[<Inline \"$x\">]\nlet Box (x: 'T) = X<obj>\n\n[<Inline \"Math.ceil($x)\">]\nlet Ceiling (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Char>)>]\nlet ToChar (x: 'T) = X<char>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToByte (x: 'T) = X<byte>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSByte (x: 'T) = X<sbyte>\n\n[<Inline>]\nlet Compare<'T> (a: 'T) (b: 'T) = Unchecked.compare a b\n\n[<Inline \"Math.cos($x)\">]\nlet Cos (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)+Math.exp(-$x))/2\">]\nlet Cosh<'T> (x: 'T) = X<'T>\n\n[<Inline \"void ($x[0]--)\">]\nlet Decrement (x: ref<int>) = ()\n\n[<Inline>]\nlet DefaultArg x d =\n    match x with\n    | Some x -> x\n    | None   -> d\n\n[<Inline>]\nlet DefaultValueArg x d =\n    match x with\n    | ValueSome x -> x\n    | ValueNone   -> d\n\n[<Inline \"$x\">]\nlet Enum<'T when 'T : enum<int>> (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDecimal (x: 'T) = X<decimal>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDouble (x: 'T) = X<double>\n\n[<Inline \"Math.exp($x)\">]\nlet inline Exp (x: 'T) = X<'T>\n\nlet FailWith (msg: string) : 'T = raise (exn msg)\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToFloat (x: 'T) = X<float>\n\n[<Inline \"Math.floor($x)\">]\nlet Floor (x: 'T) = X<'T>\n\n[<Inline \"$x[0]\">]\nlet Fst (x: TupleProxy<'T1,'T2>) = X<'T1>\n\n[<Inline>]\nlet Hash<'T when 'T : equality> (x: 'T) = Unchecked.hash x\n\n[<Inline \"$x\">]\nlet Identity (x: 'T) = X<'T>\n\n[<Inline \"void $x\">]\nlet Ignore (x: 'T) = X<unit>\n\n[<Inline \"void ($x[0]++)\">]\nlet Increment (x: ref<int>) = ()\n\n[<Inline \"Infinity\">]\nlet Infinity = Unchecked.defaultof<double>\n\nlet InvalidOp (msg: string) : 'T = raise (System.InvalidOperationException(msg))\n\nlet InvalidArg (arg: string) (msg: string) : 'T = raise (System.ArgumentException(arg, msg))\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt (x: 'T) = X<int>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt16 (x: 'T) = X<int16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSingle (x: 'T) = X<single>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt32 (x: 'T) = X<int32>\n\nlet toUInt (x: float) : int =\n    (if x < 0. then Math.Ceil(x) else Math.Floor(x)) >>>. 0 |> As<int>\n\nlet toInt (x: float) : int =\n    let u = toUInt x\n    if u >= As<int> 2147483648L then u - As<int> 4294967296L else u\n\n[<Inline \"$x\">]\nlet ToEnum<'T> (x: int) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt64 (x: 'T) = X<int64>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt16 (x: 'T) = X<uint16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt32 (x: 'T) = X<uint32>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt64 (x: 'T) = X<uint64>\n\n[<Inline \"Math.log($x)\">]\nlet Log (x: 'T) = X<'T>\n\n[<Inline \"Math.log($x)/Math.log(10)\">]\nlet Log10 (x: 'T) = X<'T>\n\n[<Inline>]\nlet Max<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a > b then a else b\n\n[<Inline>]\nlet Min<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a < b then a else b\n\n[<Inline \"Infinity\">]\nlet InfinitySingle = single infinity\n\n[<Inline \"NaN\">]\nlet NaNSingle = single nan\n\n[<Inline \"NaN\">]\nlet NaN = nan\n\n[<Inline \"!$x\">]\nlet Not (x: bool) = X<bool>\n\nlet Pown<'T> (a: 'T) (n: int) =\n    let a = box a :?> double\n    let rec p n =\n        match n with\n        | 1 ->\n            a\n        | n when n % 2 = 0 ->\n            let b = p (n / 2)\n            b * b\n        | n ->\n            a * (p (n - 1))\n    p n\n\n[<Inline \"throw $e\">]\nlet Raise (e: exn) = X<'T>\n\n[<Inline \"[$x]\">]\nlet Ref (x: 'T) = X<ref<'T>>\n\n[<Inline \"Math.round($x)\">]\nlet Round (x: 'T) = X<'T>\n\n[<Inline \"$x\">]\nlet CreateSequence (x: seq<'T>) = X<seq<'T>>\n\n[<Macro(typeof<M.Sign>); JavaScript>]\nlet Sign<'T> (x: 'T) =\n    match As<int> x with\n    | 0            -> 0\n    | n when n < 0 -> -1\n    | _            -> 1\n\n[<Inline \"Math.sin($x)\">]\nlet Sin (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)-Math.exp(-$x))/2\">]\nlet Sinh (x: 'T) = x\n\n[<Inline \"$x[1]\">]\nlet Snd (x: TupleProxy<'T1,'T2>) = X<'T2>\n\n[<Inline \"Math.sqrt($x)\">]\nlet Sqrt (x: 'T1) = X<'T2>\n\n[<Macro(typeof<M.String>)>]\nlet ToString (x: 'T) = X<string>\n\n[<Inline \"Math.tan($x)\">]\nlet inline Tan (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp(2*$x)-1)/(Math.exp(2*$x)+1)\">]\nlet Tanh (x: 'T) = X<'T>\n\nlet inline Truncate<'T> (x: 'T) =\n    if x <. 0 then Ceiling x else Floor x\n\n[<Inline \"$x\">]\nlet Unbox (x: obj) = X<'T>\n\n[<Inline \"$x == null\">]\nlet IsNull (x: 'T) = X<bool>\n\n[<Inline>]\nlet Using t f =\n    try f t finally (t :> System.IDisposable).Dispose()\n\n[<Name \"KeyValue\">]\nlet KeyValuePattern (kvp: System.Collections.Generic.KeyValuePair<_,_>) =\n    (kvp.Key, kvp.Value)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Slice\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+OperatorIntrinsics, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorIntrinsicsProxy \n\nopen WebSharper.JavaScript\n\n[<Inline \"$s.slice($st,$e)\">]\nlet Slice (s: 'T) (st: int) (e: int) = X<'T>\n\n[<Inline \"$s.slice($st)\">]\nlet SliceStart (s: 'T) (st: int) = X<'T>\n\n[<Name \"string\">]\nlet GetStringSlice (source: string) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> \"\"\n\n[<Name \"array\">]\nlet GetArraySlice<'T> (source: 'T[]) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> [||]\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Name \"setArray\">]\nlet SetArraySlice (dst: _[]) start finish (src:_[]) = \n    let start  = (match start with None -> 0 | Some n -> n) \n    let finish = (match finish with None -> Array.length dst - 1 | Some n -> n) \n    F.SetArraySub dst start (finish - start + 1) src\n\n[<Name \"array2D\">]\nlet GetArraySlice2D (arr: _[,]) start1 finish1 start2 finish2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let len2 = (finish2 - start2 + 1)\n    F.GetArray2DSub arr start1 start2 len1 len2\n\n[<Name \"array2Dfix1\">]\nlet GetArraySlice2DFixed1 (arr: _[,]) fixed1 start2 finish2 = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    let dst = JavaScript.Array(len2)\n    for j = 0 to len2 - 1 do \n        F.SetArray dst.Self j (F.GetArray2D arr fixed1 (start2+j))\n    dst.Self\n\n[<Name \"array2Dfix2\">]\nlet GetArraySlice2DFixed2 (arr: _[,]) start1 finish1 fixed2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let dst = JavaScript.Array(len1)\n    for i = 0 to len1 - 1 do \n        F.SetArray dst.Self i (F.GetArray2D arr (start1+i) fixed2)\n    dst.Self\n\n[<Name \"setArray2Dfix1\">]\nlet SetArraySlice2DFixed1 (dst: _[,]) fixed1 start2 finish2 (src:_[]) = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    for j = 0 to len2 - 1 do\n        F.SetArray2D dst fixed1 (start2+j) (F.GetArray src j)\n\n[<Name \"setArray2Dfix2\">]\nlet SetArraySlice2DFixed2 (dst: _[,]) start1 finish1 fixed2 (src:_[]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    for i = 0 to len1 - 1 do\n        F.SetArray2D dst (start1+i) fixed2 (F.GetArray src i)\n\n[<Name \"setArray2D\">]\nlet SetArraySlice2D (dst: _[,]) start1 finish1 start2 finish2 (src:_[,]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    F.SetArray2DSub dst start1 start2 (finish1 - start1 + 1) (finish2 - start2 + 1) src\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Option\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.OptionModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OptionModuleProxy\n\nopen WebSharper.JavaScript\n\n[<Inline>]\nlet Bind f x =\n    match x with\n    | Some x -> f x\n    | None   -> None\n\n[<Inline>]\nlet Contains v o =\n    match o with\n    | Some x -> x = v\n    | None -> false\n\n[<Inline \"$x ? 1 : 0\">]\nlet Count (x: option<_>) = X<int>\n\n[<Inline>]\nlet DefaultValue v o =\n    match o with\n    | Some x -> x \n    | None -> v\n\n[<Inline>]\nlet DefaultWith f o =\n    match o with\n    | Some x -> x \n    | None -> f()\n\n[<Inline>]\nlet Exists p x =\n    match x with\n    | Some x -> p x\n    | None   -> false\n\n[<Name \"filter\">]\nlet Filter f o =\n    match o with\n    | Some x when f x -> o\n    | _ -> None\n\n[<Inline>]\nlet Flatten o =\n    match o with\n    | Some x -> x\n    | None -> None\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (x: option<'T>) : 'S =\n    match x with\n    | Some x -> f s x\n    | None   -> s\n\n[<Name \"foldBack\">]\nlet FoldBack f x s =\n    match x with\n    | Some x -> f x s\n    | None   -> s\n\n[<Inline>]\nlet ForAll p x =\n    match x with\n    | Some x -> p x\n    | None   -> true\n\n[<Inline \"$x.$0\"; Pure>]\nlet GetValue (x: option<'T>) = X<'T>\n\n[<Inline \"$x==null\">]\nlet IsNone (x: option<'T>) = false\n\n[<Inline \"$x!=null\">]\nlet IsSome (x: option<'T>) =  false\n\n[<Inline>]\nlet Iterate p x =\n    match x with\n    | Some x -> p x\n    | None   -> ()\n\n[<Inline>]\nlet Map f x =\n    match x with\n    | Some x -> Some (f x)\n    | None -> None\n\n[<Inline>]\nlet Map2 f x y =\n    match x, y with\n    | Some x, Some y -> Some (f x y)\n    | _ -> None\n\n[<Inline>]\nlet Map3 f x y z =\n    match x, y, z with\n    | Some x, Some y, Some z -> Some (f x y z)\n    | _ -> None\n\n[<Name \"ofNullable\">]\nlet OfNullable (o: System.Nullable<'T>) =\n    if o ==. null then None else Some o.Value                   \n\n[<Name \"ofObj\">]\nlet OfObj o = \n    if o ==. null then None else Some o\n\n[<Inline>]\nlet OrElse v o =\n    match o with\n    | Some x -> o \n    | None -> v\n\n[<Inline>]\nlet OrElseWith f o =\n    match o with\n    | Some x -> o \n    | None -> f()\n\n[<Name \"toArray\">]\nlet ToArray x =\n    match x with\n    | Some x -> [|x|]\n    | None   -> [||]\n\n[<Name \"toList\">]\nlet ToList x =\n    match x with\n    | Some x -> [x]\n    | None   -> []\n\n[<Name \"toNullable\">]\nlet ToNullable o =\n    match o with\n    | Some v -> System.Nullable(v)\n    | _ -> System.Nullable()\n\n[<Name \"toObj\">]\nlet ToObj o = \n    match o with\n    | Some v -> v\n    | None -> null\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Queue\">]\nmodule private WebSharper.QueueProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (a: obj) =\n    splice a 0 (a :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (a: obj) (el: 'T) =\n    Seq.exists ((=) el) (a :?> seq<'T>)\n\n[<JavaScript>]\nlet CopyTo (a: obj) (array: 'T[]) (index: int) =\n    Array.blit (a :?> 'T []) 0 array index (a :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Queue<_>>)>]\n[<WebSharper.Name \"WebSharper.Queue\">]\ntype private QueueProxy<'T when 'T : equality>\n\n    [<Inline \"$data\">] private (data: 'T []) =\n\n    [<Inline \"[]\">]\n    private new () = QueueProxy [||]\n\n    [<Inline>]\n    private new (s: seq<'T>) = QueueProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index: int) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Dequeue() = X<'T>\n\n    [<Inline \"$this.push($x)\">]\n    member this.Enqueue(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = data\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule RandomHelpers =\n    [<Inline \"Math.floor(Math.random() * 2147483648)\">]\n    let Next() = X<int>\n    \n    [<Inline \"Math.floor(Math.random() * $maxValue)\">]\n    let NextMax (maxValue: int) = X<int>\n\n[<Name \"Random\">]\n[<Proxy(typeof<System.Random>)>]\ntype internal RandomProxy() =\n    member this.Next() = Next()\n\n    member this.Next maxValue =\n        if maxValue < 0 then\n            failwith \"'maxValue' must be greater than zero.\"\n        else NextMax maxValue\n\n    member this.Next (minValue: int, maxValue: int) =\n        if minValue > maxValue then\n            failwith \"'minValue' cannot be greater than maxValue.\"\n        else minValue + NextMax (maxValue - minValue)\n\n    member this.NextBytes (buffer: byte[]) =\n        for i = 0 to buffer.Length - 1 do\n            buffer.[i] <- As (NextMax 256)\n\n    [<Inline \"Math.random()\">]\n    member this.NextDouble() = X<float>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Result\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ResultModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ResultModuleProxy\n    \nlet Bind f r =\n    match r with\n    | Ok x -> f x\n    | Error e -> Error e\n        \nlet Map f r =\n    match r with\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n        \nlet MapError f r =\n    match r with\n    | Ok x -> Ok x\n    | Error e -> Error (f e)    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.RuntimeHelpersProxy\n\n#nowarn \"40\"\n\nopen WebSharper.JavaScript\n\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"WebSharper.Seq.enumFinally\">]\nlet EnumerateThenFinally (s: seq<'T>) (f: unit -> unit) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get s with e -> f(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); f()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumUsing\">]\nlet EnumerateUsing<'T1,'T2,'T3 when 'T1 :> System.IDisposable\n                                and 'T2 :> seq<'T3>>\n        (x: 'T1) (f: 'T1 -> 'T2) : seq<'T3> =\n\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get (f x) with e -> x.Dispose(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); x.Dispose()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumWhile\">]\nlet EnumerateWhile (f: unit -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let rec next (en: Enumerator.T<IE<_>,'T>) =\n            match en.State with\n            | null ->\n                if f () then\n                    en.State <- Enumerator.Get s\n                    next en\n                else\n                    false\n            | e ->\n                if e.MoveNext() then\n                    en.Current <- e.Current\n                    true\n                else\n                    e.Dispose()\n                    en.State <- null\n                    next en\n        Enumerator.NewDisposing null (fun en -> safeDispose en.State) next)\n\n[<Name \"WebSharper.Control.createEvent\">]\nlet CreateEvent<'D, 'A when 'D : delegate<'A, unit> and 'D :> System.Delegate> \n        (add: 'D -> unit) \n        (remove: 'D -> unit)\n        (create: (obj -> 'A -> unit) -> 'D) : IEvent<'D, 'A> =\n    { new IEvent<'D, 'A> with\n        member this.AddHandler h = add h\n        member this.RemoveHandler h = remove h\n        member this.Subscribe (r: System.IObserver<'A>) =     \n            let h = create (fun _ args -> r.OnNext(args))\n            add h\n            { new System.IDisposable with member this.Dispose() = remove h }\n    }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Seq\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.SeqModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.SeqModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\nlet seqEmpty() =\n    failwith \"The input sequence was empty.\"\n\n[<Name \"allPairs\">]\nlet AllPairs (source1: seq<_>) (source2: seq<_>) =\n    let cached = Seq.cache source2\n    source1 |> Seq.collect (fun x -> cached |> Seq.map (fun y -> x,y))\n\n[<Name \"append\">]\nlet Append (s1: seq<'T>) (s2: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let e1 = Enumerator.Get s1\n        let first = ref true\n        Enumerator.NewDisposing e1 (fun x -> safeDispose x.State) (fun x ->\n            if x.State.MoveNext() then\n                x.Current <- x.State.Current\n                true\n            else \n                safeDispose x.State\n                x.State <- null\n                if !first then\n                    first := false\n                    x.State <- Enumerator.Get s2\n                    if x.State.MoveNext() then\n                        x.Current <- x.State.Current\n                        true\n                    else\n                        x.State.Dispose()\n                        x.State <- null\n                        false\n                else \n                    false)) \n\n[<Name \"average\">]\nlet Average<'T> (s: seq<'T>) : 'T =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> x))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'T> (sum / As<float> count)\n\n[<Name \"averageBy\">]\nlet AverageBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> (f x)))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'U> (sum / As<float> count)\n\n[<Name \"cache\">]\nlet Cache<'T> (s: seq<'T>) : seq<'T> =\n    let cache = JavaScript.Array<'T>()\n    let o  = ref (Enumerator.Get s)\n    Enumerable.Of <| fun () ->\n        let next (e: Enumerator.T<_,_>) =\n            if e.State < cache.Length then\n                e.Current <- cache.[e.State]\n                e.State   <- e.State + 1\n                true\n            else\n                let en = !o\n                if en = null then false\n                elif en.MoveNext() then\n                    e.State   <- e.State + 1\n                    e.Current <- en.Current\n                    cache.Push(e.Current) |> ignore\n                    true\n                else\n                    en.Dispose()\n                    o := null\n                    false\n        Enumerator.New 0 next\n\n/// IEnumerable is not supported.\n[<Inline \"$i\">]\nlet Cast<'T> (i: System.Collections.IEnumerable) = X<seq<'T>>\n\n[<Inline>]\nlet Contains (el: 'T) (s: seq<'T>) =\n    SeqContains el s\n\n[<Name \"choose\">]\nlet Choose (f: 'T -> option<'U>) (s: seq<'T>) : seq<'U> =\n    s\n    |> Seq.collect (fun x ->\n        match f x with\n        | Some v -> [v]\n        | None   -> [])\n\n[<Inline>]\nlet ChunkBySize (size: int) (s: seq<'T>) = SeqChunkBySize size s\n\n[<Name \"collect\">]\nlet Collect f s = Seq.concat (Seq.map f s)\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (s1: seq<'T>) (s2: seq<'T>) : int =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = 0\n    let mutable loop = true\n    while loop && r = 0 do\n        match e1.MoveNext(), e2.MoveNext() with\n        | true, false ->\n            r <- 1\n        | false, true ->\n            r <- -1\n        | false, false ->\n            loop <- false\n        | true, true ->\n            r <- f e1.Current e2.Current\n    r\n\n[<Name \"concat\">]\nlet Concat (ss: seq<#seq<'T>>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let outerE = Enumerator.Get ss\n        let rec next (st: Enumerator.T<Enumerator.IE<'T>,'T>) =\n            match st.State with\n            | null ->\n                if outerE.MoveNext() then\n                    st.State <- Enumerator.Get outerE.Current\n                    next st\n                else\n                    outerE.Dispose()\n                    false\n            | innerE ->\n                if innerE.MoveNext() then\n                    st.Current <- innerE.Current\n                    true\n                else\n                    (st :> System.IDisposable).Dispose()\n                    st.State <- null\n                    next st\n        Enumerator.NewDisposing null (fun st -> \n            safeDispose st.State \n            safeDispose outerE) \n            next)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (s: seq<'T>) : seq<'K * int> =\n    Seq.delay <| fun () ->\n        ArrayCountBy f (Array.ofSeq s) |> Seq.ofArray\n\n[<Name \"delay\">]\nlet Delay<'T> (f: unit -> seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get(f()))\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (s: seq<'T>) : seq<'T> =\n    Seq.distinctBy id s\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet<'K>()\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(f cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(f cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"splitInto\">]\nlet SplitInto count (s: seq<'T>) =\n    if count <= 0 then failwith \"Count must be positive\"\n    Seq.delay (fun () -> ArraySplitInto count (Array.ofSeq s) |> Seq.ofArray)   \n\n[<Inline>]\nlet Empty<'T> : seq<'T> = As [||]\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne<'T> (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then\n        let x = e.Current\n        if e.MoveNext() then\n            invalidOp \"Sequence contains more than one element\"\n        else x\n    else invalidOp \"Sequence contains no elements\"\n\n[<Inline>]\nlet Except (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    SeqExcept itemsToExclude s\n\n[<Name \"exists\">]\nlet Exists p (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- p e.Current\n    r\n\n[<Name \"exists2\">]\nlet Exists2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = false\n    while not r && e1.MoveNext() && e2.MoveNext() do\n        r <- p e1.Current e2.Current\n    r\n\n[<Name \"filter\">]\nlet Filter (f: 'T -> bool) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            let mutable loop = o.MoveNext()\n            let mutable c    = o.Current\n            let mutable res  = false\n            while loop do\n                if f c then\n                    e.Current <- c\n                    res       <- true\n                    loop      <- false\n                else\n                    if o.MoveNext() then\n                        c <- o.Current\n                    else\n                        loop <- false\n            res\n\n[<Name \"find\">]\nlet Find p (s: seq<_>) =\n    match Seq.tryFind p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex p (s: seq<_>) =\n    match Seq.tryFindIndex p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : 'S =\n    let mutable r = x\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"forall\">]\nlet ForAll p s =\n    not (Seq.exists (fun x -> not (p x)) s)\n\n[<Name \"forall2\">]\nlet ForAll2 p s1 s2 =\n    not (Seq.exists2 (fun x y -> not (p x y)) s1 s2)\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality) (s: seq<'T>) : seq<'K * seq<'T>> =\n    Seq.delay <| fun () ->\n        ArrayGroupBy f (Array.ofSeq s) |> As\n\n[<Name \"head\">]\nlet Head (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if e.MoveNext() then e.Current else InsufficientElements()\n\n[<Name \"init\">]\nlet Initialize (n: int) (f: int -> 'T) : seq<'T> =\n    Seq.take n (Seq.initInfinite f)\n\n[<Name \"initInfinite\">]\nlet InitializeInfinite (f: int -> 'T) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New 0 <| fun e ->\n            e.Current <- f e.State\n            e.State   <- e.State + 1\n            true\n\n[<Name \"isEmpty\">]\nlet IsEmpty (s: seq<'T>) : bool =\n    use e = Enumerator.Get s\n    not (e.MoveNext())\n\n[<Name \"iter\">]\nlet Iterate p (s: seq<_>) =\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p e.Current\n\n[<Name \"iter2\">]\nlet Iterate2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        p e1.Current e2.Current\n\n[<Name \"iteri\">]\nlet IterateIndexed p (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p i e.Current\n        i <- i + 1\n\n[<Inline>]\nlet Last (s: seq<_>) =\n    SeqLast s\n\n[<Name \"length\">]\nlet Length (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> en.Dispose()) <| fun e ->\n            if en.MoveNext() then\n                e.Current <- f en.Current\n                true\n            else\n                false\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Seq.map2 f (Seq.initInfinite id) s\n\n[<Name \"map2\">]\nlet Map2 (f: 'T -> 'U -> 'V) (s1: seq<'T>) (s2: seq<'U>) : seq<'V> =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() then\n                e.Current <- f e1.Current e2.Current\n                true\n            else\n                false\n\n[<Name \"maxBy\">]\nlet MaxBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"minBy\">]\nlet MinBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"max\">]\nlet Max (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x > m then\n            m <- x\n    m\n\n[<Name \"min\">]\nlet Min (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x < m then\n            m <- x\n    m\n\n[<Name \"nth\">]\nlet Get index (s: seq<'T>) =\n    if index < 0 then\n        failwith \"negative index requested\"\n    let mutable pos = -1\n    use e = Enumerator.Get s\n    while pos < index do\n        if not (e.MoveNext()) then\n            InsufficientElements()\n        pos <- pos + 1\n    e.Current\n\n[<Inline>]\nlet Item index (s: seq<'T>) = Get index s\n\n[<Inline \"$a\">]\n[<Name \"ofArray\">]\nlet OfArray (a: 'T[]) = X<seq<'T>>\n\n[<Inline \"$l\">]\n[<Name \"ofList\">]\nlet OfList (l: list<'T>) = X<seq<'T>>\n\n[<Name \"pairwise\">]\nlet Pairwise (s: seq<'T>) : seq<'T * 'T> =\n    Seq.windowed 2 s\n    |> Seq.map (fun x -> (x.[0], x.[1]))\n\n[<Name \"pick\">]\nlet Pick p (s: seq<_>) =\n    match Seq.tryPick p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"readOnly\">]\nlet ReadOnly (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get s)\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (source: seq<'T>) : 'T =\n    use e = Enumerator.Get source\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable r = e.Current\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : seq<'S> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing false (fun _ -> en.Dispose()) <| fun e ->\n            if e.State then\n                if en.MoveNext() then\n                    e.Current <- f e.Current en.Current\n                    true\n                else\n                    false\n            else\n                e.Current <- x\n                e.State <- true\n                true\n\n[<Inline \"[$x]\">]\n[<Name \"singleton\">]\nlet Singleton<'T> (x: 'T) = X<seq<'T>>\n\n[<Name \"skip\">]\nlet Skip (n: int) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                for i = 1 to n do\n                    if not (o.MoveNext()) then\n                        InsufficientElements()\n                e.State <- false\n            if o.MoveNext() then\n                e.Current <- o.Current\n                true\n            else\n                false))\n\n[<Name \"skipWhile\">]\nlet SkipWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                let mutable go = true\n                let mutable empty = false\n                while go do\n                    if o.MoveNext() then\n                        if not (f o.Current) then go <- false \n                    else \n                        go <-false\n                        empty <- true\n                e.State <- false\n                if empty then \n                    false \n                else\n                    e.Current <- o.Current\n                    true\n            else\n                if o.MoveNext() then\n                    e.Current <- o.Current\n                    true\n                else\n                    false))\n\n[<Name \"sort\">]\nlet Sort<'T when 'T : comparison> (s: seq<'T>) =\n    Seq.sortBy id s\n\n[<Name \"sortBy\">]\nlet SortBy<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        Array.sortInPlaceBy f array\n        array :> _)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        ArraySortInPlaceByDescending f array\n        array :> _)\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T : comparison> (s: seq<'T>) =\n    SortByDescending id s\n\n[<Name \"sum\">]\nlet Sum<'T> (s: seq<'T>) : 'T =\n    box (Seq.fold (fun s x -> s + (box x :?> _)) 0. s) :?> _\n\n[<Name \"sumBy\">]\nlet SumBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    box (Seq.fold (fun s x -> s + (box (f x) :?> _)) 0. s) :?> _\n\n[<Name \"take\">]\nlet Take (n: int) (s: seq<'T>) : seq<'T> =\n    if n < 0 then\n        InputMustBeNonNegative()\n    Enumerable.Of (fun () ->\n        let e = ref (Enumerator.Get s)\n        Enumerator.NewDisposing 0 (fun _ -> safeDispose !e) (fun o ->\n            o.State <- o.State + 1\n            if o.State > n then false else\n            let en = !e\n            if en = null then InsufficientElements()\n            elif en.MoveNext() then\n                o.Current <- en.Current\n                if o.State = n then\n                    en.Dispose()\n                    e := null\n                true\n            else\n                en.Dispose()\n                e := null\n                InsufficientElements()\n        )\n    )\n\n[<Name \"takeWhile\">]\nlet TakeWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        while e.MoveNext() && f e.Current do\n            yield e.Current\n    }\n\n[<Inline>]\nlet ToArray (s: seq<'T>) =\n    Array.ofSeq s\n\n[<Inline>]\nlet ToList (s: seq<'T>) = List.ofSeq s\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<#seq<'T>>) : seq<seq<'T>> =\n    Seq.delay (fun () ->\n        ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofSeq)) |> As\n    )\n\n[<Name \"truncate\">]\nlet Truncate (n: int) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        let i = ref 0\n        while e.MoveNext() && !i < n do\n            incr i\n            yield e.Current\n    }\n\n[<Name \"tryFind\">]\nlet TryFind ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r.IsNone && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            r <- Some x\n    r\n\n[<Inline>]\nlet TryFindBack ok (s: seq<_>) =\n    ArrayTryFindBack ok (Array.ofSeq s) \n\n[<Inline>]\nlet TryHead (s: seq<'T>) = SeqTryHead s\n\n[<Inline>]\nlet TryItem i (s: seq<'T>) = SeqTryItem i s\n\n[<Inline>]\nlet TryLast (s: seq<'T>) =  SeqTryLast s\n\n[<Name \"findBack\">]\nlet FindBack p (s: seq<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable loop = true\n    let mutable i = 0\n    while loop && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            loop <- false\n        else\n            i <- i + 1\n    if loop then None else Some i\n\n[<Inline>]\nlet TryFindIndexBack ok (s: seq<_>) =\n    ArrayTryFindIndexBack ok (Array.ofSeq s) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: seq<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryPick\">]\nlet TryPick f (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r = None && e.MoveNext() do\n        r <- f e.Current\n    r\n\n[<Name \"unfold\">]\nlet Unfold<'S, 'T> (f: 'S -> option<'T * 'S>) (s: 'S) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New s <| fun e ->\n            match f e.State with\n            | Some (t, s) ->\n                e.Current <- t\n                e.State  <- s\n                true\n            | None ->\n                false\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: seq<'T>) : seq<'T []> =\n    if windowSize <= 0 then\n        failwith \"The input must be positive.\"\n    seq {\n        use e = Enumerator.Get s\n        let q = new System.Collections.Generic.Queue<'T>()\n        while q.Count < windowSize && e.MoveNext() do\n            q.Enqueue e.Current\n        if q.Count = windowSize then\n            yield q.ToArray()\n            while e.MoveNext() do\n                ignore (q.Dequeue())\n                q.Enqueue e.Current\n                yield q.ToArray()\n    }\n\n[<Name \"zip\">]\nlet Zip (s1: seq<'T>) (s2: seq<'U>) =\n    Seq.map2 (fun x y -> x, y) s1 s2\n\n[<Name \"map3\">]\nlet Map3 f (s1: seq<_>) (s2: seq<_>) (s3: seq<_>) =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        let e3 = Enumerator.Get s3\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose(); e3.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() && e3.MoveNext() then\n                e.Current <- f e1.Current e2.Current e3.Current\n                true\n            else\n                false\n\n[<Name \"zip3\">]\nlet Zip3 (s1: seq<'T>) (s2: seq<'U>) (s3: seq<'V>) : seq<'T * 'U * 'V> =\n    Map3 (fun x y z -> x, y, z) s1 s2 s3\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (s1: seq<'T1>)\n                        (s2: seq<'T2>) : 'S =\n    Array.fold2 f s (Array.ofSeq s1) (Array.ofSeq s2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (s: seq<_>) state =\n    Array.foldBack f (Array.ofSeq s) state\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (s1: seq<_>) (s2: seq<_>) s =\n    Array.foldBack2 f (Array.ofSeq s1) (Array.ofSeq s2) s\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    let mutable i = 0\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        f i e1.Current e2.Current\n        i <- i + 1\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    Map3 f (Seq.initInfinite id) s1 s2\n\n[<Name \"mapFold\">]\nlet MapFold<'T,'S,'R> f zero s =\n    ArrayMapFold<'T,'S,'R> f zero (Seq.toArray s)\n    |> As<seq<'R> * 'S>\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T,'S,'R> f s zero =\n    ArrayMapFoldBack<'T,'S,'R> f (Seq.toArray s) zero\n    |> As<seq<'R> * 'S>\n\n[<Name \"permute\">]\nlet Permute f (s: seq<_>) =\n    Seq.delay (fun () -> Seq.ofArray (Array.permute f (Array.ofSeq s)))\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (s: seq<_>) =\n    Array.reduceBack f (Array.ofSeq s)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    if size < 0 then InputMustBeNonNegative()\n    seq { for i in 0 .. size - 1 -> value }\n\n[<Name \"rev\">]\nlet Reverse (s: seq<'T>) =\n    Seq.delay (fun () -> Array.rev (Seq.toArray s) |> Array.toSeq)\n    \n[<Name \"scanBack\">]\nlet ScanBack f (l: seq<_>) s =\n    Seq.delay (fun () -> Seq.ofArray (Array.scanBack f (Array.ofSeq l) s))\n\n[<Name \"indexed\">]\nlet Indexed (s : seq<'T>) : seq<int * 'T> =\n    Seq.mapi (fun a b -> (a, b)) s\n\n[<Name \"sortWith\">]\nlet SortWith f (s: seq<_>) =\n    Seq.delay (fun () -> \n        let a = Array.ofSeq s\n        Array.sortInPlaceWith f a\n        Seq.ofArray a)\n\n[<Name \"tail\">]\nlet Tail<'T> (s : seq<'T>) : seq<'T> =\n    Seq.skip 1 s\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : seq<'T>) : seq<'T> =\n    Filter predicate s\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Stack\">]\nmodule private WebSharper.StackProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (stack: obj) =\n    splice stack 0 (stack :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (stack: obj) (el: 'T) =\n    Seq.exists ((=) el) (stack :?> 'T[])\n    \n[<JavaScript>]\nlet CopyTo (stack: obj) (array: 'T[]) (index: int) =\n    Array.blit array 0 array index (stack :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Stack<_>>)>]\n[<Name \"WebSharper.Stack\">]\ntype private StackProxy<'T when 'T : equality> =\n\n    [<Inline \"[].concat($s).reverse()\">]\n    private new (s: 'T []) = {}\n\n    [<Inline \"[]\">]\n    new () = {}\n\n    [<Inline>]\n    private new (s: seq<'T>) = StackProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) : bool = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Pop() = X<'T>\n\n    [<Inline \"$this.unshift($x)\">]\n    member this.Push(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = X<'T[]>\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Strings\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.StringModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.StringProxy\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\nlet Compare (x: string) (y: string) = compare x y\n\nlet CopyTo (s: string) (o: int) (d: char []) (off: int) (ct: int) =\n    Array.blit (s.ToCharArray()) o d off ct\n\n[<Direct \"$x.substring($x.length - $s.length) == $s\">]\nlet EndsWith (x: string) (s: string) = X<bool>\n\n[<Direct \"$s.indexOf($c,$i)\">]\nlet IndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$x.substring(0,$index-1)+$s+$x.substring($index)\">]\nlet Insert (x: string) (index: int) (s: string) = X<string>\n\n[<Direct \"$x == null || $x == ''\">]\nlet IsNullOrEmpty (x: string) = X<bool>\n\n[<Direct \"\"\"$x == null || /^\\s*$/.test($x)\"\"\">]\nlet IsNullOrWhiteSpace (x: string) = X<bool>\n\n[<Direct \"$s.lastIndexOf($c,$i)\">]\nlet LastIndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$n>$s.length?Array($n-$s.length+1).join($c)+$s:$s\">]\nlet PadLeftWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadLeft (s: string) (n: int) =\n    PadLeftWith s n ' '\n\n[<Direct \"$n>$s.length?$s+Array($n-$s.length+1).join($c):$s\">]\nlet PadRightWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadRight (s: string) (n: int) =\n    PadRightWith s n ' '\n\n[<Direct \"$x.substring(0,$ix) + $x.substring($ix+$ct)\">]\nlet Remove (x: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$string.replace($search,$replace)\">]\nlet ReplaceOnce string search replace = X<string>\n\nlet Replace (subject: string) (search: string) (replace: string) =\n    let rec replaceLoop (subj: string) =\n        let index = subj.IndexOf(search)\n        if index <> -1 then\n            let replaced = ReplaceOnce subj search replace\n            let nextStartIndex = index + replace.Length\n            (replaced.Substring(0, index + replace.Length)) +\n                (replaceLoop (replaced.Substring(nextStartIndex)))\n        else subj\n    replaceLoop subject\n\nlet ReplaceChar (s: string) (oldC: char) (newC: char) =\n    Replace s (string oldC) (string newC)\n\n[<Direct \"$s.substr($ix,$ct)\">]\nlet Substring (s: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$t.substring(0,$s.length) == $s\">]\nlet StartsWith (t: string) (s: string) = X<bool>\n\nlet ToCharArray (s: string) = Array.init s.Length (fun x -> s.[x])\n\nlet ToCharArrayRange (s: string) (startIndex: int) (length: int) =\n    Array.init length (fun i -> s.[startIndex + i])\n\n[<Direct @\"$s.replace(/^\\s+/,'').replace(/\\s+$/,'')\">]\nlet Trim (s: string) = X<string>\n\n[<Direct @\"$s.replace(/^\\s+/,'')\">]\nlet TrimStartWS (s: string) = X<string>\n\nlet TrimStart (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimStartWS s\n    else\n        let mutable i = 0\n        let mutable go = true\n        while i < s.Length && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i + 1 \n            else go <- false\n        s.Substring(i)\n\n[<Direct @\"$s.replace(/\\s+$/,'')\">]\nlet TrimEndWS (s: string) = X<string>\n\nlet TrimEnd (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimEndWS s\n    else \n        let mutable i = s.Length - 1\n        let mutable go = true\n        while i >= 0 && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i - 1 \n            else go <- false\n        s.Substring(0, i + 1)\n\n[<Direct \"$values.join($sep)\">]\nlet Join (sep: string) (values: string []) = X<string>\n\n[<Direct \"$str.split($pat)\">]\nlet SplitWith (str: string) (pat: obj) = X<string[]>\n\n[<Inline \"new RegExp($pat)\">]\nlet MakeRegexp (pat: string) = X<obj>\n\n[<Direct @\"$s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\">]\nlet RegexEscape (s: string) = X<string>\n\nlet Split (s: string) (pat: obj) (opts: System.StringSplitOptions) =\n    let res = SplitWith s pat\n    if opts ===. System.StringSplitOptions.RemoveEmptyEntries then\n        Array.filter (fun x -> x !==. \"\") res\n    else\n        res\n\nlet SplitChars (s: string) (sep: char[]) (opts: System.StringSplitOptions) =\n    let re = \"[\" + RegexEscape (new System.String(sep)) + \"]\"\n    Split s (MakeRegexp re) opts\n\nlet SplitStrings (s: string) (sep: string[]) (opts: System.StringSplitOptions) =\n    let re = String.concat \"|\" (Array.map RegexEscape sep)\n    Split s (MakeRegexp re) opts\n\nlet Filter f (s: string) =\n    System.String.Concat(s |> Seq.choose (fun c -> if f c then Some (string c) else None) |> Array.ofSeq)\n\n[<Inline \"$text.replace($pattern, $replace)\">]\nlet ReplaceString (pattern: RegExp) (replace: 'obj) (text: string) = X<string>\n\nlet SFormat (format: string) (args: obj[]) =\n    let pattern = RegExp(\"{(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?}\", \"g\")\n    format\n    |> ReplaceString pattern (FuncWithArgs(fun (_, i, w) ->\n        let r = string args.[JS.Plus i]\n\n        if w <> JS.Undefined then\n            let w1 = JS.Plus w\n            let w2 = abs w1\n\n            if w2 > r.Length then\n                if w1 > 0 then r.PadLeft(w2)\n                else r.PadRight(w2)\n            else r\n        else r\n    ))\n\n[<Proxy(typeof<string>)>]\ntype private StringProxy =\n\n    [<Inline \"''\">]\n    new () = {}\n\n    [<Inline \"$chars.join('')\">]\n    new (chars: char []) = {}\n\n    [<Inline>]\n    static member CtorProxy(ch: char, n: int) = String.replicate n (string ch)\n\n    [<Inline \"$chars.slice($i, $i + $j).join('')\">]\n    new (chars: char [], i: int, j: int) = {}\n\n    member this.Chars  with [<Inline \"$this[$pos]\">]\n                            get (pos: int) = X<char>\n\n    [<Inline \"$this\">]\n    member this.Clone() = this :> obj\n\n    [<Inline \"$this\">]\n    member this.Copy() = this\n\n    [<Inline>]\n    static member Compare(x: string, y: string) =\n        Unchecked.compare x y\n\n    [<Inline>]\n    static member Compare(x: string, y: string, b: bool) =\n        if b then\n            Unchecked.compare (x.ToLower()) (y.ToLower())\n        else\n        Unchecked.compare x y\n\n    [<Inline>]\n    member this.CompareTo(s: string) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline>]\n    static member Concat(strings: string seq) =\n        Join \"\" (Array.ofSeq strings)\n\n    [<Inline>]\n    static member Concat<'T>(objs: 'T seq) : string =\n        Join \"\" (Array.ofSeq (objs |> Seq.map (fun o -> o.ToString())))\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string) = s1 + s2\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string) = s1 + s2 + s3\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string, s4: string) = s1 + s2 + s3 + s4\n\n    [<Inline>]\n    static member Concat(o1: obj) = string o1\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj) = string o1 + string o2\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj) = string o1 + string o2 + string o3\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj, o4: obj) = string o1 + string o2 + string o3 + string o4\n\n    [<Inline \"$strings.join('')\">]\n    static member Concat([<System.ParamArray>] strings: string[]) = X<string>\n\n    [<Inline>]\n    static member Concat(objs: obj[]) =\n        Join \"\" (As<string[]> objs)\n\n    [<Inline \"$this.indexOf($s) != -1\">]\n    member this.Contains(s: string) = X<bool>\n\n    [<Inline>]\n    member this.CopyTo(s: int, d: char [], off: int, ct: int) =\n        CopyTo (As this) s d off ct\n\n    static member Empty with [<Inline \"''\">] get () = X<string>\n\n    [<Inline>]\n    member this.EndsWith(other: string) = EndsWith (As this) other\n\n    [<Inline \"$x == $y\">]\n    static member Equals(x: string, y: string) = X<bool>\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: string) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get (unbox<seq<char>> this) |> As<System.CharEnumerator>\n\n    [<Inline \"$this.indexOf($s)\">]\n    member this.IndexOf(s: string) = X<int>\n\n    [<Inline \"$this.indexOf($c)\">]\n    member this.IndexOf(c: char) = X<int>\n\n    [<Inline \"$this.indexOf($s,$i)\">]\n    member this.IndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.IndexOf(c: char, i: int) = IndexOf (As this) c i\n\n    [<Inline>]\n    static member IsNullOrEmpty(x: string) = IsNullOrEmpty x\n\n    [<Inline>]\n    static member IsNullOrWhiteSpace(x: string) = IsNullOrWhiteSpace x\n\n    member this.Item\n        with    [<Inline \"$this[$pos]\">]\n                get (pos: int) = X<char>\n\n    [<Inline>]\n    static member Join(sep: string, values: string seq) =\n        Join sep (Array.ofSeq values)\n\n    [<Inline>]\n    static member Join(sep: string, [<System.ParamArray>] values: string[]) =\n        Join sep values\n\n    [<Inline \"$this.lastIndexOf($s)\">]\n    member this.LastIndexOf(s: string) = X<int>\n\n    [<Inline \"$this.lastIndexOf($c)\">]\n    member this.LastIndexOf(c: char) = X<int>\n\n    [<Inline \"$this.lastIndexOf($s,$i)\">]\n    member this.LastIndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.LastIndexOf(c: char, i: int) =\n        LastIndexOf (As this) c i\n\n    member this.Length with [<Inline \"$this.length\">]\n                            get () = X<int>\n\n    [<Inline>]\n    member this.PadLeft(i: int) =\n        PadLeft (As this) i\n\n    [<Inline>]\n    member this.PadLeft(i: int, c: char) =\n        PadLeftWith (As this) i c\n\n    [<Inline>]\n    member this.PadRight(i: int) =\n        PadRight (As this) i\n\n    [<Inline>]\n    member this.PadRight(i: int, c: char) =\n        PadRightWith (As this) i c\n\n    [<Inline \"$this.substring(0,$ix)\">]\n    member this.Remove(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Remove(ix: int, count: int) = Remove (As this) ix count\n\n    [<Inline>]\n    member this.ToCharArray() = ToCharArray (As this)\n\n    [<Inline>]\n    member this.Replace(subj: string, repl: string) =\n        Replace (As this) subj repl\n\n    [<Inline>]\n    member this.Replace(subj: char, repl: char) =\n        ReplaceChar (As this) subj repl\n\n    [<Inline>]\n    member this.Split([<System.ParamArray>] sep: char[]) =\n        SplitChars (As this) sep  System.StringSplitOptions.None\n\n    [<Inline>]\n    member this.Split(sep: char[], opts: System.StringSplitOptions) =\n        SplitChars (As this) sep opts\n\n    [<Inline>]\n    member this.Split(sep: string[], opts: System.StringSplitOptions) =\n        SplitStrings (As this) sep opts\n\n    [<Inline>]\n    member this.StartsWith(s: string) =\n        StartsWith (As this) s\n\n    [<Inline \"$this.substring($ix)\">]\n    member this.Substring(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Substring(ix: int, ct: int) =\n        Substring (As this) ix ct\n\n    [<Inline>]\n    member this.ToCharArray(i: int, l: int) =\n        ToCharArrayRange (As this) i l\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n    \n    [<Inline \"$this.toLowerCase()\">]\n    member this.ToLower() = X<string>\n\n    [<Inline \"$this.toUpperCase()\">]\n    member this.ToUpper() = X<string>\n\n    [<Inline>]\n    member this.Trim() = Trim (As this)\n\n    [<Inline>]\n    member this.TrimStart(t: char[]) = TrimStart (As this) t\n\n    [<Inline>]\n    member this.TrimEnd(t: char[]) = TrimEnd (As this) t\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: string, b: string) = X<string>\n\n    [<Inline>]\n    static member (+) (a: obj, b: string) = string a + b \n\n    [<Inline>]\n    static member (+) (a: string, b: obj) = a + string b\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: string, b: string) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: string, b: string) = X<bool>\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, [<System.ParamArray>] arguments: obj []) = SFormat format arguments\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj): string = SFormat format [|arg0|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj): string = SFormat format [|arg0; arg1|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj, arg2: obj): string = SFormat format [|arg0; arg1; arg2|]\n\nlet protect (s : string) =\n    if s = null then \"\" else s\n\n[<Inline \"$strings.join($sep)\">]\nlet join (strings: string[]) (sep: string) = X<string>\n\n[<Name \"collect\">]\nlet Collect (f: char -> string) (s: string) : string =\n    System.String.Concat(Array.init s.Length (fun i -> f s.[i]))\n\n[<Name \"concat\">]\nlet Concat (separator: string) (strings: seq<string>) : string =\n    join (Seq.toArray strings) separator\n\n[<Name \"exists\">]\nlet Exists (f: char -> bool) (s: string) : bool =\n    Seq.exists f (protect s)\n\n[<Name \"forall\">]\nlet ForAll (f: char -> bool) (s: string) : bool =\n    Seq.forall f (protect s)\n\n[<Name \"init\">]\nlet Initialize (count: int) (f: int -> string) : string =\n    System.String.Concat(Array.init count f)\n\n[<Name \"iter\">]\nlet Iterate (f: char -> unit) (s: string) : unit =\n    Seq.iter f (protect s)\n\n[<Name \"iteri\">]\nlet IterateIndexed (f: int -> char -> unit) (s: string) : unit =\n    Seq.iteri f (protect s)\n\n[<Name \"length\">]\nlet Length (s: string) : int =\n    (protect s).Length\n\n[<Name \"map\">]\nlet Map (f: char -> char) (s: string) : string =\n    Collect (fun x -> string (f x)) (protect s)\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> char -> char) (s: string) : string =\n    System.String.Concat (Seq.toArray (Seq.mapi (fun i x -> string (f i x)) s))\n\n[<Name \"replicate\">]\nlet Replicate (count: int) (s: string) : string =\n    System.String.Concat(Array.create count s)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nopen System.Threading\nopen System.Threading.Tasks\n\n[<Proxy(typeof<Task>); Name \"Task\">]\ntype private TaskProxy(action: System.Action, token: CT, status, exc) =\n    [<Name \"status\">]\n    let mutable status = status\n    [<Name \"continuations\">]\n    let continuations = [||] : TaskProxy[]\n    [<Name \"exc\">]\n    let mutable exc = exc : System.AggregateException\n\n    abstract Execute : unit -> unit\n    default this.Execute() = action.Invoke()\n\n    member this.Exception = exc\n\n    member this.IsCanceled = \n        status = TaskStatus.Canceled\n\n    member this.IsCompleted = \n        status = TaskStatus.RanToCompletion || status = TaskStatus.Faulted || status = TaskStatus.Canceled\n\n    member this.IsFaulted =\n        status = TaskStatus.Faulted\n\n    member this.Status = status\n\n    new (action) = TaskProxy(action, CT.None, TaskStatus.Created, null)\n\n    new (action, ct) = TaskProxy(action, ct, TaskStatus.Created, null)\n    \n    new (action: System.Action<obj>, obj: obj) = TaskProxy((fun () -> action.Invoke(obj)), CT.None, TaskStatus.Created, null)\n\n    new (action: System.Action<obj>, obj: obj, ct: CT) = TaskProxy((fun () -> action.Invoke(obj)), ct, TaskStatus.Created, null)\n\n    member this.OnCompleted(cont : unit -> unit) =\n        if this.IsCompleted then \n            cont()\n        else \n            if this.Status = TaskStatus.Created then this.Start()\n            this.ContinueWith(fun (_: Task) -> cont()) |> ignore\n\n    member this.RunContinuations() =\n        for c in continuations do\n            c.StartContinuation()    \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task>) =\n        this.ContinueWith(action, CT.None)\n\n    member this.ContinueWith(action: System.Action<Task>, ct) =\n        let res = TaskProxy((fun () -> action.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task> res\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task,'T>) =\n        this.ContinueWith(func, CT.None)\n\n    member this.ContinueWith(func: System.Func<Task,'T>, ct) =\n        let res = TaskProxy<'T>((fun () -> func.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null, JS.Undefined)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task<'T>> res\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke (t, obj))\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke (t, obj)), ct)\n\n    member this.StartContinuation() =\n        if status = TaskStatus.WaitingForActivation then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                if status = TaskStatus.WaitingToRun then\n                    status <- TaskStatus.Running\n                    try\n                        this.Execute()\n                        status <- TaskStatus.RanToCompletion\n                    with e ->\n                        exc <- System.AggregateException(e)\n                        status <- TaskStatus.Faulted\n                    this.RunContinuations()\n            )\n\n    member this.Start() =\n        if status = TaskStatus.Created then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                status <- TaskStatus.Running\n                try\n                    this.Execute()\n                    status <- TaskStatus.RanToCompletion\n                with\n                | :? OCE as e when e.CancellationToken = token ->\n                    Console.Log(\"Task cancellation caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Canceled\n                | e ->\n                    Console.Log(\"Task error caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Faulted\n                this.RunContinuations()\n            )\n        else\n            invalidOp \"Task not in initial state\"\n        \n    static member FromCanceled ct = \n        As<Task> (TaskProxy(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException())))\n\n    static member FromCanceled(ct: CT) = \n        As<Task<_>> (TaskProxy<_>(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException()), As null)) \n\n    static member FromException (exc: exn) =\n        As<Task> (TaskProxy(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc)))\n\n    static member FromException (exc: exn) =\n        As<Task<_>> (TaskProxy<_>(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc), As null))\n\n    static member FromResult (res: 'T) = \n        As<Task<'T>> (TaskProxy<'T>(null, CT.None, TaskStatus.RanToCompletion, null, res)) \n\n    [<Inline>]\n    static member Run(action : System.Action) =\n       TaskProxy.Run(action, CT.None)\n        \n    static member Run(action : System.Action, ct) =\n        let res = TaskProxy(action, ct, TaskStatus.Created, null)\n        res.Start()\n        As<Task> res\n\n    [<Inline>]\n    static member Run(func : System.Func<Task>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled ct : Task else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    [<Inline>]\n    static member Run(func : System.Func<'T>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<'T>, ct) =\n        let res = TaskProxy<'T>(func, ct, TaskStatus.Created, null, JS.Undefined)\n        res.Start()\n        As<Task<'T>> res   \n\n    [<Inline>]\n    static member Run(func : System.Func<Task<'T>>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task<'T>>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled<'T> ct else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    static member Delay(time: int) =   \n        Async.StartAsTask (Async.Sleep time) :> Task\n             \n    static member Delay(time: int, ct) =        \n        Async.StartAsTask (Async.Sleep time, cancellationToken = ct) :> Task\n\n    [<Inline>]\n    static member Delay(time: System.TimeSpan) =        \n        TaskProxy.Delay(As<int> time)\n             \n    [<Inline>]\n    static member Delay(time: System.TimeSpan, ct) =        \n        TaskProxy.Delay(As<int> time, ct)\n\n    static member WhenAny(tasks: Task[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAny(tasks: Task<'T>[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<Task<'T>>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task<'T>>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun t -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    if !completed = target then tcs.TrySetResult() |> ignore \n            ) |> ignore\n        tcs.Task :> Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task<'T>[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let results = JavaScript.Array(target)\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun (t: Task<'T>) -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    results.[i] <- t.Result\n                    if !completed = target then tcs.SetResult results.Self\n            ) |> ignore\n        tcs.Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task<'T>>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member Yield() =\n        new Task(fun () -> ()) |> As<System.Runtime.CompilerServices.YieldAwaitable>  \n\nand [<Proxy(typeof<Task<_>>); Name \"Task1\">] private TaskProxy<'T>(func: System.Func<'T>, token: CT, status, exc, result) =\n    inherit TaskProxy(null, token, status, exc)\n    \n    [<Name \"result\">]\n    let mutable result = result\n\n    new (func) = TaskProxy<'T>(func, CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func, ct) = TaskProxy<'T>(func, ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj) = TaskProxy<'T>((fun () -> func.Invoke obj), CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj, ct: CT) = TaskProxy<'T>((fun () -> func.Invoke obj), ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    member this.Result = \n        match this.Status with\n        | TaskStatus.RanToCompletion -> result\n        | TaskStatus.Faulted\n        | TaskStatus.Canceled -> raise this.Exception \n        | _ -> invalidOp \"Task has not been completed, has no Result\"\n\n    override this.Execute () =\n        result <- func.Invoke()\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>) =\n        this.ContinueWith(As<System.Action<Task>> action)\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>, ct) =\n        this.ContinueWith(As<System.Action<Task>> action, ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>, ct) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func, ct) \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke(t, obj)) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke(t, obj)), ct) \n\n[<Proxy(typeof<TaskCompletionSource<_>>)>]\n[<Name \"TaskCompletionSource\">]\ntype private TaskCompletionSourceProxy<'T>() =\n    let task = new TaskProxy<'T>(null, CT.None, TaskStatus.WaitingForActivation, null, JS.Undefined)\n\n    member this.Task = As<Task<'T>> task\n\n    member this.SetCanceled() =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Canceled\n        task.RunContinuations()\n\n    member this.SetException(exc: exn) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Faulted\n        task?exc <- System.AggregateException(exc)\n        task.RunContinuations()\n\n    member this.SetException(exs : seq<exn>) =\n        this.SetException(System.AggregateException(exs))\n\n    member this.SetResult(res: 'T) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.RanToCompletion\n        task?result <- res \n        task.RunContinuations()\n\n    member this.TrySetCanceled() =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetCanceled(ct: CT) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task?token <- ct\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exc: exn) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Faulted\n            task?exc <- System.AggregateException(exc)\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exs : seq<exn>) =\n        this.TrySetException(System.AggregateException(exs))\n\n    member this.TrySetResult(res: 'T) =        \n        if not task.IsCompleted then\n            task?status <- TaskStatus.RanToCompletion\n            task?result <- res \n            task.RunContinuations()\n            true\n        else false\n    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements generic comparison, equality and hashing.\n[<WebSharper.Name \"Unchecked\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+Unchecked, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.UncheckedProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$a instanceof Array\">]\nlet isArray (a: obj) = X<bool>\n\n[<Inline \"$a instanceof Date\">]\nlet isDate (a: obj) = X<bool>\n\nlet rec compareArrays (a: obj []) (b: obj []) =\n    if a.Length < b.Length   then -1\n    elif a.Length > b.Length then 1\n    else\n        let mutable cmp = 0\n        let mutable i = 0\n        while cmp = 0 && i < a.Length do\n            cmp <- Unchecked.compare a.[i] b.[i]\n            i <- i + 1\n        cmp\n\n[<Inline \"$d.getTime()\">]\nlet getTime (d: obj) : int = X\n\nlet rec compareDates (a: obj) (b: obj) =\n    compare (getTime a) (getTime b)\n\n/// Compares two values generically.\nlet Compare<'T> (a: 'T) (b: 'T) : int =\n    let objCompare (a: obj) (b: obj) =\n        let cmp = ref 0\n        JS.ForEach a (fun k ->\n            if not (JS.HasOwnProperty a k) then\n                false\n            elif not (JS.HasOwnProperty b k) then\n                cmp := 1; true\n            else\n                cmp := Unchecked.compare a?(k) b?(k); !cmp <> 0)\n        if !cmp = 0 then\n            JS.ForEach b (fun k ->\n                if not (JS.HasOwnProperty b k) then\n                    false\n                elif not (JS.HasOwnProperty a k) then\n                    cmp := -1; true\n                else false)\n        !cmp\n    if a ===. b then 0 else\n        match JS.TypeOf a with\n        | JS.Undefined ->\n            match JS.TypeOf b with\n            | JS.Undefined -> 0\n            | _ -> -1\n        | JS.Function ->\n            failwith \"Cannot compare function values.\"\n        | JS.Boolean | JS.Number | JS.String ->\n            if a <. b then -1 else 1\n        | JS.Object ->\n            if a ===. null then -1\n            elif b ===. null then 1\n            elif JS.In \"CompareTo\" a then (As<System.IComparable<_>> a).CompareTo(b)\n            elif JS.In \"CompareTo0\" a then (As<System.IComparable> a).CompareTo(b)\n            elif isArray a && isArray b then compareArrays (As a) (As b)\n            elif isDate a && isDate b then compareDates a b\n            else objCompare (As a) (As b)\n\n/// Produces an undefined value.\n[<Macro(typeof<M.DefaultOf>)>]\n[<Inline \"undefined\">]\nlet DefaultOf<'T> = X<'T>\n\nlet arrayEquals (a: obj []) (b: obj []) =\n    if a.Length = b.Length then\n        let mutable eq = true\n        let mutable i = 0\n        while eq && i < a.Length do\n            if not (Unchecked.equals a.[i] b.[i]) then\n                eq <- false\n            i <- i + 1\n        eq\n    else\n        false\n\nlet dateEquals a b =\n    getTime a ===. getTime b\n\n[<Inline \"$a.Equals($b)\">]\nlet private equals (a: obj) (b: obj) = X<bool>\n\n/// Tests if two values are equal.\nlet Equals (a: 'T) (b: 'T) : bool =\n    let objEquals (a: obj) (b: obj) =\n        let eqR = ref true\n        JS.ForEach a (fun k ->\n            eqR := not (JS.HasOwnProperty a k) || JS.HasOwnProperty b k && Unchecked.equals a?(k) b?(k)\n            not !eqR)\n        if !eqR then\n            JS.ForEach b (fun k ->\n                eqR := not (JS.HasOwnProperty b k) || JS.HasOwnProperty a k\n                not !eqR)\n        !eqR\n    if a ===. b then true else\n        match JS.TypeOf a with\n        | JS.Object ->\n            if a ===. null || a ===. JS.Undefined || b ===. null || b ===. JS.Undefined then false\n            elif JS.In \"Equals\" a then equals a b\n            elif isArray a && isArray b then arrayEquals (As a) (As b)\n            elif isDate a && isDate b then dateEquals a b\n            else objEquals (As a) (As b)\n        | JS.Function ->\n            if JS.In \"$Func\" a then\n                a?``$Func`` ===. b?``$Func`` && a?``$Target`` ===. b?``$Target``\n            elif JS.In \"$Invokes\" a && JS.In \"$Invokes\" b then\n                arrayEquals a?``$Invokes`` b?``$Invokes``  \n            else false\n        | _ ->\n            false\n\nlet hashMix (x: int) (y: int) : int =\n    (x <<< 5) + x + y\n\nlet hashArray (o: obj []) =\n    let mutable h = -34948909\n    for i in 0 .. o.Length - 1 do\n        h <- hashMix h (Unchecked.hash o.[i])\n    h\n\nlet hashString (s: string) : int =\n    if s ===. null then 0 else\n        let mutable hash = 5381\n        for i = 0 to s.Length - 1 do\n            hash <- hashMix hash (int s.[i])\n        hash\n\n[<Inline \"$o.GetHashCode()\">]\nlet getHashCode(o: obj) = X<int>\n\nlet hashObject (o: obj) =\n    if JS.In \"GetHashCode\" o then getHashCode o else\n        let (++) = hashMix\n        let h = ref 0\n        JS.ForEach o (fun key ->\n            h := !h ++ hashString key ++ Unchecked.hash ((?) o key)\n            false)\n        !h\n\n/// Computes the hash of an object.\nlet Hash<'T> (o: 'T) : int =\n    match JS.TypeOf o with\n    | JS.Undefined -> 0\n    | JS.Function  -> 0\n    | JS.Boolean   -> if As o then 1 else 0\n    | JS.Number    -> As o\n    | JS.String    -> hashString (As o)\n    | JS.Object    -> if o ==. null then 0\n                      elif isArray o then hashArray (As o)\n                      else hashObject o\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<voption<_>>)>]\n[<RequireQualifiedAccess>]\ntype private ValueOptionProxy<'T> =\n    | ValueNone \n    | ValueSome of 'T\n\n    member this.Value =\n        match this with \n        | ValueNone -> invalidOp \"ValueOption.Value\"\n        | ValueSome x -> x \n\n    static member Test =\n        (ValueSome 2).Value\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"Numeric\">]\ntype internal N =\n    static member Parse<'T>(s: string, min: 'T, max: 'T, overflowMsg) =\n        let x : float = JS.Plus s\n        if x !==. (x -. (x %. 1)) then\n            raise (System.FormatException \"Input string was not in a correct format.\")\n        elif (x <. min) || (x >. max) then\n            raise (System.OverflowException overflowMsg)\n        else As<'T> x\n\n    static member TryParse<'T>(s: string, min: 'T, max: 'T, r: byref<'T>) =\n        let x : float = JS.Plus s\n        let ok = x ===. (x -. (x %. 1)) && (x >=. min) && (x <=. max)\n        if ok then r <- As<'T> x\n        ok\n\n    static member ParseBool(s: string) =\n        match s.ToLower() with\n        | \"true\" -> true\n        | \"false\" -> false\n        | _ -> raise (System.FormatException \"String was not recognized as a valid Boolean.\")\n\n    static member TryParseBool(s: string, r: byref<bool>) =\n        match s.ToLower() with\n        | \"true\" -> r <- true; true\n        | \"false\" -> r <- false; true\n        | _ -> false\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Byte>)>]\ntype internal NB =\n\n    [<Name \"WebSharper.Numeric.ParseByte\">]\n    static member Parse(s: string) : System.Byte =\n        N.Parse(s, System.Byte.MinValue, System.Byte.MaxValue, \"Value was either too large or too small for an unsigned byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseByte\">]\n    static member TryParse(s: string, r: byref<System.Byte>) : bool =\n        N.TryParse(s, System.Byte.MinValue, System.Byte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.SByte>)>]\ntype internal NSB =\n\n    [<Name \"WebSharper.Numeric.ParseSByte\">]\n    static member Parse(s: string) : System.SByte =\n        N.Parse(s, System.SByte.MinValue, System.SByte.MaxValue, \"Value was either too large or too small for a signed byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseSByte\">]\n    static member TryParse(s: string, r: byref<System.SByte>) : bool =\n        N.TryParse(s, System.SByte.MinValue, System.SByte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int16>)>]\n[<Name \"Int16\">]\ntype internal NI16 =\n\n    [<Name \"WebSharper.Numeric.ParseInt16\">]\n    static member Parse(s: string) : System.Int16 =\n        N.Parse(s, System.Int16.MinValue, System.Int16.MaxValue, \"Value was either too large or too small for an Int16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt16\">]\n    static member TryParse(s: string, r: byref<System.Int16>) : bool =\n        N.TryParse(s, System.Int16.MinValue, System.Int16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int32>)>]\n[<Name \"Int32\">]\ntype internal NI32 =\n\n    [<Name \"WebSharper.Numeric.ParseInt32\">]\n    static member Parse(s: string) : System.Int32 =\n        N.Parse(s, System.Int32.MinValue, System.Int32.MaxValue, \"Value was either too large or too small for an Int32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt32\">]\n    static member TryParse(s: string, r: byref<System.Int32>) : bool =\n        N.TryParse(s, System.Int32.MinValue, System.Int32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt16>)>]\n[<Name \"UInt16\">]\ntype internal NUI16 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt16\">]\n    static member Parse(s: string) : System.UInt16 =\n        N.Parse(s, System.UInt16.MinValue, System.UInt16.MaxValue, \"Value was either too large or too small for an UInt16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt16\">]\n    static member TryParse(s: string, r: byref<System.UInt16>) : bool =\n        N.TryParse(s, System.UInt16.MinValue, System.UInt16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt32>)>]\n[<Name \"UInt32\">]\ntype internal NUI32 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt32\">]\n    static member Parse(s: string) : System.UInt32 =\n        N.Parse(s, System.UInt32.MinValue, System.UInt32.MaxValue, \"Value was either too large or too small for an UInt32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt32\">]\n    static member TryParse(s: string, r: byref<System.UInt32>) : bool =\n        N.TryParse(s, System.UInt32.MinValue, System.UInt32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int64>)>]\n[<Name \"Int64\">]\ntype internal NI64 =\n\n    [<Name \"WebSharper.Numeric.ParseInt64\">]\n    static member Parse(s: string) : System.Int64 =\n        N.Parse(s, System.Int64.MinValue, System.Int64.MaxValue, \"Value was either too large or too small for an Int64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt64\">]\n    static member TryParse(s: string, r: byref<System.Int64>) : bool =\n        N.TryParse(s, System.Int64.MinValue, System.Int64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt64>)>]\n[<Name \"UInt64\">]\ntype internal NUI64 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt64\">]\n    static member Parse(s: string) : System.UInt64 =\n        N.Parse(s, System.UInt64.MinValue, System.UInt64.MaxValue, \"Value was either too large or too small for an UInt64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt64\">]\n    static member TryParse(s: string, r: byref<System.UInt64>) : bool =\n        N.TryParse(s, System.UInt64.MinValue, System.UInt64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Single>)>]\ntype internal NS =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: single) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: single) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: single) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: single) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Single>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Single>) = X<bool>\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Double>)>]\ntype internal ND =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: double) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: double) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: double) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: double) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Double>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Double>) = X<bool>\n\n[<Proxy(typeof<System.Boolean>)>]\ntype internal B = \n    [<Inline>]\n    static member op_LogicalNot(a: bool) = not a\n\n    [<Inline \"$this == $x\">]\n    member this.Equals(x: bool) = X<bool>\n\n    [<Inline \"$this === $x\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: bool, b: bool) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: bool, b: bool) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Constant \"true\">]\n    static member TrueString = X<string>\n\n    [<Constant \"false\">]\n    static member FalseString = X<string>\n\n    [<Inline>]\n    override this.ToString() = string this\n\n    [<Inline>]\n    member this.CompareTo(x: bool) =\n        Unchecked.compare (this :> obj) (x :> obj)\n\n    [<Inline>]\n    member this.CompareTo(x: obj) =\n        Unchecked.compare (this :> obj) x\n\n    [<Inline>]\n    static member Parse(x: string) =\n        N.ParseBool x\n\n    [<Inline>]\n    static member TryParse(x: string, r: byref<bool>) =\n        N.TryParseBool(x, &r)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule internal WebSharper.ClientSideJson\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype OptionalFieldKind =\n    /// The field doesn't have type option<'T>\n    | NotOption = 0\n    /// The field has type option<'T>\n    | NormalOption = 1\n    /// The field has type option<'T> and is marked [<OptionalField>]\n    | MarkedOption = 2\n    /// The field has type Optional<'T>\n    | ErasedOption = 3\n\nlet ServerSideProvider = WebSharper.Core.Json.Provider.Create ()\n\n[<JavaScript>]\nmodule Provider =\n    let Id () = \n        ()\n        fun () -> id\n\n    let EncodeTuple (encs: (unit -> obj -> obj)[]) : (unit -> obj[] -> obj) =\n        ()\n        fun () args ->\n            box (Array.map2 (fun f x -> f () x) encs args)\n\n    let EncodeDateTime () =\n        ()\n        fun () (x: System.DateTime) ->\n            box (x.JS.ToISOString())\n\n    let EncodeDateTimeOffset () =\n        ()\n        fun () (x: System.DateTimeOffset) ->\n            box (New [ \"d\" => x.DateTime.JS.ToISOString(); \"o\" => x?o ])\n\n    let EncodeList (encEl: unit -> 'T -> obj) : (unit -> list<'T> -> obj) =\n        ()\n        fun () (l: list<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            l |> List.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeRecord (_: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            let o = New []\n            fields |> Array.iter (fun (name, enc, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    o?(name) <- enc () x?(name)\n                | OptionalFieldKind.NormalOption ->\n                    match x?(name) with\n                    | Some x -> o?(name) <- enc () x\n                    | None -> ()\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- enc () x?(name)\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- enc () x?(name)\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let EncodeUnion (_: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = New []\n                let tag = x?(\"$\")\n                let tagName, fields = cases.[tag]\n                if JS.TypeOf discr = JS.Kind.String then o?(discr) <- tagName\n                fields |> Array.iter (fun (from, ``to``, enc, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let record = enc () (x?(\"$0\"))\n                        JS.ForEach record (fun f -> o?(f) <- record?(f); false)\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(``to``) <- enc () (x?(from))\n                        | OptionalFieldKind.NormalOption ->\n                            match x?(from) with\n                            | Some x -> o?(``to``) <- enc () x\n                            | None -> ()\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else box x // [<Constant>]\n\n    let EncodeArray (encEl: (unit -> 'T -> obj)) : (unit -> 'T[] -> obj) =\n        ()\n        fun () (a: 'T[]) ->\n            let e = encEl()\n            box (Array.map e a)\n\n    let EncodeSet (encEl: (unit -> 'T -> obj)) : (unit -> Set<'T> -> obj) =\n        ()\n        fun () (s: Set<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            s |> Set.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeStringMap (encEl:(unit -> 'T -> obj)) : (unit -> Map<string, 'T> -> obj) =\n        ()\n        fun () (m: Map<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            m |> Map.iter (fun k v -> o?(k) <- e v)\n            o\n\n    let EncodeArrayMap (encKey:(unit -> 'K -> obj)) (encEl:(unit -> 'V -> obj)) : (unit -> Map<'K, 'V> -> obj) =\n        ()\n        fun () (m: Map<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            m |> Map.iter (fun key el -> a.JS.Push([| [| k key; e el |] |]) |> ignore)\n            box a\n\n    let EncodeStringDictionary (encEl:(unit -> 'T -> obj)) : (unit -> Dictionary<string, 'T> -> obj) =\n        ()\n        fun () (d: Dictionary<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            for KeyValue(k, v) in d :> seq<_> do o?(k) <- e v\n            o\n\n    let EncodeArrayDictionary (encKey: (unit -> 'K -> obj)) (encEl: (unit -> 'V -> obj)) : (unit -> Dictionary<'K, 'V> -> obj) =\n        ()\n        fun () (d: Dictionary<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            for KeyValue(key, el) in d do a.JS.Push([| [| k key; e el |] |]) |> ignore\n            box a\n\n    let EncodeLinkedList (encEl:(unit -> 'T -> obj)) : (unit -> LinkedList<'T> -> obj) =\n        ()\n        fun () (d: LinkedList<'T>) ->\n            let o = Array<'T>()\n            let e = encEl()\n            for x in d :> seq<'T> do o.Push(e x) |> ignore\n            box o\n\n    let DecodeTuple (decs: (unit -> obj -> obj)[]) : (unit -> obj -> obj[]) =\n        As (EncodeTuple decs)\n\n    let DecodeDateTime() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                Date(x?d: string).Self\n            else \n                Date(x :?> string).Self\n\n    let DecodeDateTimeOffset() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                System.DateTimeOffset(Date(x?d: string).Self, System.TimeSpan.FromMinutes x?o)\n            else \n                System.DateTimeOffset(Date(x :?> string).Self, System.TimeSpan.Zero)\n\n    let DecodeList (decEl: (unit -> obj -> 'T)) : (unit -> obj -> list<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            List.init (a :?> obj[]).Length (fun i -> e (a :?> obj[]).[i])\n\n    let DecodeSet (decEl: unit -> obj -> 'T) : (unit -> obj -> Set<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            Set.ofArray(Array.map e (a :?> obj[]))\n\n    let DecodeRecord (t: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            let o = if t ===. JS.Undefined then New [] else JS.New t\n            fields |> Array.iter (fun (name, dec, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- dec () x?(name)\n                    else failwith (\"Missing mandatory field: \" + name)\n                | OptionalFieldKind.NormalOption ->\n                    o?(name) <-\n                        if JS.HasOwnProperty x name\n                        then Some (dec () x?(name))\n                        else None\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- (dec () x?(name))\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- (dec () x?(name))\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let DecodeUnion (t: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = if t ===. JS.Undefined then New [] else JS.New t\n                let tag =\n                    // [<NamedUnionCases(discr)>]\n                    if JS.TypeOf discr = JS.Kind.String then\n                        let tagName = x?(discr)\n                        cases |> Array.findIndex (fun (name, _) -> name = tagName)\n                    else // [<NamedUnionCases>]\n                        let r = ref JS.Undefined\n                        JS.ForEach discr (fun k ->\n                            if JS.HasOwnProperty x k then r := discr?(k); true else false)\n                        !r\n                o?(\"$\") <- tag\n                cases.[tag] |> snd |> Array.iter (fun (from, ``to``, dec, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let r = dec () x\n                        // eliminate tag field if record deserializer is identity\n                        if As<bool> ``to`` then \n                            JS.Delete r discr\n                        o?(\"$0\") <- r\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(from) <- dec () (x?(``to``))\n                        | OptionalFieldKind.NormalOption ->\n                            o?(from) <-\n                                if JS.HasOwnProperty x ``to``\n                                then Some (dec () x?(``to``))\n                                else None\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else x :?> 'T // [<Constant>]\n\n    let DecodeArray (decEl :(unit -> obj -> 'T)) : (unit -> obj -> 'T[]) =\n        As (EncodeArray (As decEl))\n\n    let DecodeStringMap (decEl :(unit -> obj -> 'T)) : (unit -> obj -> Map<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let m = ref Map.empty\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> m := Map.add k (decEl o?(k)) !m; false)\n            !m\n\n    let DecodeArrayMap (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Map<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let mutable m = Map<'K, 'V> []\n            for k, v in o :?> (obj * obj)[] do m <- Map.add (decKey k) (decEl v) m\n            m\n\n    let DecodeStringDictionary (decEl: unit -> obj -> 'T) : (unit -> obj -> Dictionary<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let d = System.Collections.Generic.Dictionary()\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> d.Add(k, decEl o?(k)); false)\n            d\n\n    let DecodeArrayDictionary (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Dictionary<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let d = Dictionary<'K, 'V>()\n            for k, v in o :?> (obj * obj)[] do d.Add(decKey k, decEl v)\n            d\n\n    let DecodeLinkedList (decEl: unit -> obj -> 'T) : (unit -> obj -> LinkedList<'T>) =\n        ()\n        fun () (o: obj) ->\n            let l = LinkedList<'T>()\n            let decEl = decEl()\n            for x in o :?> obj[] do l.AddLast(decEl x) |> ignore\n            l\n\nmodule Macro =\n\n    module M = WebSharper.Core.Metadata\n    open WebSharper.Core.AST\n    module JI = WebSharper.Core.Json.Internal\n    type private BF = System.Reflection.BindingFlags\n\n    type Parameters =\n        {\n            Warnings : ResizeArray<string>\n            Dependencies : ResizeArray<M.Node>\n            Compilation : M.ICompilation\n        }\n\n    [<AutoOpen>]\n    module private Internals =\n\n        let cString s = !~ (Literal.String s)\n        let inline cInt i = !~ (Int i)\n\n        let mainJsonModule =\n            TypeDefinition {\n                FullName = \"WebSharper.Json\"\n                Assembly = \"WebSharper.Main\"\n            }\n        let mJson (comp: M.ICompilation) f args =\n            let m = comp.GetClassInfo(mainJsonModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric mainJsonModule, NonGeneric m, args)\n\n        let (|T|) (t: TypeDefinition) = t.Value.FullName\n        let (|C|_|) (t: Type) =\n            match t with \n            | ConcreteType { Entity = e; Generics = g} -> Some (e, g)\n            | _ -> None\n\n        let providerType = \n            TypeDefinition {\n                FullName = \"WebSharper.ClientSideJson+Provider\"\n                Assembly = \"WebSharper.Web\"\n            }\n        let invoke (comp: M.ICompilation) isEnc n args = \n            let f = (if isEnc then \"Encode\" else \"Decode\") + n\n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric providerType, NonGeneric m, args)\n        let invokeId (comp: M.ICompilation) = \n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = \"Id\")\n            Call(None, NonGeneric providerType, NonGeneric m, [])\n\n        type EncodeResult = Choice<Expression, string, Type>\n\n        let (>>=) (x: EncodeResult) (f: Expression -> EncodeResult) =\n            match x with\n            | Choice1Of3 e -> f e\n            | _ -> x\n        let ok x = Choice1Of3 x : EncodeResult\n        let fail x = Choice2Of3 x : EncodeResult\n        let generic t = Choice3Of3 t : EncodeResult\n\n        let mapOk f x =\n            match x with\n            | Choice1Of3 x -> Choice1Of3 (f x) \n            | _ -> x\n\n        /// Returns None if MacroNeedsResolvedTypeArg.\n        let getEncoding name isEnc param (t: Type) : EncodeResult =\n            let warn msg = param.Warnings.Add msg\n            let addTypeDep td = param.Dependencies.Add (M.TypeNode td)\n            let comp = param.Compilation\n            let call = invoke comp isEnc\n            let ident = invokeId comp \n            let isIdent r =\n                match r with \n                | Choice1Of3 e when obj.ReferenceEquals(e, ident) -> true\n                | _ -> false\n            let rec encode t =\n                match t with\n                | ArrayType (t, 1)\n                | C (T \"System.Collections.Generic.List`1\", [t])\n                | C (T \"System.Collections.Generic.Queue`1\", [t])\n                | C (T \"System.Collections.Generic.Stack`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Array\" [e])\n                | ArrayType _ ->\n                    fail \"JSON serialization for multidimensional arrays is not supported.\"\n                | VoidType\n                | C (T (\"Microsoft.FSharp.Core.Unit\"\n                            | \"System.Boolean\"\n                            | \"System.SByte\"   | \"System.Byte\"\n                            | \"System.Int16\"   | \"System.UInt16\"\n                            | \"System.Int32\"   | \"System.UInt32\"\n                            | \"System.Int64\"   | \"System.UInt64\"\n                            | \"System.Single\"  | \"System.Double\"\n                            | \"System.String\"  | \"System.Guid\"\n                            | \"WebSharper.Core.Json+Encoded\"), []) ->\n                    ok ident\n                | C (T \"System.Object\", []) ->\n                    if isEnc then \n                        fail \"JSON serialization for System.Object is not supported; only deserialization.\" \n                    else ok ident\n                | C (T \"Microsoft.FSharp.Collections.FSharpList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"List\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpSet`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Set\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpMap`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e -> \n                        ok (call \"StringMap\" [e])\n                    | _ ->\n                        encode k >>= fun k -> \n                        encode t >>= fun e -> \n                        ok (call \"ArrayMap\" [k; e])\n                | C (T \"System.Collections.Generic.Dictionary`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e ->\n                        ok (call \"StringDictionary\" [e])\n                    | _ ->\n                        encode k >>= fun k ->\n                        encode t >>= fun e ->\n                        ok (call \"ArrayDictionary\" [k; e])\n                | C (T \"System.Collections.Generic.LinkedList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"LinkedList\" [e])\n                | TupleType (ts, _) ->\n                    ((fun es -> ok (call \"Tuple\" [NewArray es])), ts)\n                    ||> List.fold (fun k t ->\n                        fun es -> encode t >>= fun e -> k (e :: es))\n                    <| []\n                | C (T \"System.DateTime\", []) ->\n                    ok (call \"DateTime\" [])\n                | C (T \"System.DateTimeOffset\", []) ->\n                    ok (call \"DateTimeOffset\" [])\n                | C (td, args) ->                    \n                    let top = comp.AssemblyName.Replace(\".\",\"$\") + if isEnc then \"_JsonEncoder\" else \"_JsonDecoder\"\n                    let key = M.CompositeEntry [ M.StringEntry top; M.TypeEntry t ]\n                    match comp.GetMetadataEntries key with                    \n                    | M.StringEntry \"id\" :: _ ->\n                        ok ident\n                    | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                        Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                    | _ ->\n                        let gtd, gm, _ = comp.NewGenerated([top; \"j\"])\n                        let _, gv, va = comp.NewGenerated([top; \"_\" + \"v\"])\n                        comp.AddGeneratedCode(gv, Undefined)\n                        comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                        ((fun es ->\n                            let enc = encRecType t args es\n                            if isIdent enc then\n                                comp.AddMetadataEntry(key, M.StringEntry \"id\")\n                                comp.AddGeneratedInline(gm, ident)\n                                enc\n                            else\n                                enc >>= fun e ->\n                                let v = Lambda([], Call (None, NonGeneric gtd, NonGeneric gv, []))\n                                let vn = Value (String va.Value.Head)\n                                let b = Lambda ([], Conditional(v, v, ItemSet(Global [top], vn, Application(e, [], NonPure, Some 0))))\n                                comp.AddGeneratedCode(gm, b)\n                                Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                         ), args)\n                        ||> List.fold (fun k t es ->\n                            encode t >>= fun e -> k ((t, e) :: es))\n                        <| []\n                | ConcreteType _ -> failwith \"impossible\"\n                | FSharpFuncType _ -> \n                    fail (name + \": Cannot de/serialize a function value.\")\n                | ByRefType _ ->\n                    fail (name + \": Cannot de/serialize a byref value.\")\n                | LocalTypeParameter\n                | StaticTypeParameter _ \n                | TypeParameter _ ->\n                    generic t\n            // Encode a type that might be recursively defined\n            and encRecType t targs args =\n                let td = t.TypeDefinition\n                match comp.GetCustomTypeInfo td with\n                | M.EnumInfo _ -> ok ident\n                | M.FSharpRecordInfo fields ->\n                    let fieldEncoders =\n                        fields\n                        |> List.map (fun f ->\n                            if Option.isSome f.DateTimeFormat then\n                                warn (sprintf \"Warning: This record field has a custom DateTime format: %s.%s. \\\n                                    Client-side JSON serialization does not support custom DateTime formatting. \\\n                                    This field will be serialized using ISO format.\"\n                                    f.RecordFieldType.TypeDefinition.Value.FullName f.Name)\n                            let t, optionKind =\n                                match f.RecordFieldType with\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                    if f.Optional then p, OptionalFieldKind.MarkedOption\n                                    else p, OptionalFieldKind.NormalOption\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                    p, OptionalFieldKind.ErasedOption\n                                | t ->    \n                                    t, OptionalFieldKind.NotOption\n                            f.JSName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                        )  \n                    let pr =\n                        match comp.GetClassInfo td with\n                        | Some cls -> \n                            addTypeDep td \n                            if cls.HasWSPrototype then\n                                GlobalAccess cls.Address.Value\n                            else Undefined\n                        | _ -> Undefined\n                    if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                        fo <> OptionalFieldKind.NormalOption && isIdent fe\n                    )\n                    then ok ident\n                    else\n                        ((fun es ->\n                            let es, tts = List.unzip es\n                            ok (call \"Record\" [pr; NewArray es])\n                            ), fieldEncoders)\n                        ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                fe >>= fun e ->\n                                k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                        <| []\n                // TODO: handle nested case type (possible when using from C#)\n                | M.FSharpUnionInfo u ->\n                    let tryGetInlinableRecordInfo (uci: M.FSharpUnionCaseInfo) =\n                        match uci.Kind with \n                        | M.NormalFSharpUnionCase [f] when f.Name = \"Item\" ->\n                            let rec inl uft =\n                                match uft with\n                                | ConcreteType { Entity = fTd } as ft ->\n                                    match comp.GetCustomTypeInfo fTd with\n                                    | M.FSharpRecordInfo fRec -> Some (ft, fRec)\n                                    | _ -> None\n                                | TypeParameter i -> inl (targs.[i])\n                                | _ -> None\n                            inl f.UnionFieldType\n                        | _ -> None\n                    let isOption (t: Type) =\n                        match t with\n                        | ConcreteType { Entity = e } ->\n                            e.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\"\n                        | _ -> false\n                    let discr =\n                        match u.NamedUnionCases with\n                        | None -> JI.StandardField\n                        | Some None -> \n                            let allCases =\n                                u.Cases |> Seq.mapi (fun i uci ->\n                                    i,\n                                    match tryGetInlinableRecordInfo uci with\n                                    | Some (_, fRec) ->\n                                        fRec |> Seq.filter (fun rf -> not (isOption rf.RecordFieldType))\n                                        |> Seq.map (fun rf -> rf.JSName) |> Set.ofSeq\n                                    | None ->\n                                        match uci.Kind with \n                                        | M.NormalFSharpUnionCase fs ->\n                                            fs\n                                            |> List.choose (fun f ->\n                                                if isOption f.UnionFieldType then None else Some f.Name)\n                                            |> Set.ofList\n                                        | _ -> Set.empty\n                                )\n                                |> Map.ofSeq\n                            let findDistinguishingCase (cases: Map<int, Set<string>>) =\n                                cases\n                                |> Map.tryPick (fun t fs ->\n                                    let allOtherFields =\n                                        allCases\n                                        |> Seq.choose (fun (KeyValue(t', fs)) ->\n                                            if t = t' then None else Some fs)\n                                        |> Set.unionMany\n                                    let uniqueCases = fs - allOtherFields\n                                    if Set.isEmpty uniqueCases then\n                                        None\n                                    else Some (Seq.head uniqueCases, t)\n                                )\n                            let rec buildTable acc cases =\n                                if Map.isEmpty cases then acc else\n                                match findDistinguishingCase cases with\n                                | None -> failwithf \"No decoder for %s\" t.AssemblyQualifiedName\n                                | Some (name, tag) ->\n                                    buildTable\n                                        <| (name, tag) :: acc\n                                        <| Map.remove tag cases\n                            buildTable [] allCases |> JI.NoField\n                        | Some (Some n) -> JI.NamedField n\n                    let cases = u.Cases\n                    ((0, fun cases ->\n                        let cases = NewArray cases\n                        let discr =\n                            match discr with\n                            | JI.NoField discrFields ->\n                                discrFields\n                                |> List.map (fun (name, id) -> name, cInt id)\n                                |> Object\n                            | JI.StandardField -> cString \"$\"\n                            | JI.NamedField n -> cString n\n                        let tn =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td\n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else\n                                    Undefined\n                            | _ -> Undefined\n                        ok (call \"Union\" [tn; discr; cases])\n                        ), cases)\n                    ||> List.fold (fun (i, k) case ->\n                        i + 1, fun es ->\n                            match tryGetInlinableRecordInfo case with\n                            | Some (ft, _) -> \n                                let tag =\n                                    match discr with\n                                    | JI.StandardField -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                let encF = encode ft \n                                let elimTag =\n                                    if isIdent encF then !~(Bool true) else !~Null\n                                encF >>= fun e ->\n                                k (NewArray [tag; NewArray [NewArray [!~Null; elimTag; e]]] :: es)\n                            | _ ->\n                            match case.Kind with\n                            | M.NormalFSharpUnionCase fields ->\n                                ((0, fun argNames ->\n                                    let tag =\n                                        match u.NamedUnionCases with\n                                        | None -> cInt i\n                                        | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                    k (NewArray [tag; NewArray argNames] :: es)\n                                    ), fields)\n                                ||> List.fold (fun (j, k) f -> //(argName, argT, argFlags) ->\n                                    if Option.isSome f.DateTimeFormat then\n                                        warn (sprintf \"Warning: This union case field has a custom DateTime format: %s.%s [%s]. \\\n                                            Client-side JSON serialization does not support custom DateTime formatting. \\\n                                            This field will be serialized using ISO format.\"\n                                            f.UnionFieldType.TypeDefinition.Value.FullName case.Name f.Name)\n                                    let argT, optionKind =\n                                        match f.UnionFieldType with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            p, cInt (int OptionalFieldKind.NormalOption)\n                                        | t ->    \n                                            t, cInt (int OptionalFieldKind.NotOption)\n                                    j + 1, fun es ->\n                                        encode (argT.SubstituteGenerics (Array.ofList targs)) >>= fun e ->\n                                        k (NewArray [cString (\"$\" + string j); cString f.Name; e; optionKind] :: es))\n                                |> snd\n                                <| []\n                            | M.SingletonFSharpUnionCase ->\n                                let tag =\n                                    match u.NamedUnionCases with\n                                    | None -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                k (NewArray [tag; NewArray []] :: es)\n                            | M.ConstantFSharpUnionCase _ -> k (!~Null :: es)\n                    )\n                    |> snd\n                    <| []\n                | _ -> \n                    match comp.GetClassInfo td with\n                    | Some cls ->\n                        let fieldEncoders =\n                            cls.Fields.Values\n                            |> Seq.choose (fun (f, _, ft) ->\n                                let jsNameTypeAndOption =\n                                    let isOption name isMarked =\n                                        match ft with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            if isMarked then\n                                                Some (name, p, OptionalFieldKind.MarkedOption) \n                                            else\n                                                Some (name, p, OptionalFieldKind.NormalOption) \n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                            Some (name, p, OptionalFieldKind.ErasedOption) \n                                        | ft ->    \n                                            Some (name, ft, OptionalFieldKind.NotOption)\n                                    match f with\n                                    | M.InstanceField n -> isOption n false\n                                    | M.IndexedField i -> isOption (string i) false\n                                    | M.OptionalField n -> isOption n true\n                                    | M.StaticField _ -> None\n                                jsNameTypeAndOption |> Option.map (fun (jsName, t, optionKind) ->\n                                    jsName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                                )\n                            ) |> List.ofSeq\n                        let pr =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td \n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else Undefined\n                            | _ -> Undefined\n                        if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                            fo <> OptionalFieldKind.NormalOption && isIdent fe\n                        )\n                        then ok ident\n                        else\n                            ((fun es ->\n                                let es, tts = List.unzip es\n                                ok (call \"Record\" [pr; NewArray es])\n                                ), fieldEncoders)\n                            ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                    fe >>= fun e ->\n                                    k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                            <| []\n                    | _ ->\n                        fail (name + \": Type not supported: \" + t.TypeDefinition.Value.FullName)\n            encode t\n\n        let encodeLambda name param t =\n            getEncoding name true param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let encode name param t arg =\n            encodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n        let decodeLambda name param t =\n            getEncoding name false param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let decode name param t arg =\n            decodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n    let Encode param t arg =\n        // ENCODE()(arg)\n        encode \"Encode\" param t arg\n\n    let EncodeLambda warn t =\n        // ENCODE()\n        encodeLambda \"EncodeLambda\" warn t\n\n    let Serialize param t arg =\n        // JSON.stringify(ENCODE()(arg))\n        encode \"Serialize\" param t arg\n        |> mapOk (fun x -> mJson param.Compilation \"Stringify\" [x])\n\n    let SerializeLambda param t =\n        encodeLambda \"SerializeLambda\" param t\n        |> mapOk (fun x ->\n            let enc = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let enc = ENCODE() in fun arg -> JSON.stringify(enc(arg))\n            Let(enc, x,\n                Lambda([arg],\n                    mJson param.Compilation \"Stringify\" [Application(Var enc, [Var arg], Pure, Some 1)])))\n\n    let Decode param t arg =\n        // DECODE()(arg)\n        decode \"Decode\" param t arg\n\n    let DecodeLambda param t =\n        // DECODE()\n        decodeLambda \"DecodeLambda\" param t\n\n    let Deserialize param t arg =\n        // DECODE()(JSON.parse(arg))\n        decode \"Deserialize\" param t (mJson param.Compilation \"Parse\" [arg])\n\n    let DeserializeLambda param t =\n        decodeLambda \"DeserializeLambda\" param t\n        |> mapOk (fun x ->\n            let dec = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let dec = DECODE() in fun arg -> dec(JSON.parse(arg))\n            Let(dec, x,\n                Lambda([arg],\n                    Application(Var dec, [mJson param.Compilation \"Parse\" [Var arg]], Pure, Some 1))))\n\n    type SerializeMacro() =\n        inherit WebSharper.Core.Macro()\n\n        static let rec last = function\n            | [x] -> x\n            | x :: l -> last l\n            | _ -> failwith \"\"\n\n        override this.TranslateCall(c) =\n            let f =\n                match c.Method.Entity.Value.MethodName with\n                | \"Encode\" -> Encode\n                | \"Decode\" -> Decode\n                | \"Serialize\" -> Serialize\n                | \"Deserialize\" -> Deserialize\n                | _ -> failwith \"Invalid macro invocation\"\n            let param = \n                {\n                    Compilation = c.Compilation\n                    Warnings = ResizeArray()\n                    Dependencies = ResizeArray()\n                }\n            let res =\n                match f param c.Method.Generics.Head (last c.Arguments) with\n                | Choice1Of3 x -> WebSharper.Core.MacroOk x\n                | Choice2Of3 e -> WebSharper.Core.MacroError e\n                | Choice3Of3 t -> WebSharper.Core.MacroNeedsResolvedTypeArg t\n            let resWithWarnings =\n                if param.Warnings.Count > 0 then\n                    param.Warnings |> Seq.fold (fun res msg -> \n                        WebSharper.Core.MacroWarning (msg, res)) res\n                else res\n            if param.Dependencies.Count > 0 then\n                WebSharper.Core.MacroDependencies (List.ofSeq param.Dependencies, resWithWarnings)\n            else resWithWarnings    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Web\n\nopen WebSharper\nopen WebSharper.Core\n\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require (t: System.Type, [<System.ParamArray>] parameters: obj[]) =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    let t = AST.Reflection.ReadTypeDefinition t\n    let req = \n        [M.ResourceNode (t, \n            if parameters.Length = 0 then None else Some(M.ParameterObject.OfObj parameters))]\n\n    interface INode with\n        member this.Write(_, _) = ()\n        member this.IsAttribute = false\n\n    interface IRequiresResources with\n        member this.Encode(_, _) = []\n        member this.Requires(_) = req :> _\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(None, this, Shared.Metadata, Shared.Json)\n\n    override this.Render _ = ()\n#endif\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require<'T when 'T :> Resources.IResource>() =\n    inherit Require(typeof<'T>)\n\n/// A base class for defining custom ASP.NET controls. Inherit from this class,\n/// override the Body property and use the new class as a Server ASP.NET\n/// control in your application.\n[<AbstractClass>]\ntype Control() =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    static let gen = System.Random()\n    [<System.NonSerialized>]\n    let mutable id = System.String.Format(\"ws{0:x}\", gen.Next().ToString())\n\n#if NET461 // ASP.NET: Control\n    override this.ID\n#else\n    member this.ID\n#endif\n        with get () = id\n        and set x = id <- x\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(Some id, this, Shared.Metadata, Shared.Json)\n#endif\n\n    interface INode with\n        member this.IsAttribute = false\n        member this.Write (_, w) =\n            w.Write(\"\"\"<div id=\"{0}\"></div>\"\"\", this.ID)\n\n    [<JavaScript>]\n    abstract member Body : IControlBody\n\n    interface IControl with\n        [<JavaScript>]\n        member this.Body = this.Body\n        member this.Id = this.ID\n\n    member this.GetBodyNode() =\n        let t = this.GetType()\n        let t = if t.IsGenericType then t.GetGenericTypeDefinition() else t\n        let m = t.GetProperty(\"Body\").GetGetMethod()\n        M.MethodNode (R.ReadTypeDefinition t, R.ReadMethod m)\n\n    interface IRequiresResources with\n        member this.Requires(_) =\n            this.GetBodyNode() |> Seq.singleton\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n#if NET461 // ASP.NET: Control\n    override this.Render writer =\n#else\n    member this.Render (writer: WebSharper.Core.Resources.HtmlTextWriter) =\n#endif\n        writer.WriteLine(\"<div id='{0}'></div>\", this.ID)\n\nopen WebSharper.JavaScript\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\n\nmodule ClientSideInternals =\n\n    module M = WebSharper.Core.Metadata\n    module R = WebSharper.Core.AST.Reflection\n    module J = WebSharper.Core.Json\n    module P = FSharp.Quotations.Patterns\n\n    let getLocation' (q: Expr) =\n        let (|Val|_|) e : 't option =\n            match e with\n            | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n            | _ -> None\n        let l =\n            q.CustomAttributes |> Seq.tryPick (function\n                | NewTuple [ Val \"DebugRange\";\n                             NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                    Some (sprintf \"%s: %i.%i-%i.%i\" file startLine startCol endLine endCol)\n                | _ -> None)\n        defaultArg l \"(no location)\"\n\n    let (|Val|_|) e : 't option =\n        match e with\n        | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n        | _ -> None\n\n    let getLocation (q: Expr) =\n        q.CustomAttributes |> Seq.tryPick (function\n            | P.NewTuple [ Val \"DebugRange\";\n                           P.NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                ({\n                    FileName = System.IO.Path.GetFileName(file)\n                    Start = (startLine, startCol)\n                    End = (endLine, endCol)\n                } : WebSharper.Core.AST.SourcePos)\n                |> Some\n            | _ -> None)\n\n    let rec findArgs (env: Set<string>) (setArg: string -> obj -> unit) (q: Expr) =\n        match q with\n        | P.ValueWithName (v, _, n) when not (env.Contains n) -> setArg n v\n        | P.AddressOf q\n        | P.Coerce (q, _)\n        | P.FieldGet (Some q, _)\n        | P.QuoteRaw q\n        | P.QuoteTyped q\n        | P.VarSet (_, q)\n        | P.WithValue (_, _, q)\n        | P.TupleGet (q, _)\n        | P.TypeTest (q, _)\n        | P.UnionCaseTest (q, _)\n            -> findArgs env setArg q\n        | P.AddressSet (q1, q2)\n        | P.Application (q1, q2)\n        | P.Sequential (q1, q2)\n        | P.TryFinally (q1, q2)\n        | P.WhileLoop (q1, q2)\n            -> findArgs env setArg q1; findArgs env setArg q2\n        | P.PropertyGet (q, _, qs)\n        | P.Call (q, _, qs) ->\n            Option.iter (findArgs env setArg) q\n            List.iter (findArgs env setArg) qs\n        | P.FieldSet (q1, _, q2) ->\n            Option.iter (findArgs env setArg) q1; findArgs env setArg q2\n        | P.ForIntegerRangeLoop (v, q1, q2, q3) ->\n            findArgs env setArg q1\n            findArgs env setArg q2\n            findArgs (Set.add v.Name env) setArg q3\n        | P.IfThenElse (q1, q2, q3)\n            -> findArgs env setArg q1; findArgs env setArg q2; findArgs env setArg q3\n        | P.Lambda (v, q) ->\n            findArgs (Set.add v.Name env) setArg q\n        | P.Let (v, q1, q2) ->\n            findArgs env setArg q1\n            findArgs (Set.add v.Name env) setArg q2\n        | P.LetRecursive (vqs, q) ->\n            let vs, qs = List.unzip vqs\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q\n        | P.NewObject (_, qs)\n        | P.NewRecord (_, qs)\n        | P.NewTuple qs\n        | P.NewUnionCase (_, qs)\n        | P.NewArray (_, qs) ->\n            List.iter (findArgs env setArg) qs\n        | P.NewDelegate (_, vs, q) ->\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            findArgs env setArg q\n        | P.PropertySet (q1, _, qs, q2) ->\n            Option.iter (findArgs env setArg) q1\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q2\n        | P.TryWith (q, v1, q1, v2, q2) ->\n            findArgs env setArg q\n            findArgs (Set.add v1.Name env) setArg q1\n            findArgs (Set.add v2.Name env) setArg q2\n        | _ -> ()\n    \n    let internal compileClientSide (meta: M.Info) (reqs: list<M.Node>) (q: Expr) : (obj[] * _) =\n        let rec compile (reqs: list<M.Node>) (q: Expr) =\n            match getLocation q with\n            | Some p ->\n                match meta.Quotations.TryGetValue(p) with\n                | false, _ ->\n                    let ex =\n                        meta.Quotations.Keys\n                        |> Seq.map (sprintf \"  %O\")\n                        |> String.concat \"\\n\"\n                    failwithf \"Failed to find compiled quotation at position %O\\nExisting ones:\\n%s\" p ex\n                | true, (declType, meth, argNames) ->\n                    match meta.Classes.TryGetValue declType with\n                    | false, _ -> failwithf \"Error in ClientSide: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                    | true, c ->\n                        let argIndices = Map (argNames |> List.mapi (fun i x -> x, i))\n                        let args = Array.create argNames.Length null\n                        let reqs = ref (M.MethodNode (declType, meth) :: M.TypeNode declType :: reqs)\n                        let setArg (name: string) (value: obj) =\n                            let i = argIndices.[name]\n                            if isNull args.[i] then\n                                args.[i] <-\n                                    match value with\n                                    | :? Expr as q ->\n                                        failwith \"Error in ClientSide: Spliced expressions are not allowed in InlineControl\"\n                                    | value ->\n                                        let typ = value.GetType ()\n                                        reqs := M.TypeNode (WebSharper.Core.AST.Reflection.ReadTypeDefinition typ) :: !reqs\n                                        value\n                        if not (List.isEmpty argNames) then\n                            findArgs Set.empty setArg q\n                        args, !reqs\n            | None -> failwithf \"Failed to find location of quotation: %A\" q\n        compile reqs q \n\n    type private FSV = Reflection.FSharpValue\n\n    let internal compileClientSideFallback (elt: Expr) = \n        let declType, meth, args, fReqs, subs =\n            let elt =\n                match elt with\n                | Coerce (e, _) -> e\n                | e -> e\n            let rec get subs expr =\n                match expr with\n                | PropertyGet(None, p, args) ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Call(None, m, args) ->\n                    let dt = R.ReadTypeDefinition m.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Let(var, value, body) ->\n                    get (subs |> Map.add var value) body\n                | e -> failwithf \"Wrong format for InlineControl at %s: expected global value or function access, got: %A\" (getLocation' elt) e\n            get Map.empty elt\n        let args, argReqs =\n            args\n            |> List.mapi (fun i value ->\n                let rec get expr =\n                    match expr with\n                    | Value (v, t) ->\n                        let v = match v with null -> WebSharper.Core.Json.Internal.MakeTypedNull t | _ -> v\n                        v, M.TypeNode (R.ReadTypeDefinition t)\n                    | TupleGet(v, i) ->\n                        let v, n = get v\n                        FSV.GetTupleField(v, i), n\n                    | Var v when subs.ContainsKey v ->\n                        get subs.[v]   \n                    | _ -> failwithf \"Wrong format for InlineControl at %s: argument #%i is not a literal or a local variable\" (getLocation' elt) (i+1)\n                get value\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        args, declType, meth, fReqs @ argReqs\n\nopen ClientSideInternals\n\n/// Implements a web control based on a quotation-wrapped top-level body.\n/// Use the function ClientSide or ctx.ClientSide to create an InlineControl.\n[<CompiledName \"FSharpInlineControl\">]\ntype InlineControl<'T when 'T :> IControlBody>(elt: Expr<'T>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    let mutable args = [||]\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Requires(meta) =\n            let declType, meth, reqs =\n                match getLocation elt with\n                | None -> failwith \"Failed to find location of quotation\"\n                | Some p ->\n                    match meta.Quotations.TryGetValue p with\n                    | true, (ty, m, _) ->\n                        let argVals, deps = compileClientSide meta [] elt\n                        args <- argVals\n                        ty, m, deps\n                    | false, _ ->\n                        let argVals, ty, m, deps = compileClientSideFallback elt\n                        args <- argVals\n                        ty, m, deps\n\n            // set funcName\n            let fail() =\n                failwithf \"Error in InlineControl at %s: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the assembly needs to be compiled with WsFsc.exe\" \n                    (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n            match meta.Classes.TryFind declType with\n            | None -> fail()\n            | Some cls ->\n                match cls.Methods.TryFind meth with\n                | Some (M.Static a, _, _) ->\n                    funcName <- Array.ofList (List.rev a.Value)\n                | Some _ ->\n                    failwithf \"Error in InlineControl at %s: Method %s.%s must be static and not inlined\"\n                        (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n                | None -> fail()\n\n            this.GetBodyNode() :: reqs |> Seq.ofList\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n\nopen System\nopen System.Reflection\nopen System.Linq.Expressions\n\n// TODO: test in arguments: needs .NET 4.5\n// open System.Runtime.CompilerServices\n//[<CallerFilePath; Optional>] sourceFilePath \n//[<CallerLineNumber; Optional>] sourceLineNumber\n[<CompiledName \"InlineControl\">]\ntype CSharpInlineControl(elt: System.Linq.Expressions.Expression<Func<IControlBody>>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    static let ctrlReq = M.TypeNode (R.ReadTypeDefinition typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let reduce (e: Expression) = if e.CanReduce then e.Reduce() else e\n        let declType, meth, args, fReqs =\n            match reduce elt.Body with\n            | :? MemberExpression as e ->\n                match e.Member with\n                | :? PropertyInfo as p ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, [], [M.MethodNode (dt, meth)]\n                | _ -> failwith \"member must be a property\"\n            | :? MethodCallExpression as e -> \n                let m = e.Method\n                let dt = R.ReadTypeDefinition m.DeclaringType\n                let meth = R.ReadMethod m\n                dt, meth, e.Arguments |> List.ofSeq, [M.MethodNode (dt, meth)]\n            | e -> failwithf \"Wrong format for InlineControl: expected global value or function access, got: %A\"  e\n        let args, argReqs =\n            args\n            |> List.mapi (fun i a -> \n                let rec get needType (a: Expression) =\n                    match reduce a with\n                    | :? ConstantExpression as e ->\n                        let v = match e.Value with null -> WebSharper.Core.Json.Internal.MakeTypedNull e.Type | _ -> e.Value\n                        v, if needType then M.TypeNode (R.ReadTypeDefinition e.Type) else M.EntryPointNode\n                    | :? MemberExpression as e ->\n                        let o = \n                            match e.Expression with\n                            | null -> null\n                            | ee -> fst (get false ee)\n                        match e.Member with\n                        | :? FieldInfo as f ->\n                            f.GetValue(o), if needType then M.TypeNode (R.ReadTypeDefinition f.FieldType) else M.EntryPointNode\n                        | :? PropertyInfo as p ->\n                            if p.GetIndexParameters().Length > 0 then\n                                failwithf \"Wrong format for InlineControl in argument #%i, indexed property not allowed\" (i+1)\n                            p.GetValue(o, null), if needType then M.TypeNode (R.ReadTypeDefinition p.PropertyType) else M.EntryPointNode\n                        | m -> failwithf \"Wrong format for InlineControl in argument #%i, member access not allowed: %s\" (i+1) (m.GetType().Name)\n                    | a -> failwithf \"Wrong format for InlineControl in argument #%i, expression type: %s\" (i+1) (a.GetType().Name)\n                get true a\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs\n        args, (declType, meth, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, meth, reqs = snd bodyAndReqs\n                let fail() =\n                    failwithf \"Error in InlineControl: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the project file needs to include WebSharper.CSharp.targets\" \n                        declType.Value.FullName meth.Value.MethodName\n                match meta.Classes.TryFind declType with\n                | None -> fail()\n                | Some cls ->\n                    match cls.Methods.TryFind meth with\n                    | Some (M.Static a, _, _) ->\n                        funcName <- Array.ofList (List.rev a.Value)\n                    | Some _ -> \n                        failwithf \"Error in InlineControl: Method %s.%s must be static and not inlined\"\n                            declType.Value.FullName meth.Value.MethodName\n                    | None -> fail()\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n        member this.Requires(_) =\n            let _, _, reqs = snd bodyAndReqs \n            this.GetBodyNode() :: reqs |> Seq.ofList\n\nnamespace WebSharper\n\n[<AutoOpen>]\nmodule WebExtensions =\n\n    open Microsoft.FSharp.Quotations\n    open WebSharper.Web\n\n    /// Embed the given client-side control body in a server-side control.\n    /// The client-side control body must be an implicit or explicit quotation expression.\n    /// It can capture local variables, of the same types which are serializable by WebSharper as RPC results.\n    let ClientSide ([<JavaScript; ReflectedDefinition>] e: Expr<#IControlBody>) =\n        new InlineControl<_>(e)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Sitelets\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen System.Collections.Generic\nopen System.Text\n\n#nowarn \"64\" // type parameter renaming warnings \n\n[<NamedUnionCases \"result\"; RequireQualifiedAccess>]\ntype ParseRequestResult<'T> =\n    | [<CompiledName \"success\">]\n      Success of endpoint: 'T\n    | [<CompiledName \"invalidMethod\">]\n      InvalidMethod of endpoint: 'T * ``method``: string\n    | [<CompiledName \"invalidJson\">]\n      InvalidJson of endpoint: 'T\n    | [<CompiledName \"missingQueryParameter\">]\n      MissingQueryParameter of endpoint: 'T * queryParam: string\n    | [<CompiledName \"missingFormData\">]\n      MissingFormData of endpoint: 'T * formFieldName: string\n\n    member this.Value =\n        match this with\n        | Success a\n        | InvalidMethod (a, _)\n        | InvalidJson a\n        | MissingQueryParameter (a, _)\n        | MissingFormData (a, _) -> a\n\n    [<System.Obsolete \"Use Value instead\">]\n    member this.Action = this.Value\n\n[<System.Obsolete \"Use ParseRequestResult instead of ActionEncoding.DecodeResult\">]\n/// For back-compatibility only, use ParseRequestResult instead of ActionEncoding.DecodeResult\nmodule ActionEncoding =\n\n    type DecodeResult<'T> = ParseRequestResult<'T>\n\n    let Success endpoint = ParseRequestResult.Success endpoint\n    let InvalidMethod (endpoint, ``method``) = ParseRequestResult.InvalidMethod(endpoint, ``method``)\n    let InvalidJson endpoint = ParseRequestResult.InvalidJson endpoint\n    let MissingQueryParameter (endpoint, queryParam) = ParseRequestResult.MissingQueryParameter(endpoint, queryParam)\n    let MissingFormData (endpoint, formFieldName) = ParseRequestResult.MissingFormData(endpoint, formFieldName)\n\nmodule StringEncoding =\n\n    [<JavaScript>]\n    let isUnreserved isLast c =\n        match c with\n        | '-' | '_' -> true\n        | '.' -> not isLast\n        | c when c >= 'A' && c <= 'Z' -> true\n        | c when c >= 'a' && c <= 'z' -> true\n        | c when c >= '0' && c <= '9' -> true\n        | _ -> false\n    \n    let writeEscaped (w: System.Text.StringBuilder) isLast c =\n        let k = int c\n        if isUnreserved isLast c then w.Append c\n        elif k < 256 then w.AppendFormat(\"~{0:x2}\", k)\n        else w.AppendFormat(\"~u{0:x4}\", k)\n        |> ignore\n\n    [<JavaScript>]\n    let writeEscapedAsString isLast c =\n        let k = int c\n        if isUnreserved isLast c then string c\n        elif k < 256 then \"~\" + k.JS.ToString(16).PadLeft(2, '0')\n        else \"~u\" + k.JS.ToString(16).PadLeft(4, '0')\n\n    [<JavaScript>]\n    let write (s: string) = \n        if IsClient then\n            s |> Seq.mapi (fun i c ->\n                writeEscapedAsString (i + 1 = s.Length) c\n            )\n            |> String.concat \"\"\n        else\n            let b = System.Text.StringBuilder()\n            s |> Seq.iteri (fun i c ->\n                writeEscaped b (i + 1 = s.Length) c)\n            string b\n\n    [<JavaScript>]\n    let inline ( ++ ) (a: int) (b: int) = (a <<< 4) + b\n\n    [<Literal>]\n    let EOF = -1\n\n    [<Literal>]\n    let ERROR = -2\n\n    let readEscaped (r: System.IO.TextReader) =\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match r.Read() with\n        | x when x = int '~' ->\n            match r.Read() with\n            | x when x = int 'u' ->\n                let a = r.Read()\n                let b = r.Read()\n                let c = r.Read()\n                let d = r.Read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = r.Read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n\n    [<JavaScript>]\n    let readEscapedFromChars (chars: int list) =\n        let mutable chars = chars\n        let read() =\n            match chars with\n            | [] -> -1\n            | h :: t ->\n                chars <- t\n                h\n        let hex x =\n            match x with\n            | x when x >= int '0' && x <= int '9' -> x - int '0'\n            | x when x >= int 'a' && x <= int 'f' -> x - int 'a' + 10\n            | x when x >= int 'A' && x <= int 'F' -> x - int 'A' + 10\n            | _ -> ERROR\n        match read() with\n        | x when x = int '~' ->\n            match read() with\n            | x when x = int 'u' ->\n                let a = read()\n                let b = read()\n                let c = read()\n                let d = read()\n                if a >= 0 && b >= 0 && c >= 0 && d >= 0 then\n                    hex a ++ hex b ++ hex c ++ hex d\n                else ERROR\n            | x ->\n                let y = read()\n                if x >= 0 && y >= 0 then\n                    hex x ++ hex y\n                else ERROR\n        | x ->\n            x\n        , chars\n\n    [<JavaScript>]\n    let read (s: string) = \n        if IsClient then\n            let buf = ResizeArray()\n            let rec loop chars =\n                match readEscapedFromChars chars with\n                | ERROR, _ -> None\n                | EOF, _ -> Some (buf |> String.concat \"\")\n                | x, chars -> \n                    buf.Add(string (char x))\n                    loop chars\n            s |> Seq.map int |> List.ofSeq |> loop\n        else\n            let buf = System.Text.StringBuilder()\n            use i = new System.IO.StringReader(s)\n            let rec loop () =\n                match readEscaped i with\n                | ERROR -> None\n                | EOF -> Some (string buf)\n                | x -> buf.Append(char x) |> ignore; loop ()\n            loop ()\n\ntype internal PathUtil =\n    static member WriteQuery q =\n        let sb = StringBuilder 128\n        let mutable start = true\n        q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n            if start then\n                start <- false\n            else \n                sb.Append('&') |> ignore                    \n            sb.Append(k).Append('=').Append(v) |> ignore\n        )\n        sb.ToString()\n\n    static member WriteLink s q =\n        let sb = StringBuilder 128\n        if List.isEmpty s then\n            sb.Append('/') |> ignore\n        else\n            s |> List.iter (fun x ->\n                if not (System.String.IsNullOrEmpty x) then\n                    sb.Append('/').Append(x) |> ignore\n            )\n        if Map.isEmpty q then () \n        else \n            let mutable start = true\n            sb.Append('?') |> ignore                    \n            q |> Map.toSeq |> Seq.iter (fun (k: string, v: string) ->\n                if start then\n                    start <- false\n                else \n                    sb.Append('&') |> ignore                    \n                sb.Append(k).Append('=').Append(v) |> ignore\n            )\n        sb.ToString()\n\n[<Proxy(typeof<PathUtil>)>]\ntype internal PathUtilProxy =\n    static member Concat xs = \n        let sb = System.Collections.Generic.Queue()\n        let mutable start = true\n        xs |> List.iter (fun x ->\n            if not (System.String.IsNullOrEmpty x) then\n                if start then\n                    start <- false\n                else \n                    sb.Enqueue(\"/\") |> ignore                    \n                sb.Enqueue(x) |> ignore\n        )\n        sb |> System.String.Concat\n\n    static member WriteQuery q =\n        q |> Map.toSeq |> Seq.map (fun (k, v) -> k + \"=\" + v) |> String.concat \"&\"\n\n    static member WriteLink s q =\n        let query = \n            if Map.isEmpty q then \"\" \n            else \"?\" + PathUtil.WriteQuery(q)\n        \"/\" + PathUtilProxy.Concat s + query\n\n[<JavaScript>]\ntype Route =\n    {\n        Segments : list<string>\n        QueryArgs : Map<string, string>\n        FormData : Map<string, string>\n        Method : option<string> \n        Body : Lazy<string>\n    }\n\n    static member Empty =\n        {\n            Segments = []\n            QueryArgs = Map.empty\n            FormData = Map.empty\n            Method = None\n            Body = Lazy.CreateFromValue null\n        }\n    \n    static member Segment s =\n        { Route.Empty with\n            Segments = [ s ]\n        }\n\n    static member Segment s =\n        { Route.Empty with\n            Segments = s\n        }\n\n    static member Segment (s, m) =\n        { Route.Empty with\n            Segments = s\n            Method = m\n        }\n\n    static member Combine (paths: seq<Route>) =\n        let paths = Seq.toArray paths\n        match paths.Length with\n        | 1 -> paths.[0]\n        | 0 -> Route.Empty\n        | _ ->\n        let mutable method = None\n        let mutable body = null\n        let segments = System.Collections.Generic.Queue()\n        let mutable queryArgs = Map.empty\n        let mutable formData = Map.empty\n        let mutable i = 0\n        let l = paths.Length\n        while i < l do\n            let p = paths.[i]\n            match p.Method with\n            | Some _ as m ->\n                method <- m\n            | _ -> ()\n            match p.Body.Value with\n            | null -> ()\n            | b ->\n                body <- b\n            queryArgs <- p.QueryArgs |> Map.foldBack Map.add queryArgs \n            formData <- p.FormData |> Map.foldBack Map.add formData \n            p.Segments |> List.iter segments.Enqueue\n            i <- i + 1\n        {\n            Segments = List.ofSeq segments\n            QueryArgs = queryArgs\n            FormData = formData\n            Method = method\n            Body = Lazy.CreateFromValue body\n        }\n\n    static member ParseQuery(q: string) =\n        q.Split('&') |> Array.choose (fun kv ->\n            match kv.Split('=') with\n            | [| k; v |] -> Some (k, v)\n            | _ -> \n                printfn \"wrong format for query argument: %s\" kv\n                None\n        ) |> Map.ofSeq\n    \n    static member WriteQuery(q) = PathUtil.WriteQuery q\n\n    static member FromUrl(path: string, ?strict: bool) =\n        let s, q = \n            match path.IndexOf '?' with\n            | -1 -> path, Map.empty\n            | i -> \n                path.Substring(0, i),\n                path.Substring(i + 1) |> Route.ParseQuery\n        let splitOptions =\n            if Option.isSome strict && strict.Value then \n                System.StringSplitOptions.None\n            else\n                System.StringSplitOptions.RemoveEmptyEntries\n        { Route.Empty with\n            Segments = \n                s.Split([| '/' |], splitOptions) |> List.ofArray\n            QueryArgs = q\n        }\n\n    [<JavaScript false>]\n    static member FromRequest(r: Http.Request) =\n        let u = r.Uri\n        let p =\n            if u.IsAbsoluteUri then \n                u.AbsolutePath \n            else \n                let s = u.OriginalString\n                match s.IndexOf('?') with\n                | -1 -> s\n                | q -> s.Substring(0, q)\n        {\n            Segments = p.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries) |> List.ofArray\n            QueryArgs = r.Get.ToList() |> Map.ofList\n            FormData = r.Post.ToList() |> Map.ofList\n            Method = Some (r.Method.ToString())\n            Body = lazy r.BodyText\n        }\n\n    static member FromHash(path: string, ?strict: bool) =\n        match path.IndexOf \"#\" with\n        | -1 -> Route.Empty\n        | i -> \n            let h = path.Substring(i + 1)\n            if Option.isSome strict && strict.Value then \n                if h = \"\" || h = \"/\" then\n                    Route.Empty\n                elif h.StartsWith \"/\" then\n                    Route.FromUrl(h.Substring(1), true)\n                else\n                    Route.Segment(h)                    \n            else\n                Route.FromUrl(path.Substring(i), false)\n\n    member this.ToLink() = PathUtil.WriteLink this.Segments this.QueryArgs\n\n[<JavaScript>]\nmodule internal List =\n    let rec startsWith s l =\n        match s, l with\n        | [], _ -> Some l\n        | sh :: sr, lh :: lr when sh = lh -> startsWith sr lr\n        | _ -> None\n\ntype IRouter<'T> =\n    abstract Route : Http.Request -> option<'T>\n    abstract Link : 'T -> option<System.Uri>\n\n[<JavaScript>]\ntype Router =\n    {\n        Parse : Route -> Route seq\n        Segment : seq<Route> \n    }\n    \n    static member FromString (name: string) =\n        let parts = name.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton path\n                Segment = Seq.empty\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p })\n                    | _ -> Seq.empty\n                Segment = \n                    Seq.singleton (Route.Segment parts)\n            }\n\n    static member (/) (before: Router, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Segment = \n                Seq.append before.Segment after.Segment\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router, b: Router) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Segment = a.Segment\n        }\n\n    [<Inline>]\n    static member Combine<'A, 'B when 'A: equality and 'B: equality>(a: Router<'A>, b: Router<'B>) : Router<'A * 'B> =\n        a / b\n\nand [<JavaScript>] Router<'T when 'T: equality> =\n    {\n        Parse : Route -> (Route * 'T) seq\n        Write : 'T -> option<seq<Route>> \n    }\n    \n    static member (/) (before: Router<'T>, after: Router<'U>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun (p, y) -> (p, (x, y))))\n            Write = fun (v1, v2) ->\n                match before.Write v1, after.Write v2 with\n                | Some p1, Some p2 -> Some (Seq.append p1 p2)\n                | _ -> None\n        }\n\n    static member (/) (before: Router, after: Router<'T>) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect after.Parse\n            Write = fun v ->\n                after.Write v |> Option.map (Seq.append before.Segment)\n        }\n\n    static member (/) (before: Router<'T>, after: Router) =\n        {\n            Parse = fun path ->\n                before.Parse path |> Seq.collect (fun (p, x) -> after.Parse p |> Seq.map (fun p -> (p, x)))\n            Write = fun v ->\n                before.Write v |> Option.map (fun x -> Seq.append x after.Segment)\n        }\n\n    [<Inline>]\n    static member (/) (before: string, after: Router<'T>) = Router.FromString before / after\n\n    [<Inline>]\n    static member (/) (before: Router<'T>, after: string) = before / Router.FromString after\n\n    static member (+) (a: Router<'T>, b: Router<'T>) =\n        {\n            Parse = fun path ->\n                Seq.append (a.Parse path) (b.Parse path) \n            Write = fun value ->\n                match a.Write value with\n                | None -> b.Write value\n                | p -> p\n        }\n\n    interface IRouter<'T> with\n        [<JavaScript false>]\n        member this.Route req = \n            let path = Route.FromRequest req\n            this.Parse path\n            |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n        [<JavaScript false>]\n        member this.Link ep =\n            this.Write ep |> Option.map (fun p -> System.Uri((Route.Combine p).ToLink(), System.UriKind.Relative))\n        \n[<JavaScript>]\nmodule Router =\n    [<Inline>]\n    let Combine (a: Router<'A>) (b: Router<'B>) = a / b\n    \n    [<Inline>]\n    let Shift (prefix: string) (router: Router<'A>) =\n        prefix / router\n\n    let Empty<'A when 'A: equality> : Router<'A> =\n        {\n            Parse = fun _ -> Seq.empty\n            Write = fun _ -> None\n        }\n\n    /// Creates a fully customized router.\n    let New (route: Http.Request -> option<'T>) (link: 'T -> option<System.Uri>) =\n        { new IRouter<'T> with\n            member this.Route req = route req\n            member this.Link e = link e\n        }\n\n    /// Creates a router for parsing/writing a full route using URL segments.\n    let Create (ser: 'T -> list<string>) (des: list<string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des path.Segments with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment(ser value)))\n        } : Router<'T>\n\n    /// Creates a router for parsing/writing a full route using URL segments and query parameters.\n    let CreateWithQuery (ser: 'T -> list<string> * Map<string, string>) (des: list<string> * Map<string, string> -> option<'T>) =\n        {\n            Parse = fun path ->\n                match des (path.Segments, path.QueryArgs) with\n                | Some ep ->\n                    Seq.singleton ({ path with Segments = [] }, ep)\n                | None ->\n                    Seq.empty\n            Write = fun value ->\n                let s, q = ser value\n                Some (Seq.singleton { Route.Empty with Segments = s; QueryArgs = q })\n        }\n    \n    /// Parses/writes a single value from a query argument with the given key instead of url path.\n    let Query key (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.empty\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (p, v) ->\n                        { path with QueryArgs = newQa }, v\n                    )\n            Write = fun value ->\n                item.Write value |> Option.map (fun p -> \n                    let p = Route.Combine p\n                    match p.Segments with\n                    | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                    | _ -> Seq.empty\n                )\n        }\n\n    /// Parses/writes a single option value from an optional query argument with the given key instead of url path.\n    let QueryOption key (item: Router<'A>) : Router<option<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, None)\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, Some v\n                    )\n            Write = fun value ->\n                match value with\n                | None -> Some Seq.empty\n                | Some v ->\n                    item.Write v |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n        }\n\n    /// Parses/writes a single nullable value from an optional query argument with the given key instead of url path.\n    let QueryNullable key (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.QueryArgs.TryFind key with\n                | None -> Seq.singleton (path, System.Nullable())\n                | Some q -> \n                    let newQa = path.QueryArgs |> Map.remove key\n                    item.Parse { Route.Empty with Segments = [ q ] }\n                    |> Seq.map (fun (_, v) ->\n                        { path with QueryArgs = newQa }, System.Nullable v\n                    )\n            Write = fun value ->\n                if value.HasValue then\n                    item.Write value.Value |> Option.map (fun p -> \n                        let p = Route.Combine p\n                        match p.Segments with\n                        | [ v ] -> Seq.singleton { Route.Empty with QueryArgs = Map.ofList [ key, v ] }\n                        | _ -> Seq.empty\n                    )\n                else\n                    Some Seq.empty\n        }\n\n    let Method (m: string) : Router =\n        {\n            Parse = fun path ->\n                match path.Method with\n                | Some pm when pm = m -> Seq.singleton path\n                | _ -> Seq.empty\n            Segment =\n                Seq.singleton { Route.Empty with Method = Some m }\n        }\n\n    let Body (deserialize: string -> option<'A>) (serialize: 'A -> string) : Router<'A> =\n        {\n            Parse = fun path ->\n                match path.Body.Value with\n                | null -> Seq.empty\n                | x ->\n                    match deserialize x with\n                    | Some b -> Seq.singleton ({ path with Body = Lazy.CreateFromValue null}, b)\n                    | _ -> Seq.empty\n            Write = fun value ->\n                Some <| Seq.singleton { Route.Empty with Body = Lazy.CreateFromValue (serialize value) }\n        }\n\n    let FormData (item: Router<'A>) : Router<'A> =\n        {\n            Parse = fun path ->\n                item.Parse { path with QueryArgs = path.FormData }\n                |> Seq.map (fun (_, r) -> path, r)\n            Write = fun value ->\n                item.Write value\n                |> Option.map (Seq.map (fun p -> { p with QueryArgs = Map.empty; FormData = p.QueryArgs }))  \n        }\n    \n    let Parse (router: Router<'A>) path =\n        router.Parse path\n        |> Seq.tryPick (fun (path, value) -> if List.isEmpty path.Segments then Some value else None)\n\n    let Write (router: Router<'A>) endpoint =\n        router.Write endpoint |> Option.map Route.Combine \n\n    let TryLink (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> Some (p.ToLink())\n        | None -> None\n\n    let Link (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some p -> p.ToLink()\n        | None -> \"\"\n\n    let Ajax (router: Router<'A>) endpoint =\n        match Write router endpoint with\n        | Some path ->\n            let settings = AjaxSettings(DataType = DataType.Text)\n            match path.Method with\n            | Some m -> settings.Type <- As m\n            | _ -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    settings.ContentType <- Union1Of2 false\n                    settings.Data <- fd\n                    settings.ProcessData <- false\n            | b ->\n                settings.ContentType <- Union2Of2 \"application/json\"\n                settings.Data <- b\n                settings.ProcessData <- false\n            if Option.isNone path.Method then settings.Type <- RequestType.POST \n            Async.FromContinuations (fun (ok, err, cc) ->\n                settings.Success <- fun res _ _ -> ok (As<string> res) \n                settings.Error <- fun _ _ msg -> err (exn msg)\n                // todo: cancellation\n                let url = path.ToLink()\n                JQuery.Ajax(url, settings) |> ignore\n            )\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let Fetch (router: Router<'A>) endpoint : Promise<Response> =\n        match Write router endpoint with\n        | Some path ->\n            let options = RequestOptions()\n            match path.Method with\n            | Some m -> options.Method <- m\n            | None -> ()\n            match path.Body.Value with\n            | null ->\n                if not (Map.isEmpty path.FormData) then\n                    let fd = JavaScript.FormData()\n                    path.FormData |> Map.iter (fun k v -> fd.Append(k, v))\n                    options.Body <- fd\n            | b ->\n                options.Body <- b\n            if Option.isNone path.Method then options.Method <- \"POST\"\n            JS.Fetch(path.ToLink(), options)\n        | _ -> \n            failwith \"Failed to map endpoint to request\" \n\n    let HashLink (router: Router<'A>)  endpoint =\n        \"#\" + Link router endpoint\n    \n    /// Maps a router to a narrower router type. The decode function must return None if the\n    /// value can't be mapped to a value of the target.\n    let Slice (decode: 'T -> 'U option) (encode: 'U -> 'T) (router: Router<'T>) : Router<'U> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Maps a router to a wider router type. The encode function must return None if the\n    /// value can't be mapped back to a value of the source.\n    let Embed (decode: 'A -> 'B) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Maps a router with a bijection.\n    let Map (decode: 'A -> 'B) (encode: 'B -> 'A) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, decode v) \n            Write = fun value ->\n                encode value |> router.Write\n        }\n\n    /// Combination of Slice and Embed, a mapping from a subset of source values to\n    /// a subset of target values. Both encode and decode must return None if\n    /// there is no mapping to a value of the other type.\n    let TryMap (decode: 'A -> 'B option) (encode: 'B -> 'A option) router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> decode v |> Option.map (fun v -> p, v)) \n            Write = fun value ->\n                encode value |> Option.bind router.Write\n        }\n\n    /// Filters a router, only parsing/writing values that pass the predicate check.\n    let Filter predicate router =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.filter (snd >> predicate)\n            Write = fun value ->\n                if predicate value then router.Write value else None\n        }\n\n    [<Name \"Box\">]\n    let private BoxImpl tryUnbox (router: Router<'A>): Router<obj> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun (p, v) -> p, box v) \n            Write = fun value ->\n                tryUnbox value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts to Router<obj>. When writing, a type check against type A is performed.\n    let Box (router: Router<'A>): Router<obj> =\n        BoxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Inline>]\n    let Json<'T when 'T: equality> : Router<'T> =\n        Body (fun s -> try Some (Json.Deserialize<'T> s) with _ -> None) Json.Serialize<'T>\n\n    [<Name \"Unbox\">]\n    let UnboxImpl<'A when 'A: equality> tryUnbox (router: Router<obj>) : Router<'A> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryUnbox v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                box value |> router.Write\n        }\n\n    [<Inline>]\n    /// Converts from Router<obj>. When parsing, a type check against type A is performed.\n    let Unbox<'A when 'A: equality> (router: Router<obj>) : Router<'A> =\n        UnboxImpl (function :? 'A as v -> Some v | _ -> None) router\n\n    [<Name \"Cast\">]\n    let private CastImpl tryParseCast tryWriteCast (router: Router<'A>): Router<'B> =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.choose (fun (p, v) -> match tryParseCast v with Some v -> Some (p, v) | _ -> None) \n            Write = fun value ->\n                tryWriteCast value |> Option.bind router.Write\n        }\n\n    [<Inline>]\n    /// Converts a Router<A> to Router<B>. When parsing and writing, type checks are performed.\n    /// Upcasting do not change set of parsed routes, downcasting restricts it within the target type.\n    let Cast (router: Router<'A>): Router<'B> =\n        CastImpl (fun v -> match box v with :? 'B as v -> Some v | _ -> None) (fun v -> match box v with :? 'A as v -> Some v | _ -> None) router\n\n    /// Maps a single-valued (non-generic) Router to a specific value.\n    let MapTo value (router: Router) =\n        {\n            Parse = fun path ->\n                router.Parse path |> Seq.map (fun p -> p, value) \n            Write = fun v ->\n                if v = value then Some router.Segment else None\n        }\n\n    /// Parses/writes using any of the routers, attempts are made in the given order.\n    let Sum (routers: seq<Router<_>>) =\n        let routers = Array.ofSeq routers\n        {\n            Parse = fun path ->\n                routers |> Seq.collect (fun r -> r.Parse path)\n            Write = fun value ->\n                routers |> Seq.tryPick (fun r -> r.Write value)\n        }\n    \n    // todo: optimize\n    let Table<'T when 'T : equality> (mapping: seq<'T * string>) : Router<'T> =\n        mapping |> Seq.map (fun (v, s) -> Router.FromString s |> MapTo v) |> Sum \n\n    let Single<'T when 'T : equality> (endpoint: 'T) (route: string) : Router<'T> =\n        let parts = route.Split([| '/' |], System.StringSplitOptions.RemoveEmptyEntries)\n        if Array.isEmpty parts then \n            {\n                Parse = fun path -> Seq.singleton (path, endpoint)\n                Write = fun value -> if value = endpoint then Some Seq.empty else None\n            }\n        else\n            let parts = List.ofArray parts\n            {\n                Parse = fun path ->\n                    match path.Segments |> List.startsWith parts with\n                    | Some p -> \n                        Seq.singleton ({ path with Segments = p }, endpoint)\n                    | _ -> Seq.empty\n                Write = fun value ->\n                    if value = endpoint then Some (Seq.singleton (Route.Segment parts)) else None\n            }\n\n    let Delay<'T when 'T: equality> (getRouter: unit -> Router<'T>) : Router<'T> =\n        let r = lazy getRouter()\n        {\n            Parse = fun path -> r.Value.Parse path\n            Write = fun value -> r.Value.Write value\n        }\n\n    /// Creates a router for parsing/writing an Array of values.\n    let Array (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Int32.TryParse h with\n                    | true, l ->\n                        let rec collect l path acc =\n                            if l = 0 then Seq.singleton (path, Array.ofList (List.rev acc))\n                            else item.Parse path |> Seq.collect(fun (p, a) -> collect (l - 1) p (a :: acc))\n                        collect l { path with Segments = t } []\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (Seq.append (Seq.singleton (Route.Segment (string value.Length))) (parts |> Seq.collect Option.get))\n                else None                      \n        }\n\n    /// Creates a router for parsing/writing a Nullable value.\n    let Nullable (item: Router<'A>) : Router<System.Nullable<'A>> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"null\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, System.Nullable())\n                | _ ->\n                    item.Parse path |> Seq.map (fun (p, v) -> p, System.Nullable v)\n            Write = fun value ->\n                if value.HasValue then \n                    item.Write value.Value\n                else \n                    Some (Seq.singleton (Route.Segment \"null\"))\n        }\n\n    /// Creates a router for parsing/writing an F# option of a value.\n    let Option (item: Router<'A>) : Router<'A option> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | \"None\" :: p -> \n                    Seq.singleton ({ path with Segments = p }, None)\n                | \"Some\" :: p ->\n                    item.Parse { path with Segments = p } |> Seq.map (fun (p, v) -> p, Some v)\n                | _ ->\n                    Seq.empty\n            Write = fun value ->\n                match value with \n                | None -> Some (Seq.singleton (Route.Segment \"None\"))\n                | Some v -> \n                    item.Write v |> Option.map (Seq.append (Seq.singleton (Route.Segment \"Some\")))\n        }\n\n    module FArray = Collections.Array\n\n    type IListArrayConverter =\n        abstract OfArray: obj -> obj\n        abstract ToArray: obj -> obj\n\n    type ListArrayConverter<'T>() =\n        interface IListArrayConverter with\n            member this.OfArray a = List.ofArray (unbox<'T []> a) |> box\n            member this.ToArray l = List.toArray (unbox<'T list> l) |> box\n\n    /// Creates a router for parsing/writing an F# list of a value.\n    let List (item: Router<'A>) : Router<'A list> =\n        Array item |> Map List.ofArray FArray.ofList\n\ntype Router with\n    [<Inline>]\n    member this.MapTo(value: 'T) =\n        Router.MapTo value this\n\n    [<Inline>]\n    static member Sum ([<System.ParamArray>] routers: Router<'T>[]) =\n        Router.Sum routers\n\n    [<Inline>]\n    static member Empty<'T when 'T: equality>() =\n        Router.Empty<'T>\n\n    [<JavaScript false>]\n    static member New(route: System.Func<Http.Request, 'T>, link: System.Func<'T, System.Uri>) =\n        Router.New (route.Invoke >> Option.ofObj) (link.Invoke >> Option.ofObj)\n\n    [<Inline>]\n    static member Method(method:string) =\n        Router.Method method\n\n    [<Inline>]\n    static member Body(des:System.Func<string, 'T>, ser: System.Func<'T, string>) =\n        Router.Body (fun s -> des.Invoke s |> Option.ofObj) ser.Invoke \n\n    [<Inline>]\n    static member Json<'T when 'T: equality>() =\n        Router.Json<'T>\n\n    [<Inline>]\n    static member Table([<System.ParamArray>] mapping: ('T * string)[]) =\n        Router.Table mapping\n\n    [<Inline>]\n    static member Single(endpoint, route) =\n        Router.Single endpoint route\n\n    [<Inline>]\n    static member Delay(getRouter: System.Func<Router<'T>>) =\n        Router.Delay getRouter.Invoke\n\ntype Router<'T when 'T: equality> with\n\n    [<Inline>]\n    member this.Query(key: string) =\n        Router.Query key this\n\n    [<Inline>]\n    member this.Link(endpoint: 'T) =\n        Router.Link this endpoint\n\n    [<Inline>]\n    member this.TryLink(endpoint: 'T, link: byref<string>) =\n        match Router.TryLink this endpoint with\n        | Some l ->\n            link <- l\n            true\n        | _ -> false\n               \n    [<Inline>]\n    member this.HashLink(endpoint: 'T) =\n        Router.HashLink this endpoint\n\n    [<Inline>]\n    member this.Map(decode: System.Func<'T, 'U>, encode: System.Func<'U, 'T>) =\n        Router.TryMap (decode.Invoke >> ofObjNoConstraint) (encode.Invoke >> ofObjNoConstraint) this\n\n    [<Inline>]\n    member this.Filter(predicate: System.Func<'T, bool>) =\n        Router.Filter predicate.Invoke this\n\n    [<Inline>]\n    member this.Cast<'U when 'U: equality>() : Router<'U> =\n        Router.Cast this\n\n    [<Inline>]\n    member this.FormData() =\n        Router.FormData this\n\n    [<Inline>]\n    member this.Ajax(endpoint) =\n        Router.Ajax this endpoint |> Async.StartAsTask\n\n    [<Inline>]\n    member this.Box() =\n        Router.Box this\n\n    [<Inline>]\n    member this.Array() =\n        Router.Array this\n\nopen System.Runtime.CompilerServices\n    \n[<Extension>]\ntype RouterExtensions =\n    [<Inline>]\n    static member QueryNullable(router, key) =\n        Router.QueryNullable key router\n\n    [<Inline>]\n    static member Unbox<'T when 'T: equality>(router) =\n        Router.Unbox<'T> router\n\n    [<Inline>]\n    static member Nullable(router) =\n        Router.Nullable router\n\nmodule IRouter =\n    open System\n\n    let Empty : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route _ = None\n            member this.Link _ = None\n        }        \n\n    let Add (r1: IRouter<'T>) (r2: IRouter<'T>) =\n        { new IRouter<'T> with\n            member this.Route req = match r1.Route req with Some _ as l -> l | _ -> r2.Route req\n            member this.Link e = match r1.Link e with Some _ as l -> l | _ -> r2.Link e\n        }        \n\n    let Sum (routers: seq<IRouter<'T>>) : IRouter<'T> =\n        let routers = Array.ofSeq routers\n        if Seq.isEmpty routers then Empty else\n            { new IRouter<'T> with\n                member this.Route req = routers |> Array.tryPick (fun r -> r.Route req)\n                member this.Link e = routers |> Array.tryPick (fun r -> r.Link e)\n            }        \n            \n    let Map encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> router.Link\n        } \n        \n    let TryMap encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.bind encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let Embed encode decode (router: IRouter<'T>) : IRouter<'U> =\n        { new IRouter<'U> with\n            member this.Route req = router.Route req |> Option.map encode\n            member this.Link e = decode e |> Option.bind router.Link\n        } \n\n    let private makeUri uri =\n        let mutable res = null\n        if Uri.TryCreate(uri, UriKind.Relative, &res) then res else\n            Uri(uri, UriKind.Absolute)\n    \n    let private path (uri: Uri) =\n        if uri.IsAbsoluteUri\n        then uri.AbsolutePath\n        else uri.OriginalString |> joinWithSlash \"/\"\n        \n    let private trimFinalSlash (s: string) =\n        match s.TrimEnd('/') with\n        | \"\" -> \"/\"\n        | s -> s\n    \n    let Shift prefix (router: IRouter<'T>) =\n        let prefix = joinWithSlash \"/\" prefix\n        let shift (loc: System.Uri) =\n            if loc.IsAbsoluteUri then loc else\n                makeUri (joinWithSlash prefix (path loc) |> trimFinalSlash)\n        { new IRouter<'T> with\n            member this.Route req =\n                let builder = UriBuilder req.Uri\n                if builder.Path.StartsWith prefix then\n                    builder.Path <- builder.Path.Substring prefix.Length\n                    router.Route (req.WithUri(builder.Uri))\n                else\n                    None\n            member this.Link e = router.Link e |> Option.map shift\n        }     \n        \n    let Box (router: IRouter<'T>) : IRouter<obj> =\n        { new IRouter<obj> with\n            member this.Route req = router.Route req |> Option.map box\n            member this.Link e = tryUnbox<'T> e |> Option.bind router.Link\n        } \n\n    let Unbox (router: IRouter<obj>) : IRouter<'T> =\n        { new IRouter<'T> with\n            member this.Route req = router.Route req |> Option.bind tryUnbox<'T>\n            member this.Link e = box e |> router.Link\n        } \n\n[<JavaScript>]\nmodule RouterOperators =\n    let rRoot : Router =\n        {\n            Parse = fun path -> Seq.singleton path\n            Segment = Seq.empty\n        }\n    \n    [<Inline>]\n    /// Parse/write a specific string.\n    let r name : Router = Router.FromString name\n\n    /// Parse/write a string using URL encode/decode.\n    let rString : Router<string> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some s ->\n                        Seq.singleton ({ path with Segments = t }, s)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if isNull value then \"null\" else StringEncoding.write value)))\n        }\n\n    /// Parse/write a char.\n    let rChar : Router<char> =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match StringEncoding.read h with\n                    | Some c when c.Length = 1 ->\n                        Seq.singleton ({ path with Segments = t }, char c)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    [<Inline>]\n    let inline rTryParse< ^T when ^T: (static member TryParse: string * byref< ^T> -> bool) and ^T: equality>() =\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    let mutable res = Unchecked.defaultof< ^T>\n                    let ok = (^T: (static member TryParse: string * byref< ^T> -> bool) (h, &res))\n                    if ok then \n                        Seq.singleton ({ path with Segments = t }, res)\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (string value)))\n        }\n\n    /// Parse/write a Guid.\n    let rGuid = rTryParse<System.Guid>()\n    /// Parse/write an int.\n    let rInt = rTryParse<int>()\n    /// Parse/write a double.\n    let rDouble = rTryParse<double>()\n    /// Parse/write a signed byte.\n    let rSByte = rTryParse<sbyte>() \n    /// Parse/write a byte.\n    let rByte = rTryParse<byte>() \n    /// Parse/write a 16-bit int.\n    let rInt16 = rTryParse<int16>() \n    /// Parse/write a 16-bit unsigned int.\n    let rUInt16 = rTryParse<uint16>() \n    /// Parse/write an unsigned int.\n    let rUInt = rTryParse<uint32>() \n    /// Parse/write a 64-bit int.\n    let rInt64 = rTryParse<int64>() \n    /// Parse/write a 64-bit unsigned int.\n    let rUInt64 = rTryParse<uint64>() \n    /// Parse/write a single.\n    let rSingle = rTryParse<single>() \n\n    /// Parse/write a bool.\n    let rBool : Router<bool> =\n        // we define rBool not with rTryParse so that fragments are capitalized\n        // to be fully consistent on client+server\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    match System.Boolean.TryParse h with\n                    | true, g ->\n                        Seq.singleton ({ path with Segments = t }, g)\n                    | _ -> Seq.empty\n                | _ -> Seq.empty\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment (if value then \"True\" else \"False\")))\n        }\n\n    /// Parses any remaining part of the URL as a string, no URL encode/decode is done.\n    let rWildcard : Router<string> = \n        {\n            Parse = fun path ->\n                let s = path.Segments |> String.concat \"/\"\n                Seq.singleton ({ path with Segments = [] }, s)\n            Write = fun value ->\n                Some (Seq.singleton (Route.Segment value))\n        }\n    \n    let rWildcardArray (item: Router<'A>) : Router<'A[]> =\n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, Array.ofList (List.rev acc))\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> Array.map item.Write\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let rWildcardList (item: Router<'A>) : Router<'A list> = \n        {\n            Parse = fun path ->\n                let rec collect path acc =\n                    match path.Segments with\n                    | [] -> Seq.singleton (path, List.rev acc)\n                    | _ ->\n                        item.Parse path |> Seq.collect(fun (p, a) -> collect p (a :: acc))\n                collect path []\n            Write = fun value ->\n                let parts = value |> List.map item.Write\n                if List.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    /// Parse/write a DateTime in `YYYY-MM-DD-HH.mm.ss` format.\n    let rDateTime : Router<System.DateTime> =\n        let pInt x =\n            match System.Int32.TryParse x with\n            | true, i -> Some i\n            | _ -> None\n        {\n            Parse = fun path ->\n                match path.Segments with\n                | h :: t -> \n                    if h.Length = 19 && h.[4] = '-' && h.[7] = '-' && h.[10] = '-' && h.[13] = '.' && h.[16] = '.' then\n                        match pInt h.[0 .. 3], pInt h.[5 .. 6], pInt h.[8 .. 9], pInt h.[11 .. 12], pInt h.[14 .. 15], pInt h.[17 .. 18] with\n                        | Some y, Some m, Some d, Some h, Some mi, Some s  ->\n                            Seq.singleton ({ path with Segments = t }, System.DateTime(y, m, d, h, mi, s))\n                        | _ -> Seq.empty\n                    else Seq.empty\n                | _ -> Seq.empty\n            Write = fun d ->\n                let pad2 (x: int) =\n                    let s = string x\n                    if s.Length = 1 then \"0\" + s else s\n                let pad4 (x: int) =\n                    let s = string x\n                    match s.Length with\n                    | 1 -> \"000\" + s\n                    | 2 -> \"00\" + s\n                    | 3 -> \"0\" + s\n                    | _ -> s\n                let s = \n                    pad4 d.Year + \"-\" + pad2 d.Month + \"-\" + pad2 d.Day\n                    + \"-\" + pad2 d.Hour + \".\" + pad2 d.Minute + \".\" + pad2 d.Second\n                Some (Seq.singleton (Route.Segment s))\n        }\n      \n    let internal Tuple (readItems: obj -> obj[]) (createTuple: obj[] -> obj) (items: Router<obj>[]) =\n        {\n            Parse = fun path ->\n                let rec collect elems path acc =\n                    match elems with \n                    | [] -> Seq.singleton (path, createTuple (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect (List.ofArray items) path []\n            Write = fun value ->\n                let parts =\n                    (readItems value, items) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n\n    let internal JSTuple (items: Router<obj>[]) : Router<obj> =\n        let readItems (value: obj) =\n            Array.init items.Length (fun i ->\n                (As<Array<obj>> value).[i]\n            )\n        Tuple readItems box items\n\n    [<Inline>]\n    let internal JSEmpty () : Router<obj> = Router.Empty<obj>\n\n    [<Inline>]\n    let internal JSArray item = Router.Array item\n    \n    [<Inline>]\n    let internal JSList item = Router.List item\n\n    [<Inline>]\n    let internal JSOption item = Router.Option item\n\n    [<Inline>]\n    let internal JSNullable item = Router.Nullable item\n\n    [<Inline>]\n    let internal JSQuery key item = Router.Query key item\n\n    [<Inline>]\n    let internal JSQueryOption key item = Router.QueryOption key item\n\n    [<Inline>]\n    let internal JSQueryNullable key item = Router.QueryNullable key item\n\n    [<Inline>]\n    let internal JSFormData item = Router.FormData item\n\n    [<Inline>]\n    let internal JSJson<'T when 'T: equality> = Router.Json<'T>\n\n    [<Inline>]\n    let internal JSBox item = Router.Box item\n\n    [<Inline>]\n    let internal JSDelayed getRouter = Router.Delay getRouter\n        \n    let internal JSRecord (t: obj) (fields: (string * bool * Router<obj>)[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createRecord fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let fields = fields |> Array.map (fun (_, _, r) -> r)\n        let fieldsList =  List.ofArray fields        \n        {\n            Parse = fun path ->\n                let rec collect fields path acc =\n                    match fields with \n                    | [] -> Seq.singleton (path, createRecord (Array.ofList (List.rev acc)))\n                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                collect fieldsList path []\n            Write = fun value ->\n                let parts =\n                    (readFields value, fields) ||> Array.map2 (fun v r ->\n                        r.Write v\n                    )\n                if Array.forall Option.isSome parts then\n                    Some (parts |> Seq.collect Option.get)\n                else None                      \n        }\n    \n    let internal isCorrectMethod m p =\n        match p, m with\n        | Some pm, Some m -> pm = m\n        | _, Some _ -> false\n        | _ -> true\n\n    let internal JSUnion (t: obj) (cases: (option<obj> * (option<string> * string[])[] * Router<obj>[])[]) : Router<obj> = \n        let getTag value = \n            let constIndex =\n                cases |> Seq.tryFindIndex (\n                    function\n                    | Some c, _, _ -> value = c\n                    | _ -> false\n                )\n            match constIndex with\n            | Some i -> i\n            | _ -> value?(\"$\") \n        let readFields tag value =\n            let _, _, fields = cases.[tag]\n            Array.init fields.Length (fun i ->\n                value?(\"$\" + string i)\n            )\n        let createCase tag fieldValues =\n            let o = if isNull t then New [] else JS.New t\n            match cases.[tag] with\n            | Some constant, _, _ -> constant\n            | _ ->\n                o?(\"$\") <- tag\n                fieldValues |> Seq.iteri (fun i v ->\n                    o?(\"$\" + string i) <- v\n                )\n                o\n        let parseCases =\n            cases |> Seq.indexed |> Seq.collect (fun (i, (_, eps, fields)) ->\n                eps |> Seq.map (fun (m, p) -> i, m, p, fields)    \n            )\n        {                                                    \n            Parse = fun path ->\n                parseCases |> Seq.collect (fun (i, m, s, fields) ->\n                    if isCorrectMethod m path.Method then\n                        match path.Segments |> List.startsWith (List.ofArray s) with\n                        | Some p -> \n                            match List.ofArray fields with\n                            | [] -> Seq.singleton ({ path with Segments = p }, createCase i [||])\n                            | fields -> \n                                let rec collect fields path acc =\n                                    match fields with \n                                    | [] -> Seq.singleton (path, createCase i (Array.ofList (List.rev acc)))\n                                    | h :: t -> h.Parse path |> Seq.collect(fun (p, a) -> collect t p (a :: acc))\n                                collect fields { path with Segments = p } []\n                        | None -> Seq.empty\n                    else\n                        Seq.empty\n                )\n            Write = fun value ->\n                let tag = getTag value\n                let _, eps, fields = cases.[tag]\n                let method, path = eps.[0]\n                let casePath = Seq.singleton (Route.Segment (List.ofArray path, method))\n                match fields with\n                | [||] -> Some casePath\n                | _ ->\n                    let fieldParts =\n                        (readFields tag value, fields) ||> Array.map2 (fun v f -> f.Write v)\n                    if Array.forall Option.isSome fieldParts then\n                        Some (Seq.append casePath (fieldParts |> Seq.collect Option.get))\n                    else None                      \n        }\n\n    let internal JSClass (ctor: unit -> obj) (fields: (string * bool * Router<obj>)[]) (endpoints: (option<string> * Union<string, int>[])[]) (subClasses: Router<obj>[]) : Router<obj> =\n        let readFields value =\n            fields |> Array.map (fun (fn, opt, _) ->\n                if opt then\n                    let v = value?(fn)\n                    if v = JS.Undefined then box None else box (Some v)\n                else\n                    value?(fn)\n            )\n        let createObject fieldValues =\n            let o = ctor()\n            (fields, fieldValues) ||> Array.iter2 (fun (fn, opt, _) v ->\n                if opt then\n                    match As<option<obj>> v with\n                    | None -> ()\n                    | Some v ->\n                        o?(fn) <- v\n                else\n                    o?(fn) <- v\n            )\n            o\n        let partsAndRoutersLists =\n            endpoints |> Array.map (fun (m, ep) ->\n                m, \n                ep |> Seq.map (fun p ->\n                    match p with\n                    | Union1Of2 s -> Choice1Of2 s\n                    | Union2Of2 i -> \n                        let _, _, r = fields.[i]\n                        Choice2Of2 (i, r)\n                ) |> List.ofSeq\n            )\n        let thisClass =\n            {\n                Parse = fun path ->\n                    let rec collect fields path arr =\n                        match fields with \n                        | [] -> \n                            Seq.singleton (path, createObject arr)\n                        | Choice1Of2 p :: t -> \n                            match path.Segments with\n                            | pp :: pr when pp = p ->\n                                collect t { path with Segments = pr } arr\n                            | _ -> Seq.empty\n                        | Choice2Of2 (i, h) :: t -> \n                            h.Parse path |> Seq.collect(fun (p, a) -> \n                                let narr = Array.copy arr\n                                narr.[i] <- a\n                                collect t p narr\n                            )\n                    partsAndRoutersLists |> Seq.collect (fun (m, ps) -> \n                        if isCorrectMethod m path.Method then\n                            let arr = Array.zeroCreate fields.Length\n                            collect ps path arr\n                        else Seq.empty\n                    )\n                Write = fun value ->\n                    let values = readFields value\n                    let method, ep = endpoints.[0]\n                    let parts =\n                        ep |> Array.map (function\n                            | Union1Of2 p -> Some (Seq.singleton (Route.Segment(p)))\n                            | Union2Of2 i ->\n                                let _, _, r = fields.[i] \n                                r.Write(values.[i])\n                        )\n                    if Array.forall Option.isSome parts then\n                        let w = parts |> Seq.collect Option.get\n                        match method with\n                        | Some _ -> Some (Seq.append (Seq.singleton { Route.Empty with Method = method }) w)\n                        | None -> Some w\n                    else None                      \n            }\n        if Array.isEmpty subClasses then\n            thisClass\n        else\n            Router.Sum (Seq.append subClasses (Seq.singleton thisClass))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule internal Observer =\n\n    type Message<'T> =\n        | Message of 'T\n        | Error of exn\n        | Completed\n\n    let Of f : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = raise x\n            member __.OnCompleted() = ()\n        }\n\n    let New (f, e, c) : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = e x\n            member __.OnCompleted() = c()\n        }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\nmodule internal HotStream =\n    open System\n\n    /// Implementation for \"hot stream\".\n    /// Subscribers to hot streams will only observe the latest\n    /// and future values.\n    [<JavaScript>]\n    type HotStream<'T> =\n        internal\n            {\n                Latest  : ref<option<'T>>\n                Event   : Event<'T>\n            }\n        interface IObservable<'T> with\n            member this.Subscribe(o) =\n                if this.Latest.Value.IsSome then\n                    o.OnNext this.Latest.Value.Value\n                let disp =\n                    this.Event.Publish.Subscribe(fun v ->\n                        o.OnNext(v)\n                    )\n                disp\n\n        member this.Trigger(v) =\n            this.Latest := Some v\n            this.Event.Trigger v\n\n        static member New<'U>() : HotStream<'U> =\n            {\n                Latest = ref None\n                Event = Event<_>()\n            }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.JavaScript>]\nmodule internal WebSharper.Control.Observable\n\nopen System\nopen WebSharper\n\n[<Inline>]\nlet New f : IObservable<'T> = { new IObservable<'T> with member __.Subscribe o = f o }\n\nlet Of (f: ('T -> unit) -> (unit -> unit)) : IObservable<_> =\n    New (fun o -> Disposable.Of (f (fun x -> o.OnNext x)))\n\nlet Return<'T> (x: 'T) : IObservable<'T> =\n    let f (o : IObserver<'T>) =\n        o.OnNext x\n        o.OnCompleted ()\n        Disposable.Of ignore\n    New f\n\nlet Never<'T> () : IObservable<'T> =\n    New(fun _ ->\n        Disposable.Of ignore\n    )\n\nlet Protect f succeed fail =\n    match (try Choice1Of2 (f ()) with e -> Choice2Of2 e) with\n    | Choice1Of2 x -> (succeed x)\n    | Choice2Of2 e -> (fail e)\n\nlet Map (f: 'T -> 'U) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) o1.OnNext o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\n\nlet Filter (f: 'T -> bool) (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let on v = \n            Protect (fun () -> if f v then Some v else None)\n                (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <|  Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Choose  (f: 'T -> option<'U>) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Drop count (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let index = ref 0\n        let on v =\n            incr index\n            if index.Value > count then\n                o1.OnNext v\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Merge (io1: IObservable<'T>) (io2: IObservable<'T>) : IObservable<'T> =\n    New <| fun o ->\n        let completed1 = ref false\n        let completed2 = ref false\n        let disp1 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed1 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io1.Subscribe\n        let disp2 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed2 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io2.Subscribe\n        Disposable.Of (fun () -> disp1.Dispose(); disp2.Dispose())\n\nlet Concat (io1: IObservable<'T>) (io2: IObservable<'T>) =\n    New <| fun o ->\n        let innerDisp = ref None\n        let outerDisp =\n            io1.Subscribe(\n                Observer.New(o.OnNext, ignore, fun () ->\n                    innerDisp := Some <| io2.Subscribe(o)\n                )\n            )\n        Disposable.Of <| fun () ->\n            if innerDisp.Value.IsSome then\n                innerDisp.Value.Value.Dispose ()\n            outerDisp.Dispose()\n\n\nlet Range (start: int , count: int) : IObservable<int> =\n    New <| fun o ->\n        for i = start to start + count do\n            o.OnNext i\n        Disposable.Of ignore\n\n\nlet CombineLatest   (io1 : IObservable<'T>)\n                    (io2: IObservable<'U>)\n                    (f: 'T -> 'U -> 'S) : IObservable<'S> =\n    New <| fun o ->\n        let lv1 = ref None\n        let lv2 = ref None\n        let update () =\n            match !lv1, !lv2 with\n            | Some v1, Some v2  ->\n                Protect (fun () -> f v1 v2) o.OnNext o.OnError\n            | _                 ->\n                ()\n        let o1 =\n            let onNext x =\n                lv1 := Some x\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let o2 =\n            let onNext y =\n                lv2 := Some y\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let d1 = io1.Subscribe(o1)\n        let d2 = io2.Subscribe(o2)\n        Disposable.Of (fun () -> d1.Dispose() ; d2.Dispose())\n\nlet Switch (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp =\n            let index = ref 0\n            let disp : option<IDisposable> ref = ref None\n\n            // Subscribe to outer stream\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Update counter\n                incr index\n\n                // Dispose old observer\n                if disp.Value.IsSome then\n                    disp.Value.Value.Dispose ()\n\n                let currentIndex = index.Value\n                let d =\n                    o1.Subscribe (fun v ->\n                        if currentIndex = index.Value then\n                            o.OnNext(v)\n                    ) |> Some\n                // Update dispose\n                disp := d\n            )\n        disp\n    )\n\nlet SelectMany (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp = ref ignore\n        // Subscribe to outer stream\n        let d =\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Subscribe to inner stream\n                let d =\n                    o1.Subscribe (fun v ->\n                        o.OnNext v\n                    )\n                disp := fun () ->\n                    disp.Value ()\n                    d.Dispose ()\n            )\n        Disposable.Of (fun () ->\n            disp.Value ()\n            d.Dispose ()\n        )\n    )\n\nlet Aggregate (io: IObservable<'T>) (seed: 'S) (fold: 'S -> 'T -> 'S) =\n    New <| fun o1 ->\n        let state = ref seed\n        let on v = \n            Protect (fun () -> fold !state v) \n                (fun s -> state := s; o1.OnNext s) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n////    let CollectLatest (outer: IObservable<IObservable<'T>>) : IObservable<seq<'T>> =\n//        New (fun o ->\n//            let dict = System.Collections.Generic.Dictionary<int, 'T>()\n//            let index = ref 0\n//\n//            // Outer subscription\n//            outer.Subscribe(fun (inner: IObservable<'T>) ->\n//                incr index\n//                let currentIndex = index.Value\n//\n//                // Inner subscription\n//                inner.Subscribe(fun value ->\n//                    dict.[currentIndex] <- value\n//                    seq {for pair in dict do yield pair.Value}\n//                    |> o.OnNext\n//                )|> ignore\n//            )\n//        )\n\nlet Sequence (ios: seq<IObservable<'T>>) : IObservable<List<'T>> =\n    let rec sequence (ios: list<IObservable<'T>>) =\n        match ios with\n        | []        ->\n            Return []\n        | x::xs  ->\n            let rest = sequence xs\n            CombineLatest x rest  (fun x y -> x :: y)\n    sequence (List.ofSeq ios)\n\n\n[<Inline>]\nlet Heat (io: IObservable<'T>) : IObservable<'T> =\n    let formStream = HotStream.HotStream<_>.New()\n    let disp =\n        io.Subscribe formStream.Trigger\n    formStream :> IObservable<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.ObservableModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private ObservableModule =\n\n    [<Inline>]\n    let Add (f: 'T -> unit) (o: IObservable<'T>) =\n        ignore (o.Subscribe (Observer.Of f))\n\n    [<Inline>]\n    let Choose (c: 'T -> option<'U>) (e: IObservable<'T>) =\n        Observable.Choose c e\n\n    [<Inline>]\n    let Filter (ok: 'T -> bool) (e: IObservable<'T>) : IObservable<'T> =\n        Observable.Filter ok e\n\n    [<Inline>]\n    let Map (f: 'T -> 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.Map f e\n\n    [<Inline>]\n    let Merge (e1: IObservable<'T>) (e2: IObservable<'T>) =\n        Observable.Merge e1 e2\n\n    let Pairwise (e: IObservable<'T>) : IObservable<'T * 'T> =\n        Observable.New <| fun o1 ->\n            let last = ref None\n            let on v =\n                match !last with\n                | None -> ()\n                | Some l -> o1.OnNext(l, v)\n                last := Some v\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Partition (f: 'T -> bool) (e: IObservable<'T>) :\n            IObservable<'T> * IObservable<'T> =\n        (Observable.Filter f e, Observable.filter (f >> not) e)\n\n    let Scan (fold: 'U -> 'T -> 'U) (seed: 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.New <| fun o1 ->\n            let state = ref seed\n            let on v = \n                Observable.Protect (fun () -> fold !state v) \n                    (fun s -> state := s; o1.OnNext s) o1.OnError\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Split (f: 'T -> Core.Choice<'U1,'U2>) (e: IObservable<'T>) :\n            IObservable<'U1> * IObservable<'U2> =\n        let left =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _ -> None)\n        let right =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _ -> None)\n        (left, right)\n\n    [<Inline>]\n    let Subscribe (f: 'T -> unit) (e: IObservable<'T>) =\n        e.Subscribe f\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nmodule internal Event =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type Event<'T> = private { Handlers : ResizeArray<Handler<'T>> } with\n\n        member this.Trigger(x: 'T) =\n            for h in this.Handlers.ToArray() do\n                h.Invoke(null, x)\n\n        member this.AddHandler(h: Handler<'T>) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: Handler<'T>) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        member this.Subscribe(observer: IObserver<'T>) =\n            let h = new Handler<'T>(fun _ x -> observer.OnNext x)\n            this.AddHandler h\n            Disposable.Of (fun () -> this.RemoveHandler h)\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IObservable<'T> with\n                member this.Subscribe observer = this.Subscribe observer\n\n        interface IDelegateEvent<Handler<'T>> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n        interface IEvent<'T>\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n\nmodule internal DelegateEvent =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type DelegateEvent<'T when 'T :> System.Delegate and 'T: equality> = private { Handlers : ResizeArray<'T> } with\n\n        member this.Trigger(x: obj[]) =\n            for h in this.Handlers.ToArray() do\n                h.DynamicInvoke(x) |> ignore\n\n        member this.AddHandler(h: 'T) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: 'T) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IDelegateEvent<'T> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\n[<Proxy(typeof<Event<_>>)>]\n[<Name \"WebSharper.Control.FSharpEvent\">]\ntype private FSharpEvent<'T> [<JavaScript>] () =\n    let event = Event.New ()\n\n    [<Inline>]\n    member this.Trigger(x: 'T) = event.Trigger x\n\n    member this.Publish with [<Inline>] get () = event :> IEvent<_>\n\n[<Proxy(typeof<DelegateEvent<_>>)>]\n[<Name \"WebSharper.Control.FSharpDelegateEvent\">]\ntype private FSharpDelegateEvent<'T when 'T :> System.Delegate and 'T: equality> [<JavaScript>] () =\n    let event = DelegateEvent.New ()\n\n    [<Inline>]\n    member this.Trigger(args: obj[]) = event.Trigger args\n\n    member this.Publish with [<Inline>] get () = event :> IDelegateEvent<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.EventModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private EventModule =\n\n    [<Inline>]\n    let Add f (e: IEvent<_,_>) = e.Add f\n\n    let Choose c (e: IEvent<_,_>) : IEvent<_> =\n        // let r = Event.New ()\n        let r = Event<_>()\n        e.Add (fun x ->\n            match c x with\n            | Some y    -> r.Trigger y\n            | None      -> ())\n        r.Publish :> _\n\n    let Filter ok (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> if ok x then r.Trigger x)\n        r :> _\n\n    let Map f (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> r.Trigger (f x))\n        r :> _\n\n    let Merge<'D1,'T,'D2 when 'D1 :> Delegate\n                          and 'D1 :  delegate<'T,unit>\n                          and 'D2 :> Delegate\n                          and 'D2 :  delegate<'T,unit>>\n            (e1: IEvent<'D1,'T>) (e2: IEvent<'D2,'T>) : IEvent<_> =\n        let r = Event.New ()\n        e1.Add r.Trigger\n        e2.Add r.Trigger\n        r :> _\n\n    let Pairwise (e: IEvent<_,_>) : IEvent<_> =\n        let buf = ref None\n        let ev  = Event.New ()\n        e.Add (fun x ->\n            match buf.Value with\n            | None ->\n                buf := Some x\n            | Some old ->\n                buf := Some x\n                ev.Trigger(old, x))\n        ev :> _\n\n    let Partition f e =\n        (Event.filter f e, Event.filter (f >> not) e)\n\n    let Scan fold seed e =\n        let state = ref seed\n        let f value =\n            state := fold !state value\n            !state\n        Event.map f e\n\n    let Split (f: 'T -> Choice<'U1,'U2>) (e: IEvent<'Del,'T>) =\n        (\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _                 -> None),\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _                 -> None)\n        )\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Threading\n\n[<Proxy(typeof<AsyncReplyChannel<_>>)>]\ntype private ChannelProxy<'T> =\n    [<Inline \"$this($res)\">]\n    member this.Reply(res: 'T) = X<unit>\n\n[<Proxy(typeof<MailboxProcessor<_>>)>]\n[<Name \"MailboxProcessor\">]\ntype private MailboxProcessorProxy<'T> (initial, ?token: CancellationToken) =\n    let mutable started = false\n    let errorEvent = Event<exn>()\n    let mailbox = LinkedList<'T>()\n    let mutable savedCont = None\n\n    let startAsync a =\n        Async.Start(a, ?cancellationToken = token)\n\n    let resume() =\n        match savedCont with\n        | None -> ()\n        | Some c ->\n            savedCont <- None\n            c |> startAsync\n\n    do  match token with\n        | Some ct -> \n            ct.Register(fun () -> resume()) |> ignore\n        | None -> ()\n\n    let dequeue() =\n        let f = mailbox.First.Value\n        mailbox.RemoveFirst()\n        f\n\n    [<CLIEvent>]\n    member this.Error = errorEvent.Publish\n\n    member val DefaultTimeout = -1 with get, set    \n\n    member this.Start() =\n        if started then\n            failwith \"The MailboxProcessor has already been started.\"\n        else\n            started <- true\n            async {\n                try do! initial (As<MailboxProcessor<'T>> this)\n                with err -> errorEvent.Trigger err\n            } |> startAsync\n\n    static member Start(initial, ?token: CancellationToken) =\n        let mb = new MailboxProcessor<'T>(initial, ?cancellationToken = token)\n        mb.Start()\n        mb\n\n    [<Inline>]\n    member this.Post(msg: 'T) =\n        mailbox.AddLast msg |> ignore\n        resume()\n\n    member this.TryReceive(?timeout: int) =        \n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if mailbox.First = null then\n                if timeout < 0 then\n                    savedCont <- Some <| async { dequeue() |> Some |> ok }\n                else  \n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout \n                    savedCont <- Some <| async { \n                        if !waiting then do\n                            waiting := false  \n                            JS.ClearTimeout pending\n                            dequeue() |> Some |> ok \n                    }\n            else dequeue() |> Some |> ok\n\n    member this.Receive(?timeout: int) =\n        async {\n            let! x = this.TryReceive(?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n                              \n    member this.CurrentQueueLength = mailbox.Count\n\n    member this.PostAndTryAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R option> =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if timeout < 0 then\n                As (Some >> ok) |> msgf |> this.Post\n            else\n                let waiting = ref true\n                As (fun res ->\n                    if !waiting then\n                        waiting := false\n                        ok (Some res)\n                ) |> msgf |> this.Post\n                JS.SetTimeout (fun () ->\n                    if !waiting then\n                        waiting := false\n                        ok None        \n                ) timeout |> ignore               \n\n    member this.PostAndAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R> =\n        async {\n            let! x = this.PostAndTryAsyncReply(msgf, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n\n    member this.TryScan(scanner, ?timeout: int) =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        async {\n            let scanInbox() =\n                let mutable m = mailbox.First\n                let mutable found = None\n                while m <> null do \n                    match scanner m.Value with\n                    | None ->\n                        m <- m.Next\n                    | _ as a ->\n                        mailbox.Remove m\n                        m <- null\n                        found <- a\n                found\n            match scanInbox() with\n            | Some found -> \n                let! res = found\n                return Some res\n            | _ -> return! Async.FromContinuations <| fun (ok, _, _) -> \n                if timeout < 0 then\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                ok (Some res)\n                        }\n                    scanNext()\n                else\n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                if !waiting then do\n                                    waiting := false\n                                    JS.ClearTimeout pending\n                                    ok (Some res)\n                        }\n                    scanNext()\n        }\n        \n    member this.Scan(scanner, ?timeout: int) =\n        async {\n            let! x = this.TryScan(scanner, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\nmodule Array =\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine\n    /// all items into a single value.\n    [<JavaScript>]\n    let TreeReduce (defaultValue: 'A) (reduction: 'A -> 'A -> 'A) (array: 'A[]) : 'A =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine \n    /// all items into a single value using the mapping function first on each item.\n    [<JavaScript>]\n    let MapTreeReduce (mapping: 'A -> 'B) (defaultValue: 'B) (reduction: 'B -> 'B -> 'B) (array: 'A[]) : 'B =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                mapping array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    [<JavaScript>]\n    /// Same as Array.ofSeq, but if argument is an array, it does not copy it.\n    let ofSeqNonCopying (xs: seq<'T>) : 'T [] =\n        if xs :? System.Array then\n            xs :?> 'T[]\n        elif xs :? _ list then\n            Array.ofList (xs :?> 'T list)\n        elif obj.ReferenceEquals(xs, null) then\n            [||]\n        else\n            let q : 'T [] = [||]\n            use o = xs.GetEnumerator()\n            while o.MoveNext() do\n                q.JS.Push(o.Current) |> ignore\n            q\n\n    [<JavaScript>]\n    /// Unsafe operation, modifies each element of an array by a mapping function.\n    let mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n        if IsClient then\n            for i = 0 to Array.length arr - 1 do\n                arr.JS.[i] <- As (f arr.JS.[i])\n            As<'T2[]> arr\n        else Array.map f arr\n\nmodule internal String =\n\n    [<JavaScript>]\n    let isBlank s =\n        String.forall Char.IsWhiteSpace s\n\nmodule internal List =\n\n    // TODO: better impl only going to n?\n    [<JavaScript>]\n    let replaceFirst (k: 'A -> bool) (f: 'A -> 'A) (l: list<'A>) =\n        let didIt = ref false\n        l |> List.map (fun x -> if not !didIt && k x then f x else x)\n\n    // TODO: better impl only going to n?\n    [<JavaScript>]\n    let maybeReplaceFirst (k: 'A -> bool) (f: 'A -> option<'A>) (l: list<'A>) =\n        let didIt = ref false\n        l |> List.map (fun x -> if not !didIt && k x then defaultArg (f x) x else x)\n\n/// Abbreviations and small utilities for this assembly.\n[<AutoOpen>]\nmodule internal Abbrev =\n\n    [<JavaScript>]\n    module Fresh =\n\n        let mutable private counter = 0\n\n        let Int () =\n            counter <- counter + 1\n            counter\n\n        let Id () =\n            counter <- counter + 1\n            \"uid\" + string counter\n\n    [<JavaScript>]\n    module HashSet =\n\n        let ToArray (set: HashSet<'T>) =\n            let arr = Array.create set.Count JS.Undefined\n            set.CopyTo(arr)\n            arr\n\n        let Except (excluded: HashSet<'T>) (included: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray included)\n            set.ExceptWith(ToArray excluded)\n            set\n\n        let Intersect (a: HashSet<'T>) (b: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray a)\n            set.IntersectWith(ToArray b)\n            set\n\n        let Filter (ok: 'T -> bool) (set: HashSet<'T>) =\n            HashSet<'T>(ToArray set |> Array.filter ok)\n\n    [<JavaScript>]\n    module Dict =\n\n        let ToKeyArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Key)\n            arr\n\n        let ToValueArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Value)\n            arr\n\n    module Queue =\n\n        [<Inline \"$q\">]\n        let ToArray (q: Queue<_>) = q.ToArray()\n\n    [<JavaScript>]\n    [<Sealed>]\n    type Slot<'T,'K when 'K : equality>(key: 'T -> 'K, value: 'T) =\n        member s.Value = value\n\n        override s.Equals(o: obj) =\n            key value = key (o :?> Slot<'T,'K>).Value\n\n        override s.GetHashCode() = hash (key value)\n\n    [<JavaScript>]\n    type Slot =\n        static member Create key value = Slot(key, value)\n\n    [<JavaScript>]\n    module Async =\n\n        [<Direct \"console.log('WebSharper UI: Uncaught asynchronous exception', $e)\">]\n        let OnError (e: exn) = ()\n\n        let StartTo comp k =\n            Async.StartWithContinuations (comp, k, OnError, ignore)\n\n        [<Inline \"WebSharper.Concurrency.scheduler().Fork($f)\">]\n        let Schedule f =\n            async { return f () }\n            |> Async.Start\n\n    [<JavaScript>]\n    module Mailbox =\n\n        type MailboxState =\n            | Idle = 0\n            | Working = 1\n            | WorkingMore = 2\n\n        /// Simplified MailboxProcessor implementation.\n        let StartProcessor procAsync =\n            let st = ref MailboxState.Idle\n            let rec work() =\n                async {\n                    do! procAsync\n                    match !st with\n                    | MailboxState.Working -> \n                        st := MailboxState.Idle\n                    | MailboxState.WorkingMore ->\n                        st := MailboxState.Working\n                        return! work() \n                    | _ -> ()\n                }\n            let post() =\n                match !st with\n                | MailboxState.Idle ->\n                    st := MailboxState.Working\n                    Async.Start (work()) \n                | MailboxState.Working -> \n                    st := MailboxState.WorkingMore\n                | _ -> ()\n            post\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System.Collections.Generic\n\ntype AppendList<'T> =\n    | AL0\n    | AL1 of 'T\n    | AL2 of AppendList<'T> * AppendList<'T>\n    | AL3 of 'T []\n\n[<JavaScript>]\nmodule AppendList =\n\n    type T<'T> = AppendList<'T>\n\n    let Empty<'T> : T<'T> = AL0\n\n    let Append x y =\n        match x, y with\n        | AL0, x | x, AL0 -> x\n        | _ -> AL2 (x, y)\n\n    let Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Empty Append\n\n    let Single x =\n        AL1 x\n\n    let ToArray xs =\n        let out = Queue()\n        let rec loop xs =\n            match xs with\n            | AL0 -> ()\n            | AL1 x -> out.Enqueue x\n            | AL2 (x, y) -> loop x; loop y\n            | AL3 xs -> Array.iter (fun v -> out.Enqueue v) xs\n        loop xs\n        out.ToArray()\n\n    let FromArray xs =\n        match Array.length xs with\n        | 0 -> AL0\n        | 1 -> AL1 xs.[0]\n        | _ -> AL3 (Array.copy xs)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// Utility functions for manipulating DOM.\n[<JavaScript>]\nmodule internal DomUtility =\n\n    /// The current DOM Document.\n    let Doc = JS.Document\n\n    /// Appends a child node to the given DOM element.\n    let AppendTo (ctx: Dom.Element) node =\n        ctx.AppendChild(node) |> ignore\n\n    /// Removes all attributes from the given DOM element.\n    let ClearAttrs (ctx: Dom.Element) =\n        while ctx.HasAttributes() do\n            ctx.RemoveAttributeNode(ctx.Attributes.[0] :?> _) |> ignore\n\n    /// Removes all child nodes from the given DOM element.\n    let Clear (ctx: Dom.Element) =\n        while ctx.HasChildNodes() do\n            ctx.RemoveChild(ctx.FirstChild) |> ignore\n\n    /// Creates a new DOM element.\n    let CreateElement (name: string) =\n        Doc.CreateElement name\n\n    /// Creates an element in the SVG namespace.\n    let CreateSvgElement (name: string) =\n        Doc.CreateElementNS(\"http://www.w3.org/2000/svg\", name)\n\n    /// Creates a new DOM text node with the given value.\n    let CreateText s =\n        Doc.CreateTextNode(s)\n\n    /// Creates a new DOM attribute.\n    let CreateAttr name value =\n        let a = Doc.CreateAttribute(name)\n        a.Value <- value\n        a\n\n    /// Removes a DOM attribute.\n    let RemoveAttr (el: Dom.Element) (attrName: string) =\n        el.RemoveAttribute attrName\n\n    /// Sets the value of the attribute given by\n    /// `name` to `value` in element `el`.\n    let SetAttr (el: Dom.Element) name value =\n        el.SetAttribute(name, value)\n\n    [<Direct \"$target.setProperty($name, $value)\">]\n    let private SetProperty (target: obj) (name: string) (value: string) = ()\n\n    /// Sets a style property.\n    let SetStyle (el: Dom.Element) name value =\n        SetProperty el?style name value\n\n    /// Safe remove of a node\n    let RemoveNode (parent: Dom.Element) (el: Dom.Node) =\n        // make sure not to remove already removed nodes\n        if obj.ReferenceEquals(el.ParentNode, parent) then\n            parent.RemoveChild(el) |> ignore\n\n    /// Position in a `children` list of a DOM Element\n    /// where a node can be inserted.\n    [<AllowNullLiteral>]\n    type InsertPos [<Inline \"$x\">] private (x: Dom.Node) =\n        [<Inline>]\n        static member AtEnd = null : InsertPos\n        [<Inline>]\n        static member BeforeNode n = InsertPos n\n    [<Inline>]\n    let AtEnd = InsertPos.AtEnd\n    [<Inline>]\n    let BeforeNode n = InsertPos.BeforeNode n\n\n    /// Inserts a new child node into the tree under\n    /// a given `parent` at given `pos`.\n    let InsertAt (parent: Dom.Element) (pos: InsertPos) (node: Dom.Node) =\n        let currentPos (node: Dom.Node) =\n            match node.NextSibling with\n            | null -> AtEnd\n            | s -> BeforeNode s\n        let canSkip =\n            node.ParentNode ===. parent\n            && pos ===. currentPos node\n        if not canSkip then\n            parent.InsertBefore(node, As pos) |> ignore\n\n    let private clsRE cls =\n        new RegExp(@\"(\\s+|^)\" + cls + @\"(?:\\s+\" + cls + \")*(\\s+|$)\", \"g\")\n\n    [<Inline \"$element instanceof SVGElement\">]\n    let private isSvg (element: Dom.Element) = X<bool>\n\n    let private getClass (element: Dom.Element) =\n        if isSvg element then\n            element.GetAttribute(\"class\")\n        else\n            element.ClassName\n\n    let private setClass (element: Dom.Element) (value: string) =\n        if isSvg element then\n            element.SetAttribute(\"class\", value)\n        else\n            element.ClassName <- value\n\n    /// Adds a class.\n    let AddClass (element: Dom.Element) (cl: string) =\n        let c = getClass element\n        if c = \"\" then\n            setClass element cl\n        elif not <| (clsRE cl).Test(c) then\n            setClass element (c + \" \" + cl)\n\n    /// Removes a class.\n    let RemoveClass (element: Dom.Element) (cl: string) =\n        setClass element <|\n            (clsRE cl).Replace(getClass element, FuncWithArgs(fun (_fullStr, before, after) ->\n                if before = \"\" || after = \"\" then \"\" else \" \"\n            ))\n\n    /// Retrieve the children of an element as an array.\n    let ChildrenArray (element: Dom.Element) : Dom.Node[] =\n        let a = [||]\n        for i = 0 to element.ChildNodes.Length - 1 do\n            a.JS.Push(element.ChildNodes.[i]) |> ignore\n        a\n\n    /// Iterate through a NodeList assuming it's all Elements.\n    let IterSelector (el: Dom.Element) (selector: string) (f: Dom.Element -> unit) =\n        let l = el.QuerySelectorAll(selector)\n        for i = 0 to l.Length - 1 do f (l.[i] :?> Dom.Element)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System.Collections.Generic\nmodule M = Map\n\n/// Trie lookup structure.\ntype Trie<'K,'V when 'K : comparison> =\n    | TrieBranch of Map<'K,Trie<'K,'V>> // invariant: not empty\n    | TrieEmpty\n    | TrieLeaf of 'V\n\n/// Trie combinators.\n[<JavaScript>]\nmodule Trie =\n\n    /// Branch trie, maintaining invariant.\n    let TrieBranch xs =\n        if M.isEmpty xs then TrieEmpty else TrieBranch xs\n\n    /// Singleton trie.\n    let Leaf v =\n        TrieLeaf v\n\n    /// Prefix a trie - becomes a branch.\n    let Prefix key trie =\n        TrieBranch (Map [key, trie])\n\n    /// Finds a value in a multi-map.\n    let MultiFind key map =\n        defaultArg (M.tryFind key map) []\n\n    /// Adds a value to a multi-map.\n    let MultiAdd key value map =\n        Map.add key (value :: MultiFind key map) map\n\n    /// Makes sure all results are Some.\n    let AllSome (xs: seq<option<'T>>) =\n        let e = xs.GetEnumerator()\n        let r = ResizeArray()\n        let mutable ok = true\n        while ok && e.MoveNext() do\n            match e.Current with\n            | None -> ok <- false\n            | Some x -> r.Add(x)\n        if ok then Some (r.ToArray() :> seq<_>) else None\n\n    /// Merges multiple maps into one given a merge function on values.\n    let MergeMaps merge maps =\n        Seq.collect M.toSeq maps\n        |> Seq.fold (fun s (k, v) -> MultiAdd k v s) M.empty\n        |> M.toSeq\n        |> Seq.map (fun (k, vs) -> merge vs |> Option.map (fun v -> (k, v)))\n        |> AllSome\n        |> Option.map Map.ofSeq\n\n    /// Checks for leaves.\n    let IsLeaf t =\n        match t with\n        | TrieLeaf _ -> true\n        | _ -> false\n\n    /// Merges tries.\n    let rec Merge (ts: seq<_>) =\n        let ts = Array.ofSeqNonCopying ts\n        match ts.Length with\n        | 0 -> Some TrieEmpty\n        | 1 -> Some ts.[0]\n        | _ ->\n            // leaves do not merge\n            if Array.exists IsLeaf ts then None else\n                ts\n                |> Seq.choose (function\n                    | TrieBranch map -> Some map\n                    | _ -> None)\n                |> MergeMaps Merge\n                |> Option.map TrieBranch\n\n    /// Inner loop for Map function.\n    let rec MapLoop loc f trie =\n        match trie with\n        | TrieBranch mp ->\n            mp\n            |> M.map (fun k v -> MapLoop (loc @ [k]) f v)\n            |> TrieBranch\n        | TrieEmpty -> TrieEmpty\n        | TrieLeaf x -> TrieLeaf (f loc x)\n\n    /// Maps a function.\n    let Map f trie =\n        MapLoop [] f trie\n\n    /// Map with a counter.\n    let Mapi f trie =\n        let counter = ref 0\n        let next () =\n            let c = !counter\n            counter := c + 1\n            c\n        Map (fun x -> f (next ()) x) trie\n\n    /// Collects all values.\n    let ToArray trie =\n        // TODO: more efficient than this.\n        let all = Queue()\n        Map (fun _ v -> all.Enqueue v) trie\n        |> ignore\n        all.ToArray()\n\n    /// Result of lookup function.\n    type LookupResult<'K,'V> =\n        | Found of value: 'V * remainder: list<'K>\n        | NotFound\n\n    /// Lookup main loop.\n    let rec Look key trie =\n        match trie, key with\n        | TrieLeaf v, _ -> Found (v, key)\n        | TrieBranch map, k :: ks ->\n            match M.tryFind k map with\n            | Some trie -> Look ks trie\n            | None -> NotFound\n        | _ -> NotFound\n\n    /// Looks up a value in the trie.\n    let Lookup trie key =\n        Look (Seq.toList key) trie\n\n    /// Empty trie.\n    let Empty<'K,'V when 'K : comparison> : Trie<'K,'V> =\n        TrieEmpty\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\n(*\n\nSnap implements a snapshot of a time-varying value.\n\nFinal states:\n\n    Forever     -- will never be obsolete\n    Obsolete    -- is obsolete\n\nDistinguishing Forever state is important as it avoids a class of\nmemory leaks connected with waiting on a Snap to become obsolete\nwhen it will never do so.\n\nState transitions:\n\n    Waiting         -> Forever      // MarkForever\n    Waiting         -> Obsolete     // MarkObsolete\n    Waiting         -> Ready        // MarkReady\n    Ready           -> Obsolete     // MarkObsolete\n\n*)\n\n[<JavaScript false>]\ntype ISnap =\n    abstract Obsolete : unit -> unit\n    abstract IsNotObsolete : unit -> bool\n\ntype OnObsoleted = Union<ISnap, unit -> unit>\n\n[<JavaScript>]\ntype SnapState<'T> =\n    | Forever of 'T\n    | [<Constant null>] Obsolete\n    | Ready of 'T * Queue<OnObsoleted>\n    | Waiting of Queue<'T -> unit> * Queue<OnObsoleted>\n\n[<JavaScript; AutoOpen>]\nmodule SnapInternals =\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $o()\">]\n    let obs (o: OnObsoleted) doObs =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> f()\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $doFunc($o)\">]\n    let clean (o: OnObsoleted) doObs doFunc =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> doFunc f\n\ntype Snap<'T> =\n    {\n        [<Name \"s\">] mutable State : SnapState<'T>\n    }\n\n    [<JavaScript>]\n    static member Obsolete(sn: Snap<'T>) =\n        match sn.State with\n        | Forever _ | Obsolete -> ()\n        | Ready (_, q) | Waiting (_, q) ->\n            sn.State <- Obsolete\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                obs qa.[i] (fun sn -> sn.Obsolete())\n\n    interface ISnap with\n        member this.Obsolete() =\n            Snap.Obsolete(this)\n\n        member this.IsNotObsolete() =\n            match this.State with\n            | Obsolete -> false\n            | _ -> true\n\n[<Proxy(typeof<ISnap>)>]\ntype internal ISnapProxy =\n    [<Inline>]\n    member this.Obsolete() =\n        Snap.Obsolete(As<Snap<obj>> this)\n\n    [<Inline \"$this.s\">]\n    member this.IsNotObsolete() = X<bool>\n\n[<JavaScript>]\nmodule Snap =\n\n  // constructors\n\n    [<Inline>]\n    let Make st = { State = st }\n\n    [<Inline>]\n    let Create () = Make (Waiting (Queue(), Queue()))\n\n    [<Inline>]\n    let CreateForever v = Make (Forever v)\n\n    [<Inline>]\n    let CreateWithValue v = Make (Ready (v, Queue()))\n\n  // misc\n\n    [<Inline>]\n    let IsForever snap =\n        match snap.State with\n        | Forever _ -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsObsolete snap =\n        match snap.State with\n        | Obsolete -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsDone snap =\n        match snap.State with\n        | Forever _ | Ready _ -> true\n        | _ -> false\n\n    let TryGet snap =\n        match snap.State with\n        | Forever x | Ready (x, _) -> Some x\n        | _ -> None\n\n  // transitions\n\n    let MarkForever sn v =\n        match sn.State with\n        | Waiting (q, _) ->\n            sn.State <- Forever v\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    [<Inline>]\n    let MarkObsolete (sn: Snap<_>) =\n        (sn :> ISnap).Obsolete()\n\n    let MarkReady sn v =\n        match sn.State with\n        | Waiting (q1, q2) ->\n            sn.State <- Ready (v, q2)\n            let qa = Queue.ToArray q1\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    let MarkDone res sn v =\n        if IsForever sn then\n            MarkForever res v\n        else\n            MarkReady res v\n\n    let EnqueueSafe (q: Queue<_>) x =\n        q.Enqueue x\n        if q.Count % 20 = 0 then\n            let qcopy = q.ToArray()\n            q.Clear()\n            for i = 0 to qcopy.Length - 1 do\n                clean qcopy.[i]\n                    (fun sn -> if sn.IsNotObsolete() then q.Enqueue (Union1Of2 sn))\n                    (fun f -> q.Enqueue (Union2Of2 f)) \n\n  // eliminators\n\n    let When snap avail (obs: ISnap) =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q1) -> EnqueueSafe q1 (Union1Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenRun snap avail obs =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs()\n        | Ready (v, q1) -> q1.Enqueue (Union2Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; q2.Enqueue (Union2Of2 obs)\n\n    let WhenReady snap avail =\n        match snap.State with\n        | Forever v\n        | Ready (v, _) -> avail v\n        | Obsolete -> ()\n        | Waiting (q1, _) -> q1.Enqueue avail\n\n    let WhenObsolete snap (obs: ISnap) =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q) -> EnqueueSafe q (Union1Of2 obs)\n        | Waiting (q1, q2) -> EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenObsoleteRun snap obs =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs()\n        | Ready (v, q) -> q.Enqueue (Union2Of2 obs)\n        | Waiting (q1, q2) -> q2.Enqueue (Union2Of2 obs)\n\n    let ValueAndForever snap =\n        match snap.State with\n        | Forever v -> Some (v, true)\n        | Ready (v, _) -> Some (v, false)\n        | _ -> None\n\n  // combinators\n\n    let Join snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n        When snap onReady res\n        res\n\n    let JoinInner snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n            WhenObsolete snap y\n        When snap onReady res\n        res\n\n    let CreateForeverAsync a =\n        let o = Make (Waiting (Queue(), Queue()))\n        Async.StartTo a (MarkForever o)\n        o\n\n    let Sequence (snaps : seq<Snap<'T>>) =\n        let snaps = Array.ofSeq snaps\n        if Array.isEmpty snaps then CreateForever Seq.empty\n        else\n            let res = Create () : Snap<seq<'T>>\n            let w = ref (snaps.Length - 1)\n            let cont _ =\n                if !w = 0 then\n                    // all source snaps should have a value\n                    let vs = \n                        snaps |> Array.map (fun s -> \n                            match s.State with\n                            | Forever v | Ready (v, _) -> v\n                            | _ -> failwith \"value not found by View.Sequence\")\n                    if Array.forall IsForever snaps then\n                        MarkForever res (vs :> seq<_>)\n                    else\n                        MarkReady res (vs :> seq<_>)\n                else\n                    decr w\n            snaps\n            |> Array.iter (fun s -> When s cont res)\n            res\n\n    let Map fn sn =\n        match sn.State with\n        | Forever x -> CreateForever (fn x) // optimization\n        | _ ->\n            let res = Create ()\n            When sn (fun a -> MarkDone res sn (fn a)) res\n            res\n\n    let WithInit x sn =\n        match sn.State with\n        | Forever _\n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = CreateWithValue x\n            When sn (fun _ -> Snap.Obsolete res) res\n            res\n\n    let WithInitOption sn =\n        match sn.State with\n        | Forever x -> CreateForever (Some x) // optimization\n        | Obsolete -> { State = Obsolete }\n        | Ready (v, _) ->\n            let res = CreateWithValue (Some v)\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = CreateWithValue None\n            When sn (fun _ -> Snap.Obsolete res) res\n            res\n\n    let Copy sn =\n        match sn.State with\n        | Forever _ \n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = Create ()\n            When sn (MarkDone res sn) res\n            res\n\n    let MapCachedBy eq prev fn sn =\n        let fn x =\n            match !prev with\n            | Some (x', y) when eq x x' -> y\n            | _ ->\n                let y = fn x\n                prev := Some (x, y)\n                y\n        Map fn sn\n\n    let Map2Opt1 fn x sn2 = Map (fun y -> fn x y) sn2\n    let Map2Opt2 fn y sn1 = Map (fun x -> fn x y) sn1\n    let Map2 fn sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever x, Forever y -> CreateForever (fn x y) // optimization\n        | Forever x, _ -> Map2Opt1 fn x sn2 // optimize for known sn1\n        | _, Forever y -> Map2Opt2 fn y sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (x, f1), Some (y, f2) ->\n                        if f1 && f2 then\n                            MarkForever res (fn x y)\n                        else\n                            MarkReady res (fn x y) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map2Unit sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever (), Forever () -> CreateForever () // optimization\n        | Forever (), _ -> sn2 // optimize for known sn1\n        | _, Forever () -> sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont () =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (_, f1), Some (_, f2) ->\n                        if f1 && f2 then\n                            MarkForever res ()\n                        else\n                            MarkReady res () \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map3Opt1 fn x y sn3   = Map (fun z -> fn x y z) sn3\n    let Map3Opt2 fn x z sn2   = Map (fun y -> fn x y z) sn2\n    let Map3Opt3 fn x sn2 sn3 = Map2 (fun y z -> fn x y z) sn2 sn3\n    let Map3Opt4 fn y z sn1   = Map (fun x -> fn x y z) sn1\n    let Map3Opt5 fn y sn1 sn3 = Map2 (fun x z -> fn x y z) sn1 sn3\n    let Map3Opt6 fn z sn1 sn2 = Map2 (fun x y -> fn x y z) sn1 sn2\n    let Map3 fn sn1 sn2 sn3 =\n        match sn1.State, sn2.State, sn3.State with\n        | Forever x, Forever y, Forever z -> CreateForever (fn x y z)\n        | Forever x, Forever y, _         -> Map3Opt1 fn x y sn3  \n        | Forever x, _,         Forever z -> Map3Opt2 fn x z sn2  \n        | Forever x, _,         _         -> Map3Opt3 fn x sn2 sn3\n        | _,         Forever y, Forever z -> Map3Opt4 fn y z sn1  \n        | _,         Forever y, _         -> Map3Opt5 fn y sn1 sn3\n        | _,         _,         Forever z -> Map3Opt6 fn z sn1 sn2    \n        | _,         _,         _         ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2, ValueAndForever sn3 with\n                    | Some (x, f1), Some (y, f2), Some (z, f3) ->\n                        if f1 && f2 && f3 then\n                            MarkForever res (fn x y z)\n                        else\n                            MarkReady res (fn x y z) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            When sn3 cont res\n            res\n\n    let SnapshotOn sn1 sn2 =\n        let res = Create ()\n        let cont _ =\n            if not (IsDone res) then \n                match ValueAndForever sn1, ValueAndForever sn2 with\n                | Some (_, f1), Some (y, f2) ->\n                    if f1 || f2 then\n                        MarkForever res y \n                    else\n                        MarkReady res y\n                | _ -> ()\n        When sn1 cont res\n        WhenReady sn2 cont\n        res\n\n    let MapAsync fn snap =\n        let res = Create ()\n        When snap\n            (fun v -> Async.StartTo (fn v) (MarkDone res snap))\n            res\n        res\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n#nowarn \"40\" // AsyncAwait let rec\n\nopen System.Collections.Generic\nopen WebSharper\ntype private JS = WebSharper.JavaScript.JS\n\n[<JavaScript; AbstractClass>]\ntype Var<'T>() =\n    abstract Get : unit -> 'T\n    abstract Set : 'T -> unit\n    abstract SetFinal : 'T -> unit\n    member this.Value\n        with [<Inline>] get() = this.Get()\n        and [<Inline>] set v = this.Set v\n    abstract Update : ('T -> 'T) -> unit\n    abstract UpdateMaybe : ('T -> 'T option) -> unit\n    abstract View : View<'T>\n    abstract Id : string\n\nand [<JavaScript>] View<'T> =\n    | View of (unit -> Snap<'T>)\n\n[<AutoOpen>]\nmodule ViewOptimization =\n    open WebSharper.JavaScript\n    [<Inline \"$x\">]\n    let V (x: unit -> Snap<'T>) = View x\n    [<Inline \"$x\">]\n    let (|V|) (x: View<'T>) = let (View v) = x in v\n    [<Inline \"$x\">]\n    let getSnapV (x: Snap<View<'T>>) = Snap.Map (|V|) x\n    [<Inline \"$x\">]\n    let getSnapF (x: 'A -> View<'T>) = x >> (|V|)\n    [<Inline \"null\">]\n    let jsNull<'T>() = Unchecked.defaultof<'T>\n    [<Inline \"Error().stack\">]\n    let jsStack<'T>() = \"\"\n    \n/// Var either holds a Snap or is in Const state.\n[<JavaScript>]\ntype ConcreteVar<'T>(isConst: bool, initSnap: Snap<'T>, initValue: 'T) =\n    inherit Var<'T>()\n\n    let mutable isConst = isConst\n    let mutable current = initValue\n    let mutable snap = initSnap\n    let view = V (fun () -> snap)\n    let id = Fresh.Int()\n\n    override this.Get() = current\n\n    override this.Set(v) =\n        if isConst then\n            printfn \"WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete snap\n            current <- v\n            snap <- Snap.CreateWithValue v\n\n    override this.SetFinal(v) =\n        if isConst then\n            printfn \"WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete snap\n            isConst <- true\n            current <- v\n            snap <- Snap.CreateForever v\n\n    override this.Update(f) =\n        this.Set (f (this.Get()))\n\n    override this.UpdateMaybe(f) =\n        match f (this.Get()) with\n        | None -> ()\n        | Some v -> this.Set(v)\n\n    override this.View = view\n\n    override this.Id = \"uinref\" + string id\n\nand [<JavaScript; Sealed>] Var private () =\n\n    [<Inline>]\n    static let (?) x f = WebSharper.JavaScript.Pervasives.(?) x f\n\n    [<Inline>]\n    static let (?<-) x f v = WebSharper.JavaScript.Pervasives.(?<-) x f v\n\n    static member Create v =\n        ConcreteVar<'T>(false, Snap.CreateWithValue v, v)\n        :> Var<'T>\n\n    static member CreateLogged (name: string) v =\n        if IsClient then\n            if not (JS.Global?UINVars) then\n                JS.Global?UINVars <- [||]\n            let res = Var.Create v\n            JS.Global?UINVars?push([| name; unbox res |])\n            res\n        else\n            Var.Create v\n\n    static member Create() =\n        ConcreteVar<unit>(false, Snap.CreateWithValue(), ())\n        :> Var<unit>\n\n    static member CreateWaiting<'T>() =\n        ConcreteVar<'T>(false, Snap.Create(), jsNull<'T>())\n        :> Var<'T>\n\n    [<Inline>]\n    static member Get (var: Var<'T>) =\n        var.Get()\n\n    static member Set (var: Var<'T>) value =\n        var.Set(value)\n\n    static member SetFinal (var: Var<'T>) value =\n        var.SetFinal(value)\n\n    static member Update var fn =\n        Var.Set var (fn (Var.Get var))\n\n    [<Inline>]\n    static member GetId (var: Var<'T>) =\n        var.Id\n\ntype [<JavaScript>] Updates = \n    {\n        [<Name \"c\">] mutable Current : View<unit>\n        [<Name \"s\">] mutable Snap : Snap<unit>\n        [<Name \"v\">] VarView : View<unit>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Current = v\n                Snap = jsNull()\n                VarView = \n                    let obs () =\n                        let mutable c = var.Snap\n                        if obj.ReferenceEquals(c, null) then\n                            let (V observe) = var.Current\n                            c <- observe() |> Snap.Copy\n                            var.Snap <- c\n                            Snap.WhenObsoleteRun c (fun () -> \n                                var.Snap <- jsNull())\n                            c\n                        else c\n                    \n                    V obs\n            }\n        var\n\n    member this.Value\n        with [<Inline>] get() = this.Current\n        and set v =\n            let sn = this.Snap\n            if not (obj.ReferenceEquals(sn, null)) then\n                Snap.MarkObsolete sn\n            this.Current <- v\n\ntype ViewNode<'A,'B> =\n    {\n        [<Name \"e\">] NValue : 'B\n        [<Name \"r\">] NVar : Var<'A>\n        [<Name \"w\">] NView : View<'A>\n    }\n\ntype LazyView<'T> =\n    {\n        [<Name \"c\">] mutable Current : Snap<'T>\n        [<Name \"o\">] mutable Observe : unit -> Snap<'T>  \n    } \n\n[<JavaScript>]\n[<Sealed>]\ntype View =\n\n    [<Inline>]\n    static member FromVar (var: Var<'T>) =\n        var.View\n\n    static member CreateLazy observe =\n        let lv =\n            {\n                Current = jsNull()\n                Observe = observe \n            }\n        let obs () =\n            let mutable c = lv.Current\n            if obj.ReferenceEquals(c, null) then\n                c <- lv.Observe()\n                lv.Current <- c\n                if Snap.IsForever c then \n                    lv.Observe <- jsNull()\n                else\n                    Snap.WhenObsoleteRun c (fun () -> \n                        lv.Current <- jsNull()) \n                c\n            else c\n        V obs\n\n    static member Map fn (V observe) =\n        View.CreateLazy (fun () ->\n            observe () |> Snap.Map fn)\n\n    static member MapCachedBy eq fn (V observe) =\n        let vref = ref None\n        View.CreateLazy (fun () ->\n            observe () |> Snap.MapCachedBy eq vref fn)\n\n    static member MapCached fn v =\n        View.MapCachedBy (=) fn v\n\n    static member Map2 fn (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2 fn s1 s2)\n\n    static member Map2Unit (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2Unit s1 s2)\n\n    static member Map3 fn (V o1) (V o2) (V o3) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            let s3 = o3 ()\n            Snap.Map3 fn s1 s2 s3)\n\n    static member MapAsync fn (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.MapAsync fn)\n\n    static member MapAsync2 fn v1 v2 =\n        View.Map2 fn v1 v2 |> View.MapAsync id\n\n    static member TryGet (V observe) =\n        Snap.TryGet (observe ())\n\n    static member Get (f: 'T -> unit) (V observe) =\n        let ok = ref false\n        let rec obs () =\n            Snap.WhenRun (observe ())\n                (fun v ->\n                    if not !ok then\n                        ok := true\n                        f v)\n                (fun () -> if not !ok then obs ())\n        obs ()\n\n    static member WithInit (x: 'T) (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.WithInit x)\n\n    static member WithInitOption (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.WithInitOption)\n\n    static member GetAsync v =\n        Async.FromContinuations (fun (ok, _, _) -> View.Get ok v)\n\n    static member SnapshotOn def (V o1) (V o2) =\n        let sInit = Snap.CreateWithValue def\n\n        let obs () =\n            let s1 = o1 ()\n            if Snap.IsObsolete sInit then\n                let s2 = o2 ()\n                Snap.SnapshotOn s1 s2\n            else\n                Snap.WhenObsolete s1 sInit\n                sInit\n\n        View.CreateLazy obs\n\n     // Collections --------------------------------------------------------------\n\n    static member MapSeqCachedBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'A -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let res =\n                        if prevState.ContainsKey k\n                            then prevState.[k]\n                            else conv x\n                    newState.[k] <- res\n                    res)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCached conv view =\n        View.MapSeqCachedBy (fun x -> x) conv view\n\n    static member ConvertSeqNode conv value =\n        let var = Var.Create value\n        let view = View.FromVar var\n        {\n            NValue = conv view\n            NVar = var\n            NView = view\n        }\n\n    static member MapSeqCachedViewBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'K -> View<'A> -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let node =\n                        if prevState.ContainsKey k then\n                            let n = prevState.[k]\n                            Var.Set n.NVar x\n                            n\n                        else\n                            View.ConvertSeqNode (fun v -> conv k v) x\n                    newState.[k] <- node\n                    node.NValue)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCachedView conv view =\n        View.MapSeqCachedViewBy (fun x -> x) (fun _ v -> conv v) view\n\n    [<Inline>]\n    static member Convert<'A, 'B when 'A : equality> (f: 'A -> 'B) v =\n        View.MapSeqCached f v\n\n    [<Inline>]\n    static member ConvertBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'A -> 'B) v =\n        View.MapSeqCachedBy k f v\n\n    [<Inline>]\n    static member ConvertSeq<'A, 'B when 'A : equality> (f: View<'A> -> 'B) v =\n        View.MapSeqCachedView f v\n\n    [<Inline>]\n    static member ConvertSeqBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'K -> View<'A> -> 'B) v =\n        View.MapSeqCachedViewBy k f v\n\n  // More cominators ------------------------------------------------------------\n\n    static member Join (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.Join (getSnapV (observe ())))\n\n    static member Bind (fn: 'A -> View<'B>) view =\n        View.Join (View.Map fn view)\n\n    static member JoinInner (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.JoinInner (getSnapV (observe ())))\n\n    static member BindInner fn view =\n        View.JoinInner (View.Map fn view)\n\n    static member UpdateWhile def v1 v2 =\n        let value = ref def\n        View.BindInner (fun pred ->\n            if pred then\n                View.Map (fun v ->\n                    value := v\n                    v\n                ) v2   \n            else View.Const (!value) \n        ) v1\n\n    static member Sequence views =\n        View.CreateLazy(fun () ->\n            views\n            |> Seq.map (fun (V observe) -> observe ())\n            |> Snap.Sequence)\n\n    static member Const x =\n        let o = Snap.CreateForever x\n        V (fun () -> o)\n\n    static member ConstAsync a =\n        let o = Snap.CreateForeverAsync a\n        V (fun () -> o)\n\n    static member TryWith (f: exn -> View<'T>) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            with exn ->\n                let (V obs) = f exn\n                obs ()\n        )\n\n    static member TryFinally (f: unit -> unit) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            finally\n                f ()\n        )\n\n    static member Sink act (V observe) =\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn act (fun () ->\n                Async.Schedule loop)\n        Async.Schedule loop\n\n    static member RemovableSink act (V observe) =\n        let cont = ref true\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn\n                (fun x -> if !cont then act x)\n                (fun () -> if !cont then Async.Schedule loop)\n        Async.Schedule loop\n        fun () -> cont := false\n\n    static member AsyncAwait filter view =\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec remove =\n                View.RemovableSink (fun value ->\n                    if filter value then\n                        remove ()\n                        ok value\n                ) view\n            ()\n\n    static member Apply fn view =\n        View.Map2 (fun f x -> f x) fn view\n\ntype Var with\n\n    [<JavaScript>]\n    static member Lens (var: Var<_>) get update =\n        let id = Fresh.Id()\n        let view = var.View |> View.Map get\n\n        { new Var<'V>() with\n\n            member this.Get() =\n                get (var.Get())\n\n            member this.Set(v) =\n                var.Update(fun t -> update t v)\n\n            member this.SetFinal(v) =\n                this.Set(v)\n\n            member this.Update(f) =\n                var.Update(fun t -> update t (f (get t)))\n\n            member this.UpdateMaybe(f) =\n                var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n\n            member this.View =\n                view\n\n            member this.Id =\n                id\n        }\n\n    static member MapLens<'A, 'B, 'K when 'K : equality> (getKey: 'A -> 'K) (f: Var<'A> -> 'B) (var: Var<list<'A>>) : View<seq<'B>> =\n        var.View |> View.MapSeqCachedViewBy getKey (fun k v ->\n            let id = Fresh.Id()\n            let isThis a =\n                getKey a = k\n            f { new Var<'A>() with\n\n                member this.Get() =\n                    List.find isThis var.Value\n\n                member this.Set(v) =\n                    var.Update (List.replaceFirst isThis (fun _ -> v))\n\n                member this.SetFinal(v) =\n                    this.Set(v)\n\n                member this.Update(f) =\n                    var.Update(List.replaceFirst isThis f)\n\n                member this.UpdateMaybe(f) =\n                    var.Update(List.maybeReplaceFirst isThis f)\n\n                member this.View =\n                    v\n\n                member this.Id =\n                    id\n            }\n        )\n\n\n// These methods apply to any View<'A>, so we can use `type View with`\n// and they'll be compiled as normal instance methods on View<'A>.\ntype View<'T> with\n\n    [<JavaScript; Inline>]\n    member v.Map f = View.Map f v\n\n    //[<JavaScript; Inline>]\n    //member v.Map (f: System.Func<_, 'B>) =\n    //    View.Map (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.MapAsync f = View.MapAsync f v\n\n    //member v.MapAsync (f: System.Func<_, System.Threading.Tasks.Task<'B>>) =\n    //    v |> View.MapAsync (fun a ->\n    //        async {\n    //            let! res = f.Invoke(a) |> Async.AwaitTask\n    //            return res\n    //        })\n\n    [<JavaScript; Inline>]\n    member v.Bind f = View.Bind f v\n\n    [<JavaScript; Inline>]\n    member v.BindInner f = View.BindInner f v\n\n    //[<JavaScript; Inline>]\n    //member v.Bind (f: System.Func<_, View<'B>>) =\n    //    View.Bind (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.SnapshotOn init v' = View.SnapshotOn init v' v\n\n    [<JavaScript; Inline>]\n    member v.UpdateWhile init vPred = View.UpdateWhile init vPred v\n\n    [<JavaScript; Macro(typeof<Macros.VProp>)>]\n    member v.V = failwith \"View<'T>.V can only be called in an argument to a V-enabled function or if 'T = Doc.\" : 'T\n\ntype Var<'T> with\n\n    [<Macro(typeof<Macros.VProp>)>]\n    member this.V = this.View.V\n\n    [<JavaScript; Inline>]\n    member var.Lens get update =\n        Var.Lens var get update\n\n[<JavaScript>]\ntype FromView<'T>(view: View<'T>, set: 'T -> unit) =\n    inherit Var<'T>()\n\n    let id = Fresh.Int()\n    let mutable current =\n        match View.TryGet view with\n        | Some x -> x\n        | None -> jsNull<'T>()\n    let view = view |> View.Map (fun x -> current <- x; x)\n\n    override this.View = view\n\n    override this.Get() = current\n\n    override this.Set(x) = set x\n\n    override this.UpdateMaybe(f) =\n        view |> View.Get (fun x ->\n            match f x with\n            | None -> ()\n            | Some x -> set x\n        )\n\n    override this.Update(f) =\n        view |> View.Get (f >> set)\n\n    override this.SetFinal(x) = set x\n\n    override this.Id = \"uinref\" + string id\n\ntype Var with\n\n    [<JavaScript; Inline>]\n    static member Make view set =\n        FromView(view, set) :> Var<_>\n\ntype ViewBuilder =\n    | B\n\n    [<JavaScript; Inline>]\n    member b.Bind(x, f) = View.Bind f x\n\n    [<JavaScript; Inline>]\n    member b.Return x = View.Const x\n\n    [<JavaScript; Inline>]\n    member b.ReturnFrom(v: View<'T>) = v\n\n    [<JavaScript; Inline>]\n    member b.TryWith(v, f) = View.TryWith f v\n\n    [<JavaScript; Inline>]\n    member b.TryFinally(v, f) = View.TryFinally f v\n\ntype View with\n    [<JavaScript>]\n    static member Do = B\n\n[<Sealed; JavaScript>]\ntype Submitter<'T> (input: View<'T>, init: 'T) =\n    let var = Var.Create ()\n    let view = View.SnapshotOn init var.View input\n\n    [<Inline>]\n    member this.View = view\n\n    member this.Trigger() = var.Value <- ()\n\n    [<Inline>]\n    member this.Input = input\n\n[<Sealed; JavaScript>]\ntype Submitter =\n\n    [<Inline>]\n    static member CreateDefault input =\n        Submitter<_>(input, Unchecked.defaultof<_>)\n\n    [<Inline>]\n    static member Create input init =\n        Submitter<_>(input, init)\n\n    static member CreateOption input =\n        Submitter<_>(View.Map Some input, None)\n\n    [<Inline>]\n    static member View (s: Submitter<_>) =\n        s.View\n\n    [<Inline>]\n    static member Trigger (s: Submitter<_>) =\n        s.Trigger()\n\n    [<Inline>]\n    static member Input (s: Submitter<_>) =\n        s.Input\n\n[<AutoOpen>]\nmodule V =\n\n    [<Macro(typeof<Macros.V>)>]\n    let V (x: 'T) = View.Const x\n\n[<assembly:System.Runtime.CompilerServices.Extension>]\ndo ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\n\n[<JavaScript>]\ntype Key =\n    | Key of int\n\n    static member Fresh () = Key (Fresh.Int ())\n\n[<JavaScript>]\ntype Model<'I,'M>(var: Var<'M>, view: View<'I>) =\n\n    new (proj: Func<'M, 'I>, init: 'M) =\n        let var = Var.Create init\n        let view = View.Map proj.Invoke var.View\n        Model(var, view)\n\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.View = view\n\n[<JavaScript>]\n[<Sealed>]\ntype Model =\n\n    static member Create proj init =\n        Model(Func<_,_>(proj), init)\n\n    static member Update update (m: Model<'I, 'M>) =\n        Var.Update m.Var (fun x -> update x; x)\n\n    [<Inline>]\n    static member View (m: Model<'I, 'M>) =\n        m.View\n\ntype Storage<'T> =\n    [<Name \"SAppend\">]\n    abstract member Append : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SAppendMany\">]\n    abstract member AppendMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrepend\">]\n    abstract member Prepend : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrependMany\">]\n    abstract member PrependMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SInit\">]\n    abstract member Init : unit -> 'T[]\n    [<Name \"SRemoveIf\">]\n    abstract member RemoveIf : ('T -> bool) -> 'T [] -> 'T[]\n    [<Name \"SSetAt\">]\n    abstract member SetAt : int -> 'T -> 'T[] -> 'T[]\n    [<Name \"SSet\">]\n    abstract member Set : 'T seq -> 'T[]\n\ntype Serializer<'T> =\n    {\n        Encode : 'T -> obj\n        Decode : obj -> 'T\n    }\n\n[<JavaScript>]\nmodule Serializer =\n    open WebSharper\n    open WebSharper.JavaScript\n\n    let Default =\n        {\n            Encode = box\n            Decode = unbox\n        }\n\n    [<Inline>]\n    let Typed =\n        {\n            Encode = WebSharper.Json.Encode<'T>\n            Decode = WebSharper.Json.Decode<'T>\n        }\n\n[<JavaScript>]\nmodule Storage =\n    open WebSharper\n    open WebSharper.JavaScript\n    \n    type private ArrayStorage<'T>(init) =\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Init () = init\n            member x.RemoveIf pred arr = Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; arr\n            member x.Set coll = Seq.toArray coll\n\n    type private LocalStorageBackend<'T>(id : string, serializer : Serializer<'T>) =\n        let storage = JS.Window.LocalStorage\n        let set (arr : 'T[]) = \n            storage.SetItem(id, arr |> Array.map serializer.Encode |> Json.Stringify)\n            arr\n        let clear () = storage.RemoveItem(id)\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; set arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; set arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; set arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; set arr\n\n            member x.Init () =\n                let item = storage.GetItem(id)\n                if item = null then [||]\n                else \n                    try\n                        let arr = As<obj []> <| Json.Parse(item)\n                        arr |> Array.map serializer.Decode\n                    with _ -> [||]\n\n            member x.RemoveIf pred arr = set <| Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; set arr\n            member x.Set coll = set <| Seq.toArray coll\n\n    let InMemory init =\n        new ArrayStorage<_>(init) :> Storage<_>\n\n    let LocalStorage id serializer =\n        new LocalStorageBackend<_>(id, serializer) :> Storage<_>\n\ntype ListModelState<'T> =\n    [<Inline>]\n    member this.Length =\n        JavaScript.Pervasives.As<'T[]>(this).Length\n    [<Inline>]\n    member this.Item\n        with get i = JavaScript.Pervasives.As<'T[]>(this).[i]\n    [<Inline>]\n    member this.ToArray() =                             \n        Array.copy (JavaScript.Pervasives.As<'T[]>(this))\n    [<Inline>]\n    member this.ToArray(pred: Predicate<'T>) =\n        Array.filter pred.Invoke (JavaScript.Pervasives.As<'T[]>(this))\n    interface seq<'T> with\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T[]>(this)).GetEnumerator()\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T seq>(this)).GetEnumerator()\n\n[<JavaScript>]\ntype ListModel<'Key, 'T when 'Key : equality>\n    (\n        key : System.Func<'T, 'Key>,\n        var: Var<'T[]>,\n        storage : Storage<'T>\n    ) =\n\n    let v = var.View.Map(fun x -> Array.copy x :> _ seq)\n           \n    let it = Dictionary<'Key, Snap<option<'T>>>()\n\n    new (key: System.Func<'T, 'Key>, init: seq<'T>) =\n        let init = Seq.toArray init\n        ListModel<'Key, 'T>(key, Var.Create init, Storage.InMemory init)\n\n    new (key: System.Func<'T, 'Key>) =\n        ListModel<'Key, 'T>(key, [||])\n\n    new (key: System.Func<'T, 'Key>, storage: Storage<'T>) =\n        let var =\n            Seq.distinctBy key.Invoke (storage.Init ())\n            |> Seq.toArray\n            |> Var.Create\n        ListModel<'Key, 'T>(key, var, storage)\n\n    [<Inline>]\n    member this.key x = key.Invoke x\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.Storage = storage\n    [<Inline>]\n    member this.View = v\n    [<Inline>]\n    member this.ViewState = JavaScript.Pervasives.As<View<ListModelState<'T>>> var.View\n    [<Inline>]\n    member this.itemSnaps = it\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            (Seq.ofArray var.Value).GetEnumerator()\n\n        member this.GetEnumerator() =\n            var.Value.GetEnumerator()\n\n[<JavaScript>]\nmodule ListModels =\n               \n    let Contains keyFn item xs =\n        let t = keyFn item\n        Array.exists (fun it -> keyFn it = t) xs\n\ntype ListModel<'Key,'T when 'Key : equality> with\n\n    [<Inline>]\n    member m.Key x = m.key x\n\n    [<Inline>]\n    member m.Add item =\n        m.Append item\n\n    member m.ObsoleteKey key =\n        match m.itemSnaps.TryGetValue(key) with\n        | true, sn ->\n            Snap.MarkObsolete sn \n            m.itemSnaps.Remove key |> ignore\n        | _ -> ()\n\n    member m.ObsoleteAll() =\n        m.itemSnaps |> Seq.iter (fun ksn -> Snap.MarkObsolete ksn.Value)\n        m.itemSnaps.Clear()\n\n    member m.Append item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Append item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.AppendMany items =\n        let toAppend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index ->\n                    m.Storage.SetAt index item v\n                | None -> toAppend.Add item; v)\n        m.Var.Value <- m.Storage.AppendMany toAppend v\n\n    member m.Prepend item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Prepend item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.PrependMany items =\n        let toPrepend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index -> \n                    m.Storage.SetAt index item v\n                | None -> toPrepend.Add item; v)\n        m.Var.Value <- m.Storage.PrependMany toPrepend v\n\n    member m.Remove item =\n        let v = m.Var.Value\n        if ListModels.Contains m.key item v then\n            let keyFn = m.key\n            let k = keyFn item\n            m.Var.Value <- m.Storage.RemoveIf (fun i -> keyFn i = k) v\n            m.ObsoleteKey k\n\n    member m.RemoveBy (f: 'T -> bool) =\n        for v in m.Var.Value do\n            if f v then\n                m.ObsoleteKey (m.key v)\n        m.Var.Value <- m.Storage.RemoveIf f m.Var.Value\n\n    member m.RemoveByKey key =\n        m.Var.Value <- m.Storage.RemoveIf (fun i -> m.Key i = key) m.Var.Value\n        m.ObsoleteKey key\n\n    member m.Iter fn =\n        Array.iter fn m.Var.Value\n\n    member m.Set lst =\n        m.Var.Value <- m.Storage.Set lst\n        m.ObsoleteAll()\n\n    member m.ContainsKey key =\n        Array.exists (fun it -> m.key it = key) m.Var.Value\n\n    member m.ContainsKeyAsView key =\n        m.Var.View |> View.Map (Array.exists (fun it -> m.key it = key))\n\n    member m.Find pred =\n        Array.find pred m.Var.Value\n\n    member m.TryFind pred =\n        Array.tryFind pred m.Var.Value\n\n    member m.FindAsView pred =\n        m.Var.View |> View.Map (Array.find pred)\n\n    member m.TryFindAsView pred =\n        m.Var.View |> View.Map (Array.tryFind pred)\n\n    member m.FindByKey key =\n        Array.find (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKey key =\n        Array.tryFind (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKeyAsView key =\n        ViewOptimization.V (fun () -> \n            match m.itemSnaps.TryGetValue(key) with\n            | true, snap -> snap                \n            | _ ->\n                let it = m.TryFindByKey(key)\n                let sn = Snap.CreateWithValue it\n                m.itemSnaps.Add(key, sn)\n                sn\n        )\n\n    member m.FindByKeyAsView key =\n        m.TryFindByKeyAsView key |> View.Map Option.get\n\n    member m.UpdateAll fn =\n        m.Var.Update <| fun a ->\n            a |> Array.iteri (fun i x ->\n                fn x |> Option.iter (fun y -> a.[i] <- y))\n            m.Storage.Set a\n        m.ObsoleteAll()\n\n    member m.UpdateBy fn key =\n        let v = m.Var.Value\n        match Array.tryFindIndex (fun it -> m.key it = key) v with\n        | None -> ()\n        | Some index ->\n            match fn v.[index] with\n            | None -> ()\n            | Some value ->\n                m.Var.Value <- m.Storage.SetAt index value v\n                m.ObsoleteKey key\n\n    [<Inline>]\n    member m.UpdateByU(fn, key) =\n        m.UpdateBy fn key\n\n    member m.Clear () =\n        m.Var.Value <- m.Storage.Set Seq.empty\n        m.ObsoleteAll()\n\n    member m.Length =\n        m.Var.Value.Length\n\n    member m.LengthAsView =\n        m.Var.View |> View.Map (fun arr -> arr.Length)\n\n    member private m.LensInto'(get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key, view: View<'V>) : Var<'V> =\n        let id = Fresh.Id()\n    \n        { new Var<'V>() with\n\n            member r.Get() =\n                m.FindByKey key |> get\n\n            member r.Set(v) =\n                m.UpdateBy (fun i -> Some (update i v)) key\n\n            member r.SetFinal(v) =\n                r.Set(v)\n\n            member r.Update(f) =\n                m.UpdateBy (fun i -> Some (update i (f (get i)))) key\n\n            member r.UpdateMaybe(f) =\n                m.UpdateBy (fun i -> Option.map (fun v -> update i v) (f (get i))) key\n\n            member r.View =\n                view\n\n            member r.Id =\n                id\n        }\n\n    member m.LensInto (get: 'T -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) : Var<'V> =\n        let view = m.FindByKeyAsView(key) |> View.Map get\n        m.LensInto'(get, update, key, view)\n\n    [<Inline>]\n    member m.LensIntoU<'V> (get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key) : Var<'V> =\n        m.LensInto get update key\n\n    member m.Lens (key: 'Key) =\n        m.LensInto id (fun _ -> id) key\n\n    member m.Value\n        with [<Inline>] get () = m.Var.Value :> seq<_>\n        and [<Inline>] set v = m.Set(v)\n\n    [<Inline>]\n    member m.Map (f: 'T -> 'V) : View<seq<'V>> =\n        View.MapSeqCachedBy m.key f m.ViewState\n\n    [<Inline>]\n    member m.Map (f: 'Key -> View<'T> -> 'V) : View<seq<'V>> =\n        View.MapSeqCachedViewBy m.key f m.ViewState\n\n    member m.MapLens (f: 'Key -> Var<'T> -> 'V) =\n        let get k v =\n            f k (m.LensInto'(id, (fun _ -> id), k, v))\n        View.MapSeqCachedViewBy m.key get m.ViewState\n\n[<JavaScript>]\ntype ListModel =\n\n    static member CreateWithStorage<'Key,'T when 'Key : equality>\n            (key: 'T -> 'Key) (storage : Storage<'T>) =\n        ListModel<'Key, 'T>(key, storage)\n\n    static member Create<'Key, 'T when 'Key : equality> (key: 'T -> 'Key) init =\n        ListModel.CreateWithStorage key (Storage.InMemory <| Seq.toArray init)\n\n    static member FromSeq init =\n        ListModel.Create id init\n\n    static member Wrap<'Key, 'T, 'U when 'Key : equality>\n            (underlying: ListModel<'Key, 'U>)\n            (extract: 'T -> 'U)\n            (createItem: 'U -> 'T)\n            (updateItem: 'T -> 'U -> 'T) =\n        let state = ref (Dictionary<'Key, 'T>())\n        let init =\n            underlying.Var.Value |> Array.map (fun u ->\n                let t = createItem u\n                (!state).[underlying.Key u] <- t\n                t)\n        let var : Var<'T[]> =\n            underlying.Var.Lens\n                <| fun us ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let ts =\n                        us |> Array.map (fun u ->\n                            let k = underlying.Key u\n                            let t =\n                                if (!state).ContainsKey(k) then\n                                    updateItem (!state).[k] u\n                                else\n                                    createItem u\n                            newState.[k] <- t\n                            t\n                        )\n                    state := newState\n                    ts\n                <| fun us ts ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let us =\n                        ts |> Array.map (fun t ->\n                            let u = extract t\n                            newState.[underlying.Key u] <- t\n                            u)\n                    state := newState\n                    us\n        ListModel<'Key, 'T>(Func<_,_>(extract >> underlying.Key), var, Storage.InMemory init)\n\n    [<Inline>]\n    static member View (m: ListModel<_,_>) =\n        m.View\n\n    [<Inline>]\n    static member ViewState (m: ListModel<_,_>) =\n        m.ViewState\n\n    [<Inline>]\n    static member Key (m: ListModel<_,_>) =\n        m.key\n\n    [<Inline>]\n    static member Map f (m: ListModel<_, _>) =\n        View.MapSeqCachedBy m.key f m.ViewState\n\n    [<Inline>]\n    static member MapView f (m: ListModel<_, _>) =\n        View.MapSeqCachedViewBy m.key f m.ViewState\n\n    [<Inline>]\n    static member MapLens f (m: ListModel<_, _>) =\n        m.MapLens f\n\ntype ListModel<'Key,'T when 'Key : equality> with\n\n    member this.Wrap extract wrap update =\n        ListModel.Wrap this extract wrap update\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System.Runtime.CompilerServices\nopen WebSharper\nopen WebSharper.JavaScript\ntype private KV<'K, 'V> = System.Collections.Generic.KeyValuePair<'K, 'V>\n\n[<AutoOpen>]\nmodule VarModule =\n\n    [<Macro(typeof<Macros.LensFunction>)>]\n    let Lens (x: 'T) = Var.Create x\n\n// These methods apply to specific types of View (such as View<seq<'A>> when 'A : equality)\n/// so we need to use C#-style extension methods.\n[<Extension; JavaScript>]\ntype ReactiveExtensions() =\n\n    [<Extension; Inline>]\n    static member MapCached (v, f) = View.MapCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<seq<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<seq<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<seq<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<seq<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<list<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<list<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<list<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<list<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<array<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<array<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<array<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<array<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<ListModelState<'A>>, f: 'A -> 'B) = View.MapSeqCached f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<ListModelState<'A>>, k: 'A -> 'K, f: 'A -> 'B) = View.MapSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v: View<ListModelState<'A>>, f: View<'A> -> 'B) = View.MapSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality>\n        (v: View<ListModelState<'A>>, k: 'A -> 'K, f: 'K -> View<'A> -> 'B) = View.MapSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B, 'K when 'K : equality and 'K : comparison>\n        (v: View<Map<'K, 'A>>, f: 'K -> View<'A> -> 'B) =\n        View.MapSeqCachedViewBy\n            (fun (kv: KV<'K, 'A>) -> kv.Key)\n            (fun k v -> f k (View.Map (fun (kv: KV<'K, 'A>) -> kv.Value) v))\n            v\n\n    [<Extension; Macro(typeof<Macros.LensMethod>)>]\n    static member LensAuto<'T, 'U>(ref: Var<'T>, getter: 'T -> 'U) = X<Var<'U>>\n\n    [<Extension; Inline>]\n    static member MapLens<'A, 'B, 'K when 'K : equality>(v: Var<list<'A>>, k: 'A -> 'K, f: Var<'A> -> 'B) = Var.MapLens k f v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype Time = double\ntype NormalizedTime = double\n\n// Interpolation --------------------------------------------------------------\n\ntype Interpolation<'T> =\n    [<Name \"Interpolate\">]\n    abstract Interpolate : NormalizedTime -> 'T -> 'T -> 'T\n\n[<JavaScript>]\ntype DoubleInterpolation =\n    | DoubleInterpolation\n\n    interface Interpolation<double> with\n        member d.Interpolate t x y =\n            x + t * (y - x)\n\n[<JavaScript>]\n[<Sealed>]\ntype Interpolation =\n    static member Double = DoubleInterpolation :> Interpolation<_>\n\n// Easing ---------------------------------------------------------------------\n\n[<JavaScript>]\ntype Easing (transformTime : Converter<NormalizedTime, NormalizedTime>) =\n\n    member this.TransformTime t = transformTime.Invoke t\n    static member Custom f = Easing (fun t -> f t)\n\n[<JavaScript>]\nmodule Easings =\n\n    let CubicInOut =\n        let f t =\n            let t2 = t * t\n            let t3 = t2 * t\n            3. * t2 - 2. * t3\n        Easing.Custom f\n\ntype Easing with\n    static member CubicInOut = Easings.CubicInOut\n\n// Animation ------------------------------------------------------------------\n\ntype Anim<'T> =\n    private {\n        Compute : Time -> 'T\n        Duration : Time\n    }\n\ntype Animation =\n    | Finally of (unit -> unit)\n    | Work of Anim<unit>\n\n[<JavaScript>]\n[<Name \"An\">]\ntype Anim =\n    | Anim of AppendList<Animation>\n\n[<JavaScript>]\nmodule Anims =\n\n    let List (Anim xs) =\n        xs\n\n    let Finalize (Anim all) =\n        AppendList.ToArray all\n        |> Array.iter (function\n            | Finally f -> f ()\n            | _ -> ())\n\n    let Def d f =\n        { Compute = f; Duration = d}\n\n    let Const v =\n        Def 0. (fun t -> v)\n\n    // \"Prolongs\" an animation to the given time by adding in several\n    // no-ops after the animation finishes.\n    let Prolong nextDuration anim =\n        let comp = anim.Compute\n        let dur = anim.Duration\n        let last = lazy anim.Compute anim.Duration\n        let compute t = if t >= dur then last.Value else comp t\n\n        {\n            Compute = compute\n            Duration = nextDuration\n        }\n\n    let ConcatActions xs =\n        let xs = Array.ofSeqNonCopying xs\n        match xs.Length with\n        | 0 -> Const ()\n        | 1 -> xs.[0]\n        | _ ->\n            let dur = xs |> Seq.map (fun anim -> anim.Duration) |> Seq.max\n            let xs = Array.map (Prolong dur) xs\n            Def dur (fun t -> Array.iter (fun anim -> anim.Compute t) xs)\n\n    let Actions (Anim all) =\n        AppendList.ToArray all\n        |> Array.choose (function\n            | Work w -> Some w\n            | _ -> None)\n        |> ConcatActions\n\n    let mutable UseAnimations = true\n\ntype Anim with\n\n    static member UseAnimations \n        with get() = Anims.UseAnimations\n        and set v = Anims.UseAnimations <- v \n\n    static member Append (Anim a) (Anim b) =\n        Anim (AppendList.Append a b)\n\n    static member Concat xs =\n        xs\n        |> Seq.map Anims.List\n        |> AppendList.Concat\n        |> Anim\n\n    static member Const v =\n        Anims.Const v\n\n    static member Simple (inter: Interpolation<'T>) (easing: Easing) dur x y=\n        {\n            Duration = dur\n            Compute = fun t ->\n                let t = easing.TransformTime (t / dur)\n                inter.Interpolate t x y\n        }\n\n    static member Delayed (inter: Interpolation<'T>) (easing: Easing) dur delay x y =\n        {\n            Duration = dur + delay\n            Compute = fun t ->\n              //  JavaScript.Log <| \"T: \" + (string t) + \", delay: \" + (string delay)\n                if t <= delay then\n                    x\n                else\n                    let normalisedTime = easing.TransformTime ((t - delay) / dur)\n                    inter.Interpolate normalisedTime x y\n        }\n\n    static member Map f anim =\n        Anims.Def anim.Duration (anim.Compute >> f)\n\n    static member Pack anim =\n        Anim (AppendList.Single (Work anim))\n\n    static member Play anim =\n        async {\n            do! Anims.Actions anim\n                |> Anim.Run ignore\n            return Anims.Finalize anim\n        }\n\n    static member Run k anim =\n        let dur = anim.Duration\n        if dur = 0. then async.Zero() else\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec loop start now =\n                let t = now - start\n                k (anim.Compute t)\n                if t <= dur then\n                    JS.RequestAnimationFrame (fun t -> loop start t) |> ignore\n                else ok ()\n            JS.RequestAnimationFrame (fun t -> loop t t) |> ignore\n\n    static member WhenDone f main =\n        main\n        |> Anim.Append (Anim (AppendList.Single (Finally f)))\n\n    static member Empty =\n        Anim AppendList.Empty\n\n// Transitions ----------------------------------------------------------------\n\ntype TFlags =\n    | TTrivial = 0\n    | TChange = 1\n    | TEnter = 2\n    | TExit = 4\n\n[<JavaScript>]\ntype Trans<'T>\n    (\n        change: Func<'T, 'T, Anim<'T>>,\n        enter: Func<'T, Anim<'T>>,\n        exit: Func<'T, Anim<'T>>,\n        flags: TFlags\n    ) =\n\n    new () =\n        Trans(\n            (fun x y -> Anim.Const y),\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TTrivial\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>) =\n        Trans(\n            ch,\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TChange\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>, enter, exit) =\n        Trans(\n            ch,\n            (if enter = null then Func<_,_>(fun t -> Anim.Const t) else enter),\n            (if exit = null then Func<_,_>(fun t -> Anim.Const t) else exit),\n            TFlags.TChange ||| \n                (if enter = null then TFlags.TTrivial else TFlags.TEnter) |||\n                (if exit = null then TFlags.TTrivial else TFlags.TExit)\n        )\n\n    member this.TChange x y = change.Invoke(x, y)\n    member this.TEnter = enter.Invoke\n    member this.TExit = exit.Invoke\n    member this.TFlags = flags\n\n    member this.Copy(?change, ?enter, ?exit, ?flags) =\n        let ch = defaultArg change this.TChange\n        let en = defaultArg enter this.TEnter\n        let ex = defaultArg exit this.TExit\n        let fl = defaultArg flags this.TFlags\n        Trans(Func<_,_,_>(ch), Func<_,_>(en),\n            Func<_,_>(ex), fl)\n\n[<JavaScript>]\n[<Sealed>]\ntype Trans =\n\n  // Using a Trans ---------------\n\n    static member AnimateChange (tr: Trans<'T>) x y = tr.TChange x y\n    static member AnimateEnter (tr: Trans<'T>) x = tr.TEnter x\n    static member AnimateExit (tr: Trans<'T>) x = tr.TExit x\n    static member CanAnimateChange (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TChange)\n    static member CanAnimateEnter (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TEnter)\n    static member CanAnimateExit (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TExit)\n\n  // Creating a Trans ------------\n\n    static member Trivial () =\n        Trans()\n\n    static member Create (ch: 'T -> 'T -> Anim<'T>) =\n        Trans(Func<_,_,_>(ch))\n\n    static member Change ch (tr: Trans<'T>) =\n        tr.Copy(change = ch, flags = (tr.TFlags ||| TFlags.TChange))\n\n    static member Enter f (tr: Trans<'T>) =\n        tr.Copy(enter = f, flags = (tr.TFlags ||| TFlags.TEnter))\n\n    static member Exit f (tr: Trans<'T>) =\n        tr.Copy(exit = f, flags = (tr.TFlags ||| TFlags.TExit))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen System\nopen System.Linq.Expressions\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Core.Resources\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\nmodule J = WebSharper.Core.Json\nmodule P = FSharp.Quotations.Patterns\n\nmodule private Internal =\n\n    open WebSharper.Core\n    open WebSharper.Web.ClientSideInternals\n\n    let activateNode =\n        M.MethodNode(\n            AST.TypeDefinition {\n                Assembly = \"WebSharper.Main\"\n                FullName = \"WebSharper.Activator\"\n            },\n            AST.Method {\n                MethodName = \"Activate\"\n                Parameters = []\n                ReturnType = AST.VoidType\n                Generics = 0\n            } \n        )\n\n    let compile (meta: M.Info) (json: J.Provider) (q: Expr) (doCall: string -> string) =\n        let reqs = ResizeArray<M.Node>()\n        let rec compile' (q: Expr) =\n            match getLocation q with\n            | Some p ->\n                match meta.Quotations.TryGetValue(p) with\n                | false, _ ->\n                    None\n                | true, (declType, meth, argNames) ->\n                    match meta.Classes.TryGetValue declType with\n                    | false, _ -> failwithf \"Error in Handler: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                    | true, c ->\n                        let argIndices = Map (argNames |> List.mapi (fun i x -> x, i))\n                        let args = Array.create argNames.Length null\n                        reqs.Add(M.MethodNode (declType, meth))\n                        reqs.Add(M.TypeNode declType)\n                        let setArg (name: string) (value: obj) =\n                            let i = argIndices.[name]\n                            if isNull args.[i] then\n                                args.[i] <-\n                                    match value with\n                                    | :? Expr as q ->\n                                        compile' q |> Option.get\n                                    | value ->\n                                        let typ = value.GetType()\n                                        reqs.Add(M.TypeNode (WebSharper.Core.AST.Reflection.ReadTypeDefinition typ))\n                                        let packed = json.GetEncoder(typ).Encode(value) |> json.Pack\n                                        let s =\n                                            WebSharper.Core.Json.Stringify(packed)\n                                                .Replace(\"&\", \"&amp;\")\n                                                .Replace(\"\\\"\", \"&quot;\")\n                                        match packed with\n                                        | WebSharper.Core.Json.Object (((\"$TYPES\" | \"$DATA\"), _) :: _) ->\n                                            \"WebSharper.Json.Activate(\" + s + \")\"\n                                        | _ -> s\n                        findArgs Set.empty setArg q\n                        let addr =\n                            match c.Methods.TryGetValue meth with\n                            | true, (M.CompiledMember.Static x, _, _) -> x.Value\n                            | _ -> failwithf \"Error in Handler: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                        let funcall = String.concat \".\" (List.rev addr)\n                        let args = String.concat \",\" args\n                        Some (sprintf \"%s(%s)\" funcall args)\n            | None -> None\n        compile' q\n        |> Option.map (fun s ->\n            reqs.Add(activateNode)\n            doCall s, reqs :> seq<_>\n        )\n\ntype private OnAfterRenderControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body =\n        let l = JS.Document.QuerySelectorAll(\"[ws-runafterrender]\")\n        for i = 0 to l.Length - 1 do\n            let x = l.[i] :?> Dom.Element\n            let f = JS.Eval(x.GetAttribute(\"ws-runafterrender\")) :?> (Dom.Element -> unit)\n            x.RemoveAttribute(\"ws-runafterrender\")\n            f x\n        { new IControlBody with member this.ReplaceInDom(_) = () }\n\n// We would have wanted to use UseNullAsTrueValue so that EmptyAttr = null,\n// which makes things much easier when it comes to optional arguments in Templating.\n// The problem is that for some reason UNATV is ignored if there are 4 or more cases.\n// So we end up having to do explicit null checks everywhere :(\ntype Attr =\n    | AppendAttr of list<Attr>\n    | SingleAttr of string * string\n    | DepAttr of string * (M.Info -> string) * (M.Info -> seq<M.Node>) * (M.Info -> J.Provider -> list<string * J.Encoded>)\n\n    member this.Write(meta, w: HtmlTextWriter, removeWsHole) =\n        match this with\n        | AppendAttr attrs ->\n            attrs |> List.iter (fun a ->\n                if not (obj.ReferenceEquals(a, null))\n                then a.Write(meta, w, removeWsHole))\n        | SingleAttr (n, v) ->\n            if not (removeWsHole && n = \"ws-hole\") then\n                w.WriteAttribute(n, v)\n        | DepAttr (n, v, _, _) ->\n            w.WriteAttribute(n, v meta)\n\n    interface IRequiresResources with\n\n        member this.Requires(meta) =\n            match this with\n            | AppendAttr attrs ->\n                attrs |> Seq.collect (fun a ->\n                    if obj.ReferenceEquals(a, null)\n                    then Seq.empty\n                    else (a :> IRequiresResources).Requires(meta))\n            | DepAttr (_, _, reqs, _) -> reqs meta\n            | SingleAttr _ -> Seq.empty\n\n        member this.Encode (meta, json) =\n            match this with\n            | AppendAttr attrs ->\n                attrs |> List.collect (fun a ->\n                    if obj.ReferenceEquals(a, null)\n                    then []\n                    else (a :> IRequiresResources).Encode(meta, json))\n            | DepAttr (_, _, _, enc) -> enc meta json\n            | SingleAttr _ -> []\n\n    member this.WithName(n) =\n        match this with\n        | AppendAttr _ -> this\n        | SingleAttr(_, v) -> SingleAttr(n, v)\n        | DepAttr(_, v, d, e) -> DepAttr(n, v, d, e)\n\n    static member Create name value =\n        SingleAttr (name, value)\n\n    static member Append a b =\n        AppendAttr [a; b]\n\n    static member Empty =\n        AppendAttr []\n\n    static member Concat (xs: seq<Attr>) =\n        AppendAttr (List.ofSeq xs)\n\n    static member WithDependencies(name, getValue, deps) =\n        DepAttr (name, getValue, deps, fun _ _ -> [])\n\n    static member OnAfterRenderImpl(q: Expr<Dom.Element -> unit>) =\n        let json = WebSharper.Web.Shared.Json // TODO: fix?\n        let value = ref None\n        let init meta =\n            if Option.isNone !value then\n                value :=\n                    match Internal.compile meta json q id with\n                    | Some _ as v -> v\n                    | _ ->\n                        let m =\n                            match q with\n                            | Lambda (x1, Call(None, m, [Var x2])) when x1 = x2 -> m\n                            | _ -> failwithf \"Invalid handler function: %A\" q\n                        let loc = WebSharper.Web.ClientSideInternals.getLocation' q\n                        let func, reqs = Attr.HandlerFallback(m, loc, id)\n                        Some (func meta, reqs)\n        let getValue (meta: M.Info) =\n            init meta\n            fst (Option.get !value)\n        let getReqs (meta: M.Info) =\n            init meta\n            snd (Option.get !value)\n        let enc (meta: M.Info) (json: J.Provider) =\n            init meta\n            (new OnAfterRenderControl() :> IRequiresResources).Encode(meta, json)\n        DepAttr(\"ws-runafterrender\", getValue, getReqs, enc)\n\n    static member HandlerImpl(event: string, q: Expr<Dom.Element -> #Dom.Event -> unit>) =\n        let json = WebSharper.Web.Shared.Json // TODO: fix?\n        let value = ref None\n        let init meta =\n            if Option.isNone !value then\n                value :=\n                    match Internal.compile meta json q (fun s -> s + \"(this)(event)\") with\n                    | Some _ as v -> v\n                    | _ ->\n                        let m =\n                            match q with\n                            | Lambda (x1, Lambda (y1, Call(None, m, [Var x2; (Var y2 | Coerce(Var y2, _))]))) when x1 = x2 && y1 = y2 -> m\n                            | _ -> failwithf \"Invalid handler function: %A\" q\n                        let loc = WebSharper.Web.ClientSideInternals.getLocation' q\n                        let func, reqs = Attr.HandlerFallback(m, loc, fun s -> s + \"(this, event)\")\n                        Some (func meta, reqs)\n        let getValue (meta: M.Info) =\n            init meta\n            fst (Option.get !value)\n        let getReqs (meta: M.Info) =\n            init meta\n            snd (Option.get !value)\n        Attr.WithDependencies(\"on\" + event, getValue, getReqs)\n\n    static member Handler (event: string) ([<JavaScript>] q: Expr<Dom.Element -> #Dom.Event -> unit>) =\n        Attr.HandlerImpl(event, q)\n\n    static member HandlerFallback(m, location, doCall) =\n        let meth = R.ReadMethod m\n        let declType = R.ReadTypeDefinition m.DeclaringType\n        let reqs = [M.MethodNode (declType, meth); M.TypeNode declType]\n        let value = ref None\n        let fail() =\n            failwithf \"Error in Handler%s: Couldn't find JavaScript address for method %s.%s\"\n                location declType.Value.FullName meth.Value.MethodName\n        let func (meta: M.Info) =\n            match !value with\n            | None ->\n                match meta.Classes.TryGetValue declType with\n                | true, c ->\n                    let addr =\n                        match c.Methods.TryGetValue meth with\n                        | true, (M.CompiledMember.Static x, _, _) -> x.Value\n                        | _ -> fail()\n                    let s = String.concat \".\" (List.rev addr) |> doCall\n                    value := Some s\n                    s\n                | _ -> fail()\n            | Some v -> v\n        func, reqs :> seq<_>\n\n    static member HandlerLinqImpl(event, m, location) =\n        let func, reqs = Attr.HandlerFallback(m, location, fun s -> s + \"(this, event)\")\n        DepAttr (\"on\" + event, func, (fun _ -> reqs), (fun _ _ -> []))\n\n    static member HandlerLinq (event: string) (q: Expression<Action<Dom.Element, #Dom.Event>>) =\n        let meth =\n            match q.Body with\n            | :? MethodCallExpression as e -> e.Method\n            | _ -> failwithf \"Invalid handler function: %A\" q\n        Attr.HandlerLinqImpl(event, meth, \"\")\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Client\n\nopen System.Collections.Generic\nopen Microsoft.FSharp.Quotations\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nmodule DU = DomUtility\n\ntype IAttrNode =\n    [<Name \"NChanged\">]\n    abstract Changed : View<unit>\n    [<Name \"NGetChangeAnim\">]\n    abstract GetChangeAnim : Dom.Element -> Anim\n    [<Name \"NGetEnterAnim\">]\n    abstract GetEnterAnim : Dom.Element -> Anim\n    [<Name \"NGetExitAnim\">]\n    abstract GetExitAnim : Dom.Element -> Anim\n    [<Name \"NSync\">]\n    abstract Sync : Dom.Element -> unit\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.AnimatedAttrNode\">]\ntype AnimatedAttrNode<'T>(tr: Trans<'T>, view: View<'T>, push: Dom.Element -> 'T -> unit) =\n    let mutable logical : option<'T> = None // current logical value\n    let mutable visible : option<'T> = None // current value pushed to the parent element\n    let mutable dirty = true // logical <> visible\n\n    let updates =\n        view\n        |> View.Map (fun x ->\n            logical <- Some x\n            dirty <- true)\n\n    let pushVisible el v =\n        visible <- Some v\n        dirty <- true\n        push el v\n\n    let sync p =\n        if dirty then\n            Option.iter (fun v -> push p v) logical\n            visible <- logical\n            dirty <- false\n\n    interface IAttrNode with\n\n        member a.GetChangeAnim parent =\n            match visible, logical with\n            | Some v, Some l when dirty ->\n                Trans.AnimateChange tr v l\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetEnterAnim parent =\n            match visible, logical with\n            | Some vi, Some lo when dirty ->\n                Trans.AnimateChange tr vi lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | None, Some lo ->\n                Trans.AnimateEnter tr lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetExitAnim parent =\n            match visible with\n            | Some cur ->\n                Trans.AnimateExit tr cur\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> dirty <- true; visible <- None)\n\n        /// NOTE: enter or change animation will do the sync.\n        member a.Sync parent = ()\n\n        member a.Changed = updates\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.DynamicAttrNode\">]\ntype DynamicAttrNode<'T>(view: View<'T>, push: Dom.Element -> 'T -> unit) =\n    let mutable value = JS.Undefined\n    let mutable dirty = false\n    let updates = view |> View.Map (fun x -> value <- x; dirty <- true)\n    interface IAttrNode with\n        member a.GetChangeAnim parent = Anim.Empty\n        member a.GetEnterAnim parent = Anim.Empty\n        member a.GetExitAnim parent = Anim.Empty\n        member a.Sync parent = if dirty then push parent value; dirty <- false\n        member a.Changed = updates\n\ntype AttrFlags =\n    | Defaults = 0\n    | HasEnterAnim = 1\n    | HasExitAnim = 2\n    | HasChangeAnim = 4\n\n[<JavaScript; Proxy(typeof<Attr>); Name \"WebSharper.UI.AttrProxy\"; Prototype>]\ntype internal AttrProxy =\n    | [<Constant(null)>] A0\n    | A1 of IAttrNode\n    | A2 of AttrProxy * AttrProxy\n    | A3 of init: (Dom.Element -> unit)\n    | A4 of onAfterRender: (Dom.Element -> unit)\n\n[<JavaScript; Name \"WebSharper.UI.Attrs\">]\nmodule Attrs =\n\n    type Dyn =\n        {\n            DynElem : Dom.Element\n            DynFlags : AttrFlags\n            DynNodes : IAttrNode []\n            [<OptionalField>]\n            OnAfterRender : option<Dom.Element -> unit>\n        }\n\n    let HasChangeAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasChangeAnim\n\n    let HasEnterAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasEnterAnim\n\n    let HasExitAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasExitAnim\n\n    let Flags a =\n        if a !==. null && JS.HasOwnProperty a \"flags\"\n        then a?flags\n        else AttrFlags.Defaults\n\n    let SetFlags (a: AttrProxy) (f: AttrFlags) =\n        a?flags <- f\n\n    /// Synchronizes dynamic attributes.\n    let Sync elem dyn =\n        dyn.DynNodes\n        |> Array.iter (fun d ->\n            d.Sync elem)\n\n    /// Inserts static attributes and computes dynamic attributes.\n    let Insert elem (tree: Attr) =\n        let nodes = Queue()\n        let oar = Queue()\n        let rec loop node =\n          if not (obj.ReferenceEquals(node, null)) then // work around WS issue with UseNullAsTrueValue\n            match node with\n            | A0 -> ()\n            | A1 n -> nodes.Enqueue n\n            | A2 (a, b) -> loop a; loop b\n            | A3 mk -> mk elem\n            | A4 cb -> oar.Enqueue cb\n        loop (As<AttrProxy> tree)\n        let arr = nodes.ToArray()\n        {\n            DynElem = elem\n            DynFlags = Flags tree\n            DynNodes = arr\n            OnAfterRender =\n                if oar.Count = 0 then None else\n                Some (fun el -> Seq.iter (fun f -> f el) oar)\n        }\n\n    let Empty e =\n        {\n            DynElem = e\n            DynFlags = AttrFlags.Defaults\n            DynNodes = [||]\n            OnAfterRender = None\n        }\n\n    let Updates dyn =\n        dyn.DynNodes\n        |> Array.MapTreeReduce (fun x -> x.Changed) (View.Const ()) View.Map2Unit\n\n    let GetAnim dyn f =\n        dyn.DynNodes\n        |> Array.map (fun n -> f n dyn.DynElem)\n        |> Anim.Concat\n\n    let GetEnterAnim dyn =\n        GetAnim dyn (fun n -> n.GetEnterAnim)\n\n    let GetExitAnim dyn =\n        GetAnim dyn (fun n -> n.GetExitAnim)\n\n    let GetChangeAnim dyn =\n        GetAnim dyn (fun n -> n.GetChangeAnim)\n\n    [<Inline>]\n    let GetOnAfterRender dyn =\n        dyn.OnAfterRender\n\n    let AppendTree a b =\n        // work around WS issue with UseNullAsTrueValue\n        if obj.ReferenceEquals(a, null) then b\n        elif obj.ReferenceEquals(b, null) then a\n        else\n        let x = A2 (a, b)\n        SetFlags x (Flags a ||| Flags b)\n        x\n//        match a, b with\n//        | A0, x | x, A0 -> x\n//        | _ -> A2 (a, b)\n\n    let internal EmptyAttr = A0\n\n    let internal Animated tr view set =\n        let node = AnimatedAttrNode (tr, view, set)\n        let mutable flags = AttrFlags.HasChangeAnim\n        if Trans.CanAnimateEnter tr then\n            flags <- flags ||| AttrFlags.HasEnterAnim\n        if Trans.CanAnimateExit tr then\n            flags <- flags ||| AttrFlags.HasExitAnim\n        let n = A1 node\n        SetFlags n flags\n        n\n\n    let internal Dynamic view set =\n        A1 (DynamicAttrNode (view, set))\n\n    let internal Static attr =\n        A3 attr\n\n\n[<JavaScript>]\ntype AttrProxy with\n\n    static member Create name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetAttr el name value))\n\n    static member Append (a: Attr) (b: Attr) =\n        As<Attr> (Attrs.AppendTree (As a) (As b))\n\n    [<Inline>]\n    static member Empty =\n        As<Attr> Attrs.EmptyAttr\n\n    static member Concat (xs: seq<Attr>) =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Attr.Empty Attr.Append\n\n    static member OnAfterRenderImpl(q: Expr<Dom.Element -> unit>) =\n        As<Attr> (A4 (As q))\n\n    static member HandlerImpl(event: string, q: Expr<Dom.Element -> #Dom.Event-> unit>) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(event, (As<Dom.Element -> Dom.Event -> unit> q) el, false)))\n\n    static member Handler (event: string) (q: Expr<Dom.Element -> #Dom.Event-> unit>) =\n        AttrProxy.HandlerImpl(event, q)\n\n[<JavaScript; Name \"WebSharper.UI.CheckedInput\">]\ntype CheckedInput<'T> =\n    | Valid of value: 'T * inputText: string\n    | Invalid of inputText: string\n    | Blank of inputText: string\n\n    static member Make(x: 'T) =\n        Valid (x, x.ToString())\n\n    member this.Input =\n        match this with\n        | Valid (_, x)\n        | Invalid x\n        | Blank x -> x\n\n[<JavaScript; Name \"WebSharper.UI.AttrModule\">]\nmodule Attr =\n\n    [<JavaScript; Macro(typeof<Macros.AttrStyle>)>]\n    let Style name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetStyle el name value))\n\n    let Animated name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetAttr el name (attr v)))\n\n    let AnimatedStyle name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetStyle el name (attr v)))\n\n    let Dynamic name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetAttr el name v))\n\n    let DynamicCustom set view =\n        As<Attr> (Attrs.Dynamic view set)\n\n    let DynamicStyle name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetStyle el name v))\n\n    let Handler name (callback: Dom.Element -> #Dom.Event -> unit) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(name, As<Dom.Event -> unit> (callback el), false)))\n\n    let HandlerView name (view: View<'T>) (callback: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let init (el: Dom.Element) =\n            let callback = callback el\n            el.AddEventListener(name, (fun (ev: Dom.Event) -> View.Get (callback (As ev)) view), false)\n        As<Attr> (Attrs.Static init)\n\n    let OnAfterRender (callback: Dom.Element -> unit) =\n        As<Attr> (A4 callback)\n\n    let OnAfterRenderView (v: View<'T>) (callback: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        Attr.Append\n            (OnAfterRender (fun el -> callback el el?(id)))\n            (DynamicCustom (fun el x -> el?(id) <- x) v)\n\n    let DynamicClassPred name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            if v then DU.AddClass el name else DU.RemoveClass el name))\n\n    [<JavaScript; Macro(typeof<Macros.AttrClass>)>]\n    let ClassPred name isSet =\n        As<Attr> (Attrs.Static (fun el ->\n            if isSet then DU.AddClass el name else DU.RemoveClass el name))\n\n    let Class name = ClassPred name true\n\n    let DynamicClass name view ok =\n        DynamicClassPred name (View.Map ok view)\n\n    let DynamicPred name predView valView =\n        let viewFn el (p, v) =\n            if p then\n                DU.SetAttr el name v\n            else\n                DU.RemoveAttr el name\n        let tupleView = View.Map2 (fun pred value -> (pred, value)) predView valView\n        As<Attr> (Attrs.Dynamic tupleView viewFn)\n\n    let DynamicProp name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            el?(name) <- v))\n\n    let CustomVar (var: Var<'a>) (set: Dom.Element -> 'a -> unit) (get: Dom.Element -> 'a option) =\n        let onChange (el: Dom.Element) (e: Dom.Event) =\n            var.UpdateMaybe(fun v ->\n                match get el with\n                | Some x as o when x <> v -> o\n                | _ -> None)\n        let set e v =\n            match get e with\n            | Some x when x = v -> ()\n            | _ -> set e v\n        Attr.Concat [\n            Handler \"change\" onChange\n            Handler \"input\" onChange\n            Handler \"keypress\" onChange\n            DynamicCustom set var.View\n        ]\n\n    let CustomValue (var: Var<'a>) (toString : 'a -> string) (fromString : string -> 'a option) =\n        CustomVar var (fun e v -> e?value <- toString v) (fun e -> fromString e?value)\n\n    let ContentEditableText (var: Var<string>) =\n        CustomVar var (fun e v -> e.TextContent <- v) (fun e -> Some e.TextContent)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let ContentEditableHtml (var: Var<string>) =\n        CustomVar var (fun e v -> e?innerHTML <- v) (fun e -> Some e?innerHTML)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let Value (var: Var<string>) =\n        CustomValue var id (id >> Some)\n\n    [<JavaScript; Inline \"$e.checkValidity?$e.checkValidity():true\">]\n    let CheckValidity (e: Dom.Element) = X<bool>\n\n    let IntValueUnchecked (var: Var<int>) =\n        let parseInt (s: string) =\n            if String.isBlank s then Some 0 else\n            let pd : int = JS.Plus s\n            if pd !==. (pd >>. 0) then None else Some pd\n        CustomValue var string parseInt\n\n    let IntValue (var: Var<CheckedInput<int>>) =\n        let parseCheckedInt (el: Dom.Element) : option<CheckedInput<int>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                match System.Int32.TryParse(s) with\n                | true, i -> Valid (i, s)\n                | false, _ -> Invalid s\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedInt\n\n    let FloatValueUnchecked (var: Var<float>) =\n        let parseFloat (s: string) =\n            if String.isBlank s then Some 0. else\n            let pd : float = JS.Plus s\n            if JS.IsNaN pd then None else Some pd\n        CustomValue var string parseFloat\n\n    let FloatValue (var: Var<CheckedInput<float>>) =\n        let parseCheckedFloat (el: Dom.Element) : option<CheckedInput<float>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                let i = JS.Plus s\n                if JS.IsNaN i then Invalid s else Valid (i, s)\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedFloat\n\n    let Checked (var: Var<bool>) =\n        let onSet (el: Dom.Element) (ev: Dom.Event) =\n            if var.Value <> el?``checked`` then\n                var.Value <- el?``checked``\n        Attr.Concat [\n            DynamicProp \"checked\" var.View\n            Handler \"change\" onSet\n        ]\n\n    let ValidateForm () =\n        OnAfterRender Resources.H5F.Setup\n\n[<assembly:System.Reflection.AssemblyVersionAttribute(\"4.0.0.0\")>]\ndo()\n", "namespace WebSharper.UI.Client\n\n#nowarn \"44\" // HTML deprecated\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\n\nmodule DU = DomUtility\ntype private A = Attr\n\n[<JavaScript>]\nmodule Settings =\n    let mutable BatchUpdatesEnabled = true\n\n[<JavaScript>]\ntype internal DocNode =\n    | AppendDoc of DocNode * DocNode\n    | ElemDoc of DocElemNode\n    | EmbedDoc of DocEmbedNode\n    | [<Constant(null)>] EmptyDoc\n    | TextDoc of DocTextNode\n    | TextNodeDoc of Dom.Text\n    | TreeDoc of DocTreeNode\n\nand [<CustomEquality>]\n    [<JavaScript>]\n    [<NoComparison>]\n    [<Name \"WebSharper.UI.DocElemNode\">]\n    internal DocElemNode =\n    {\n        Attr : Attrs.Dyn\n        mutable Children : DocNode\n        [<OptionalField>]\n        Delimiters : (Dom.Node * Dom.Node) option\n        El : Dom.Element\n        ElKey : int\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\n    override this.Equals(o: obj) =\n        this.ElKey = (o :?> DocElemNode).ElKey\n\n    override this.GetHashCode() =\n        this.ElKey\n\nand internal DocEmbedNode =\n    {\n        mutable Current : DocNode\n        mutable Dirty : bool\n    }\n\nand internal DocTextNode =\n    {\n        Text : Dom.Text\n        mutable Dirty : bool\n        mutable Value : string\n    }\n\nand internal DocTreeNode =\n    {\n        mutable Els : Union<Dom.Node, DocNode>[]\n        mutable Dirty : bool\n        mutable Holes : DocElemNode[]\n        Attrs : (Dom.Element * Attrs.Dyn)[]\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n        [<OptionalField>]\n        El : option<Dom.Element>\n    }\n\ntype EltUpdater =\n    inherit Elt\n\n    member this.AddUpdated(doc: Elt) = ()\n    member this.RemoveUpdated(doc: Elt) = ()\n    member this.RemoveAllUpdated() = ()\n\n[<JavaScript; Name \"WebSharper.UI.Docs\">]\nmodule internal Docs =\n\n    /// Sets of DOM nodes.\n    type DomNodes =\n        | DomNodes of Dom.Node[]\n\n        /// Actual chidlren of an element.\n        static member Children (elem: Dom.Element) (delims: option<Dom.Node * Dom.Node>) =\n            match delims with\n            | None ->\n                DomNodes (Array.init elem.ChildNodes.Length elem.ChildNodes.Item)\n            | Some (ldelim, rdelim) ->\n                let a = Array<_>()\n                let mutable n = ldelim.NextSibling\n                while n !==. rdelim do\n                    a.Push(n) |> ignore\n                    n <- n.NextSibling\n                DomNodes (As a)\n\n        /// Shallow children of an element node.\n        static member DocChildren node =\n            let q = Queue()\n            let rec loop doc =\n                match doc with\n                | AppendDoc (a, b) -> loop a; loop b\n                | EmbedDoc d -> loop d.Current\n                | ElemDoc e -> q.Enqueue (e.El :> Dom.Node)\n                | EmptyDoc -> ()\n                | TextNodeDoc tn -> q.Enqueue (tn :> Dom.Node)\n                | TextDoc t -> q.Enqueue (t.Text :> Dom.Node)\n                | TreeDoc t ->\n                    t.Els |> Array.iter (function\n                        | Union1Of2 e -> q.Enqueue e\n                        | Union2Of2 n -> loop n\n                    )\n            loop node.Children\n            DomNodes (Array.ofSeqNonCopying q)\n\n        /// Set difference - currently only using equality O(N^2).\n        /// Can do better? Can store <hash> data on every node?\n        static member Except (DomNodes excluded) (DomNodes included) =\n            included\n            |> Array.filter (fun n ->\n                excluded\n                |> Array.forall (fun k -> not (n ===. k)))\n            |> DomNodes\n\n        /// Iteration.\n        static member Iter f (DomNodes ns) =\n            Array.iter f ns\n\n        /// Iteration.\n        static member FoldBack f (DomNodes ns) z =\n            Array.foldBack f ns z\n\n    /// Inserts a node at position.\n    let InsertNode parent node pos =\n        DU.InsertAt parent pos node\n        DU.BeforeNode node\n\n    /// Inserts a doc at position.\n    let rec InsertDoc parent doc pos =\n        match doc with\n        | AppendDoc (a, b) -> InsertDoc parent a (InsertDoc parent b pos)\n        | ElemDoc e -> InsertNode parent e.El pos\n        | EmbedDoc d -> d.Dirty <- false; InsertDoc parent d.Current pos\n        | EmptyDoc -> pos\n        | TextDoc t -> InsertNode parent t.Text pos\n        | TextNodeDoc t -> InsertNode parent t pos\n        | TreeDoc t ->\n            Array.foldBack (fun el pos ->\n                match el with\n                | Union1Of2 e -> InsertNode parent e pos\n                | Union2Of2 n -> InsertDoc parent n pos\n            ) t.Els pos\n\n    /// Synchronizes an element with its children (shallow).\n    let DoSyncElement (el : DocElemNode) =\n        let parent = el.El\n        let rec ins doc pos =\n            match doc with\n            | AppendDoc (a, b) -> ins a (ins b pos)\n            | ElemDoc e -> DU.BeforeNode e.El\n            | EmbedDoc d ->\n                if d.Dirty then\n                    d.Dirty <- false\n                    InsertDoc parent d.Current pos\n                else\n                    ins d.Current pos\n            | EmptyDoc -> pos\n            | TextDoc t -> DU.BeforeNode t.Text\n            | TextNodeDoc t -> DU.BeforeNode t\n            | TreeDoc t ->\n                if t.Dirty then t.Dirty <- false\n                Array.foldBack (fun el pos ->\n                    match el with\n                    | Union1Of2 e -> DU.BeforeNode e\n                    | Union2Of2 n -> ins n pos\n                ) t.Els pos\n        let ch = DomNodes.DocChildren el\n        // remove children that are not in the current set\n        DomNodes.Children el.El el.Delimiters\n        |> DomNodes.Except ch\n        |> DomNodes.Iter (DU.RemoveNode el.El)\n        // insert current children\n        let pos =\n            match el.Delimiters with\n            | None -> DU.AtEnd\n            | Some (_, rdelim) -> DU.BeforeNode rdelim\n        ins el.Children pos |> ignore\n\n    /// Optimized version of DoSyncElement.\n    let SyncElement (el: DocElemNode) =\n        /// Test if any children have changed.\n        let rec hasDirtyChildren el =\n            let rec dirty doc =\n                match doc with\n                | AppendDoc (a, b) -> dirty a || dirty b\n                | EmbedDoc d -> d.Dirty || dirty d.Current\n                | TreeDoc t -> t.Dirty || Array.exists hasDirtyChildren t.Holes\n                | _ -> false\n            dirty el.Children\n        Attrs.Sync el.El el.Attr\n        if hasDirtyChildren el then\n            DoSyncElement el\n\n    /// Links an element to children by inserting them.\n    let LinkElement el children =\n        InsertDoc el children DU.AtEnd |> ignore\n\n    /// Links an element to previous siblings by inserting them.\n    let LinkPrevElement (el: Dom.Node) children =\n        InsertDoc (el.ParentNode :?> _) children (DU.BeforeNode el) |> ignore\n\n    let InsertBeforeDelim (afterDelim: Dom.Node) (doc: DocNode) =\n        let p = afterDelim.ParentNode\n        let before = JS.Document.CreateTextNode(\"\") :> Dom.Node\n        p.InsertBefore(before, afterDelim) |> ignore\n        LinkPrevElement afterDelim doc\n        before\n\n    /// Invokes and clears an element's afterRender callback(s).\n    let AfterRender (el: DocElemNode) =\n        match el.Render with\n        | None -> ()\n        | Some f -> f el.El; el.Render <- None\n\n    /// Synchronizes the document (deep).\n    let rec Sync doc =\n        match doc with\n        | AppendDoc (a, b) -> Sync a; Sync b\n        | ElemDoc el -> SyncElemNode false el\n        | EmbedDoc n -> Sync n.Current\n        | EmptyDoc\n        | TextNodeDoc _ -> ()\n        | TextDoc d ->\n            if d.Dirty then\n                d.Text.NodeValue <- d.Value\n                d.Dirty <- false\n        | TreeDoc t ->\n            Array.iter (SyncElemNode false) t.Holes\n            Array.iter (fun (e, a) -> Attrs.Sync e a) t.Attrs\n            AfterRender (As t)\n\n    /// Synchronizes an element node (deep).\n    and SyncElemNode childrenOnly el =\n        if not childrenOnly then\n            SyncElement el\n        Sync el.Children\n        AfterRender el\n\n    /// A set of node element nodes.\n    type NodeSet =\n        | NodeSet of HashSet<DocElemNode>\n\n        /// Filters out only nodes that have on-remove animations.\n        static member Filter f (NodeSet set) =\n            NodeSet (HashSet.Filter f set)\n\n        /// Finds all node elements in a tree.\n        static member FindAll doc =\n            let q = Queue()\n            let rec loop node =\n                match node with\n                | AppendDoc (a, b) -> loop a; loop b\n                | ElemDoc el -> loopEN el\n                | EmbedDoc em -> loop em.Current\n                | TreeDoc t -> t.Holes |> Array.iter loopEN\n                | _ -> ()\n            and loopEN el =\n                q.Enqueue el\n                loop el.Children\n            loop doc\n            NodeSet (HashSet q)\n\n        /// Set difference.\n        static member Except (NodeSet excluded) (NodeSet included) =\n            NodeSet (included |> HashSet.Except excluded)\n\n        /// Set intersection.\n        static member Intersect (NodeSet a) (NodeSet b) =\n            NodeSet (HashSet.Intersect a b)\n\n        /// Checks if empty.\n        static member IsEmpty (NodeSet ns) =\n            ns.Count = 0\n\n        /// The empty set.\n        static member Empty =\n            NodeSet (HashSet ())\n\n        /// Converts to array.\n        static member ToArray (NodeSet ns) =\n            HashSet.ToArray ns\n\n    /// State of the Doc.Run (updator) proces.\n    type RunState =\n        {\n            mutable PreviousNodes : NodeSet\n            Top : DocElemNode\n        }\n\n    /// Creates an element node.\n    let CreateElemNode el attr children =\n        LinkElement el children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = None\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates an element node that handles a delimited subset of its children.\n    let CreateDelimitedElemNode (ldelim: Dom.Node) (rdelim: Dom.Node) attr children =\n        let el = ldelim.ParentNode :?> Dom.Element\n        LinkPrevElement rdelim children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = Some (ldelim, rdelim)\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates a new RunState.\n    let CreateRunState parent doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateElemNode parent Attr.Empty doc\n        }\n\n    /// Creates a new RunState for a delimited subset of the children of a node.\n    let CreateDelimitedRunState ldelim rdelim doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateDelimitedElemNode ldelim rdelim Attr.Empty doc\n        }\n\n    /// Computes the animation of nodes that animate removal.\n    let ComputeExitAnim st cur =\n        st.PreviousNodes\n        |> NodeSet.Filter (fun n -> Attrs.HasExitAnim n.Attr)\n        |> NodeSet.Except cur\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetExitAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for changed nodes.\n    let ComputeChangeAnim st cur =\n        let relevant = NodeSet.Filter (fun n -> Attrs.HasChangeAnim n.Attr)\n        NodeSet.Intersect (relevant st.PreviousNodes) (relevant cur)\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetChangeAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for entering nodes.\n    let ComputeEnterAnim st cur =\n        cur\n        |> NodeSet.Filter (fun n -> Attrs.HasEnterAnim n.Attr)\n        |> NodeSet.Except st.PreviousNodes\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetEnterAnim n.Attr)\n        |> Anim.Concat\n\n    let SyncElemNodesNextFrame childrenOnly st =\n        if Settings.BatchUpdatesEnabled then\n            Async.FromContinuations <| fun (ok, _, _) ->\n                JS.RequestAnimationFrame (fun _ ->\n                    SyncElemNode childrenOnly st.Top\n                    ok()\n                ) |> ignore\n        else\n            async.Return(SyncElemNode childrenOnly st.Top)\n\n    /// The main function: how to perform an animated top-level document update.\n    let PerformAnimatedUpdate childrenOnly st doc =\n        if Anim.UseAnimations then\n            async {\n                let cur = NodeSet.FindAll doc\n                let change = ComputeChangeAnim st cur\n                let enter = ComputeEnterAnim st cur\n                let exit = ComputeExitAnim st cur\n                do! Anim.Play (Anim.Append change exit)\n                do! SyncElemNodesNextFrame childrenOnly st\n                do! Anim.Play enter\n                return st.PreviousNodes <- cur\n            }\n        else\n            SyncElemNodesNextFrame childrenOnly st\n\n    let PerformSyncUpdate childrenOnly st doc =\n        let cur = NodeSet.FindAll doc\n        SyncElemNode childrenOnly st.Top\n        st.PreviousNodes <- cur\n\n    /// EmbedNode constructor.\n    let CreateEmbedNode () =\n        {\n            Current = EmptyDoc\n            Dirty = false\n        }\n\n    /// EmbedNode update (marks dirty).\n    let UpdateEmbedNode node upd =\n        node.Current <- upd\n        node.Dirty <- true\n\n    /// Text node constructor.\n    let CreateTextNode () =\n        {\n            Dirty = false\n            Text = DU.CreateText \"\"\n            Value = \"\"\n        }\n\n    /// Text node update (marks dirty).\n    let UpdateTextNode n t =\n        n.Value <- t\n        n.Dirty <- true\n\n// We implement the Doc interface, the Doc module proxy and the Client.Doc module proxy\n// all in this so that it all neatly looks like Doc.* in javascript.\n[<Name \"WebSharper.UI.Doc\"; Proxy(typeof<Doc>)>]\ntype internal Doc' [<JavaScript>] (docNode, updates) =\n\n    [<JavaScript; Inline>]\n    member this.DocNode = docNode\n    [<JavaScript; Inline>]\n    member this.Updates = updates\n\n    interface IControlBody with\n\n        [<JavaScript>]\n        member this.ReplaceInDom(elt) =\n            // Insert empty text nodes that will serve as delimiters for the Doc.\n            let rdelim = JS.Document.CreateTextNode \"\"\n            elt.ParentNode.ReplaceChild(rdelim, elt) |> ignore\n            Doc'.RunBefore rdelim this\n\n    [<JavaScript>]\n    static member Mk node updates =\n        Doc'(node, updates)\n\n    [<JavaScript>]\n    static member Append (a: Doc') (b: Doc') =\n        (a.Updates, b.Updates)\n        ||> View.Map2Unit\n        |> Doc'.Mk (AppendDoc (a.DocNode, b.DocNode))\n\n    [<JavaScript>]\n    static member Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Doc'.Empty Doc'.Append\n\n    [<JavaScript>]\n    static member Empty\n        with get () =\n            Doc'.Mk EmptyDoc (View.Const ())\n\n    [<JavaScript; Inline>]\n    static member Elem el attr (children: Doc') =\n        Elt'.New(el, attr, children)\n\n    [<JavaScript>]\n    static member TextNode v =\n        Doc'.Mk (TextNodeDoc (DU.CreateText v)) (View.Const ())\n\n    [<JavaScript>]\n    static member StaticProxy el : Elt' =\n        Doc'.Elem el Attr.Empty Doc'.Empty\n\n    [<JavaScript; Inline>]\n    static member Static el : Elt = As (Doc'.StaticProxy el)\n\n    [<JavaScript>]\n    static member Verbatim html =\n        let a =\n            match JQuery.JQuery.ParseHTML html with\n            | null -> [||]\n            | a -> a\n        let elem (n: Dom.Node) =\n            if n.NodeType = Dom.NodeType.Text then\n                TextNodeDoc (n :?> Dom.Text)\n            else\n                ElemDoc (Docs.CreateElemNode (n :?> Dom.Element) Attr.Empty EmptyDoc)\n        let append x y = AppendDoc (x, y)\n        let es = Array.MapTreeReduce elem EmptyDoc append a\n        Doc'.Mk es (View.Const ())\n\n    [<JavaScript>]\n    static member EmbedView (view: View<Doc'>) =\n        let node = Docs.CreateEmbedNode ()\n        view\n        |> View.Bind (fun doc ->\n            Docs.UpdateEmbedNode node doc.DocNode\n            doc.Updates)\n        |> View.Map ignore\n        |> Doc'.Mk (EmbedDoc node)\n\n    [<JavaScript>]\n    static member BindView (f: 'T -> Doc') (view: View<'T>) =\n        Doc'.EmbedView (View.Map f view)\n\n    [<JavaScript>]\n    static member Async (a: Async<Doc'>) : Doc' =\n        View.Const a\n        |> View.MapAsync id\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member RunBetween ldelim rdelim (doc: Doc') =\n        Docs.LinkPrevElement rdelim doc.DocNode\n        let st = Docs.CreateDelimitedRunState ldelim rdelim doc.DocNode\n        let p =\n            if Anim.UseAnimations || Settings.BatchUpdatesEnabled then\n                Mailbox.StartProcessor (Docs.PerformAnimatedUpdate false st doc.DocNode)\n            else\n                fun () -> Docs.PerformSyncUpdate false st doc.DocNode\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunBefore (rdelim: Dom.Node) (doc: Doc') =\n        let ldelim = JS.Document.CreateTextNode(\"\")\n        rdelim.ParentNode.InsertBefore(ldelim, rdelim) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunBeforeById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunBefore el doc\n\n    [<JavaScript>]\n    static member RunAfter (ldelim : Dom.Node) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode(\"\")\n        ldelim.ParentNode.InsertBefore(rdelim, ldelim.NextSibling) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunAfterById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAfter el doc\n\n    [<JavaScript>]\n    static member RunAppend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.AppendChild(rdelim) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunAppendById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAppend el doc\n\n    [<JavaScript>]\n    static member RunPrepend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.InsertBefore(rdelim, parent.FirstChild) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunPrependById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunPrepend el doc\n\n    [<JavaScript>]\n    static member RunInPlace childrenOnly parent (doc: Doc') =\n        let d = doc.DocNode\n        let st = Docs.CreateRunState parent d\n        let p =\n            if Anim.UseAnimations || Settings.BatchUpdatesEnabled then\n                Mailbox.StartProcessor (Docs.PerformAnimatedUpdate childrenOnly st doc.DocNode)\n            else\n                fun () -> Docs.PerformSyncUpdate childrenOnly st doc.DocNode\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member Run parent (doc: Doc') =\n        Docs.LinkElement parent doc.DocNode\n        Doc'.RunInPlace false parent doc\n\n    [<JavaScript>]\n    static member RunById id tr =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.Run el tr\n\n    [<JavaScript>]\n    static member RunReplaceById id (tr: Doc') =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> (tr :> IControlBody).ReplaceInDom(el)\n\n    [<JavaScript>]\n    static member TextView txt =\n        let node = Docs.CreateTextNode ()\n        txt\n        |> View.Map (Docs.UpdateTextNode node)\n        |> Doc'.Mk (TextDoc node)\n\n    [<JavaScript>]\n    static member Flatten view =\n        view\n        |> View.Map Doc'.Concat\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member Convert render view =\n        View.MapSeqCached render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertBy key render view =\n        View.MapSeqCachedBy key render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeq render view =\n        View.MapSeqCachedView render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqBy key render view =\n        View.MapSeqCachedViewBy key (As render) view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqVarBy key render var =\n        Var.MapLens key (As render) var |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member InputInternal elemTy attr =\n        let el = DU.CreateElement elemTy\n        Doc'.Elem el (Attr.Concat (attr el)) Doc'.Empty\n\n    [<JavaScript>]\n    static member Input attr (var: Var<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member PasswordBox attr (var: Var<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                Attr.Value var\n                Attr.Create \"type\" \"password\"\n            |])\n\n    [<JavaScript>]\n    static member IntInputUnchecked attr (var: Var<int>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0 then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.IntValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member IntInput attr (var: Var<CheckedInput<int>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.IntValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInputUnchecked attr (var: Var<float>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0. then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.FloatValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInput attr (var: Var<CheckedInput<float>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.FloatValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member InputArea attr (var: Var<string>) =\n        Doc'.InputInternal \"textarea\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member SelectImpl attrs (show: 'T -> string) (optionElements) (current: Var<'T>) =\n        let options = ref []\n        let getIndex (el: Dom.Element) =\n            el?selectedIndex : int\n        let setIndex (el: Dom.Element) (i: int) =\n            el?selectedIndex <- i\n        let getSelectedItem el =\n            let i = getIndex el\n            (!options).[i]\n        let itemIndex x =\n            List.findIndex ((=) x) !options\n        let setSelectedItem (el: Dom.Element) item =\n            setIndex el (itemIndex item)\n        let el = DU.CreateElement \"select\"\n        let selectedItemAttr =\n            current.View\n            |> Attr.DynamicCustom setSelectedItem\n        let onChange (x: Dom.Event) =\n            current.UpdateMaybe(fun x ->\n                let y = getSelectedItem el\n                if x = y then None else Some y\n            )\n        el.AddEventListener(\"change\", onChange, false)\n        let attrs =\n            Attr.Concat attrs\n            |> Attr.Append selectedItemAttr\n            |> Attr.Append (Attr.OnAfterRender (fun el -> \n                setSelectedItem el <| current.Get()))\n        Doc'.Elem el attrs (optionElements options)\n\n    [<JavaScript>]\n    static member SelectDyn attrs (show: 'T -> string) (vOptions: View<list<'T>>) (current: Var<'T>) =\n        let optionElements options =\n            vOptions\n            |> View.Map (fun l ->\n                options := l\n                l |> Seq.mapi (fun i x -> i, x)\n            )\n            |> Doc'.Convert (fun (i, o) ->\n                Doc'.Element \"option\" [\n                    Attr.Create \"value\" (string i)\n                ] [Doc'.TextNode (show o)]\n                :> Doc'\n            )\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member Select attrs show options current =\n        let optionElements rOptions =\n            rOptions := options\n            options\n            |> List.mapi (fun i o ->\n                Doc'.Element \"option\" [\n                    Attr.Create \"value\" (string i)\n                ] [Doc'.TextNode (show o)]\n                :> Doc'\n            )\n            |> Doc'.Concat\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member SelectOptional attrs noneText show options current =\n        Doc'.Select attrs\n            (function None -> noneText | Some x -> show x)\n            (None :: List.map Some options)\n            current\n\n    [<JavaScript>]\n    static member SelectDynOptional attrs noneText show vOptions current =\n        Doc'.SelectDyn attrs\n            (function None -> noneText | Some x -> show x)\n            (vOptions |> View.Map (fun options -> None :: List.map Some options))\n            current\n\n    [<JavaScript>]\n    static member CheckBox attrs (chk: Var<bool>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attrs [\n                Attr.Create \"type\" \"checkbox\"\n                Attr.Checked chk\n            ])\n\n    [<JavaScript>]\n    static member CheckBoxGroup attrs (item: 'T) (chk: Var<list<'T>>) =\n        let rv =\n            chk.Lens\n                (List.exists ((=) item))\n                (fun l b ->\n                    if b then\n                        if List.exists ((=) item) l then l else item :: l\n                    else\n                        List.filter ((<>) item) l\n                )\n        Doc'.CheckBox attrs rv\n\n    [<JavaScript>]\n    static member Clickable elem action =\n        let el = DU.CreateElement elem\n        el.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            ev.PreventDefault()\n            action ()), false)\n        el\n\n    [<JavaScript>]\n    static member Button caption attrs action =\n        let attrs = Attr.Concat attrs\n        let el = Doc'.Clickable \"button\" action\n        Doc'.Elem el attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member ButtonView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr|] attrs)\n        Doc'.Elem (DU.CreateElement \"button\") attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member Link caption attrs action =\n        let attrs = Attr.Concat attrs |> Attr.Append (Attr.Create \"href\" \"#\")\n        let el = Doc'.Clickable \"a\" action\n        Doc'.Elem el attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member LinkView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr; Attr.Create \"href\" \"#\"|] attrs)\n        Doc'.Elem (DU.CreateElement \"a\") attrs (Doc'.TextNode caption)\n\n    [<JavaScript>]\n    static member Radio attrs value (var: Var<_>) =\n        // Radio buttons work by taking a common var, which is given a unique ID.\n        // This ID is serialised and used as the name, giving us the \"grouping\"\n        // behaviour.\n        let el = DU.CreateElement \"input\"\n        el.AddEventListener(\"click\", (fun (x : Dom.Event) -> var.Set value), false)\n        let predView = View.Map (fun x -> x = value) var.View\n        let valAttr = Attr.DynamicProp \"checked\" predView\n        let (==>) k v = Attr.Create k v\n        let attr =\n            [\n                \"type\" ==> \"radio\"\n                \"name\" ==> var.Id\n                valAttr\n            ] @ (List.ofSeq attrs) |> Attr.Concat\n        Doc'.Elem el attr Doc'.Empty\n\n    // Actual proxy members\n\n    [<JavaScript>]\n    static member Element (name: string) (attr: seq<Attr>) (children: seq<Doc'>) : Elt' =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat children\n        Doc'.Elem (DU.CreateElement name) attr children\n\n    static member ToMixedDoc (o: obj) =\n        match o with\n        | :? Doc' as d -> d\n        | :? string as t -> Doc'.TextNode t\n        | :? Dom.Element as e -> Doc'.StaticProxy e :> Doc'\n        | :? Function as v ->\n            Doc'.EmbedView ((As<View<_>>v).Map Doc'.ToMixedDoc)\n        | :? Var<obj> as v ->\n            Doc'.EmbedView (v.View.Map Doc'.ToMixedDoc)\n        | null -> Doc'.Empty\n        | o -> Doc'.TextNode (string o)\n\n    static member MixedNodes (nodes: seq<obj>) =\n        let attrs = ResizeArray()\n        let children = ResizeArray()\n        for n in nodes do\n            match n with\n            | :? Attr as a -> attrs.Add a\n            | _ -> children.Add (Doc'.ToMixedDoc n)\n        attrs :> _ seq, children :> _ seq \n\n    static member ConcatMixed (elts: obj[]) =\n        Doc'.Concat (Seq.map Doc'.ToMixedDoc elts)\n\n    [<JavaScript>]\n    static member ElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc'.Element tagname attrs children \n\n    [<JavaScript>]\n    static member SvgElement (name: string) (attr: seq<Attr>) (children: seq<Doc'>) : Elt' =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat children\n        Doc'.Elem (DU.CreateSvgElement name) attr children\n\n    [<JavaScript>]\n    static member SvgElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc'.SvgElement tagname attrs children \n\n    [<JavaScript; Inline>]\n    static member ClientSide (expr: Microsoft.FSharp.Quotations.Expr<#IControlBody>) : Doc' =\n        As expr\n\nand [<JavaScript; Proxy(typeof<Elt>); Name \"WebSharper.UI.Elt\">]\n    internal Elt'(docNode, updates, elt: Dom.Element, rvUpdates: Updates) =\n    inherit Doc'(docNode, updates)\n\n    static member New(el: Dom.Element, attr: Attr, children: Doc') =\n        let node = Docs.CreateElemNode el attr children.DocNode\n        let rvUpdates = Updates.Create children.Updates\n        let attrUpdates = Attrs.Updates node.Attr\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(ElemDoc node, updates, el, rvUpdates)\n\n    /// Assumes tree.Els = [| Union1Of2 someDomElement |]\n    static member TreeNode(tree: DocTreeNode, updates) =\n        let rvUpdates = Updates.Create updates\n        let attrUpdates =\n            tree.Attrs\n            |> Array.map (snd >> Attrs.Updates)\n            |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(TreeDoc tree, updates, tree.Els.[0].Value1 :?> _, rvUpdates)\n\n    [<Inline \"$0.elt\">]\n    member this.Element = elt\n\n    member this.on (ev: string, cb: Dom.Element -> #Dom.Event -> unit) =\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> cb elt (ev :?> _)), false)\n        this\n\n    member this.onView (ev: string, view: View<'T>, cb: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let cb = cb elt\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> View.Get (cb (ev :?> _)) view), false)\n        this\n\n    [<Name \"On\"; Inline>]\n    member this.onExpr (ev: string, cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> #Dom.Event -> unit>) =\n        this.on (ev, As<_ -> _ -> _> cb)\n\n    member this.OnAfterRender' (cb: Dom.Element -> unit) =\n        match docNode with\n        | ElemDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | TreeDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | _ -> failwith \"Invalid docNode in Elt\"\n        this\n\n    member this.OnAfterRender (cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> unit>) =\n        this.OnAfterRender' (As<Dom.Element -> unit> cb)\n\n    member this.OnAfterRenderView (view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        this.AppendDoc(Doc'.BindView (fun x -> this.Element?(id) <- x; Doc'.Empty) view)\n        this.OnAfterRender'(fun e -> cb e e?(id))\n\n    abstract AddHole : DocElemNode -> unit \n    default this.AddHole h = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes.JS.Push h |> ignore\n        | _ -> ()\n\n    abstract ClearHoles : unit -> unit \n    default this.ClearHoles() = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes <- [||]\n        | _ -> ()\n\n    [<Name \"Append\">]\n    member this.AppendDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(e.Children, doc.DocNode)\n            Docs.InsertDoc elt doc.DocNode DU.AtEnd |> ignore\n        | TreeDoc e ->\n            let after = elt.AppendChild(JS.Document.CreateTextNode \"\")\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            } \n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Prepend\">]\n    member this.PrependDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(doc.DocNode, e.Children)\n            let pos =\n                match elt.FirstChild with\n                | null -> DU.AtEnd\n                | n -> DU.BeforeNode n\n            Docs.InsertDoc elt doc.DocNode pos |> ignore\n        | TreeDoc e ->\n            let after = elt.InsertBefore(JS.Document.CreateTextNode \"\", elt.FirstChild)\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            }\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Clear\">]\n    member this.Clear'() =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        while (elt.HasChildNodes()) do elt.RemoveChild(elt.FirstChild) |> ignore\n\n    [<JavaScript>]\n    member this.ToUpdater() =\n        let docTreeNode : DocTreeNode =\n            match docNode with\n            | ElemDoc e ->\n                {\n                    Els = [| Union1Of2 (upcast elt) |]\n                    Holes = [||]\n                    Attrs = [| elt, e.Attr |]\n                    Render = None\n                    Dirty = true\n                    El = Some elt\n                }\n            | TreeDoc e -> e\n            | _ -> failwith \"Invalid docNode in Elt\"\n\n        EltUpdater'(docTreeNode, updates, elt, rvUpdates, Var.Create [||])\n\n    [<Name \"Html\">]\n    member this.Html'() : string =\n        elt?outerHTML\n\n    [<Name \"Id\">]\n    member this.Id'() : string =\n        elt?id\n\n    [<Name \"GetValue\">]\n    member this.GetValue() : string =\n        elt?value\n\n    [<Name \"SetValue\">]\n    member this.SetValue(v: string) : unit =\n        elt?value <- v\n\n    [<Name \"GetText\">]\n    member this.GetText() : string =\n        elt.TextContent\n\n    [<Name \"SetText\">]\n    member this.SetText(v: string) : unit =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        elt.TextContent <- v\n\n    [<Name \"SetAttribute\">]\n    member this.SetAttribute'(name: string, value: string) =\n        elt.SetAttribute(name, value)\n\n    [<Name \"GetAttribute\">]\n    member this.GetAttribute'(name) =\n        elt.GetAttribute(name)\n\n    [<Name \"HasAttribute\">]\n    member this.HasAttribute'(name) =\n        elt.HasAttribute(name)\n\n    [<Name \"RemoveAttribute\">]\n    member this.RemoveAttribute'(name) =\n        elt.RemoveAttribute(name)\n\n    [<Name \"SetProperty\">]\n    member this.SetProperty'(name: string, value: 'T) =\n        elt?(name) <- value\n\n    [<Name \"GetProperty\">]\n    member this.GetProperty'(name: string) : 'T =\n        elt?(name)\n\n    [<Inline>]\n    member this.AddClass'(cls: string) =\n        DU.AddClass elt cls\n\n    [<Inline>]\n    member this.RemoveClass'(cls: string) =\n        DU.RemoveClass elt cls\n\n    [<Name \"HasClass\">]\n    member this.HasClass'(cls: string) =\n        (new RegExp(@\"(\\s|^)\" + cls + @\"(\\s|$)\")).Test(elt?className)\n\n    [<Name \"SetStyle\">]\n    member this.SetStyle'(style: string, value: string) =\n        elt?style?(style) <- value\n\n    // {{ event\n    [<Inline>]\n    member this.OnAbort(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"abort\", cb)\n    [<Inline>]\n    member this.OnAfterPrint(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"afterprint\", cb)\n    [<Inline>]\n    member this.OnAnimationEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationend\", cb)\n    [<Inline>]\n    member this.OnAnimationIteration(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationiteration\", cb)\n    [<Inline>]\n    member this.OnAnimationStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"animationstart\", cb)\n    [<Inline>]\n    member this.OnAudioProcess(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"audioprocess\", cb)\n    [<Inline>]\n    member this.OnBeforePrint(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beforeprint\", cb)\n    [<Inline>]\n    member this.OnBeforeUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beforeunload\", cb)\n    [<Inline>]\n    member this.OnBeginEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"beginEvent\", cb)\n    [<Inline>]\n    member this.OnBlocked(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"blocked\", cb)\n    [<Inline>]\n    member this.OnBlur(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.FocusEvent -> unit>) = this.onExpr(\"blur\", cb)\n    [<Inline>]\n    member this.OnCached(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"cached\", cb)\n    [<Inline>]\n    member this.OnCanPlay(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"canplay\", cb)\n    [<Inline>]\n    member this.OnCanPlayThrough(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"canplaythrough\", cb)\n    [<Inline>]\n    member this.OnChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"change\", cb)\n    [<Inline>]\n    member this.OnChargingChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"chargingchange\", cb)\n    [<Inline>]\n    member this.OnChargingTimeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"chargingtimechange\", cb)\n    [<Inline>]\n    member this.OnChecking(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"checking\", cb)\n    [<Inline>]\n    member this.OnClick(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"click\", cb)\n    [<Inline>]\n    member this.OnClose(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"close\", cb)\n    [<Inline>]\n    member this.OnComplete(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"complete\", cb)\n    [<Inline>]\n    member this.OnCompositionEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionend\", cb)\n    [<Inline>]\n    member this.OnCompositionStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionstart\", cb)\n    [<Inline>]\n    member this.OnCompositionUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.CompositionEvent -> unit>) = this.onExpr(\"compositionupdate\", cb)\n    [<Inline>]\n    member this.OnContextMenu(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"contextmenu\", cb)\n    [<Inline>]\n    member this.OnCopy(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"copy\", cb)\n    [<Inline>]\n    member this.OnCut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"cut\", cb)\n    [<Inline>]\n    member this.OnDblClick(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"dblclick\", cb)\n    [<Inline>]\n    member this.OnDeviceLight(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"devicelight\", cb)\n    [<Inline>]\n    member this.OnDeviceMotion(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"devicemotion\", cb)\n    [<Inline>]\n    member this.OnDeviceOrientation(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"deviceorientation\", cb)\n    [<Inline>]\n    member this.OnDeviceProximity(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"deviceproximity\", cb)\n    [<Inline>]\n    member this.OnDischargingTimeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dischargingtimechange\", cb)\n    [<Inline>]\n    member this.OnDOMActivate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"DOMActivate\", cb)\n    [<Inline>]\n    member this.OnDOMAttributeNameChanged(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMAttributeNameChanged\", cb)\n    [<Inline>]\n    member this.OnDOMAttrModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMAttrModified\", cb)\n    [<Inline>]\n    member this.OnDOMCharacterDataModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMCharacterDataModified\", cb)\n    [<Inline>]\n    member this.OnDOMContentLoaded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMContentLoaded\", cb)\n    [<Inline>]\n    member this.OnDOMElementNameChanged(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"DOMElementNameChanged\", cb)\n    [<Inline>]\n    member this.OnDOMNodeInserted(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeInserted\", cb)\n    [<Inline>]\n    member this.OnDOMNodeInsertedIntoDocument(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeInsertedIntoDocument\", cb)\n    [<Inline>]\n    member this.OnDOMNodeRemoved(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeRemoved\", cb)\n    [<Inline>]\n    member this.OnDOMNodeRemovedFromDocument(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMNodeRemovedFromDocument\", cb)\n    [<Inline>]\n    member this.OnDOMSubtreeModified(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MutationEvent -> unit>) = this.onExpr(\"DOMSubtreeModified\", cb)\n    [<Inline>]\n    member this.OnDownloading(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"downloading\", cb)\n    [<Inline>]\n    member this.OnDrag(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"drag\", cb)\n    [<Inline>]\n    member this.OnDragEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragend\", cb)\n    [<Inline>]\n    member this.OnDragEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragenter\", cb)\n    [<Inline>]\n    member this.OnDragLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragleave\", cb)\n    [<Inline>]\n    member this.OnDragOver(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragover\", cb)\n    [<Inline>]\n    member this.OnDragStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"dragstart\", cb)\n    [<Inline>]\n    member this.OnDrop(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"drop\", cb)\n    [<Inline>]\n    member this.OnDurationChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"durationchange\", cb)\n    [<Inline>]\n    member this.OnEmptied(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"emptied\", cb)\n    [<Inline>]\n    member this.OnEnded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"ended\", cb)\n    [<Inline>]\n    member this.OnEndEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"endEvent\", cb)\n    [<Inline>]\n    member this.OnError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"error\", cb)\n    [<Inline>]\n    member this.OnFocus(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.FocusEvent -> unit>) = this.onExpr(\"focus\", cb)\n    [<Inline>]\n    member this.OnFullScreenChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"fullscreenchange\", cb)\n    [<Inline>]\n    member this.OnFullScreenError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"fullscreenerror\", cb)\n    [<Inline>]\n    member this.OnGamepadConnected(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"gamepadconnected\", cb)\n    [<Inline>]\n    member this.OnGamepadDisconnected(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"gamepaddisconnected\", cb)\n    [<Inline>]\n    member this.OnHashChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"hashchange\", cb)\n    [<Inline>]\n    member this.OnInput(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"input\", cb)\n    [<Inline>]\n    member this.OnInvalid(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"invalid\", cb)\n    [<Inline>]\n    member this.OnKeyDown(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keydown\", cb)\n    [<Inline>]\n    member this.OnKeyPress(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keypress\", cb)\n    [<Inline>]\n    member this.OnKeyUp(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.KeyboardEvent -> unit>) = this.onExpr(\"keyup\", cb)\n    [<Inline>]\n    member this.OnLanguageChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"languagechange\", cb)\n    [<Inline>]\n    member this.OnLevelChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"levelchange\", cb)\n    [<Inline>]\n    member this.OnLoad(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"load\", cb)\n    [<Inline>]\n    member this.OnLoadedData(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadeddata\", cb)\n    [<Inline>]\n    member this.OnLoadedMetadata(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadedmetadata\", cb)\n    [<Inline>]\n    member this.OnLoadEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadend\", cb)\n    [<Inline>]\n    member this.OnLoadStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"loadstart\", cb)\n    [<Inline>]\n    member this.OnMessage(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"message\", cb)\n    [<Inline>]\n    member this.OnMouseDown(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mousedown\", cb)\n    [<Inline>]\n    member this.OnMouseEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseenter\", cb)\n    [<Inline>]\n    member this.OnMouseLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseleave\", cb)\n    [<Inline>]\n    member this.OnMouseMove(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mousemove\", cb)\n    [<Inline>]\n    member this.OnMouseOut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseout\", cb)\n    [<Inline>]\n    member this.OnMouseOver(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseover\", cb)\n    [<Inline>]\n    member this.OnMouseUp(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"mouseup\", cb)\n    [<Inline>]\n    member this.OnNoUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"noupdate\", cb)\n    [<Inline>]\n    member this.OnObsolete(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"obsolete\", cb)\n    [<Inline>]\n    member this.OnOffline(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"offline\", cb)\n    [<Inline>]\n    member this.OnOnline(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"online\", cb)\n    [<Inline>]\n    member this.OnOpen(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"open\", cb)\n    [<Inline>]\n    member this.OnOrientationChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"orientationchange\", cb)\n    [<Inline>]\n    member this.OnPageHide(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pagehide\", cb)\n    [<Inline>]\n    member this.OnPageShow(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pageshow\", cb)\n    [<Inline>]\n    member this.OnPaste(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"paste\", cb)\n    [<Inline>]\n    member this.OnPause(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pause\", cb)\n    [<Inline>]\n    member this.OnPlay(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"play\", cb)\n    [<Inline>]\n    member this.OnPlaying(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"playing\", cb)\n    [<Inline>]\n    member this.OnPointerLockChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pointerlockchange\", cb)\n    [<Inline>]\n    member this.OnPointerLockError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"pointerlockerror\", cb)\n    [<Inline>]\n    member this.OnPopState(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"popstate\", cb)\n    [<Inline>]\n    member this.OnProgress(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"progress\", cb)\n    [<Inline>]\n    member this.OnRateChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"ratechange\", cb)\n    [<Inline>]\n    member this.OnReadyStateChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"readystatechange\", cb)\n    [<Inline>]\n    member this.OnRepeatEvent(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"repeatEvent\", cb)\n    [<Inline>]\n    member this.OnReset(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"reset\", cb)\n    [<Inline>]\n    member this.OnResize(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"resize\", cb)\n    [<Inline>]\n    member this.OnScroll(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"scroll\", cb)\n    [<Inline>]\n    member this.OnSeeked(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"seeked\", cb)\n    [<Inline>]\n    member this.OnSeeking(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"seeking\", cb)\n    [<Inline>]\n    member this.OnSelect(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"select\", cb)\n    [<Inline>]\n    member this.OnShow(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.MouseEvent -> unit>) = this.onExpr(\"show\", cb)\n    [<Inline>]\n    member this.OnStalled(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"stalled\", cb)\n    [<Inline>]\n    member this.OnStorage(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"storage\", cb)\n    [<Inline>]\n    member this.OnSubmit(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"submit\", cb)\n    [<Inline>]\n    member this.OnSuccess(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"success\", cb)\n    [<Inline>]\n    member this.OnSuspend(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"suspend\", cb)\n    [<Inline>]\n    member this.OnSVGAbort(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGAbort\", cb)\n    [<Inline>]\n    member this.OnSVGError(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGError\", cb)\n    [<Inline>]\n    member this.OnSVGLoad(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGLoad\", cb)\n    [<Inline>]\n    member this.OnSVGResize(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGResize\", cb)\n    [<Inline>]\n    member this.OnSVGScroll(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGScroll\", cb)\n    [<Inline>]\n    member this.OnSVGUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGUnload\", cb)\n    [<Inline>]\n    member this.OnSVGZoom(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"SVGZoom\", cb)\n    [<Inline>]\n    member this.OnTimeOut(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"timeout\", cb)\n    [<Inline>]\n    member this.OnTimeUpdate(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"timeupdate\", cb)\n    [<Inline>]\n    member this.OnTouchCancel(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchcancel\", cb)\n    [<Inline>]\n    member this.OnTouchEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchend\", cb)\n    [<Inline>]\n    member this.OnTouchEnter(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchenter\", cb)\n    [<Inline>]\n    member this.OnTouchLeave(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchleave\", cb)\n    [<Inline>]\n    member this.OnTouchMove(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchmove\", cb)\n    [<Inline>]\n    member this.OnTouchStart(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"touchstart\", cb)\n    [<Inline>]\n    member this.OnTransitionEnd(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"transitionend\", cb)\n    [<Inline>]\n    member this.OnUnload(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.UIEvent -> unit>) = this.onExpr(\"unload\", cb)\n    [<Inline>]\n    member this.OnUpdateReady(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"updateready\", cb)\n    [<Inline>]\n    member this.OnUpgradeNeeded(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"upgradeneeded\", cb)\n    [<Inline>]\n    member this.OnUserProximity(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"userproximity\", cb)\n    [<Inline>]\n    member this.OnVersionChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"versionchange\", cb)\n    [<Inline>]\n    member this.OnVisibilityChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"visibilitychange\", cb)\n    [<Inline>]\n    member this.OnVolumeChange(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"volumechange\", cb)\n    [<Inline>]\n    member this.OnWaiting(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.Event -> unit>) = this.onExpr(\"waiting\", cb)\n    [<Inline>]\n    member this.OnWheel(cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> Dom.WheelEvent -> unit>) = this.onExpr(\"wheel\", cb)\n    // }}\n\nand [<JavaScript; Proxy(typeof<EltUpdater>)>] \n    internal EltUpdater'(treeNode : DocTreeNode, updates, elt, rvUpdates: Updates, holeUpdates: Var<(int * View<unit>)[]>) =\n    inherit Elt'(\n        TreeDoc treeNode, \n        View.Map2Unit updates (holeUpdates.View |> View.BindInner (Array.map snd >> Array.TreeReduce (View.Const ()) View.Map2Unit)),\n        elt, rvUpdates)\n\n    let mutable origHoles = treeNode.Holes\n\n    override this.AddHole h =\n        origHoles.JS.Push h |> ignore\n        treeNode.Holes <- Array.append treeNode.Holes [| h |]\n\n    override this.ClearHoles() =\n        origHoles <- [||]\n        treeNode.Holes <- [||]\n        holeUpdates.Value <- [||]\n\n    member this.AddUpdated(doc: Elt') =\n        match doc.DocNode with\n        | ElemDoc e ->\n            treeNode.Holes <- Array.append treeNode.Holes [| e |]\n            let hu = holeUpdates.Value\n            hu.JS.Push ((e.ElKey, doc.Updates)) |> ignore\n            holeUpdates.Value <- hu\n        | _ -> failwith \"DocUpdater.AddUpdated expects a single element node\"\n\n    member this.RemoveUpdated(doc: Elt') =\n        match doc.DocNode with\n        | ElemDoc e ->\n            let k = e.ElKey\n            treeNode.Holes <-\n                treeNode.Holes |> Array.filter (fun h -> h.ElKey <> k)\n            holeUpdates.Value <-\n                holeUpdates.Value |> Array.filter (function\n                    | uk, _ when uk = k -> false\n                    | _ -> true\n                )  \n        | _ -> failwith \"DocUpdater.RemoveUpdated expects a single element node\"\n\n    member this.RemoveAllUpdated() =\n        treeNode.Holes <- origHoles\n        holeUpdates.Value <- [||]\n", "namespace WebSharper.UI.Client\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\n\n[<JavaScript>]\nmodule internal Templates =\n\n    let LoadedTemplates = Dictionary<string, Dictionary<string, Dom.Element>>()\n    let LoadedTemplateFile name =\n        match LoadedTemplates.TryGetValue name with\n        | true, d -> d\n        | false, _ ->\n            let d = Dictionary()\n            LoadedTemplates.[name] <- d\n            d\n    let mutable LocalTemplatesLoaded = false\n\n    let TextHoleRE = \"\"\"\\${([^}]+)}\"\"\"\n\n    let InlineTemplate (el: Dom.Element) (fillWith: seq<TemplateHole>) =\n        let holes : DocElemNode[] = [||]\n        let updates : View<unit>[] = [||]\n        let attrs : (Dom.Element * Attrs.Dyn)[] = [||]\n        let afterRender : (Dom.Element -> unit)[] = [||]\n        let fw = Dictionary()\n        for x in fillWith do fw.[TemplateHole.Name x] <- x\n        let els = As<Union<Dom.Node, DocNode>[]> (DomUtility.ChildrenArray el)\n        let addAttr (el: Dom.Element) (attr: Attr) =\n            let attr = Attrs.Insert el attr\n            updates.JS.Push (Attrs.Updates attr) |> ignore\n            attrs.JS.Push ((el, attr)) |> ignore\n            match Attrs.GetOnAfterRender attr with\n            | Some f -> afterRender.JS.Push(fun _ -> f el) |> ignore\n            | None -> ()\n        let tryGetAsDoc name =\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Elt (_, doc) -> Some (As<Doc'> doc)\n            | true, TemplateHole.Text (_, text) -> Some (Doc'.TextNode text)\n            | true, TemplateHole.TextView (_, tv) -> Some (Doc'.TextView tv)\n            | true, TemplateHole.VarStr (_, v) -> Some (Doc'.TextView v.View)\n            | true, TemplateHole.VarBool (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarInt (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarIntUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarFloat (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarFloatUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, _ -> Console.Warn(\"Content hole filled with attribute data\", name); None\n            | false, _ -> None\n\n        DomUtility.IterSelector el \"[ws-hole]\" <| fun p ->\n            let name = p.GetAttribute(\"ws-hole\")\n            p.RemoveAttribute(\"ws-hole\")\n            while (p.HasChildNodes()) do\n                p.RemoveChild(p.LastChild) |> ignore\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                Docs.LinkElement p doc.DocNode\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = None\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-replace]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-replace\")\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                let p = e.ParentNode :?> Dom.Element\n                let after = JS.Document.CreateTextNode(\"\") :> Dom.Node\n                p.ReplaceChild(after, e) |> ignore\n                let before = Docs.InsertBeforeDelim after doc.DocNode\n                els\n                |> Array.tryFindIndex ((===.) e)\n                |> Option.iter (fun i -> els.[i] <- Union2Of2 doc.DocNode)\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = Some (before, after)\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-attr]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-attr\")\n            e.RemoveAttribute(\"ws-attr\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Attribute (_, attr) -> addAttr e attr\n            | true, _ -> Console.Warn(\"Attribute hole filled with non-attribute data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-on]\" <| fun e ->\n            e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Array.choose (fun x ->\n                let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                match fw.TryGetValue(a.[1]) with\n                | true, TemplateHole.Event (_, handler) -> Some (Attr.Handler a.[0] handler)\n                | true, TemplateHole.EventQ (_, _, handler) -> Some (A.Handler a.[0] handler)\n                | true, _ ->\n                    Console.Warn(\"Event hole on\" + a.[0] + \" filled with non-event data\", a.[1])\n                    None\n                | false, _ -> None\n            )\n            |> Attr.Concat\n            |> addAttr e\n            e.RemoveAttribute(\"ws-on\")\n\n        DomUtility.IterSelector el \"[ws-onafterrender]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-onafterrender\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.AfterRender (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender handler)\n            | true, TemplateHole.AfterRenderQ (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender (As handler))\n            | true, _ -> Console.Warn(\"onafterrender hole filled with non-onafterrender data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-var]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-var\")\n            e.RemoveAttribute(\"ws-var\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.VarStr (_, var) -> addAttr e (Attr.Value var)\n            | true, TemplateHole.VarBool (_, var) -> addAttr e (Attr.Checked var)\n            | true, TemplateHole.VarInt (_, var) -> addAttr e (Attr.IntValue var)\n            | true, TemplateHole.VarIntUnchecked (_, var) -> addAttr e (Attr.IntValueUnchecked var)\n            | true, TemplateHole.VarFloat (_, var) -> addAttr e (Attr.FloatValue var)\n            | true, TemplateHole.VarFloatUnchecked (_, var) -> addAttr e (Attr.FloatValueUnchecked var)\n            | true, _ -> Console.Warn(\"Var hole filled with non-Var data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-attr-holes]\" <| fun e ->\n            let re = new RegExp(TextHoleRE, \"g\")\n            let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            e.RemoveAttribute(\"ws-attr-holes\")\n            for attrName in holeAttrs do\n                let s = e.GetAttribute(attrName)\n                let mutable m = null\n                let mutable lastIndex = 0\n                let res : (string * string)[] = [||]\n                while (m <- re.Exec s; m !==. null) do\n                    let textBefore = s.[lastIndex .. re.LastIndex-m.[0].Length-1]\n                    lastIndex <- re.LastIndex\n                    let holeName = m.[1]\n                    res.JS.Push((textBefore, holeName)) |> ignore\n                let finalText = s.[lastIndex..]\n                re.LastIndex <- 0\n                let value =\n                    Array.foldBack (fun (textBefore, holeName: string) (textAfter, views) ->\n                        let holeContent =\n                            match fw.TryGetValue(holeName) with\n                            | true, TemplateHole.Text (_, t) -> Choice1Of2 t\n                            | true, TemplateHole.TextView (_, v) -> Choice2Of2 v\n                            | true, TemplateHole.VarStr (_, v) -> Choice2Of2 v.View\n                            | true, TemplateHole.VarBool (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarInt (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarIntUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarFloat (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarFloatUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, _ ->\n                                Console.Warn(\"Attribute value hole filled with non-text data\", holeName)\n                                Choice1Of2 \"\"\n                            | false, _ -> Choice1Of2 \"\"\n                        match holeContent with\n                        | Choice1Of2 text -> textBefore + text + textAfter, views\n                        | Choice2Of2 v ->\n                            let v =\n                                if textAfter = \"\" then v else\n                                View.Map (fun s -> s + textAfter) v\n                            textBefore, v :: views\n                    ) res (finalText, [])\n                match value with\n                | s, [] -> Attr.Create attrName s\n                | \"\", [v] -> Attr.Dynamic attrName v\n                | s, [v] -> Attr.Dynamic attrName (View.Map (fun v -> s + v) v)\n                | s, [v1; v2] -> Attr.Dynamic attrName (View.Map2 (fun v1 v2 -> s + v1 + v2) v1 v2)\n                | s, [v1; v2; v3] -> Attr.Dynamic attrName (View.Map3 (fun v1 v2 v3 -> s + v1 + v2 + v3) v1 v2 v3)\n                | s, vs ->\n                    View.Sequence vs\n                    |> View.Map (fun vs -> s + String.concat \"\" vs)\n                    |> Attr.Dynamic attrName\n                |> addAttr e\n\n        let docTreeNode : DocTreeNode =\n            {\n                Els = els\n                Holes = holes\n                Attrs = attrs\n                Render =\n                    if Array.isEmpty afterRender\n                    then None\n                    else Some (fun el -> Array.iter (fun f -> f el) afterRender)\n                Dirty = true\n                El =\n                    match els with\n                    | [| Union1Of2 (:? Dom.Element as el) |] -> Some el\n                    | _ -> None\n            }\n        let updates =\n            updates |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        docTreeNode, updates\n\n    let ChildrenTemplate (el: Dom.Element) (fillWith: seq<TemplateHole>) =\n        let docTreeNode, updates = InlineTemplate el fillWith\n        match docTreeNode.Els with\n        | [| Union1Of2 e |] when e.NodeType = Dom.NodeType.Element ->\n            Elt'.TreeNode(docTreeNode, updates) :> Doc'\n        | _ ->\n            Doc'.Mk (TreeDoc docTreeNode) updates\n\n    let FakeRoot (els: Dom.Node[]) =\n        let fakeroot = JS.Document.CreateElement(\"div\")\n        for el in els do fakeroot.AppendChild el |> ignore\n        fakeroot\n\n    let FakeRootSingle (el: Dom.Element) =\n        el.RemoveAttribute(\"ws-template\")\n        match el.GetAttribute(\"ws-replace\") with\n        | null -> ()\n        | replace ->\n            el.RemoveAttribute(\"ws-replace\")\n            match el.ParentNode with\n            | null -> ()\n            | p ->\n                let n = JS.Document.CreateElement(el.TagName)\n                n.SetAttribute(\"ws-replace\", replace)\n                p.ReplaceChild(n, el) |> ignore\n        FakeRoot [| el |]\n\n    module private Prepare =\n\n        let convertAttrs (el: Dom.Element) =\n            let attrs = el.Attributes\n            let toRemove = [||]\n            let events = [||]\n            let holedAttrs = [||]\n            for i = 0 to attrs.Length - 1 do\n                let a = attrs.[i]\n                if a.NodeName.StartsWith \"ws-on\" && a.NodeName <> \"ws-onafterrender\" && a.NodeName <> \"ws-on\" then\n                    toRemove.JS.Push(a.NodeName) |> ignore\n                    events.JS.Push(a.NodeName.[\"ws-on\".Length..] + \":\" + a.NodeValue.ToLower()) |> ignore\n                elif not (a.NodeName.StartsWith \"ws-\") && RegExp(TextHoleRE).Test(a.NodeValue) then\n                    a.NodeValue <-\n                        RegExp(TextHoleRE, \"g\")\n                            .Replace(a.NodeValue, FuncWithArgs (fun (_, h: string) ->\n                                \"${\" + h.ToLower() + \"}\"))\n                    holedAttrs.JS.Push(a.NodeName) |> ignore\n            if not (Array.isEmpty events) then\n                el.SetAttribute(\"ws-on\", String.concat \" \" events)\n            if not (Array.isEmpty holedAttrs) then\n                el.SetAttribute(\"ws-attr-holes\", String.concat \" \" holedAttrs)\n            let lowercaseAttr name =\n                match el.GetAttribute(name) with\n                | null -> ()\n                | x -> el.SetAttribute(name, x.ToLower())\n            lowercaseAttr \"ws-hole\"\n            lowercaseAttr \"ws-replace\"\n            lowercaseAttr \"ws-attr\"\n            lowercaseAttr \"ws-onafterrender\"\n            lowercaseAttr \"ws-var\"\n            Array.iter el.RemoveAttribute toRemove\n\n        let convertTextNode (n: Dom.Node) =\n            let mutable m = null\n            let mutable li = 0\n            let s = n.TextContent\n            let strRE = RegExp(TextHoleRE, \"g\")\n            while (m <- strRE.Exec s; m !==. null) do\n                n.ParentNode.InsertBefore(JS.Document.CreateTextNode(s.[li..strRE.LastIndex-m.[0].Length-1]), n) |> ignore\n                li <- strRE.LastIndex\n                let hole = JS.Document.CreateElement(\"span\")\n                hole.SetAttribute(\"ws-replace\", m.[1].ToLower())\n                n.ParentNode.InsertBefore(hole, n) |> ignore\n            strRE.LastIndex <- 0\n            n.TextContent <- s.[li..]\n\n        let mapHoles (t: Dom.Element) (mappings: Dictionary<string, string>) =\n            let run attrName =\n                DomUtility.IterSelector t (\"[\" + attrName + \"]\") <| fun e ->\n                    match mappings.TryGetValue(e.GetAttribute(attrName).ToLower()) with\n                    | true, m -> e.SetAttribute(attrName, m)\n                    | false, _ -> ()\n            run \"ws-hole\"\n            run \"ws-replace\"\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector t \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.map (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        match mappings.TryGetValue(a.[1]) with\n                        | true, x -> a.[0] + \":\" + x\n                        | false, _ -> x\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector t \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        (e.GetAttribute(attrName), mappings)\n                        ||> Seq.fold (fun s (KeyValue(a, m)) ->\n                            RegExp(\"\\\\${\" + a + \"}\", \"ig\").Replace(s, \"${\" + m + \"}\")\n                        )\n                    e.SetAttribute(attrName, s)\n\n        let fillInstanceAttrs (instance: Dom.Element) (fillWith: Dom.Element) =\n            convertAttrs fillWith\n            let name = fillWith.NodeName.ToLower()\n            match instance.QuerySelector(\"[ws-attr=\" + name + \"]\") with\n            | null -> Console.Warn(\"Filling non-existent attr hole\", name)\n            | e ->\n                e.RemoveAttribute(\"ws-attr\")\n                for i = 0 to fillWith.Attributes.Length - 1 do\n                    let a = fillWith.Attributes.[i]\n                    if a.Name = \"class\" && e.HasAttribute(\"class\") then\n                        e.SetAttribute(\"class\", e.GetAttribute(\"class\") + \" \" + a.NodeValue)\n                    else\n                        e.SetAttribute(a.Name, a.NodeValue)\n\n        let removeHolesExcept (instance: Dom.Element) (dontRemove: HashSet<string>) =\n            let run attrName =\n                DomUtility.IterSelector instance (\"[\" + attrName + \"]\") <| fun e ->\n                    if not (dontRemove.Contains(e.GetAttribute attrName)) then\n                        e.RemoveAttribute(attrName)\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector instance \"[ws-hole]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-hole\")) then\n                    e.RemoveAttribute(\"ws-hole\")\n                    while e.HasChildNodes() do\n                        e.RemoveChild(e.LastChild) |> ignore\n            DomUtility.IterSelector instance \"[ws-replace]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-replace\")) then\n                    e.ParentNode.RemoveChild(e) |> ignore\n            DomUtility.IterSelector instance \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.filter (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        dontRemove.Contains a.[1]\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        RegExp(TextHoleRE, \"g\")\n                            .Replace(e.GetAttribute(attrName), FuncWithArgs(fun (full: string, h: string) ->\n                                if dontRemove.Contains h then full else \"\"\n                            ))\n                    e.SetAttribute(attrName, s)\n\n        let fillTextHole (instance: Dom.Element) (fillWith: string) (templateName: string) =\n            match instance.QuerySelector \"[ws-replace]\" with\n            | null ->\n                Console.Warn(\"Filling non-existent text hole\", templateName)\n                None\n            | n ->\n                n.ParentNode.ReplaceChild(Dom.Text fillWith, n) |> ignore\n                Some <| n.GetAttribute(\"ws-replace\")\n\n        let rec fill (fillWith: Dom.Element) (p: Dom.Node) n =\n            if fillWith.HasChildNodes() then\n                fill fillWith p (p.InsertBefore(fillWith.LastChild, n))\n\n        let failNotLoaded (name: string) =\n            Console.Warn(\"Instantiating non-loaded template\", name)\n\n    let rec PrepareTemplateStrict (baseName: string) (name: option<string>) (els: Dom.Node[]) (root: option<Dom.Element>) (prepareLocalTemplate: option<string -> unit>) =\n        let rec fillDocHole (instance: Dom.Element) (fillWith: Dom.Element) =\n            let name = fillWith.NodeName.ToLower()\n            let fillHole (p: Dom.Node) (n: Dom.Node) =\n                // The \"title\" node is treated specially by HTML, its content is considered pure text,\n                // so we need to re-parse it.\n                if name = \"title\" && fillWith.HasChildNodes() then\n                    let parsed = JQuery.JQuery.ParseHTML fillWith.TextContent\n                    fillWith.RemoveChild(fillWith.FirstChild) |> ignore\n                    for i in parsed do\n                        fillWith.AppendChild(i) |> ignore\n                convertElement fillWith\n                Prepare.fill fillWith p n\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    e.SetAttribute(attrName,\n                        RegExp(\"\\\\${\" + name + \"}\", \"ig\").\n                            Replace(e.GetAttribute(attrName), fillWith.TextContent)\n                    )\n            match instance.QuerySelector(\"[ws-hole=\" + name + \"]\") with\n            | null ->\n                match instance.QuerySelector(\"[ws-replace=\" + name + \"]\") with\n                | null -> ()\n                | e ->\n                    fillHole e.ParentNode e\n                    e.ParentNode.RemoveChild(e) |> ignore\n            | e ->\n                while e.HasChildNodes() do\n                    e.RemoveChild(e.LastChild) |> ignore\n                e.RemoveAttribute(\"ws-hole\")\n                fillHole e null\n\n        and convertElement (el: Dom.Element) =\n            if el.NodeName.ToLower().StartsWith \"ws-\" then\n                convertInstantiation el\n            else\n                Prepare.convertAttrs el\n                convertNodeAndSiblings el.FirstChild\n\n        and convertNodeAndSiblings (n: Dom.Node) =\n            if n !==. null then\n                let next = n.NextSibling\n                if n.NodeType = Dom.NodeType.Text then\n                    Prepare.convertTextNode n\n                elif n.NodeType = Dom.NodeType.Element then\n                    convertElement (n :?> Dom.Element)\n                convertNodeAndSiblings next\n\n        and convertInstantiation (el: Dom.Element) =\n            let name = el.NodeName.[3..].ToLower()\n            let instBaseName, instName =\n                match name.IndexOf('.') with\n                | -1 -> baseName, name\n                | n -> name.[..n-1], name.[n+1..]\n            if instBaseName <> \"\" && not (LoadedTemplates.ContainsKey instBaseName) then\n                Prepare.failNotLoaded instName\n            else\n            if instBaseName = \"\" && prepareLocalTemplate.IsSome then\n                prepareLocalTemplate.Value instName\n            let d = LoadedTemplates.[instBaseName]\n            if not (d.ContainsKey instName) then Prepare.failNotLoaded instName else\n            let t = d.[instName]\n            let instance = t.CloneNode(true) :?> Dom.Element\n            let usedHoles = HashSet()\n            let mappings = Dictionary()\n            // 1. gather mapped and filled holes.\n            let attrs = el.Attributes\n            for i = 0 to attrs.Length - 1 do\n                let name = attrs.[i].Name.ToLower()\n                let mappedName = match attrs.[i].NodeValue with \"\" -> name | s -> s.ToLower()\n                mappings.[name] <- mappedName\n                if not (usedHoles.Add(name)) then\n                    Console.Warn(\"Hole mapped twice\", name)\n            for i = 0 to el.ChildNodes.Length - 1 do\n                let n = el.ChildNodes.[i]\n                if n.NodeType = Dom.NodeType.Element then\n                    let n = n :?> Dom.Element\n                    if not (usedHoles.Add(n.NodeName.ToLower())) then\n                        Console.Warn(\"Hole filled twice\", instName)\n            // 2. If single text hole, apply it.\n            let singleTextFill = el.ChildNodes.Length = 1 && el.FirstChild.NodeType = Dom.NodeType.Text\n            if singleTextFill then\n                Prepare.fillTextHole instance el.FirstChild.TextContent instName\n                |> Option.iter (usedHoles.Add >> ignore)\n            // 3. eliminate non-mapped/filled holes.\n            Prepare.removeHolesExcept instance usedHoles\n            // 4. apply mappings/fillings.\n            if not singleTextFill then\n                for i = 0 to el.ChildNodes.Length - 1 do\n                    let n = el.ChildNodes.[i]\n                    if n.NodeType = Dom.NodeType.Element then\n                        let n = n :?> Dom.Element\n                        if n.HasAttributes() then\n                            Prepare.fillInstanceAttrs instance n\n                        else\n                            fillDocHole instance n\n            Prepare.mapHoles instance mappings\n            // 5. insert result.\n            Prepare.fill instance el.ParentNode el\n            el.ParentNode.RemoveChild(el) |> ignore\n\n        let rec convertNestedTemplates (el: Dom.Element) =\n            match el.QuerySelector \"[ws-template]\" with\n            | null ->\n                match el.QuerySelector \"[ws-children-template]\" with\n                | null -> ()\n                | n ->\n                    let name = n.GetAttribute \"ws-children-template\"\n                    n.RemoveAttribute \"ws-children-template\"\n                    PrepareTemplateStrict baseName (Some name) (DomUtility.ChildrenArray n) None None\n                    convertNestedTemplates el\n            | n ->\n                let name = n.GetAttribute \"ws-template\"\n                PrepareSingleTemplate baseName (Some name) n None\n                convertNestedTemplates el\n\n        let fakeroot = root |> Option.defaultWith (fun () -> FakeRoot els)\n        let name = (defaultArg name \"\").ToLower()\n        LoadedTemplateFile(baseName).[name] <- fakeroot\n        if els.Length > 0 then\n            convertNestedTemplates fakeroot\n            convertNodeAndSiblings els.[0]\n\n    and PrepareSingleTemplate (baseName: string) (name: option<string>) (el: Dom.Element) =\n        let root = FakeRootSingle el\n        PrepareTemplateStrict baseName name [| el |] (Some root)\n\n    let PrepareTemplate (baseName: string) (name: option<string>) (els: unit -> Dom.Node[]) =\n        if not (LoadedTemplateFile(baseName).ContainsKey(defaultArg name \"\")) then\n            let els = els()\n            for el in els do\n                match el.ParentNode :?> Dom.Element with\n                | null -> ()\n                | p -> p.RemoveChild(el) |> ignore\n            PrepareTemplateStrict baseName name els None None\n\n    /// Load all the templates declared nested under `root` into `baseName`.\n    let LoadNestedTemplates (root: Dom.Element) baseName =\n        let loadedTpls = LoadedTemplateFile baseName\n        let rawTpls = Dictionary()\n        let wsTemplates = root.QuerySelectorAll \"[ws-template]\"\n        for i = 0 to wsTemplates.Length - 1 do\n            let node = wsTemplates.[i] :?> Dom.Element\n            let name = node.GetAttribute(\"ws-template\").ToLower()\n            node.RemoveAttribute(\"ws-template\")\n            rawTpls.[name] <- ([| node :> Dom.Node |], FakeRootSingle node)\n        let wsChildrenTemplates = root.QuerySelectorAll \"[ws-children-template]\"\n        for i = 0 to wsChildrenTemplates.Length - 1 do\n            let node = wsChildrenTemplates.[i] :?> Dom.Element\n            let name = node.GetAttribute(\"ws-children-template\").ToLower()\n            node.RemoveAttribute(\"ws-children-template\")\n            rawTpls.[name] <-\n                let els = DomUtility.ChildrenArray node\n                (els, FakeRoot els)\n        let instantiated = HashSet()\n        let rec prepareTemplate name =\n            if not (loadedTpls.ContainsKey name) then\n                match rawTpls.TryGetValue(name) with\n                | false, _ ->\n                    Console.Warn(\n                        if instantiated.Contains(name)\n                        then \"Encountered loop when instantiating \" + name\n                        else \"Local template does not exist: \" + name)\n                | true, (els, root) ->\n                    instantiated.Add(name) |> ignore\n                    rawTpls.Remove(name) |> ignore\n                    PrepareTemplateStrict baseName (Some name) els (Some root) (Some prepareTemplate)\n        while rawTpls.Count > 0 do\n            prepareTemplate (Seq.head rawTpls.Keys)\n\n    let LoadLocalTemplates (baseName: string) =\n        if not LocalTemplatesLoaded then\n            LocalTemplatesLoaded <- true\n            LoadNestedTemplates JS.Document.Body \"\"\n        LoadedTemplates.[baseName] <- LoadedTemplateFile(\"\")\n\n    let RunFullDocTemplate (fillWith: seq<TemplateHole>) =\n        LoadLocalTemplates \"\"\n        PrepareTemplateStrict \"\" None (DomUtility.ChildrenArray JS.Document.Body) (Some JS.Document.Body) None\n        ChildrenTemplate JS.Document.Body fillWith\n        |>! Doc'.RunInPlace true JS.Document.Body\n\n    let Template (els: Dom.Node[]) (fillWith: seq<TemplateHole>) =\n        ChildrenTemplate (FakeRoot els) fillWith\n\n    let NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) =\n        match LoadedTemplateFile(baseName).TryGetValue(defaultArg name \"\") with\n        | true, t -> ChildrenTemplate (t.CloneNode(true) :?> Dom.Element) fillWith\n        | false, _ -> Console.Warn(\"Local template doesn't exist\", name); Doc'.Empty\n\n    let GetOrLoadTemplate (baseName: string) (name: option<string>) (els: unit -> Dom.Node[]) (fillWith: seq<TemplateHole>) =\n        LoadLocalTemplates \"\"\n        PrepareTemplate baseName name els\n        NamedTemplate baseName name fillWith\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\nopen WebSharper\n\nopen System\nopen WebSharper.UI.Client\n\n[<JavaScript>]\ntype Flow<'T>(render: Var<Doc> -> ('T -> unit) -> unit) =\n\n    new (define: Func<Func<'T, unit>, Doc>) =\n        Flow(fun var cont -> Var.Set var (define.Invoke (Func<_,_>(cont))))\n\n    member this.Render = render\n\n[<JavaScript>]\n[<Sealed>]\ntype Flow =\n\n    static member Map f (x: Flow<'A>) =\n        Flow(fun var cont -> x.Render var (fun r -> (f r) |> cont))\n\n    // \"Unwrap\" the value from the flowlet, use it as an argument to the\n    // continuation k, and return the value of the applied continuation.\n\n    // Semantically, what we're doing here is running the form (or other\n    // input mechanism, but let's stick with thinking about forms), getting\n    // the result, and then using this as an input to the continuation.\n    static member Bind (m: Flow<'A>) (k: 'A -> Flow<'B>) =\n        Flow(fun var cont -> m.Render var (fun r -> (k r).Render var cont))\n\n    static member Return x =\n        Flow(fun var cont -> cont x)\n\n    static member Embed (fl: Flow<'A>) =\n        let var = Var.Create Doc.Empty\n        fl.Render var ignore\n        Doc.EmbedView var.View\n\n    static member Define (f: ('A -> unit) -> Doc) =\n        Flow(Func<_,_>(fun (x: Func<'A, unit>) -> f x.Invoke))\n\n    static member Static doc =\n        Flow(fun var cont -> Var.Set var doc; cont ())\n\n[<JavaScript>]\n[<Sealed>]\ntype FlowBuilder() =\n    member x.Bind(comp, func) = Flow.Bind comp func\n    member x.Return(value) = Flow.Return value\n    member x.ReturnFrom(inner: Flow<'A>) = inner\n\ntype Flow with\n\n    static member Do =\n        FlowBuilder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n#nowarn \"44\" // HTML deprecated\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n/// This is an auto-generated module providing HTML5 vocabulary.\n/// Generated using tags.csv from WebSharper;\n/// See tools/UpdateElems.fsx for the code-generation logic.\n// Warning: don't mark this module as JavaScript: some submodules _must_ not\n// be JavaScript because they are proxied.\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Html =\n\n    /// Create a text node with constant content, or with dynamic content using `view.V`.\n    [<JavaScript; Inline; Macro(typeof<Macros.TextView>)>]\n    let text t = Doc.TextNode t\n\n    /// Create a text node with dynamic content.\n    [<JavaScript; Inline>]\n    let textView v = Client.Doc.TextView v\n\n    /// Insert a client-side Doc.\n    [<JavaScript; Inline>]\n    let client ([<ReflectedDefinition; JavaScript>] q) = Doc.ClientSide q\n\n    module Elt =\n\n        // {{ tag normal colliding deprecated [elt]\n        /// Create an HTML element <a> with attributes and children.\n        [<JavaScript; Inline>]\n        let a ats ch = Doc.Element \"a\" ats ch\n        /// Create an HTML element <abbr> with attributes and children.\n        [<JavaScript; Inline>]\n        let abbr ats ch = Doc.Element \"abbr\" ats ch\n        /// Create an HTML element <acronym> with attributes and children.\n        [<JavaScript; Inline>]\n        let acronym ats ch = Doc.Element \"acronym\" ats ch\n        /// Create an HTML element <address> with attributes and children.\n        [<JavaScript; Inline>]\n        let address ats ch = Doc.Element \"address\" ats ch\n        /// Create an HTML element <applet> with attributes and children.\n        [<JavaScript; Inline>]\n        let applet ats ch = Doc.Element \"applet\" ats ch\n        /// Create an HTML element <area> with attributes and children.\n        [<JavaScript; Inline>]\n        let area ats ch = Doc.Element \"area\" ats ch\n        /// Create an HTML element <article> with attributes and children.\n        [<JavaScript; Inline>]\n        let article ats ch = Doc.Element \"article\" ats ch\n        /// Create an HTML element <aside> with attributes and children.\n        [<JavaScript; Inline>]\n        let aside ats ch = Doc.Element \"aside\" ats ch\n        /// Create an HTML element <audio> with attributes and children.\n        [<JavaScript; Inline>]\n        let audio ats ch = Doc.Element \"audio\" ats ch\n        /// Create an HTML element <b> with attributes and children.\n        [<JavaScript; Inline>]\n        let b ats ch = Doc.Element \"b\" ats ch\n        /// Create an HTML element <base> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``base`` ats ch = Doc.Element \"base\" ats ch\n        /// Create an HTML element <basefont> with attributes and children.\n        [<JavaScript; Inline>]\n        let basefont ats ch = Doc.Element \"basefont\" ats ch\n        /// Create an HTML element <bdi> with attributes and children.\n        [<JavaScript; Inline>]\n        let bdi ats ch = Doc.Element \"bdi\" ats ch\n        /// Create an HTML element <bdo> with attributes and children.\n        [<JavaScript; Inline>]\n        let bdo ats ch = Doc.Element \"bdo\" ats ch\n        /// Create an HTML element <big> with attributes and children.\n        [<JavaScript; Inline>]\n        let big ats ch = Doc.Element \"big\" ats ch\n        /// Create an HTML element <blockquote> with attributes and children.\n        [<JavaScript; Inline>]\n        let blockquote ats ch = Doc.Element \"blockquote\" ats ch\n        /// Create an HTML element <body> with attributes and children.\n        [<JavaScript; Inline>]\n        let body ats ch = Doc.Element \"body\" ats ch\n        /// Create an HTML element <br> with attributes and children.\n        [<JavaScript; Inline>]\n        let br ats ch = Doc.Element \"br\" ats ch\n        /// Create an HTML element <button> with attributes and children.\n        [<JavaScript; Inline>]\n        let button ats ch = Doc.Element \"button\" ats ch\n        /// Create an HTML element <canvas> with attributes and children.\n        [<JavaScript; Inline>]\n        let canvas ats ch = Doc.Element \"canvas\" ats ch\n        /// Create an HTML element <caption> with attributes and children.\n        [<JavaScript; Inline>]\n        let caption ats ch = Doc.Element \"caption\" ats ch\n        /// Create an HTML element <center> with attributes and children.\n        [<JavaScript; Inline>]\n        let center ats ch = Doc.Element \"center\" ats ch\n        /// Create an HTML element <cite> with attributes and children.\n        [<JavaScript; Inline>]\n        let cite ats ch = Doc.Element \"cite\" ats ch\n        /// Create an HTML element <code> with attributes and children.\n        [<JavaScript; Inline>]\n        let code ats ch = Doc.Element \"code\" ats ch\n        /// Create an HTML element <col> with attributes and children.\n        [<JavaScript; Inline>]\n        let col ats ch = Doc.Element \"col\" ats ch\n        /// Create an HTML element <colgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let colgroup ats ch = Doc.Element \"colgroup\" ats ch\n        /// Create an HTML element <command> with attributes and children.\n        [<JavaScript; Inline>]\n        let command ats ch = Doc.Element \"command\" ats ch\n        /// Create an HTML element <content> with attributes and children.\n        [<JavaScript; Inline>]\n        let content ats ch = Doc.Element \"content\" ats ch\n        /// Create an HTML element <data> with attributes and children.\n        [<JavaScript; Inline>]\n        let data ats ch = Doc.Element \"data\" ats ch\n        /// Create an HTML element <datalist> with attributes and children.\n        [<JavaScript; Inline>]\n        let datalist ats ch = Doc.Element \"datalist\" ats ch\n        /// Create an HTML element <dd> with attributes and children.\n        [<JavaScript; Inline>]\n        let dd ats ch = Doc.Element \"dd\" ats ch\n        /// Create an HTML element <del> with attributes and children.\n        [<JavaScript; Inline>]\n        let del ats ch = Doc.Element \"del\" ats ch\n        /// Create an HTML element <details> with attributes and children.\n        [<JavaScript; Inline>]\n        let details ats ch = Doc.Element \"details\" ats ch\n        /// Create an HTML element <dfn> with attributes and children.\n        [<JavaScript; Inline>]\n        let dfn ats ch = Doc.Element \"dfn\" ats ch\n        /// Create an HTML element <dir> with attributes and children.\n        [<JavaScript; Inline>]\n        let dir ats ch = Doc.Element \"dir\" ats ch\n        /// Create an HTML element <div> with attributes and children.\n        [<JavaScript; Inline>]\n        let div ats ch = Doc.Element \"div\" ats ch\n        /// Create an HTML element <dl> with attributes and children.\n        [<JavaScript; Inline>]\n        let dl ats ch = Doc.Element \"dl\" ats ch\n        /// Create an HTML element <dt> with attributes and children.\n        [<JavaScript; Inline>]\n        let dt ats ch = Doc.Element \"dt\" ats ch\n        /// Create an HTML element <em> with attributes and children.\n        [<JavaScript; Inline>]\n        let em ats ch = Doc.Element \"em\" ats ch\n        /// Create an HTML element <embed> with attributes and children.\n        [<JavaScript; Inline>]\n        let embed ats ch = Doc.Element \"embed\" ats ch\n        /// Create an HTML element <fieldset> with attributes and children.\n        [<JavaScript; Inline>]\n        let fieldset ats ch = Doc.Element \"fieldset\" ats ch\n        /// Create an HTML element <figcaption> with attributes and children.\n        [<JavaScript; Inline>]\n        let figcaption ats ch = Doc.Element \"figcaption\" ats ch\n        /// Create an HTML element <figure> with attributes and children.\n        [<JavaScript; Inline>]\n        let figure ats ch = Doc.Element \"figure\" ats ch\n        /// Create an HTML element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Doc.Element \"font\" ats ch\n        /// Create an HTML element <footer> with attributes and children.\n        [<JavaScript; Inline>]\n        let footer ats ch = Doc.Element \"footer\" ats ch\n        /// Create an HTML element <form> with attributes and children.\n        [<JavaScript; Inline>]\n        let form ats ch = Doc.Element \"form\" ats ch\n        /// Create an HTML element <frame> with attributes and children.\n        [<JavaScript; Inline>]\n        let frame ats ch = Doc.Element \"frame\" ats ch\n        /// Create an HTML element <frameset> with attributes and children.\n        [<JavaScript; Inline>]\n        let frameset ats ch = Doc.Element \"frameset\" ats ch\n        /// Create an HTML element <h1> with attributes and children.\n        [<JavaScript; Inline>]\n        let h1 ats ch = Doc.Element \"h1\" ats ch\n        /// Create an HTML element <h2> with attributes and children.\n        [<JavaScript; Inline>]\n        let h2 ats ch = Doc.Element \"h2\" ats ch\n        /// Create an HTML element <h3> with attributes and children.\n        [<JavaScript; Inline>]\n        let h3 ats ch = Doc.Element \"h3\" ats ch\n        /// Create an HTML element <h4> with attributes and children.\n        [<JavaScript; Inline>]\n        let h4 ats ch = Doc.Element \"h4\" ats ch\n        /// Create an HTML element <h5> with attributes and children.\n        [<JavaScript; Inline>]\n        let h5 ats ch = Doc.Element \"h5\" ats ch\n        /// Create an HTML element <h6> with attributes and children.\n        [<JavaScript; Inline>]\n        let h6 ats ch = Doc.Element \"h6\" ats ch\n        /// Create an HTML element <head> with attributes and children.\n        [<JavaScript; Inline>]\n        let head ats ch = Doc.Element \"head\" ats ch\n        /// Create an HTML element <header> with attributes and children.\n        [<JavaScript; Inline>]\n        let header ats ch = Doc.Element \"header\" ats ch\n        /// Create an HTML element <hgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let hgroup ats ch = Doc.Element \"hgroup\" ats ch\n        /// Create an HTML element <hr> with attributes and children.\n        [<JavaScript; Inline>]\n        let hr ats ch = Doc.Element \"hr\" ats ch\n        /// Create an HTML element <html> with attributes and children.\n        [<JavaScript; Inline>]\n        let html ats ch = Doc.Element \"html\" ats ch\n        /// Create an HTML element <i> with attributes and children.\n        [<JavaScript; Inline>]\n        let i ats ch = Doc.Element \"i\" ats ch\n        /// Create an HTML element <iframe> with attributes and children.\n        [<JavaScript; Inline>]\n        let iframe ats ch = Doc.Element \"iframe\" ats ch\n        /// Create an HTML element <img> with attributes and children.\n        [<JavaScript; Inline>]\n        let img ats ch = Doc.Element \"img\" ats ch\n        /// Create an HTML element <input> with attributes and children.\n        [<JavaScript; Inline>]\n        let input ats ch = Doc.Element \"input\" ats ch\n        /// Create an HTML element <ins> with attributes and children.\n        [<JavaScript; Inline>]\n        let ins ats ch = Doc.Element \"ins\" ats ch\n        /// Create an HTML element <isindex> with attributes and children.\n        [<JavaScript; Inline>]\n        let isindex ats ch = Doc.Element \"isindex\" ats ch\n        /// Create an HTML element <kbd> with attributes and children.\n        [<JavaScript; Inline>]\n        let kbd ats ch = Doc.Element \"kbd\" ats ch\n        /// Create an HTML element <keygen> with attributes and children.\n        [<JavaScript; Inline>]\n        let keygen ats ch = Doc.Element \"keygen\" ats ch\n        /// Create an HTML element <label> with attributes and children.\n        [<JavaScript; Inline>]\n        let label ats ch = Doc.Element \"label\" ats ch\n        /// Create an HTML element <legend> with attributes and children.\n        [<JavaScript; Inline>]\n        let legend ats ch = Doc.Element \"legend\" ats ch\n        /// Create an HTML element <li> with attributes and children.\n        [<JavaScript; Inline>]\n        let li ats ch = Doc.Element \"li\" ats ch\n        /// Create an HTML element <link> with attributes and children.\n        [<JavaScript; Inline>]\n        let link ats ch = Doc.Element \"link\" ats ch\n        /// Create an HTML element <main> with attributes and children.\n        [<JavaScript; Inline>]\n        let main ats ch = Doc.Element \"main\" ats ch\n        /// Create an HTML element <map> with attributes and children.\n        [<JavaScript; Inline>]\n        let map ats ch = Doc.Element \"map\" ats ch\n        /// Create an HTML element <mark> with attributes and children.\n        [<JavaScript; Inline>]\n        let mark ats ch = Doc.Element \"mark\" ats ch\n        /// Create an HTML element <menu> with attributes and children.\n        [<JavaScript; Inline>]\n        let menu ats ch = Doc.Element \"menu\" ats ch\n        /// Create an HTML element <menuitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let menuitem ats ch = Doc.Element \"menuitem\" ats ch\n        /// Create an HTML element <meta> with attributes and children.\n        [<JavaScript; Inline>]\n        let meta ats ch = Doc.Element \"meta\" ats ch\n        /// Create an HTML element <meter> with attributes and children.\n        [<JavaScript; Inline>]\n        let meter ats ch = Doc.Element \"meter\" ats ch\n        /// Create an HTML element <nav> with attributes and children.\n        [<JavaScript; Inline>]\n        let nav ats ch = Doc.Element \"nav\" ats ch\n        /// Create an HTML element <noframes> with attributes and children.\n        [<JavaScript; Inline>]\n        let noframes ats ch = Doc.Element \"noframes\" ats ch\n        /// Create an HTML element <noscript> with attributes and children.\n        [<JavaScript; Inline>]\n        let noscript ats ch = Doc.Element \"noscript\" ats ch\n        /// Create an HTML element <object> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``object`` ats ch = Doc.Element \"object\" ats ch\n        /// Create an HTML element <ol> with attributes and children.\n        [<JavaScript; Inline>]\n        let ol ats ch = Doc.Element \"ol\" ats ch\n        /// Create an HTML element <optgroup> with attributes and children.\n        [<JavaScript; Inline>]\n        let optgroup ats ch = Doc.Element \"optgroup\" ats ch\n        /// Create an HTML element <option> with attributes and children.\n        [<JavaScript; Inline>]\n        let option ats ch = Doc.Element \"option\" ats ch\n        /// Create an HTML element <output> with attributes and children.\n        [<JavaScript; Inline>]\n        let output ats ch = Doc.Element \"output\" ats ch\n        /// Create an HTML element <p> with attributes and children.\n        [<JavaScript; Inline>]\n        let p ats ch = Doc.Element \"p\" ats ch\n        /// Create an HTML element <param> with attributes and children.\n        [<JavaScript; Inline>]\n        let param ats ch = Doc.Element \"param\" ats ch\n        /// Create an HTML element <picture> with attributes and children.\n        [<JavaScript; Inline>]\n        let picture ats ch = Doc.Element \"picture\" ats ch\n        /// Create an HTML element <pre> with attributes and children.\n        [<JavaScript; Inline>]\n        let pre ats ch = Doc.Element \"pre\" ats ch\n        /// Create an HTML element <progress> with attributes and children.\n        [<JavaScript; Inline>]\n        let progress ats ch = Doc.Element \"progress\" ats ch\n        /// Create an HTML element <q> with attributes and children.\n        [<JavaScript; Inline>]\n        let q ats ch = Doc.Element \"q\" ats ch\n        /// Create an HTML element <rp> with attributes and children.\n        [<JavaScript; Inline>]\n        let rp ats ch = Doc.Element \"rp\" ats ch\n        /// Create an HTML element <rt> with attributes and children.\n        [<JavaScript; Inline>]\n        let rt ats ch = Doc.Element \"rt\" ats ch\n        /// Create an HTML element <rtc> with attributes and children.\n        [<JavaScript; Inline>]\n        let rtc ats ch = Doc.Element \"rtc\" ats ch\n        /// Create an HTML element <ruby> with attributes and children.\n        [<JavaScript; Inline>]\n        let ruby ats ch = Doc.Element \"ruby\" ats ch\n        /// Create an HTML element <s> with attributes and children.\n        [<JavaScript; Inline>]\n        let s ats ch = Doc.Element \"s\" ats ch\n        /// Create an HTML element <samp> with attributes and children.\n        [<JavaScript; Inline>]\n        let samp ats ch = Doc.Element \"samp\" ats ch\n        /// Create an HTML element <script> with attributes and children.\n        [<JavaScript; Inline>]\n        let script ats ch = Doc.Element \"script\" ats ch\n        /// Create an HTML element <section> with attributes and children.\n        [<JavaScript; Inline>]\n        let section ats ch = Doc.Element \"section\" ats ch\n        /// Create an HTML element <select> with attributes and children.\n        [<JavaScript; Inline>]\n        let select ats ch = Doc.Element \"select\" ats ch\n        /// Create an HTML element <shadow> with attributes and children.\n        [<JavaScript; Inline>]\n        let shadow ats ch = Doc.Element \"shadow\" ats ch\n        /// Create an HTML element <small> with attributes and children.\n        [<JavaScript; Inline>]\n        let small ats ch = Doc.Element \"small\" ats ch\n        /// Create an HTML element <source> with attributes and children.\n        [<JavaScript; Inline>]\n        let source ats ch = Doc.Element \"source\" ats ch\n        /// Create an HTML element <span> with attributes and children.\n        [<JavaScript; Inline>]\n        let span ats ch = Doc.Element \"span\" ats ch\n        /// Create an HTML element <strike> with attributes and children.\n        [<JavaScript; Inline>]\n        let strike ats ch = Doc.Element \"strike\" ats ch\n        /// Create an HTML element <strong> with attributes and children.\n        [<JavaScript; Inline>]\n        let strong ats ch = Doc.Element \"strong\" ats ch\n        /// Create an HTML element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Doc.Element \"style\" ats ch\n        /// Create an HTML element <sub> with attributes and children.\n        [<JavaScript; Inline>]\n        let sub ats ch = Doc.Element \"sub\" ats ch\n        /// Create an HTML element <summary> with attributes and children.\n        [<JavaScript; Inline>]\n        let summary ats ch = Doc.Element \"summary\" ats ch\n        /// Create an HTML element <sup> with attributes and children.\n        [<JavaScript; Inline>]\n        let sup ats ch = Doc.Element \"sup\" ats ch\n        /// Create an HTML element <table> with attributes and children.\n        [<JavaScript; Inline>]\n        let table ats ch = Doc.Element \"table\" ats ch\n        /// Create an HTML element <tbody> with attributes and children.\n        [<JavaScript; Inline>]\n        let tbody ats ch = Doc.Element \"tbody\" ats ch\n        /// Create an HTML element <td> with attributes and children.\n        [<JavaScript; Inline>]\n        let td ats ch = Doc.Element \"td\" ats ch\n        /// Create an HTML element <template> with attributes and children.\n        [<JavaScript; Inline>]\n        let template ats ch = Doc.Element \"template\" ats ch\n        /// Create an HTML element <textarea> with attributes and children.\n        [<JavaScript; Inline>]\n        let textarea ats ch = Doc.Element \"textarea\" ats ch\n        /// Create an HTML element <tfoot> with attributes and children.\n        [<JavaScript; Inline>]\n        let tfoot ats ch = Doc.Element \"tfoot\" ats ch\n        /// Create an HTML element <th> with attributes and children.\n        [<JavaScript; Inline>]\n        let th ats ch = Doc.Element \"th\" ats ch\n        /// Create an HTML element <thead> with attributes and children.\n        [<JavaScript; Inline>]\n        let thead ats ch = Doc.Element \"thead\" ats ch\n        /// Create an HTML element <time> with attributes and children.\n        [<JavaScript; Inline>]\n        let time ats ch = Doc.Element \"time\" ats ch\n        /// Create an HTML element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Doc.Element \"title\" ats ch\n        /// Create an HTML element <tr> with attributes and children.\n        [<JavaScript; Inline>]\n        let tr ats ch = Doc.Element \"tr\" ats ch\n        /// Create an HTML element <track> with attributes and children.\n        [<JavaScript; Inline>]\n        let track ats ch = Doc.Element \"track\" ats ch\n        /// Create an HTML element <tt> with attributes and children.\n        [<JavaScript; Inline>]\n        let tt ats ch = Doc.Element \"tt\" ats ch\n        /// Create an HTML element <u> with attributes and children.\n        [<JavaScript; Inline>]\n        let u ats ch = Doc.Element \"u\" ats ch\n        /// Create an HTML element <ul> with attributes and children.\n        [<JavaScript; Inline>]\n        let ul ats ch = Doc.Element \"ul\" ats ch\n        /// Create an HTML element <var> with attributes and children.\n        [<JavaScript; Inline>]\n        let var ats ch = Doc.Element \"var\" ats ch\n        /// Create an HTML element <video> with attributes and children.\n        [<JavaScript; Inline>]\n        let video ats ch = Doc.Element \"video\" ats ch\n        /// Create an HTML element <wbr> with attributes and children.\n        [<JavaScript; Inline>]\n        let wbr ats ch = Doc.Element \"wbr\" ats ch\n        // }}\n\n    // {{ tag normal [doc]\n    /// Create an HTML element <a> with attributes and children.\n    [<JavaScript; Inline>]\n    let a ats ch = Elt.a ats ch :> Doc\n    /// Create an HTML element <abbr> with attributes and children.\n    [<JavaScript; Inline>]\n    let abbr ats ch = Elt.abbr ats ch :> Doc\n    /// Create an HTML element <address> with attributes and children.\n    [<JavaScript; Inline>]\n    let address ats ch = Elt.address ats ch :> Doc\n    /// Create an HTML element <area> with attributes and children.\n    [<JavaScript; Inline>]\n    let area ats ch = Elt.area ats ch :> Doc\n    /// Create an HTML element <article> with attributes and children.\n    [<JavaScript; Inline>]\n    let article ats ch = Elt.article ats ch :> Doc\n    /// Create an HTML element <aside> with attributes and children.\n    [<JavaScript; Inline>]\n    let aside ats ch = Elt.aside ats ch :> Doc\n    /// Create an HTML element <audio> with attributes and children.\n    [<JavaScript; Inline>]\n    let audio ats ch = Elt.audio ats ch :> Doc\n    /// Create an HTML element <b> with attributes and children.\n    [<JavaScript; Inline>]\n    let b ats ch = Elt.b ats ch :> Doc\n    /// Create an HTML element <base> with attributes and children.\n    [<JavaScript; Inline>]\n    let ``base`` ats ch = Elt.``base`` ats ch :> Doc\n    /// Create an HTML element <bdi> with attributes and children.\n    [<JavaScript; Inline>]\n    let bdi ats ch = Elt.bdi ats ch :> Doc\n    /// Create an HTML element <bdo> with attributes and children.\n    [<JavaScript; Inline>]\n    let bdo ats ch = Elt.bdo ats ch :> Doc\n    /// Create an HTML element <blockquote> with attributes and children.\n    [<JavaScript; Inline>]\n    let blockquote ats ch = Elt.blockquote ats ch :> Doc\n    /// Create an HTML element <body> with attributes and children.\n    [<JavaScript; Inline>]\n    let body ats ch = Elt.body ats ch :> Doc\n    /// Create an HTML element <br> with attributes and children.\n    [<JavaScript; Inline>]\n    let br ats ch = Elt.br ats ch :> Doc\n    /// Create an HTML element <button> with attributes and children.\n    [<JavaScript; Inline>]\n    let button ats ch = Elt.button ats ch :> Doc\n    /// Create an HTML element <canvas> with attributes and children.\n    [<JavaScript; Inline>]\n    let canvas ats ch = Elt.canvas ats ch :> Doc\n    /// Create an HTML element <caption> with attributes and children.\n    [<JavaScript; Inline>]\n    let caption ats ch = Elt.caption ats ch :> Doc\n    /// Create an HTML element <cite> with attributes and children.\n    [<JavaScript; Inline>]\n    let cite ats ch = Elt.cite ats ch :> Doc\n    /// Create an HTML element <code> with attributes and children.\n    [<JavaScript; Inline>]\n    let code ats ch = Elt.code ats ch :> Doc\n    /// Create an HTML element <col> with attributes and children.\n    [<JavaScript; Inline>]\n    let col ats ch = Elt.col ats ch :> Doc\n    /// Create an HTML element <colgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let colgroup ats ch = Elt.colgroup ats ch :> Doc\n    /// Create an HTML element <command> with attributes and children.\n    [<JavaScript; Inline>]\n    let command ats ch = Elt.command ats ch :> Doc\n    /// Create an HTML element <datalist> with attributes and children.\n    [<JavaScript; Inline>]\n    let datalist ats ch = Elt.datalist ats ch :> Doc\n    /// Create an HTML element <dd> with attributes and children.\n    [<JavaScript; Inline>]\n    let dd ats ch = Elt.dd ats ch :> Doc\n    /// Create an HTML element <del> with attributes and children.\n    [<JavaScript; Inline>]\n    let del ats ch = Elt.del ats ch :> Doc\n    /// Create an HTML element <details> with attributes and children.\n    [<JavaScript; Inline>]\n    let details ats ch = Elt.details ats ch :> Doc\n    /// Create an HTML element <dfn> with attributes and children.\n    [<JavaScript; Inline>]\n    let dfn ats ch = Elt.dfn ats ch :> Doc\n    /// Create an HTML element <div> with attributes and children.\n    [<JavaScript; Inline>]\n    let div ats ch = Elt.div ats ch :> Doc\n    /// Create an HTML element <dl> with attributes and children.\n    [<JavaScript; Inline>]\n    let dl ats ch = Elt.dl ats ch :> Doc\n    /// Create an HTML element <dt> with attributes and children.\n    [<JavaScript; Inline>]\n    let dt ats ch = Elt.dt ats ch :> Doc\n    /// Create an HTML element <em> with attributes and children.\n    [<JavaScript; Inline>]\n    let em ats ch = Elt.em ats ch :> Doc\n    /// Create an HTML element <embed> with attributes and children.\n    [<JavaScript; Inline>]\n    let embed ats ch = Elt.embed ats ch :> Doc\n    /// Create an HTML element <fieldset> with attributes and children.\n    [<JavaScript; Inline>]\n    let fieldset ats ch = Elt.fieldset ats ch :> Doc\n    /// Create an HTML element <figcaption> with attributes and children.\n    [<JavaScript; Inline>]\n    let figcaption ats ch = Elt.figcaption ats ch :> Doc\n    /// Create an HTML element <figure> with attributes and children.\n    [<JavaScript; Inline>]\n    let figure ats ch = Elt.figure ats ch :> Doc\n    /// Create an HTML element <footer> with attributes and children.\n    [<JavaScript; Inline>]\n    let footer ats ch = Elt.footer ats ch :> Doc\n    /// Create an HTML element <form> with attributes and children.\n    [<JavaScript; Inline>]\n    let form ats ch = Elt.form ats ch :> Doc\n    /// Create an HTML element <h1> with attributes and children.\n    [<JavaScript; Inline>]\n    let h1 ats ch = Elt.h1 ats ch :> Doc\n    /// Create an HTML element <h2> with attributes and children.\n    [<JavaScript; Inline>]\n    let h2 ats ch = Elt.h2 ats ch :> Doc\n    /// Create an HTML element <h3> with attributes and children.\n    [<JavaScript; Inline>]\n    let h3 ats ch = Elt.h3 ats ch :> Doc\n    /// Create an HTML element <h4> with attributes and children.\n    [<JavaScript; Inline>]\n    let h4 ats ch = Elt.h4 ats ch :> Doc\n    /// Create an HTML element <h5> with attributes and children.\n    [<JavaScript; Inline>]\n    let h5 ats ch = Elt.h5 ats ch :> Doc\n    /// Create an HTML element <h6> with attributes and children.\n    [<JavaScript; Inline>]\n    let h6 ats ch = Elt.h6 ats ch :> Doc\n    /// Create an HTML element <head> with attributes and children.\n    [<JavaScript; Inline>]\n    let head ats ch = Elt.head ats ch :> Doc\n    /// Create an HTML element <header> with attributes and children.\n    [<JavaScript; Inline>]\n    let header ats ch = Elt.header ats ch :> Doc\n    /// Create an HTML element <hgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let hgroup ats ch = Elt.hgroup ats ch :> Doc\n    /// Create an HTML element <hr> with attributes and children.\n    [<JavaScript; Inline>]\n    let hr ats ch = Elt.hr ats ch :> Doc\n    /// Create an HTML element <html> with attributes and children.\n    [<JavaScript; Inline>]\n    let html ats ch = Elt.html ats ch :> Doc\n    /// Create an HTML element <i> with attributes and children.\n    [<JavaScript; Inline>]\n    let i ats ch = Elt.i ats ch :> Doc\n    /// Create an HTML element <iframe> with attributes and children.\n    [<JavaScript; Inline>]\n    let iframe ats ch = Elt.iframe ats ch :> Doc\n    /// Create an HTML element <img> with attributes and children.\n    [<JavaScript; Inline>]\n    let img ats ch = Elt.img ats ch :> Doc\n    /// Create an HTML element <input> with attributes and children.\n    [<JavaScript; Inline>]\n    let input ats ch = Elt.input ats ch :> Doc\n    /// Create an HTML element <ins> with attributes and children.\n    [<JavaScript; Inline>]\n    let ins ats ch = Elt.ins ats ch :> Doc\n    /// Create an HTML element <kbd> with attributes and children.\n    [<JavaScript; Inline>]\n    let kbd ats ch = Elt.kbd ats ch :> Doc\n    /// Create an HTML element <keygen> with attributes and children.\n    [<JavaScript; Inline>]\n    let keygen ats ch = Elt.keygen ats ch :> Doc\n    /// Create an HTML element <label> with attributes and children.\n    [<JavaScript; Inline>]\n    let label ats ch = Elt.label ats ch :> Doc\n    /// Create an HTML element <legend> with attributes and children.\n    [<JavaScript; Inline>]\n    let legend ats ch = Elt.legend ats ch :> Doc\n    /// Create an HTML element <li> with attributes and children.\n    [<JavaScript; Inline>]\n    let li ats ch = Elt.li ats ch :> Doc\n    /// Create an HTML element <link> with attributes and children.\n    [<JavaScript; Inline>]\n    let link ats ch = Elt.link ats ch :> Doc\n    /// Create an HTML element <mark> with attributes and children.\n    [<JavaScript; Inline>]\n    let mark ats ch = Elt.mark ats ch :> Doc\n    /// Create an HTML element <meta> with attributes and children.\n    [<JavaScript; Inline>]\n    let meta ats ch = Elt.meta ats ch :> Doc\n    /// Create an HTML element <meter> with attributes and children.\n    [<JavaScript; Inline>]\n    let meter ats ch = Elt.meter ats ch :> Doc\n    /// Create an HTML element <nav> with attributes and children.\n    [<JavaScript; Inline>]\n    let nav ats ch = Elt.nav ats ch :> Doc\n    /// Create an HTML element <noframes> with attributes and children.\n    [<JavaScript; Inline>]\n    let noframes ats ch = Elt.noframes ats ch :> Doc\n    /// Create an HTML element <noscript> with attributes and children.\n    [<JavaScript; Inline>]\n    let noscript ats ch = Elt.noscript ats ch :> Doc\n    /// Create an HTML element <ol> with attributes and children.\n    [<JavaScript; Inline>]\n    let ol ats ch = Elt.ol ats ch :> Doc\n    /// Create an HTML element <optgroup> with attributes and children.\n    [<JavaScript; Inline>]\n    let optgroup ats ch = Elt.optgroup ats ch :> Doc\n    /// Create an HTML element <output> with attributes and children.\n    [<JavaScript; Inline>]\n    let output ats ch = Elt.output ats ch :> Doc\n    /// Create an HTML element <p> with attributes and children.\n    [<JavaScript; Inline>]\n    let p ats ch = Elt.p ats ch :> Doc\n    /// Create an HTML element <param> with attributes and children.\n    [<JavaScript; Inline>]\n    let param ats ch = Elt.param ats ch :> Doc\n    /// Create an HTML element <picture> with attributes and children.\n    [<JavaScript; Inline>]\n    let picture ats ch = Elt.picture ats ch :> Doc\n    /// Create an HTML element <pre> with attributes and children.\n    [<JavaScript; Inline>]\n    let pre ats ch = Elt.pre ats ch :> Doc\n    /// Create an HTML element <progress> with attributes and children.\n    [<JavaScript; Inline>]\n    let progress ats ch = Elt.progress ats ch :> Doc\n    /// Create an HTML element <q> with attributes and children.\n    [<JavaScript; Inline>]\n    let q ats ch = Elt.q ats ch :> Doc\n    /// Create an HTML element <rp> with attributes and children.\n    [<JavaScript; Inline>]\n    let rp ats ch = Elt.rp ats ch :> Doc\n    /// Create an HTML element <rt> with attributes and children.\n    [<JavaScript; Inline>]\n    let rt ats ch = Elt.rt ats ch :> Doc\n    /// Create an HTML element <rtc> with attributes and children.\n    [<JavaScript; Inline>]\n    let rtc ats ch = Elt.rtc ats ch :> Doc\n    /// Create an HTML element <ruby> with attributes and children.\n    [<JavaScript; Inline>]\n    let ruby ats ch = Elt.ruby ats ch :> Doc\n    /// Create an HTML element <samp> with attributes and children.\n    [<JavaScript; Inline>]\n    let samp ats ch = Elt.samp ats ch :> Doc\n    /// Create an HTML element <script> with attributes and children.\n    [<JavaScript; Inline>]\n    let script ats ch = Elt.script ats ch :> Doc\n    /// Create an HTML element <section> with attributes and children.\n    [<JavaScript; Inline>]\n    let section ats ch = Elt.section ats ch :> Doc\n    /// Create an HTML element <select> with attributes and children.\n    [<JavaScript; Inline>]\n    let select ats ch = Elt.select ats ch :> Doc\n    /// Create an HTML element <shadow> with attributes and children.\n    [<JavaScript; Inline>]\n    let shadow ats ch = Elt.shadow ats ch :> Doc\n    /// Create an HTML element <small> with attributes and children.\n    [<JavaScript; Inline>]\n    let small ats ch = Elt.small ats ch :> Doc\n    /// Create an HTML element <source> with attributes and children.\n    [<JavaScript; Inline>]\n    let source ats ch = Elt.source ats ch :> Doc\n    /// Create an HTML element <span> with attributes and children.\n    [<JavaScript; Inline>]\n    let span ats ch = Elt.span ats ch :> Doc\n    /// Create an HTML element <strong> with attributes and children.\n    [<JavaScript; Inline>]\n    let strong ats ch = Elt.strong ats ch :> Doc\n    /// Create an HTML element <sub> with attributes and children.\n    [<JavaScript; Inline>]\n    let sub ats ch = Elt.sub ats ch :> Doc\n    /// Create an HTML element <summary> with attributes and children.\n    [<JavaScript; Inline>]\n    let summary ats ch = Elt.summary ats ch :> Doc\n    /// Create an HTML element <sup> with attributes and children.\n    [<JavaScript; Inline>]\n    let sup ats ch = Elt.sup ats ch :> Doc\n    /// Create an HTML element <table> with attributes and children.\n    [<JavaScript; Inline>]\n    let table ats ch = Elt.table ats ch :> Doc\n    /// Create an HTML element <tbody> with attributes and children.\n    [<JavaScript; Inline>]\n    let tbody ats ch = Elt.tbody ats ch :> Doc\n    /// Create an HTML element <td> with attributes and children.\n    [<JavaScript; Inline>]\n    let td ats ch = Elt.td ats ch :> Doc\n    /// Create an HTML element <textarea> with attributes and children.\n    [<JavaScript; Inline>]\n    let textarea ats ch = Elt.textarea ats ch :> Doc\n    /// Create an HTML element <tfoot> with attributes and children.\n    [<JavaScript; Inline>]\n    let tfoot ats ch = Elt.tfoot ats ch :> Doc\n    /// Create an HTML element <th> with attributes and children.\n    [<JavaScript; Inline>]\n    let th ats ch = Elt.th ats ch :> Doc\n    /// Create an HTML element <thead> with attributes and children.\n    [<JavaScript; Inline>]\n    let thead ats ch = Elt.thead ats ch :> Doc\n    /// Create an HTML element <time> with attributes and children.\n    [<JavaScript; Inline>]\n    let time ats ch = Elt.time ats ch :> Doc\n    /// Create an HTML element <tr> with attributes and children.\n    [<JavaScript; Inline>]\n    let tr ats ch = Elt.tr ats ch :> Doc\n    /// Create an HTML element <track> with attributes and children.\n    [<JavaScript; Inline>]\n    let track ats ch = Elt.track ats ch :> Doc\n    /// Create an HTML element <ul> with attributes and children.\n    [<JavaScript; Inline>]\n    let ul ats ch = Elt.ul ats ch :> Doc\n    /// Create an HTML element <video> with attributes and children.\n    [<JavaScript; Inline>]\n    let video ats ch = Elt.video ats ch :> Doc\n    /// Create an HTML element <wbr> with attributes and children.\n    [<JavaScript; Inline>]\n    let wbr ats ch = Elt.wbr ats ch :> Doc\n    // }}\n\n    /// HTML5 element functions.\n    module Tags =\n\n        // {{ tag colliding deprecated [doc]\n        /// Create an HTML element <acronym> with attributes and children.\n        [<JavaScript; Inline>]\n        let acronym ats ch = Elt.acronym ats ch :> Doc\n        /// Create an HTML element <applet> with attributes and children.\n        [<JavaScript; Inline>]\n        let applet ats ch = Elt.applet ats ch :> Doc\n        /// Create an HTML element <basefont> with attributes and children.\n        [<JavaScript; Inline>]\n        let basefont ats ch = Elt.basefont ats ch :> Doc\n        /// Create an HTML element <big> with attributes and children.\n        [<JavaScript; Inline>]\n        let big ats ch = Elt.big ats ch :> Doc\n        /// Create an HTML element <center> with attributes and children.\n        [<JavaScript; Inline>]\n        let center ats ch = Elt.center ats ch :> Doc\n        /// Create an HTML element <content> with attributes and children.\n        [<JavaScript; Inline>]\n        let content ats ch = Elt.content ats ch :> Doc\n        /// Create an HTML element <data> with attributes and children.\n        [<JavaScript; Inline>]\n        let data ats ch = Elt.data ats ch :> Doc\n        /// Create an HTML element <dir> with attributes and children.\n        [<JavaScript; Inline>]\n        let dir ats ch = Elt.dir ats ch :> Doc\n        /// Create an HTML element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Elt.font ats ch :> Doc\n        /// Create an HTML element <frame> with attributes and children.\n        [<JavaScript; Inline>]\n        let frame ats ch = Elt.frame ats ch :> Doc\n        /// Create an HTML element <frameset> with attributes and children.\n        [<JavaScript; Inline>]\n        let frameset ats ch = Elt.frameset ats ch :> Doc\n        /// Create an HTML element <isindex> with attributes and children.\n        [<JavaScript; Inline>]\n        let isindex ats ch = Elt.isindex ats ch :> Doc\n        /// Create an HTML element <main> with attributes and children.\n        [<JavaScript; Inline>]\n        let main ats ch = Elt.main ats ch :> Doc\n        /// Create an HTML element <map> with attributes and children.\n        [<JavaScript; Inline>]\n        let map ats ch = Elt.map ats ch :> Doc\n        /// Create an HTML element <menu> with attributes and children.\n        [<JavaScript; Inline>]\n        let menu ats ch = Elt.menu ats ch :> Doc\n        /// Create an HTML element <menuitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let menuitem ats ch = Elt.menuitem ats ch :> Doc\n        /// Create an HTML element <object> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``object`` ats ch = Elt.``object`` ats ch :> Doc\n        /// Create an HTML element <option> with attributes and children.\n        [<JavaScript; Inline>]\n        let option ats ch = Elt.option ats ch :> Doc\n        /// Create an HTML element <s> with attributes and children.\n        [<JavaScript; Inline>]\n        let s ats ch = Elt.s ats ch :> Doc\n        /// Create an HTML element <strike> with attributes and children.\n        [<JavaScript; Inline>]\n        let strike ats ch = Elt.strike ats ch :> Doc\n        /// Create an HTML element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Elt.style ats ch :> Doc\n        /// Create an HTML element <template> with attributes and children.\n        [<JavaScript; Inline>]\n        let template ats ch = Elt.template ats ch :> Doc\n        /// Create an HTML element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Elt.title ats ch :> Doc\n        /// Create an HTML element <tt> with attributes and children.\n        [<JavaScript; Inline>]\n        let tt ats ch = Elt.tt ats ch :> Doc\n        /// Create an HTML element <u> with attributes and children.\n        [<JavaScript; Inline>]\n        let u ats ch = Elt.u ats ch :> Doc\n        /// Create an HTML element <var> with attributes and children.\n        [<JavaScript; Inline>]\n        let var ats ch = Elt.var ats ch :> Doc\n        // }}\n\n    /// SVG elements.\n    module SvgElements =\n\n        module Elt =\n\n            // {{ svgtag normal [elt]\n            /// Create an SVG element <a> with attributes and children.\n            [<JavaScript; Inline>]\n            let a ats ch = Doc.SvgElement \"a\" ats ch\n            /// Create an SVG element <altglyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyph ats ch = Doc.SvgElement \"altglyph\" ats ch\n            /// Create an SVG element <altglyphdef> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyphdef ats ch = Doc.SvgElement \"altglyphdef\" ats ch\n            /// Create an SVG element <altglyphitem> with attributes and children.\n            [<JavaScript; Inline>]\n            let altglyphitem ats ch = Doc.SvgElement \"altglyphitem\" ats ch\n            /// Create an SVG element <animate> with attributes and children.\n            [<JavaScript; Inline>]\n            let animate ats ch = Doc.SvgElement \"animate\" ats ch\n            /// Create an SVG element <animatecolor> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatecolor ats ch = Doc.SvgElement \"animatecolor\" ats ch\n            /// Create an SVG element <animatemotion> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatemotion ats ch = Doc.SvgElement \"animatemotion\" ats ch\n            /// Create an SVG element <animatetransform> with attributes and children.\n            [<JavaScript; Inline>]\n            let animatetransform ats ch = Doc.SvgElement \"animatetransform\" ats ch\n            /// Create an SVG element <circle> with attributes and children.\n            [<JavaScript; Inline>]\n            let circle ats ch = Doc.SvgElement \"circle\" ats ch\n            /// Create an SVG element <clippath> with attributes and children.\n            [<JavaScript; Inline>]\n            let clippath ats ch = Doc.SvgElement \"clippath\" ats ch\n            /// Create an SVG element <color-profile> with attributes and children.\n            [<JavaScript; Inline>]\n            let colorProfile ats ch = Doc.SvgElement \"color-profile\" ats ch\n            /// Create an SVG element <cursor> with attributes and children.\n            [<JavaScript; Inline>]\n            let cursor ats ch = Doc.SvgElement \"cursor\" ats ch\n            /// Create an SVG element <defs> with attributes and children.\n            [<JavaScript; Inline>]\n            let defs ats ch = Doc.SvgElement \"defs\" ats ch\n            /// Create an SVG element <desc> with attributes and children.\n            [<JavaScript; Inline>]\n            let desc ats ch = Doc.SvgElement \"desc\" ats ch\n            /// Create an SVG element <ellipse> with attributes and children.\n            [<JavaScript; Inline>]\n            let ellipse ats ch = Doc.SvgElement \"ellipse\" ats ch\n            /// Create an SVG element <feblend> with attributes and children.\n            [<JavaScript; Inline>]\n            let feblend ats ch = Doc.SvgElement \"feblend\" ats ch\n            /// Create an SVG element <fecolormatrix> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecolormatrix ats ch = Doc.SvgElement \"fecolormatrix\" ats ch\n            /// Create an SVG element <fecomponenttransfer> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecomponenttransfer ats ch = Doc.SvgElement \"fecomponenttransfer\" ats ch\n            /// Create an SVG element <fecomposite> with attributes and children.\n            [<JavaScript; Inline>]\n            let fecomposite ats ch = Doc.SvgElement \"fecomposite\" ats ch\n            /// Create an SVG element <feconvolvematrix> with attributes and children.\n            [<JavaScript; Inline>]\n            let feconvolvematrix ats ch = Doc.SvgElement \"feconvolvematrix\" ats ch\n            /// Create an SVG element <fediffuselighting> with attributes and children.\n            [<JavaScript; Inline>]\n            let fediffuselighting ats ch = Doc.SvgElement \"fediffuselighting\" ats ch\n            /// Create an SVG element <fedisplacementmap> with attributes and children.\n            [<JavaScript; Inline>]\n            let fedisplacementmap ats ch = Doc.SvgElement \"fedisplacementmap\" ats ch\n            /// Create an SVG element <fedistantlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fedistantlight ats ch = Doc.SvgElement \"fedistantlight\" ats ch\n            /// Create an SVG element <feflood> with attributes and children.\n            [<JavaScript; Inline>]\n            let feflood ats ch = Doc.SvgElement \"feflood\" ats ch\n            /// Create an SVG element <fefunca> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefunca ats ch = Doc.SvgElement \"fefunca\" ats ch\n            /// Create an SVG element <fefuncb> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncb ats ch = Doc.SvgElement \"fefuncb\" ats ch\n            /// Create an SVG element <fefuncg> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncg ats ch = Doc.SvgElement \"fefuncg\" ats ch\n            /// Create an SVG element <fefuncr> with attributes and children.\n            [<JavaScript; Inline>]\n            let fefuncr ats ch = Doc.SvgElement \"fefuncr\" ats ch\n            /// Create an SVG element <fegaussianblur> with attributes and children.\n            [<JavaScript; Inline>]\n            let fegaussianblur ats ch = Doc.SvgElement \"fegaussianblur\" ats ch\n            /// Create an SVG element <feimage> with attributes and children.\n            [<JavaScript; Inline>]\n            let feimage ats ch = Doc.SvgElement \"feimage\" ats ch\n            /// Create an SVG element <femerge> with attributes and children.\n            [<JavaScript; Inline>]\n            let femerge ats ch = Doc.SvgElement \"femerge\" ats ch\n            /// Create an SVG element <femergenode> with attributes and children.\n            [<JavaScript; Inline>]\n            let femergenode ats ch = Doc.SvgElement \"femergenode\" ats ch\n            /// Create an SVG element <femorphology> with attributes and children.\n            [<JavaScript; Inline>]\n            let femorphology ats ch = Doc.SvgElement \"femorphology\" ats ch\n            /// Create an SVG element <feoffset> with attributes and children.\n            [<JavaScript; Inline>]\n            let feoffset ats ch = Doc.SvgElement \"feoffset\" ats ch\n            /// Create an SVG element <fepointlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fepointlight ats ch = Doc.SvgElement \"fepointlight\" ats ch\n            /// Create an SVG element <fespecularlighting> with attributes and children.\n            [<JavaScript; Inline>]\n            let fespecularlighting ats ch = Doc.SvgElement \"fespecularlighting\" ats ch\n            /// Create an SVG element <fespotlight> with attributes and children.\n            [<JavaScript; Inline>]\n            let fespotlight ats ch = Doc.SvgElement \"fespotlight\" ats ch\n            /// Create an SVG element <fetile> with attributes and children.\n            [<JavaScript; Inline>]\n            let fetile ats ch = Doc.SvgElement \"fetile\" ats ch\n            /// Create an SVG element <feturbulence> with attributes and children.\n            [<JavaScript; Inline>]\n            let feturbulence ats ch = Doc.SvgElement \"feturbulence\" ats ch\n            /// Create an SVG element <filter> with attributes and children.\n            [<JavaScript; Inline>]\n            let filter ats ch = Doc.SvgElement \"filter\" ats ch\n            /// Create an SVG element <font> with attributes and children.\n            [<JavaScript; Inline>]\n            let font ats ch = Doc.SvgElement \"font\" ats ch\n            /// Create an SVG element <font-face> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFace ats ch = Doc.SvgElement \"font-face\" ats ch\n            /// Create an SVG element <font-face-format> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceFormat ats ch = Doc.SvgElement \"font-face-format\" ats ch\n            /// Create an SVG element <font-face-name> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceName ats ch = Doc.SvgElement \"font-face-name\" ats ch\n            /// Create an SVG element <font-face-src> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceSrc ats ch = Doc.SvgElement \"font-face-src\" ats ch\n            /// Create an SVG element <font-face-uri> with attributes and children.\n            [<JavaScript; Inline>]\n            let fontFaceUri ats ch = Doc.SvgElement \"font-face-uri\" ats ch\n            /// Create an SVG element <foreignobject> with attributes and children.\n            [<JavaScript; Inline>]\n            let foreignobject ats ch = Doc.SvgElement \"foreignobject\" ats ch\n            /// Create an SVG element <g> with attributes and children.\n            [<JavaScript; Inline>]\n            let g ats ch = Doc.SvgElement \"g\" ats ch\n            /// Create an SVG element <glyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let glyph ats ch = Doc.SvgElement \"glyph\" ats ch\n            /// Create an SVG element <glyphref> with attributes and children.\n            [<JavaScript; Inline>]\n            let glyphref ats ch = Doc.SvgElement \"glyphref\" ats ch\n            /// Create an SVG element <hkern> with attributes and children.\n            [<JavaScript; Inline>]\n            let hkern ats ch = Doc.SvgElement \"hkern\" ats ch\n            /// Create an SVG element <image> with attributes and children.\n            [<JavaScript; Inline>]\n            let image ats ch = Doc.SvgElement \"image\" ats ch\n            /// Create an SVG element <line> with attributes and children.\n            [<JavaScript; Inline>]\n            let line ats ch = Doc.SvgElement \"line\" ats ch\n            /// Create an SVG element <lineargradient> with attributes and children.\n            [<JavaScript; Inline>]\n            let lineargradient ats ch = Doc.SvgElement \"lineargradient\" ats ch\n            /// Create an SVG element <marker> with attributes and children.\n            [<JavaScript; Inline>]\n            let marker ats ch = Doc.SvgElement \"marker\" ats ch\n            /// Create an SVG element <mask> with attributes and children.\n            [<JavaScript; Inline>]\n            let mask ats ch = Doc.SvgElement \"mask\" ats ch\n            /// Create an SVG element <metadata> with attributes and children.\n            [<JavaScript; Inline>]\n            let metadata ats ch = Doc.SvgElement \"metadata\" ats ch\n            /// Create an SVG element <missing-glyph> with attributes and children.\n            [<JavaScript; Inline>]\n            let missingGlyph ats ch = Doc.SvgElement \"missing-glyph\" ats ch\n            /// Create an SVG element <mpath> with attributes and children.\n            [<JavaScript; Inline>]\n            let mpath ats ch = Doc.SvgElement \"mpath\" ats ch\n            /// Create an SVG element <path> with attributes and children.\n            [<JavaScript; Inline>]\n            let path ats ch = Doc.SvgElement \"path\" ats ch\n            /// Create an SVG element <pattern> with attributes and children.\n            [<JavaScript; Inline>]\n            let pattern ats ch = Doc.SvgElement \"pattern\" ats ch\n            /// Create an SVG element <polygon> with attributes and children.\n            [<JavaScript; Inline>]\n            let polygon ats ch = Doc.SvgElement \"polygon\" ats ch\n            /// Create an SVG element <polyline> with attributes and children.\n            [<JavaScript; Inline>]\n            let polyline ats ch = Doc.SvgElement \"polyline\" ats ch\n            /// Create an SVG element <radialgradient> with attributes and children.\n            [<JavaScript; Inline>]\n            let radialgradient ats ch = Doc.SvgElement \"radialgradient\" ats ch\n            /// Create an SVG element <rect> with attributes and children.\n            [<JavaScript; Inline>]\n            let rect ats ch = Doc.SvgElement \"rect\" ats ch\n            /// Create an SVG element <script> with attributes and children.\n            [<JavaScript; Inline>]\n            let script ats ch = Doc.SvgElement \"script\" ats ch\n            /// Create an SVG element <set> with attributes and children.\n            [<JavaScript; Inline>]\n            let set ats ch = Doc.SvgElement \"set\" ats ch\n            /// Create an SVG element <stop> with attributes and children.\n            [<JavaScript; Inline>]\n            let stop ats ch = Doc.SvgElement \"stop\" ats ch\n            /// Create an SVG element <style> with attributes and children.\n            [<JavaScript; Inline>]\n            let style ats ch = Doc.SvgElement \"style\" ats ch\n            /// Create an SVG element <svg> with attributes and children.\n            [<JavaScript; Inline>]\n            let svg ats ch = Doc.SvgElement \"svg\" ats ch\n            /// Create an SVG element <switch> with attributes and children.\n            [<JavaScript; Inline>]\n            let switch ats ch = Doc.SvgElement \"switch\" ats ch\n            /// Create an SVG element <symbol> with attributes and children.\n            [<JavaScript; Inline>]\n            let symbol ats ch = Doc.SvgElement \"symbol\" ats ch\n            /// Create an SVG element <text> with attributes and children.\n            [<JavaScript; Inline>]\n            let text ats ch = Doc.SvgElement \"text\" ats ch\n            /// Create an SVG element <textpath> with attributes and children.\n            [<JavaScript; Inline>]\n            let textpath ats ch = Doc.SvgElement \"textpath\" ats ch\n            /// Create an SVG element <title> with attributes and children.\n            [<JavaScript; Inline>]\n            let title ats ch = Doc.SvgElement \"title\" ats ch\n            /// Create an SVG element <tref> with attributes and children.\n            [<JavaScript; Inline>]\n            let tref ats ch = Doc.SvgElement \"tref\" ats ch\n            /// Create an SVG element <tspan> with attributes and children.\n            [<JavaScript; Inline>]\n            let tspan ats ch = Doc.SvgElement \"tspan\" ats ch\n            /// Create an SVG element <use> with attributes and children.\n            [<JavaScript; Inline>]\n            let ``use`` ats ch = Doc.SvgElement \"use\" ats ch\n            /// Create an SVG element <view> with attributes and children.\n            [<JavaScript; Inline>]\n            let view ats ch = Doc.SvgElement \"view\" ats ch\n            /// Create an SVG element <vkern> with attributes and children.\n            [<JavaScript; Inline>]\n            let vkern ats ch = Doc.SvgElement \"vkern\" ats ch\n            // }}\n\n        // {{ svgtag normal [doc]\n        /// Create an SVG element <a> with attributes and children.\n        [<JavaScript; Inline>]\n        let a ats ch = Elt.a ats ch :> Doc\n        /// Create an SVG element <altglyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyph ats ch = Elt.altglyph ats ch :> Doc\n        /// Create an SVG element <altglyphdef> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyphdef ats ch = Elt.altglyphdef ats ch :> Doc\n        /// Create an SVG element <altglyphitem> with attributes and children.\n        [<JavaScript; Inline>]\n        let altglyphitem ats ch = Elt.altglyphitem ats ch :> Doc\n        /// Create an SVG element <animate> with attributes and children.\n        [<JavaScript; Inline>]\n        let animate ats ch = Elt.animate ats ch :> Doc\n        /// Create an SVG element <animatecolor> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatecolor ats ch = Elt.animatecolor ats ch :> Doc\n        /// Create an SVG element <animatemotion> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatemotion ats ch = Elt.animatemotion ats ch :> Doc\n        /// Create an SVG element <animatetransform> with attributes and children.\n        [<JavaScript; Inline>]\n        let animatetransform ats ch = Elt.animatetransform ats ch :> Doc\n        /// Create an SVG element <circle> with attributes and children.\n        [<JavaScript; Inline>]\n        let circle ats ch = Elt.circle ats ch :> Doc\n        /// Create an SVG element <clippath> with attributes and children.\n        [<JavaScript; Inline>]\n        let clippath ats ch = Elt.clippath ats ch :> Doc\n        /// Create an SVG element <color-profile> with attributes and children.\n        [<JavaScript; Inline>]\n        let colorProfile ats ch = Elt.colorProfile ats ch :> Doc\n        /// Create an SVG element <cursor> with attributes and children.\n        [<JavaScript; Inline>]\n        let cursor ats ch = Elt.cursor ats ch :> Doc\n        /// Create an SVG element <defs> with attributes and children.\n        [<JavaScript; Inline>]\n        let defs ats ch = Elt.defs ats ch :> Doc\n        /// Create an SVG element <desc> with attributes and children.\n        [<JavaScript; Inline>]\n        let desc ats ch = Elt.desc ats ch :> Doc\n        /// Create an SVG element <ellipse> with attributes and children.\n        [<JavaScript; Inline>]\n        let ellipse ats ch = Elt.ellipse ats ch :> Doc\n        /// Create an SVG element <feblend> with attributes and children.\n        [<JavaScript; Inline>]\n        let feblend ats ch = Elt.feblend ats ch :> Doc\n        /// Create an SVG element <fecolormatrix> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecolormatrix ats ch = Elt.fecolormatrix ats ch :> Doc\n        /// Create an SVG element <fecomponenttransfer> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecomponenttransfer ats ch = Elt.fecomponenttransfer ats ch :> Doc\n        /// Create an SVG element <fecomposite> with attributes and children.\n        [<JavaScript; Inline>]\n        let fecomposite ats ch = Elt.fecomposite ats ch :> Doc\n        /// Create an SVG element <feconvolvematrix> with attributes and children.\n        [<JavaScript; Inline>]\n        let feconvolvematrix ats ch = Elt.feconvolvematrix ats ch :> Doc\n        /// Create an SVG element <fediffuselighting> with attributes and children.\n        [<JavaScript; Inline>]\n        let fediffuselighting ats ch = Elt.fediffuselighting ats ch :> Doc\n        /// Create an SVG element <fedisplacementmap> with attributes and children.\n        [<JavaScript; Inline>]\n        let fedisplacementmap ats ch = Elt.fedisplacementmap ats ch :> Doc\n        /// Create an SVG element <fedistantlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fedistantlight ats ch = Elt.fedistantlight ats ch :> Doc\n        /// Create an SVG element <feflood> with attributes and children.\n        [<JavaScript; Inline>]\n        let feflood ats ch = Elt.feflood ats ch :> Doc\n        /// Create an SVG element <fefunca> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefunca ats ch = Elt.fefunca ats ch :> Doc\n        /// Create an SVG element <fefuncb> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncb ats ch = Elt.fefuncb ats ch :> Doc\n        /// Create an SVG element <fefuncg> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncg ats ch = Elt.fefuncg ats ch :> Doc\n        /// Create an SVG element <fefuncr> with attributes and children.\n        [<JavaScript; Inline>]\n        let fefuncr ats ch = Elt.fefuncr ats ch :> Doc\n        /// Create an SVG element <fegaussianblur> with attributes and children.\n        [<JavaScript; Inline>]\n        let fegaussianblur ats ch = Elt.fegaussianblur ats ch :> Doc\n        /// Create an SVG element <feimage> with attributes and children.\n        [<JavaScript; Inline>]\n        let feimage ats ch = Elt.feimage ats ch :> Doc\n        /// Create an SVG element <femerge> with attributes and children.\n        [<JavaScript; Inline>]\n        let femerge ats ch = Elt.femerge ats ch :> Doc\n        /// Create an SVG element <femergenode> with attributes and children.\n        [<JavaScript; Inline>]\n        let femergenode ats ch = Elt.femergenode ats ch :> Doc\n        /// Create an SVG element <femorphology> with attributes and children.\n        [<JavaScript; Inline>]\n        let femorphology ats ch = Elt.femorphology ats ch :> Doc\n        /// Create an SVG element <feoffset> with attributes and children.\n        [<JavaScript; Inline>]\n        let feoffset ats ch = Elt.feoffset ats ch :> Doc\n        /// Create an SVG element <fepointlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fepointlight ats ch = Elt.fepointlight ats ch :> Doc\n        /// Create an SVG element <fespecularlighting> with attributes and children.\n        [<JavaScript; Inline>]\n        let fespecularlighting ats ch = Elt.fespecularlighting ats ch :> Doc\n        /// Create an SVG element <fespotlight> with attributes and children.\n        [<JavaScript; Inline>]\n        let fespotlight ats ch = Elt.fespotlight ats ch :> Doc\n        /// Create an SVG element <fetile> with attributes and children.\n        [<JavaScript; Inline>]\n        let fetile ats ch = Elt.fetile ats ch :> Doc\n        /// Create an SVG element <feturbulence> with attributes and children.\n        [<JavaScript; Inline>]\n        let feturbulence ats ch = Elt.feturbulence ats ch :> Doc\n        /// Create an SVG element <filter> with attributes and children.\n        [<JavaScript; Inline>]\n        let filter ats ch = Elt.filter ats ch :> Doc\n        /// Create an SVG element <font> with attributes and children.\n        [<JavaScript; Inline>]\n        let font ats ch = Elt.font ats ch :> Doc\n        /// Create an SVG element <font-face> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFace ats ch = Elt.fontFace ats ch :> Doc\n        /// Create an SVG element <font-face-format> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceFormat ats ch = Elt.fontFaceFormat ats ch :> Doc\n        /// Create an SVG element <font-face-name> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceName ats ch = Elt.fontFaceName ats ch :> Doc\n        /// Create an SVG element <font-face-src> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceSrc ats ch = Elt.fontFaceSrc ats ch :> Doc\n        /// Create an SVG element <font-face-uri> with attributes and children.\n        [<JavaScript; Inline>]\n        let fontFaceUri ats ch = Elt.fontFaceUri ats ch :> Doc\n        /// Create an SVG element <foreignobject> with attributes and children.\n        [<JavaScript; Inline>]\n        let foreignobject ats ch = Elt.foreignobject ats ch :> Doc\n        /// Create an SVG element <g> with attributes and children.\n        [<JavaScript; Inline>]\n        let g ats ch = Elt.g ats ch :> Doc\n        /// Create an SVG element <glyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let glyph ats ch = Elt.glyph ats ch :> Doc\n        /// Create an SVG element <glyphref> with attributes and children.\n        [<JavaScript; Inline>]\n        let glyphref ats ch = Elt.glyphref ats ch :> Doc\n        /// Create an SVG element <hkern> with attributes and children.\n        [<JavaScript; Inline>]\n        let hkern ats ch = Elt.hkern ats ch :> Doc\n        /// Create an SVG element <image> with attributes and children.\n        [<JavaScript; Inline>]\n        let image ats ch = Elt.image ats ch :> Doc\n        /// Create an SVG element <line> with attributes and children.\n        [<JavaScript; Inline>]\n        let line ats ch = Elt.line ats ch :> Doc\n        /// Create an SVG element <lineargradient> with attributes and children.\n        [<JavaScript; Inline>]\n        let lineargradient ats ch = Elt.lineargradient ats ch :> Doc\n        /// Create an SVG element <marker> with attributes and children.\n        [<JavaScript; Inline>]\n        let marker ats ch = Elt.marker ats ch :> Doc\n        /// Create an SVG element <mask> with attributes and children.\n        [<JavaScript; Inline>]\n        let mask ats ch = Elt.mask ats ch :> Doc\n        /// Create an SVG element <metadata> with attributes and children.\n        [<JavaScript; Inline>]\n        let metadata ats ch = Elt.metadata ats ch :> Doc\n        /// Create an SVG element <missing-glyph> with attributes and children.\n        [<JavaScript; Inline>]\n        let missingGlyph ats ch = Elt.missingGlyph ats ch :> Doc\n        /// Create an SVG element <mpath> with attributes and children.\n        [<JavaScript; Inline>]\n        let mpath ats ch = Elt.mpath ats ch :> Doc\n        /// Create an SVG element <path> with attributes and children.\n        [<JavaScript; Inline>]\n        let path ats ch = Elt.path ats ch :> Doc\n        /// Create an SVG element <pattern> with attributes and children.\n        [<JavaScript; Inline>]\n        let pattern ats ch = Elt.pattern ats ch :> Doc\n        /// Create an SVG element <polygon> with attributes and children.\n        [<JavaScript; Inline>]\n        let polygon ats ch = Elt.polygon ats ch :> Doc\n        /// Create an SVG element <polyline> with attributes and children.\n        [<JavaScript; Inline>]\n        let polyline ats ch = Elt.polyline ats ch :> Doc\n        /// Create an SVG element <radialgradient> with attributes and children.\n        [<JavaScript; Inline>]\n        let radialgradient ats ch = Elt.radialgradient ats ch :> Doc\n        /// Create an SVG element <rect> with attributes and children.\n        [<JavaScript; Inline>]\n        let rect ats ch = Elt.rect ats ch :> Doc\n        /// Create an SVG element <script> with attributes and children.\n        [<JavaScript; Inline>]\n        let script ats ch = Elt.script ats ch :> Doc\n        /// Create an SVG element <set> with attributes and children.\n        [<JavaScript; Inline>]\n        let set ats ch = Elt.set ats ch :> Doc\n        /// Create an SVG element <stop> with attributes and children.\n        [<JavaScript; Inline>]\n        let stop ats ch = Elt.stop ats ch :> Doc\n        /// Create an SVG element <style> with attributes and children.\n        [<JavaScript; Inline>]\n        let style ats ch = Elt.style ats ch :> Doc\n        /// Create an SVG element <svg> with attributes and children.\n        [<JavaScript; Inline>]\n        let svg ats ch = Elt.svg ats ch :> Doc\n        /// Create an SVG element <switch> with attributes and children.\n        [<JavaScript; Inline>]\n        let switch ats ch = Elt.switch ats ch :> Doc\n        /// Create an SVG element <symbol> with attributes and children.\n        [<JavaScript; Inline>]\n        let symbol ats ch = Elt.symbol ats ch :> Doc\n        /// Create an SVG element <text> with attributes and children.\n        [<JavaScript; Inline>]\n        let text ats ch = Elt.text ats ch :> Doc\n        /// Create an SVG element <textpath> with attributes and children.\n        [<JavaScript; Inline>]\n        let textpath ats ch = Elt.textpath ats ch :> Doc\n        /// Create an SVG element <title> with attributes and children.\n        [<JavaScript; Inline>]\n        let title ats ch = Elt.title ats ch :> Doc\n        /// Create an SVG element <tref> with attributes and children.\n        [<JavaScript; Inline>]\n        let tref ats ch = Elt.tref ats ch :> Doc\n        /// Create an SVG element <tspan> with attributes and children.\n        [<JavaScript; Inline>]\n        let tspan ats ch = Elt.tspan ats ch :> Doc\n        /// Create an SVG element <use> with attributes and children.\n        [<JavaScript; Inline>]\n        let ``use`` ats ch = Elt.``use`` ats ch :> Doc\n        /// Create an SVG element <view> with attributes and children.\n        [<JavaScript; Inline>]\n        let view ats ch = Elt.view ats ch :> Doc\n        /// Create an SVG element <vkern> with attributes and children.\n        [<JavaScript; Inline>]\n        let vkern ats ch = Elt.vkern ats ch :> Doc\n        // }}\n\n    [<JavaScript; Sealed>]\n    type attr private () =\n\n        /// Create an HTML attribute \"data-name\" with the given value.\n        [<JavaScript; Inline>]\n        static member ``data-`` name value = Attr.Create (\"data-\" + name) value\n\n        // {{ attr normal colliding deprecated\n        /// Create an HTML attribute \"accept\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accept\")>]\n        static member accept value = Attr.Create \"accept\" value\n        /// Create an HTML attribute \"accept-charset\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accept-charset\")>]\n        static member acceptCharset value = Attr.Create \"accept-charset\" value\n        /// Create an HTML attribute \"accesskey\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accesskey\")>]\n        static member accesskey value = Attr.Create \"accesskey\" value\n        /// Create an HTML attribute \"action\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"action\")>]\n        static member action value = Attr.Create \"action\" value\n        /// Create an HTML attribute \"align\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"align\")>]\n        static member align value = Attr.Create \"align\" value\n        /// Create an HTML attribute \"alink\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alink\")>]\n        static member alink value = Attr.Create \"alink\" value\n        /// Create an HTML attribute \"alt\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alt\")>]\n        static member alt value = Attr.Create \"alt\" value\n        /// Create an HTML attribute \"altcode\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"altcode\")>]\n        static member altcode value = Attr.Create \"altcode\" value\n        /// Create an HTML attribute \"archive\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"archive\")>]\n        static member archive value = Attr.Create \"archive\" value\n        /// Create an HTML attribute \"async\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"async\")>]\n        static member async value = Attr.Create \"async\" value\n        /// Create an HTML attribute \"autocomplete\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autocomplete\")>]\n        static member autocomplete value = Attr.Create \"autocomplete\" value\n        /// Create an HTML attribute \"autofocus\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autofocus\")>]\n        static member autofocus value = Attr.Create \"autofocus\" value\n        /// Create an HTML attribute \"autoplay\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autoplay\")>]\n        static member autoplay value = Attr.Create \"autoplay\" value\n        /// Create an HTML attribute \"autosave\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"autosave\")>]\n        static member autosave value = Attr.Create \"autosave\" value\n        /// Create an HTML attribute \"axis\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"axis\")>]\n        static member axis value = Attr.Create \"axis\" value\n        /// Create an HTML attribute \"background\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"background\")>]\n        static member background value = Attr.Create \"background\" value\n        /// Create an HTML attribute \"bgcolor\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bgcolor\")>]\n        static member bgcolor value = Attr.Create \"bgcolor\" value\n        /// Create an HTML attribute \"border\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"border\")>]\n        static member border value = Attr.Create \"border\" value\n        /// Create an HTML attribute \"bordercolor\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bordercolor\")>]\n        static member bordercolor value = Attr.Create \"bordercolor\" value\n        /// Create an HTML attribute \"buffered\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"buffered\")>]\n        static member buffered value = Attr.Create \"buffered\" value\n        /// Create an HTML attribute \"cellpadding\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cellpadding\")>]\n        static member cellpadding value = Attr.Create \"cellpadding\" value\n        /// Create an HTML attribute \"cellspacing\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cellspacing\")>]\n        static member cellspacing value = Attr.Create \"cellspacing\" value\n        /// Create an HTML attribute \"challenge\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"challenge\")>]\n        static member challenge value = Attr.Create \"challenge\" value\n        /// Create an HTML attribute \"char\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"char\")>]\n        static member char value = Attr.Create \"char\" value\n        /// Create an HTML attribute \"charoff\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"charoff\")>]\n        static member charoff value = Attr.Create \"charoff\" value\n        /// Create an HTML attribute \"charset\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"charset\")>]\n        static member charset value = Attr.Create \"charset\" value\n        /// Create an HTML attribute \"checked\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"checked\")>]\n        static member ``checked`` value = Attr.Create \"checked\" value\n        /// Create an HTML attribute \"cite\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cite\")>]\n        static member cite value = Attr.Create \"cite\" value\n        /// Create an HTML attribute \"class\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"class\")>]\n        static member ``class`` value = Attr.Create \"class\" value\n        /// Create an HTML attribute \"classid\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"classid\")>]\n        static member classid value = Attr.Create \"classid\" value\n        /// Create an HTML attribute \"clear\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clear\")>]\n        static member clear value = Attr.Create \"clear\" value\n        /// Create an HTML attribute \"code\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"code\")>]\n        static member code value = Attr.Create \"code\" value\n        /// Create an HTML attribute \"codebase\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"codebase\")>]\n        static member codebase value = Attr.Create \"codebase\" value\n        /// Create an HTML attribute \"codetype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"codetype\")>]\n        static member codetype value = Attr.Create \"codetype\" value\n        /// Create an HTML attribute \"color\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color\")>]\n        static member color value = Attr.Create \"color\" value\n        /// Create an HTML attribute \"cols\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cols\")>]\n        static member cols value = Attr.Create \"cols\" value\n        /// Create an HTML attribute \"colspan\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"colspan\")>]\n        static member colspan value = Attr.Create \"colspan\" value\n        /// Create an HTML attribute \"compact\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"compact\")>]\n        static member compact value = Attr.Create \"compact\" value\n        /// Create an HTML attribute \"content\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"content\")>]\n        static member content value = Attr.Create \"content\" value\n        /// Create an HTML attribute \"contenteditable\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contenteditable\")>]\n        static member contenteditable value = Attr.Create \"contenteditable\" value\n        /// Create an HTML attribute \"contextmenu\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contextmenu\")>]\n        static member contextmenu value = Attr.Create \"contextmenu\" value\n        /// Create an HTML attribute \"controls\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"controls\")>]\n        static member controls value = Attr.Create \"controls\" value\n        /// Create an HTML attribute \"coords\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"coords\")>]\n        static member coords value = Attr.Create \"coords\" value\n        /// Create an HTML attribute \"data\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"data\")>]\n        static member data value = Attr.Create \"data\" value\n        /// Create an HTML attribute \"datetime\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"datetime\")>]\n        static member datetime value = Attr.Create \"datetime\" value\n        /// Create an HTML attribute \"declare\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"declare\")>]\n        static member declare value = Attr.Create \"declare\" value\n        /// Create an HTML attribute \"default\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"default\")>]\n        static member ``default`` value = Attr.Create \"default\" value\n        /// Create an HTML attribute \"defer\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"defer\")>]\n        static member defer value = Attr.Create \"defer\" value\n        /// Create an HTML attribute \"dir\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dir\")>]\n        static member dir value = Attr.Create \"dir\" value\n        /// Create an HTML attribute \"disabled\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"disabled\")>]\n        static member disabled value = Attr.Create \"disabled\" value\n        /// Create an HTML attribute \"download\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"download\")>]\n        static member download value = Attr.Create \"download\" value\n        /// Create an HTML attribute \"draggable\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"draggable\")>]\n        static member draggable value = Attr.Create \"draggable\" value\n        /// Create an HTML attribute \"dropzone\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dropzone\")>]\n        static member dropzone value = Attr.Create \"dropzone\" value\n        /// Create an HTML attribute \"enctype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"enctype\")>]\n        static member enctype value = Attr.Create \"enctype\" value\n        /// Create an HTML attribute \"face\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"face\")>]\n        static member face value = Attr.Create \"face\" value\n        /// Create an HTML attribute \"for\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"for\")>]\n        static member ``for`` value = Attr.Create \"for\" value\n        /// Create an HTML attribute \"form\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"form\")>]\n        static member form value = Attr.Create \"form\" value\n        /// Create an HTML attribute \"formaction\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formaction\")>]\n        static member formaction value = Attr.Create \"formaction\" value\n        /// Create an HTML attribute \"formenctype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formenctype\")>]\n        static member formenctype value = Attr.Create \"formenctype\" value\n        /// Create an HTML attribute \"formmethod\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formmethod\")>]\n        static member formmethod value = Attr.Create \"formmethod\" value\n        /// Create an HTML attribute \"formnovalidate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formnovalidate\")>]\n        static member formnovalidate value = Attr.Create \"formnovalidate\" value\n        /// Create an HTML attribute \"formtarget\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"formtarget\")>]\n        static member formtarget value = Attr.Create \"formtarget\" value\n        /// Create an HTML attribute \"frame\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"frame\")>]\n        static member frame value = Attr.Create \"frame\" value\n        /// Create an HTML attribute \"frameborder\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"frameborder\")>]\n        static member frameborder value = Attr.Create \"frameborder\" value\n        /// Create an HTML attribute \"headers\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"headers\")>]\n        static member headers value = Attr.Create \"headers\" value\n        /// Create an HTML attribute \"height\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"height\")>]\n        static member height value = Attr.Create \"height\" value\n        /// Create an HTML attribute \"hidden\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hidden\")>]\n        static member hidden value = Attr.Create \"hidden\" value\n        /// Create an HTML attribute \"high\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"high\")>]\n        static member high value = Attr.Create \"high\" value\n        /// Create an HTML attribute \"href\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"href\")>]\n        static member href value = Attr.Create \"href\" value\n        /// Create an HTML attribute \"hreflang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hreflang\")>]\n        static member hreflang value = Attr.Create \"hreflang\" value\n        /// Create an HTML attribute \"hspace\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"hspace\")>]\n        static member hspace value = Attr.Create \"hspace\" value\n        /// Create an HTML attribute \"http\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"http\")>]\n        static member http value = Attr.Create \"http\" value\n        /// Create an HTML attribute \"icon\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"icon\")>]\n        static member icon value = Attr.Create \"icon\" value\n        /// Create an HTML attribute \"id\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"id\")>]\n        static member id value = Attr.Create \"id\" value\n        /// Create an HTML attribute \"ismap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ismap\")>]\n        static member ismap value = Attr.Create \"ismap\" value\n        /// Create an HTML attribute \"itemprop\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"itemprop\")>]\n        static member itemprop value = Attr.Create \"itemprop\" value\n        /// Create an HTML attribute \"keytype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keytype\")>]\n        static member keytype value = Attr.Create \"keytype\" value\n        /// Create an HTML attribute \"kind\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kind\")>]\n        static member kind value = Attr.Create \"kind\" value\n        /// Create an HTML attribute \"label\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"label\")>]\n        static member label value = Attr.Create \"label\" value\n        /// Create an HTML attribute \"lang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"lang\")>]\n        static member lang value = Attr.Create \"lang\" value\n        /// Create an HTML attribute \"language\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"language\")>]\n        static member language value = Attr.Create \"language\" value\n        /// Create an HTML attribute \"link\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"link\")>]\n        static member link value = Attr.Create \"link\" value\n        /// Create an HTML attribute \"list\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"list\")>]\n        static member list value = Attr.Create \"list\" value\n        /// Create an HTML attribute \"longdesc\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"longdesc\")>]\n        static member longdesc value = Attr.Create \"longdesc\" value\n        /// Create an HTML attribute \"loop\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"loop\")>]\n        static member loop value = Attr.Create \"loop\" value\n        /// Create an HTML attribute \"low\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"low\")>]\n        static member low value = Attr.Create \"low\" value\n        /// Create an HTML attribute \"manifest\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"manifest\")>]\n        static member manifest value = Attr.Create \"manifest\" value\n        /// Create an HTML attribute \"marginheight\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marginheight\")>]\n        static member marginheight value = Attr.Create \"marginheight\" value\n        /// Create an HTML attribute \"marginwidth\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marginwidth\")>]\n        static member marginwidth value = Attr.Create \"marginwidth\" value\n        /// Create an HTML attribute \"max\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"max\")>]\n        static member max value = Attr.Create \"max\" value\n        /// Create an HTML attribute \"maxlength\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maxlength\")>]\n        static member maxlength value = Attr.Create \"maxlength\" value\n        /// Create an HTML attribute \"media\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"media\")>]\n        static member media value = Attr.Create \"media\" value\n        /// Create an HTML attribute \"method\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"method\")>]\n        static member ``method`` value = Attr.Create \"method\" value\n        /// Create an HTML attribute \"min\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"min\")>]\n        static member min value = Attr.Create \"min\" value\n        /// Create an HTML attribute \"multiple\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"multiple\")>]\n        static member multiple value = Attr.Create \"multiple\" value\n        /// Create an HTML attribute \"name\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"name\")>]\n        static member name value = Attr.Create \"name\" value\n        /// Create an HTML attribute \"nohref\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"nohref\")>]\n        static member nohref value = Attr.Create \"nohref\" value\n        /// Create an HTML attribute \"noresize\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"noresize\")>]\n        static member noresize value = Attr.Create \"noresize\" value\n        /// Create an HTML attribute \"noshade\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"noshade\")>]\n        static member noshade value = Attr.Create \"noshade\" value\n        /// Create an HTML attribute \"novalidate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"novalidate\")>]\n        static member novalidate value = Attr.Create \"novalidate\" value\n        /// Create an HTML attribute \"nowrap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"nowrap\")>]\n        static member nowrap value = Attr.Create \"nowrap\" value\n        /// Create an HTML attribute \"object\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"object\")>]\n        static member ``object`` value = Attr.Create \"object\" value\n        /// Create an HTML attribute \"open\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"open\")>]\n        static member ``open`` value = Attr.Create \"open\" value\n        /// Create an HTML attribute \"optimum\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"optimum\")>]\n        static member optimum value = Attr.Create \"optimum\" value\n        /// Create an HTML attribute \"pattern\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pattern\")>]\n        static member pattern value = Attr.Create \"pattern\" value\n        /// Create an HTML attribute \"ping\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ping\")>]\n        static member ping value = Attr.Create \"ping\" value\n        /// Create an HTML attribute \"placeholder\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"placeholder\")>]\n        static member placeholder value = Attr.Create \"placeholder\" value\n        /// Create an HTML attribute \"poster\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"poster\")>]\n        static member poster value = Attr.Create \"poster\" value\n        /// Create an HTML attribute \"preload\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preload\")>]\n        static member preload value = Attr.Create \"preload\" value\n        /// Create an HTML attribute \"profile\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"profile\")>]\n        static member profile value = Attr.Create \"profile\" value\n        /// Create an HTML attribute \"prompt\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"prompt\")>]\n        static member prompt value = Attr.Create \"prompt\" value\n        /// Create an HTML attribute \"pubdate\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pubdate\")>]\n        static member pubdate value = Attr.Create \"pubdate\" value\n        /// Create an HTML attribute \"radiogroup\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"radiogroup\")>]\n        static member radiogroup value = Attr.Create \"radiogroup\" value\n        /// Create an HTML attribute \"readonly\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"readonly\")>]\n        static member readonly value = Attr.Create \"readonly\" value\n        /// Create an HTML attribute \"rel\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rel\")>]\n        static member rel value = Attr.Create \"rel\" value\n        /// Create an HTML attribute \"required\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"required\")>]\n        static member required value = Attr.Create \"required\" value\n        /// Create an HTML attribute \"rev\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rev\")>]\n        static member rev value = Attr.Create \"rev\" value\n        /// Create an HTML attribute \"reversed\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"reversed\")>]\n        static member reversed value = Attr.Create \"reversed\" value\n        /// Create an HTML attribute \"rows\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rows\")>]\n        static member rows value = Attr.Create \"rows\" value\n        /// Create an HTML attribute \"rowspan\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rowspan\")>]\n        static member rowspan value = Attr.Create \"rowspan\" value\n        /// Create an HTML attribute \"rules\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rules\")>]\n        static member rules value = Attr.Create \"rules\" value\n        /// Create an HTML attribute \"sandbox\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"sandbox\")>]\n        static member sandbox value = Attr.Create \"sandbox\" value\n        /// Create an HTML attribute \"scheme\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scheme\")>]\n        static member scheme value = Attr.Create \"scheme\" value\n        /// Create an HTML attribute \"scope\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scope\")>]\n        static member scope value = Attr.Create \"scope\" value\n        /// Create an HTML attribute \"scoped\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scoped\")>]\n        static member scoped value = Attr.Create \"scoped\" value\n        /// Create an HTML attribute \"scrolling\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scrolling\")>]\n        static member scrolling value = Attr.Create \"scrolling\" value\n        /// Create an HTML attribute \"seamless\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"seamless\")>]\n        static member seamless value = Attr.Create \"seamless\" value\n        /// Create an HTML attribute \"selected\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"selected\")>]\n        static member selected value = Attr.Create \"selected\" value\n        /// Create an HTML attribute \"shape\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"shape\")>]\n        static member shape value = Attr.Create \"shape\" value\n        /// Create an HTML attribute \"size\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"size\")>]\n        static member size value = Attr.Create \"size\" value\n        /// Create an HTML attribute \"sizes\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"sizes\")>]\n        static member sizes value = Attr.Create \"sizes\" value\n        /// Create an HTML attribute \"span\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"span\")>]\n        static member span value = Attr.Create \"span\" value\n        /// Create an HTML attribute \"spellcheck\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"spellcheck\")>]\n        static member spellcheck value = Attr.Create \"spellcheck\" value\n        /// Create an HTML attribute \"src\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"src\")>]\n        static member src value = Attr.Create \"src\" value\n        /// Create an HTML attribute \"srcdoc\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"srcdoc\")>]\n        static member srcdoc value = Attr.Create \"srcdoc\" value\n        /// Create an HTML attribute \"srclang\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"srclang\")>]\n        static member srclang value = Attr.Create \"srclang\" value\n        /// Create an HTML attribute \"standby\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"standby\")>]\n        static member standby value = Attr.Create \"standby\" value\n        /// Create an HTML attribute \"start\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"start\")>]\n        static member start value = Attr.Create \"start\" value\n        /// Create an HTML attribute \"step\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"step\")>]\n        static member step value = Attr.Create \"step\" value\n        /// Create an HTML attribute \"style\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"style\")>]\n        static member style value = Attr.Create \"style\" value\n        /// Create an HTML attribute \"subject\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"subject\")>]\n        static member subject value = Attr.Create \"subject\" value\n        /// Create an HTML attribute \"summary\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"summary\")>]\n        static member summary value = Attr.Create \"summary\" value\n        /// Create an HTML attribute \"tabindex\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"tabindex\")>]\n        static member tabindex value = Attr.Create \"tabindex\" value\n        /// Create an HTML attribute \"target\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"target\")>]\n        static member target value = Attr.Create \"target\" value\n        /// Create an HTML attribute \"text\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text\")>]\n        static member text value = Attr.Create \"text\" value\n        /// Create an HTML attribute \"title\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"title\")>]\n        static member title value = Attr.Create \"title\" value\n        /// Create an HTML attribute \"type\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"type\")>]\n        static member ``type`` value = Attr.Create \"type\" value\n        /// Create an HTML attribute \"usemap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"usemap\")>]\n        static member usemap value = Attr.Create \"usemap\" value\n        /// Create an HTML attribute \"valign\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"valign\")>]\n        static member valign value = Attr.Create \"valign\" value\n        /// Create an HTML attribute \"value\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"value\")>]\n        static member value value = Attr.Create \"value\" value\n        /// Create an HTML attribute \"valuetype\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"valuetype\")>]\n        static member valuetype value = Attr.Create \"valuetype\" value\n        /// Create an HTML attribute \"version\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"version\")>]\n        static member version value = Attr.Create \"version\" value\n        /// Create an HTML attribute \"vlink\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"vlink\")>]\n        static member vlink value = Attr.Create \"vlink\" value\n        /// Create an HTML attribute \"vspace\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"vspace\")>]\n        static member vspace value = Attr.Create \"vspace\" value\n        /// Create an HTML attribute \"width\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"width\")>]\n        static member width value = Attr.Create \"width\" value\n        /// Create an HTML attribute \"wrap\" with the given value.\n        /// The value can be reactive using `view.V`.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"wrap\")>]\n        static member wrap value = Attr.Create \"wrap\" value\n        // }}\n\n    type on =\n\n        /// Adds a callback to be called after the element has been inserted in the DOM.\n        /// The callback is guaranteed to be called only once, even if the element is moved or removed and reinserted.\n        static member afterRender ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> unit>) = Attr.OnAfterRenderImpl(f)\n\n        // {{ event\n        /// Create a handler for the event \"abort\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member abort ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"abort\", f)\n        /// Create a handler for the event \"afterprint\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member afterPrint ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"afterprint\", f)\n        /// Create a handler for the event \"animationend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationend\", f)\n        /// Create a handler for the event \"animationiteration\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationIteration ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationiteration\", f)\n        /// Create a handler for the event \"animationstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member animationStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"animationstart\", f)\n        /// Create a handler for the event \"audioprocess\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member audioProcess ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"audioprocess\", f)\n        /// Create a handler for the event \"beforeprint\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beforePrint ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beforeprint\", f)\n        /// Create a handler for the event \"beforeunload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beforeUnload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beforeunload\", f)\n        /// Create a handler for the event \"beginEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member beginEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"beginEvent\", f)\n        /// Create a handler for the event \"blocked\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member blocked ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"blocked\", f)\n        /// Create a handler for the event \"blur\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member blur ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.FocusEvent -> unit>) = Attr.HandlerImpl(\"blur\", f)\n        /// Create a handler for the event \"cached\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member cached ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"cached\", f)\n        /// Create a handler for the event \"canplay\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member canPlay ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"canplay\", f)\n        /// Create a handler for the event \"canplaythrough\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member canPlayThrough ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"canplaythrough\", f)\n        /// Create a handler for the event \"change\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member change ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"change\", f)\n        /// Create a handler for the event \"chargingchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member chargingChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"chargingchange\", f)\n        /// Create a handler for the event \"chargingtimechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member chargingTimeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"chargingtimechange\", f)\n        /// Create a handler for the event \"checking\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member checking ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"checking\", f)\n        /// Create a handler for the event \"click\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member click ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"click\", f)\n        /// Create a handler for the event \"close\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member close ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"close\", f)\n        /// Create a handler for the event \"complete\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member complete ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"complete\", f)\n        /// Create a handler for the event \"compositionend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionend\", f)\n        /// Create a handler for the event \"compositionstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionstart\", f)\n        /// Create a handler for the event \"compositionupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member compositionUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.CompositionEvent -> unit>) = Attr.HandlerImpl(\"compositionupdate\", f)\n        /// Create a handler for the event \"contextmenu\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member contextMenu ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"contextmenu\", f)\n        /// Create a handler for the event \"copy\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member copy ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"copy\", f)\n        /// Create a handler for the event \"cut\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member cut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"cut\", f)\n        /// Create a handler for the event \"dblclick\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dblClick ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"dblclick\", f)\n        /// Create a handler for the event \"devicelight\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceLight ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"devicelight\", f)\n        /// Create a handler for the event \"devicemotion\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceMotion ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"devicemotion\", f)\n        /// Create a handler for the event \"deviceorientation\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceOrientation ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"deviceorientation\", f)\n        /// Create a handler for the event \"deviceproximity\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member deviceProximity ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"deviceproximity\", f)\n        /// Create a handler for the event \"dischargingtimechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dischargingTimeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dischargingtimechange\", f)\n        /// Create a handler for the event \"DOMActivate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMActivate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"DOMActivate\", f)\n        /// Create a handler for the event \"DOMAttributeNameChanged\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMAttributeNameChanged ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMAttributeNameChanged\", f)\n        /// Create a handler for the event \"DOMAttrModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMAttrModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMAttrModified\", f)\n        /// Create a handler for the event \"DOMCharacterDataModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMCharacterDataModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMCharacterDataModified\", f)\n        /// Create a handler for the event \"DOMContentLoaded\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMContentLoaded ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMContentLoaded\", f)\n        /// Create a handler for the event \"DOMElementNameChanged\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMElementNameChanged ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"DOMElementNameChanged\", f)\n        /// Create a handler for the event \"DOMNodeInserted\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeInserted ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeInserted\", f)\n        /// Create a handler for the event \"DOMNodeInsertedIntoDocument\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeInsertedIntoDocument ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeInsertedIntoDocument\", f)\n        /// Create a handler for the event \"DOMNodeRemoved\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeRemoved ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeRemoved\", f)\n        /// Create a handler for the event \"DOMNodeRemovedFromDocument\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMNodeRemovedFromDocument ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMNodeRemovedFromDocument\", f)\n        /// Create a handler for the event \"DOMSubtreeModified\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member DOMSubtreeModified ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MutationEvent -> unit>) = Attr.HandlerImpl(\"DOMSubtreeModified\", f)\n        /// Create a handler for the event \"downloading\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member downloading ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"downloading\", f)\n        /// Create a handler for the event \"drag\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member drag ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"drag\", f)\n        /// Create a handler for the event \"dragend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragend\", f)\n        /// Create a handler for the event \"dragenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragenter\", f)\n        /// Create a handler for the event \"dragleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragleave\", f)\n        /// Create a handler for the event \"dragover\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragOver ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragover\", f)\n        /// Create a handler for the event \"dragstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member dragStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"dragstart\", f)\n        /// Create a handler for the event \"drop\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member drop ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"drop\", f)\n        /// Create a handler for the event \"durationchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member durationChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"durationchange\", f)\n        /// Create a handler for the event \"emptied\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member emptied ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"emptied\", f)\n        /// Create a handler for the event \"ended\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member ended ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"ended\", f)\n        /// Create a handler for the event \"endEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member endEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"endEvent\", f)\n        /// Create a handler for the event \"error\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member error ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"error\", f)\n        /// Create a handler for the event \"focus\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member focus ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.FocusEvent -> unit>) = Attr.HandlerImpl(\"focus\", f)\n        /// Create a handler for the event \"fullscreenchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member fullScreenChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"fullscreenchange\", f)\n        /// Create a handler for the event \"fullscreenerror\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member fullScreenError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"fullscreenerror\", f)\n        /// Create a handler for the event \"gamepadconnected\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member gamepadConnected ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"gamepadconnected\", f)\n        /// Create a handler for the event \"gamepaddisconnected\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member gamepadDisconnected ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"gamepaddisconnected\", f)\n        /// Create a handler for the event \"hashchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member hashChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"hashchange\", f)\n        /// Create a handler for the event \"input\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member input ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"input\", f)\n        /// Create a handler for the event \"invalid\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member invalid ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"invalid\", f)\n        /// Create a handler for the event \"keydown\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyDown ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keydown\", f)\n        /// Create a handler for the event \"keypress\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyPress ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keypress\", f)\n        /// Create a handler for the event \"keyup\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member keyUp ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.KeyboardEvent -> unit>) = Attr.HandlerImpl(\"keyup\", f)\n        /// Create a handler for the event \"languagechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member languageChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"languagechange\", f)\n        /// Create a handler for the event \"levelchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member levelChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"levelchange\", f)\n        /// Create a handler for the event \"load\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member load ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"load\", f)\n        /// Create a handler for the event \"loadeddata\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadedData ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadeddata\", f)\n        /// Create a handler for the event \"loadedmetadata\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadedMetadata ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadedmetadata\", f)\n        /// Create a handler for the event \"loadend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadend\", f)\n        /// Create a handler for the event \"loadstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member loadStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"loadstart\", f)\n        /// Create a handler for the event \"message\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member message ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"message\", f)\n        /// Create a handler for the event \"mousedown\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseDown ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mousedown\", f)\n        /// Create a handler for the event \"mouseenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseenter\", f)\n        /// Create a handler for the event \"mouseleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseleave\", f)\n        /// Create a handler for the event \"mousemove\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseMove ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mousemove\", f)\n        /// Create a handler for the event \"mouseout\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseOut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseout\", f)\n        /// Create a handler for the event \"mouseover\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseOver ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseover\", f)\n        /// Create a handler for the event \"mouseup\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member mouseUp ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"mouseup\", f)\n        /// Create a handler for the event \"noupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member noUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"noupdate\", f)\n        /// Create a handler for the event \"obsolete\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member obsolete ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"obsolete\", f)\n        /// Create a handler for the event \"offline\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member offline ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"offline\", f)\n        /// Create a handler for the event \"online\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member online ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"online\", f)\n        /// Create a handler for the event \"open\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member ``open`` ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"open\", f)\n        /// Create a handler for the event \"orientationchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member orientationChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"orientationchange\", f)\n        /// Create a handler for the event \"pagehide\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pageHide ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pagehide\", f)\n        /// Create a handler for the event \"pageshow\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pageShow ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pageshow\", f)\n        /// Create a handler for the event \"paste\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member paste ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"paste\", f)\n        /// Create a handler for the event \"pause\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pause ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pause\", f)\n        /// Create a handler for the event \"play\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member play ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"play\", f)\n        /// Create a handler for the event \"playing\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member playing ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"playing\", f)\n        /// Create a handler for the event \"pointerlockchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pointerLockChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pointerlockchange\", f)\n        /// Create a handler for the event \"pointerlockerror\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member pointerLockError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"pointerlockerror\", f)\n        /// Create a handler for the event \"popstate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member popState ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"popstate\", f)\n        /// Create a handler for the event \"progress\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member progress ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"progress\", f)\n        /// Create a handler for the event \"ratechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member rateChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"ratechange\", f)\n        /// Create a handler for the event \"readystatechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member readyStateChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"readystatechange\", f)\n        /// Create a handler for the event \"repeatEvent\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member repeatEvent ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"repeatEvent\", f)\n        /// Create a handler for the event \"reset\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member reset ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"reset\", f)\n        /// Create a handler for the event \"resize\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member resize ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"resize\", f)\n        /// Create a handler for the event \"scroll\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member scroll ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"scroll\", f)\n        /// Create a handler for the event \"seeked\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member seeked ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"seeked\", f)\n        /// Create a handler for the event \"seeking\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member seeking ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"seeking\", f)\n        /// Create a handler for the event \"select\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member select ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"select\", f)\n        /// Create a handler for the event \"show\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member show ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.MouseEvent -> unit>) = Attr.HandlerImpl(\"show\", f)\n        /// Create a handler for the event \"stalled\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member stalled ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"stalled\", f)\n        /// Create a handler for the event \"storage\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member storage ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"storage\", f)\n        /// Create a handler for the event \"submit\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member submit ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"submit\", f)\n        /// Create a handler for the event \"success\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member success ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"success\", f)\n        /// Create a handler for the event \"suspend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member suspend ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"suspend\", f)\n        /// Create a handler for the event \"SVGAbort\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGAbort ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGAbort\", f)\n        /// Create a handler for the event \"SVGError\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGError ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGError\", f)\n        /// Create a handler for the event \"SVGLoad\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGLoad ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGLoad\", f)\n        /// Create a handler for the event \"SVGResize\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGResize ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGResize\", f)\n        /// Create a handler for the event \"SVGScroll\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGScroll ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGScroll\", f)\n        /// Create a handler for the event \"SVGUnload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGUnload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGUnload\", f)\n        /// Create a handler for the event \"SVGZoom\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member SVGZoom ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"SVGZoom\", f)\n        /// Create a handler for the event \"timeout\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member timeOut ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"timeout\", f)\n        /// Create a handler for the event \"timeupdate\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member timeUpdate ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"timeupdate\", f)\n        /// Create a handler for the event \"touchcancel\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchCancel ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchcancel\", f)\n        /// Create a handler for the event \"touchend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchend\", f)\n        /// Create a handler for the event \"touchenter\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchEnter ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchenter\", f)\n        /// Create a handler for the event \"touchleave\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchLeave ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchleave\", f)\n        /// Create a handler for the event \"touchmove\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchMove ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchmove\", f)\n        /// Create a handler for the event \"touchstart\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member touchStart ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"touchstart\", f)\n        /// Create a handler for the event \"transitionend\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member transitionEnd ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"transitionend\", f)\n        /// Create a handler for the event \"unload\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member unload ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.UIEvent -> unit>) = Attr.HandlerImpl(\"unload\", f)\n        /// Create a handler for the event \"updateready\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member updateReady ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"updateready\", f)\n        /// Create a handler for the event \"upgradeneeded\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member upgradeNeeded ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"upgradeneeded\", f)\n        /// Create a handler for the event \"userproximity\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member userProximity ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"userproximity\", f)\n        /// Create a handler for the event \"versionchange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member versionChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"versionchange\", f)\n        /// Create a handler for the event \"visibilitychange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member visibilityChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"visibilitychange\", f)\n        /// Create a handler for the event \"volumechange\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member volumeChange ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"volumechange\", f)\n        /// Create a handler for the event \"waiting\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member waiting ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.Event -> unit>) = Attr.HandlerImpl(\"waiting\", f)\n        /// Create a handler for the event \"wheel\".\n        /// When called on the server side, the handler must be a top-level function or a static member.\n        static member wheel ([<JavaScript; ReflectedDefinition>] f: Microsoft.FSharp.Quotations.Expr<JavaScript.Dom.Element -> JavaScript.Dom.WheelEvent -> unit>) = Attr.HandlerImpl(\"wheel\", f)\n        // }}\n\n    /// SVG attributes.\n    module SvgAttributes =\n\n        // {{ svgattr normal\n        /// Create an SVG attribute \"accent-height\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accent-height\")>]\n        let accentHeight value = Attr.Create \"accent-height\" value\n        /// Create an SVG attribute \"accumulate\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"accumulate\")>]\n        let accumulate value = Attr.Create \"accumulate\" value\n        /// Create an SVG attribute \"additive\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"additive\")>]\n        let additive value = Attr.Create \"additive\" value\n        /// Create an SVG attribute \"alignment-baseline\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"alignment-baseline\")>]\n        let alignmentBaseline value = Attr.Create \"alignment-baseline\" value\n        /// Create an SVG attribute \"ascent\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ascent\")>]\n        let ascent value = Attr.Create \"ascent\" value\n        /// Create an SVG attribute \"attributeName\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"attributeName\")>]\n        let attributeName value = Attr.Create \"attributeName\" value\n        /// Create an SVG attribute \"attributeType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"attributeType\")>]\n        let attributeType value = Attr.Create \"attributeType\" value\n        /// Create an SVG attribute \"azimuth\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"azimuth\")>]\n        let azimuth value = Attr.Create \"azimuth\" value\n        /// Create an SVG attribute \"baseFrequency\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"baseFrequency\")>]\n        let baseFrequency value = Attr.Create \"baseFrequency\" value\n        /// Create an SVG attribute \"baseline-shift\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"baseline-shift\")>]\n        let baselineShift value = Attr.Create \"baseline-shift\" value\n        /// Create an SVG attribute \"begin\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"begin\")>]\n        let ``begin`` value = Attr.Create \"begin\" value\n        /// Create an SVG attribute \"bias\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"bias\")>]\n        let bias value = Attr.Create \"bias\" value\n        /// Create an SVG attribute \"calcMode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"calcMode\")>]\n        let calcMode value = Attr.Create \"calcMode\" value\n        /// Create an SVG attribute \"class\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"class\")>]\n        let ``class`` value = Attr.Create \"class\" value\n        /// Create an SVG attribute \"clip\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip\")>]\n        let clip value = Attr.Create \"clip\" value\n        /// Create an SVG attribute \"clip-path\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip-path\")>]\n        let clipPath value = Attr.Create \"clip-path\" value\n        /// Create an SVG attribute \"clipPathUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clipPathUnits\")>]\n        let clipPathUnits value = Attr.Create \"clipPathUnits\" value\n        /// Create an SVG attribute \"clip-rule\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"clip-rule\")>]\n        let clipRule value = Attr.Create \"clip-rule\" value\n        /// Create an SVG attribute \"color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color\")>]\n        let color value = Attr.Create \"color\" value\n        /// Create an SVG attribute \"color-interpolation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-interpolation\")>]\n        let colorInterpolation value = Attr.Create \"color-interpolation\" value\n        /// Create an SVG attribute \"color-interpolation-filters\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-interpolation-filters\")>]\n        let colorInterpolationFilters value = Attr.Create \"color-interpolation-filters\" value\n        /// Create an SVG attribute \"color-profile\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-profile\")>]\n        let colorProfile value = Attr.Create \"color-profile\" value\n        /// Create an SVG attribute \"color-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"color-rendering\")>]\n        let colorRendering value = Attr.Create \"color-rendering\" value\n        /// Create an SVG attribute \"contentScriptType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contentScriptType\")>]\n        let contentScriptType value = Attr.Create \"contentScriptType\" value\n        /// Create an SVG attribute \"contentStyleType\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"contentStyleType\")>]\n        let contentStyleType value = Attr.Create \"contentStyleType\" value\n        /// Create an SVG attribute \"cursor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cursor\")>]\n        let cursor value = Attr.Create \"cursor\" value\n        /// Create an SVG attribute \"cx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cx\")>]\n        let cx value = Attr.Create \"cx\" value\n        /// Create an SVG attribute \"cy\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"cy\")>]\n        let cy value = Attr.Create \"cy\" value\n        /// Create an SVG attribute \"d\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"d\")>]\n        let d value = Attr.Create \"d\" value\n        /// Create an SVG attribute \"diffuseConstant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"diffuseConstant\")>]\n        let diffuseConstant value = Attr.Create \"diffuseConstant\" value\n        /// Create an SVG attribute \"direction\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"direction\")>]\n        let direction value = Attr.Create \"direction\" value\n        /// Create an SVG attribute \"display\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"display\")>]\n        let display value = Attr.Create \"display\" value\n        /// Create an SVG attribute \"divisor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"divisor\")>]\n        let divisor value = Attr.Create \"divisor\" value\n        /// Create an SVG attribute \"dominant-baseline\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dominant-baseline\")>]\n        let dominantBaseline value = Attr.Create \"dominant-baseline\" value\n        /// Create an SVG attribute \"dur\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dur\")>]\n        let dur value = Attr.Create \"dur\" value\n        /// Create an SVG attribute \"dx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dx\")>]\n        let dx value = Attr.Create \"dx\" value\n        /// Create an SVG attribute \"dy\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"dy\")>]\n        let dy value = Attr.Create \"dy\" value\n        /// Create an SVG attribute \"edgeMode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"edgeMode\")>]\n        let edgeMode value = Attr.Create \"edgeMode\" value\n        /// Create an SVG attribute \"elevation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"elevation\")>]\n        let elevation value = Attr.Create \"elevation\" value\n        /// Create an SVG attribute \"end\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"end\")>]\n        let ``end`` value = Attr.Create \"end\" value\n        /// Create an SVG attribute \"externalResourcesRequired\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"externalResourcesRequired\")>]\n        let externalResourcesRequired value = Attr.Create \"externalResourcesRequired\" value\n        /// Create an SVG attribute \"fill\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill\")>]\n        let fill value = Attr.Create \"fill\" value\n        /// Create an SVG attribute \"fill-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill-opacity\")>]\n        let fillOpacity value = Attr.Create \"fill-opacity\" value\n        /// Create an SVG attribute \"fill-rule\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"fill-rule\")>]\n        let fillRule value = Attr.Create \"fill-rule\" value\n        /// Create an SVG attribute \"filter\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filter\")>]\n        let filter value = Attr.Create \"filter\" value\n        /// Create an SVG attribute \"filterRes\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filterRes\")>]\n        let filterRes value = Attr.Create \"filterRes\" value\n        /// Create an SVG attribute \"filterUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"filterUnits\")>]\n        let filterUnits value = Attr.Create \"filterUnits\" value\n        /// Create an SVG attribute \"flood-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"flood-color\")>]\n        let floodColor value = Attr.Create \"flood-color\" value\n        /// Create an SVG attribute \"flood-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"flood-opacity\")>]\n        let floodOpacity value = Attr.Create \"flood-opacity\" value\n        /// Create an SVG attribute \"font-family\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-family\")>]\n        let fontFamily value = Attr.Create \"font-family\" value\n        /// Create an SVG attribute \"font-size\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-size\")>]\n        let fontSize value = Attr.Create \"font-size\" value\n        /// Create an SVG attribute \"font-size-adjust\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-size-adjust\")>]\n        let fontSizeAdjust value = Attr.Create \"font-size-adjust\" value\n        /// Create an SVG attribute \"font-stretch\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-stretch\")>]\n        let fontStretch value = Attr.Create \"font-stretch\" value\n        /// Create an SVG attribute \"font-style\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-style\")>]\n        let fontStyle value = Attr.Create \"font-style\" value\n        /// Create an SVG attribute \"font-variant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-variant\")>]\n        let fontVariant value = Attr.Create \"font-variant\" value\n        /// Create an SVG attribute \"font-weight\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"font-weight\")>]\n        let fontWeight value = Attr.Create \"font-weight\" value\n        /// Create an SVG attribute \"from\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"from\")>]\n        let from value = Attr.Create \"from\" value\n        /// Create an SVG attribute \"gradientTransform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"gradientTransform\")>]\n        let gradientTransform value = Attr.Create \"gradientTransform\" value\n        /// Create an SVG attribute \"gradientUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"gradientUnits\")>]\n        let gradientUnits value = Attr.Create \"gradientUnits\" value\n        /// Create an SVG attribute \"height\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"height\")>]\n        let height value = Attr.Create \"height\" value\n        /// Create an SVG attribute \"image-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"image-rendering\")>]\n        let imageRendering value = Attr.Create \"image-rendering\" value\n        /// Create an SVG attribute \"in\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"in\")>]\n        let ``in`` value = Attr.Create \"in\" value\n        /// Create an SVG attribute \"in2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"in2\")>]\n        let in2 value = Attr.Create \"in2\" value\n        /// Create an SVG attribute \"k1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k1\")>]\n        let k1 value = Attr.Create \"k1\" value\n        /// Create an SVG attribute \"k2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k2\")>]\n        let k2 value = Attr.Create \"k2\" value\n        /// Create an SVG attribute \"k3\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k3\")>]\n        let k3 value = Attr.Create \"k3\" value\n        /// Create an SVG attribute \"k4\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"k4\")>]\n        let k4 value = Attr.Create \"k4\" value\n        /// Create an SVG attribute \"kernelMatrix\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kernelMatrix\")>]\n        let kernelMatrix value = Attr.Create \"kernelMatrix\" value\n        /// Create an SVG attribute \"kernelUnitLength\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kernelUnitLength\")>]\n        let kernelUnitLength value = Attr.Create \"kernelUnitLength\" value\n        /// Create an SVG attribute \"kerning\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"kerning\")>]\n        let kerning value = Attr.Create \"kerning\" value\n        /// Create an SVG attribute \"keySplines\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keySplines\")>]\n        let keySplines value = Attr.Create \"keySplines\" value\n        /// Create an SVG attribute \"keyTimes\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"keyTimes\")>]\n        let keyTimes value = Attr.Create \"keyTimes\" value\n        /// Create an SVG attribute \"letter-spacing\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"letter-spacing\")>]\n        let letterSpacing value = Attr.Create \"letter-spacing\" value\n        /// Create an SVG attribute \"lighting-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"lighting-color\")>]\n        let lightingColor value = Attr.Create \"lighting-color\" value\n        /// Create an SVG attribute \"limitingConeAngle\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"limitingConeAngle\")>]\n        let limitingConeAngle value = Attr.Create \"limitingConeAngle\" value\n        /// Create an SVG attribute \"local\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"local\")>]\n        let local value = Attr.Create \"local\" value\n        /// Create an SVG attribute \"marker-end\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-end\")>]\n        let markerEnd value = Attr.Create \"marker-end\" value\n        /// Create an SVG attribute \"markerHeight\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerHeight\")>]\n        let markerHeight value = Attr.Create \"markerHeight\" value\n        /// Create an SVG attribute \"marker-mid\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-mid\")>]\n        let markerMid value = Attr.Create \"marker-mid\" value\n        /// Create an SVG attribute \"marker-start\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"marker-start\")>]\n        let markerStart value = Attr.Create \"marker-start\" value\n        /// Create an SVG attribute \"markerUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerUnits\")>]\n        let markerUnits value = Attr.Create \"markerUnits\" value\n        /// Create an SVG attribute \"markerWidth\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"markerWidth\")>]\n        let markerWidth value = Attr.Create \"markerWidth\" value\n        /// Create an SVG attribute \"mask\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"mask\")>]\n        let mask value = Attr.Create \"mask\" value\n        /// Create an SVG attribute \"maskContentUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maskContentUnits\")>]\n        let maskContentUnits value = Attr.Create \"maskContentUnits\" value\n        /// Create an SVG attribute \"maskUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"maskUnits\")>]\n        let maskUnits value = Attr.Create \"maskUnits\" value\n        /// Create an SVG attribute \"max\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"max\")>]\n        let max value = Attr.Create \"max\" value\n        /// Create an SVG attribute \"min\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"min\")>]\n        let min value = Attr.Create \"min\" value\n        /// Create an SVG attribute \"mode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"mode\")>]\n        let mode value = Attr.Create \"mode\" value\n        /// Create an SVG attribute \"numOctaves\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"numOctaves\")>]\n        let numOctaves value = Attr.Create \"numOctaves\" value\n        /// Create an SVG attribute \"opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"opacity\")>]\n        let opacity value = Attr.Create \"opacity\" value\n        /// Create an SVG attribute \"operator\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"operator\")>]\n        let operator value = Attr.Create \"operator\" value\n        /// Create an SVG attribute \"order\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"order\")>]\n        let order value = Attr.Create \"order\" value\n        /// Create an SVG attribute \"overflow\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"overflow\")>]\n        let overflow value = Attr.Create \"overflow\" value\n        /// Create an SVG attribute \"paint-order\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"paint-order\")>]\n        let paintOrder value = Attr.Create \"paint-order\" value\n        /// Create an SVG attribute \"pathLength\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pathLength\")>]\n        let pathLength value = Attr.Create \"pathLength\" value\n        /// Create an SVG attribute \"patternContentUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternContentUnits\")>]\n        let patternContentUnits value = Attr.Create \"patternContentUnits\" value\n        /// Create an SVG attribute \"patternTransform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternTransform\")>]\n        let patternTransform value = Attr.Create \"patternTransform\" value\n        /// Create an SVG attribute \"patternUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"patternUnits\")>]\n        let patternUnits value = Attr.Create \"patternUnits\" value\n        /// Create an SVG attribute \"pointer-events\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointer-events\")>]\n        let pointerEvents value = Attr.Create \"pointer-events\" value\n        /// Create an SVG attribute \"points\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"points\")>]\n        let points value = Attr.Create \"points\" value\n        /// Create an SVG attribute \"pointsAtX\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtX\")>]\n        let pointsAtX value = Attr.Create \"pointsAtX\" value\n        /// Create an SVG attribute \"pointsAtY\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtY\")>]\n        let pointsAtY value = Attr.Create \"pointsAtY\" value\n        /// Create an SVG attribute \"pointsAtZ\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"pointsAtZ\")>]\n        let pointsAtZ value = Attr.Create \"pointsAtZ\" value\n        /// Create an SVG attribute \"preserveAlpha\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preserveAlpha\")>]\n        let preserveAlpha value = Attr.Create \"preserveAlpha\" value\n        /// Create an SVG attribute \"preserveAspectRatio\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"preserveAspectRatio\")>]\n        let preserveAspectRatio value = Attr.Create \"preserveAspectRatio\" value\n        /// Create an SVG attribute \"primitiveUnits\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"primitiveUnits\")>]\n        let primitiveUnits value = Attr.Create \"primitiveUnits\" value\n        /// Create an SVG attribute \"r\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"r\")>]\n        let r value = Attr.Create \"r\" value\n        /// Create an SVG attribute \"radius\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"radius\")>]\n        let radius value = Attr.Create \"radius\" value\n        /// Create an SVG attribute \"repeatCount\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"repeatCount\")>]\n        let repeatCount value = Attr.Create \"repeatCount\" value\n        /// Create an SVG attribute \"repeatDur\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"repeatDur\")>]\n        let repeatDur value = Attr.Create \"repeatDur\" value\n        /// Create an SVG attribute \"requiredFeatures\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"requiredFeatures\")>]\n        let requiredFeatures value = Attr.Create \"requiredFeatures\" value\n        /// Create an SVG attribute \"restart\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"restart\")>]\n        let restart value = Attr.Create \"restart\" value\n        /// Create an SVG attribute \"result\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"result\")>]\n        let result value = Attr.Create \"result\" value\n        /// Create an SVG attribute \"rx\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"rx\")>]\n        let rx value = Attr.Create \"rx\" value\n        /// Create an SVG attribute \"ry\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"ry\")>]\n        let ry value = Attr.Create \"ry\" value\n        /// Create an SVG attribute \"scale\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"scale\")>]\n        let scale value = Attr.Create \"scale\" value\n        /// Create an SVG attribute \"seed\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"seed\")>]\n        let seed value = Attr.Create \"seed\" value\n        /// Create an SVG attribute \"shape-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"shape-rendering\")>]\n        let shapeRendering value = Attr.Create \"shape-rendering\" value\n        /// Create an SVG attribute \"specularConstant\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"specularConstant\")>]\n        let specularConstant value = Attr.Create \"specularConstant\" value\n        /// Create an SVG attribute \"specularExponent\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"specularExponent\")>]\n        let specularExponent value = Attr.Create \"specularExponent\" value\n        /// Create an SVG attribute \"stdDeviation\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stdDeviation\")>]\n        let stdDeviation value = Attr.Create \"stdDeviation\" value\n        /// Create an SVG attribute \"stitchTiles\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stitchTiles\")>]\n        let stitchTiles value = Attr.Create \"stitchTiles\" value\n        /// Create an SVG attribute \"stop-color\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stop-color\")>]\n        let stopColor value = Attr.Create \"stop-color\" value\n        /// Create an SVG attribute \"stop-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stop-opacity\")>]\n        let stopOpacity value = Attr.Create \"stop-opacity\" value\n        /// Create an SVG attribute \"stroke\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke\")>]\n        let stroke value = Attr.Create \"stroke\" value\n        /// Create an SVG attribute \"stroke-dasharray\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-dasharray\")>]\n        let strokeDasharray value = Attr.Create \"stroke-dasharray\" value\n        /// Create an SVG attribute \"stroke-dashoffset\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-dashoffset\")>]\n        let strokeDashoffset value = Attr.Create \"stroke-dashoffset\" value\n        /// Create an SVG attribute \"stroke-linecap\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-linecap\")>]\n        let strokeLinecap value = Attr.Create \"stroke-linecap\" value\n        /// Create an SVG attribute \"stroke-linejoin\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-linejoin\")>]\n        let strokeLinejoin value = Attr.Create \"stroke-linejoin\" value\n        /// Create an SVG attribute \"stroke-miterlimit\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-miterlimit\")>]\n        let strokeMiterlimit value = Attr.Create \"stroke-miterlimit\" value\n        /// Create an SVG attribute \"stroke-opacity\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-opacity\")>]\n        let strokeOpacity value = Attr.Create \"stroke-opacity\" value\n        /// Create an SVG attribute \"stroke-width\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"stroke-width\")>]\n        let strokeWidth value = Attr.Create \"stroke-width\" value\n        /// Create an SVG attribute \"style\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"style\")>]\n        let style value = Attr.Create \"style\" value\n        /// Create an SVG attribute \"surfaceScale\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"surfaceScale\")>]\n        let surfaceScale value = Attr.Create \"surfaceScale\" value\n        /// Create an SVG attribute \"targetX\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"targetX\")>]\n        let targetX value = Attr.Create \"targetX\" value\n        /// Create an SVG attribute \"targetY\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"targetY\")>]\n        let targetY value = Attr.Create \"targetY\" value\n        /// Create an SVG attribute \"text-anchor\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-anchor\")>]\n        let textAnchor value = Attr.Create \"text-anchor\" value\n        /// Create an SVG attribute \"text-decoration\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-decoration\")>]\n        let textDecoration value = Attr.Create \"text-decoration\" value\n        /// Create an SVG attribute \"text-rendering\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"text-rendering\")>]\n        let textRendering value = Attr.Create \"text-rendering\" value\n        /// Create an SVG attribute \"to\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"to\")>]\n        let ``to`` value = Attr.Create \"to\" value\n        /// Create an SVG attribute \"transform\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"transform\")>]\n        let transform value = Attr.Create \"transform\" value\n        /// Create an SVG attribute \"type\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"type\")>]\n        let ``type`` value = Attr.Create \"type\" value\n        /// Create an SVG attribute \"values\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"values\")>]\n        let values value = Attr.Create \"values\" value\n        /// Create an SVG attribute \"viewBox\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"viewBox\")>]\n        let viewBox value = Attr.Create \"viewBox\" value\n        /// Create an SVG attribute \"visibility\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"visibility\")>]\n        let visibility value = Attr.Create \"visibility\" value\n        /// Create an SVG attribute \"width\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"width\")>]\n        let width value = Attr.Create \"width\" value\n        /// Create an SVG attribute \"word-spacing\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"word-spacing\")>]\n        let wordSpacing value = Attr.Create \"word-spacing\" value\n        /// Create an SVG attribute \"writing-mode\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"writing-mode\")>]\n        let writingMode value = Attr.Create \"writing-mode\" value\n        /// Create an SVG attribute \"x\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x\")>]\n        let x value = Attr.Create \"x\" value\n        /// Create an SVG attribute \"x1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x1\")>]\n        let x1 value = Attr.Create \"x1\" value\n        /// Create an SVG attribute \"x2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"x2\")>]\n        let x2 value = Attr.Create \"x2\" value\n        /// Create an SVG attribute \"xChannelSelector\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"xChannelSelector\")>]\n        let xChannelSelector value = Attr.Create \"xChannelSelector\" value\n        /// Create an SVG attribute \"y\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y\")>]\n        let y value = Attr.Create \"y\" value\n        /// Create an SVG attribute \"y1\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y1\")>]\n        let y1 value = Attr.Create \"y1\" value\n        /// Create an SVG attribute \"y2\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"y2\")>]\n        let y2 value = Attr.Create \"y2\" value\n        /// Create an SVG attribute \"yChannelSelector\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"yChannelSelector\")>]\n        let yChannelSelector value = Attr.Create \"yChannelSelector\" value\n        /// Create an SVG attribute \"z\" with the given value.\n        [<JavaScript; Inline; Macro(typeof<Macros.AttrCreate>, \"z\")>]\n        let z value = Attr.Create \"z\" value\n        // }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Sitelets\n\n[<CompiledName \"InstallRouter\">]\n[<JavaScript>]\nmodule Router =\n\n    let private getCurrent parse onParseError =\n        let loc = JS.Window.Location\n        let p = loc.Pathname + loc.Search |> Route.FromUrl\n        match parse p with\n        | Some a -> a\n        | None ->\n            printfn \"Failed to parse route: %s\" (p.ToLink()) \n            onParseError\n\n    /// Trim the #fragment, if any, from a URL.\n    let private trimFragment (url: string) =\n        match url.IndexOf('#') with\n        | -1 -> url\n        | i -> url.[..i-1]\n\n    /// Transform the url from an <a href=\"XYZ\"> tag into an absolute path+query,\n    /// if it is indeed a URL that Install wants to handle.\n    let private hrefToAbsolute (href: string) =\n        if href.StartsWith(\"?\") then\n            // Query only, just add it to the current path\n            Some (JS.Window.Location.Pathname + href |> trimFragment)\n        elif href.StartsWith(\"#\") then\n            // Fragment only, Install doesn't handle it\n            None\n        elif href.StartsWith(\"/\") then\n            // Absolute path, just use it\n            Some (href |> trimFragment)\n        elif RegExp(\"^[a-zA-Z0-9]:\").Test(href) then\n            // Full URL (eg: \"http://foo.bar\"), we don't handle it\n            None\n        else\n            // Relative URL, combine it with the current path\n            let s = JS.Window.Location.Pathname\n            Some (s.[..s.LastIndexOf('/')] + href |> trimFragment)\n\n    let rec private findLinkHref (n: Dom.Element) =\n        if n.TagName = \"A\" then\n            n.GetAttribute(\"href\") |> Option.ofObj\n        elif n ===. JS.Document.Body then\n            None\n        else\n            findLinkHref (n.ParentNode :?> Dom.Element)\n\n    /// Installs client-side routing on the full URL. \n    /// If initials URL parse fails, value is left as the initial value of `var`.\n    let InstallInto (var: Var<'T>) onParseError (router: Router<'T>) : unit =\n        let parse p = Router.Parse router p\n        let cur() : 'T = getCurrent parse onParseError\n\n        let set value =\n            if var.Value <> value then\n                var.Value <- value\n        \n        JS.Window.AddEventListener(\"popstate\", (fun () -> set (cur())), false)\n\n        JS.Document.Body.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            findLinkHref (As ev.Target)\n            |> Option.bind hrefToAbsolute\n            |> Option.bind (Route.FromUrl >> parse)\n            |> Option.iter (fun a ->\n                set a\n                ev.PreventDefault()\n            )\n        ), false)\n        \n        var.View\n        |> View.Sink (fun value ->\n            if value <> cur() then \n                let url = Router.Link router value\n                JS.Window.History.PushState(null, null, url)\n        )\n\n    /// Installs client-side routing on the full URL. \n    /// If initials URL parse fails, value is set to `onParseError`. \n    let Install onParseError (router: Router<'T>) : Var<'T> =\n        let parse p = Router.Parse router p\n        let var = Var.Create (getCurrent parse onParseError)\n        InstallInto var onParseError router\n        var\n\n    let private getCurrentHash parse onParseError =\n        let h = JS.Window.Location.Hash\n        match parse h with\n        | Some a -> \n            a\n        | None ->\n            printfn \"Failed to parse route: %s\" h \n            onParseError\n\n    /// Installs client-side routing on the hash part of the URL. \n    /// If initials URL parse fails, value is left as the initial value of `var`.\n    let InstallHashInto (var: Var<'T>) onParseError (router: Router<'T>) =\n        let parse h = \n            let p = Route.FromHash(h, true)\n            Router.Parse router p\n        let cur() : 'T = getCurrentHash parse onParseError\n        let set value =\n            if var.Value <> value then\n                var.Value <- value\n       \n        JS.Window.AddEventListener(\"popstate\", (fun () -> set (cur())), false)\n        JS.Window.AddEventListener(\"hashchange\", (fun () -> set (cur())), false)\n\n        JS.Document.Body.AddEventListener(\"click\", (fun (ev: Dom.Event) ->\n            findLinkHref (As ev.Target)\n            |> Option.bind (fun href -> if href.StartsWith \"#\" then parse href else None)\n            |> Option.iter (fun a ->\n                set a\n                ev.PreventDefault()\n            )\n        ), false)\n\n        var.View\n        |> View.Sink (fun value ->\n            if value <> cur() then \n                let url = Router.HashLink router value\n                JS.Window.History.PushState(null, null, url)\n        )\n\n    /// Installs client-side routing on the hash part of the URL. \n    /// If initials URL parse fails, value is set to `onParseError`. \n    let InstallHash onParseError (router: Router<'T>) =\n        let parse h = \n            let p = Route.FromHash(h, true)\n            Router.Parse router p\n        let cur() : 'T = getCurrentHash parse onParseError\n        let var = Var.Create (cur())\n        InstallHashInto var onParseError router\n        var\n\nopen System.Runtime.CompilerServices\n\n[<Extension; JavaScript>]\ntype RouterExtensions =\n\n    [<Extension; Inline>]\n    static member Install(router, onParseError) =\n        Router.Install onParseError router\n\n    [<Extension; Inline>]\n    static member InstallHash(router, onParseError) =\n        Router.InstallHash onParseError router\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI\n\n// NOTES: need better facilities for the user to construct routers. In particular,\n// should be possible to encode numbers, semi-automatically provide bijections,\n// and so on.\n\nopen WebSharper\nopen WebSharper.JavaScript\nmodule A = AppendList\nmodule T = Trie\n\ntype RouteMap<'T> =\n    {\n        Des : (list<string> * Map<string, string>) -> 'T\n        Ser : 'T -> (list<string> * Map<string, string>)\n    }\n\n[<JavaScript>]\nmodule Route =\n\n    let private NoHash (s: string) =\n        if s.StartsWith(\"#\") then s.Substring(1) else s\n\n    [<Inline \"decodeURIComponent($x)\">]\n    let private Decode (x: string) : string = JS.Undefined\n\n    [<Inline \"encodeURIComponent($x)\">]\n    let private Encode (x: string) : string = JS.Undefined\n\n    type T =\n        private\n        | Route of AppendList<string> * Map<string, string>\n\n    let ParseHash (hash: string) =\n        let hash = NoHash hash\n        let path, query =\n            match hash.IndexOf '?' with\n            | -1 -> hash, \"\"\n            | i -> hash.[..i-1], hash.[i+1..]\n        let path =\n            if path = \"\" then [||] \n            else path.Split('/') |> Array.map Decode\n            |> A.FromArray\n        let query =\n            query.Split('&')\n            |> Array.map (fun s ->\n                match s.IndexOf '=' with\n                | -1 -> Decode s, \"\"\n                | i -> Decode (s.[..i-1]), Decode (s.[i+1..]))\n            |> Map.ofArray\n        Route (path, query)\n\n    let MakeHash (Route (path, query)) =\n        let path =\n            A.ToArray path\n            |> Array.map Encode\n            |> String.concat \"/\"\n        if Map.isEmpty query then\n            path\n        else\n            path + \"?\" +\n            (query\n            |> Seq.map (fun (KeyValue(k, v)) -> Encode k + \"=\" + Encode v)\n            |> String.concat \"&\")\n\n    let SameHash a b =\n        NoHash a = NoHash b\n\n    let ToList (Route (rt, q)) =\n        let path =\n            A.ToArray rt\n            |> Array.toList\n        path, q\n\n    let FromList (xs, q) =\n        let a =\n            List.toArray xs\n            |> A.FromArray\n        Route(a, q)\n\n    let Append (Route (pa, qa)) (Route (pb, qb)) =\n        Route (A.Append pa pb, Map.foldBack Map.add qa qb)\n\n[<JavaScript>]\nmodule Routing =\n\n    let InstallMap (rt: RouteMap<'T>) : Var<'T> =\n        let win = JS.Window\n        let same a b = rt.Ser a = rt.Ser b\n        let cur () =\n            Route.ParseHash win.Location.Hash\n            |> Route.ToList\n            |> rt.Des\n        let var = Var.Create (cur ())\n        let set value =\n            if not (same var.Value value) then\n                var.Value <- value\n        let onUpdate = System.Action<_>(fun (evt: Dom.Event) -> set (cur ()))\n        win.Onpopstate <- onUpdate\n        win.Onhashchange <- onUpdate\n        var.View\n        |> View.Sink (fun loc ->\n            let ha = Route.MakeHash (Route.FromList (rt.Ser loc))\n            if not (Route.SameHash win.Location.Hash ha) then\n                win.Location.Replace (\"#\" + ha))\n        var\n\n    let DoRoute map route =\n        map.Des (Route.ToList route)\n\n    let DoLink map va =\n        Route.FromList (map.Ser va)\n\n[<JavaScript>]\n[<Sealed>]\ntype RouteMap =\n\n    static member CreateWithQuery ser des =\n        { Ser = ser; Des = des }\n\n    static member Create ser des =\n        { Ser = (fun x -> ser x, Map.empty); Des = fst >> des }\n\n    static member Install map =\n        Routing.InstallMap map\n", "namespace WebSharper.UI\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Notation\nopen WebSharper.JQuery\n\n[<JavaScript>]\nmodule Input =\n\n    type MousePosSt =\n        {\n            mutable Active : bool\n            PosV : Var<int * int>\n        }\n\n    type MouseBtnSt =\n        {\n            mutable Active : bool\n            Left : Var<bool>\n            Middle : Var<bool>\n            Right : Var<bool>\n        }\n\n    let MousePosSt = { Active = false; PosV = Var.Create (0, 0) }\n    let MouseBtnSt =\n        {\n            Active = false;\n            Left = Var.Create false\n            Middle = Var.Create false\n            Right = Var.Create false\n        }\n\n    // Add the button listener if it hasn't been added already.\n    // Button listener adds mousedown and mouseup events, which modify\n    // MouseBtnSt vars.\n    let ActivateButtonListener =\n        let buttonListener (evt: Dom.MouseEvent) down =\n            match evt.Button with\n            | 0 -> Var.Set MouseBtnSt.Left down\n            | 1 -> Var.Set MouseBtnSt.Middle down\n            | 2 -> Var.Set MouseBtnSt.Right down\n            | _ -> ()\n\n        if not MouseBtnSt.Active then\n            MouseBtnSt.Active <- true\n            JS.Document.AddEventListener(\"mousedown\",\n                (fun (evt: Dom.Event) -> buttonListener (evt :?> Dom.MouseEvent) true), false)\n            JS.Document.AddEventListener(\"mouseup\",\n                (fun (evt: Dom.Event) -> buttonListener (evt :?> Dom.MouseEvent) false), false)\n\n    [<Sealed>]\n    type Mouse =\n\n        static member Position =\n\n            let onMouseMove (evt: Dom.Event) =\n                // We know this is a mouse event, so safe to downcast\n                let mEvt = evt :?> Dom.MouseEvent\n                Var.Set MousePosSt.PosV (mEvt.ClientX, mEvt.ClientY)\n\n            // Add the mouse movement event if it's not there already.\n            if not MousePosSt.Active then\n                JS.Document.AddEventListener(\"mousemove\", onMouseMove, false)\n                MousePosSt.Active <- true\n\n            View.FromVar MousePosSt.PosV\n\n        static member LeftPressed =\n            ActivateButtonListener\n            MouseBtnSt.Left.View\n\n        static member MiddlePressed =\n            ActivateButtonListener\n            MouseBtnSt.Middle.View\n\n        static member RightPressed =\n            ActivateButtonListener\n            MouseBtnSt.Right.View\n\n        static member MousePressed =\n            ActivateButtonListener\n            // True if any button is pressed\n            View.Const (fun l m r -> l || m || r)\n            <*> MouseBtnSt.Left.View\n            <*> MouseBtnSt.Middle.View\n            <*> MouseBtnSt.Right.View\n\n    type Key = int\n\n    // State for keyboard listener: which keys are pressed, whether the listener\n    // is active, and the last key that has been presed\n    type KeyListenerSt =\n        {\n            KeysPressed : Var<Key list>\n            mutable KeyListenerActive : bool\n            LastPressed : Var<Key>\n        }\n\n    let KeyListenerState =\n        {\n            KeysPressed = Var.Create []\n            KeyListenerActive = false\n            LastPressed = Var.Create (-1)\n        }\n\n    let ActivateKeyListener =\n        if not KeyListenerState.KeyListenerActive then\n            // Using JQuery for cross-compatibility.\n            JQuery.Of(JS.Document).Keydown(fun el evt ->\n                let keyCode = evt.Which\n                Var.Set KeyListenerState.LastPressed keyCode\n                let xs = Var.Get KeyListenerState.KeysPressed\n                if not (List.exists (fun x -> x = keyCode) xs) then\n                    KeyListenerState.KeysPressed.Value <- xs @ [keyCode]\n            ) |> ignore\n\n            JQuery.Of(JS.Document).Keyup(fun el evt ->\n                let keyCode = evt.Which\n                Var.Update KeyListenerState.KeysPressed\n                    (List.filter (fun x -> x <> keyCode))\n            ) |> ignore\n\n    [<Sealed>]\n    type Keyboard =\n\n        static member KeysPressed =\n            ActivateKeyListener\n            KeyListenerState.KeysPressed.View\n\n        static member LastPressed =\n            ActivateKeyListener\n            KeyListenerState.LastPressed.View\n\n        static member IsPressed key =\n            ActivateKeyListener\n            View.Map (List.exists (fun x -> x = key))\n                KeyListenerState.KeysPressed.View\n"],
"names": [],
"mappings": "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"
}
