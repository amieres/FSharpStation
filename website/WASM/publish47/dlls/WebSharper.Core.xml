<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>WebSharper.Core</name></assembly>
<members>
<member name="T:WebSharper.WildcardAttribute">
<summary>
 Indicates that the last field or union case argument parses all the remaining
 path segments into a list or an array.
 Example: type Action = | [&lt;Wildcard&gt;] MyAction of string * list&lt;string&gt;
</summary>
</member>
<member name="M:WebSharper.FormDataAttribute.#ctor(System.String[])">
<summary>
 Indicates that the union case arguments with the given names must be parsed
 from the request&apos;s query parameters.
 Example: type Action = | [&lt;FormData &quot;someField&quot;&gt;] MyAction of someField: string
</summary>
</member>
<member name="M:WebSharper.FormDataAttribute.#ctor">
<summary>
 Indicates that a field must be parsed from the request&apos;s query parameters.
 Example: type Action = { [&lt;FormData&gt;] someField: string }
</summary>
</member>
<member name="T:WebSharper.FormDataAttribute">
<summary>
 Indicates that a field or union case argument must be parsed
 from the request&apos;s body in form post syntax, ie. with the Content-Type
 being either application/x-www-form-urlencoded or multipart/form-data.
 The value must be a primitive value, a DateTime, or an option thereof.
</summary>
</member>
<member name="M:WebSharper.QueryAttribute.#ctor(System.String[])">
<summary>
 Indicates that the union case arguments with the given names must be parsed
 from the request&apos;s query parameters.
 Example: type Action = | [&lt;Query &quot;someField&quot;&gt;] MyAction of someField: string
</summary>
</member>
<member name="M:WebSharper.QueryAttribute.#ctor">
<summary>
 Indicates that a field must be parsed from the request&apos;s query parameters.
 Example: type Action = { [&lt;Query&gt;] someField : string }
</summary>
</member>
<member name="T:WebSharper.QueryAttribute">
<summary>
 Indicates that a field or union case argument must be parsed
 from the request&apos;s query parameters, rather than from the URL path.
 The value must be a primitive value, a DateTime, or an option thereof.
</summary>
</member>
<member name="M:WebSharper.JsonAttribute.#ctor(System.String)">
<summary>
 Indicates that the union case argument with the given name must be parsed
 from the request&apos;s body as JSON.
 Example: type Action = | [&lt;Json &quot;data&quot;&gt;] MyAction of data: MyData
</summary>
</member>
<member name="M:WebSharper.JsonAttribute.#ctor">
<summary>
 Indicates that a field must be parsed from the request&apos;s body as JSON.
 Example: type Action = { [&lt;Json&gt;] data : MyData }
</summary>
</member>
<member name="T:WebSharper.JsonAttribute">
<summary>
 Indicates that a field or a union case argument must be parsed
 from the request body as JSON, rather than from the URL path.
</summary>
</member>
<member name="T:WebSharper.MethodAttribute">
<summary>
 Indicates that a union case in an action type must only be mapped
 for requests that use the given HTTP method(s).
 Example: type Action = | [&lt;Method &quot;POST&quot;&gt;] MyPostAction
</summary>
</member>
<member name="M:WebSharper.EndPointAttribute.#ctor(System.String,System.Int32,System.Boolean)">
<summary>
 Indicates the URL fragments parsed by this class.
 `order` specifies the parsing order.
 `inheritRoute = false` allows re-specifying the full route instead of inheriting starting segment(s) from
 base class.
</summary>
</member>
<member name="M:WebSharper.EndPointAttribute.#ctor(System.String,System.Int32)">
<summary>
 Indicates the URL fragments parsed by this class.
 `order` specifies the parsing order.
</summary>
</member>
<member name="M:WebSharper.EndPointAttribute.#ctor(System.String,System.Boolean)">
<summary>
 Indicates the URL fragments parsed by this class.
 `inheritRoute = false` allows re-specifying the full route instead of inheriting starting segment(s) from
 base class.
</summary>
</member>
<member name="M:WebSharper.EndPointAttribute.#ctor(System.String[])">
<summary>
 Indicates the URL fragments parsed by this class or union case.
 If there are multiple arguments, first is the canonical form, used for writing links but all are parsed.
</summary>
</member>
<member name="M:WebSharper.EndPointAttribute.#ctor(System.String)">
<summary>
 Indicates the URL fragments parsed by this class or union case.
</summary>
</member>
<member name="T:WebSharper.EndPointAttribute">
<summary>
 Indicates the URL fragment parsed by this class or union case.
</summary>
</member>
<member name="M:WebSharper.PrototypeAttribute.#ctor(System.Boolean)">
<summary>
 Prototype(true) is equivalent to Prototype().
 Prototype(false) forces to have no prototype, tranlating instance methods to static,
 usable only for sealed classes and F# unions and records.
</summary>
</member>
<member name="T:WebSharper.PrototypeAttribute">
<summary>
 Marks a type to be translated to have a prototype if it would not have one otherwise.
 This is needed if you want to do type checks in client code against it.
</summary>
</member>
<member name="M:WebSharper.JavaScriptExportAttribute.#ctor(System.Type)">
<summary>
 Specify a type to export in JavaScript.
 Use on assembly level.
</summary>
</member>
<member name="M:WebSharper.JavaScriptExportAttribute.#ctor(System.String)">
<summary>
 Specify a type full name or file name (without path) to export in JavaScript.
 Use on assembly level.
</summary>
</member>
<member name="T:WebSharper.JavaScriptExportAttribute">
<summary>
 Marks methods, properties and constructors for always including it in JavaScript output.
 Includes the effect of JavaSctipt attribute.
</summary>
</member>
<member name="T:WebSharper.SPAEntryPointAttribute">
<summary>
 Marks the entry point of a Single Page Application.
</summary>
</member>
<member name="M:WebSharper.DateTimeFormatAttribute.#ctor(System.String,System.String)">
<summary>
 Defines the format used to de/serialize the union case argument with the given name.
</summary>
</member>
<member name="M:WebSharper.DateTimeFormatAttribute.#ctor(System.String)">
<summary>
 Defines the format used to de/serialize a record or object field.
</summary>
</member>
<member name="T:WebSharper.DateTimeFormatAttribute">
<summary>
 Defines the format used to de/serialize a DateTime field or union case argument.
 The default is &quot;o&quot; (ISO 8601 round-trip format) for JSON serialization,
 and &quot;yyyy-MM-dd-HH.mm.ss&quot; for URL parsing.
</summary>
</member>
<member name="M:WebSharper.NamedUnionCasesAttribute.#ctor">
<summary>
 The case is inferred from the field names. Every case must have at least one
 non-option-typed field whose name is unique across all cases of this union.
</summary>
</member>
<member name="M:WebSharper.NamedUnionCasesAttribute.#ctor(System.String)">
<summary>
 The case is determined by a field named `discriminatorName`,
 which stores the CompiledName of the case.
</summary>
</member>
<member name="T:WebSharper.NamedUnionCasesAttribute">
<summary>
 Declares that when de/serializing this union type for external use
 (eg. when parsing a [&lt;Json&gt;] sitelet action or writing a Sitelet.Content.JsonContent),
 its fields must be tagged by their name rather than &quot;$0&quot; ... &quot;$n&quot;.
 Also determines how the cases are distinguished, instead of the default &quot;$&quot;: &lt;integer&gt;.
</summary>
</member>
<member name="T:WebSharper.OptionalFieldAttribute">
<summary>
 Adds automatic inlines to a property so that a missing JavaScript field
 is converted to None, otherwise Some fieldValue.
</summary>
</member>
<member name="T:WebSharper.RemotingProviderAttribute">
<summary>
 Indicates the client-side remoting provider that should be used
 by remote function calls in this assembly. The type passed to the
 constructor must have three static methods as described by the
 interface Remoting.IRemotingProvider.
</summary>
</member>
<member name="T:WebSharper.StubAttribute">
<summary>
 Marks members that should be compiled by-name.
</summary>
</member>
<member name="T:WebSharper.RequireAttribute">
<summary>
 Annotates members with dependencies. The type passed to the constructor
 must implement Resources.IResourceDefinition and a default constructor.
</summary>
</member>
<member name="T:WebSharper.RemoteAttribute">
<summary>
 Marks a server-side function to be invokable remotely from the client-side.
</summary>
</member>
<member name="M:WebSharper.ProxyAttribute.#ctor(System.String)">
<summary>
 Constructs a new proxy link using an assembly-qualified name.
</summary>
</member>
<member name="M:WebSharper.ProxyAttribute.#ctor(System.Type)">
<summary>
 Constructs a new proxy link using a type directly.
</summary>
</member>
<member name="T:WebSharper.ProxyAttribute">
<summary>
 Declares a type to be a proxy for another type, identified directly or
 by using an assembly-qualified name.
</summary>
</member>
<member name="M:WebSharper.NameAttribute.#ctor(System.String[])">
<summary>
 Constructs a qualified name from an explicit array of parts.
</summary>
</member>
<member name="M:WebSharper.NameAttribute.#ctor(System.Int32)">
<summary>
 Constructs an indexed field.
</summary>
</member>
<member name="M:WebSharper.NameAttribute.#ctor(System.String)">
<summary>
 Constructs a qualified name from a dot-separated string.
</summary>
</member>
<member name="T:WebSharper.NameAttribute">
<summary>
 Provides a runtime name for members when it differs from the F# name.
 The constructor accepts either an explicit array of parts,
 or a single string, in which case it is assumed to be dot-separated.
</summary>
</member>
<member name="T:WebSharper.GeneratedAttribute">
<summary>
 Annotates methods with a generator type that provides the method body.
 The supplied type should implement Macros.IGenerator and a default constructor.
</summary>
</member>
<member name="T:WebSharper.MacroAttribute">
<summary>
 Annotates methods an constructors with custom compilation rules.
 The supplied type should implement Macros.IMacro and a default constructor.
</summary>
</member>
<member name="M:WebSharper.JavaScriptAttribute.#ctor(System.Type)">
<summary>
 Specify a type to include in JavaScript compilation.
 Use on assembly level.
</summary>
</member>
<member name="M:WebSharper.JavaScriptAttribute.#ctor(System.String)">
<summary>
 Specify a type full name or file name (without path) to include in JavaScript compilation.
 Use on assembly level.
</summary>
</member>
<member name="M:WebSharper.JavaScriptAttribute.#ctor(System.Boolean)">
<summary>
 Use JavaScript(false) to exclude a type or member from JavaScript compilation scope.
</summary>
</member>
<member name="T:WebSharper.JavaScriptAttribute">
<summary>
 Marks methods, properties and constructors for compilation to JavaScript.
</summary>
</member>
<member name="T:WebSharper.WarnAttribute">
<summary>
 Adds a compiler warning whenever annotated member is used from client-side code.
</summary>
</member>
<member name="T:WebSharper.PureAttribute">
<summary>
 Marks methods and constructors as pure, so the call may be erased by optimizer
 or applied in different execution order. 
</summary>
</member>
<member name="F:WebSharper.DirectAttribute.UsingDollarVariables@">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="P:WebSharper.DirectAttribute.UsingDollarVariables(System.String)">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="P:WebSharper.DirectAttribute.UsingDollarVariables">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="T:WebSharper.DirectAttribute">
<summary>
 Marks methods and constructors for direct compilation to a JavaScript function.
 Direct members work by expanding JavaScript code templates
 with placeholders of the form such as $0, $x, $this or $value
 into the body of a JavaScript function. See also InlineAttribute.
</summary>
</member>
<member name="F:WebSharper.InlineAttribute.UsingDollarVariables@">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="P:WebSharper.InlineAttribute.UsingDollarVariables(System.String)">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="P:WebSharper.InlineAttribute.UsingDollarVariables">
<summary>
 Comma separated list of variable names starting with a dollar
 that are expected to be found in the inline JavaScript.
 Any variable name starting with a dollar that is neither
 in this list nor an argument raises a warning.
</summary>
</member>
<member name="T:WebSharper.InlineAttribute">
<summary>
 Marks methods and constructors for inline compilation to JavaScript.
 Inline members work by expanding JavaScript code templates
 with placeholders of the form such as $0, $x, $this or $value
 directly at the place of invocation. See also DirectAttribute.
</summary>
</member>
<member name="M:WebSharper.ConstantAttribute.#ctor(System.String)">
<summary>
 Constructs a string or a null constant annotation.
</summary>
</member>
<member name="M:WebSharper.ConstantAttribute.#ctor(System.Double)">
<summary>
 Constructs a floating constant annotation.
</summary>
</member>
<member name="M:WebSharper.ConstantAttribute.#ctor(System.Int32)">
<summary>
 Constructs an integer constant annotation.
</summary>
</member>
<member name="M:WebSharper.ConstantAttribute.#ctor(System.Boolean)">
<summary>
 Constructs a boolean constant annotation.
</summary>
</member>
<member name="T:WebSharper.ConstantAttribute">
<summary>
 Marks union cases or properties that should be compiled to constants.
</summary>
</member>
<member name="P:WebSharper.TypedJson.ServerSideProvider">
<summary>
 An instance of Json.Provider, used for custom JSON serialization on the server.
</summary>
</member>
<member name="M:WebSharper.TypedJson.Serialize``1(``0)">
<summary>
 Serializes an object to JSON using the same readable format as Sitelets.
 For plain JSON stringification, see Json.Stringify.
</summary>
</member>
<member name="M:WebSharper.TypedJson.Encode``1(``0)">
<summary>
 Encodes an object in such a way that JSON stringification
 results in the same readable format as Sitelets.
 Client-side only.
</summary>
</member>
<member name="M:WebSharper.TypedJson.Deserialize``1(System.String)">
<summary>
 Deserializes a JSON string using the same readable format as Sitelets.
 For plain JSON parsing, see Json.Parse.
</summary>
</member>
<member name="M:WebSharper.TypedJson.Decode``1(System.Object)">
<summary>
 Decodes an object parsed from the same readable JSON format as Sitelets.
 Client-side only.
</summary>
</member>
<member name="P:WebSharper.PathConventions.PathUtility.ScriptBasePath">
<summary>
 Base path for script URLs.
</summary>
</member>
<member name="P:WebSharper.PathConventions.PathUtility.ContentBasePath">
<summary>
 Base path for content URLs.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.VirtualPaths(System.String)">
<summary>
 Constructs a utiltiy object for computing URLs based on a given
 virtual path root (such as &apos;/&apos;).
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.TypeScriptDefinitionsPath(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.d.ts` TypeScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.TypeScriptDefinitionsFileName(WebSharper.PathConventions.AssemblyId)">
<summary>
 Filename for the `.d.ts` TypeScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MinifiedMapFilePath(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.min.map` source mapping file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MinifiedMapFileName(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.min.map` source mapping file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MinifiedJavaScriptPath(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.min.js` JavaScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MinifiedJavaScriptFileName(WebSharper.PathConventions.AssemblyId)">
<summary>
 Filename for the `.min.js` JavaScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MapFilePath(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.map` source mapping file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.MapFileName(WebSharper.PathConventions.AssemblyId)">
<summary>
 Filename for the `.map` source mapping file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.JavaScriptPath(WebSharper.PathConventions.AssemblyId)">
<summary>
 Path or URL to the `.js` JavaScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.JavaScriptFileName(WebSharper.PathConventions.AssemblyId)">
<summary>
 Filename for the `.js` JavaScript file corresponding to an assembly.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.FileSystem(System.String)">
<summary>
 Constructs a utiltiy object based on the physical path to the
 web root folder, which can be obtained by `Server.MapPath(&quot;~&quot;)`.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.EmbeddedResourceKey(WebSharper.PathConventions.EmbeddedResource)">
<summary>
 Key of embedded resource for looking up hash.
</summary>
</member>
<member name="M:WebSharper.PathConventions.PathUtility.EmbeddedPath(WebSharper.PathConventions.EmbeddedResource)">
<summary>
 Path or URL for the embedded resource.
</summary>
</member>
<member name="T:WebSharper.PathConventions.PathUtility">
<summary>
 Utility object for computing paths on the filesystem or relative URLs.
</summary>
</member>
<member name="M:WebSharper.PathConventions.EmbeddedResource.Create(WebSharper.PathConventions.ResourceKind,WebSharper.PathConventions.AssemblyId,System.String)">
<summary>
 Constructs a new embedded resource identifier.
</summary>
</member>
<member name="T:WebSharper.PathConventions.EmbeddedResource">
<summary>
 Represents embedded resources.
</summary>
</member>
<member name="P:WebSharper.PathConventions.ResourceKind.Script">
<summary>
 Script resources (primarily JavaScript).
</summary>
</member>
<member name="P:WebSharper.PathConventions.ResourceKind.Content">
<summary>
 Content resources (such as CSS stylesheet).
</summary>
</member>
<member name="T:WebSharper.PathConventions.ResourceKind">
<summary>
 Represents kinds of resources.
</summary>
</member>
<member name="M:WebSharper.PathConventions.AssemblyId.Create(System.Type)">
<summary>
 Creates an assembly identifier from a marker type.
</summary>
</member>
<member name="M:WebSharper.PathConventions.AssemblyId.Create(System.Reflection.AssemblyName)">
<summary>
 Creates an assembly identifier from a `System.Reflection` name.
</summary>
</member>
<member name="M:WebSharper.PathConventions.AssemblyId.Create(System.Reflection.Assembly)">
<summary>
 Creates an assembly identifier for the given assembly object.
</summary>
</member>
<member name="M:WebSharper.PathConventions.AssemblyId.Create(System.String)">
<summary>
 Creates an assembly identifier from a string representation.
</summary>
</member>
<member name="T:WebSharper.PathConventions.AssemblyId">
<summary>
 Identifies assemblies by name.
</summary>
</member>
<member name="T:WebSharper.PathConventions">
<summary>
 Makes resource path and naming conventions explicit to avoid code duplication.
</summary>
</member>
<member name="T:WebSharper.Core.Hashed`1">
<summary>
 A wrapper type for storing a computed hash for faster dictionary lookups
</summary>
</member>
<member name="T:WebSharper.Core.Generator">
<summary>
 An abstract base class for code generation used with GeneratedAttribute.
</summary>
</member>
<member name="T:WebSharper.Core.Generated">
<summary>
 Input for a Generate method on a generator
</summary>
</member>
<member name="T:WebSharper.Core.GeneratedMember">
<summary>
 The return type of Generate method of a generator 
</summary>
</member>
<member name="P:WebSharper.Core.Macro.NeedsTranslatedArguments">
<summary>
 Set this to true if compiler must translate the arguments to JavaScript expressions before calling TranslateCall or TranslateCtor.
 Default is false, ie. arguments are .NET expressions.
</summary>
</member>
<member name="M:WebSharper.Core.Macro.TranslateCtor(WebSharper.Core.MacroCtor)">
<summary>
 This method is invoked every time a call to a constructor annotated with this macro type is being translated.
</summary>
</member>
<member name="M:WebSharper.Core.Macro.TranslateCall(WebSharper.Core.MacroCall)">
<summary>
 This method is invoked every time a call to a method annotated with this macro type is being translated.
</summary>
</member>
<member name="T:WebSharper.Core.Macro">
<summary>
 An abstract base class for macro definitions used with MacroAttribute.
</summary>
</member>
<member name="T:WebSharper.Core.GeneratorResult">
<summary>
 Represents method bodies, at either JavaScript core or syntax level.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroUsedBoundVar">
<summary>
 Report that the macro has made use of the expression of an outside let binding
 which now can be removed
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroNeedsResolvedTypeArg">
<summary>
 Report that the macro needs concrete type information.
 Delays compilation of inlined calls until type resolution. 
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroFallback">
<summary>
 Revert to next in chain tranlation strategy for the call.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroDependencies">
<summary>
 Add code dependencies to the member containing the call for the macroed member.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroError">
<summary>
 Add a source error at the call point for macroed member.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroWarning">
<summary>
 Add a source warning at the call point for macroed member.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult.MacroOk">
<summary>
 An expression to inline at call point for macroed member.
 Can contain JavaScript and .NET level AST nodes.
</summary>
</member>
<member name="T:WebSharper.Core.MacroResult">
<summary>
 The return type of macro methods 
</summary>
</member>
<member name="T:WebSharper.Core.MacroCtor">
<summary>
 Input for a TranslateCtor method on a macro
</summary>
</member>
<member name="T:WebSharper.Core.MacroCall">
<summary>
 Input for a TranslateCall method on a macro
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.InvokeN(System.Object[])">
<summary>
 Invokes with an arbitrary number of arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke7(System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
<summary>
 Invokes with 7 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke6(System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
<summary>
 Invokes with 6 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke5(System.Object,System.Object,System.Object,System.Object,System.Object)">
<summary>
 Invokes with 5 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke4(System.Object,System.Object,System.Object,System.Object)">
<summary>
 Invokes with 4 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke3(System.Object,System.Object,System.Object)">
<summary>
 Invokes with 3 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke2(System.Object,System.Object)">
<summary>
 Invokes with 2 arguments.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke1(System.Object)">
<summary>
 Invokes with 1 argument.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.FastMethod.Invoke0">
<summary>
 Invokes with 0 arguments.
</summary>
</member>
<member name="T:WebSharper.Core.FastInvoke.FastMethod">
<summary>
 Represents a method that can be quickly invoked dynamically.
</summary>
</member>
<member name="M:WebSharper.Core.FastInvoke.Compile(System.Reflection.MethodInfo)">
<summary>
 Compiles a method to a fast invoke function.
</summary>
</member>
<member name="T:WebSharper.Core.FastInvoke">
<summary>
 Splits invocation of methods represented as `System.Reflection.MethodInfo`
 into the static and dynamic phase, doing the binding work at the static phase.
 A pre-bound method can be 100-1000x faster to invoke compared to using `.Invoke`
 every time, which has to repeatedly do method binding.
</summary>
</member>
<member name="T:WebSharper.Core.ContentTypes">
<summary>
 Provides a small vocabulary for dealing with Internet media types,
 as far as WebSharper is concerned.
</summary>
</member>
<member name="M:WebSharper.Core.Dict.tryFind``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 IDictionary.TryGetValue result converted to option
</summary>
</member>
<member name="M:WebSharper.Core.Dict.swap``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Swap the key and values of an IDictionary
</summary>
</member>
<member name="M:WebSharper.Core.Dict.unionDupl``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{``0,``1}})">
<summary>
 IDictionary union, allowing exact duplicates
</summary>
</member>
<member name="M:WebSharper.Core.Dict.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IDictionary{``2,``0})">
<summary>
 Map values of an IDictionary
</summary>
</member>
<member name="M:WebSharper.Core.Dict.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Filter an IDictionary
</summary>
</member>
<member name="M:WebSharper.Core.Dict.getFromMulti``2(System.Collections.Generic.IDictionary{``0,Microsoft.FSharp.Collections.FSharpList{``1}},``0)">
<summary>
 Get the list or an empty list from an IDictionary having a lists as values
</summary>
</member>
<member name="M:WebSharper.Core.Dict.addToMulti``2(System.Collections.Generic.IDictionary{``0,Microsoft.FSharp.Collections.FSharpList{``1}},``0,``1)">
<summary>
 Add or append item to an IDictionary having a lists as values
</summary>
</member>
<member name="M:WebSharper.Core.Dict.isEmpty``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Returns true if the dictionary has no elements
</summary>
</member>
<member name="T:WebSharper.Core.Dict">
<summary>
 Utility functions on IDictionary objects
</summary>
</member>
<member name="T:WebSharper.Core.FSharpExtensions">
<summary>
 Utility extensions of IDictionary and parsing value types
</summary>
</member>
<member name="M:WebSharper.Core.Binary.EncodingProvider.DeriveEncoding(System.Type)">
<summary>
 Derives an encoding for a given type.
</summary>
</member>
<member name="M:WebSharper.Core.Binary.EncodingProvider.Create">
<summary>
 Constructs a new EncodingProvider.
</summary>
</member>
<member name="T:WebSharper.Core.Binary.EncodingProvider">
<summary>
 Constructs Encoding objects.
</summary>
</member>
<member name="P:WebSharper.Core.Binary.Encoding.Type">
<summary>
 The type for which operations are supported.
</summary>
</member>
<member name="M:WebSharper.Core.Binary.Encoding.Encode(System.IO.Stream,System.Object,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Encodes an object to a stream.
</summary>
</member>
<member name="M:WebSharper.Core.Binary.Encoding.Decode(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Decodes an object from a stream.
</summary>
</member>
<member name="T:WebSharper.Core.Binary.Encoding">
<summary>
 Represents an encoding for a given type.
</summary>
</member>
<member name="T:WebSharper.Core.Binary.EncodingException">
<summary>
 Thrown when the decoder fails to reconstruct a value.
</summary>
</member>
<member name="T:WebSharper.Core.Binary.NoEncodingException">
<summary>
 Thrown when no decoder can be derived for a given type.
</summary>
</member>
<member name="T:WebSharper.Core.Binary">
<summary>
 Implements binary serialization for server-side use.
 The encoding supports all records, unions, numeric types,
 strings, rank-1 arrays, maps, sets, lists and dictionaries.
 Strings are interned for efficiency. The encoding also uses
 binary compression.
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.LocalTypeParameter">
<summary>
 used for F# inner generics
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.StaticTypeParameter">
<summary>
 used for F# statically resolved type parameters
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.VoidType">
<summary>
 Unified case for FSharp.Core.Unit and System.Void
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.ByRefType">
<summary>
 The type of a ref or out parameter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.FSharpFuncType">
<summary>
 Identifies the FSharp.Core.FSharpFunc type
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.TupleType">
<summary>
 A Sytem.Tuple type, type parameters are in a straight list
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.ArrayType">
<summary>
 An array with the specified number of dimensions
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.TypeParameter">
<summary>
 A class and method type parameters specified by index in the combined list
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type.ConcreteType">
<summary>
 A specific type not covered by other cases
</summary>
</member>
<member name="T:WebSharper.Core.AST.Type">
<summary>
 Identifies a type by shape
</summary>
</member>
<member name="T:WebSharper.Core.AST.Concrete`1">
<summary>
 Stores a definition and type parameter information
</summary>
</member>
<member name="T:WebSharper.Core.AST.TypeDefinitionInfo">
<summary>
 Identifies a type definition by AssemblyName and FullName
</summary>
</member>
<member name="T:WebSharper.Core.AST.SourcePos">
<summary>
 A range in original source code
</summary>
</member>
<member name="T:WebSharper.Core.AST.FuncArgOptimization">
<summary>
 Specifies a curried or tupled F# function argument that is translated to a flat function
</summary>
</member>
<member name="T:WebSharper.Core.AST.Id">
<summary>
 An identifier for a variable or label.
</summary>
</member>
<member name="T:WebSharper.Core.AST.StatementVisitor">
<summary>
 A visitor base class that skips expression forms
</summary>
</member>
<member name="T:WebSharper.Core.AST.StatementTransformer">
<summary>
 A transformer base class that skips expression forms
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitYield(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# &apos;yield return&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitWhile(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement)">
<summary>
 &apos;while&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitVarSet(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Variable set
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitVarDeclaration(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Variable declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitVar(WebSharper.Core.AST.Id)">
<summary>
 Gets the value of a variable
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitValue(WebSharper.Core.AST.Literal)">
<summary>
 Contains a literal value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitUnionCaseTest(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String)">
<summary>
 .NET - F# union case test
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitUnionCaseTag(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}})">
<summary>
 .NET - F# union case tag getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitUnionCaseGet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,System.String)">
<summary>
 .NET - F# union case field getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitUndefined">
<summary>
 JavaScript `undefined` value or `void` in .NET
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitUnary(WebSharper.Core.AST.UnaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Unary operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitTypeCheck(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Type)">
<summary>
 .NET - Type check, returns bool
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitTryWith(WebSharper.Core.AST.Statement,Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 &apos;try..with&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitTryFinally(WebSharper.Core.AST.Statement,WebSharper.Core.AST.Statement)">
<summary>
 &apos;try..finally&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitTraitCall(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Type},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Method call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitThrow(WebSharper.Core.AST.Expression)">
<summary>
 &apos;throw&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitThis">
<summary>
 The `this` value of current JavaScript function scope
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitSwitch(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Statement}})">
<summary>
 JavaScript &apos;switch&apos; expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitStatementSourcePos(WebSharper.Core.AST.SourcePos,WebSharper.Core.AST.Statement)">
<summary>
 Original source location for a statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitStatementExpr(WebSharper.Core.AST.Statement,Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitSequential(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Sequential evaluation of expressions, value is taken from the last
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitSelf">
<summary>
 Temporary - Refers to the class from a static method
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitReturn(WebSharper.Core.AST.Expression)">
<summary>
 Return a value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitRefOrOutParameter(WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# ref or out parameter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitOverrideName(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo},WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo})">
<summary>
 .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitOptimizedFSharpArg(WebSharper.Core.AST.Expression,WebSharper.Core.AST.FuncArgOptimization)">
<summary>
 Temporary - optimized curried or tupled F# function argument
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitObject(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,WebSharper.Core.AST.Expression}})">
<summary>
 JavaSript object
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNewVar(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 .NET - An expression-level variable declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNewUnionCase(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# union case constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNewRecord(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# record constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNewDelegate(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}})">
<summary>
 .NET - Creates a new delegate
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNewArray(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Creating a new array
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNew(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 JavaScript &apos;new&apos; call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitNamedParameter(System.Int32,WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# named parameter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitMutatingUnary(WebSharper.Core.AST.MutatingUnaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Unary operation mutating value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitMutatingBinary(WebSharper.Core.AST.Expression,WebSharper.Core.AST.MutatingBinaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Binary operation mutating right side
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitMatchSuccess(System.Int32,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# successful match
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitLetRec(Microsoft.FSharp.Collections.FSharpList{System.Tuple{WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression}},WebSharper.Core.AST.Expression)">
<summary>
 .NET - F# let rec
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitLet(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 .NET - An immutable value definition used only in expression body
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitLabeled(WebSharper.Core.AST.Id,WebSharper.Core.AST.Statement)">
<summary>
 Statement with a label
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitItemSet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Indexer set
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitItemGet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Purity)">
<summary>
 Indexer get without side effects
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitIf(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement,WebSharper.Core.AST.Statement)">
<summary>
 &apos;if&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitId(WebSharper.Core.AST.Id)">
<summary>
 Identifier for variable or label
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitHole(System.Int32)">
<summary>
 Temporary - A hole in an expression for inlining
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitGotoCase(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# &apos;goto case&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitGoto(WebSharper.Core.AST.Id)">
<summary>
 Temporary - C# &apos;goto&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitGlobalAccess(WebSharper.Core.Hashed{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 A global value by path, list is reversed
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFunction(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Function declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFuncWithThis(WebSharper.Core.AST.Id,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Temporary - Method of F# object expressions
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFuncDeclaration(WebSharper.Core.AST.Id,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Function declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitForIn(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement)">
<summary>
 JavaScript &apos;for .. in&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFor(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Statement)">
<summary>
 &apos;for&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFieldSet(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,WebSharper.Core.AST.Expression)">
<summary>
 .NET - Field setter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitFieldGet(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String)">
<summary>
 .NET - Field getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitExprStatement(WebSharper.Core.AST.Expression)">
<summary>
 Expression as statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitExprSourcePos(WebSharper.Core.AST.SourcePos,WebSharper.Core.AST.Expression)">
<summary>
 Original source location for an expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitEmpty">
<summary>
 Empty statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitDoWhile(WebSharper.Core.AST.Statement,WebSharper.Core.AST.Expression)">
<summary>
 &apos;do..while&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitDoNotReturn">
<summary>
 .NET - F# tail call position
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCurriedApplication(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - F# function application
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCtor(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.Hashed{WebSharper.Core.AST.ConstructorInfo},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Constructor call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCopyCtor(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo},WebSharper.Core.AST.Expression)">
<summary>
 .NET - Creating an object from a plain object
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitContinue(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 JavaScript continue statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitContinuation(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitConditional(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Conditional operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitComplexElement(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# complex element in initializer expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCoalesce(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Type,WebSharper.Core.AST.Expression)">
<summary>
 .NET - Null-coalescing
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCctor(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo})">
<summary>
 .NET - Static constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCallNeedingMoreArgs(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - Partial application, workaround for FCS issue #414
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCall(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Method call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitCSharpSwitch(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression}},WebSharper.Core.AST.Statement}})">
<summary>
 Temporary - C# &apos;switch&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitBreak(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 JavaScript break statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitBlock(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Statement})">
<summary>
 Block of statements
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitBinary(WebSharper.Core.AST.Expression,WebSharper.Core.AST.BinaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Binary operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitBaseCtor(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.Hashed{WebSharper.Core.AST.ConstructorInfo},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Base constructor call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitBase">
<summary>
 Temporary - Refers to the base class from an instance method
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitAwait(WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# await expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitArguments">
<summary>
 The `arguments` value of current JavaScript function scope
</summary>
</member>
<member name="M:WebSharper.Core.AST.Visitor.VisitApplication(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Purity,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
</summary>
</member>
<member name="T:WebSharper.Core.AST.Visitor">
<summary>
 Base class for code visitors.
 Provides virtual methods for visiting each AST case separately.
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformYield(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# &apos;yield return&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformWhile(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement)">
<summary>
 &apos;while&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformVarSet(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Variable set
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformVarDeclaration(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Variable declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformVar(WebSharper.Core.AST.Id)">
<summary>
 Gets the value of a variable
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformValue(WebSharper.Core.AST.Literal)">
<summary>
 Contains a literal value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformUnionCaseTest(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String)">
<summary>
 .NET - F# union case test
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformUnionCaseTag(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}})">
<summary>
 .NET - F# union case tag getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformUnionCaseGet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,System.String)">
<summary>
 .NET - F# union case field getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformUndefined">
<summary>
 JavaScript `undefined` value or `void` in .NET
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformUnary(WebSharper.Core.AST.UnaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Unary operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformTypeCheck(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Type)">
<summary>
 .NET - Type check, returns bool
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformTryWith(WebSharper.Core.AST.Statement,Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 &apos;try..with&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformTryFinally(WebSharper.Core.AST.Statement,WebSharper.Core.AST.Statement)">
<summary>
 &apos;try..finally&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformTraitCall(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Type},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Method call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformThrow(WebSharper.Core.AST.Expression)">
<summary>
 &apos;throw&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformThis">
<summary>
 The `this` value of current JavaScript function scope
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformSwitch(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Statement}})">
<summary>
 JavaScript &apos;switch&apos; expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformStatementSourcePos(WebSharper.Core.AST.SourcePos,WebSharper.Core.AST.Statement)">
<summary>
 Original source location for a statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformStatementExpr(WebSharper.Core.AST.Statement,Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformSequential(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Sequential evaluation of expressions, value is taken from the last
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformSelf">
<summary>
 Temporary - Refers to the class from a static method
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformReturn(WebSharper.Core.AST.Expression)">
<summary>
 Return a value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformRefOrOutParameter(WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# ref or out parameter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformOverrideName(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo},WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo})">
<summary>
 .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformOptimizedFSharpArg(WebSharper.Core.AST.Expression,WebSharper.Core.AST.FuncArgOptimization)">
<summary>
 Temporary - optimized curried or tupled F# function argument
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformObject(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,WebSharper.Core.AST.Expression}})">
<summary>
 JavaSript object
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNewVar(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 .NET - An expression-level variable declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNewUnionCase(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# union case constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNewRecord(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# record constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNewDelegate(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}})">
<summary>
 .NET - Creates a new delegate
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNewArray(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Creating a new array
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNew(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 JavaScript &apos;new&apos; call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformNamedParameter(System.Int32,WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# named parameter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformMutatingUnary(WebSharper.Core.AST.MutatingUnaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Unary operation mutating value
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformMutatingBinary(WebSharper.Core.AST.Expression,WebSharper.Core.AST.MutatingBinaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Binary operation mutating right side
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformMatchSuccess(System.Int32,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - F# successful match
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformLetRec(Microsoft.FSharp.Collections.FSharpList{System.Tuple{WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression}},WebSharper.Core.AST.Expression)">
<summary>
 .NET - F# let rec
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformLet(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 .NET - An immutable value definition used only in expression body
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformLabeled(WebSharper.Core.AST.Id,WebSharper.Core.AST.Statement)">
<summary>
 Statement with a label
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformItemSet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Indexer set
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformItemGet(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Purity)">
<summary>
 Indexer get without side effects
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformIf(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement,WebSharper.Core.AST.Statement)">
<summary>
 &apos;if&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformId(WebSharper.Core.AST.Id)">
<summary>
 Identifier for variable or label
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformHole(System.Int32)">
<summary>
 Temporary - A hole in an expression for inlining
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformGotoCase(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# &apos;goto case&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformGoto(WebSharper.Core.AST.Id)">
<summary>
 Temporary - C# &apos;goto&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformGlobalAccess(WebSharper.Core.Hashed{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 A global value by path, list is reversed
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFunction(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Function declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFuncWithThis(WebSharper.Core.AST.Id,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Temporary - Method of F# object expressions
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFuncDeclaration(WebSharper.Core.AST.Id,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Id},WebSharper.Core.AST.Statement)">
<summary>
 Function declaration
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformForIn(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Statement)">
<summary>
 JavaScript &apos;for .. in&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFor(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Statement)">
<summary>
 &apos;for&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFieldSet(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String,WebSharper.Core.AST.Expression)">
<summary>
 .NET - Field setter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformFieldGet(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},System.String)">
<summary>
 .NET - Field getter
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformExprStatement(WebSharper.Core.AST.Expression)">
<summary>
 Expression as statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformExprSourcePos(WebSharper.Core.AST.SourcePos,WebSharper.Core.AST.Expression)">
<summary>
 Original source location for an expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformEmpty">
<summary>
 Empty statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformDoWhile(WebSharper.Core.AST.Statement,WebSharper.Core.AST.Expression)">
<summary>
 &apos;do..while&apos; loop
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformDoNotReturn">
<summary>
 .NET - F# tail call position
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCurriedApplication(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - F# function application
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCtor(WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.Hashed{WebSharper.Core.AST.ConstructorInfo},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Constructor call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCopyCtor(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo},WebSharper.Core.AST.Expression)">
<summary>
 .NET - Creating an object from a plain object
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformContinue(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 JavaScript continue statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformContinuation(WebSharper.Core.AST.Id,WebSharper.Core.AST.Expression)">
<summary>
 Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformConditional(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Conditional operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformComplexElement(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - C# complex element in initializer expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCoalesce(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Type,WebSharper.Core.AST.Expression)">
<summary>
 .NET - Null-coalescing
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCctor(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo})">
<summary>
 .NET - Static constructor
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCallNeedingMoreArgs(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Temporary - Partial application, workaround for FCS issue #414
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCall(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.MethodInfo}},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Method call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformCSharpSwitch(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Expression}},WebSharper.Core.AST.Statement}})">
<summary>
 Temporary - C# &apos;switch&apos; statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformBreak(Microsoft.FSharp.Core.FSharpOption{WebSharper.Core.AST.Id})">
<summary>
 JavaScript break statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformBlock(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Statement})">
<summary>
 Block of statements
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformBinary(WebSharper.Core.AST.Expression,WebSharper.Core.AST.BinaryOperator,WebSharper.Core.AST.Expression)">
<summary>
 Binary operation
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformBaseCtor(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Concrete{WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo}},WebSharper.Core.Hashed{WebSharper.Core.AST.ConstructorInfo},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 .NET - Base constructor call
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformBase">
<summary>
 Temporary - Refers to the base class from an instance method
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformAwait(WebSharper.Core.AST.Expression)">
<summary>
 Temporary - C# await expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformArguments">
<summary>
 The `arguments` value of current JavaScript function scope
</summary>
</member>
<member name="M:WebSharper.Core.AST.Transformer.TransformApplication(WebSharper.Core.AST.Expression,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression},WebSharper.Core.AST.Purity,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
</summary>
</member>
<member name="T:WebSharper.Core.AST.Transformer">
<summary>
 Base class for code transformers.
 Provides virtual methods for transforming each AST case separately.
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.DoNotReturn">
<summary>
 .NET - F# tail call position
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.GotoCase">
<summary>
 Temporary - C# &apos;goto case&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.CSharpSwitch">
<summary>
 Temporary - C# &apos;switch&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Yield">
<summary>
 Temporary - C# &apos;yield return&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Continuation">
<summary>
 Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Goto">
<summary>
 Temporary - C# &apos;goto&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.StatementSourcePos">
<summary>
 Original source location for a statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Labeled">
<summary>
 Statement with a label
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.TryFinally">
<summary>
 &apos;try..finally&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.TryWith">
<summary>
 &apos;try..with&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Throw">
<summary>
 &apos;throw&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.If">
<summary>
 &apos;if&apos; statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Switch">
<summary>
 JavaScript &apos;switch&apos; expression
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.ForIn">
<summary>
 JavaScript &apos;for .. in&apos; loop
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.For">
<summary>
 &apos;for&apos; loop
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.DoWhile">
<summary>
 &apos;do..while&apos; loop
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.While">
<summary>
 &apos;while&apos; loop
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.FuncDeclaration">
<summary>
 Function declaration
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.VarDeclaration">
<summary>
 Variable declaration
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Block">
<summary>
 Block of statements
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Return">
<summary>
 Return a value
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.ExprStatement">
<summary>
 Expression as statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Continue">
<summary>
 JavaScript continue statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Break">
<summary>
 JavaScript break statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Statement.Empty">
<summary>
 Empty statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Hole">
<summary>
 Temporary - A hole in an expression for inlining
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.New">
<summary>
 JavaScript &apos;new&apos; call
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.GlobalAccess">
<summary>
 A global value by path, list is reversed
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Object">
<summary>
 JavaSript object
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.ComplexElement">
<summary>
 Temporary - C# complex element in initializer expression
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.RefOrOutParameter">
<summary>
 Temporary - C# ref or out parameter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NamedParameter">
<summary>
 Temporary - C# named parameter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Await">
<summary>
 Temporary - C# await expression
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.TraitCall">
<summary>
 .NET - Method call
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.MatchSuccess">
<summary>
 .NET - F# successful match
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.UnionCaseTag">
<summary>
 .NET - F# union case tag getter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.UnionCaseGet">
<summary>
 .NET - F# union case field getter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.UnionCaseTest">
<summary>
 .NET - F# union case test
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NewUnionCase">
<summary>
 .NET - F# union case constructor
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NewRecord">
<summary>
 .NET - F# record constructor
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.LetRec">
<summary>
 .NET - F# let rec
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.StatementExpr">
<summary>
 .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NewDelegate">
<summary>
 .NET - Creates a new delegate
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.OverrideName">
<summary>
 .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.TypeCheck">
<summary>
 .NET - Type check, returns bool
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Coalesce">
<summary>
 .NET - Null-coalescing
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NewVar">
<summary>
 .NET - An expression-level variable declaration
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Let">
<summary>
 .NET - An immutable value definition used only in expression body
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.FieldSet">
<summary>
 .NET - Field setter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.FieldGet">
<summary>
 .NET - Field getter
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Cctor">
<summary>
 .NET - Static constructor
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.CopyCtor">
<summary>
 .NET - Creating an object from a plain object
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.BaseCtor">
<summary>
 .NET - Base constructor call
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Ctor">
<summary>
 .NET - Constructor call
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.OptimizedFSharpArg">
<summary>
 Temporary - optimized curried or tupled F# function argument
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.CurriedApplication">
<summary>
 Temporary - F# function application
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.CallNeedingMoreArgs">
<summary>
 Temporary - Partial application, workaround for FCS issue #414
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Call">
<summary>
 .NET - Method call
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Base">
<summary>
 Temporary - Refers to the base class from an instance method
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Self">
<summary>
 Temporary - Refers to the class from a static method
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.FuncWithThis">
<summary>
 Temporary - Method of F# object expressions
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.ExprSourcePos">
<summary>
 Original source location for an expression
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.MutatingUnary">
<summary>
 Unary operation mutating value
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Unary">
<summary>
 Unary operation
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.MutatingBinary">
<summary>
 Binary operation mutating right side
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Binary">
<summary>
 Binary operation
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.ItemSet">
<summary>
 Indexer set
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.ItemGet">
<summary>
 Indexer get without side effects
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Conditional">
<summary>
 Conditional operation
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.NewArray">
<summary>
 Creating a new array
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Sequential">
<summary>
 Sequential evaluation of expressions, value is taken from the last
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.VarSet">
<summary>
 Variable set
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Function">
<summary>
 Function declaration
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Application">
<summary>
 Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Value">
<summary>
 Contains a literal value
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Var">
<summary>
 Gets the value of a variable
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Arguments">
<summary>
 The `arguments` value of current JavaScript function scope
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.This">
<summary>
 The `this` value of current JavaScript function scope
</summary>
</member>
<member name="T:WebSharper.Core.AST.Expression.Undefined">
<summary>
 JavaScript `undefined` value or `void` in .NET
</summary>
</member>
<member name="T:WebSharper.Core.AST.ASTHelpers.ReplaceIds">
<summary>
 Change every occurence of multiple Ids
</summary>
</member>
<member name="T:WebSharper.Core.AST.ASTHelpers.ReplaceId">
<summary>
 Change every occurence of one Id to another
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.|UnaryOpName|_|(System.String)">
<summary>
 recognizes .NET names for unary operators
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.|BinaryOpName|_|(System.String)">
<summary>
 recognizes .NET names for binary operators
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.SetRef(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Sets the value of a by-address value proxy
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.GetRef(WebSharper.Core.AST.Expression)">
<summary>
 Gets the value from a by-address value proxy
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.MakeRef(WebSharper.Core.AST.Expression,Microsoft.FSharp.Core.FSharpFunc{WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression})">
<summary>
 Make a proxy for a by-address value, having two functions for get/set.
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.Global(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Creates a GlobalAccess case from an access list in normal order
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.CombineExpressions(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Expression})">
<summary>
 Combines a list of AST.Expressions into a single AST.Expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.CombineStatements(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Statement})">
<summary>
 Combines a list of AST.Statements into a single AST.Statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.DefaultValueOf(WebSharper.Core.AST.Type)">
<summary>
 Creates a call to a macro that generates default value for type
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.ReadLiteral(System.Object)">
<summary>
 Creates an AST.Literal value from an object
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.WithSourcePosOfStatement(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Copies wrapping ExprSourcePos case if present to another AST.Statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.IgnoreStatementSourcePos(WebSharper.Core.AST.Statement)">
<summary>
 Removes wrapping ExprSourcePos case if present from an AST.Statement
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.WithSourcePosOfExpr(WebSharper.Core.AST.Expression,WebSharper.Core.AST.Expression)">
<summary>
 Copies wrapping ExprSourcePos case if present to another AST.Expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.IgnoreExprSourcePos(WebSharper.Core.AST.Expression)">
<summary>
 Removes wrapping ExprSourcePos case if present from an AST.Expression
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.DefaultGenericType(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo})">
<summary>
 Constructs a ConcreteType with fully unresolved generics for the type.
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.NonGenericType(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo})">
<summary>
 Constructs a ConcreteType case with empty type argument list
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.GenericType(WebSharper.Core.Hashed{WebSharper.Core.AST.TypeDefinitionInfo},Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Type})">
<summary>
 Constructs a ConcreteType case
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.NonGeneric``1(``0)">
<summary>
 Constructs a Concrete&lt;&apos;T&gt; instance with empty type argument list
</summary>
</member>
<member name="M:WebSharper.Core.AST.ASTHelpers.Generic``1(``0,Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.AST.Type})">
<summary>
 Constructs a Concrete&lt;&apos;T&gt; instance
</summary>
</member>
<member name="P:WebSharper.Core.Metadata.IClassInfo.Fields">
<summary>
 value: field info, is readonly
</summary>
</member>
<member name="T:WebSharper.Core.Resources.Runtime">
<summary>
 Represents the runtime library resource required by all WebSharper code.
</summary>
</member>
<member name="M:WebSharper.Core.Resources.BaseResource.#ctor(System.String,System.String,System.String[])">
<summary>
 References several external resources by specifying the
 absolute base URL and one or more relative URLs.
 The base URL is made configurable by consulting the application
 setting matching the full name of the declaring type.
 CSS resources are distinguished from JavaScript resources
 by checking for the .css syntax.
</summary>
</member>
<member name="M:WebSharper.Core.Resources.BaseResource.#ctor(System.String)">
<summary>
 References an embedded resource from he current assembly.
 The string represents either a reference to an embedded
 resource from the current assembly, or a (possibly relative)
 URL. CSS resources are distinguished from JavaScript resources by
 checking for the .css suffix.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.BaseResource">
<summary>
 A helper base class for resource-defining types.
</summary>
</member>
<member name="M:WebSharper.Core.Resources.IExternalScriptResource.Urls(WebSharper.Core.Resources.Context)">
<summary>
 Get the JavaScript script URL(s) for this resource.
 Can return an empty array if this is not a JavaScript resource.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.IExternalScriptResource">
<summary>
 An interface for resources whose JavaScript code, if any,
 is a sequence of external scripts with the given URLs.
</summary>
</member>
<member name="M:WebSharper.Core.Resources.IDownloadableResource.Unpack(System.String)">
<summary>
 Gets the WebSharper output root directory.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.IDownloadableResource">
<summary>
 An interface for resources to execute custom unpack.
</summary>
</member>
<member name="M:WebSharper.Core.Resources.IResource.Render(WebSharper.Core.Resources.Context)">
<summary>
 Renders the resource to a given TextWriter.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.IResource">
<summary>
 An interface for resource-defining types.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.ResourceDependencyCache">
<summary>
 Cache for resolved dependency lookups.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.RenderingCache">
<summary>
 Cache for resolved rendering of resources.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.WebRoot">
<summary>
 Gets the web application root URL. 
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.GetWebResourceRendering">
<summary>
 Constructs URLs to point to embedded resources.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.GetSetting">
<summary>
 Provides a configuration settings collection.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.GetAssemblyRendering">
<summary>
 Constructs URLs to JavaScript-compiled assemblies.
 Assembly names are short, such as FSharp.Core.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.ScriptBaseUrl">
<summary>
 Get the base URL path for WebSharper scripts.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.DefaultToHttp">
<summary>
 Transform foreign links to starting with `//` to `http://`.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.Context.DebuggingEnabled">
<summary>
 A flag indicating if debugging is enabled or not.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.Context">
<summary>
 Defines the context in which resources can be rendered.
</summary>
</member>
<member name="T:WebSharper.Core.Resources.Rendering">
<summary>
 Defines how to render a resource.
</summary>
</member>
<member name="P:WebSharper.Core.Resources.EmptyResource">
<summary>
 A resource value appending nothing.
</summary>
</member>
<member name="T:WebSharper.Core.Resources">
<summary>
 Manages resources, such as dependent JavaScript and CSS files.
</summary>
</member>
<member name="T:WebSharper.Core.Macros">
<summary>
 Defines macros used by proxy definitions.
</summary>
</member>
<member name="P:WebSharper.Core.DependencyGraph.Graph.Overrides">
<summary>
 Nested dictionary lookup order: TypeNode -&gt; AbstractMethodNode -&gt; ImplementationNode 
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.GetResourcesOf(System.Collections.Generic.IEnumerable{WebSharper.Core.Metadata.Node})">
<summary>
 Gets the resource nodes of a set of already explored graph nodes.
 Used for minimal bundling.
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.GetResources(System.Collections.Generic.IEnumerable{WebSharper.Core.Metadata.Node})">
<summary>
 Gets all resource class instances for a set of graph nodes.
 Resource nodes are ordered by graph edges, assembly nodes by assembly dependencies.
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.GetRequires(System.Collections.Generic.IEnumerable{WebSharper.Core.Metadata.Node})">
<summary>
 Get all resource nodes used by a graph node.
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.GetDependencies(System.Collections.Generic.IEnumerable{WebSharper.Core.Metadata.Node})">
<summary>
 Get all code dependencies unordered
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.FromData(System.Collections.Generic.IEnumerable{WebSharper.Core.Metadata.GraphData})">
<summary>
 Create a mutable graph from a sequence of parsed immutable graph data
</summary>
</member>
<member name="M:WebSharper.Core.DependencyGraph.Graph.FromData(WebSharper.Core.Metadata.GraphData)">
<summary>
 Create a mutable graph from parsed immutable graph data
</summary>
</member>
<member name="T:WebSharper.Core.DependencyGraph.Graph">
<summary>
 The compilation-time mutable representation of a code dependency graph
</summary>
</member>
<member name="T:WebSharper.Core.DependencyGraph.AssemblyResource">
<summary>
 A resource class for including the compiled .js for an assembly in Sitelets
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.Pack(WebSharper.Core.Json.Encoded)">
<summary>
 Packs an encoded value to JSON.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.GetEncoder``1">
<summary>
 Derives an encoder for a given type.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.GetEncoder(System.Type)">
<summary>
 Derives an encoder for a given type.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.GetDecoder``1">
<summary>
 Derives a decoder for a given type.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.GetDecoder(System.Type)">
<summary>
 Derives a decoder for a given type.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.CreateTyped(WebSharper.Core.Metadata.Info)">
<summary>
 Constructs a typed JSON encoding provider.
 This provider uses a WebSharper-specific encoding of types
 and is only suitable for internal uses.
 It is the encoding used for Remoting and Web.Control initialization.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.Create(WebSharper.Core.Json.FormatOptions)">
<summary>
 Constructs a basic JSON encoding provider.
 This provider uses an untyped encoding
 and is suitable for use with external APIs.
 It is the encoding used by Sitelets (Infer, JsonContent)
 and WebSharper.Json.Serialize/Deserialize.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Provider.Create">
<summary>
 Constructs a basic JSON encoding provider.
 This provider uses an untyped encoding
 and is suitable for use with external APIs.
 It is the encoding used by Sitelets (Infer, JsonContent)
 and WebSharper.Json.Serialize/Deserialize.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Provider">
<summary>
 Provides JSON encodings for arbitrary types.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Encoder`1">
<summary>
 Represents a typed encoder.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Encoder">
<summary>
 Represents an encoder.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Decoder`1">
<summary>
 Represents a typed decoder.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Decoder">
<summary>
 Represents a decoder.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Encoded.Object(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,WebSharper.Core.Json.Encoded}})">
<summary>
 Constructs an object.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Encoded.Lift(WebSharper.Core.Json.Value)">
<summary>
 Lifts a value.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Encoded.Array(Microsoft.FSharp.Collections.FSharpList{WebSharper.Core.Json.Encoded})">
<summary>
 Constructs an array.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Encoded">
<summary>
 Represents an object encoded to JSON.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Value">
<summary>
 Represents JSON values.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Stringify(WebSharper.Core.Json.Value)">
<summary>
 Converts JSON to a string. Throws WriteError.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Write(System.IO.TextWriter,WebSharper.Core.Json.Value)">
<summary>
 Writes raw JSON. Throws WriteError.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Parse(System.String)">
<summary>
 Parses a JSON string. Throws ReadError.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Read(System.IO.TextReader)">
<summary>
 Reads raw JSON. Throws ReadError.
</summary>
</member>
<member name="T:WebSharper.Core.Json.NoEncoderException">
<summary>
 Thrown when no encoder can be derived for a given type.
</summary>
</member>
<member name="T:WebSharper.Core.Json.NoDecoderException">
<summary>
 Thrown when no decoder can be derived for a given type.
</summary>
</member>
<member name="T:WebSharper.Core.Json.EncoderException">
<summary>
 Thrown when the encoder is given a value it cannot encode.
</summary>
</member>
<member name="T:WebSharper.Core.Json.DecoderException">
<summary>
 Thrown when the decoder fails to reconstruct a value from JSON.
</summary>
</member>
<member name="T:WebSharper.Core.Json.WriteException">
<summary>
 Thrown when the value being written is not valid JSON.
</summary>
</member>
<member name="T:WebSharper.Core.Json.ReadException">
<summary>
 Thrown when text being read from the text reader is not valid JSON.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Internal.GetUnionEncoding(System.Type)">
<summary>
 Get the encoding characteristics of a discriminated union.
 t is assumed to be a discriminated union.
</summary>
</member>
<member name="M:WebSharper.Core.Json.Internal.GetName``1(``0)">
<summary>
 Get the (potentially customized) name of a field or property.
</summary>
</member>
<member name="T:WebSharper.Core.Json.Internal">
<summary>
 Common functions about the JSON encoding.
</summary>
</member>
<member name="T:WebSharper.Core.Json">
<summary>
 Implements JSON encoding and decoding for client-server interaction.
</summary>
</member>
<member name="P:WebSharper.Core.Remoting.Server.JsonProvider">
<summary>
 Exposes the Json encoding/decoding provider
</summary>
</member>
<member name="M:WebSharper.Core.Remoting.Server.HandleRequest(WebSharper.Core.Remoting.Request)">
<summary>
 Handles a request.
</summary>
</member>
<member name="M:WebSharper.Core.Remoting.Server.Create(WebSharper.Core.Metadata.Info,WebSharper.Core.Json.Provider)">
<summary>
 Creates a new instance.
</summary>
</member>
<member name="T:WebSharper.Core.Remoting.Server">
<summary>
 Handles remote procedure call requests.
</summary>
</member>
<member name="T:WebSharper.Core.Remoting.Request">
<summary>
 Represents an incoming request.
</summary>
</member>
<member name="T:WebSharper.Core.Remoting.Headers">
<summary>
 Represents read-only access to HTTP headers.
</summary>
</member>
<member name="T:WebSharper.Core.Remoting.Response">
<summary>
 Represents the response.
</summary>
</member>
<member name="M:WebSharper.Core.Remoting.AddHandler(System.Type,System.Object)">
<summary>
 Adds an RPC handler object for a given remoting type.
 You can only add one instance for each type.
</summary>
</member>
<member name="M:WebSharper.Core.Remoting.IsRemotingRequest(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}})">
<summary>
 Tests if the given request is marked as a
 WebSharper remote procedure call request.
</summary>
</member>
<member name="T:WebSharper.Core.Remoting">
<summary>
 Implements server-side remote procedure call support.
</summary>
</member>
<member name="M:WebSharper.JavaScript.Function.Of``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Type cast.
 Warning: a tupled F# function is translated to JavaScript as a function with a single array argument.
</summary>
</member>
<member name="T:WebSharper.JavaScript.ClientSideOnly">
<summary>
 Thrown on the server when client-side code is being executed.
</summary>
</member>
<member name="M:WebSharper.JavaScript.Interop.X``1">
<summary>
 Specifies a value intended for client-side use only, so that there is no
 .NET implementation.
 Raises a WebSharper.JavaScript.ClientSideOnly exception.
</summary>
</member>
</members>
</doc>
