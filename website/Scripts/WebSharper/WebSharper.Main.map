{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Main/Promise.fs", "WebSharper.Main/JavaScript.Pervasives.fs", "WebSharper.Main/Json.fs", "WebSharper.Main/Remoting.fs", "WebSharper.Main/Html.fs", "WebSharper.Main/Comparers.fs", "WebSharper.Main/Utils.fs", "WebSharper.Main/Concurrency.fs", "WebSharper.Main/Enumerator.fs", "WebSharper.Main/CollectionInternals.fs", "WebSharper.Main/Object.fs", "WebSharper.Main/IntrinsicFunctions.fs", "WebSharper.Main/Array.fs", "WebSharper.Main/ArrayModule.fs", "WebSharper.Main/Array2DModule.fs", "WebSharper.Main/Async.fs", "WebSharper.Main/Char.fs", "WebSharper.Main/CommonExtensions.fs", "WebSharper.Main/DateTime.fs", "WebSharper.Main/Delegate.fs", "WebSharper.Main/Dictionary.fs", "WebSharper.Main/Exception.fs", "WebSharper.Main/ExtraTopLevelOperators.fs", "WebSharper.Main/Guid.fs", "WebSharper.Main/HashSet.fs", "WebSharper.Main/Interfaces.fs", "WebSharper.Main/LazyExtensions.fs", "WebSharper.Main/List.fs", "WebSharper.Main/ListModule.fs", "WebSharper.Main/Nullable.fs", "WebSharper.Main/Operators.fs", "WebSharper.Main/OperatorIntrinsics.fs", "WebSharper.Main/OptionModule.fs", "WebSharper.Main/Queue.fs", "WebSharper.Main/Random.fs", "WebSharper.Main/ResultModule.fs", "WebSharper.Main/RuntimeHelpers.fs", "WebSharper.Main/SeqModule.fs", "WebSharper.Main/Stack.fs", "WebSharper.Main/String.fs", "WebSharper.Main/Task.fs", "WebSharper.Main/Unchecked.fs", "WebSharper.Main/ValueOption.fs", "WebSharper.Main/Primitives.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.JavaScript\n\nopen System\nopen System.Runtime.CompilerServices\nopen System.Threading.Tasks\nopen WebSharper\n\n[<JavaScript>]\ntype NonStandardPromiseRejectionException(reason: obj) =\n    inherit Exception(\"Promise rejected\")\n\n    member this.Reason = reason\n\n[<JavaScript>]\nmodule Promise =\n\n    let private unwrapExn (x: obj) : exn =\n        match x with\n        | :? exn as e -> e\n        | x -> NonStandardPromiseRejectionException x :> exn\n\n    let OfAsync (a: Async<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            Async.StartWithContinuations(a, resolve, reject, reject)\n        )\n\n    let OfTask (t: Task<'T>) : Promise<'T> =\n        new Promise<'T>(fun (resolve, reject) ->\n            t.ContinueWith(fun (t: Task<'T>) ->\n                if t.IsCanceled then\n                    reject (TaskCanceledException())\n                elif t.IsFaulted then\n                    reject t.Exception\n                else // RanToCompletion\n                    resolve t.Result\n            )\n            |> ignore\n        )\n\n    let AsAsync (p: Promise<'T>) : Async<'T> =\n        Async.FromContinuations(fun (ok, ko, _) ->\n            p.Then(ok, fun (err: obj) ->\n                ko (unwrapExn err)\n            )\n            |> ignore\n        )\n\n    let AsTask (p: Promise<'T>) : Task<'T> =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n        p.Then(tcs.SetResult, fun (err: obj) ->\n            tcs.SetException(unwrapExn err)\n        )\n        |> ignore\n        tcs.Task\n\n    let private For (xs: seq<'T>) (f: 'T -> Promise<unit>) : Promise<unit> =\n        let e = xs.GetEnumerator()\n        let rec run() : Promise<unit> =\n            if e.MoveNext() then\n               (f e.Current).Then<unit>(run)\n            else\n                Promise.Resolve(())\n        // Call run() in a Promise rather than immediately,\n        // or .Finally wouldn't catch an exception when enumerating the first item.\n        Promise<unit>(fun (resolve, reject) -> resolve (unbox<unit>(run())))\n            .Finally(fun () -> e.Dispose())\n\n    type Builder [<Inline \"null\">] internal () =\n\n        [<Inline>]\n        member this.Bind(p: Promise<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            p.Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Async<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfAsync a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Bind(a: Task<'T>, f: 'T -> Promise<'U>) : Promise<'U> =\n            (OfTask a).Then<'U>(f)\n\n        [<Inline>]\n        member this.Return(x: 'T) : Promise<'T> =\n            Promise<'T>.Resolve(x)\n\n        [<Inline>]\n        member this.ReturnFrom(x: Promise<'T>) : Promise<'T> =\n            x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Async<'T>) : Promise<'T> =\n            OfAsync x\n\n        [<Inline>]\n        member this.ReturnFrom(x: Task<'T>) : Promise<'T> =\n            OfTask x\n\n        [<Inline>]\n        member this.Using(x: 'T when 'T :> IDisposable, f: 'T -> Promise<'U>) : Promise<'U> =\n            Promise(fun (resolve, reject) -> resolve (unbox<'U> (f x)))\n                .Finally(fun () -> x.Dispose())\n\n        [<Inline>]\n        member this.For(xs: seq<'T>, f: 'T -> Promise<unit>) : Promise<unit> =\n            For xs f\n\n        [<Inline>]\n        member this.Zero() : Promise<unit> =\n            Promise.Resolve(())\n\n        [<Inline>]\n        member this.Combine(p1: Promise<'T>, p2: Promise<'T>) : Promise<'T> =\n            p1.Then<'T>(fun _ -> p2)\n\n        [<Inline>]\n        member this.TryWith(p: Promise<'T>, f: exn -> Promise<'T>) : Promise<'T> =\n            p.Catch<'T>(unwrapExn >> f)\n\n        [<Inline>]\n        member this.TryFinally(p: Promise<'T>, f: unit -> unit) : Promise<'T> =\n            p.Finally(fun () -> f())\n\n        [<Inline>]\n        member this.Delay(f: unit -> Promise<'T>) : Promise<'T> =\n            Promise<'T>(fun (resolve, _) -> resolve (unbox<'T> (f())))\n\n    [<Inline>]\n    let Do = Builder()\n\n[<Extension; JavaScript>]\ntype PromiseExtensions =\n\n    [<Extension; Inline>]\n    static member AsAsync this = Promise.AsAsync this\n\n    [<Extension; Inline>]\n    static member AsTask this = Promise.AsTask this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfAsync this\n\n    [<Extension; Inline>]\n    static member AsPromise this = Promise.OfTask this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines operators and functions that are automatically available whenever\n/// `WebSharper` is open.\n[<AutoOpen>]\nmodule WebSharper.JavaScript.Pervasives\n\nopen WebSharper\nmodule M = WebSharper.Core.Macros\n\n/// Casts an object to the desired type.\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"$x * $y\">]\nlet ( *. ) x y = X<obj>\n\n[<Inline \"$x / $y\">]\nlet ( /. ) x y = X<obj>\n\n[<Inline \"$x % $y\">]\nlet ( %. ) x y = X<obj>\n\n[<Inline \"$x + $y\">]\nlet ( +. ) x y = X<obj>\n\n[<Inline \"$x - $y\">]\nlet ( -. ) x y = X<obj>\n\n[<Inline \"$x << $y\">]\nlet ( <<. ) x y = X<obj>\n\n[<Inline \"$x >> $y\">]\nlet ( >>. ) x y = X<obj>\n\n[<Inline \"$x >>> $y\">]\nlet ( >>>. ) x y = X<obj>\n\n[<Inline \"$x < $y\">]\nlet ( <. ) x y = X<bool>\n\n[<Inline \"$x > $y\">]\nlet ( >. ) x y = X<bool>\n\n[<Inline \"$x >= $y\">]\nlet ( >=. ) x y = X<bool>\n\n[<Inline \"$x <= $y\">]\nlet ( <=. ) x y = X<bool>\n\n[<Inline \"$x == $y\">]\nlet ( ==. ) x y = X<bool>\n\n[<Inline \"$x === $y\">]\nlet ( ===. ) x y = X<bool>\n\n[<Inline \"$x != $y\">]\nlet ( !=. ) x y = X<bool>\n\n[<Inline \"$x !== $y\">]\nlet ( !==. ) x y = X<bool>\n\n[<Inline \"$x | $y\">]\nlet ( |. ) x y = X<obj>\n\n[<Inline \"$x & $y\">]\nlet ( &. ) x y = X<obj>\n\n[<Inline \"$x ^ $y\">]\nlet ( ^. ) x y = X<obj>\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"[$x,$y]\">]\nlet ( => ) (x: string) (y: obj) = (x, y)\n\n[<JavaScript>]\nlet private NewFromSeq<'T> (fields: seq<string * obj>) : 'T =\n    let r = JS.Inline \"{}\"\n    for (k, v) in fields do\n        (?<-) r k v\n    As r\n\n/// Constructs a new object as if an object literal was used.\n[<Macro(typeof<M.New>); Inline>]\nlet New<'T> (fields: seq<string * obj>) = NewFromSeq<'T> fields\n\n/// Constructs an proxy to a remote object instance.\n[<Constant null>]\nlet Remote<'T> = X<'T>\n\n/// Gets JavaScript properties in sequence dynamically from an object.\n[<JavaScript; Macro(typeof<M.GetJS>)>]\nlet GetJS<'T> (x: obj) (items: seq<string>) =\n    let mutable x = x\n    for i in items do\n        x <- x?(i)\n    As<'T> x    \n\n/// Erases generic parameters inside this expression during WebSharper translation.\n/// You can get use this to translate `defaultof` inside a generic function.\n[<Macro(typeof<M.DefaultToUndefined>)>]\nlet DefaultToUndefined<'T> (x: 'T) = x\n\nmodule Optional =\n    /// Converts an F# option value to a JavaScript erased option\n    [<Inline>]\n    let ofOption x =\n        match x with\n        | None -> Undefined\n        | Some v -> Defined v\n\n    /// Converts a JavaScript erased option to an F# option value\n    [<Inline>]\n    let toOption x =\n        match x with\n        | Undefined -> None\n        | Defined v -> Some v\n\n    [<Inline \"$x !== undefined\">]\n    let isDefined x =\n        match x with\n        | Undefined -> false\n        | Defined _ -> true\n\n    [<Inline \"$x === undefined\">]\n    let isUndefined x =\n        match x with\n        | Undefined -> true\n        | Defined _ -> false\n\nmodule Union =\n// {{ generated by genInterop.fsx, do not modify\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice2 (x: Choice<'T1, 'T2>) = X<Union<'T1, 'T2>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice2 x =\n        match x with\n        | Union1Of2 v -> Choice1Of2 v\n        | Union2Of2 v -> Choice2Of2 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice3 (x: Choice<'T1, 'T2, 'T3>) = X<Union<'T1, 'T2, 'T3>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice3 x =\n        match x with\n        | Union1Of3 v -> Choice1Of3 v\n        | Union2Of3 v -> Choice2Of3 v\n        | Union3Of3 v -> Choice3Of3 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice4 (x: Choice<'T1, 'T2, 'T3, 'T4>) = X<Union<'T1, 'T2, 'T3, 'T4>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice4 x =\n        match x with\n        | Union1Of4 v -> Choice1Of4 v\n        | Union2Of4 v -> Choice2Of4 v\n        | Union3Of4 v -> Choice3Of4 v\n        | Union4Of4 v -> Choice4Of4 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice5 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice5 x =\n        match x with\n        | Union1Of5 v -> Choice1Of5 v\n        | Union2Of5 v -> Choice2Of5 v\n        | Union3Of5 v -> Choice3Of5 v\n        | Union4Of5 v -> Choice4Of5 v\n        | Union5Of5 v -> Choice5Of5 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice6 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice6 x =\n        match x with\n        | Union1Of6 v -> Choice1Of6 v\n        | Union2Of6 v -> Choice2Of6 v\n        | Union3Of6 v -> Choice3Of6 v\n        | Union4Of6 v -> Choice4Of6 v\n        | Union5Of6 v -> Choice5Of6 v\n        | Union6Of6 v -> Choice6Of6 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice7 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice7 x =\n        match x with\n        | Union1Of7 v -> Choice1Of7 v\n        | Union2Of7 v -> Choice2Of7 v\n        | Union3Of7 v -> Choice3Of7 v\n        | Union4Of7 v -> Choice4Of7 v\n        | Union5Of7 v -> Choice5Of7 v\n        | Union6Of7 v -> Choice6Of7 v\n        | Union7Of7 v -> Choice7Of7 v\n// }}\n\n/// The computation expression for JavaScript Promises.\n[<Inline>]\nlet promise = Promise.Builder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen WebSharper.JavaScript\nmodule Js = WebSharper.Core.Json\nmodule Re = WebSharper.Core.Resources\n\ntype Resource() =\n    interface Re.IResource with\n        member this.Render ctx =\n            let name = if ctx.DebuggingEnabled then \"Json.js\" else \"Json.min.js\"\n            let ren = Re.Rendering.GetWebResourceRendering(ctx, typeof<Resource>, name)\n            fun html ->\n                let html = html Re.Scripts\n                html.WriteLine \"<!--[if lte IE 7.0]>\"\n                ren.Emit(html, Re.Js)\n                html.WriteLine \"<![endif]-->\"\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"JSON.parse($json)\">]\n[<Require(typeof<Resource>)>]\nlet Parse (json: string) = X<obj>\n\n[<Inline \"JSON.stringify($obj)\">]\n[<Require(typeof<Resource>)>]\nlet Stringify (obj: obj) = X<string>\n\n/// Lookups an object by its FQN.\n[<JavaScript>]\nlet lookup<'T> (x: string []) : obj =\n    let k = x.Length\n    let mutable r = JS.Global\n    let mutable i = 0\n    while i < k do\n        let n  = x.[i]\n        let rn = (?) r n\n        if JS.TypeOf rn <> JS.Undefined then\n            r <- rn\n            i <- i + 1\n        else\n            failwith (\"Invalid server reply. Failed to find type: \" + n)\n    r\n\n/// Does a shallow generic mapping over an object.\n[<JavaScript>]\nlet shallowMap (f: obj -> obj) (x: obj) : obj =\n    if x :? System.Array then\n        As (Array.map f (As x))\n    else\n        match JS.TypeOf x with\n        | JS.Object ->\n            let r = New []\n            JS.ForEach x (fun y -> (?<-) r y (f ((?) x y)); false)\n            r\n        | _ ->\n            x\n\ntype SpecialTypes =\n    | List = 1\n    | Decimal = 2\n\n[<JavaScript>]\n[<Require(typeof<Resource>)>]\nlet Activate<'T> (json: obj) : 'T =\n    let types = if As json then json?(\"$TYPES\") : obj[] else JS.Undefined\n    let data =\n        if types ===. JS.Undefined then\n            json\n        else\n            for i = 0 to types.Length - 1 do\n                types.[i] <- \n                    match As<string[]> types.[i] with\n                    | [| \"WebSharper\"; \"List\"; \"T\" |] -> box SpecialTypes.List\n                    | [| \"WebSharper\"; \"Decimal\" |] -> box SpecialTypes.Decimal\n                    | t -> lookup t\n            json?(\"$DATA\")\n    let rec decode (x: obj) : obj =\n        if x = null then x else\n            match JS.TypeOf x with\n            | JS.Object ->\n                if x :? System.Array then\n                    shallowMap decode x\n                else\n                    let o  = shallowMap decode (x?(\"$V\"))\n                    let ti = x?(\"$T\")\n                    if ti ===. JS.Undefined then o else\n                        let t = types.[ti]\n                        if t ===. SpecialTypes.List then\n                            box (List.ofArray (As<obj[]> o))\n                        elif t ===. SpecialTypes.Decimal then\n                            box (JS.Global?WebSharper?Decimal?CreateDecimalBits(o))\n                        else\n                            let r = JS.New types.[ti]\n                            JS.ForEach o (fun k -> (?<-) r k ((?) o k); false)\n                            r\n            | _ ->\n                x\n    As (decode data)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Remoting\n\nopen WebSharper.JavaScript\n\nmodule R = WebSharper.Core.Remoting\n\n[<JavaScript>]\nlet mutable EndPoint = \"?\"\n\n[<JavaScript>]\nlet UseHttps() =\n    try\n        if not (JS.Window.Location.Href.StartsWith \"https://\") then\n            EndPoint <- JS.Window.Location.Href.Replace(\"http://\", \"https://\")\n            true\n        else false\n    with _ ->\n        // This function is intended to be callable from the top-level in a module,\n        // which means that it will be (unnecessarily) called on the server too\n        // and throw NotImplementedException. Just silence it.\n        false\n\ntype Data = string\ntype Headers = obj\ntype Url = string\n\n[<JavaScript>]\ntype IAjaxProvider =\n    [<Name \"Async\">]\n    abstract member Async : Url -> Headers -> Data -> (Data -> unit) -> (exn -> unit) -> unit\n\n    [<Name \"Sync\">]\n    abstract member Sync : Url -> Headers -> Data -> Data\n\n[<Direct @\"\n    var xhr = new XMLHttpRequest();\n    var csrf = document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*csrftoken\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1');\n    xhr.open('POST', $url, $async);\n    if ($async == true) {\n        xhr.withCredentials = true;\n    }\n    for (var h in $headers) {\n        xhr.setRequestHeader(h, $headers[h]);\n    }\n    if (csrf) {\n        xhr.setRequestHeader('x-csrftoken', csrf);\n    }\n    function k() {\n        if (xhr.status == 200) {\n            $ok(xhr.responseText)\n        } else if ($csrf && xhr.status == 403 && xhr.responseText == 'CSRF') {\n            $csrf();\n        } else {\n            var msg = 'Response status is not 200: ';\n            $err(new Error(msg + xhr.status));\n        }\n    }\n    if ('onload' in xhr) {\n        xhr.onload = xhr.onerror = xhr.onabort = k;\n    } else {\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                k();\n            }\n        };\n    }\n    xhr.send($data);\n\">]\nlet private ajax (async: bool) (url: Url) (headers: Headers) (data: Data)\n    (ok: Data -> unit) (err: exn -> unit) (csrf: unit -> unit) = ()\n\ntype XhrProvider [<JavaScript>] () =\n    interface IAjaxProvider with\n\n        [<JavaScript>]\n        member this.Async url headers data ok err =\n            ajax true url headers data ok err\n                (fun () -> ajax true url headers data ok err JS.Undefined)\n\n        [<JavaScript>]\n        member this.Sync url headers data =\n            let res = ref Unchecked.defaultof<_>\n            ajax false url headers data\n                (fun x -> res := x)\n                (fun e -> raise e)\n                (fun () ->\n                    ajax false url headers data\n                        (fun x -> res := x)\n                        (fun e -> raise e)\n                        JS.Undefined)\n            !res\n\n[<JavaScript>]\nlet mutable AjaxProvider = XhrProvider() :> IAjaxProvider\n\n[<JavaScript>]\nlet private makeHeaders (m: string) =\n    New [\n        \"content-type\" => \"application/json\"   \n        \"x-websharper-rpc\" => m\n    ]\n\n[<JavaScript>]\nlet private makePayload (data: obj []) =\n    Json.Stringify data\n\n[<JavaScript>]\ntype IRemotingProvider =\n    [<Name \"Sync\">]\n    abstract member Sync : string -> obj[] -> obj\n    [<Name \"Async\">]\n    abstract member Async : string -> obj[] -> Async<obj>\n    [<Name \"Task\">]\n    abstract member Task : string -> obj[] -> System.Threading.Tasks.Task<obj>\n    [<Name \"Send\">]\n    abstract member Send : string -> obj[] -> unit\n\n[<JavaScript>]\n[<Name \"WebSharper.Remoting.AjaxRemotingProvider\">]\ntype AjaxRemotingProvider() =\n    abstract EndPoint : string\n    override this.EndPoint = EndPoint\n\n    abstract AsyncBase : string * obj[] -> Async<obj> \n    override this.AsyncBase(m, data) = \n        async {\n            let headers = makeHeaders m\n            let payload = makePayload data\n            let! token = Async.CancellationToken\n            return! Async.FromContinuations (fun (ok, err, cc) ->\n                let waiting = ref true\n                let reg =\n                    token.Register(fun () ->\n                        if !waiting then\n                            waiting := false\n                            cc (new System.OperationCanceledException(token))\n                    )\n                let ok (x: Data) = \n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        ok (Json.Activate (Json.Parse x))\n                let err (e: exn) =\n                    if !waiting then\n                        waiting := false\n                        reg.Dispose()\n                        err e\n                AjaxProvider.Async this.EndPoint headers payload ok err)\n        }\n\n    interface IRemotingProvider with\n        member this.Sync m data : obj =\n            let data = AjaxProvider.Sync this.EndPoint (makeHeaders m) (makePayload data)\n            Json.Activate (Json.Parse data)\n\n        member this.Async m data : Async<obj> =\n            this.AsyncBase(m, data)\n\n        member this.Task m data : System.Threading.Tasks.Task<obj> =\n            this.AsyncBase(m, data) |> Async.StartAsTask   \n\n        member this.Send m data =\n            Async.Start (Async.Ignore (this.AsyncBase(m, data)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nmodule M = WebSharper.Core.Metadata\nmodule J = WebSharper.Core.Json\n\n/// An interface that has to be implemented by controls\n/// that depend on resources.\ntype IRequiresResources =\n    abstract member Requires : M.Info -> seq<M.Node>\n    abstract member Encode : M.Info * J.Provider -> list<string * J.Encoded>\n\n/// HTML content that can be used as the Body of a web Control.\n/// Can be zero, one or many DOM nodes.\ntype IControlBody =\n    /// Replace the given node with the HTML content.\n    /// The node is guaranteed to be present in the DOM.\n    /// Called exactly once on startup on an IControl's Body.\n    [<JavaScript; Name \"ReplaceInDom\">]\n    abstract ReplaceInDom : Dom.Node -> unit\n\n/// An interface that has to be implemented by controls that\n/// are subject to activation, ie. server-side controls that\n/// contain client-side elements.\ntype IControl =\n    inherit IRequiresResources\n    [<JavaScript; Name \"Body\">]\n    abstract member Body : IControlBody\n    abstract member Id : string\n\n[<AutoOpen>]\nmodule HtmlContentExtensions =\n\n    [<JavaScript>]\n    type private SingleNode(node: Dom.Node) =\n        interface IControlBody with\n            member this.ReplaceInDom(old) =\n                node.ParentNode.ReplaceChild(node, old) |> ignore\n\n    [<JavaScript>]\n    type IControlBody with\n        /// Create HTML content comprised of a single DOM node.\n        static member SingleNode (node: Dom.Node) =\n            new SingleNode(node) :> IControlBody\n\n[<JavaScript>]\nmodule Activator =\n\n    /// The identifier of the meta tag holding the controls.\n    [<Literal>]\n    let META_ID = \"websharper-data\"\n\n    let mutable Instances : obj = null\n\n    let private onReady (f: unit -> unit) =\n        let mutable readyFired = false\n        let rec ready() =\n            if not readyFired then\n                readyFired <- true\n                f()\n                JS.Document.RemoveEventListener(\"DOMContentLoaded\", ready, false)\n                JS.Window.RemoveEventListener(\"load\", ready, false)\n        if JS.Document?readyState = \"complete\" then\n            ready()\n        else\n            JS.Document.AddEventListener(\"DOMContentLoaded\", ready, false)\n            JS.Window.AddEventListener(\"load\", ready, false)\n\n    let private Activate() =\n        if As JS.Document then\n            let meta = JS.Document.GetElementById(META_ID)\n            if (As meta) then\n                onReady <| fun () ->\n                    let text = meta.GetAttribute(\"content\")\n                    let obj = Json.Activate (Json.Parse text)\n                    JS.GetFields obj\n                    |> Array.iter (fun (k, v) ->\n                        match v with\n                        | :? IControl as v ->\n                            let p = v.Body\n                            let old = JS.Document.GetElementById k\n                            p.ReplaceInDom old\n                        | _ -> ()\n                    )\n                    Instances <- obj\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Comparers\n\nopen WebSharper\n\n[<JavaScript>]\ntype private EquatableEqualityComparer<'T when 'T :> System.IEquatable<'T>>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = (x :> System.IEquatable<_>).Equals(y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private BaseEqualityComparer<'T>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = obj.Equals(box x, box y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private ComparableComparer<'T when 'T :> System.IComparable<'T>>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = (x :> System.IComparable<'T>).CompareTo(y)\n\n[<JavaScript>]\ntype private BaseComparer<'T when 'T : comparison>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = compare x y\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\nmodule private WebSharper.Utils\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nlet toSafe (s: string) =\n    if s ==. null then \"\" else s  \n\n[<JavaScript>]\nlet plusForPos (n: obj, s) =\n    if 0 <=. n then \"+\" + s else s     \n\n[<JavaScript>]\nlet spaceForPos (n: obj, s) =\n    if 0 <=. n then \" \" + s else s      \n\n[<Inline \"$s.substr(1)\">]\nlet skip1 (s: string) = X<string>\n\n[<JavaScript>]\nlet padNumLeft (s: string, l) =\n    let f = (As<string[]> s).[0]\n    if f = \" \" || f = \"+\" || f = \"-\" then\n        f + (skip1 s).PadLeft(l - 1, '0')\n    else s.PadLeft(l, '0')\n\n[<JavaScript>]\nlet printList (p: obj -> string, o: obj list) =\n    \"[\" + (o |> Seq.map p |> String.concat \"; \") + \"]\" \n\n[<JavaScript>]\nlet printArray (p: obj -> string, o: obj[]) =\n    if o ===. null then \"null\" else\n    \"[|\" + (o |> Array.map p |> String.concat \"; \") + \"|]\" \n\n[<JavaScript>]\nlet printArray2D (p: obj -> string, o: obj[,]) =\n    if o ===. null then \"null\" else\n     \"[[\" + (\n        seq {\n            let l2 = Array2D.length2 o\n            for i in 0 .. Array2D.length1 o - 1 ->\n                seq { for j in 0 .. l2 - 1 -> p o.[i, j] } \n                |> String.concat \"; \"\n        }\n        |> String.concat \"][\"\n     ) + \"]]\" \n\n[<JavaScript>]\nlet rec prettyPrint (o: obj) =\n    let printObject (o: obj) =\n        let s = string o\n        if s = \"[object Object]\" then\n            \"{\" + (JS.GetFields o |> Array.map (fun (k, v) -> k + \" = \" + prettyPrint v) |> String.concat \"; \") + \"}\"\n        else s\n    if o ===. null then \"null\" else\n    let t = JS.TypeOf o\n    if t  ==. JS.String then\n        \"\\\"\" + As o + \"\\\"\"\n    elif t  ==. JS.Object then\n        if o :? System.Array then\n            \"[|\" + (As o |> Array.map prettyPrint |> String.concat \"; \") + \"|]\"\n        else printObject o\n    else string o\n\n[<JavaScript>]\n[<Name \"WebSharper.Operators.charRange\">]\nlet charRange (min: char) (max: char) : seq<char> =\n    let minv = int min\n    let count = 1 + int max - minv\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> char (x + minv))\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.op\">]\nlet nullableOp (a: obj) (b: obj) f = if a ==. null || b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opL\">]\nlet nullableOpL (a: obj) (b: obj) f = if a ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opR\">]\nlet nullableOpR (a: obj) (b: obj) f = if b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmp\">]\nlet nullableCmp (a: obj) (b: obj) f = if a ==. null || b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpE\">]\nlet nullableCmpE (a: obj) (b: obj) f =\n    if a ==. null then\n        b ==. null\n    elif b ==. null then \n        false \n    else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpL\">]\nlet nullableCmpL (a: obj) (b: obj) f = if a ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpR\">]\nlet nullableCmpR (a: obj) (b: obj) f = if b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.conv\">]\nlet nullableConv (a: obj) f = if a ==. null then null else f a", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements concurrency primitives.\nmodule internal WebSharper.Concurrency\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype private OCE = System.OperationCanceledException\n\n[<JavaScript; Prototype false>]\ntype Result<'T> =\n    | Ok of 'T\n    | No of exn\n    | Cc of OCE\n  \n[<JavaScript; Prototype false>]\ntype CT =\n    { \n        [<Name \"c\">] mutable IsCancellationRequested : bool \n        [<Name \"r\">] Registrations : (unit -> unit)[]\n    }\n\n[<Inline \"$arr.push($item)\">]\nlet private push arr item = X<int>\n\n[<JavaScript>]\nlet internal noneCT =           \n    { \n        IsCancellationRequested = false\n        Registrations = [||]\n    }\n\n[<JavaScript>]\nlet internal Register (ct: CT) (callback: unit -> unit) =\n    if ct ===. noneCT then\n        { new System.IDisposable with\n            member this.Dispose() = ()\n        }\n    else\n        let i = push ct.Registrations callback - 1\n        { new System.IDisposable with\n            member this.Dispose() = ct.Registrations.[i] <- ignore\n        }\n\n[<JavaScript; Prototype false>]\ntype AsyncBody<'T> =\n    {\n        k  : Result<'T> -> unit\n        ct : CT\n    }\n\ntype Concurrent<'T>     = AsyncBody<'T> -> unit\nand private C<'T>       = Concurrent<'T>\n\ntype private Queue<'T>  = System.Collections.Generic.Queue<'T>\ntype Milliseconds       = int\n\ntype private Scheduler [<JavaScript>]() =\n    let mutable idle    = true\n    let robin           = Queue<unit->unit>()\n\n    [<JavaScript>]\n    let rec tick () =\n        let t = System.DateTime.Now\n        let mutable loop = true\n        while loop do\n            match robin.Count with\n            | 0 ->\n                idle <- true\n                loop <- false\n            | _ ->\n                robin.Dequeue()()\n                if System.DateTime.Now - t > System.TimeSpan.FromMilliseconds 40. then\n                    JS.SetTimeout tick 0 |> ignore\n                    loop <- false\n\n    [<JavaScript>]\n    member this.Fork(action: unit -> unit) =\n        robin.Enqueue action\n        if idle then\n            idle <- false\n            JS.SetTimeout tick 0 |> ignore\n\n[<JavaScript>]\nlet private scheduler = Scheduler()\n\n[<JavaScript>]\nlet internal defCTS = ref(new System.Threading.CancellationTokenSource())\n\n[<Inline>]\nlet fork action = scheduler.Fork action\n\n[<JavaScript>]\nlet private cancel c = c.k (Cc (new OCE(As<System.Threading.CancellationToken> c.ct)))\n\n[<JavaScript>]\nlet private checkCancel r =\n    ()\n    fun c -> if c.ct.IsCancellationRequested then cancel c else r c\n\n[<JavaScript; Pure>]\nlet Return (x: 'T) : C<'T> =\n    ()\n    fun c -> c.k (Ok x)\n\n[<JavaScript; Pure>]\nlet Zero =\n    Return ()\n\n[<JavaScript; Pure>]\nlet Bind (r: C<'T>, f: 'T -> C<'R>) =\n    checkCancel <| fun c ->\n        r { \n            k = function \n                | Ok x -> fork (fun () -> try f x c with e -> c.k (No e))\n                | res  -> fork (fun () -> c.k (As res)) // error or cancellation\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Combine (a: C<unit>, b: C<'T>) : C<'T> = \n    Bind (a, fun _ -> b)\n\n[<Inline>]\nlet Ignore (r: C<'T>): C<unit> = As<C<unit>> r\n\n[<JavaScript; Pure>]\nlet Delay (mk: unit -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        try mk () c with e -> c.k (No e)\n\n[<JavaScript; Pure>]\nlet TryFinally (run: C<'T>, f: unit -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = fun r -> \n                try f ()\n                    c.k r \n                with e -> c.k (No e)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet TryWith (r: C<'T>, f: exn -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        r {\n            k = function\n                | Ok x -> c.k (Ok x)\n                | No e as res -> try f e c with e -> c.k (As res)\n                | res -> c.k (As res)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Catch (r : C<'T>) : C<Choice<'T, exn>> =\n    ()\n    fun c ->\n        try r {\n                k = function \n                    | Ok x -> c.k (Ok (Choice1Of2 x))\n                    | No e -> c.k (Ok (Choice2Of2 e))\n                    | res  -> c.k (As res)\n                ct = c.ct\n            }\n        with e -> c.k (Ok (Choice2Of2 e))\n\n[<JavaScript; Pure>]\nlet GetCT : C<CT> =\n    ()\n    fun c -> c.k (Ok c.ct)\n\n[<JavaScript; Pure>]\nlet FromContinuations (subscribe: ('T -> unit) * (exn -> unit) * (OCE -> unit) -> unit) : C<'T> =\n    ()\n    fun c ->\n        let continued = ref false\n        let once cont : unit =\n            if !continued then failwith \"A continuation provided by Async.FromContinuations was invoked multiple times\" else\n            continued := true\n            fork cont   \n        subscribe (\n            fun a -> once (fun () -> c.k (Ok a))\n        ,   fun e -> once (fun () -> c.k (No e))\n        ,   fun e -> once (fun () -> c.k (Cc e))\n        )\n\n[<JavaScript>]\nlet StartWithContinuations (c: C<'T>, s: 'T -> unit, f: exn -> unit, cc: OCE -> unit, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | Ok x -> s x\n                | No e -> f e\n                | Cc e -> cc e\n            ct = ct\n        }\n\n[<JavaScript>]\nlet UncaughtAsyncError (e: exn) =\n    Console.Log (\"WebSharper: Uncaught asynchronous exception\", e)\n\n[<JavaScript>]\nlet Start (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    fork (fun () -> \n        if not ct.IsCancellationRequested then\n            c {\n                k = function\n                    | No e -> UncaughtAsyncError e\n                    | _ -> ()\n                ct = ct\n            }\n    )\n\n[<JavaScript>]\nlet StartImmediate (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | No e -> UncaughtAsyncError e\n                | _ -> ()\n            ct = ct\n        }\n\n#nowarn \"40\"\n\n[<JavaScript; Pure>]\nlet AwaitEvent (e: IEvent<'T>, ca: option<unit -> unit>) : C<'T> =\n    ()\n    fun c ->\n        let mutable sub = JS.Undefined<System.IDisposable>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        sub <-\n            e.Subscribe (fun x -> \n                sub.Dispose()\n                creg.Dispose()\n                fork (fun () -> c.k (Ok x))        \n            )\n        creg <-\n            Register c.ct (fun () -> \n                match ca with\n                | Some ca ->\n                    ca()\n                | _ ->\n                    sub.Dispose()\n                    fork (fun () -> cancel c)    \n            ) \n\n[<JavaScript; Pure>]\nlet AwaitTask (t: System.Threading.Tasks.Task) : C<unit> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun t ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok()   \n        ) |> ignore\n    )\n\n[<JavaScript; Pure>]\nlet AwaitTask1 (t: System.Threading.Tasks.Task<'T>) : C<'T> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun (t: System.Threading.Tasks.Task<'T>) ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok t.Result  \n        ) |> ignore\n    )\n\n[<JavaScript>]\nlet StartAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    fork (fun () ->\n        StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    )\n    tcs.Task\n\n[<JavaScript>]\nlet StartImmediateAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    tcs.Task\n\n[<JavaScript; Pure>]\nlet Sleep (ms: Milliseconds) : C<unit> =\n    ()\n    fun c ->\n        let mutable pending = JS.Undefined<JS.Handle>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        pending <-\n            JS.SetTimeout (fun () -> \n                creg.Dispose()\n                fork (fun () -> c.k (Ok ()))\n            ) ms\n        creg <-\n            Register c.ct (fun () -> \n                JS.ClearTimeout pending\n                fork (fun () -> cancel c)\n            )\n\n[<JavaScript; Pure>]\nlet Parallel (cs: seq<C<'T>>) : C<'T[]> =\n    let cs = Array.ofSeq cs\n    if cs.Length = 0 then Return [||] else\n    fun c ->\n        let n = Array.length cs\n        let o = ref n\n        let a = As<'T[]>(JavaScript.Array(n))\n        let accept i x =\n            match !o, x with\n            | 0, _     -> ()\n            | 1, Ok x  -> a.[i] <- x; o := 0; c.k (Ok a)\n            | n, Ok x  -> a.[i] <- x; o := n - 1\n            | n, res   -> o := 0; c.k (As res)\n        Array.iteri (fun i run ->\n            fork (fun () -> run { k = accept i; ct = c.ct }))\n            cs\n\n[<JavaScript; Pure>]\nlet StartChild (r : C<'T>, t: Milliseconds option) : C<C<'T>> =\n    ()\n    fun c ->\n        let inTime = ref true\n        let cached = ref None\n        let queue  = Queue()\n        let tReg =\n            match t with\n            | Some timeout ->\n                JS.SetTimeout (fun () ->\n                    inTime := false\n                    let err = No (System.TimeoutException())\n                    while queue.Count > 0 do\n                        queue.Dequeue() err\n                ) timeout |> Some     \n            | _ -> None\n        fork (fun _ ->\n            if not c.ct.IsCancellationRequested then\n                r {\n                    k = fun res ->\n                        if !inTime then\n                            cached := Some res\n                            match tReg with\n                            | Some r -> JS.ClearTimeout r\n                            | _ -> ()\n                            while queue.Count > 0 do\n                                queue.Dequeue() res\n                    ct = c.ct\n                }\n        )\n        let r2 c2 =            \n            if !inTime then\n                match cached.Value with\n                | Some x    -> c2.k x\n                | None      -> queue.Enqueue c2.k\n            else c2.k (No (System.TimeoutException()))\n        c.k (Ok r2)\n\n[<JavaScript>]\nlet StartChildAsTask (r : C<'T>) =\n    ()\n    fun c ->\n        let ch = StartChild(r, None)\n        ch {\n            k = function\n                | Ok r2 -> c.k (Ok (StartImmediateAsTask(r2, Some c.ct)))\n                | _ -> ()\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet OnCancel (action: unit -> unit) : C<System.IDisposable> =\n    ()\n    fun c -> c.k (Ok (Register c.ct action))\n\n[<JavaScript; Pure>]\nlet TryCancelled (run: C<'T>, comp: OCE -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = function\n                | Cc e as res ->\n                    comp e\n                    c.k res\n                | res -> c.k res\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Using (x: 'U, f: 'U -> C<'T>) =\n    TryFinally (f x, fun () -> (x :> System.IDisposable).Dispose())\n\n[<JavaScript; Pure>]\nlet rec While (g: unit -> bool, c: C<unit>) : C<unit> = \n    if g() then \n        Bind (c, fun () -> While (g, c)) \n    else\n        Return ()\n\n[<JavaScript; Pure>]\nlet rec For (s: seq<'T>, b: 'T -> C<unit>) =\n    Using (s.GetEnumerator(), fun ie -> \n        While ((fun () -> ie.MoveNext()), \n            Delay (fun () -> b ie.Current)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides an `IEnumerator` implementation.\nmodule private WebSharper.Enumerator\n\nopen WebSharper.JavaScript\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n/// Represents an unfolding enumerator.\n[<Sealed>]\ntype T<'S,'T> [<JavaScript>] (s: 'S, c: 'T, n: T<'S,'T> -> bool, d: T<'S,'T> -> unit) =\n    [<Inline; JavaScript>] \n    member this.MoveNext() = n this\n    member this.State with [<Inline; JavaScript>] get() = s and [<Inline; JavaScript>] set (v: 'S) = this?s <- v\n    member this.Current with [<Inline; JavaScript>] get() = c and [<Inline; JavaScript>] set (v: 'T) = this?c <- v\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = n this\n        [<JavaScript>]\n        member this.Current with get() = box c\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = c\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = if As d then d this\n\n/// Constructs a new `IEnumerator` by unfolding a function.\n[<Inline>]\n[<JavaScript>]\nlet New<'S,'T> (state: 'S) (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, As JS.Undefined)) \n\n[<Inline>]\n[<JavaScript>]\nlet NewDisposing<'S,'T> (state: 'S) dispose (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, dispose))\n\n[<Inline \"$x.GetEnumerator()\">]\nlet getEnumerator (x: obj) : IE<'T> = X\n\n[<JavaScript>]\nlet ArrayEnumerator (s: obj[]) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet StringEnumerator (s: string) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet Get (x: seq<'T>) : IE<'T> =\n    if x :? System.Array then\n        ArrayEnumerator (As x)\n    elif JS.TypeOf x = JS.String then\n        StringEnumerator (As x)\n    else\n        getEnumerator x\n\n[<Inline \"'GetEnumerator0' in $x ? $x.GetEnumerator0() : $x.GetEnumerator()\">]\nlet getEnumerator0 (x: obj) : System.Collections.IEnumerator = X\n\n[<JavaScript>]\nlet Get0 (x: System.Collections.IEnumerable) : System.Collections.IEnumerator =\n    if x :? System.Array then\n        As (ArrayEnumerator (As x))\n    elif JS.TypeOf x = JS.String then\n        As (StringEnumerator (As x))\n    else\n        getEnumerator0 x\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides seq/list/array proxies\n[<JavaScript>]\nmodule internal WebSharper.CollectionInternals\n\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Arrays.splitInto\">]\nlet ArraySplitInto count (arr: 'T[]) =\n    if count <= 0 then failwith \"Count must be positive\"\n    let len = arr.Length\n    if len = 0 then\n        [| |]\n    else\n        let count = min count len\n        let res = Array.zeroCreate count : 'T[][]\n        let minChunkSize = len / count\n        let mutable startIndex = 0\n        for i = 0 to len % count - 1 do\n            res.JS.[i] <- Array.sub arr startIndex (minChunkSize + 1)\n            startIndex <- startIndex + minChunkSize + 1\n        for i = len % count to count - 1 do\n            res.JS.[i] <-  Array.sub arr startIndex minChunkSize\n            startIndex <- startIndex + minChunkSize\n        res\n\n[<Name \"WebSharper.Arrays.contains\">]\nlet ArrayContains (item: 'T) (arr: 'T[])  =\n    let mutable c = true\n    let mutable i = 0\n    let l = arr.Length\n    while c && i < l do\n        if arr.JS.[i] = item then\n            c <- false\n        else\n            i <- i + 1\n    not c\n\n[<Name \"WebSharper.Arrays.tryFindBack\">]\nlet ArrayTryFindBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        let r = arr.JS.[i]\n        if f r then res <- Some r\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.tryFindIndexBack\">]\nlet ArrayTryFindIndexBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        if f arr.[i] then res <- Some i\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.mapFold\">]\nlet ArrayMapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) (zero: 'S) (arr: 'T[]) : 'R[] * 'S =\n    let r = JavaScript.Array(Array.length arr)\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        let a, b = f acc arr.JS.[i]\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapFoldBack\">]\nlet ArrayMapFoldBack<'T,'S,'R> (f: 'T -> 'S -> 'R * 'S) (arr: 'T[]) (zero: 'S) : 'R[] * 'S =\n    let r = JavaScript.Array<'R>(Array.length arr)\n    let mutable acc = zero\n    let len = Array.length arr\n    for j = 1 to len do\n        let i = len - j\n        let a, b = f arr.JS.[i] acc\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapInPlace\">]\nlet mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f arr.JS.[i])\n\n[<Name \"WebSharper.Arrays.mapiInPlace\">]\nlet mapiInPlace (f: int -> 'T1 -> 'T2) (arr: 'T1 []) : 'T2[] =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f i arr.JS.[i])\n    As arr\n\n[<Name \"WebSharper.Arrays.sortInPlaceByDescending\">]\nlet ArraySortInPlaceByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"WebSharper.Seq.tryHead\">]\nlet SeqTryHead (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryItem\">]\nlet SeqTryItem i (s: seq<'T>) =\n    if i < 0 then None else\n    let mutable j = 0\n    use e = Enumerator.Get s\n    let mutable go = true\n    while go && j <= i do\n        if e.MoveNext() then\n            j <- j + 1\n        else\n            go <- false\n    if go then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryLast\">]\nlet SeqTryLast (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then \n        while e.MoveNext() do ()\n        Some e.Current \n    else None\n\n[<Name \"WebSharper.Seq.chunkBySize\">]\nlet SeqChunkBySize (size: int) (s: seq<'T>) =\n    if size <= 0 then failwith \"Chunk size must be positive\"\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) <| fun e ->\n            if e.State && o.MoveNext() then\n                let res = [|o.Current|]\n                while e.State && res.Length < size do\n                    if o.MoveNext() then\n                        res.JS.Push o.Current |> ignore\n                    else \n                        e.State <- false\n                e.Current <- res\n                true\n            else false\n\n[<Name \"WebSharper.Arrays.countBy\">]\nlet ArrayCountBy (f: 'T -> 'K) (a: 'T[]) : ('K * int)[] =\n    let d = System.Collections.Generic.Dictionary<'K, int>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k] <- d.[k] + 1 \n        else\n            keys.Push(k) |> ignore\n            d.Add(k, 1)\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.except\">]\nlet SeqExcept (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet(itemsToExclude)\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"WebSharper.List.skip\">]\nlet ListSkip i (l : list<'T>) =\n    let mutable res = l\n    for j = 1 to i do\n        match res with \n        | _ :: t ->\n            res <- t\n        | [] -> failwith \"Input list too short.\"\n    res\n\n[<Name \"WebSharper.Arrays.groupBy\">]\nlet ArrayGroupBy (f: 'T -> 'K when 'K : equality) (a: 'T[]) : ('K * 'T[])[] =\n    let d = System.Collections.Generic.Dictionary<'K, 'T[]>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k].JS.Push(c) |> ignore\n        else\n            keys.Push(k) |> ignore\n            d.Add(k, [| c |])\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.insufficient\">]\nlet InsufficientElements() =\n    failwith \"The input sequence has an insufficient number of elements.\"\n\n[<Name \"WebSharper.Seq.last\">]\nlet SeqLast (s: seq<_>) =\n    use e = Enumerator.Get s\n    if not <| e.MoveNext() then InsufficientElements()\n    else \n        while e.MoveNext() do ()\n        e.Current\n\n[<Name \"WebSharper.Seq.contains\">]\nlet SeqContains (el: 'T) (s: seq<'T>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- e.Current = el\n    r\n\n[<Name \"WebSharper.List.skipWhile\">]\nlet rec ListSkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    let mutable rest = list\n    while not (List.isEmpty rest) && predicate (List.head rest) do\n        rest <- List.tail rest \n    rest\n\n[<Name \"WebSharper.Seq.nonNegative\">]\nlet InputMustBeNonNegative() =\n    failwith \"The input must be non-negative.\"\n\n[<Name \"WebSharper.Arrays.transposeArray\">]\nlet ArrayTranspose (array:'T[][]) : 'T[][] =\n    let len = array.Length\n    if len = 0 then [||] else\n    let lenInner = array.[0].Length\n\n    for j in 1..len-1 do\n        if lenInner <> array.[j].Length then\n            failwith \"The arrays have different lengths.\"\n\n    let result = Array lenInner\n    for i in 0..lenInner-1 do\n        result.[i] <- Array len\n        for j in 0..len-1 do\n            result.[i].[j] <- array.[j].[i]\n    As result", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\n#nowarn \"864\"\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.Object>)>]\n[<Name \"WebSharper.Obj\">]\ntype private ObjectProxy() =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Name \"GetHashCode\">]\n    member this.GetHashCodeImpl() = -1\n\n    [<Name \"Equals\">]\n    member this.EqualsImpl(obj: obj) = this ===. obj\n\n    [<Inline>]\n    static member Equals(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member ReferenceEquals(a: obj, b: obj) = a ===. b\n\n    [<Inline>]\n    static member op_Equality(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member op_Inequality(a: obj, b: obj) = not (Unchecked.equals a b)\n\n    [<Inline>]\n    override this.ToString() = string this\n\n[<Proxy(typeof<System.ValueType>)>]\ntype private ValueTypeProxy =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Inline>]\n    override this.ToString() = string this", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.IntrinsicFunctionProxy\n\nopen System\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$value\">]\nlet UnboxGeneric<'T> (value: obj) = X<'T>\n\n[<Inline \"$value\">]\nlet UnboxFast<'T> (value: obj) = X<'T>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestGeneric<'T> (value: obj) = X<bool>\n\n[<Macro(typeof<M.TypeTest>)>]\nlet TypeTestFast<'T> (value: obj) = X<bool>\n\n[<Inline \"$arr.length\">]\nlet GetArray2DLength1 (arr: 'T[,]) = X<int>\n\n[<Inline \"$arr.length ? $arr[0].length : 0\">]\nlet GetArray2DLength2 (arr: 'T[,]) =  X<int>\n\n[<Name \"WebSharper.Arrays.checkBounds\">]\nlet checkBounds (arr: 'T[]) (n: int) =\n    if n < 0 || n >= Array.length arr then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Name \"WebSharper.Arrays.checkBounds2D\">]\nlet checkBounds2D<'T> (arr: 'T[,]) (n1: int) (n2: int) =\n    if n1 < 0 || n2 < 0 || n1 >= GetArray2DLength1 arr\n        || n2 >= GetArray2DLength2 arr then\n        raise (new IndexOutOfRangeException())\n\n[<Name \"WebSharper.Arrays.checkRange\">]\n\nlet checkRange (arr: 'T []) (start: int) (size: int) : unit =\n    if (size < 0) || (start < 0) || (Array.length arr < start + size) then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Inline \"$arr[$n]\">]\nlet GetArrayInternal<'T> (arr: 'T[]) (n:int) = X<'T>\n\n[<Inline \"void ($arr[$n] = $x)\">]\nlet SetArrayInternal<'T> (arr: 'T[]) (n:int) (x:'T) = ()\n\n[<Name \"WebSharper.Arrays.set\">]\nlet SetArray<'T> (arr: 'T[]) (n: int) (x: 'T) =\n    checkBounds arr n\n    SetArrayInternal arr n x\n\n[<Inline \"$s[$ix]\">]\n[<Name \"WebSharper.Strings.get\">]\nlet GetString (s: string) (ix: int) = X<char>\n\n[<Name \"WebSharper.Arrays.get\">]\nlet GetArray<'T> (arr: 'T[]) (n: int) =\n    checkBounds arr n\n    GetArrayInternal arr n\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Name \"WebSharper.Arrays.sub\">]\nlet GetArraySub<'T> (arr: 'T[]) start length =\n    checkRange arr start length\n    subArray arr start length\n\n[<Name \"WebSharper.Arrays.setSub\" >]\nlet SetArraySub<'T> (arr: 'T[]) start len (src: 'T[]) =\n    for i = 0 to len - 1 do\n        arr.[start+i] <- src.[i]\n\n[<Inline \"$arr[$n1][$n2]\">]\nlet GetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) = X<'T>\n\n[<Name \"WebSharper.Arrays.get2D\" >]\nlet GetArray2D (arr: 'T[,]) (n1: int) (n2: int) =\n    checkBounds2D arr n1 n2\n    GetArray2DInternal arr n1 n2\n\n[<Inline \"void ($arr[$n1][$n2] = $x)\">]\nlet SetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) (x:'T) = ()\n\n\n[<Name \"WebSharper.Arrays.set2D\" >]\nlet SetArray2D (arr: 'T[,]) (n1: int) (n2: int) (x: 'T) =\n    checkBounds2D arr n1 n2\n    SetArray2DInternal arr n1 n2 x\n\n[<Name \"WebSharper.Arrays.zeroCreate2D\" >]\nlet Array2DZeroCreate<'T> (n:int) (m:int) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.zeroCreate m))\n    arr?dims <- 2\n    arr\n\n[<Name \"WebSharper.Arrays.sub2D\" >]\nlet GetArray2DSub<'T> (src: 'T[,]) src1 src2 len1 len2 =\n    let len1 = (if len1 < 0 then 0 else len1)\n    let len2 = (if len2 < 0 then 0 else len2)\n    let dst = Array2DZeroCreate len1 len2\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[i,j] <- src.[src1 + i, src2 + j]\n    dst\n\n[<Name \"WebSharper.Arrays.setSub2D\" >]\nlet SetArray2DSub<'T> (dst: 'T[,]) src1 src2 len1 len2 (src: 'T[,]) =\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[src1+i, src2+j] <- src.[i, j]\n\n[<Name \"WebSharper.Arrays.length\" >]\nlet GetLength<'T> (arr: System.Array) =\n    match arr?dims with\n    | 2 -> GetArray2DLength1 (As arr) * GetArray2DLength1 (As arr)\n    | _ -> Array.length (As arr)\n\n[<Name \"WebSharper.checkThis\">]\nlet CheckThis (this: 'T) =\n    if this = null then\n        invalidOp \"The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.\"\n    else this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\ntype private IComparer = System.Collections.IComparer\ntype private IComparer<'T> = System.Collections.Generic.IComparer<'T>\ntype private JSArray<'T> = WebSharper.JavaScript.Array<'T>\ntype private Comparer<'T> = System.Collections.Generic.Comparer<'T>\n\n[<AutoOpen; JavaScript>]\nmodule ArrayProxy =\n\n    [<Name \"WebSharper.Arrays.binarySearch\">]\n    let binarySearch (haystack: 'T[]) (comparer: 'T -> int) start finish =\n        if start < 0 then raise (ArgumentOutOfRangeException(\"index\", \"Non-negative number required.\"))\n        if finish > haystack.Length then raise (ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\"))\n        if finish < start then raise (ArgumentOutOfRangeException(\"length\", \"Non-negative number required.\"))\n        let rec search left right =\n            if left > right then\n                ~~~left\n            else\n                let pivot = (left + right) / 2\n                let cmp = comparer haystack.[pivot]\n                if left = right then\n                    if cmp = 0 then left\n                    elif cmp > 0 then ~~~(left + 1)\n                    else ~~~left\n                elif cmp <= 0 then\n                    search left pivot\n                else\n                    search (pivot + 1) right\n        search start (finish - 1)\n\n    [<Name \"WebSharper.Arrays.binarySearchComparer\">]\n    let objBinarySearchComparer (needle: obj) =\n       // Check for an implementation of IComparable\n       if needle?CompareTo0 then\n           As<IComparable>(needle).CompareTo\n       else\n           fun x ->\n               if x?CompareTo0 then\n                   -As<IComparable>(x).CompareTo(needle)\n               else\n                   InvalidOperationException(\n                       \"Failed to compare two elements in the array.\",\n                       ArgumentException(\"At least one object must implement IComparable.\"))\n                   |> raise\n\n    [<Name \"WebSharper.Arrays.sortInternal\">]\n    let sortInternal (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) (swap: int -> int -> unit) : unit =\n        let partition l r =\n            let pivot = keys.JS.[r]\n            let mutable i = l - 1\n            for j = l to r - 1 do\n                if comp(keys.JS.[j], pivot) < 0 then\n                    i <- i + 1\n                    swap i j\n            if comp(keys.JS.[r], keys.JS.[i + 1]) < 0 then\n                swap (i + 1) r\n            i + 1\n        let rec quicksort l r =\n            if l < r then\n                let p = partition l r\n                quicksort l (p - 1)\n                quicksort (p + 1) r\n        quicksort index (index + length - 1)\n\n    [<Name \"WebSharper.Arrays.sortSub\">]\n    let sortSub (keys: 'K[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n        sortInternal keys index length comp swap\n\n    [<Name \"WebSharper.Arrays.sortByKeys\">]\n    let sortByKeys (keys: 'K[]) (items: 'V[]) (index: int) (length: int) (comp: 'K * 'K -> int) : unit =\n        let swap i j =\n            let k = keys.JS.[i]\n            keys.JS.[i] <- keys.JS.[j]\n            keys.JS.[j] <- k\n            let v = items.JS.[i]\n            items.JS.[i] <- items.JS.[j]\n            items.JS.[j] <- v\n        sortInternal keys index length comp swap\n\n[<Proxy(typeof<System.Array>)>]\ntype private ArrayProxy =\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj) : int =\n        binarySearch (As<obj[]> haystack) (objBinarySearchComparer needle) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch(haystack: System.Array, start: int, length: int, needle: obj, comparer: IComparer) : int =\n        binarySearch (As<obj[]> haystack) (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T) : int =\n        let compare y = compare (As<IComparable> needle) (As<IComparable> y)\n        binarySearch haystack compare start (start + length)\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) 0 haystack.Length\n\n    [<Inline>]\n    static member BinarySearch<'T>(haystack: 'T[], start: int, length: int, needle: 'T, comparer: IComparer<'T>) : int =\n        binarySearch haystack (fun o -> comparer.Compare(needle, o)) start (start + length)\n\n    [<Name \"WebSharper.Arrays.clear\">]\n    static member Clear(array: System.Array, index: int, length: int) : unit =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if index < 0 || length < 0 || index + length > array.Length then raise (IndexOutOfRangeException())\n        for i = index to index + length - 1 do\n            (As<JSArray<obj>> array).[i] <-\n                match JS.TypeOf (As<JSArray<obj>> array).[i] with\n                | JS.Number -> box 0\n                | _ -> null\n\n    [<Inline>]\n    member this.Clone() =\n        Array.copy (As<obj[]> this) :> obj\n\n    [<Name \"WebSharper.Arrays.constrainedCopy\">]\n    static member ConstrainedCopy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        if src ===. dst && dstIndex <= srcIndex + length then\n            let tmp = Array.init length (fun i -> (As<obj[]> src).[srcIndex + i])\n            Array.blit tmp 0 (As<obj[]> dst) dstIndex length\n        else\n            Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    static member Copy(src: System.Array, srcIndex: int, dst: System.Array, dstIndex: int, length: int) =\n        Array.blit (As<obj[]> src) srcIndex (As<obj[]> dst) dstIndex length\n\n    [<Inline>]\n    member this.CopyTo(dst: System.Array, index: int) =\n        if this.Length + index < dst.Length then raise (ArgumentException(\"array\"))\n        Array.blit (As<obj[]> this) 0 (As<obj[]> dst) index this.Length\n\n    [<Inline>]\n    static member Copy(src: System.Array, dst: System.Array, length: int) =\n        Array.blit (As<obj[]> src) 0 (As<obj[]> dst) 0 length\n\n    [<Inline>]\n    static member ConvertAll<'T, 'U>(array: 'T[], converter: Converter<'T, 'U>) : 'U[] =\n        Array.map converter.Invoke array\n\n    [<Inline>]\n    static member Empty<'T>() : 'T[] =\n        Array.empty\n\n    [<Inline>]\n    static member Exists<'T>(array: 'T[], predicate: Predicate<'T>) : bool =\n        Array.exists predicate.Invoke array\n\n    [<Inline>]\n    static member Find<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFind predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    static member FindAll<'T>(array: 'T[], predicate: Predicate<'T>) : 'T[] =\n        Array.filter predicate.Invoke array\n\n    [<Name \"WebSharper.Arrays.findIndexBound\">]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f finish i =\n            if i = finish then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f finish (i + 1)\n        f (startIndex + count) startIndex\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member FindLast<'T>(array: 'T[], predicate: Predicate<'T>) : 'T =\n        defaultArg (Array.tryFindBack predicate.Invoke array) Unchecked.defaultof<'T>\n\n    [<Name \"WebSharper.Arrays.findLastIndexBound\">]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, count: int, predicate: Predicate<'T>) : int =\n        if isNull array then raise (ArgumentNullException(\"array\"))\n        if isNull predicate then raise (ArgumentNullException(\"match\"))\n        if startIndex < 0 then raise (ArgumentOutOfRangeException(\"startIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\"))\n        if count < 0 || startIndex + count > array.Length then raise (ArgumentOutOfRangeException(\"count\", \"Count must be positive and count must refer to a location within the string/array/collection.\"))\n        let rec f i =\n            if i < startIndex then\n                -1\n            elif predicate.Invoke(array.[i]) then\n                i\n            else\n                f (i - 1)\n        f (startIndex + count - 1)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], startIndex: int, predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, startIndex, array.Length - startIndex, predicate)\n\n    [<Inline>]\n    static member FindLastIndex<'T>(array: 'T[], predicate: Predicate<'T>) : int =\n        System.Array.FindLastIndex<'T>(array, 0, array.Length, predicate)\n\n    [<Inline>]\n    static member ForEach<'T>(array: 'T[], action: Action<'T>) : unit =\n        Array.iter action.Invoke array\n\n    [<Inline>]\n    member this.GetValue(i: int) =\n        (As<obj[]> this).[i]\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member IndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf(haystack: System.Array, needle: obj) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(As<obj[]> haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int, count:  int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, count, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T, startIndex: int) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, startIndex, Predicate(predicate))\n\n    [<Inline>]\n    static member LastIndexOf<'T when 'T : null and 'T : equality>(haystack: 'T[], needle: 'T) : int =\n        let predicate = if isNull needle then isNull else needle.Equals\n        System.Array.FindLastIndex(haystack, Predicate(predicate))\n\n    [<Inline>]\n    static member Resize<'T>(array: byref<'T[]>, newSize: int) =\n        let a = Array.zeroCreate newSize\n        if not (isNull array) then\n            Array.blit array 0 a 0 (min newSize array.Length)\n        array <- a\n\n    [<Inline \"$array.reverse()\">]\n    static member Reverse(array: System.Array) = X<unit>\n\n    [<Name \"WebSharper.Arrays.reverse\">]\n    static member Reverse(array: System.Array, offset: int, length: int) =\n        let a = Array.rev (Array.sub (As array) offset length)\n        Array.blit a 0 (As array) offset a.Length\n\n    [<Inline>]\n    member this.SetValue(v: obj, index: int) =\n        (As<obj[]> this).[index] <- v\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int, comp: IComparer<'K>) : unit =\n        sortByKeys keys items index length comp.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], index: int, length: int) : unit =\n        sortByKeys keys items index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[], comparer: IComparer<'K>) : unit =\n        sortByKeys keys items 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K, 'V>(keys: 'K[], items: 'V[]) : unit =\n        sortByKeys keys items 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int, comparer: IComparer<'K>) : unit =\n        sortSub keys index length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], index: int, length: int) : unit =\n        sortSub keys index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparer: IComparer<'K>) : unit =\n        sortSub keys 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[]) : unit =\n        sortSub keys 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort<'K>(keys: 'K[], comparison: Comparison<'K>) =\n        sortSub keys 0 keys.Length comparison.Invoke\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) index length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, index: int, length: int) : unit =\n        sortSub (As<obj[]> keys) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, comparer: IComparer) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length comparer.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, index: int, length: int) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) index length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array, comp: IComparer) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length comp.Compare\n\n    [<Inline>]\n    static member Sort(keys: System.Array, items: System.Array) : unit =\n        sortByKeys (As<obj[]> keys) (As<obj[]> items) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member Sort(keys: System.Array) : unit =\n        sortSub (As<obj[]> keys) 0 keys.Length (fun (x, y) -> compare (As x) (As y))\n\n    [<Inline>]\n    static member TrueForAll<'T>(array : 'T[], predicate: Predicate<'T>) : bool =\n        Array.forall predicate.Invoke array\n\n    member this.Length\n        with [<Inline>] get() = F.GetLength (As this)   \n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get0 (As this)         \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ArrayModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ArrayModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\nlet checkLength (arr1: 'T1[]) (arr2: 'T2[]) =\n    if Array.length arr1 <> Array.length arr2 then\n        failwith \"The arrays have different lengths.\"\n\n[<Inline \"$x.push($y)\">]\nlet push (x: obj) (y: obj) = ()\n\n[<Inline \"$arr1.concat($arr2)\">]\nlet Append<'T> (arr1: 'T []) (arr2: 'T []) : 'T [] = arr1\n\n[<Name \"allPairs\">]\nlet AllPairs (array1: 'T1 []) (array2: 'T2 []) =\n    let len1 = Array.length array1\n    let len2 = Array.length array2\n    let res = JavaScript.Array (len1 * len2)\n    for i = 0 to len1-1 do\n        for j = 0 to len2-1 do\n            res.[i * len2 + j] <- (array1.JS.[i],array2.JS.[j])\n    res |> As<('T1 * 'T2) []>\n\n[<Name \"average\">]\nlet inline Average (arr: 'T []): 'T = As (float (Array.sum arr) / float (Array.length arr))\n\n[<Name \"averageBy\">]\nlet inline AverageBy (f: 'T -> 'U) (arr: 'T []) : 'U = As (float (Array.sumBy f arr) / float (Array.length arr))\n\n[<Name \"blit\">]\nlet CopyTo<'T> (arr1: 'T [], start1, arr2: 'T [], start2, length) =\n    F.checkRange arr1 start1 length\n    F.checkRange arr2 start2 length\n    for i = 0 to length - 1 do\n        arr2.JS.[start2 + i] <- arr1.JS.[start1 + i]\n\n[<Name \"choose\">]\nlet Choose<'T,'U> (f: 'T -> option<'U>) (arr: 'T []) : 'U [] =\n    let q : 'U [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match f arr.JS.[i] with\n        | Some x -> push q x\n        | None   -> ()\n    q\n\n[<Inline \"Array.prototype.concat.apply([], $x)\"; Pure>]\nlet concatArray (x: 'T[][]) = X<'T[]>\n\n[<Name \"collect\">]\nlet Collect<'T,'U> (f: 'T -> 'U[]) (x: 'T []) : 'U[] =\n    concatArray (Array.map f x)\n\n[<Name \"concat\">]\nlet Concat<'T> (xs: seq<'T []>) : 'T [] =\n    concatArray (Array.ofSeq xs)\n\n[<Inline>]\nlet SplitInto count (arr: 'T[]) = ArraySplitInto count arr\n\n[<Inline \"$x.slice()\">]\nlet Copy (x: 'T []) = X<'T []>\n\n[<Name \"create\">]\nlet Create (size: int) value =\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- value\n    r.Self\n\n[<Inline \"[]\">]\nlet Empty () = X<'T []>\n\n[<Name \"exists\">]\nlet Exists<'T> (f: 'T -> bool) (x: 'T []) =\n    let mutable e = false\n    let mutable i = 0\n    let l = x.Length\n    while not e && i < l do\n        if f x.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n    e\n\n[<Name \"exists2\">]\nlet Exists2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable e = false\n    let mutable i = 0\n    let l = x1.Length\n    while not e && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n\n    e\n\n[<Name \"fill\">]\nlet Fill<'T> (arr: 'T []) (start: int) (length: int) (value: 'T) =\n    F.checkRange arr start length\n    for i = start to start + length - 1 do\n        arr.JS.[i] <- value\n\n[<Name \"filter\">]\nlet Filter<'T> f (arr: 'T []) : 'T [] =\n    let r : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push r arr.JS.[i]\n    r\n\n[<Name \"find\">]\nlet Find f (arr: _ []) =\n    match Array.tryFind f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex f (arr: _ []) =\n    match Array.tryFindIndex f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S =\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> f (zero: 'S) (arr1: 'T1 []) (arr2: 'T2 []) : 'S =\n    checkLength arr1 arr2\n    let mutable accum = zero\n    for i in 0 .. Array.length arr1 - 1 do\n        accum <- f accum arr1.JS.[i] arr2.JS.[i]\n    accum\n\n[<Name \"foldBack\">]\nlet FoldBack f (arr: _ []) zero =\n    let mutable acc = zero\n    let len = Array.length arr\n    for i = 1 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (arr1: _ []) (arr2: _ []) zero =\n    checkLength arr1 arr2\n    let len = Array.length arr1\n    let mutable accum = zero\n    for i in 1 .. len do\n        accum <- f arr1.JS.[len - i] arr2.JS.[len - i] accum\n    accum\n\n[<Name \"forall\">]\nlet ForAll f (x: _ []) =\n    let mutable a = true\n    let mutable i = 0\n    let l = x.Length\n    while a && i < l do\n        if f x.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable a = true\n    let mutable i = 0\n    let l = x1.Length\n    while a && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Inline>]\nlet Get (arr: _ []) index =\n    F.GetArray arr index\n\n[<Inline>]\nlet Item index (arr: _ []) =\n    F.GetArray arr index\n\n[<Name \"init\">]\nlet Initialize (size: int) f =\n    if size < 0 then\n        failwith \"Negative size given.\"\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- f i\n    r.Self\n\n[<Inline \"$arr.length == 0\">]\nlet IsEmpty (arr: _ []) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f arr.JS.[i]\n\n[<Name \"iter2\">]\nlet Iterate2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f arr1.JS.[i] arr2.JS.[i]\n\n[<Name \"iteri\">]\nlet IterateIndexed f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f i arr.JS.[i]\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f i arr1.JS.[i] arr2.JS.[i]\n\n[<Inline \"$arr.length\">]\nlet Length<'T> (arr: 'T []) = X<int>\n\n[<Name \"map\">]\nlet Map<'T1,'T2> (f: 'T1 -> 'T2) (arr: 'T1 []) : 'T2 [] =\n    let r = JavaScript.Array<'T2>(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        r.[i] <- f arr.JS.[i]\n    r.Self\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (arr1: 'T1 []) (arr2: 'T2 []) : 'T3 [] =\n    checkLength arr1 arr2\n    let r = JavaScript.Array<'T3>(Array.length arr2)\n    for i = 0 to Array.length arr2 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i]\n    r.Self\n\n[<Name \"mapi\">]\nlet MapIndexed f (arr: _ []) =\n    let y = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        y.[i] <- f i arr.JS.[i]\n    y.Self\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (arr1: 'T1 []) (arr2: 'T2 []): 'U[] =\n    checkLength arr1 arr2\n    let res = JavaScript.Array(Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.[i] <- f i arr1.JS.[i] arr2.JS.[i]\n    res.Self\n\n[<Inline>]\nlet MapFold<'T,'S,'R> f zero arr = ArrayMapFold<'T, 'S, 'R> f zero arr\n\n[<Inline>]\nlet MapFoldBack f arr zero = ArrayMapFoldBack f arr zero\n\nlet private nonEmpty (arr: _ []) =\n    if Array.length arr = 0 then\n        failwith \"The input array was empty.\"\n\n[<Name \"max\">]\nlet Max arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x > m then\n            m <- x\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"min\">]\nlet Min arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        if x < m then\n            m <- x\n    m\n\n\n[<Name \"minBy\">]\nlet MinBy f arr =\n    nonEmpty arr\n    let mutable m = arr.JS.[0]\n    let mutable fm = f m\n    for i = 1 to Array.length arr - 1 do\n        let x = arr.JS.[i]\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"ofList\">]\nlet OfList<'T> (xs: list<'T>) =\n    let q : 'T [] = [||]\n    let mutable l = xs\n    while not (List.isEmpty l) do\n        push q l.Head\n        l <- l.Tail\n    q\n\n[<Name \"ofSeq\">]\nlet OfSeq<'T> (xs: seq<'T>) : 'T [] =\n    if xs :? System.Array then\n        Array.copy (As<'T[]> xs)\n    elif xs :? _ list then\n        Array.ofList (As<'T list> xs)\n    else\n        let q : 'T [] = [||]\n        use o = Enumerator.Get xs\n        while o.MoveNext() do\n            push q o.Current\n        q\n\n[<Name \"partition\">]\nlet Partition f (arr: 'T []) : 'T [] * 'T [] =\n    let ret1 : 'T [] = [||]\n    let ret2 : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push ret1 arr.JS.[i]\n        else\n            push ret2 arr.JS.[i]\n    (ret1, ret2)\n\n[<Name \"permute\">]\nlet Permute f (arr: 'T []) =\n    let ret = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        ret.[f i] <- arr.JS.[i]\n    ret.Self\n\n[<Name \"pick\">]\nlet Pick f (arr: _ []) =\n    match Array.tryPick f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"reduce\">]\nlet Reduce f (arr: _ []) =\n    nonEmpty arr\n    let mutable acc = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (arr: _ []) =\n    nonEmpty arr\n    let len = Array.length arr\n    let mutable acc = arr.JS.[len - 1]\n    for i = 2 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Inline \"$x.slice().reverse()\">]\nlet Reverse (x: 'T []) = X<'T []>\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S [] =\n    let ret = JavaScript.Array(1 + Array.length arr)\n    ret.[0] <- zero\n    for i = 0 to Array.length arr - 1 do\n        ret.[i + 1] <- f ret.[i] arr.JS.[i]\n    ret.Self\n\n[<Name \"scanBack\">]\nlet ScanBack (f: 'T -> 'S -> 'S) (arr: 'T []) (zero: 'S) : 'S [] =\n    let len = Array.length arr\n    let ret = JavaScript.Array(1 + len)\n    ret.[len] <- zero\n    for i = 0 to len - 1 do\n        ret.[len - i - 1] <- f arr.JS.[len - i - 1] ret.[len - i]\n    ret.Self\n\n[<Inline>]\nlet Set (arr: _ []) i v =\n    F.SetArray arr i v\n\n[<Name \"sort\">]\nlet Sort<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> Array.map fst\n\n[<Name \"sortBy\">]\nlet SortBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortInPlace\">]\nlet SortInPlace<'T when 'T: comparison> (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> mapInPlace fst\n\n[<Name \"sortInPlaceBy\">]\nlet SortInPlaceBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"sortInPlaceWith\">]\nlet SortInPlaceWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) =\n    arr.JS.Sort(fun (x, y) -> comparer x y) |> ignore\n\n[<Name \"sortWith\">]\nlet SortWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) : 'T [] =\n    (Array.copy arr).JS.Sort(fun (x, y) -> comparer x y)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> - compare x y) |> Array.map fst\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Inline>]\nlet GetSubArray (arr: 'T []) (start: int) (length: int) : 'T []=\n    F.GetArraySub arr start length\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $arr[i]; return sum\">]\n[<Name \"sum\">]\nlet Sum (arr: 'T []) : 'T = X<'T>\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $f($arr[i]); return sum\">]\n[<Name \"sumBy\">]\nlet SumBy (f: 'T -> 'U) (arr: 'T []) : 'U =  X<'U>\n\n[<Name \"transpose\">]\nlet Transpose (x: 'T[] seq) : 'T[][] =\n    match x with\n    | :? System.Array -> ArrayTranspose (As<'T[][]> x)\n    | _ -> ArrayTranspose (Array.ofSeq x)\n\n[<Inline>]\nlet ToList arr = List.ofArray arr\n\n[<Inline \"$arr\">]\nlet ToSeq (arr: _ []) = arr :> seq<_>\n\n[<Name \"tryFind\">]\nlet TryFind f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some arr.JS.[i]\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindBack f (arr: _ []) = ArrayTryFindBack f arr\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some i\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindIndexBack f (arr: _ []) = ArrayTryFindIndexBack f arr\n\n[<Name \"tryHead\">]\nlet TryHead (arr: 'T[]) =\n    if Array.length arr = 0 then None else Some arr.JS.[0]\n\n[<Name \"tryItem\">]\nlet TryItem i (arr: 'T[]) =\n    if Array.length arr <= i || i < 0 then None else Some arr.JS.[i]\n\n[<Name \"tryLast\">]\nlet TryLast (arr: 'T[]) =\n    let len = Array.length arr\n    if len = 0 then None else Some arr.JS.[len - 1]\n\n[<Name \"tryPick\">]\nlet TryPick f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        match f arr.JS.[i] with\n        | Some _ as r -> res <- r\n        | _ -> ()\n        i <- i + 1\n    res\n\n[<Name \"unzip\">]\nlet Unzip<'T1,'T2> (arr: ('T1 * 'T2) []) : 'T1 [] * 'T2 [] =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        let (a, b) = arr.JS.[i]\n        push x a\n        push y b\n    (x, y)\n\n[<Name \"unzip3\">]\nlet Unzip3<'T1,'T2,'T3> (arr: ('T1 * 'T2 * 'T3) []) =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    let z : 'T3 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match arr.JS.[i] with\n        | (a, b, c) ->\n            push x a\n            push y b\n            push z c\n    (x, y, z)\n\n[<Inline>]\n[<Name \"zeroCreate\">]\nlet ZeroCreate<'T> (size: int) =\n    Create size Unchecked.defaultof<'T>\n\n[<Name \"zip\">]\nlet Zip (arr1: 'T1 []) (arr2: 'T2 []) =\n    checkLength arr1 arr2\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i])\n    res\n\n[<Name \"zip3\">]\nlet Zip3 (arr1: _ [], arr2: _ [], arr3: _ []) =\n    checkLength arr1 arr2\n    checkLength arr2 arr3\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i], arr3.JS.[i])\n    res\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size array =\n    SeqChunkBySize size (Array.toSeq array)\n    |> Seq.toArray\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (a1: 'T []) (a2: 'T []) : int =\n    Seq.compareWith f (Array.toSeq a1) (Array.toSeq a2)\n\n[<Inline>]\nlet CountBy (f: 'T -> 'K) (a: 'T []) : ('K * int) [] =\n    ArrayCountBy f a\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: 'T []) : 'T [] =\n    Seq.distinct (Array.toSeq l)\n    |> Seq.toArray\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (a: 'T []) : 'T [] =\n    Seq.distinctBy f (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (a: 'T []) =\n    SeqExcept itemsToExclude (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"findBack\">]\nlet FindBack p (s: _ []) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: _ []) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (a: 'T []) : ('K * 'T []) [] =\n    ArrayGroupBy f a\n\n[<Name \"head\">]\nlet Head (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[0]\n\n[<Name \"last\">]\nlet Last (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[Array.length arr - 1]\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (arr1: 'T1 []) (arr2: 'T2 []) (arr3: 'T3 []) : 'T4 [] =\n    checkLength arr1 arr2\n    checkLength arr1 arr3\n    let r = JavaScript.Array<'T4>(Array.length arr3)\n    for i = 0 to Array.length arr3 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i] arr3.JS.[i]\n    r.Self\n\n[<Inline>]\nlet Contains (el: 'T) (a: 'T []) =\n    ArrayContains el a\n\n[<Name \"pairwise\">]\nlet Pairwise (a: 'T []) : ('T * 'T) [] =\n    Seq.pairwise (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    Array.create size value\n\n[<Name \"indexed\">]\nlet Indexed (ar : 'T []) : (int * 'T) [] =\n    Array.mapi (fun a b -> (a, b)) ar\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [| x |]\n\n[<Name \"skip\">]\nlet Skip<'T> i (ar : 'T []) =\n    if i < 0 then InputMustBeNonNegative() else\n    if i > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(i)\n\n[<Name \"skipWhile\">]\nlet SkipWhile<'T> (predicate : 'T -> bool) (ar : 'T []) : 'T [] =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(i)\n\n[<Name \"tail\">]\nlet Tail<'T> (ar : 'T []) : 'T [] =\n    Skip 1 ar\n\n[<Name \"take\">]\nlet Take<'T> n (ar: 'T []) =\n    if n < 0 then InputMustBeNonNegative() else\n    if n > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(0, n)\n\n[<Name \"takeWhile\">]\nlet TakeWhile<'T> (predicate : 'T -> bool) (ar: 'T []) =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(0, i)\n\n[<Inline>]\nlet Truncate<'T> n (ar: 'T []) =\n    ar.JS.Slice(0, n)\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (ar : 'T []) =\n    if Array.length ar = 1 then\n        ar.JS.[0]\n    else\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : 'T [] =\n    Seq.unfold f s\n    |> Seq.toArray\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T []) : 'T [] =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T []) : array<'T []> =\n    Seq.windowed windowSize (Array.toSeq s)\n    |> Seq.toArray\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (ar: 'T []) =\n    Take n ar, Skip n ar\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays2D\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.Array2DModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.Array2DModuleProxy\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Inline>]\nlet Length1 (arr: 'T[,]) = F.GetArray2DLength1 arr\n\n[<Inline>]\nlet Length2 (arr: 'T[,]) = F.GetArray2DLength2 arr\n\n[<Inline>]\nlet Get (array: 'T[,]) (n:int) (m:int) = F.GetArray2D array n m\n\n[<Inline>]\nlet Set (array: 'T[,]) (n:int) (m:int) (x:'T) = F.SetArray2D array n m x\n\n[<Inline>]\nlet ZeroCreate (n:int) (m:int) = F.Array2DZeroCreate n m\n    \n[<Inline>]\nlet Create n m (x:'T) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.create m x))\n    arr?dims <- 2\n    arr\n     \n[<Name \"init\">]\nlet Initialize n m f = \n    let array = ZeroCreate n m : 'T[,]  \n    for i = 0 to n - 1 do \n        for j = 0 to m - 1 do \n            array.[i, j] <- f i j\n    array\n\n[<Name \"iter\">]\nlet Iterate f array = \n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f array.[i,j]\n\n[<Name \"iteri\">]\nlet IterateIndexed (f : int -> int -> 'T -> unit) (array:'T[,]) =\n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f i j array.[i,j]\n\n[<Name \"map\">]\nlet Map f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f array.[i,j])\n\n[<Name \"mapi\">]\nlet MapIndexed f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f i j array.[i,j])\n\n[<Name \"copy\">]\nlet Copy array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> array.[i,j])\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\ntype private CT  = System.Threading.CancellationToken\ntype private CTS  = System.Threading.CancellationTokenSource\ntype private CTR  = System.Threading.CancellationTokenRegistration\ntype private OCE = System.OperationCanceledException\nmodule C = WebSharper.Concurrency\n\n[<Proxy(typeof<Async>)>]\ntype private AsyncProxy =\n\n    [<Inline>]\n    static member Catch(a: Async<'T>) : Async<Choice<'T,exn>>  =\n        As (C.Catch (As a))\n\n    [<Inline>]\n    static member Start(computation: Async<unit>, ?t: CT) : unit =\n        C.Start (As computation, As t)\n\n    [<Inline>]\n    static member Ignore (computation: Async<'T>) : Async<unit> =\n        As (C.Ignore (As computation))\n\n    [<Inline>]\n    static member Sleep milliseconds : Async<unit> =\n        As (C.Sleep milliseconds)\n\n    [<Inline>]\n    static member StartWithContinuations(op: Async<'T>,\n                                         c1: 'T -> unit,\n                                         c2: exn -> unit,\n                                         c3: OCE -> unit,\n                                         ?t: CT) : unit =\n        C.StartWithContinuations (As op, c1, c2, c3, As t)\n\n    [<Inline>]\n    static member FromContinuations(callback: (('T -> unit) *\n                                               (exn -> unit) *\n                                               (OCE -> unit)) -> unit)\n                                    : Async<'T> =\n        As (C.FromContinuations callback)\n\n    [<Inline>]\n    static member AwaitEvent(ev: IEvent<'D,'T>, ?t: unit -> unit) : Async<'T> =\n        As (C.AwaitEvent (As ev, t))\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task) : Async<unit> =\n        As (C.AwaitTask t)\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task<'T>) : Async<'T> =\n        As (C.AwaitTask1 t)\n\n    [<Inline>]\n    static member StartChild(a: Async<'T>, ?timeOut: int) : Async<Async<'T>> =\n        As (C.StartChild (As a, timeOut))\n\n    [<Inline>]\n    static member StartChildAsTask(a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions) \n        : Async<System.Threading.Tasks.Task<'T>> =\n        As (C.StartChildAsTask (As a))\n\n    [<Inline>]\n    static member Parallel(cs: seq<Async<'T>>) : Async<'T []> =\n        As (C.Parallel (As cs))\n\n    [<Inline>]\n    static member StartImmediate(c: Async<unit>, ?t: CT) : unit =\n        C.StartImmediate (As c, As t)\n\n    [<Inline>]\n    static member StartAsTask (a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartAsTask(As a, As t)        \n\n    [<Inline>]\n    static member StartImmediateAsTask (a: Async<'T>, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartImmediateAsTask(As a, As t)        \n\n    [<Inline>]\n    static member DefaultCancellationToken : CT =\n        As !C.defCTS\n\n    [<Inline>]\n    static member CancelDefaultToken() : unit =\n        let cts = !C.defCTS\n        C.defCTS := new CTS()\n        cts.Cancel()    \n\n    [<Inline>]\n    static member CancellationToken : Async<CT> =\n        As C.GetCT\n\n    [<Inline>]\n    static member OnCancel(action: unit -> unit) : Async<System.IDisposable> =\n        As (C.OnCancel action)\n    \n    [<Inline>]\n    static member TryCancelled(p: Async<'T>, f: OCE -> unit) : Async<'T> =\n        As (C.TryCancelled(As p, f))\n\n[<Proxy(typeof<CT>)>]\ntype private CancellationTokenProxy =\n    [<Inline \"$this.c\">]\n    member this.IsCancellationRequested = X<bool>\n\n    [<Inline>]\n    member this.Register(callback: System.Action) =\n        As<CTR> (C.Register (As this) callback.Invoke)\n\n    [<Inline>]\n    member this.ThrowIfCancellationRequested() =\n        if this.IsCancellationRequested then raise (OCE(As<CT> this)) \n\n    [<Inline>]\n    static member None = As<CT> C.noneCT\n        \n[<Proxy(typeof<CTS>)>]\n[<Name \"CancellationTokenSource\">]\ntype private CancellationTokenSourceProxy () =\n    let mutable c = false\n\n    let mutable pending = None\n\n    let r = [||] : (unit -> unit)[]\n\n    [<Inline>]\n    new (delay: int) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    new (delay: System.TimeSpan) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    member this.IsCancellationRequested = c\n\n    member this.Token \n        with [<Inline \"$this\">] get() = X<CT>\n\n    member this.Cancel() =\n        if not c then\n            c <- true\n            let errors = \n                r |> Array.choose (fun a -> \n                    try a()\n                        None\n                    with e -> Some e\n                )\n            if errors.Length > 0 then\n                raise (System.AggregateException(errors))    \n            \n    member this.Cancel(throwOnFirstException) =\n        if not throwOnFirstException then\n            this.Cancel()\n        else\n            if not c then\n                c <- true\n                r |> Array.iter (fun a -> a())   \n \n    member this.CancelAfter(delay: int) =\n        if not c then\n            pending |> Option.iter JS.ClearTimeout\n            pending <- Some <| JS.SetTimeout this.Cancel delay\n\n    [<Inline>]\n    member this.CancelAfter(delay: System.TimeSpan) = this.CancelAfter(As<int> delay)\n\n    static member CreateLinkedTokenSource(tokens: CT[]) =\n        let cts = new CTS()\n        tokens |> Array.iter (fun t -> t.Register(fun () -> cts.Cancel()) |> ignore)\n        cts\n\n    static member CreateLinkedTokenSource(t1: CT, t2: CT) =\n        CancellationTokenSourceProxy.CreateLinkedTokenSource [| t1; t2 |]\n\n[<Proxy(typeof<System.Threading.CancellationTokenRegistration>)>]\ntype private CancellationTokenRegistrationProxy =\n    [<Inline>]\n    member this.Dispose() = (this :> System.IDisposable).Dispose() \n    \n    interface System.IDisposable with\n        [<JavaScript false>]\n        member this.Dispose() = ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name \"Char\">]\n[<Proxy(typeof<System.Char>)>]\ntype private CharProxy =\n\n    [<Inline \"'\\u0000'\">]\n    new () = {}\n\n    [<Inline>]\n    member this.CompareTo(s: char) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: char) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    static member GetNumericValue(c: char) : float =\n        if c >= '0' && c <= '9' then float c - float '0' else -1.\n\n    [<Inline>]\n    static member GetNumericValue(s: string, i: int) = CharProxy.GetNumericValue(s.[i])\n\n    static member IsControl(c: char) : bool =\n        c >= '\\u0000' && c <= '\\u001f'\n        || c >= '\\u0080' && c <= '\\u009f'\n\n    [<Inline>]\n    static member IsControl(s: string, i: int) = CharProxy.IsControl(s.[i])\n\n    static member IsDigit(c: char) : bool =\n        c >= '0' && c <= '9'\n\n    [<Inline>]\n    static member IsDigit(s: string, i: int) = CharProxy.IsDigit(s.[i])\n\n    static member IsLetter(c: char) : bool =\n        c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLetter(s: string, i: int) = CharProxy.IsLetter(s.[i])\n\n    static member IsLetterOrDigit(c: char) : bool =\n        System.Char.IsLetter c || System.Char.IsDigit c\n\n    [<Inline>]\n    static member IsLetterOrDigit(s: string, i: int) = CharProxy.IsLetterOrDigit(s.[i])\n\n    static member IsLower(c: char) : bool =\n        c >= 'a' && c <= 'z'\n\n    [<Inline>]\n    static member IsLower(s: string, i: int) = CharProxy.IsLower(s.[i])\n\n    static member IsUpper(c: char) : bool =\n        c >= 'A' && c <= 'Z'\n\n    [<Inline>]\n    static member IsUpper(s: string, i: int) = CharProxy.IsUpper(s.[i])\n\n    [<Direct @\"$c.match(/\\s/) !== null\">]\n    static member IsWhiteSpace(c: char) = X<bool>\n\n    [<Inline>]\n    static member IsWhiteSpace(s: string, i: int) = CharProxy.IsWhiteSpace(s.[i])\n\n    static member Parse(s: string) =\n        if s.Length = 1 then As<char> s else\n            failwith \"String must be exactly one character long.\"\n\n    [<Inline \"String.fromCharCode($x.charCodeAt() + $y.charCodeAt())\">]\n    static member (+) (x: char, y: char) : char = x + y\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Util\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.CommonExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.CommonExtensionsProxy\n\nopen WebSharper.JavaScript\n\nlet observer (h: 'T -> unit) : System.IObserver<'T> =\n    { new System.IObserver<'T> with \n        member this.OnCompleted() = ()\n        member this.OnError _ = ()\n        member this.OnNext args = h args\n    }\n\n[<Inline>]\nlet AddToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h) |> ignore\n\n[<Inline>]\nlet SubscribeToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\nopen System\n\ntype private D = System.DateTime\ntype private K = System.DateTimeKind\ntype internal TS = System.TimeSpan\ntype private DO = System.DateTimeOffset\n\n[<JavaScript>]\n[<Name \"DateUtil\">]\nmodule private DateTimeHelpers =\n    let DatePortion (d: int) =\n        let e = Date(d)\n        Date(       \n            e.GetFullYear(),\n            e.GetMonth(),\n            e.GetDate()\n        ).GetTime()\n        |> As<D>        \n\n    let TimePortion (d: int) =\n        let e = Date(d)\n        TS(\n            0,\n            e.GetHours(), \n            e.GetMinutes(), \n            e.GetSeconds(), \n            e.GetMilliseconds()\n        )        \n        |> As<TS>        \n\n    let AddYears(d: int, years) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear() + years,\n            e.GetMonth(),\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()\n        |> As<D>        \n\n    let AddMonths(d: int, months: int) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear(),\n            e.GetMonth() + months,\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()    \n        |> As<D>        \n\n    let TryParse (s: string) =\n        let d = Date.Parse(s)   \n        if JS.IsNaN(d) then\n            None\n        else Some d\n\n    let Parse (s: string) =\n        match TryParse s with\n        | Some d -> d\n        | _ ->\n            failwith \"Failed to parse date string.\"\n\n    [<Direct \"(new Date($d)).toLocaleDateString({}, {year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'})\">]\n    let LongDate (d: obj) = X<string>\n     \n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', hour12: false})\">]\n    let ShortTime (d: obj) = X<string>\n\n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})\">]\n    let LongTime (d: obj) = X<string>\n                \n// DateTime is represented as an UTC epoch for remoting purposes.\n// Properties for getting sub-dates/times like Day or Hour convert it to local time on the client for easier display purposes.\n// This is inconsistent, but covers most common uses.\n// If you need UTC time details, use .JS and its UTC methods.\n[<Proxy(typeof<System.DateTime>)>]\ntype private DateTimeProxy =\n    [<Inline \"0\">]\n    new () = {}\n\n    [<Inline \"new Date($y,$mo-1,$d).getTime()\">]\n    new (y: int, mo: int, d: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s,$ms).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int, ms: int) = {}\n    \n    static member Now\n        with [<Inline \"Date.now()\">] get() = X<D>\n\n    static member UtcNow\n        with [<Inline \"Date.now()\">] get() = X<D>\n    \n    [<Inline \"1\">]\n    member this.Kind = X<System.DateTimeKind>\n\n    member this.Date \n        with [<Inline; JavaScript>] get() : D = DateTimeHelpers.DatePortion(As this)\n\n    static member Today\n        with [<Inline; JavaScript>] get() = DateTimeProxy.Now.Date  \n\n    member this.TimeOfDay \n        with [<Inline; JavaScript>] get() = DateTimeHelpers.TimePortion(As this)\n\n    member this.Year\n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetFullYear()\n\n    member this.Month \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMonth() + 1\n\n    member this.Day \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetDate()\n\n    member this.Hour \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetHours()\n                                                  \n    member this.Minute \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMinutes()\n    \n    member this.Second \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetSeconds()\n\n    member this.Millisecond \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMilliseconds()\n    \n    member this.DayOfWeek \n        with [<Inline; JavaScript>] get() = As<System.DayOfWeek>(Date(As<int> this).GetDay())\n\n    member this.Ticks\n        with [<Inline \"$this * 1E4\">] get() = X<int64>\n\n    [<Inline \"$this + $t\">]\n    member this.Add(t: TS) = X<D>\n                            \n    [<Inline \"$this - $t\">]\n    member this.Subtract(t: TS) = X<D>\n\n    [<Inline \"$this - $d\">]\n    member this.Subtract(d: D) = X<TS>\n\n    [<Inline; JavaScript>]\n    member this.AddYears(years: int) : D = DateTimeHelpers.AddYears(As this, years)\n\n    [<Inline; JavaScript>]\n    member this.AddMonths(months: int) : D = DateTimeHelpers.AddMonths(As this, months)\n\n    [<Inline; JavaScript>]\n    member this.AddDays(days: float) : D =\n        this.Add(TS.FromDays days)\n\n    [<Inline; JavaScript>]\n    member this.AddHours(hours: float) : D =\n        this.Add(TS.FromHours hours)\n\n    [<Inline; JavaScript>]\n    member this.AddMinutes(minutes: float) : D =\n        this.Add (TS.FromMinutes minutes)\n\n    [<Inline; JavaScript>]\n    member this.AddSeconds(seconds: float) : D =\n        this.Add (TS.FromSeconds seconds)\n\n    [<Inline; JavaScript>]\n    member this.AddMilliseconds(msec: float) : D =\n        this.Add (TS.FromMilliseconds msec)\n\n    [<Inline; JavaScript>]\n    member this.AddTicks(ticks: int64) : D =\n        this.Add (TS.FromTicks ticks)\n\n    [<Inline \"new Date($this).toLocaleDateString()\">]\n    member this.ToShortDateString() = X<string>\n    \n    [<Inline; JavaScript>]\n    member this.ToLongDateString() = DateTimeHelpers.LongDate(this)\n    \n    [<Inline; JavaScript>]\n    member this.ToShortTimeString() = DateTimeHelpers.ShortTime(this)\n\n    [<Inline; JavaScript>]\n    member this.ToLongTimeString() = DateTimeHelpers.LongTime(this)\n\n    [<Inline; JavaScript>]\n    static member Parse(s) = As<D>(DateTimeHelpers.Parse(s))\n\n    [<Inline; JavaScript>]\n    static member TryParse(s, [<Out>] res: byref<D>) =\n        match DateTimeHelpers.TryParse s with\n        | Some d ->\n            res <- As<D> d   \n            true\n        | _ -> false    \n\n    static member MaxValue\n        with [<Inline \"8640000000000000\">] get () = X<int>\n\n    static member MinValue\n        with [<Inline \"-8640000000000000\">] get () = X<int>\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: TS) = X<D>\n\n    [<Inline \"$a - $b\">]\n    static member (-) (a: D, b: D) = X<TS>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality (a: D, b: D) = X<bool>\n\n    [<Inline \"$a > $b\">]\n    static member op_GreaterThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a < $b\">]\n    static member op_LessThan (a: D, b: D) = X<bool>\n\n    [<Inline \"$a >= $b\">]\n    static member op_GreaterThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"$a <= $b\">]\n    static member op_LessThanOrEqual (a: D, b: D) = X<bool>\n\n    [<Inline \"new Date($y, $mo, 0).getDate()\">]\n    static member DaysInMonth (y: int, mo: int) = X<int>\n\n    [<Inline \"new Date($y, 1, 29).getDate() == 29\">]\n    static member IsLeapYear (y: int) = X<bool>\n\n[<Proxy(typeof<System.DateTimeOffset>)>]\n[<Prototype false>]\n[<Name \"DateTimeOffset\">]\n// \"d\" contains UTC epoch time\n// \"o\" contains time zone offset in minutes\ntype private DateTimeOffsetProxy [<Inline \"{d: $d, o: $o}\">] (d: D, o: int) =\n\n    [<Inline>]\n    new (d: D, o: TS) = DateTimeOffsetProxy(d, int o.TotalMinutes) \n\n    [<Inline>]\n    new (d: D) = DateTimeOffsetProxy(d, 0) \n\n    member this.DateTime = d\n\n    [<Inline \"$this.o * 60000\">]\n    member this.Offset = X<TS>\n\n    [<Direct \"var d = new Date(); return { d: d.getTime(), o: -d.getTimezoneOffset() } \">]\n    static member Now = X<DO>\n\n    [<Inline \"{ d: Date.now(), o: 0 }\">]\n    static member UtcNow = X<DO>\n        \n    [<Inline>]\n    member this.ToLocalTime() =\n        DO(d, As<TS>(Date().GetTimezoneOffset()))\n        \n    [<Inline>]\n    member this.ToUniversalTime() =\n        DO(d, TS.Zero)\n\n    [<Inline>]\n    member this.UtcDateTime = d\n\n    [<Inline>]\n    member this.TimeOfDay = d.TimeOfDay\n\n    [<Inline>]\n    member this.Year = d.Year\n\n    [<Inline>]\n    member this.Month = d.Month\n\n    [<Inline>]\n    member this.Day = d.Day\n\n    [<Inline>]\n    member this.Hour = d.Hour\n                                                  \n    [<Inline>]\n    member this.Minute = d.Minute\n    \n    [<Inline>]\n    member this.Second = d.Second\n\n    [<Inline>]\n    member this.Millisecond = d.Millisecond\n    \n    [<Inline>]\n    member this.DayOfWeek = d.DayOfWeek\n\n    [<Inline>]\n    member this.Ticks = d.Ticks\n\n    [<Inline>]\n    member this.Add(t: TS) = DateTimeOffsetProxy(d.Add(t), o)\n                            \n    [<Inline>]\n    member this.Subtract(t: TS) = DateTimeOffsetProxy(d.Subtract(t), o)\n\n    [<Inline>]\n    member this.Subtract(o: DO) = d.Subtract(o?d: D)\n\n    [<Inline>]\n    member this.AddYears(years: int) = DateTimeOffsetProxy(d.AddYears(years), o)\n\n    [<Inline>]\n    member this.AddMonths(months: int) = DateTimeOffsetProxy(d.AddMonths(months), o)\n\n    [<Inline>]\n    member this.AddDays(days: float) = DateTimeOffsetProxy(d.AddDays(days), o)\n\n    [<Inline>]\n    member this.AddHours(hours: float) = DateTimeOffsetProxy(d.AddHours(hours), o)\n\n    [<Inline>]\n    member this.AddMinutes(minutes: float) = DateTimeOffsetProxy(d.AddMinutes(minutes), o)\n\n    [<Inline>]\n    member this.AddSeconds(seconds: float) = DateTimeOffsetProxy(d.AddSeconds(seconds), o)\n\n    [<Inline>]\n    member this.AddMilliseconds(msec: float) = DateTimeOffsetProxy(d.AddMilliseconds(msec), o)\n\n    [<Inline>]\n    member this.AddTicks(ticks: int64) = DateTimeOffsetProxy(d.AddTicks(ticks), o)\n\n    [<Inline>]\n    static member (+) (a: DO, b: TS) = a.Add(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: TS) = a.Subtract(b)\n\n    [<Inline>]\n    static member (-) (a: DO, b: DO) = a.Subtract(b)\n\n    [<Inline \"$a.d == $b.d\">]\n    static member op_Equality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d != $b.d\">]\n    static member op_Inequality (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d > $b.d\">]\n    static member op_GreaterThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d < $b.d\">]\n    static member op_LessThan (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d >= $b.d\">]\n    static member op_GreaterThanOrEqual (a: DO, b: DO) = X<bool>\n\n    [<Inline \"$a.d <= $b.d\">]\n    static member op_LessThanOrEqual (a: DO, b: DO) = X<bool>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Delegate\">]\n[<Proxy(typeof<Delegate>)>]\ntype internal DelegateProxy =\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: Delegate, b: Delegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline \"$this.apply(null, $args)\">]\n    member this.DynamicInvoke(args: obj[]) = X<obj>\n\n    [<Direct \"$0.$Invokes || [$0]\">]\n    static member InvocationList(del: Delegate) = X<Delegate[]> \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n    \n    static member DelegateTarget(del) =\n        if (JS.Not del) then null\n        elif (JS.In \"$Target\" del) then del?``$Target``\n        elif (JS.In \"$Invokes\" del) then \n            let inv = del?``$Invokes`` : (_ * _)[]\n            snd inv.[inv.Length - 1]\n        else null\n\n    [<Inline>]\n    member this.Target =\n        DelegateProxy.DelegateTarget this\n\n    [<Inline \"$wsruntime.CreateDelegate($0)\">]\n    static member JSCreateDelegate(invokes: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates([$0, $1])\">]\n    static member Combine(a: Delegate, b: Delegate) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates($0)\">]\n    static member Combine(delegates: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member DelegateEqual(d1: Delegate, d2: Delegate) = X<bool>\n                           \n    static member Remove(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        let resInv = [||]\n        let mutable found = false\n        for i = sourceInv.Length - 1 downto 0 do\n            let it = sourceInv.[i]\n            if not found && DelegateProxy.DelegateEqual(it, value) then\n                found <- true\n            else\n                resInv.JS.Unshift(it) |> ignore\n        DelegateProxy.JSCreateDelegate(resInv)         \n\n    static member RemoveAll(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        DelegateProxy.JSCreateDelegate(sourceInv |> Array.filter (fun i -> not (i.Equals(value))))         \n\n[<Proxy(typeof<MulticastDelegate>)>]\ntype internal MulticastDelegateProxy =\n    \n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Equality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline \"!$wsruntime.DelegateEqual($0, $1)\">]\n    static member op_Inequality(a: MulticastDelegate, b: MulticastDelegate) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Collections\nopen System.Collections.Generic\n\ntype private KVP<'K,'V> = KeyValuePair<'K,'V>\ntype private D<'K,'V> = Dictionary<'K,'V>\n\n[<JavaScript>]\nmodule internal DictionaryUtil =\n\n    let notPresent () =\n        failwith \"The given key was not present in the dictionary.\"\n\n    let alreadyAdded () =\n        failwith \"An item with the same key has already been added.\"\n\n    let equals (c: IEqualityComparer<'T>) =\n        FuncWithArgs(fun (x, y) -> c.Equals(x, y))\n\n    [<Inline>]\n    let genEquals<'T when 'T : equality> () = \n        FuncWithArgs(fun (x :'T, y) -> x = y)\n\n    let getHashCode (c: IEqualityComparer<'T>) x =\n        c.GetHashCode x\n\nopen DictionaryUtil\nopen System.Runtime.InteropServices\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.KeyCollection.Enumerator>)>]\n[<Stub>]\ntype private KeyCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'K> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.ValueCollection.Enumerator>)>]\n[<Stub>]\ntype private ValueCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'V> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Name \"WebSharper.Collections.KeyCollection\">]\n[<Proxy(typeof<D<_,_>.KeyCollection>)>]\ntype private KeyCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.KeyCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Key)).GetEnumerator())\n            \n    interface IEnumerable<'K> with\n        member this.GetEnumerator() = As<IEnumerator<'K>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Name \"WebSharper.Collections.ValueCollection\">]\n[<Proxy(typeof<D<_,_>.ValueCollection>)>]\ntype private ValueCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.ValueCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Value)).GetEnumerator())\n            \n    interface IEnumerable<'V> with\n        member this.GetEnumerator() = As<IEnumerator<'V>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Proxy(typeof<D<_,_>.Enumerator>)>]\n[<Stub>]\ntype private DictionaryEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<KVP<'K,'V>> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n/// Implements a proxy for the .NET dictionary.\n[<Name \"WebSharper.Collections.Dictionary\">]\n[<Proxy(typeof<D<_,_>>)>]\ntype internal Dictionary<'K,'V when 'K : equality>\n\n    private (init   : seq<KVP<'K,'V>>,\n             equals : FuncWithArgs<'K * 'K, bool>,\n             hash   : 'K -> int) =\n\n        let mutable count = 0\n        let mutable data  = As<Array<Array<KVP<'K, 'V>>>> [||]\n\n        let get k =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                notPresent()\n            else\n                d.Self |> Array.pick (fun (KeyValue(dk, v)) -> \n                    if equals.Call(dk, k) then Some v else None\n                ) \n\n        let set k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==.null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                match d.Self |> Array.tryFindIndex (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) with\n                | Some i ->\n                    d.[i] <- KVP(k, v) \n                | None ->\n                    count <- count + 1\n                    d.Push(KVP(k, v)) |> ignore\n                    \n        let add k v =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n            else\n                if d.Self |> Array.exists (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) then\n                    alreadyAdded()                    \n                count <- count + 1\n                d.Push(KVP(k, v)) |> ignore\n                    \n        let remove k =\n            let h = hash k \n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let r = d.Self |> Array.filter (fun (KeyValue(dk, _)) -> not (equals.Call(dk, k)))\n                if r.Length < d.Length then                  \n                    count <- count - 1\n                    data.[h] <- r.JS\n                    true\n                else\n                    false\n\n        do for x in init do\n            set x.Key x.Value\n\n        new () = new Dictionary<'K,'V>([||], genEquals<'K>(), hash)\n\n        new (capacity: int) = new Dictionary<'K,'V>()\n\n        new (comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>([||], equals comparer, getHashCode comparer)\n\n        new (capacity: int, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(comparer)\n\n        new (dictionary: IDictionary<'K,'V>) =\n            new Dictionary<'K,'V>(dictionary, genEquals<'K>(), hash)\n\n        new (dictionary: IDictionary<'K,'V>, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(\n                dictionary,\n                equals comparer,\n                getHashCode comparer\n            )\n\n        member this.Add(k: 'K, v: 'V) =\n            add k v\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member this.ContainsKey(k: 'K) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                d.Self |> Array.exists (fun (KeyValue(dk, _)) -> \n                    equals.Call(dk, k)\n                ) \n\n        member this.Count with [<Inline>] get () = count\n\n        member this.Item\n            with get (k: 'K) : 'V = get k\n            and set (k: 'K) (v: 'V) = set k v\n\n        member this.GetEnumerator() = As<D<'K,'V>.Enumerator> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        interface System.Collections.IEnumerable with\n            member this.GetEnumerator() = \n                let s = JS.GetFieldValues data\n                (As<KeyValuePair<'K,'V>[][]> s |> Array.concat).GetEnumerator()\n            \n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = As<IEnumerator<KeyValuePair<'K,'V>>> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        member this.Remove(k: 'K) =\n            remove k\n\n        member this.TryGetValue(k: 'K, [<Out>] res : byref<'V>) =\n            let h = hash k\n            let d = data.[h]\n            if d ==. null then\n                false\n            else\n                let v =\n                    d.Self |> Array.tryPick (fun (KeyValue(dk, v)) -> \n                        if equals.Call(dk, k) then Some v else None\n                    ) \n                match v with \n                | Some v -> \n                    res <- v\n                    true\n                | _ -> false\n\n        member this.Values =\n            As<D<'K,'V>.ValueCollection>(ValueCollectionProxy(As<D<'K,'V>>this))\n\n        member this.Keys =\n            As<D<'K,'V>.KeyCollection>(KeyCollectionProxy(As<D<'K,'V>>this))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Exception =\n    let withInner (msg, inner) =\n        let e = Error(msg)\n        e?inner <- inner\n        e\n\n[<Name [| \"Error\" |]>]\n[<Proxy(typeof<System.Exception>)>]\ntype private ExceptionProxy =\n    [<Inline \"new Error()\">]\n    new () = { }\n\n    [<Inline \"new Error($message)\">]\n    new (message: string) = { }\n\n    [<Inline>]\n    static member CtorProxy (message: string, inner: exn) = Exception.withInner (message, inner)\n\n    member this.Message with [<Inline \"$this.message\">] get () = X<string>\n    member this.InnerException with [<Inline \"$this.inner\">] get () = X<System.Exception>\n    member this.StackTrace with [<Inline \"$this.stack\">] get () = X<string>\n\n[<Proxy(typeof<MatchFailureException>)>]\n[<Name \"MatchFailureException\">]\ntype private MatchFailureExceptionProxy (message: string, line: int, column: int) =\n    inherit exn(message + \" at \" + string line + \":\" + string column)\n\n[<Proxy(typeof<System.IndexOutOfRangeException>)>]\n[<Name \"IndexOutOfRangeException\">]\ntype private IndexOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n\n    new () = IndexOutOfRangeExceptionProxy \"Index was outside the bounds of the array.\"\n\n[<Proxy(typeof<System.OperationCanceledException>)>]\n[<Name \"OperationCanceledException\">]\ntype private OperationCanceledExceptionProxy(message: string, inner: exn, ct: CT) =\n    inherit exn(message, inner)\n\n    new (ct) = OperationCanceledExceptionProxy (\"The operation was canceled.\", null, ct)\n    \n    [<Inline>]\n    new () = OperationCanceledExceptionProxy (CT.None)\n    [<Inline>]\n    new (message) = OperationCanceledExceptionProxy (message, null, CT.None)\n    [<Inline>]\n    new (message, ct) = OperationCanceledExceptionProxy (message, null, ct)\n    [<Inline>]\n    new (message, inner) = OperationCanceledExceptionProxy (message, inner, CT.None)\n\n    [<Inline>]\n    member this.CancellationToken = ct\n\n[<Proxy(typeof<System.ArgumentException>)>]\n[<Name \"ArgumentException\">]\ntype private ArgumentExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentExceptionProxy \"Value does not fall within the expected range.\"\n\n    new (argumentName: string, message: string) =\n        ArgumentExceptionProxy (message + \"\\nParameter name: \" + argumentName)\n\n[<Proxy(typeof<System.ArgumentOutOfRangeException>)>]\n[<Name \"ArgumentOutOfRangeException\">]\ntype private ArgumentOutOfRangeExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Specified argument was out of the range of valid values.\") }\n\n    new (argumentName: string) =\n        new ArgumentOutOfRangeExceptionProxy(argumentName, \"Specified argument was out of the range of valid values.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.ArgumentNullException>)>]\n[<Name \"ArgumentNullException\">]\ntype private ArgumentNullExceptionProxy =\n    inherit exn\n\n    new () =\n        { inherit exn(\"Value cannot be null.\") }\n\n    new (argumentName: string) =\n        new ArgumentNullExceptionProxy(argumentName, \"Value cannot be null.\")\n\n    new (argumentName: string, message: string) =\n        { inherit exn(message + \"\\nParameter name: \" + argumentName) }\n\n[<Proxy(typeof<System.InvalidOperationException>)>]\n[<Name \"InvalidOperationException\">]\ntype private InvalidOperationExceptionProxy(message: string, innerExn: exn) =\n    inherit exn(message, innerExn)\n    \n    new () = InvalidOperationExceptionProxy \"Operation is not valid due to the current state of the object.\"\n\n    new (message) =\n        new InvalidOperationExceptionProxy(message, null)\n\n[<Proxy(typeof<System.AggregateException>)>]\n[<Name \"AggregateException\">]\ntype private AggregateExceptionProxy(message: string, innerExceptions: exn[]) =\n    inherit exn(message)\n\n    new (innerExceptions: exn[]) = AggregateExceptionProxy(\"One or more errors occurred.\", innerExceptions)\n\n    new (innerExceptions: seq<exn>) = AggregateExceptionProxy(\"One or more errors occurred.\", Array.ofSeq innerExceptions)\n\n    new (message, innerExceptions: seq<exn>) = AggregateExceptionProxy(message, Array.ofSeq innerExceptions)\n\n    new (message, innerException: exn) = AggregateExceptionProxy(message, [| innerException |])\n\n    [<Inline>]\n    member this.InnerExceptions \n        with get() = As<System.Collections.ObjectModel.ReadOnlyCollection<exn>> innerExceptions\n\n[<Proxy(typeof<System.TimeoutException>)>]\n[<Name \"TimeoutException\">]\ntype private TimeoutExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = TimeoutExceptionProxy \"The operation has timed out.\"\n\n[<Proxy(typeof<System.FormatException>)>]\n[<Name \"FormatException\">]\ntype private FormatException(message: string) =\n    inherit exn(message)\n\n    new () = FormatException \"One of the identified items was in an invalid format.\"\n\n[<Proxy(typeof<System.OverflowException>)>]\n[<Name \"OverflowException\">]\ntype private OverflowException(message: string) =\n    inherit exn(message)\n\n    new () = OverflowException \"Arithmetic operation resulted in an overflow.\"\n\n[<Proxy(typeof<System.Threading.Tasks.TaskCanceledException>)>]\n[<Name \"TaskCanceledException\">]\ntype private TaskCanceledException(message: string) =\n    inherit exn(message)\n\n    new () = TaskCanceledException \"A task was canceled.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ExtraTopLevelOperators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ExtraTopLevelOperatorsProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"null\">]\nlet DefaultAsyncBuilder : Control.AsyncBuilder =\n    As (AsyncBuilderProxy())\n\n[<Name \"WebSharper.Arrays.create2D\" >]\nlet CreateArray2D (rows : seq<#seq<'T>>) =\n    let arr = rows |> Seq.map (Array.ofSeq) |> Array.ofSeq |> As<'T[,]>\n    arr?dims <- 2\n    arr\n\n[<Inline \"+$0\">]\nlet ToDouble<'T> (x: 'T) : double = X\n\n[<Inline \"$f(function(x){return x;})\">]\nlet PrintFormatToString (f: Printf.StringFormat<'T>) = X<'T>\n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThen k f = Printf.ksprintf k f \n\n[<Inline; JavaScript>]\nlet PrintFormatLine f = Printf.printfn f \n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThenFail f = Printf.failwithf f \n\n[<Inline; JavaScript>]\nlet SpliceExpression (e: Microsoft.FSharp.Quotations.Expr<'T>) =\n    As<'T> e\n\n[<Inline; JavaScript>]\nlet SpliceUntypedExpression<'T> (e: Microsoft.FSharp.Quotations.Expr) =\n    As<'T> e\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen Concurrency\nopen System.Runtime.InteropServices\n\n[<Proxy(typeof<System.Guid>)>]\n[<Prototype(false)>]\ntype internal GuidProxy =\n    \n    [<Inline \"$g\">]\n    new (g: string) = {}\n    \n    [<Direct \"return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&3|8);\n        return v.toString(16); });\">]\n    static member NewGuid() = X<System.Guid>\n\n    [<Constant \"00000000-0000-0000-0000-000000000000\">]\n    static member Empty = X<System.Guid>\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: System.Guid, b: System.Guid) = X<bool>\n\n    [<Inline>]\n    member this.CompareTo(s: System.Guid) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    static member FormatError() =\n        raise (FormatException \"\"\"Format String can be only \"D\", \"d\", \"N\", \"n\", \"P\", \"p\", \"B\", \"b\", \"X\" or \"x\".\"\"\")\n\n    static member HexaError() =\n        raise (FormatException \"Hexadecimal Guid printing not implemented by WebSharper.\")\n\n    static member ShapeError() =\n        raise (FormatException \"Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\")\n\n    static member ParseError() =\n        raise (FormatException \"Unrecognized Guid format.\")\n\n    member this.ToString(format: string) =\n        match format.ToUpper() with\n        | \"N\" -> (As<string> this).Replace(\"-\", \"\")\n        | \"D\" -> As<string> this\n        | \"B\" -> \"{\" + As<string> this + \"}\"\n        | \"P\" -> \"(\" + As<string> this + \")\"\n        | \"X\" ->\n            let s = As<string> this\n            \"{0x\" + s.Substring(0, 8) + \",0x\" + s.Substring(9, 4) + \",0x\" + s.Substring(14, 4) + \",{0x\"\n            + s.Substring(19, 2) + \",0x\" + s.Substring(21, 2) + \",0x\" + s.Substring(24, 2) + \",0x\"\n            + s.Substring(26, 2) + \",0x\" + s.Substring(28, 2) + \",0x\" + s.Substring(30, 2) + \",0x\" \n            + s.Substring(32, 2) + \",0x\" + s.Substring(34, 2) + \"}}\"\n        | _ -> GuidProxy.FormatError()\n    \n    static member Parse(input: string) =\n        try GuidProxy.ParseExact(input, \"D\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"B\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"P\") \n        with _ ->\n        try GuidProxy.ParseExact(input, \"N\") \n        with _ ->\n            GuidProxy.ParseExact(input, \"X\") \n\n    static member ParseExact(input: string, format: string) =\n        let parseD (s: string) =\n            for i = 0 to 35 do\n                match i with \n                | 8 | 13 | 18 | 23 -> if s.[i] <> '-' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            As<System.Guid> s    \n\n        match format.ToUpper() with\n        | \"N\" -> \n            let s = input.Trim().ToLower()\n            if s.Length <> 32 then GuidProxy.ShapeError()\n            for i = 0 to 31 do\n                let c = s.[i]\n                if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError()   \n            s.Substring(0, 8) + \"-\" + s.Substring(8, 4) + \"-\" + s.Substring(12, 4) + \"-\" \n            + s.Substring(16, 4) + \"-\" + s.Substring(20)\n            |> As<System.Guid>\n        | \"D\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 36 then GuidProxy.ShapeError()\n            parseD s\n        | \"B\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '{' || s.[17] <> '}' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"P\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 38 || s.[0] <> '(' || s.[17] <> ')' then GuidProxy.ShapeError()\n            parseD (s.Substring(1, 36))\n        | \"X\" ->\n            let s = input.Trim().ToLower()\n            if s.Length <> 68 then GuidProxy.ShapeError()\n            for i = 0 to 67 do\n                match i with \n                | 0 | 26 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | 1 | 12 | 19 | 27 | 32 | 37 | 42 | 47 | 52 | 57 | 62 -> if s.[i] <> '0' then GuidProxy.ShapeError()\n                | 2 | 13 | 20 | 28 | 33 | 38 | 43 | 48 | 53 | 58 | 63 -> if s.[i] <> 'x' then GuidProxy.ShapeError()\n                | 11 | 18 | 25 | 31 | 36 | 41 | 46 | 51 | 56 | 61 -> if s.[i] <> ',' then GuidProxy.ShapeError()\n                | 66 | 67 -> if s.[i] <> '{' then GuidProxy.ShapeError()\n                | _ ->\n                    let c = s.[i]\n                    if not (('0' <= c && c <= '9') || ('a' <= c && c <= 'f')) then GuidProxy.ShapeError() \n            s.Substring(3, 8) + \"-\" + s.Substring(14, 4) + \"-\" + s.Substring(21, 4) + \"-\" + s.Substring(29, 2) \n            + s.Substring(34, 2) + \"-\" + s.Substring(39, 2) + s.Substring(44, 2) + s.Substring(49, 2) \n            + s.Substring(54, 2) + s.Substring(59, 2) + s.Substring(64, 2)\n            |> As<System.Guid>\n        | _ -> GuidProxy.FormatError()\n\n    static member TryParse(input: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.Parse(input)\n            true\n        with _ -> false\n\n    static member TryParseExact(input: string, format: string, [<Out>] output: byref<System.Guid>) =\n        try \n            output <- GuidProxy.ParseExact(input, format)\n            true\n        with _ -> false\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule private HashSetUtil =\n    [<Direct \"var r=[]; for(var k in $o) { r.push.apply(r, $o[k]) }; return r\">]\n    let concat (o: Array<Array<'T>>) = X<Array<'T>>\n    \nopen DictionaryUtil\n\n// not really used, an array enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<HashSet<_>.Enumerator>)>]\n[<Stub>]\ntype private HashSetEnumeratorProxy<'T> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'T> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Proxy(typeof<HashSet<_>>)>]\n[<Name \"HashSet\">]\ntype internal HashSetProxy<'T when 'T : equality>\n\n    private (init   : seq<'T>,\n             equals : FuncWithArgs<'T * 'T, bool>,\n             hash   : 'T -> int) =\n\n        let mutable data  = Array<Array<'T>>()\n        let mutable count = 0\n\n        let arrContains (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let arrRemove (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    arr.Splice(i, 1) |> ignore\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let add (item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then\n                data.[h] <- As [| item |]\n                count <- count + 1\n                true\n            else\n                if arrContains item arr then false else    \n                    arr.Push item |> ignore\n                    count <- count + 1\n                    true\n\n        do for x in init do add x |> ignore\n\n        new () = HashSetProxy<'T>(Seq.empty, genEquals<'T>(), hash)\n\n        new (init: seq<'T>) = new HashSetProxy<'T>(init, genEquals<'T>(), hash)\n\n        new (comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(Seq.empty, equals comparer, getHashCode comparer)\n\n        new (init: seq<'T>, comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(init, equals comparer, getHashCode comparer)\n\n        member this.Add(item: 'T) = add item\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member x.Contains(item: 'T) =\n            let arr = data.[hash item]\n            if arr ==. null then false else arrContains item arr\n\n        member x.CopyTo(arr: 'T[]) =\n            let mutable i = 0\n            let all = concat data \n            for i = 0 to all.Length - 1 do \n                arr.[i] <- all.[i]\n\n        member x.Count = count\n\n        member x.ExceptWith(xs: seq<'T>) =\n            for item in xs do\n                x.Remove(item) |> ignore\n\n        [<Inline>]\n        member this.GetEnumerator() =\n           As<HashSet<'T>.Enumerator>((As<seq<'T>>(concat data)).GetEnumerator())\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n        \n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        // TODO: optimize methods by checking if other collection\n        // is a HashSet with the same IEqualityComparer\n        \n        member x.IntersectWith(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash) \n            let all = concat data\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if other.Contains(item) |> not then\n                    x.Remove(item) |> ignore\n\n        member x.IsProperSubsetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count < other.Length && x.IsSubsetOf(other)\n\n        member x.IsProperSupersetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count > other.Length && x.IsSupersetOf(other)\n\n        member x.IsSubsetOf(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            As<_[]>(concat data) |> Array.forall other.Contains\n\n        member x.IsSupersetOf(xs: seq<'T>) =\n            xs |> Seq.forall x.Contains\n\n        member x.Overlaps(xs: seq<'T>) =\n            xs |> Seq.exists x.Contains\n\n        member x.Remove(item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then false else\n                if arrRemove item arr then\n                    count <- count - 1\n                    true\n                else false\n\n        member x.RemoveWhere(cond: System.Predicate<'T>) =\n            let all = concat data\n            let mutable res = 0\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if cond.Invoke item then\n                    if x.Remove(item) then\n                        res <- res + 1\n            res\n\n        member x.SetEquals(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            x.Count = other.Count && x.IsSupersetOf(other)\n\n        member x.SymmetricExceptWith(xs: seq<'T>) =\n            for item in xs do\n                if x.Contains item then\n                    x.Remove(item) |> ignore\n                else\n                    x.Add(item) |> ignore\n\n        member x.UnionWith(xs: seq<'T>) =\n            for item in xs do\n                x.Add(item) |> ignore\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Proxy(typeof<System.IComparable>)>]\ntype private IComparableProxy =\n    [<Name \"CompareTo0\">]\n    abstract CompareTo : obj -> int\n\n[<Proxy(typeof<System.IComparable<_>>)>]\ntype private IComparableProxy<'T> =\n    [<Name \"CompareTo\">]\n    abstract CompareTo : 'T -> int\n\n[<Proxy(typeof<System.Collections.IEqualityComparer>)>]\ntype private IEqualityComparerProxy =\n    [<Name \"CEquals0\">]\n    abstract Equals : obj * obj -> bool \n    [<Name \"CGetHashCode0\">]\n    abstract GetHashCode : obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IEqualityComparer<_>>)>]\ntype private IEqualityComparerProxy<'T> =\n    [<Name \"CEquals\">]\n    abstract Equals : 'T * 'T -> bool \n    [<Name \"CGetHashCode\">]\n    abstract GetHashCode : 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.EqualityComparer<_>>)>]\n[<Name \"WebSharper.Collections.EqualityComparer\">]\n[<AbstractClass>]\ntype private EqualityComparerProxy<'T>() =\n    abstract Equals : 'T * 'T -> bool \n    abstract GetHashCode : 'T -> int\n    interface System.Collections.Generic.IEqualityComparer<'T> with\n        member this.Equals(x, y) = this.Equals(x, y)\n        member this.GetHashCode(x) = this.GetHashCode(x)\n    interface System.Collections.IEqualityComparer with\n        member this.Equals(x, y) = this.Equals(As x, As y)\n        member this.GetHashCode(x) = this.GetHashCode(As x)\n    [<Macro(typeof<M.EqualityComparer>)>]\n    static member Default = X<System.Collections.Generic.EqualityComparer<'T>>\n\n[<Proxy(typeof<System.Collections.IComparer>)>]\ntype private IComparerProxy =\n    [<Name \"Compare0\">]\n    abstract Compare : obj * obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IComparer<_>>)>]\ntype private IComparerProxy<'T> =\n    [<Name \"Compare\">]\n    abstract Compare : 'T * 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.Comparer<_>>)>]\n[<Name \"WebSharper.Collections.Comparer\">]\n[<AbstractClass>]\ntype private ComparerProxy<'T>() =\n    abstract Compare : 'T * 'T -> int\n    interface System.Collections.Generic.IComparer<'T> with\n        member this.Compare(x, y) = this.Compare(x, y)\n    interface System.Collections.IComparer with\n        member this.Compare(x, y) = this.Compare(As x, As y)\n    [<Macro(typeof<M.Comparer>)>]\n    static member Default = X<System.Collections.Generic.Comparer<'T>>\n\n[<Proxy(typeof<System.IEquatable<_>>)>]\ntype private IEquatableProxy<'T> =\n    [<Name \"EEquals\">]\n    abstract Equals : 'T -> bool\n\n[<Proxy(typeof<System.Collections.IStructuralEquatable>)>]\ntype private IStructuralEquatableProxy =\n    [<Name \"SEquals\">]\n    abstract Equals : obj * System.Collections.IEqualityComparer -> bool \n    [<Name \"SGetHashCode\">]\n    abstract GetHashCode : System.Collections.IEqualityComparer -> int\n\n[<Proxy(typeof<System.Collections.IStructuralComparable>)>]\ntype private IStructuralComparableProxy =\n    [<Name \"SCompareTo\">]\n    abstract CompareTo : obj * System.Collections.IComparer -> int \n\n[<Proxy(typeof<System.IDisposable>)>]\ntype private IDisposableProxy =\n    [<Name \"Dispose\">]\n    abstract member Dispose : unit -> unit\n\n[<Proxy(typeof<System.Collections.IEnumerable>)>]  \ntype private IEnumerableProxy =\n\n    [<Name \"GetEnumerator0\">]\n    abstract GetEnumerator : unit -> System.Collections.IEnumerator\n\n[<Proxy(typeof<seq<_>>)>]  \ntype private IEnumerableProxy<'T> =\n    inherit System.Collections.IEnumerable \n    \n    [<Name \"GetEnumerator\">]\n    abstract GetEnumerator : unit -> System.Collections.Generic.IEnumerator<'T>\n    \n[<Proxy(typeof<System.Collections.IEnumerator>)>]\n[<Name \"WebSharper.IEnumerator\">]\ntype private IEnumeratorProxy =\n    [<Name \"Current0\">]\n    abstract member Current  : obj\n    [<Name \"MoveNext\">]\n    abstract member MoveNext : unit -> bool\n    [<Name \"Reset\">]\n    abstract member Reset    : unit -> unit\n\n[<Proxy(typeof<System.Collections.Generic.IEnumerator<_>>)>]\n[<Name \"WebSharper.IEnumerator1\">]\ntype private IEnumeratorProxy<'T> =\n    [<Name \"Current\">]\n    abstract member Current : 'T\n\n[<Proxy(typeof<System.IObservable<_>>)>]\ntype private IObservableProxy<'T> =\n    [<Name \"Subscribe\">]\n    abstract member Subscribe : System.IObserver<'T> -> System.IDisposable\n\n[<Proxy(typeof<System.IObserver<_>>)>]\ntype private IObserverProxy<'T> =\n    [<Name \"OnCompleted\">]\n    abstract member OnCompleted : unit -> unit\n    [<Name \"OnError\">]\n    abstract member OnError : exn -> unit\n    [<Name \"OnNext\">]\n    abstract member OnNext : 'T -> unit\n\n[<Proxy(typeof<IDelegateEvent<_>>)>]\ntype private IDelegateEventProxy<'D> =\n    [<Name \"AddHandler\">]\n    abstract AddHandler : 'D -> unit\n    [<Name \"RemoveHandler\">]\n    abstract RemoveHandler : 'D -> unit\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Lazy\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.LazyExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.LazyExtensionsProxy\n\nopen WebSharper.JavaScript\n\n[<JavaScript; Prototype false>]\ntype LazyRecord<'T> =\n    {\n        [<Name \"c\">] mutable created : bool\n        [<Name \"v\">] mutable evalOrVal : obj\n        [<Name \"f\">] mutable force : unit -> 'T\n    }\n\nlet cachedLazy<'T> () =\n    JS.This.evalOrVal\n\nlet forceLazy<'T> () =\n    let v = (As JS.This.evalOrVal)()\n    JS.This.created <- true\n    JS.This.evalOrVal <- v\n    JS.This.force <- As cachedLazy\n    v\n\nlet Create (f: unit -> 'T) : Lazy<'T> =\n    As {\n        created = false\n        evalOrVal = f\n        force = As forceLazy\n    }\n\nlet CreateFromValue (v: 'T) : Lazy<'T> =\n    As {\n        created = true\n        evalOrVal = v\n        force = As cachedLazy\n    }\n\nlet Force (x: Lazy<'T>) : 'T =\n    As<LazyRecord<'T>>(x).force()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<list<_>>)>]\n[<Name \"WebSharper.List.T\">]\n[<DefaultAugmentation(false)>]\ntype private ListProxy<'T> =\n    | Empty\n    | Cons of Head: 'T * Tail: List<'T>\n\n    [<Inline; Pure>]\n    static member Cons(head: 'T, tail: list<'T>) = head :: tail\n\n    [<Inline; Pure>]\n    static member Empty : list<'T> = []\n\n    member this.Head with [<Inline>] get () = List.head (As this) : 'T\n    member this.Tail with [<Inline>] get () = List.tail (As this) : list<'T>\n    member this.IsEmpty with [<Inline \"$this.$ == 0\">] get () = X<bool>\n\n    member this.Length with get () = List.length (As this)\n\n    member this.Item with get (x: int) : 'T = List.item x (As this)\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() = (this :> _ seq).GetEnumerator() :> _\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let data = As<list<'T>> this\n            Enumerator.New data (fun e ->\n                match e.State with\n                | x :: xs ->\n                    e.Current <- x\n                    e.State <- xs\n                    true\n                | [] ->\n                    false)\n\n    member this.GetSlice(start, finish) : list<'T> =\n        match start, finish with\n        | None, None -> As this\n        | Some i, None -> As this |> CollectionInternals.ListSkip i\n        | None, Some j -> As this |> Seq.take (j + 1) |> List.ofSeq  \n        | Some i, Some j -> As this |> CollectionInternals.ListSkip i |> Seq.take (j - i + 1) |> List.ofSeq        \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"List\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ListModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ListModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nlet badLengths() =\n    failwith \"The lists have different lengths.\"\n\nlet listEmpty() =\n    failwith \"The input list was empty.\"\n\n[<Inline \"$l.$0\">]\nlet unsafeHead (l: list<'T>) = X<'T> \n\n[<Inline \"$l.$1\">]\nlet unsafeTail (l: list<'T>) = X<list<'T>> \n\n[<Inline>]\nlet setValue (l: list<'T>) (v: 'T) =\n    JS.Set l \"$0\" v\n\n[<Inline>]\nlet setTail (l: list<'T>) (t: list<'T>) =\n    JS.Set l \"$1\" t\n\n[<Inline \"new WebSharper.List.T({$: 1})\"; Pure>]\nlet freshEmptyList() = X<list<'T>>\n\n[<Inline>]\nlet freshTail (l: list<'T>) =\n    let t = freshEmptyList()\n    setTail l t\n    t\n\n[<Inline \"$l.$ == 1\">]\nlet notEmpty (l: list<_>) = X<bool>\n\n[<Name \"allPairs\">]\nlet AllPairs (l1: list<_>) (l2: list<_>) =\n    let arr1 = Array.ofList l1\n    let arr2 = Array.ofList l2\n    let res = Array.allPairs arr1 arr2\n    List.ofArray res\n\n[<Name \"append\">]\nlet Append (x: list<'T>) (y: list<'T>) = \n    if List.isEmpty x then y\n    elif List.isEmpty y then x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (unsafeHead l)\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r y |> ignore\n    res\n\n[<Inline>]\nlet inline Average (l: list<_>) = Seq.average l\n\n[<Inline>]\nlet inline AverageBy f (l: list<_>) = Seq.averageBy f l\n\n[<Name \"choose\">]\nlet Choose f (l: list<_>) = List.ofSeq (Seq.choose f l)\n\n[<Name \"collect\">]\nlet Collect (f: _ -> list<_>) (l: list<_>) = List.ofSeq (Seq.collect f l)\n\n[<Name \"concat\">]\nlet Concat (s: seq<list<_>>) = List.ofSeq (Seq.concat s)\n\n[<Inline>]\nlet Empty<'T> : list<'T> = []\n\n[<Name \"exists\">]\nlet Exists<'T> (p: 'T -> bool) (x: list<'T>) =\n    let mutable e = false\n    let mutable l = x\n    while not e && notEmpty l do\n        e <- p (unsafeHead l)\n        l <- unsafeTail l\n    e\n\n[<Name \"exists2\">]\nlet Exists2<'T1,'T2> (p : 'T1 -> 'T2 -> bool)\n                        (x1: list<'T1>)\n                        (x2: list<'T2>) =\n    let mutable e = false\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while not e && notEmpty l1 && notEmpty l2 do\n        e <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if not e && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    e\n\n[<Name \"filter\">]\nlet Filter<'T> (p: 'T -> bool) (l: list<'T>) =\n    List.ofSeq (Seq.filter p l)\n\n[<Inline>]\nlet Find p (l: list<_>) = Seq.find p l\n\n[<Inline>]\nlet FindIndex p (l: list<_>) = Seq.findIndex p l\n\n[<Inline>]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : 'S =\n    Seq.fold f s l\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (l1: list<'T1>)\n                        (l2: list<'T2>) : 'S =\n    Array.fold2 f s (Array.ofList l1) (Array.ofList l2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (l: list<_>) s =\n    Array.foldBack f (Array.ofList l) s\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (l1: list<_>) (l2: list<_>) s =\n    Array.foldBack2 f (Array.ofList l1) (Array.ofList l2) s\n\n[<Name \"forAll\">]\nlet ForAll p (x: list<_>) =\n    let mutable a = true\n    let mutable l = x\n    while a && notEmpty l do\n        a <- p (unsafeHead l)\n        l <- unsafeTail l\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 p (x1: list<_>) (x2: list<_>) =\n    let mutable a = true\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while a && notEmpty l1 && notEmpty l2 do\n        a <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if a && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    a\n\n[<Name \"head\">]\nlet Head (l: list<'T>) =\n    match l with \n    | h :: _ -> h\n    | _ -> listEmpty()\n\n[<Name \"init\">]\nlet Initialize s f = List.ofArray (Array.init s f)\n\n[<Inline \"$l.$ == 0\">]\nlet IsEmpty (l: list<_>) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (l: list<_>) =\n    let mutable r = l\n    while notEmpty r do\n        f r.Head\n        r <- r.Tail\n\n[<Name \"iter2\">]\nlet Iterate2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"iteri\">]\nlet IterateIndexed f (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        f i r.Head\n        r <- r.Tail\n        i <- i + 1\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    let mutable i = 0\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f i r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n        i <- i + 1\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"length\">]\nlet Length (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        r <- r.Tail\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T1 -> 'T2) (x: list<'T1>) = \n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (f (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r []\n    res\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (x1: list<'T1>) (x2: list<'T2>) (x3: list<'T3>) =\n    let mutable go = notEmpty x1 && notEmpty x2 && notEmpty x3\n    if not go then \n        if notEmpty x1 || notEmpty x2 || notEmpty x3 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable l3 = x3\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2) (unsafeHead l3))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        l3 <- unsafeTail l3\n        if notEmpty l1 && notEmpty l2 && notEmpty l3 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 || notEmpty l3 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T1 -> 'T2) (x: list<'T1>) =\n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable i = 0\n    let mutable go = true\n    while go do\n        setValue r (f i (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then \n            go <- false\n        else\n            r <- freshTail r\n            i <- i + 1\n    setTail r []\n    res\n\n[<Name \"mapi2\">]\nlet MapIndexed2 (f: int -> 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable i = 0\n    while go do\n        setValue r (f i (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n            i <- i + 1\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\nlet private nonEmpty (l: list<_>) =\n    if List.isEmpty l then\n        listEmpty()\n\n[<Name \"max\">]\nlet Max (list: list<_>) = \n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x > m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"maxBy\">]\nlet MaxBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Name \"min\">]\nlet Min (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        if x < m then\n            m <- x\n        l <- unsafeTail l\n    m\n\n[<Name \"minBy\">]\nlet MinBy f (list: list<_>) =\n    nonEmpty list\n    let mutable m = unsafeHead list\n    let mutable fm = f m\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        let x = unsafeHead l\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n        l <- unsafeTail l\n    m\n\n[<Inline>]\nlet Get (l: list<_>) ix = Seq.item ix l\n\n[<Inline>]\nlet Item ix (l: list<_>) = Seq.item ix l\n\n[<Name \"ofArray\">]\nlet OfArray<'T> (arr: 'T []) =\n    let mutable r = []\n    for i = arr.Length - 1 downto 0 do\n        r <- arr.[i] :: r\n    r\n\n[<Name \"ofSeq\">]\nlet OfSeq (s: seq<'T>) =\n    if s :? _ list then\n        As<'T list> s\n    elif s :? System.Array then\n        List.ofArray (As<'T[]> s)\n    else\n        use e = Enumerator.Get s\n        let mutable go = e.MoveNext()\n        if not go then [] else\n        let res = freshEmptyList()\n        let mutable r = res\n        while go do\n            setValue r e.Current\n            if e.MoveNext() then\n                r <- freshTail r\n            else    \n                go <- false\n        setTail r []\n        res\n\n[<Name \"partition\">]\nlet Partition p (l: list<_>) =\n    let (a, b) = Array.partition p (Array.ofList l)\n    (List.ofArray a, List.ofArray b)\n\n[<Name \"permute\">]\nlet Permute f (l: list<_>) =\n    List.ofArray (Array.permute f (Array.ofList l))\n\n[<Inline>]\nlet Pick f (l: list<_>) = Seq.pick f l\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (list: list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = unsafeHead list\n    let mutable l = unsafeTail list\n    while notEmpty l do\n        r <- f r (unsafeHead l)\n        l <- unsafeTail l\n    r\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (l: list<_>) =\n    Array.reduceBack f (Array.ofList l)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    List.ofArray (Array.create size value)\n\n[<Name \"rev\">]\nlet Reverse (l: list<'T>) =\n    let mutable res = []\n    let mutable r = l\n    while notEmpty r do\n        res <- unsafeHead r :: res\n        r <- unsafeTail r\n    res\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : list<'S> =\n    List.ofSeq (Seq.scan f s l)\n\n[<Name \"scanBack\">]\nlet ScanBack f (l: list<_>) s =\n    List.ofArray (Array.scanBack f (Array.ofList l) s)\n\n[<Name \"sort\">]\nlet Sort (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlace a\n    List.ofArray a\n\n[<Name \"sortBy\">]\nlet SortBy f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceBy f a\n    List.ofArray a\n\n[<Name \"sortByDescending\">]\nlet SortByDescending f (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending f a\n    List.ofArray a\n\n[<Name \"sortDescending\">]\nlet SortDescending (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending id a\n    List.ofArray a\n\n[<Name \"sortWith\">]\nlet SortWith f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceWith f a\n    List.ofArray a\n\n[<Inline>]\nlet inline Sum (l: list<'T>) : 'T = Seq.sum l\n\n[<Inline>]\nlet inline SumBy (f: 'T -> 'U) (l: list<'T>) : 'U = Seq.sumBy f l\n\n[<Name \"tail\">]\nlet Tail (l: list<'T>) = \n    match l with \n    | _ :: t -> t\n    | _ -> listEmpty()\n\n[<Inline>]\nlet ToArray (l: list<_>) = Array.ofList l\n\n[<Inline \"$x\">]\nlet ToSeq<'T> (x: list<'T>) : seq<'T> = x :> _\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<list<'T>>) : list<list<'T>> =\n    ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofList))\n    |> Seq.map List.ofArray |> List.ofSeq\n\n[<Inline>]\nlet TryFind p (l: list<_>) = Seq.tryFind p l\n\n[<Inline>]\nlet TryFindIndex p (l: list<_>) = Seq.tryFindIndex p l\n\n[<Inline>]\nlet TryPick p (l: list<_>) = Seq.tryPick p l\n\n[<Name \"unzip\">]\nlet Unzip (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    for (a, b) in l do\n        x.Enqueue a\n        y.Enqueue b\n    (List.ofArray (x.ToArray()), List.ofArray (y.ToArray()))\n\n[<Name \"unzip3\">]\nlet Unzip3 (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    let z = System.Collections.Generic.Queue<_>()\n    for (a, b, c) in l do\n        x.Enqueue a\n        y.Enqueue b\n        z.Enqueue c\n    (\n        List.ofArray (x.ToArray()),\n        List.ofArray (y.ToArray()),\n        List.ofArray (z.ToArray())\n    )\n\n[<Name \"zip\">]\nlet Zip (l1: list<_>) (l2: list<_>) =\n    List.map2 (fun x y -> x, y) l1 l2\n\n[<Name \"zip3\">]\nlet Zip3 (l1: list<_>) (l2: list<_>) (l3: list<_>) =\n    Map3 (fun x y z -> (x, y, z)) l1 l2 l3\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size list =\n    SeqChunkBySize size (List.toSeq list)\n    |> Seq.toList\n    |> List.map Array.toList\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (l1: list<'T>) (l2: list<'T>) : int =\n    Seq.compareWith f (List.toSeq l1) (List.toSeq l2)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (l: list<'T>) : list<'K * int> =\n    ArrayCountBy f (List.toArray l)\n    |> Array.toList\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: list<'T>) : list<'T> =\n    Seq.distinct (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (l: list<'T>) : list<'T> =\n    Seq.distinctBy f (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"splitInto\">]\nlet SplitInto count (list: list<'T>) =\n    ArraySplitInto count (List.toArray list)\n    |> Array.toList\n    |> List.map Array.toList\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (l: list<'T>) =\n    SeqExcept itemsToExclude l\n    |> Seq.toList\n\n[<Name \"tryFindBack\">]\nlet TryFindBack ok (l: list<_>) =\n    ArrayTryFindBack ok (Array.ofList l)\n\n[<Name \"findBack\">]\nlet FindBack p (s: list<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet TryFindIndexBack ok (l: list<_>) =\n    ArrayTryFindIndexBack ok (Array.ofList l) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: list<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (l: list<'T>) : list<'K * list<'T>> =\n    let arr = ArrayGroupBy f (List.toArray l)\n    arr |> mapInPlace (fun (k, s) -> (k, Array.toList s))\n    Array.toList (As arr)\n\n[<Name \"last\">]\nlet Last (list : list<'T>) : 'T =\n    nonEmpty list\n    let mutable r = list\n    let mutable t = unsafeTail r\n    while notEmpty t do\n        r <- t\n        t <- unsafeTail r\n    unsafeHead r\n\n[<Name \"contains\">]\nlet Contains (el: 'T) (x: list<'T>) =\n    let mutable c = false\n    let mutable l = x\n    while not c && notEmpty l do\n        c <- el = unsafeHead l\n        l <- unsafeTail l\n    c\n\n[<Name \"mapFold\">]\nlet MapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) zero list =\n    ArrayMapFold f zero (List.toArray list)\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T, 'S, 'R> f list zero =\n    ArrayMapFoldBack<'T, 'S, 'R> f (List.toArray list) zero\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"pairwise\">]\nlet Pairwise (l: list<'T>) : list<'T * 'T> =\n    Seq.pairwise (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"indexed\">]\nlet Indexed (list : list<'T>) : list<int * 'T> =\n    List.mapi (fun a b -> (a, b)) list\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [x]\n\n[<Inline>]\nlet Skip<'T> i (l : list<'T>) = ListSkip i l\n\n[<Inline>]\nlet SkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    ListSkipWhile predicate list\n\n[<Inline>]\nlet Take<'T> n (list: list<'T>) =\n    Seq.take n list |> List.ofSeq\n\n[<Inline>]\nlet TakeWhile<'T> (predicate : 'T -> bool) (list: list<'T>) =\n    Seq.takeWhile predicate list |> List.ofSeq\n\n[<Inline>]\nlet Truncate<'T> n (list: list<'T>) =\n    Seq.truncate n list |> List.ofSeq\n\n[<Name \"tryHead\">]\nlet TryHead<'T> (list: list<'T>) =\n    match list with\n    | head :: _ ->\n        Some head\n    | [] ->\n        None\n\n[<Inline>]\nlet TryItem<'T> n (list: list<'T>) =\n    SeqTryItem n list \n\n[<Inline>]\nlet TryLast<'T> (list: list<'T>) =\n    SeqTryLast list\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (list : 'T list) =\n    match list with\n    | head :: [] ->\n        head\n    | _ ->\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : list<'T> =\n    Seq.unfold f s\n    |> Seq.toList\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T list) : 'T list =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T list) : list<list<'T>> =\n    Seq.windowed windowSize (List.toSeq s)\n    |> Seq.map List.ofArray |> Seq.toList\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (list: 'T list) =\n    (Take n list, Skip n list)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Nullable =\n    let get (x: obj) =\n        if x ===. null then failwith \"Nullable object must have a value.\" else x\n\n////    let getOrDefault<'T> (x: 'T) =\n//        if x ==. null then Unchecked.defaultof<'T> else x     \n\n    let getOrValue<'T> (x: 'T) (v: 'T)  =\n        if x ===. null then v else x     \n\n[<Proxy(typeof<System.Nullable<_>>)>]\ntype private NullableProxy<'T> =\n    \n    [<Inline \"null\">]\n    new () = {}\n\n    [<Inline \"$v\">]\n    new (v: 'T) = {}\n\n    member this.Value \n        with [<JavaScript; Inline>] get(): 'T = As<'T>(Nullable.get this)\n\n    member this.HasValue\n        with [<JavaScript; Inline>] get() = this !=. null\n\n    [<Inline>]\n    member this.GetValueOrDefault() : 'T = Nullable.getOrValue (As<'T> this) Unchecked.defaultof<'T>\n\n    [<Inline>]\n    member this.GetValueOrDefault(v: 'T) : 'T = Nullable.getOrValue (As<'T> this) v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Operators\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorsProxy\n\n#nowarn \"86\"\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"range\">]\n[<Macro(typeof<M.Range>)>]\nlet ( .. ) (min: 'T) (max: 'T) : seq<'T> =\n    let count = 1 + As max - As min\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> As (x + As min))\n\n[<Name \"step\">]\nlet ( .. .. ) (min: 'T1) (step: 'T2) (max: 'T1) : seq<'T1> =\n    let s = sign (As<int> step)\n    Seq.initInfinite (fun k -> As<int> min + k * As<int> step)\n    |> Seq.takeWhile (fun k -> s * (As<int> max - As<int> k) >= 0)\n    |> As\n\n[<Inline \"$r[0]\">]\nlet ( ! ) (r: ref<'T>) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( % ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"$a & $b\">]\nlet ( &&& ) (a: 'T1) (b: 'T1) = X<'T1>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( * ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"Math.pow($a, $b)\">]\nlet ( ** ) (a: 'T1) (b: 'T2) = X<'T1>\n\n[<Inline \"Math.pow($a, $p)\">]\nlet PowInteger (a: 'T, p: int) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( + ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( - ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( / ) (x: 'T1) (y: 'T2) = X<'T3>\n\n[<Inline \"void ($a[0] = $b)\">]\nlet ( := ) (a: ref<'T>) (b: 'T) = X<unit>\n\n[<Inline>]\nlet ( << ) (f: 'T1 -> 'T2) (g: 'T3 -> 'T1) : 'T3 -> 'T2 = \n    ()\n    fun x -> f (g x)\n\n[<Inline \"$a << $b\">]\nlet inline ( <<< ) (a: 'T) (b: int) = X<'T>\n\n[<Inline>]\nlet ( <| ) (f: 'T -> 'TR) (x: 'T) : 'TR = f x\n\n[<Inline>]\nlet ( <|| ) (f: 'T1 -> 'T2 -> 'TR) (x: 'T1, y: 'T2) : 'TR = f x y\n\n[<Inline>]\nlet ( <||| ) (f: 'T1 -> 'T2 -> 'T3 -> 'TR)\n             (x: 'T1, y: 'T2, z: 'T3) : 'TR = f x y z\n\n[<Macro(typeof<M.Comp>)>]\nlet ( = ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <> ) (a: 'T) (b: 'T) =  X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( < ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( > ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( >= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Inline>]\nlet ( >> ) (f: 'T1 -> 'T2) (g: 'T2 -> 'T3): 'T1->'T3 = \n    ()\n    fun x -> g (f x)\n\n[<Inline \"$a >> $b\">]\nlet inline ( >>> ) (a: 'T) (b: int) : 'T = a >>> b\n\n[<Inline>]\nlet ( @ ) a b = List.append a b\n\n[<Inline \"$a + $b\">]\nlet ( ^ ) (a: string) (b: string) : string = a + b\n\n[<Inline \"$a ^ $b\">]\nlet ( ^^^ ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |> ) (x: 'T1) (f: 'T1 -> 'T2) : 'T2 = f x\n\n[<Inline>]\nlet ( ||> ) (x: 'T1, y: 'T2) (f: 'T1 -> 'T2 -> 'TR) : 'TR = f x y\n\n[<Inline \"$a | $b\">]\nlet ( ||| ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |||> ) (x: 'T1, y: 'T2, z: 'T3)\n             (f: 'T1 -> 'T2 -> 'T3 -> 'TR) : 'TR = f x y z\n\n[<Inline \"+ $x\">]\nlet ( ~+ ) (x: 'T) = X<'T>\n\n[<Inline \"- $x\">]\nlet ( ~- ) (x: 'T) = X<'T>\n\n[<Inline \"~ $x\">]\nlet ( ~~~ ) (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Abs>)>]\n[<Inline \"Math.abs($x)\">]\nlet Abs (x: 'T) = X<'T>\n\n[<Inline \"Math.acos($x)\">]\nlet Acos (x: 'T) = X<'T>\n\n[<Inline \"Math.asin($x)\">]\nlet Asin (x: 'T) = X<'T>\n\n[<Inline \"Math.atan($x)\">]\nlet Atan (x: 'T) = X<'T>\n\n[<Inline \"Math.atan2($x, $y)\">]\nlet Atan2 (x: 'T1) (y: 'T1) = X<'T2>\n\n[<Inline \"$x\">]\nlet Box (x: 'T) = X<obj>\n\n[<Inline \"Math.ceil($x)\">]\nlet Ceiling (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Char>)>]\nlet ToChar (x: 'T) = X<char>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToByte (x: 'T) = X<byte>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSByte (x: 'T) = X<sbyte>\n\n[<Inline>]\nlet Compare<'T> (a: 'T) (b: 'T) = Unchecked.compare a b\n\n[<Inline \"Math.cos($x)\">]\nlet Cos (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)+Math.exp(-$x))/2\">]\nlet Cosh<'T> (x: 'T) = X<'T>\n\n[<Inline \"void ($x[0]--)\">]\nlet Decrement (x: ref<int>) = ()\n\n[<Inline>]\nlet DefaultArg x d =\n    match x with\n    | Some x -> x\n    | None   -> d\n\n[<Inline>]\nlet DefaultValueArg x d =\n    match x with\n    | ValueSome x -> x\n    | ValueNone   -> d\n\n[<Inline \"$x\">]\nlet Enum<'T when 'T : enum<int>> (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDecimal (x: 'T) = X<decimal>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDouble (x: 'T) = X<double>\n\n[<Inline \"Math.exp($x)\">]\nlet inline Exp (x: 'T) = X<'T>\n\nlet FailWith (msg: string) : 'T = raise (exn msg)\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToFloat (x: 'T) = X<float>\n\n[<Inline \"Math.floor($x)\">]\nlet Floor (x: 'T) = X<'T>\n\n[<Inline \"$x[0]\">]\nlet Fst (x: TupleProxy<'T1,'T2>) = X<'T1>\n\n[<Inline>]\nlet Hash<'T when 'T : equality> (x: 'T) = Unchecked.hash x\n\n[<Inline \"$x\">]\nlet Identity (x: 'T) = X<'T>\n\n[<Inline \"void $x\">]\nlet Ignore (x: 'T) = X<unit>\n\n[<Inline \"void ($x[0]++)\">]\nlet Increment (x: ref<int>) = ()\n\n[<Inline \"Infinity\">]\nlet Infinity = Unchecked.defaultof<double>\n\nlet InvalidOp (msg: string) : 'T = raise (System.InvalidOperationException(msg))\n\nlet InvalidArg (arg: string) (msg: string) : 'T = raise (System.ArgumentException(arg, msg))\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt (x: 'T) = X<int>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt16 (x: 'T) = X<int16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSingle (x: 'T) = X<single>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt32 (x: 'T) = X<int32>\n\nlet toUInt (x: float) : int =\n    (if x < 0. then Math.Ceil(x) else Math.Floor(x)) >>>. 0 |> As<int>\n\nlet toInt (x: float) : int =\n    let u = toUInt x\n    if u >= As<int> 2147483648L then u - As<int> 4294967296L else u\n\n[<Inline \"$x\">]\nlet ToEnum<'T> (x: int) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt64 (x: 'T) = X<int64>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt16 (x: 'T) = X<uint16>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt32 (x: 'T) = X<uint32>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToUInt64 (x: 'T) = X<uint64>\n\n[<Inline \"Math.log($x)\">]\nlet Log (x: 'T) = X<'T>\n\n[<Inline \"Math.log($x)/Math.log(10)\">]\nlet Log10 (x: 'T) = X<'T>\n\n[<Inline>]\nlet Max<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a > b then a else b\n\n[<Inline>]\nlet Min<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a < b then a else b\n\n[<Inline \"Infinity\">]\nlet InfinitySingle = single infinity\n\n[<Inline \"NaN\">]\nlet NaNSingle = single nan\n\n[<Inline \"NaN\">]\nlet NaN = nan\n\n[<Inline \"!$x\">]\nlet Not (x: bool) = X<bool>\n\nlet Pown<'T> (a: 'T) (n: int) =\n    let a = box a :?> double\n    let rec p n =\n        match n with\n        | 1 ->\n            a\n        | n when n % 2 = 0 ->\n            let b = p (n / 2)\n            b * b\n        | n ->\n            a * (p (n - 1))\n    p n\n\n[<Inline \"throw $e\">]\nlet Raise (e: exn) = X<'T>\n\n[<Inline \"[$x]\">]\nlet Ref (x: 'T) = X<ref<'T>>\n\n[<Inline \"Math.round($x)\">]\nlet Round (x: 'T) = X<'T>\n\n[<Inline \"$x\">]\nlet CreateSequence (x: seq<'T>) = X<seq<'T>>\n\n[<Macro(typeof<M.Sign>); JavaScript>]\nlet Sign<'T> (x: 'T) =\n    match As<int> x with\n    | 0            -> 0\n    | n when n < 0 -> -1\n    | _            -> 1\n\n[<Inline \"Math.sin($x)\">]\nlet Sin (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)-Math.exp(-$x))/2\">]\nlet Sinh (x: 'T) = x\n\n[<Inline \"$x[1]\">]\nlet Snd (x: TupleProxy<'T1,'T2>) = X<'T2>\n\n[<Inline \"Math.sqrt($x)\">]\nlet Sqrt (x: 'T1) = X<'T2>\n\n[<Macro(typeof<M.String>)>]\nlet ToString (x: 'T) = X<string>\n\n[<Inline \"Math.tan($x)\">]\nlet inline Tan (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp(2*$x)-1)/(Math.exp(2*$x)+1)\">]\nlet Tanh (x: 'T) = X<'T>\n\nlet inline Truncate<'T> (x: 'T) =\n    if x <. 0 then Ceiling x else Floor x\n\n[<Inline \"$x\">]\nlet Unbox (x: obj) = X<'T>\n\n[<Inline \"$x == null\">]\nlet IsNull (x: 'T) = X<bool>\n\n[<Inline>]\nlet Using t f =\n    try f t finally (t :> System.IDisposable).Dispose()\n\n[<Name \"KeyValue\">]\nlet KeyValuePattern (kvp: System.Collections.Generic.KeyValuePair<_,_>) =\n    (kvp.Key, kvp.Value)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Slice\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+OperatorIntrinsics, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorIntrinsicsProxy \n\nopen WebSharper.JavaScript\n\n[<Inline \"$s.slice($st,$e)\">]\nlet Slice (s: 'T) (st: int) (e: int) = X<'T>\n\n[<Inline \"$s.slice($st)\">]\nlet SliceStart (s: 'T) (st: int) = X<'T>\n\n[<Name \"string\">]\nlet GetStringSlice (source: string) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> \"\"\n\n[<Name \"array\">]\nlet GetArraySlice<'T> (source: 'T[]) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> [||]\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Name \"setArray\">]\nlet SetArraySlice (dst: _[]) start finish (src:_[]) = \n    let start  = (match start with None -> 0 | Some n -> n) \n    let finish = (match finish with None -> Array.length dst - 1 | Some n -> n) \n    F.SetArraySub dst start (finish - start + 1) src\n\n[<Name \"array2D\">]\nlet GetArraySlice2D (arr: _[,]) start1 finish1 start2 finish2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let len2 = (finish2 - start2 + 1)\n    F.GetArray2DSub arr start1 start2 len1 len2\n\n[<Name \"array2Dfix1\">]\nlet GetArraySlice2DFixed1 (arr: _[,]) fixed1 start2 finish2 = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    let dst = JavaScript.Array(len2)\n    for j = 0 to len2 - 1 do \n        F.SetArray dst.Self j (F.GetArray2D arr fixed1 (start2+j))\n    dst.Self\n\n[<Name \"array2Dfix2\">]\nlet GetArraySlice2DFixed2 (arr: _[,]) start1 finish1 fixed2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let dst = JavaScript.Array(len1)\n    for i = 0 to len1 - 1 do \n        F.SetArray dst.Self i (F.GetArray2D arr (start1+i) fixed2)\n    dst.Self\n\n[<Name \"setArray2Dfix1\">]\nlet SetArraySlice2DFixed1 (dst: _[,]) fixed1 start2 finish2 (src:_[]) = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    for j = 0 to len2 - 1 do\n        F.SetArray2D dst fixed1 (start2+j) (F.GetArray src j)\n\n[<Name \"setArray2Dfix2\">]\nlet SetArraySlice2DFixed2 (dst: _[,]) start1 finish1 fixed2 (src:_[]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    for i = 0 to len1 - 1 do\n        F.SetArray2D dst (start1+i) fixed2 (F.GetArray src i)\n\n[<Name \"setArray2D\">]\nlet SetArraySlice2D (dst: _[,]) start1 finish1 start2 finish2 (src:_[,]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    F.SetArray2DSub dst start1 start2 (finish1 - start1 + 1) (finish2 - start2 + 1) src\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Option\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.OptionModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OptionModuleProxy\n\nopen WebSharper.JavaScript\n\n[<Inline>]\nlet Bind f x =\n    match x with\n    | Some x -> f x\n    | None   -> None\n\n[<Inline>]\nlet Contains v o =\n    match o with\n    | Some x -> x = v\n    | None -> false\n\n[<Inline \"$x ? 1 : 0\">]\nlet Count (x: option<_>) = X<int>\n\n[<Inline>]\nlet DefaultValue v o =\n    match o with\n    | Some x -> x \n    | None -> v\n\n[<Inline>]\nlet DefaultWith f o =\n    match o with\n    | Some x -> x \n    | None -> f()\n\n[<Inline>]\nlet Exists p x =\n    match x with\n    | Some x -> p x\n    | None   -> false\n\n[<Name \"filter\">]\nlet Filter f o =\n    match o with\n    | Some x when f x -> o\n    | _ -> None\n\n[<Inline>]\nlet Flatten o =\n    match o with\n    | Some x -> x\n    | None -> None\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (x: option<'T>) : 'S =\n    match x with\n    | Some x -> f s x\n    | None   -> s\n\n[<Name \"foldBack\">]\nlet FoldBack f x s =\n    match x with\n    | Some x -> f x s\n    | None   -> s\n\n[<Inline>]\nlet ForAll p x =\n    match x with\n    | Some x -> p x\n    | None   -> true\n\n[<Inline \"$x.$0\"; Pure>]\nlet GetValue (x: option<'T>) = X<'T>\n\n[<Inline \"$x==null\">]\nlet IsNone (x: option<'T>) = false\n\n[<Inline \"$x!=null\">]\nlet IsSome (x: option<'T>) =  false\n\n[<Inline>]\nlet Iterate p x =\n    match x with\n    | Some x -> p x\n    | None   -> ()\n\n[<Inline>]\nlet Map f x =\n    match x with\n    | Some x -> Some (f x)\n    | None -> None\n\n[<Inline>]\nlet Map2 f x y =\n    match x, y with\n    | Some x, Some y -> Some (f x y)\n    | _ -> None\n\n[<Inline>]\nlet Map3 f x y z =\n    match x, y, z with\n    | Some x, Some y, Some z -> Some (f x y z)\n    | _ -> None\n\n[<Name \"ofNullable\">]\nlet OfNullable (o: System.Nullable<'T>) =\n    if o ==. null then None else Some o.Value                   \n\n[<Name \"ofObj\">]\nlet OfObj o = \n    if o ==. null then None else Some o\n\n[<Inline>]\nlet OrElse v o =\n    match o with\n    | Some x -> o \n    | None -> v\n\n[<Inline>]\nlet OrElseWith f o =\n    match o with\n    | Some x -> o \n    | None -> f()\n\n[<Name \"toArray\">]\nlet ToArray x =\n    match x with\n    | Some x -> [|x|]\n    | None   -> [||]\n\n[<Name \"toList\">]\nlet ToList x =\n    match x with\n    | Some x -> [x]\n    | None   -> []\n\n[<Name \"toNullable\">]\nlet ToNullable o =\n    match o with\n    | Some v -> System.Nullable(v)\n    | _ -> System.Nullable()\n\n[<Name \"toObj\">]\nlet ToObj o = \n    match o with\n    | Some v -> v\n    | None -> null\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Queue\">]\nmodule private WebSharper.QueueProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (a: obj) =\n    splice a 0 (a :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (a: obj) (el: 'T) =\n    Seq.exists ((=) el) (a :?> seq<'T>)\n\n[<JavaScript>]\nlet CopyTo (a: obj) (array: 'T[]) (index: int) =\n    Array.blit (a :?> 'T []) 0 array index (a :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Queue<_>>)>]\n[<WebSharper.Name \"WebSharper.Queue\">]\ntype private QueueProxy<'T when 'T : equality>\n\n    [<Inline \"$data\">] private (data: 'T []) =\n\n    [<Inline \"[]\">]\n    private new () = QueueProxy [||]\n\n    [<Inline>]\n    private new (s: seq<'T>) = QueueProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index: int) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Dequeue() = X<'T>\n\n    [<Inline \"$this.push($x)\">]\n    member this.Enqueue(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = data\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule RandomHelpers =\n    [<Inline \"Math.floor(Math.random() * 2147483648)\">]\n    let Next() = X<int>\n    \n    [<Inline \"Math.floor(Math.random() * $maxValue)\">]\n    let NextMax (maxValue: int) = X<int>\n\n[<Name \"Random\">]\n[<Proxy(typeof<System.Random>)>]\ntype internal RandomProxy() =\n    member this.Next() = Next()\n\n    member this.Next maxValue =\n        if maxValue < 0 then\n            failwith \"'maxValue' must be greater than zero.\"\n        else NextMax maxValue\n\n    member this.Next (minValue: int, maxValue: int) =\n        if minValue > maxValue then\n            failwith \"'minValue' cannot be greater than maxValue.\"\n        else minValue + NextMax (maxValue - minValue)\n\n    member this.NextBytes (buffer: byte[]) =\n        for i = 0 to buffer.Length - 1 do\n            buffer.[i] <- As (NextMax 256)\n\n    [<Inline \"Math.random()\">]\n    member this.NextDouble() = X<float>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Result\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ResultModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ResultModuleProxy\n    \nlet Bind f r =\n    match r with\n    | Ok x -> f x\n    | Error e -> Error e\n        \nlet Map f r =\n    match r with\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n        \nlet MapError f r =\n    match r with\n    | Ok x -> Ok x\n    | Error e -> Error (f e)    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.RuntimeHelpersProxy\n\n#nowarn \"40\"\n\nopen WebSharper.JavaScript\n\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"WebSharper.Seq.enumFinally\">]\nlet EnumerateThenFinally (s: seq<'T>) (f: unit -> unit) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get s with e -> f(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); f()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumUsing\">]\nlet EnumerateUsing<'T1,'T2,'T3 when 'T1 :> System.IDisposable\n                                and 'T2 :> seq<'T3>>\n        (x: 'T1) (f: 'T1 -> 'T2) : seq<'T3> =\n\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get (f x) with e -> x.Dispose(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); x.Dispose()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumWhile\">]\nlet EnumerateWhile (f: unit -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let rec next (en: Enumerator.T<IE<_>,'T>) =\n            match en.State with\n            | null ->\n                if f () then\n                    en.State <- Enumerator.Get s\n                    next en\n                else\n                    false\n            | e ->\n                if e.MoveNext() then\n                    en.Current <- e.Current\n                    true\n                else\n                    e.Dispose()\n                    en.State <- null\n                    next en\n        Enumerator.NewDisposing null (fun en -> safeDispose en.State) next)\n\n[<Name \"WebSharper.Control.createEvent\">]\nlet CreateEvent<'D, 'A when 'D : delegate<'A, unit> and 'D :> System.Delegate> \n        (add: 'D -> unit) \n        (remove: 'D -> unit)\n        (create: (obj -> 'A -> unit) -> 'D) : IEvent<'D, 'A> =\n    { new IEvent<'D, 'A> with\n        member this.AddHandler h = add h\n        member this.RemoveHandler h = remove h\n        member this.Subscribe (r: System.IObserver<'A>) =     \n            let h = create (fun _ args -> r.OnNext(args))\n            add h\n            { new System.IDisposable with member this.Dispose() = remove h }\n    }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Seq\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.SeqModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.SeqModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\nlet seqEmpty() =\n    failwith \"The input sequence was empty.\"\n\n[<Name \"allPairs\">]\nlet AllPairs (source1: seq<_>) (source2: seq<_>) =\n    let cached = Seq.cache source2\n    source1 |> Seq.collect (fun x -> cached |> Seq.map (fun y -> x,y))\n\n[<Name \"append\">]\nlet Append (s1: seq<'T>) (s2: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let e1 = Enumerator.Get s1\n        let first = ref true\n        Enumerator.NewDisposing e1 (fun x -> safeDispose x.State) (fun x ->\n            if x.State.MoveNext() then\n                x.Current <- x.State.Current\n                true\n            else \n                safeDispose x.State\n                x.State <- null\n                if !first then\n                    first := false\n                    x.State <- Enumerator.Get s2\n                    if x.State.MoveNext() then\n                        x.Current <- x.State.Current\n                        true\n                    else\n                        x.State.Dispose()\n                        x.State <- null\n                        false\n                else \n                    false)) \n\n[<Name \"average\">]\nlet Average<'T> (s: seq<'T>) : 'T =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> x))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'T> (sum / As<float> count)\n\n[<Name \"averageBy\">]\nlet AverageBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> (f x)))\n            (0, 0.)\n            s\n    if count = 0 then\n        seqEmpty()\n    else\n        As<'U> (sum / As<float> count)\n\n[<Name \"cache\">]\nlet Cache<'T> (s: seq<'T>) : seq<'T> =\n    let cache = JavaScript.Array<'T>()\n    let o  = ref (Enumerator.Get s)\n    Enumerable.Of <| fun () ->\n        let next (e: Enumerator.T<_,_>) =\n            if e.State < cache.Length then\n                e.Current <- cache.[e.State]\n                e.State   <- e.State + 1\n                true\n            else\n                let en = !o\n                if en = null then false\n                elif en.MoveNext() then\n                    e.State   <- e.State + 1\n                    e.Current <- en.Current\n                    cache.Push(e.Current) |> ignore\n                    true\n                else\n                    en.Dispose()\n                    o := null\n                    false\n        Enumerator.New 0 next\n\n/// IEnumerable is not supported.\n[<Inline \"$i\">]\nlet Cast<'T> (i: System.Collections.IEnumerable) = X<seq<'T>>\n\n[<Inline>]\nlet Contains (el: 'T) (s: seq<'T>) =\n    SeqContains el s\n\n[<Name \"choose\">]\nlet Choose (f: 'T -> option<'U>) (s: seq<'T>) : seq<'U> =\n    s\n    |> Seq.collect (fun x ->\n        match f x with\n        | Some v -> [v]\n        | None   -> [])\n\n[<Inline>]\nlet ChunkBySize (size: int) (s: seq<'T>) = SeqChunkBySize size s\n\n[<Name \"collect\">]\nlet Collect f s = Seq.concat (Seq.map f s)\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (s1: seq<'T>) (s2: seq<'T>) : int =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = 0\n    let mutable loop = true\n    while loop && r = 0 do\n        match e1.MoveNext(), e2.MoveNext() with\n        | true, false ->\n            r <- 1\n        | false, true ->\n            r <- -1\n        | false, false ->\n            loop <- false\n        | true, true ->\n            r <- f e1.Current e2.Current\n    r\n\n[<Name \"concat\">]\nlet Concat (ss: seq<#seq<'T>>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let outerE = Enumerator.Get ss\n        let rec next (st: Enumerator.T<Enumerator.IE<'T>,'T>) =\n            match st.State with\n            | null ->\n                if outerE.MoveNext() then\n                    st.State <- Enumerator.Get outerE.Current\n                    next st\n                else\n                    outerE.Dispose()\n                    false\n            | innerE ->\n                if innerE.MoveNext() then\n                    st.Current <- innerE.Current\n                    true\n                else\n                    (st :> System.IDisposable).Dispose()\n                    st.State <- null\n                    next st\n        Enumerator.NewDisposing null (fun st -> \n            safeDispose st.State \n            safeDispose outerE) \n            next)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (s: seq<'T>) : seq<'K * int> =\n    Seq.delay <| fun () ->\n        ArrayCountBy f (Array.ofSeq s) |> Seq.ofArray\n\n[<Name \"delay\">]\nlet Delay<'T> (f: unit -> seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get(f()))\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (s: seq<'T>) : seq<'T> =\n    Seq.distinctBy id s\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet<'K>()\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(f cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(f cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"splitInto\">]\nlet SplitInto count (s: seq<'T>) =\n    if count <= 0 then failwith \"Count must be positive\"\n    Seq.delay (fun () -> ArraySplitInto count (Array.ofSeq s) |> Seq.ofArray)   \n\n[<Inline>]\nlet Empty<'T> : seq<'T> = As [||]\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne<'T> (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then\n        let x = e.Current\n        if e.MoveNext() then\n            invalidOp \"Sequence contains more than one element\"\n        else x\n    else invalidOp \"Sequence contains no elements\"\n\n[<Inline>]\nlet Except (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    SeqExcept itemsToExclude s\n\n[<Name \"exists\">]\nlet Exists p (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- p e.Current\n    r\n\n[<Name \"exists2\">]\nlet Exists2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = false\n    while not r && e1.MoveNext() && e2.MoveNext() do\n        r <- p e1.Current e2.Current\n    r\n\n[<Name \"filter\">]\nlet Filter (f: 'T -> bool) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            let mutable loop = o.MoveNext()\n            let mutable c    = o.Current\n            let mutable res  = false\n            while loop do\n                if f c then\n                    e.Current <- c\n                    res       <- true\n                    loop      <- false\n                else\n                    if o.MoveNext() then\n                        c <- o.Current\n                    else\n                        loop <- false\n            res\n\n[<Name \"find\">]\nlet Find p (s: seq<_>) =\n    match Seq.tryFind p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex p (s: seq<_>) =\n    match Seq.tryFindIndex p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : 'S =\n    let mutable r = x\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"forall\">]\nlet ForAll p s =\n    not (Seq.exists (fun x -> not (p x)) s)\n\n[<Name \"forall2\">]\nlet ForAll2 p s1 s2 =\n    not (Seq.exists2 (fun x y -> not (p x y)) s1 s2)\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality) (s: seq<'T>) : seq<'K * seq<'T>> =\n    Seq.delay <| fun () ->\n        ArrayGroupBy f (Array.ofSeq s) |> As\n\n[<Name \"head\">]\nlet Head (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if e.MoveNext() then e.Current else InsufficientElements()\n\n[<Name \"init\">]\nlet Initialize (n: int) (f: int -> 'T) : seq<'T> =\n    Seq.take n (Seq.initInfinite f)\n\n[<Name \"initInfinite\">]\nlet InitializeInfinite (f: int -> 'T) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New 0 <| fun e ->\n            e.Current <- f e.State\n            e.State   <- e.State + 1\n            true\n\n[<Name \"isEmpty\">]\nlet IsEmpty (s: seq<'T>) : bool =\n    use e = Enumerator.Get s\n    not (e.MoveNext())\n\n[<Name \"iter\">]\nlet Iterate p (s: seq<_>) =\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p e.Current\n\n[<Name \"iter2\">]\nlet Iterate2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        p e1.Current e2.Current\n\n[<Name \"iteri\">]\nlet IterateIndexed p (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p i e.Current\n        i <- i + 1\n\n[<Inline>]\nlet Last (s: seq<_>) =\n    SeqLast s\n\n[<Name \"length\">]\nlet Length (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> en.Dispose()) <| fun e ->\n            if en.MoveNext() then\n                e.Current <- f en.Current\n                true\n            else\n                false\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Seq.map2 f (Seq.initInfinite id) s\n\n[<Name \"map2\">]\nlet Map2 (f: 'T -> 'U -> 'V) (s1: seq<'T>) (s2: seq<'U>) : seq<'V> =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() then\n                e.Current <- f e1.Current e2.Current\n                true\n            else\n                false\n\n[<Name \"maxBy\">]\nlet MaxBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx > fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"minBy\">]\nlet MinBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    let mutable fm = f m\n    while e.MoveNext() do\n        let x = e.Current\n        let fx = f x\n        if fx < fm then\n            m <- x\n            fm <- fx\n    m\n\n[<Name \"max\">]\nlet Max (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x > m then\n            m <- x\n    m\n\n[<Name \"min\">]\nlet Min (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable m = e.Current\n    while e.MoveNext() do\n        let x = e.Current\n        if x < m then\n            m <- x\n    m\n\n[<Name \"nth\">]\nlet Get index (s: seq<'T>) =\n    if index < 0 then\n        failwith \"negative index requested\"\n    let mutable pos = -1\n    use e = Enumerator.Get s\n    while pos < index do\n        if not (e.MoveNext()) then\n            InsufficientElements()\n        pos <- pos + 1\n    e.Current\n\n[<Inline>]\nlet Item index (s: seq<'T>) = Get index s\n\n[<Inline \"$a\">]\n[<Name \"ofArray\">]\nlet OfArray (a: 'T[]) = X<seq<'T>>\n\n[<Inline \"$l\">]\n[<Name \"ofList\">]\nlet OfList (l: list<'T>) = X<seq<'T>>\n\n[<Name \"pairwise\">]\nlet Pairwise (s: seq<'T>) : seq<'T * 'T> =\n    Seq.windowed 2 s\n    |> Seq.map (fun x -> (x.[0], x.[1]))\n\n[<Name \"pick\">]\nlet Pick p (s: seq<_>) =\n    match Seq.tryPick p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"readOnly\">]\nlet ReadOnly (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get s)\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (source: seq<'T>) : 'T =\n    use e = Enumerator.Get source\n    if not (e.MoveNext()) then\n        seqEmpty()\n    let mutable r = e.Current\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : seq<'S> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing false (fun _ -> en.Dispose()) <| fun e ->\n            if e.State then\n                if en.MoveNext() then\n                    e.Current <- f e.Current en.Current\n                    true\n                else\n                    false\n            else\n                e.Current <- x\n                e.State <- true\n                true\n\n[<Inline \"[$x]\">]\n[<Name \"singleton\">]\nlet Singleton<'T> (x: 'T) = X<seq<'T>>\n\n[<Name \"skip\">]\nlet Skip (n: int) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                for i = 1 to n do\n                    if not (o.MoveNext()) then\n                        InsufficientElements()\n                e.State <- false\n            if o.MoveNext() then\n                e.Current <- o.Current\n                true\n            else\n                false))\n\n[<Name \"skipWhile\">]\nlet SkipWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                let mutable go = true\n                let mutable empty = false\n                while go do\n                    if o.MoveNext() then\n                        if not (f o.Current) then go <- false \n                    else \n                        go <-false\n                        empty <- true\n                e.State <- false\n                if empty then \n                    false \n                else\n                    e.Current <- o.Current\n                    true\n            else\n                if o.MoveNext() then\n                    e.Current <- o.Current\n                    true\n                else\n                    false))\n\n[<Name \"sort\">]\nlet Sort<'T when 'T : comparison> (s: seq<'T>) =\n    Seq.sortBy id s\n\n[<Name \"sortBy\">]\nlet SortBy<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        Array.sortInPlaceBy f array\n        array :> _)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        ArraySortInPlaceByDescending f array\n        array :> _)\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T : comparison> (s: seq<'T>) =\n    SortByDescending id s\n\n[<Name \"sum\">]\nlet Sum<'T> (s: seq<'T>) : 'T =\n    box (Seq.fold (fun s x -> s + (box x :?> _)) 0. s) :?> _\n\n[<Name \"sumBy\">]\nlet SumBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    box (Seq.fold (fun s x -> s + (box (f x) :?> _)) 0. s) :?> _\n\n[<Name \"take\">]\nlet Take (n: int) (s: seq<'T>) : seq<'T> =\n    if n < 0 then\n        InputMustBeNonNegative()\n    Enumerable.Of (fun () ->\n        let e = ref (Enumerator.Get s)\n        Enumerator.NewDisposing 0 (fun _ -> safeDispose !e) (fun o ->\n            o.State <- o.State + 1\n            if o.State > n then false else\n            let en = !e\n            if en = null then InsufficientElements()\n            elif en.MoveNext() then\n                o.Current <- en.Current\n                if o.State = n then\n                    en.Dispose()\n                    e := null\n                true\n            else\n                en.Dispose()\n                e := null\n                InsufficientElements()\n        )\n    )\n\n[<Name \"takeWhile\">]\nlet TakeWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        while e.MoveNext() && f e.Current do\n            yield e.Current\n    }\n\n[<Inline>]\nlet ToArray (s: seq<'T>) =\n    Array.ofSeq s\n\n[<Inline>]\nlet ToList (s: seq<'T>) = List.ofSeq s\n\n[<Name \"transpose\">]\nlet Transpose (x: seq<#seq<'T>>) : seq<seq<'T>> =\n    Seq.delay (fun () ->\n        ArrayTranspose (Array.ofSeq (x |> Seq.map Array.ofSeq)) |> As\n    )\n\n[<Name \"truncate\">]\nlet Truncate (n: int) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        let i = ref 0\n        while e.MoveNext() && !i < n do\n            incr i\n            yield e.Current\n    }\n\n[<Name \"tryFind\">]\nlet TryFind ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r.IsNone && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            r <- Some x\n    r\n\n[<Inline>]\nlet TryFindBack ok (s: seq<_>) =\n    ArrayTryFindBack ok (Array.ofSeq s) \n\n[<Inline>]\nlet TryHead (s: seq<'T>) = SeqTryHead s\n\n[<Inline>]\nlet TryItem i (s: seq<'T>) = SeqTryItem i s\n\n[<Inline>]\nlet TryLast (s: seq<'T>) =  SeqTryLast s\n\n[<Name \"findBack\">]\nlet FindBack p (s: seq<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable loop = true\n    let mutable i = 0\n    while loop && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            loop <- false\n        else\n            i <- i + 1\n    if loop then None else Some i\n\n[<Inline>]\nlet TryFindIndexBack ok (s: seq<_>) =\n    ArrayTryFindIndexBack ok (Array.ofSeq s) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: seq<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryPick\">]\nlet TryPick f (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r = None && e.MoveNext() do\n        r <- f e.Current\n    r\n\n[<Name \"unfold\">]\nlet Unfold<'S, 'T> (f: 'S -> option<'T * 'S>) (s: 'S) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New s <| fun e ->\n            match f e.State with\n            | Some (t, s) ->\n                e.Current <- t\n                e.State  <- s\n                true\n            | None ->\n                false\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: seq<'T>) : seq<'T []> =\n    if windowSize <= 0 then\n        failwith \"The input must be positive.\"\n    seq {\n        use e = Enumerator.Get s\n        let q = new System.Collections.Generic.Queue<'T>()\n        while q.Count < windowSize && e.MoveNext() do\n            q.Enqueue e.Current\n        if q.Count = windowSize then\n            yield q.ToArray()\n            while e.MoveNext() do\n                ignore (q.Dequeue())\n                q.Enqueue e.Current\n                yield q.ToArray()\n    }\n\n[<Name \"zip\">]\nlet Zip (s1: seq<'T>) (s2: seq<'U>) =\n    Seq.map2 (fun x y -> x, y) s1 s2\n\n[<Name \"map3\">]\nlet Map3 f (s1: seq<_>) (s2: seq<_>) (s3: seq<_>) =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        let e3 = Enumerator.Get s3\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose(); e3.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() && e3.MoveNext() then\n                e.Current <- f e1.Current e2.Current e3.Current\n                true\n            else\n                false\n\n[<Name \"zip3\">]\nlet Zip3 (s1: seq<'T>) (s2: seq<'U>) (s3: seq<'V>) : seq<'T * 'U * 'V> =\n    Map3 (fun x y z -> x, y, z) s1 s2 s3\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (s1: seq<'T1>)\n                        (s2: seq<'T2>) : 'S =\n    Array.fold2 f s (Array.ofSeq s1) (Array.ofSeq s2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (s: seq<_>) state =\n    Array.foldBack f (Array.ofSeq s) state\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (s1: seq<_>) (s2: seq<_>) s =\n    Array.foldBack2 f (Array.ofSeq s1) (Array.ofSeq s2) s\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    let mutable i = 0\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        f i e1.Current e2.Current\n        i <- i + 1\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    Map3 f (Seq.initInfinite id) s1 s2\n\n[<Name \"mapFold\">]\nlet MapFold<'T,'S,'R> f zero s =\n    ArrayMapFold<'T,'S,'R> f zero (Seq.toArray s)\n    |> As<seq<'R> * 'S>\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T,'S,'R> f s zero =\n    ArrayMapFoldBack<'T,'S,'R> f (Seq.toArray s) zero\n    |> As<seq<'R> * 'S>\n\n[<Name \"permute\">]\nlet Permute f (s: seq<_>) =\n    Seq.delay (fun () -> Seq.ofArray (Array.permute f (Array.ofSeq s)))\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (s: seq<_>) =\n    Array.reduceBack f (Array.ofSeq s)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    if size < 0 then InputMustBeNonNegative()\n    seq { for i in 0 .. size - 1 -> value }\n\n[<Name \"rev\">]\nlet Reverse (s: seq<'T>) =\n    Seq.delay (fun () -> Array.rev (Seq.toArray s) |> Array.toSeq)\n    \n[<Name \"scanBack\">]\nlet ScanBack f (l: seq<_>) s =\n    Seq.delay (fun () -> Seq.ofArray (Array.scanBack f (Array.ofSeq l) s))\n\n[<Name \"indexed\">]\nlet Indexed (s : seq<'T>) : seq<int * 'T> =\n    Seq.mapi (fun a b -> (a, b)) s\n\n[<Name \"sortWith\">]\nlet SortWith f (s: seq<_>) =\n    Seq.delay (fun () -> \n        let a = Array.ofSeq s\n        Array.sortInPlaceWith f a\n        Seq.ofArray a)\n\n[<Name \"tail\">]\nlet Tail<'T> (s : seq<'T>) : seq<'T> =\n    Seq.skip 1 s\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : seq<'T>) : seq<'T> =\n    Filter predicate s\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Stack\">]\nmodule private WebSharper.StackProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (stack: obj) =\n    splice stack 0 (stack :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (stack: obj) (el: 'T) =\n    Seq.exists ((=) el) (stack :?> 'T[])\n    \n[<JavaScript>]\nlet CopyTo (stack: obj) (array: 'T[]) (index: int) =\n    Array.blit array 0 array index (stack :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Stack<_>>)>]\n[<Name \"WebSharper.Stack\">]\ntype private StackProxy<'T when 'T : equality> =\n\n    [<Inline \"[].concat($s).reverse()\">]\n    private new (s: 'T []) = {}\n\n    [<Inline \"[]\">]\n    new () = {}\n\n    [<Inline>]\n    private new (s: seq<'T>) = StackProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) : bool = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Pop() = X<'T>\n\n    [<Inline \"$this.unshift($x)\">]\n    member this.Push(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = X<'T[]>\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Strings\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.StringModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.StringProxy\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\nlet Compare (x: string) (y: string) = compare x y\n\nlet CopyTo (s: string) (o: int) (d: char []) (off: int) (ct: int) =\n    Array.blit (s.ToCharArray()) o d off ct\n\n[<Direct \"$x.substring($x.length - $s.length) == $s\">]\nlet EndsWith (x: string) (s: string) = X<bool>\n\n[<Direct \"$s.indexOf($c,$i)\">]\nlet IndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$x.substring(0,$index-1)+$s+$x.substring($index)\">]\nlet Insert (x: string) (index: int) (s: string) = X<string>\n\n[<Direct \"$x == null || $x == ''\">]\nlet IsNullOrEmpty (x: string) = X<bool>\n\n[<Direct \"\"\"$x == null || /^\\s*$/.test($x)\"\"\">]\nlet IsNullOrWhiteSpace (x: string) = X<bool>\n\n[<Direct \"$s.lastIndexOf($c,$i)\">]\nlet LastIndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$n>$s.length?Array($n-$s.length+1).join($c)+$s:$s\">]\nlet PadLeftWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadLeft (s: string) (n: int) =\n    PadLeftWith s n ' '\n\n[<Direct \"$n>$s.length?$s+Array($n-$s.length+1).join($c):$s\">]\nlet PadRightWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadRight (s: string) (n: int) =\n    PadRightWith s n ' '\n\n[<Direct \"$x.substring(0,$ix) + $x.substring($ix+$ct)\">]\nlet Remove (x: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$string.replace($search,$replace)\">]\nlet ReplaceOnce string search replace = X<string>\n\nlet Replace (subject: string) (search: string) (replace: string) =\n    let rec replaceLoop (subj: string) =\n        let index = subj.IndexOf(search)\n        if index <> -1 then\n            let replaced = ReplaceOnce subj search replace\n            let nextStartIndex = index + replace.Length\n            (replaced.Substring(0, index + replace.Length)) +\n                (replaceLoop (replaced.Substring(nextStartIndex)))\n        else subj\n    replaceLoop subject\n\nlet ReplaceChar (s: string) (oldC: char) (newC: char) =\n    Replace s (string oldC) (string newC)\n\n[<Direct \"$s.substr($ix,$ct)\">]\nlet Substring (s: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$t.substring(0,$s.length) == $s\">]\nlet StartsWith (t: string) (s: string) = X<bool>\n\nlet ToCharArray (s: string) = Array.init s.Length (fun x -> s.[x])\n\nlet ToCharArrayRange (s: string) (startIndex: int) (length: int) =\n    Array.init length (fun i -> s.[startIndex + i])\n\n[<Direct @\"$s.replace(/^\\s+/,'').replace(/\\s+$/,'')\">]\nlet Trim (s: string) = X<string>\n\n[<Direct @\"$s.replace(/^\\s+/,'')\">]\nlet TrimStartWS (s: string) = X<string>\n\nlet TrimStart (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimStartWS s\n    else\n        let mutable i = 0\n        let mutable go = true\n        while i < s.Length && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i + 1 \n            else go <- false\n        s.Substring(i)\n\n[<Direct @\"$s.replace(/\\s+$/,'')\">]\nlet TrimEndWS (s: string) = X<string>\n\nlet TrimEnd (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimEndWS s\n    else \n        let mutable i = s.Length - 1\n        let mutable go = true\n        while i >= 0 && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i - 1 \n            else go <- false\n        s.Substring(0, i + 1)\n\n[<Direct \"$values.join($sep)\">]\nlet Join (sep: string) (values: string []) = X<string>\n\n[<Direct \"$str.split($pat)\">]\nlet SplitWith (str: string) (pat: obj) = X<string[]>\n\n[<Inline \"new RegExp($pat)\">]\nlet MakeRegexp (pat: string) = X<obj>\n\n[<Direct @\"$s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\">]\nlet RegexEscape (s: string) = X<string>\n\nlet Split (s: string) (pat: obj) (opts: System.StringSplitOptions) =\n    let res = SplitWith s pat\n    if opts ===. System.StringSplitOptions.RemoveEmptyEntries then\n        Array.filter (fun x -> x !==. \"\") res\n    else\n        res\n\nlet SplitChars (s: string) (sep: char[]) (opts: System.StringSplitOptions) =\n    let re = \"[\" + RegexEscape (new System.String(sep)) + \"]\"\n    Split s (MakeRegexp re) opts\n\nlet SplitStrings (s: string) (sep: string[]) (opts: System.StringSplitOptions) =\n    let re = String.concat \"|\" (Array.map RegexEscape sep)\n    Split s (MakeRegexp re) opts\n\nlet Filter f (s: string) =\n    System.String.Concat(s |> Seq.choose (fun c -> if f c then Some (string c) else None) |> Array.ofSeq)\n\n[<Inline \"$text.replace($pattern, $replace)\">]\nlet ReplaceString (pattern: RegExp) (replace: 'obj) (text: string) = X<string>\n\nlet SFormat (format: string) (args: obj[]) =\n    let pattern = RegExp(\"{(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?}\", \"g\")\n    format\n    |> ReplaceString pattern (FuncWithArgs(fun (_, i, w) ->\n        let r = string args.[JS.Plus i]\n\n        if w <> JS.Undefined then\n            let w1 = JS.Plus w\n            let w2 = abs w1\n\n            if w2 > r.Length then\n                if w1 > 0 then r.PadLeft(w2)\n                else r.PadRight(w2)\n            else r\n        else r\n    ))\n\n[<Proxy(typeof<string>)>]\ntype private StringProxy =\n\n    [<Inline \"''\">]\n    new () = {}\n\n    [<Inline \"$chars.join('')\">]\n    new (chars: char []) = {}\n\n    [<Inline>]\n    static member CtorProxy(ch: char, n: int) = String.replicate n (string ch)\n\n    [<Inline \"$chars.slice($i, $i + $j).join('')\">]\n    new (chars: char [], i: int, j: int) = {}\n\n    member this.Chars  with [<Inline \"$this[$pos]\">]\n                            get (pos: int) = X<char>\n\n    [<Inline \"$this\">]\n    member this.Clone() = this :> obj\n\n    [<Inline \"$this\">]\n    member this.Copy() = this\n\n    [<Inline>]\n    static member Compare(x: string, y: string) =\n        Unchecked.compare x y\n\n    [<Inline>]\n    static member Compare(x: string, y: string, b: bool) =\n        if b then\n            Unchecked.compare (x.ToLower()) (y.ToLower())\n        else\n        Unchecked.compare x y\n\n    [<Inline>]\n    member this.CompareTo(s: string) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    member this.CompareTo(s: obj) =\n        Unchecked.compare (this :> obj) s\n\n    [<Inline>]\n    static member Concat(strings: string seq) =\n        Join \"\" (Array.ofSeq strings)\n\n    [<Inline>]\n    static member Concat<'T>(objs: 'T seq) : string =\n        Join \"\" (Array.ofSeq (objs |> Seq.map (fun o -> o.ToString())))\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string) = s1 + s2\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string) = s1 + s2 + s3\n\n    [<Inline>]\n    static member Concat(s1: string, s2: string, s3: string, s4: string) = s1 + s2 + s3 + s4\n\n    [<Inline>]\n    static member Concat(o1: obj) = string o1\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj) = string o1 + string o2\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj) = string o1 + string o2 + string o3\n\n    [<Inline>]\n    static member Concat(o1: obj, o2: obj, o3: obj, o4: obj) = string o1 + string o2 + string o3 + string o4\n\n    [<Inline \"$strings.join('')\">]\n    static member Concat([<System.ParamArray>] strings: string[]) = X<string>\n\n    [<Inline>]\n    static member Concat(objs: obj[]) =\n        Join \"\" (As<string[]> objs)\n\n    [<Inline \"$this.indexOf($s) != -1\">]\n    member this.Contains(s: string) = X<bool>\n\n    [<Inline>]\n    member this.CopyTo(s: int, d: char [], off: int, ct: int) =\n        CopyTo (As this) s d off ct\n\n    static member Empty with [<Inline \"''\">] get () = X<string>\n\n    [<Inline>]\n    member this.EndsWith(other: string) = EndsWith (As this) other\n\n    [<Inline \"$x == $y\">]\n    static member Equals(x: string, y: string) = X<bool>\n\n    [<Inline \"$this == $s\">]\n    member this.Equals(s: string) = X<bool>\n\n    [<Inline \"$this === $s\">]\n    override this.Equals(s: obj) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get (unbox<seq<char>> this) |> As<System.CharEnumerator>\n\n    [<Inline \"$this.indexOf($s)\">]\n    member this.IndexOf(s: string) = X<int>\n\n    [<Inline \"$this.indexOf($c)\">]\n    member this.IndexOf(c: char) = X<int>\n\n    [<Inline \"$this.indexOf($s,$i)\">]\n    member this.IndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.IndexOf(c: char, i: int) = IndexOf (As this) c i\n\n    [<Inline>]\n    static member IsNullOrEmpty(x: string) = IsNullOrEmpty x\n\n    [<Inline>]\n    static member IsNullOrWhiteSpace(x: string) = IsNullOrWhiteSpace x\n\n    member this.Item\n        with    [<Inline \"$this[$pos]\">]\n                get (pos: int) = X<char>\n\n    [<Inline>]\n    static member Join(sep: string, values: string seq) =\n        Join sep (Array.ofSeq values)\n\n    [<Inline>]\n    static member Join(sep: string, [<System.ParamArray>] values: string[]) =\n        Join sep values\n\n    [<Inline \"$this.lastIndexOf($s)\">]\n    member this.LastIndexOf(s: string) = X<int>\n\n    [<Inline \"$this.lastIndexOf($c)\">]\n    member this.LastIndexOf(c: char) = X<int>\n\n    [<Inline \"$this.lastIndexOf($s,$i)\">]\n    member this.LastIndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.LastIndexOf(c: char, i: int) =\n        LastIndexOf (As this) c i\n\n    member this.Length with [<Inline \"$this.length\">]\n                            get () = X<int>\n\n    [<Inline>]\n    member this.PadLeft(i: int) =\n        PadLeft (As this) i\n\n    [<Inline>]\n    member this.PadLeft(i: int, c: char) =\n        PadLeftWith (As this) i c\n\n    [<Inline>]\n    member this.PadRight(i: int) =\n        PadRight (As this) i\n\n    [<Inline>]\n    member this.PadRight(i: int, c: char) =\n        PadRightWith (As this) i c\n\n    [<Inline \"$this.substring(0,$ix)\">]\n    member this.Remove(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Remove(ix: int, count: int) = Remove (As this) ix count\n\n    [<Inline>]\n    member this.ToCharArray() = ToCharArray (As this)\n\n    [<Inline>]\n    member this.Replace(subj: string, repl: string) =\n        Replace (As this) subj repl\n\n    [<Inline>]\n    member this.Replace(subj: char, repl: char) =\n        ReplaceChar (As this) subj repl\n\n    [<Inline>]\n    member this.Split([<System.ParamArray>] sep: char[]) =\n        SplitChars (As this) sep  System.StringSplitOptions.None\n\n    [<Inline>]\n    member this.Split(sep: char[], opts: System.StringSplitOptions) =\n        SplitChars (As this) sep opts\n\n    [<Inline>]\n    member this.Split(sep: string[], opts: System.StringSplitOptions) =\n        SplitStrings (As this) sep opts\n\n    [<Inline>]\n    member this.StartsWith(s: string) =\n        StartsWith (As this) s\n\n    [<Inline \"$this.substring($ix)\">]\n    member this.Substring(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Substring(ix: int, ct: int) =\n        Substring (As this) ix ct\n\n    [<Inline>]\n    member this.ToCharArray(i: int, l: int) =\n        ToCharArrayRange (As this) i l\n\n    [<Inline \"$this\">]\n    override this.ToString() = X<string>\n    \n    [<Inline \"$this.toLowerCase()\">]\n    member this.ToLower() = X<string>\n\n    [<Inline \"$this.toUpperCase()\">]\n    member this.ToUpper() = X<string>\n\n    [<Inline>]\n    member this.Trim() = Trim (As this)\n\n    [<Inline>]\n    member this.TrimStart(t: char[]) = TrimStart (As this) t\n\n    [<Inline>]\n    member this.TrimEnd(t: char[]) = TrimEnd (As this) t\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: string, b: string) = X<string>\n\n    [<Inline>]\n    static member (+) (a: obj, b: string) = string a + b \n\n    [<Inline>]\n    static member (+) (a: string, b: obj) = a + string b\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: string, b: string) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: string, b: string) = X<bool>\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, [<System.ParamArray>] arguments: obj []) = SFormat format arguments\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj): string = SFormat format [|arg0|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj): string = SFormat format [|arg0; arg1|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj, arg2: obj): string = SFormat format [|arg0; arg1; arg2|]\n\nlet protect (s : string) =\n    if s = null then \"\" else s\n\n[<Inline \"$strings.join($sep)\">]\nlet join (strings: string[]) (sep: string) = X<string>\n\n[<Name \"collect\">]\nlet Collect (f: char -> string) (s: string) : string =\n    System.String.Concat(Array.init s.Length (fun i -> f s.[i]))\n\n[<Name \"concat\">]\nlet Concat (separator: string) (strings: seq<string>) : string =\n    join (Seq.toArray strings) separator\n\n[<Name \"exists\">]\nlet Exists (f: char -> bool) (s: string) : bool =\n    Seq.exists f (protect s)\n\n[<Name \"forall\">]\nlet ForAll (f: char -> bool) (s: string) : bool =\n    Seq.forall f (protect s)\n\n[<Name \"init\">]\nlet Initialize (count: int) (f: int -> string) : string =\n    System.String.Concat(Array.init count f)\n\n[<Name \"iter\">]\nlet Iterate (f: char -> unit) (s: string) : unit =\n    Seq.iter f (protect s)\n\n[<Name \"iteri\">]\nlet IterateIndexed (f: int -> char -> unit) (s: string) : unit =\n    Seq.iteri f (protect s)\n\n[<Name \"length\">]\nlet Length (s: string) : int =\n    (protect s).Length\n\n[<Name \"map\">]\nlet Map (f: char -> char) (s: string) : string =\n    Collect (fun x -> string (f x)) (protect s)\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> char -> char) (s: string) : string =\n    System.String.Concat (Seq.toArray (Seq.mapi (fun i x -> string (f i x)) s))\n\n[<Name \"replicate\">]\nlet Replicate (count: int) (s: string) : string =\n    System.String.Concat(Array.create count s)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nopen System.Threading\nopen System.Threading.Tasks\n\n[<Proxy(typeof<Task>); Name \"Task\">]\ntype private TaskProxy(action: System.Action, token: CT, status, exc) =\n    [<Name \"status\">]\n    let mutable status = status\n    [<Name \"continuations\">]\n    let continuations = [||] : TaskProxy[]\n    [<Name \"exc\">]\n    let mutable exc = exc : System.AggregateException\n\n    abstract Execute : unit -> unit\n    default this.Execute() = action.Invoke()\n\n    member this.Exception = exc\n\n    member this.IsCanceled = \n        status = TaskStatus.Canceled\n\n    member this.IsCompleted = \n        status = TaskStatus.RanToCompletion || status = TaskStatus.Faulted || status = TaskStatus.Canceled\n\n    member this.IsFaulted =\n        status = TaskStatus.Faulted\n\n    member this.Status = status\n\n    new (action) = TaskProxy(action, CT.None, TaskStatus.Created, null)\n\n    new (action, ct) = TaskProxy(action, ct, TaskStatus.Created, null)\n    \n    new (action: System.Action<obj>, obj: obj) = TaskProxy((fun () -> action.Invoke(obj)), CT.None, TaskStatus.Created, null)\n\n    new (action: System.Action<obj>, obj: obj, ct: CT) = TaskProxy((fun () -> action.Invoke(obj)), ct, TaskStatus.Created, null)\n\n    member this.OnCompleted(cont : unit -> unit) =\n        if this.IsCompleted then \n            cont()\n        else \n            if this.Status = TaskStatus.Created then this.Start()\n            this.ContinueWith(fun (_: Task) -> cont()) |> ignore\n\n    member this.RunContinuations() =\n        for c in continuations do\n            c.StartContinuation()    \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task>) =\n        this.ContinueWith(action, CT.None)\n\n    member this.ContinueWith(action: System.Action<Task>, ct) =\n        let res = TaskProxy((fun () -> action.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task> res\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task,'T>) =\n        this.ContinueWith(func, CT.None)\n\n    member this.ContinueWith(func: System.Func<Task,'T>, ct) =\n        let res = TaskProxy<'T>((fun () -> func.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null, JS.Undefined)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task<'T>> res\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task>(fun t -> action.Invoke (t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke (t, obj))\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task, obj, 'T>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke (t, obj)), ct)\n\n    member this.StartContinuation() =\n        if status = TaskStatus.WaitingForActivation then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                if status = TaskStatus.WaitingToRun then\n                    status <- TaskStatus.Running\n                    try\n                        this.Execute()\n                        status <- TaskStatus.RanToCompletion\n                    with e ->\n                        exc <- System.AggregateException(e)\n                        status <- TaskStatus.Faulted\n                    this.RunContinuations()\n            )\n\n    member this.Start() =\n        if status = TaskStatus.Created then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                status <- TaskStatus.Running\n                try\n                    this.Execute()\n                    status <- TaskStatus.RanToCompletion\n                with\n                | :? OCE as e when e.CancellationToken = token ->\n                    Console.Log(\"Task cancellation caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Canceled\n                | e ->\n                    Console.Log(\"Task error caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Faulted\n                this.RunContinuations()\n            )\n        else\n            invalidOp \"Task not in initial state\"\n        \n    static member FromCanceled ct = \n        As<Task> (TaskProxy(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException())))\n\n    static member FromCanceled(ct: CT) = \n        As<Task<_>> (TaskProxy<_>(null, ct, TaskStatus.Canceled, System.AggregateException(TaskCanceledException()), As null)) \n\n    static member FromException (exc: exn) =\n        As<Task> (TaskProxy(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc)))\n\n    static member FromException (exc: exn) =\n        As<Task<_>> (TaskProxy<_>(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc), As null))\n\n    static member FromResult (res: 'T) = \n        As<Task<'T>> (TaskProxy<'T>(null, CT.None, TaskStatus.RanToCompletion, null, res)) \n\n    [<Inline>]\n    static member Run(action : System.Action) =\n       TaskProxy.Run(action, CT.None)\n        \n    static member Run(action : System.Action, ct) =\n        let res = TaskProxy(action, ct, TaskStatus.Created, null)\n        res.Start()\n        As<Task> res\n\n    [<Inline>]\n    static member Run(func : System.Func<Task>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled ct : Task else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    [<Inline>]\n    static member Run(func : System.Func<'T>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<'T>, ct) =\n        let res = TaskProxy<'T>(func, ct, TaskStatus.Created, null, JS.Undefined)\n        res.Start()\n        As<Task<'T>> res   \n\n    [<Inline>]\n    static member Run(func : System.Func<Task<'T>>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task<'T>>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled<'T> ct else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    static member Delay(time: int) =   \n        Async.StartAsTask (Async.Sleep time) :> Task\n             \n    static member Delay(time: int, ct) =        \n        Async.StartAsTask (Async.Sleep time, cancellationToken = ct) :> Task\n\n    [<Inline>]\n    static member Delay(time: System.TimeSpan) =        \n        TaskProxy.Delay(As<int> time)\n             \n    [<Inline>]\n    static member Delay(time: System.TimeSpan, ct) =        \n        TaskProxy.Delay(As<int> time, ct)\n\n    static member WhenAny(tasks: Task[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAny(tasks: Task<'T>[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<Task<'T>>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task<'T>>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun t -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    if !completed = target then tcs.TrySetResult() |> ignore \n            ) |> ignore\n        tcs.Task :> Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task<'T>[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let results = JavaScript.Array(target)\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun (t: Task<'T>) -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    results.[i] <- t.Result\n                    if !completed = target then tcs.SetResult results.Self\n            ) |> ignore\n        tcs.Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task<'T>>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member Yield() =\n        new Task(fun () -> ()) |> As<System.Runtime.CompilerServices.YieldAwaitable>  \n\nand [<Proxy(typeof<Task<_>>); Name \"Task1\">] private TaskProxy<'T>(func: System.Func<'T>, token: CT, status, exc, result) =\n    inherit TaskProxy(null, token, status, exc)\n    \n    [<Name \"result\">]\n    let mutable result = result\n\n    new (func) = TaskProxy<'T>(func, CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func, ct) = TaskProxy<'T>(func, ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj) = TaskProxy<'T>((fun () -> func.Invoke obj), CT.None, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    new (func: System.Func<obj, 'T>, obj: obj, ct: CT) = TaskProxy<'T>((fun () -> func.Invoke obj), ct, TaskStatus.Created, null, As<'T> JS.Undefined)\n\n    member this.Result = \n        match this.Status with\n        | TaskStatus.RanToCompletion -> result\n        | TaskStatus.Faulted\n        | TaskStatus.Canceled -> raise this.Exception \n        | _ -> invalidOp \"Task has not been completed, has no Result\"\n\n    override this.Execute () =\n        result <- func.Invoke()\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>) =\n        this.ContinueWith(As<System.Action<Task>> action)\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>, ct) =\n        this.ContinueWith(As<System.Action<Task>> action, ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>, ct) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func, ct) \n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)))\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>, obj>, obj: obj, ct) =\n        this.ContinueWith(System.Action<Task<'T>>(fun t -> action.Invoke(t, obj)), ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj) =\n        this.ContinueWith(fun t -> func.Invoke(t, obj)) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, obj, 'R>, obj: obj, ct) =\n        this.ContinueWith((fun t -> func.Invoke(t, obj)), ct) \n\n[<Proxy(typeof<TaskCompletionSource<_>>)>]\n[<Name \"TaskCompletionSource\">]\ntype private TaskCompletionSourceProxy<'T>() =\n    let task = new TaskProxy<'T>(null, CT.None, TaskStatus.WaitingForActivation, null, JS.Undefined)\n\n    member this.Task = As<Task<'T>> task\n\n    member this.SetCanceled() =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Canceled\n        task.RunContinuations()\n\n    member this.SetException(exc: exn) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Faulted\n        task?exc <- System.AggregateException(exc)\n        task.RunContinuations()\n\n    member this.SetException(exs : seq<exn>) =\n        this.SetException(System.AggregateException(exs))\n\n    member this.SetResult(res: 'T) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.RanToCompletion\n        task?result <- res \n        task.RunContinuations()\n\n    member this.TrySetCanceled() =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetCanceled(ct: CT) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task?token <- ct\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exc: exn) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Faulted\n            task?exc <- System.AggregateException(exc)\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exs : seq<exn>) =\n        this.TrySetException(System.AggregateException(exs))\n\n    member this.TrySetResult(res: 'T) =        \n        if not task.IsCompleted then\n            task?status <- TaskStatus.RanToCompletion\n            task?result <- res \n            task.RunContinuations()\n            true\n        else false\n    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements generic comparison, equality and hashing.\n[<WebSharper.Name \"Unchecked\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+Unchecked, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.UncheckedProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Core.Macros\n\n[<Inline \"$a instanceof Array\">]\nlet isArray (a: obj) = X<bool>\n\n[<Inline \"$a instanceof Date\">]\nlet isDate (a: obj) = X<bool>\n\nlet rec compareArrays (a: obj []) (b: obj []) =\n    if a.Length < b.Length   then -1\n    elif a.Length > b.Length then 1\n    else\n        let mutable cmp = 0\n        let mutable i = 0\n        while cmp = 0 && i < a.Length do\n            cmp <- Unchecked.compare a.[i] b.[i]\n            i <- i + 1\n        cmp\n\n[<Inline \"$d.getTime()\">]\nlet getTime (d: obj) : int = X\n\nlet rec compareDates (a: obj) (b: obj) =\n    compare (getTime a) (getTime b)\n\n/// Compares two values generically.\nlet Compare<'T> (a: 'T) (b: 'T) : int =\n    let objCompare (a: obj) (b: obj) =\n        let cmp = ref 0\n        JS.ForEach a (fun k ->\n            if not (JS.HasOwnProperty a k) then\n                false\n            elif not (JS.HasOwnProperty b k) then\n                cmp := 1; true\n            else\n                cmp := Unchecked.compare a?(k) b?(k); !cmp <> 0)\n        if !cmp = 0 then\n            JS.ForEach b (fun k ->\n                if not (JS.HasOwnProperty b k) then\n                    false\n                elif not (JS.HasOwnProperty a k) then\n                    cmp := -1; true\n                else false)\n        !cmp\n    if a ===. b then 0 else\n        match JS.TypeOf a with\n        | JS.Undefined ->\n            match JS.TypeOf b with\n            | JS.Undefined -> 0\n            | _ -> -1\n        | JS.Function ->\n            failwith \"Cannot compare function values.\"\n        | JS.Boolean | JS.Number | JS.String ->\n            if a <. b then -1 else 1\n        | JS.Object ->\n            if a ===. null then -1\n            elif b ===. null then 1\n            elif JS.In \"CompareTo\" a then (As<System.IComparable<_>> a).CompareTo(b)\n            elif JS.In \"CompareTo0\" a then (As<System.IComparable> a).CompareTo(b)\n            elif isArray a && isArray b then compareArrays (As a) (As b)\n            elif isDate a && isDate b then compareDates a b\n            else objCompare (As a) (As b)\n\n/// Produces an undefined value.\n[<Macro(typeof<M.DefaultOf>)>]\n[<Inline \"undefined\">]\nlet DefaultOf<'T> = X<'T>\n\nlet arrayEquals (a: obj []) (b: obj []) =\n    if a.Length = b.Length then\n        let mutable eq = true\n        let mutable i = 0\n        while eq && i < a.Length do\n            if not (Unchecked.equals a.[i] b.[i]) then\n                eq <- false\n            i <- i + 1\n        eq\n    else\n        false\n\nlet dateEquals a b =\n    getTime a ===. getTime b\n\n[<Inline \"$a.Equals($b)\">]\nlet private equals (a: obj) (b: obj) = X<bool>\n\n/// Tests if two values are equal.\nlet Equals (a: 'T) (b: 'T) : bool =\n    let objEquals (a: obj) (b: obj) =\n        let eqR = ref true\n        JS.ForEach a (fun k ->\n            eqR := not (JS.HasOwnProperty a k) || JS.HasOwnProperty b k && Unchecked.equals a?(k) b?(k)\n            not !eqR)\n        if !eqR then\n            JS.ForEach b (fun k ->\n                eqR := not (JS.HasOwnProperty b k) || JS.HasOwnProperty a k\n                not !eqR)\n        !eqR\n    if a ===. b then true else\n        match JS.TypeOf a with\n        | JS.Object ->\n            if a ===. null || a ===. JS.Undefined || b ===. null || b ===. JS.Undefined then false\n            elif JS.In \"Equals\" a then equals a b\n            elif isArray a && isArray b then arrayEquals (As a) (As b)\n            elif isDate a && isDate b then dateEquals a b\n            else objEquals (As a) (As b)\n        | JS.Function ->\n            if JS.In \"$Func\" a then\n                a?``$Func`` ===. b?``$Func`` && a?``$Target`` ===. b?``$Target``\n            elif JS.In \"$Invokes\" a && JS.In \"$Invokes\" b then\n                arrayEquals a?``$Invokes`` b?``$Invokes``  \n            else false\n        | _ ->\n            false\n\nlet hashMix (x: int) (y: int) : int =\n    (x <<< 5) + x + y\n\nlet hashArray (o: obj []) =\n    let mutable h = -34948909\n    for i in 0 .. o.Length - 1 do\n        h <- hashMix h (Unchecked.hash o.[i])\n    h\n\nlet hashString (s: string) : int =\n    if s ===. null then 0 else\n        let mutable hash = 5381\n        for i = 0 to s.Length - 1 do\n            hash <- hashMix hash (int s.[i])\n        hash\n\n[<Inline \"$o.GetHashCode()\">]\nlet getHashCode(o: obj) = X<int>\n\nlet hashObject (o: obj) =\n    if JS.In \"GetHashCode\" o then getHashCode o else\n        let (++) = hashMix\n        let h = ref 0\n        JS.ForEach o (fun key ->\n            h := !h ++ hashString key ++ Unchecked.hash ((?) o key)\n            false)\n        !h\n\n/// Computes the hash of an object.\nlet Hash<'T> (o: 'T) : int =\n    match JS.TypeOf o with\n    | JS.Undefined -> 0\n    | JS.Function  -> 0\n    | JS.Boolean   -> if As o then 1 else 0\n    | JS.Number    -> As o\n    | JS.String    -> hashString (As o)\n    | JS.Object    -> if o ==. null then 0\n                      elif isArray o then hashArray (As o)\n                      else hashObject o\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<voption<_>>)>]\n[<RequireQualifiedAccess>]\ntype private ValueOptionProxy<'T> =\n    | ValueNone \n    | ValueSome of 'T\n\n    member this.Value =\n        match this with \n        | ValueNone -> invalidOp \"ValueOption.Value\"\n        | ValueSome x -> x \n\n    static member Test =\n        (ValueSome 2).Value\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Core.Macros\n\n[<JavaScript>]\n[<Name \"Numeric\">]\ntype internal N =\n    static member Parse<'T>(s: string, min: 'T, max: 'T, overflowMsg) =\n        let x : float = JS.Plus s\n        if x !==. (x -. (x %. 1)) then\n            raise (System.FormatException \"Input string was not in a correct format.\")\n        elif (x <. min) || (x >. max) then\n            raise (System.OverflowException overflowMsg)\n        else As<'T> x\n\n    static member TryParse<'T>(s: string, min: 'T, max: 'T, r: byref<'T>) =\n        let x : float = JS.Plus s\n        let ok = x ===. (x -. (x %. 1)) && (x >=. min) && (x <=. max)\n        if ok then r <- As<'T> x\n        ok\n\n    static member ParseBool(s: string) =\n        match s.ToLower() with\n        | \"true\" -> true\n        | \"false\" -> false\n        | _ -> raise (System.FormatException \"String was not recognized as a valid Boolean.\")\n\n    static member TryParseBool(s: string, r: byref<bool>) =\n        match s.ToLower() with\n        | \"true\" -> r <- true; true\n        | \"false\" -> r <- false; true\n        | _ -> false\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Byte>)>]\ntype internal NB =\n\n    [<Name \"WebSharper.Numeric.ParseByte\">]\n    static member Parse(s: string) : System.Byte =\n        N.Parse(s, System.Byte.MinValue, System.Byte.MaxValue, \"Value was either too large or too small for an unsigned byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseByte\">]\n    static member TryParse(s: string, r: byref<System.Byte>) : bool =\n        N.TryParse(s, System.Byte.MinValue, System.Byte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.SByte>)>]\ntype internal NSB =\n\n    [<Name \"WebSharper.Numeric.ParseSByte\">]\n    static member Parse(s: string) : System.SByte =\n        N.Parse(s, System.SByte.MinValue, System.SByte.MaxValue, \"Value was either too large or too small for a signed byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseSByte\">]\n    static member TryParse(s: string, r: byref<System.SByte>) : bool =\n        N.TryParse(s, System.SByte.MinValue, System.SByte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int16>)>]\n[<Name \"Int16\">]\ntype internal NI16 =\n\n    [<Name \"WebSharper.Numeric.ParseInt16\">]\n    static member Parse(s: string) : System.Int16 =\n        N.Parse(s, System.Int16.MinValue, System.Int16.MaxValue, \"Value was either too large or too small for an Int16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt16\">]\n    static member TryParse(s: string, r: byref<System.Int16>) : bool =\n        N.TryParse(s, System.Int16.MinValue, System.Int16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int32>)>]\n[<Name \"Int32\">]\ntype internal NI32 =\n\n    [<Name \"WebSharper.Numeric.ParseInt32\">]\n    static member Parse(s: string) : System.Int32 =\n        N.Parse(s, System.Int32.MinValue, System.Int32.MaxValue, \"Value was either too large or too small for an Int32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt32\">]\n    static member TryParse(s: string, r: byref<System.Int32>) : bool =\n        N.TryParse(s, System.Int32.MinValue, System.Int32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt16>)>]\n[<Name \"UInt16\">]\ntype internal NUI16 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt16\">]\n    static member Parse(s: string) : System.UInt16 =\n        N.Parse(s, System.UInt16.MinValue, System.UInt16.MaxValue, \"Value was either too large or too small for an UInt16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt16\">]\n    static member TryParse(s: string, r: byref<System.UInt16>) : bool =\n        N.TryParse(s, System.UInt16.MinValue, System.UInt16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt32>)>]\n[<Name \"UInt32\">]\ntype internal NUI32 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt32\">]\n    static member Parse(s: string) : System.UInt32 =\n        N.Parse(s, System.UInt32.MinValue, System.UInt32.MaxValue, \"Value was either too large or too small for an UInt32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt32\">]\n    static member TryParse(s: string, r: byref<System.UInt32>) : bool =\n        N.TryParse(s, System.UInt32.MinValue, System.UInt32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int64>)>]\n[<Name \"Int64\">]\ntype internal NI64 =\n\n    [<Name \"WebSharper.Numeric.ParseInt64\">]\n    static member Parse(s: string) : System.Int64 =\n        N.Parse(s, System.Int64.MinValue, System.Int64.MaxValue, \"Value was either too large or too small for an Int64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt64\">]\n    static member TryParse(s: string, r: byref<System.Int64>) : bool =\n        N.TryParse(s, System.Int64.MinValue, System.Int64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt64>)>]\n[<Name \"UInt64\">]\ntype internal NUI64 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt64\">]\n    static member Parse(s: string) : System.UInt64 =\n        N.Parse(s, System.UInt64.MinValue, System.UInt64.MaxValue, \"Value was either too large or too small for an UInt64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt64\">]\n    static member TryParse(s: string, r: byref<System.UInt64>) : bool =\n        N.TryParse(s, System.UInt64.MinValue, System.UInt64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Single>)>]\ntype internal NS =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: single) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: single) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: single) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: single) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Single>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Single>) = X<bool>\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Double>)>]\ntype internal ND =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: double) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: double) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: double) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: double) = X<bool>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member Parse(x: string) = X<System.Double>\n\n    [<Macro(typeof<M.NumericMacro>)>]\n    static member TryParse(x: string, r: byref<System.Double>) = X<bool>\n\n[<Proxy(typeof<System.Boolean>)>]\ntype internal B = \n    [<Inline>]\n    static member op_LogicalNot(a: bool) = not a\n\n    [<Inline \"$this == $x\">]\n    member this.Equals(x: bool) = X<bool>\n\n    [<Inline \"$this === $x\">]\n    override this.Equals(x: obj) = X<bool>\n\n    [<Inline \"$a == $b\">]\n    static member op_Equality(a: bool, b: bool) = X<bool>\n\n    [<Inline \"$a != $b\">]\n    static member op_Inequality(a: bool, b: bool) = X<bool>\n\n    [<Inline>]\n    override this.GetHashCode() = hash this\n\n    [<Constant \"true\">]\n    static member TrueString = X<string>\n\n    [<Constant \"false\">]\n    static member FalseString = X<string>\n\n    [<Inline>]\n    override this.ToString() = string this\n\n    [<Inline>]\n    member this.CompareTo(x: bool) =\n        Unchecked.compare (this :> obj) (x :> obj)\n\n    [<Inline>]\n    member this.CompareTo(x: obj) =\n        Unchecked.compare (this :> obj) x\n\n    [<Inline>]\n    static member Parse(x: string) =\n        N.ParseBool x\n\n    [<Inline>]\n    static member TryParse(x: string, r: byref<bool>) =\n        N.TryParseBool(x, &r)\n"],
"names": [],
"mappings": "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"
}
