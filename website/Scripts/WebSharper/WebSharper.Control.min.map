{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Control/Observer.fs", "WebSharper.Control/HotStream.fs", "WebSharper.Control/Observable.fs", "WebSharper.Control/ObservableModule.fs", "WebSharper.Control/Event.fs", "WebSharper.Control/FSharpEvent.fs", "WebSharper.Control/EventModule.fs", "WebSharper.Control/MailboxProcessor.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule internal Observer =\n\n    type Message<'T> =\n        | Message of 'T\n        | Error of exn\n        | Completed\n\n    let Of f : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = raise x\n            member __.OnCompleted() = ()\n        }\n\n    let New (f, e, c) : IObserver<_> =\n        { new IObserver<'T> with\n            member __.OnNext x = f x\n            member __.OnError x = e x\n            member __.OnCompleted() = c()\n        }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\nmodule internal HotStream =\n    open System\n\n    /// Implementation for \"hot stream\".\n    /// Subscribers to hot streams will only observe the latest\n    /// and future values.\n    [<JavaScript>]\n    type HotStream<'T> =\n        internal\n            {\n                Latest  : ref<option<'T>>\n                Event   : Event<'T>\n            }\n        interface IObservable<'T> with\n            member this.Subscribe(o) =\n                if this.Latest.Value.IsSome then\n                    o.OnNext this.Latest.Value.Value\n                let disp =\n                    this.Event.Publish.Subscribe(fun v ->\n                        o.OnNext(v)\n                    )\n                disp\n\n        member this.Trigger(v) =\n            this.Latest := Some v\n            this.Event.Trigger v\n\n        static member New<'U>() : HotStream<'U> =\n            {\n                Latest = ref None\n                Event = Event<_>()\n            }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.JavaScript>]\nmodule internal WebSharper.Control.Observable\n\nopen System\nopen WebSharper\n\n[<Inline>]\nlet New f : IObservable<'T> = { new IObservable<'T> with member __.Subscribe o = f o }\n\nlet Of (f: ('T -> unit) -> (unit -> unit)) : IObservable<_> =\n    New (fun o -> Disposable.Of (f (fun x -> o.OnNext x)))\n\nlet Return<'T> (x: 'T) : IObservable<'T> =\n    let f (o : IObserver<'T>) =\n        o.OnNext x\n        o.OnCompleted ()\n        Disposable.Of ignore\n    New f\n\nlet Never<'T> () : IObservable<'T> =\n    New(fun _ ->\n        Disposable.Of ignore\n    )\n\nlet Protect f succeed fail =\n    match (try Choice1Of2 (f ()) with e -> Choice2Of2 e) with\n    | Choice1Of2 x -> (succeed x)\n    | Choice2Of2 e -> (fail e)\n\nlet Map (f: 'T -> 'U) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) o1.OnNext o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\n\nlet Filter (f: 'T -> bool) (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let on v = \n            Protect (fun () -> if f v then Some v else None)\n                (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <|  Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Choose  (f: 'T -> option<'U>) (io: IObservable<'T>) : IObservable<'U> =\n    New <| fun o1 ->\n        let on v = Protect (fun () -> f v) (Option.iter o1.OnNext) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Drop count (io: IObservable<'T>) : IObservable<'T> =\n    New <| fun o1 ->\n        let index = ref 0\n        let on v =\n            incr index\n            if index.Value > count then\n                o1.OnNext v\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)\n\nlet Merge (io1: IObservable<'T>) (io2: IObservable<'T>) : IObservable<'T> =\n    New <| fun o ->\n        let completed1 = ref false\n        let completed2 = ref false\n        let disp1 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed1 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io1.Subscribe\n        let disp2 =\n            Observer.New(o.OnNext, ignore, fun () ->\n                completed2 := true\n                if completed1.Value && completed2.Value then\n                    o.OnCompleted ()\n            )\n            |> io2.Subscribe\n        Disposable.Of (fun () -> disp1.Dispose(); disp2.Dispose())\n\nlet Concat (io1: IObservable<'T>) (io2: IObservable<'T>) =\n    New <| fun o ->\n        let innerDisp = ref None\n        let outerDisp =\n            io1.Subscribe(\n                Observer.New(o.OnNext, ignore, fun () ->\n                    innerDisp := Some <| io2.Subscribe(o)\n                )\n            )\n        Disposable.Of <| fun () ->\n            if innerDisp.Value.IsSome then\n                innerDisp.Value.Value.Dispose ()\n            outerDisp.Dispose()\n\n\nlet Range (start: int , count: int) : IObservable<int> =\n    New <| fun o ->\n        for i = start to start + count do\n            o.OnNext i\n        Disposable.Of ignore\n\n\nlet CombineLatest   (io1 : IObservable<'T>)\n                    (io2: IObservable<'U>)\n                    (f: 'T -> 'U -> 'S) : IObservable<'S> =\n    New <| fun o ->\n        let lv1 = ref None\n        let lv2 = ref None\n        let update () =\n            match !lv1, !lv2 with\n            | Some v1, Some v2  ->\n                Protect (fun () -> f v1 v2) o.OnNext o.OnError\n            | _                 ->\n                ()\n        let o1 =\n            let onNext x =\n                lv1 := Some x\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let o2 =\n            let onNext y =\n                lv2 := Some y\n                update ()\n            Observer.New(onNext, ignore, ignore)\n        let d1 = io1.Subscribe(o1)\n        let d2 = io2.Subscribe(o2)\n        Disposable.Of (fun () -> d1.Dispose() ; d2.Dispose())\n\nlet Switch (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp =\n            let index = ref 0\n            let disp : option<IDisposable> ref = ref None\n\n            // Subscribe to outer stream\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Update counter\n                incr index\n\n                // Dispose old observer\n                if disp.Value.IsSome then\n                    disp.Value.Value.Dispose ()\n\n                let currentIndex = index.Value\n                let d =\n                    o1.Subscribe (fun v ->\n                        if currentIndex = index.Value then\n                            o.OnNext(v)\n                    ) |> Some\n                // Update dispose\n                disp := d\n            )\n        disp\n    )\n\nlet SelectMany (io: IObservable<IObservable<'T>>) : IObservable<'T> =\n    New (fun o ->\n        let disp = ref ignore\n        // Subscribe to outer stream\n        let d =\n            io.Subscribe(fun (o1 : IObservable<'T>) ->\n                // Subscribe to inner stream\n                let d =\n                    o1.Subscribe (fun v ->\n                        o.OnNext v\n                    )\n                disp := fun () ->\n                    disp.Value ()\n                    d.Dispose ()\n            )\n        Disposable.Of (fun () ->\n            disp.Value ()\n            d.Dispose ()\n        )\n    )\n\nlet Aggregate (io: IObservable<'T>) (seed: 'S) (fold: 'S -> 'T -> 'S) =\n    New <| fun o1 ->\n        let state = ref seed\n        let on v = \n            Protect (fun () -> fold !state v) \n                (fun s -> state := s; o1.OnNext s) o1.OnError\n        io.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n////    let CollectLatest (outer: IObservable<IObservable<'T>>) : IObservable<seq<'T>> =\n//        New (fun o ->\n//            let dict = System.Collections.Generic.Dictionary<int, 'T>()\n//            let index = ref 0\n//\n//            // Outer subscription\n//            outer.Subscribe(fun (inner: IObservable<'T>) ->\n//                incr index\n//                let currentIndex = index.Value\n//\n//                // Inner subscription\n//                inner.Subscribe(fun value ->\n//                    dict.[currentIndex] <- value\n//                    seq {for pair in dict do yield pair.Value}\n//                    |> o.OnNext\n//                )|> ignore\n//            )\n//        )\n\nlet Sequence (ios: seq<IObservable<'T>>) : IObservable<List<'T>> =\n    let rec sequence (ios: list<IObservable<'T>>) =\n        match ios with\n        | []        ->\n            Return []\n        | x::xs  ->\n            let rest = sequence xs\n            CombineLatest x rest  (fun x y -> x :: y)\n    sequence (List.ofSeq ios)\n\n\n[<Inline>]\nlet Heat (io: IObservable<'T>) : IObservable<'T> =\n    let formStream = HotStream.HotStream<_>.New()\n    let disp =\n        io.Subscribe formStream.Trigger\n    formStream :> IObservable<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.ObservableModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private ObservableModule =\n\n    [<Inline>]\n    let Add (f: 'T -> unit) (o: IObservable<'T>) =\n        ignore (o.Subscribe (Observer.Of f))\n\n    [<Inline>]\n    let Choose (c: 'T -> option<'U>) (e: IObservable<'T>) =\n        Observable.Choose c e\n\n    [<Inline>]\n    let Filter (ok: 'T -> bool) (e: IObservable<'T>) : IObservable<'T> =\n        Observable.Filter ok e\n\n    [<Inline>]\n    let Map (f: 'T -> 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.Map f e\n\n    [<Inline>]\n    let Merge (e1: IObservable<'T>) (e2: IObservable<'T>) =\n        Observable.Merge e1 e2\n\n    let Pairwise (e: IObservable<'T>) : IObservable<'T * 'T> =\n        Observable.New <| fun o1 ->\n            let last = ref None\n            let on v =\n                match !last with\n                | None -> ()\n                | Some l -> o1.OnNext(l, v)\n                last := Some v\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Partition (f: 'T -> bool) (e: IObservable<'T>) :\n            IObservable<'T> * IObservable<'T> =\n        (Observable.Filter f e, Observable.filter (f >> not) e)\n\n    let Scan (fold: 'U -> 'T -> 'U) (seed: 'U) (e: IObservable<'T>) : IObservable<'U> =\n        Observable.New <| fun o1 ->\n            let state = ref seed\n            let on v = \n                Observable.Protect (fun () -> fold !state v) \n                    (fun s -> state := s; o1.OnNext s) o1.OnError\n            e.Subscribe <| Observer.New(on, o1.OnError, o1.OnCompleted)  \n\n    let Split (f: 'T -> Core.Choice<'U1,'U2>) (e: IObservable<'T>) :\n            IObservable<'U1> * IObservable<'U2> =\n        let left =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _ -> None)\n        let right =\n            e\n            |> Observable.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _ -> None)\n        (left, right)\n\n    [<Inline>]\n    let Subscribe (f: 'T -> unit) (e: IObservable<'T>) =\n        e.Subscribe f\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nmodule internal Event =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type Event<'T> = private { Handlers : ResizeArray<Handler<'T>> } with\n\n        member this.Trigger(x: 'T) =\n            for h in this.Handlers.ToArray() do\n                h.Invoke(null, x)\n\n        member this.AddHandler(h: Handler<'T>) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: Handler<'T>) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        member this.Subscribe(observer: IObserver<'T>) =\n            let h = new Handler<'T>(fun _ x -> observer.OnNext x)\n            this.AddHandler h\n            Disposable.Of (fun () -> this.RemoveHandler h)\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IObservable<'T> with\n                member this.Subscribe observer = this.Subscribe observer\n\n        interface IDelegateEvent<Handler<'T>> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n        interface IEvent<'T>\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n\nmodule internal DelegateEvent =\n    open System\n    open WebSharper\n    open WebSharper.JavaScript\n\n    [<JavaScript>]\n    type DelegateEvent<'T when 'T :> System.Delegate and 'T: equality> = private { Handlers : ResizeArray<'T> } with\n\n        member this.Trigger(x: obj[]) =\n            for h in this.Handlers.ToArray() do\n                h.DynamicInvoke(x) |> ignore\n\n        member this.AddHandler(h: 'T) =\n            this.Handlers.Add h\n\n        member this.RemoveHandler(h: 'T) =\n            this.Handlers\n            |> Seq.tryFindIndex ((=) h)\n            |> Option.iter this.Handlers.RemoveAt\n\n        interface IDisposable with\n                member this.Dispose() = ()\n\n        interface IDelegateEvent<'T> with\n                member this.AddHandler x = this.AddHandler x\n                member this.RemoveHandler x = this.RemoveHandler x\n\n    [<Inline>]\n    let New () = { Handlers = ResizeArray() }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen WebSharper\n\n[<Proxy(typeof<Event<_>>)>]\n[<Name \"WebSharper.Control.FSharpEvent\">]\ntype private FSharpEvent<'T> [<JavaScript>] () =\n    let event = Event.New ()\n\n    [<Inline>]\n    member this.Trigger(x: 'T) = event.Trigger x\n\n    member this.Publish with [<Inline>] get () = event :> IEvent<_>\n\n[<Proxy(typeof<DelegateEvent<_>>)>]\n[<Name \"WebSharper.Control.FSharpDelegateEvent\">]\ntype private FSharpDelegateEvent<'T when 'T :> System.Delegate and 'T: equality> [<JavaScript>] () =\n    let event = DelegateEvent.New ()\n\n    [<Inline>]\n    member this.Trigger(args: obj[]) = event.Trigger args\n\n    member this.Publish with [<Inline>] get () = event :> IDelegateEvent<'T>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System\nopen WebSharper\n\n[<Proxy \"Microsoft.FSharp.Control.EventModule, \\\n    FSharp.Core, Culture=neutral, \\\n    PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private EventModule =\n\n    [<Inline>]\n    let Add f (e: IEvent<_,_>) = e.Add f\n\n    let Choose c (e: IEvent<_,_>) : IEvent<_> =\n        // let r = Event.New ()\n        let r = Event<_>()\n        e.Add (fun x ->\n            match c x with\n            | Some y    -> r.Trigger y\n            | None      -> ())\n        r.Publish :> _\n\n    let Filter ok (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> if ok x then r.Trigger x)\n        r :> _\n\n    let Map f (e: IEvent<_,_>) : IEvent<_> =\n        let r = Event.New ()\n        e.Add (fun x -> r.Trigger (f x))\n        r :> _\n\n    let Merge<'D1,'T,'D2 when 'D1 :> Delegate\n                          and 'D1 :  delegate<'T,unit>\n                          and 'D2 :> Delegate\n                          and 'D2 :  delegate<'T,unit>>\n            (e1: IEvent<'D1,'T>) (e2: IEvent<'D2,'T>) : IEvent<_> =\n        let r = Event.New ()\n        e1.Add r.Trigger\n        e2.Add r.Trigger\n        r :> _\n\n    let Pairwise (e: IEvent<_,_>) : IEvent<_> =\n        let buf = ref None\n        let ev  = Event.New ()\n        e.Add (fun x ->\n            match buf.Value with\n            | None ->\n                buf := Some x\n            | Some old ->\n                buf := Some x\n                ev.Trigger(old, x))\n        ev :> _\n\n    let Partition f e =\n        (Event.filter f e, Event.filter (f >> not) e)\n\n    let Scan fold seed e =\n        let state = ref seed\n        let f value =\n            state := fold !state value\n            !state\n        Event.map f e\n\n    let Split (f: 'T -> Choice<'U1,'U2>) (e: IEvent<'Del,'T>) =\n        (\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice1Of2 x -> Some x\n                | _                 -> None),\n            e |> Event.choose (fun x ->\n                match f x with\n                | Core.Choice2Of2 x -> Some x\n                | _                 -> None)\n        )\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Control\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Threading\n\n[<Proxy(typeof<AsyncReplyChannel<_>>)>]\ntype private ChannelProxy<'T> =\n    [<Inline \"$this($res)\">]\n    member this.Reply(res: 'T) = X<unit>\n\n[<Proxy(typeof<MailboxProcessor<_>>)>]\n[<Name \"MailboxProcessor\">]\ntype private MailboxProcessorProxy<'T> (initial, ?token: CancellationToken) =\n    let mutable started = false\n    let errorEvent = Event<exn>()\n    let mailbox = LinkedList<'T>()\n    let mutable savedCont = None\n\n    let startAsync a =\n        Async.Start(a, ?cancellationToken = token)\n\n    let resume() =\n        match savedCont with\n        | None -> ()\n        | Some c ->\n            savedCont <- None\n            c |> startAsync\n\n    do  match token with\n        | Some ct -> \n            ct.Register(fun () -> resume()) |> ignore\n        | None -> ()\n\n    let dequeue() =\n        let f = mailbox.First.Value\n        mailbox.RemoveFirst()\n        f\n\n    [<CLIEvent>]\n    member this.Error = errorEvent.Publish\n\n    member val DefaultTimeout = -1 with get, set    \n\n    member this.Start() =\n        if started then\n            failwith \"The MailboxProcessor has already been started.\"\n        else\n            started <- true\n            async {\n                try do! initial (As<MailboxProcessor<'T>> this)\n                with err -> errorEvent.Trigger err\n            } |> startAsync\n\n    static member Start(initial, ?token: CancellationToken) =\n        let mb = new MailboxProcessor<'T>(initial, ?cancellationToken = token)\n        mb.Start()\n        mb\n\n    [<Inline>]\n    member this.Post(msg: 'T) =\n        mailbox.AddLast msg |> ignore\n        resume()\n\n    member this.TryReceive(?timeout: int) =        \n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if mailbox.First = null then\n                if timeout < 0 then\n                    savedCont <- Some <| async { dequeue() |> Some |> ok }\n                else  \n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout \n                    savedCont <- Some <| async { \n                        if !waiting then do\n                            waiting := false  \n                            JS.ClearTimeout pending\n                            dequeue() |> Some |> ok \n                    }\n            else dequeue() |> Some |> ok\n\n    member this.Receive(?timeout: int) =\n        async {\n            let! x = this.TryReceive(?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n                              \n    member this.CurrentQueueLength = mailbox.Count\n\n    member this.PostAndTryAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R option> =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        Async.FromContinuations <| fun (ok, _, _) ->\n            if timeout < 0 then\n                As (Some >> ok) |> msgf |> this.Post\n            else\n                let waiting = ref true\n                As (fun res ->\n                    if !waiting then\n                        waiting := false\n                        ok (Some res)\n                ) |> msgf |> this.Post\n                JS.SetTimeout (fun () ->\n                    if !waiting then\n                        waiting := false\n                        ok None        \n                ) timeout |> ignore               \n\n    member this.PostAndAsyncReply(msgf: AsyncReplyChannel<'R> -> 'T, ?timeout: int) : Async<'R> =\n        async {\n            let! x = this.PostAndTryAsyncReply(msgf, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n\n    member this.TryScan(scanner, ?timeout: int) =\n        let timeout = defaultArg timeout this.DefaultTimeout\n        async {\n            let scanInbox() =\n                let mutable m = mailbox.First\n                let mutable found = None\n                while m <> null do \n                    match scanner m.Value with\n                    | None ->\n                        m <- m.Next\n                    | _ as a ->\n                        mailbox.Remove m\n                        m <- null\n                        found <- a\n                found\n            match scanInbox() with\n            | Some found -> \n                let! res = found\n                return Some res\n            | _ -> return! Async.FromContinuations <| fun (ok, _, _) -> \n                if timeout < 0 then\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                ok (Some res)\n                        }\n                    scanNext()\n                else\n                    let waiting = ref true\n                    let pending = \n                        JS.SetTimeout(fun () ->\n                            if !waiting then\n                                waiting := false\n                                savedCont <- None\n                                ok None\n                        ) timeout\n                    let rec scanNext() =\n                        savedCont <- Some <| async {\n                            match scanner mailbox.First.Value with\n                            | None -> scanNext()\n                            | Some c ->\n                                mailbox.RemoveFirst()\n                                let! res = c\n                                if !waiting then do\n                                    waiting := false\n                                    JS.ClearTimeout pending\n                                    ok (Some res)\n                        }\n                    scanNext()\n        }\n        \n    member this.Scan(scanner, ?timeout: int) =\n        async {\n            let! x = this.TryScan(scanner, ?timeout = timeout)\n            return\n                match x with\n                | None -> raise (System.TimeoutException())\n                | Some x -> x\n        }\n"],
"names": [],
"mappings": "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"
}
