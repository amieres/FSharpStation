////-d:FSharpStation1564764915205 -d:TEE -d:WEBSHARPER
////#cd @"D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer"
#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1"
#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\Facades"
#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461"
#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461"
#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Owin\lib\net40"
#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Core.dll"
#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.dll"
#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Web.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.JavaScript.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Collections.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.InterfaceGenerator.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Main.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JQuery.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JavaScript.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Web.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Sitelets.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Control.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\HtmlAgilityPack.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Runtime.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Common.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp.Data\lib\net45\FSharp.Data.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Microsoft.Owin\lib\net451\Microsoft.Owin.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\Owin.WebSocket.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\WebSharper.Owin.WebSocket.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Owin\lib\net40\Owin.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\other\AuthorizeNet\lib\AuthorizeNet.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\other\Microsoft.IdentityModel.Clients.ActiveDirectory\lib\net45\Microsoft.IdentityModel.Clients.ActiveDirectory.dll"
#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Newtonsoft.Json\lib\net45\Newtonsoft.Json.dll"
#nowarn "3242"
/// Root namespace for all code
//#define FSharpStation1564764915205
#if INTERACTIVE
module FsRoot   =
#else
namespace FsRoot
#endif

    #if !NETSTANDARD20
    //#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1"
    //#I @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\Facades"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\mscorlib.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Core.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.dll"
    //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Web.dll"
    
    #if WEBSHARPER
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461"
    //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461"
    
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Core.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Collections.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.InterfaceGenerator.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Main.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JQuery.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.JavaScript.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Web.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Sitelets.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper\lib\net461\WebSharper.Control.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\HtmlAgilityPack.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Runtime.dll"
    //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.UI\lib\net461\WebSharper.UI.Templating.Common.dll"
    #endif
    #endif
    #if WEBSHARPER
    //#nowarn "3242" 
    
    open WebSharper
    open WebSharper.JavaScript
    open WebSharper.UI
    open WebSharper.UI.Client
    type on   = WebSharper.UI.Html.on
    type attr = WebSharper.UI.Html.attr
    #else
    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time
    module WebSharper =
        type RpcAttribute() =
            inherit System.Attribute()
            let a = 1
        type JavaScriptAttribute(translate:bool) =
            inherit System.Attribute()
            let a = 1
            new() = JavaScriptAttribute true
        type InlineAttribute(code:string) =
            inherit System.Attribute()
            let a = 1
            new() = InlineAttribute ""
        type DirectAttribute(code:string) =
            inherit System.Attribute()
            let a = 1
    
    open WebSharper
    
    #endif
    
        /// Essentials that can be converted to JavaScript with WebSharper
        [< JavaScript ; AutoOpen >]
        module Library = 
            let Error = Result.Error
        
            let [<Inline>] inline swap f a b = f b a
            
            /// swap: for use with operators: [1..5] |> List.map (__ (/) 2)
            let [<Inline>] inline __   f a b = f b a
            
            /// call a function but return the input value
            /// for logging, debugging
            /// use: (5 * 8) |> tee (printfn "value = %d") |> doSomethingElse
            let [<Inline>] inline tee f v = f v ; v
            
            /// tee: call a function but return the input value
            /// for logging, debugging
            /// use: (5 * 8) |!> printfn "value = %d" |> doSomethingElse
            let [<Inline>] inline  (|>!) v f   = f v ; v
            let [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v
            
            let inline print v = 
                match box v with
                | :? string as s -> printfn "%s" s
                | __             -> printfn "%A" v
            
            //#define TEE
            
            let [< Inline "new Date(0).getTime()" >] Utc1970_01_01                 = System.DateTime(1970,1,1,0,0,0,System.DateTimeKind.Utc)
            let [< Inline "$d"                    >] date2Long (d:System.DateTime) = d.Subtract(Utc1970_01_01).Ticks / 10000L
            let [< Inline "$l"                    >] long2Date (l:int64          ) = Utc1970_01_01.Add(System.TimeSpan(l * 10000L) )
            
            
            (* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2
            module IDict =
            #if WEBSHARPER
                [< Inline >]
            #endif
                let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =
                    let mutable res = Unchecked.defaultof<_>
                    if dict.TryGetValue(key, &res)
                    then Some res 
                    else None
                let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)
            *)
            module Dict =
                let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =
                    let mutable res = Unchecked.defaultof<_>
                    if dict.TryGetValue(key, &res)
                    then Some res 
                    else None
                let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)
            
            module LDict =
                let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))
                //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))
                let [<Inline>] inline tryGetValue fitem key  dict =
                    if containsKey key dict then Some (fitem key)
                    else None
            
            
            /// Extensible type for error messages, warnings and exceptions
            type ResultMessage<'M> =
                | NoMsg
                | ErrorMsg  of string
                | Warning   of string
                | Info      of string
                | Message   of 'M
                | ExceptMsg of string * string
                | RMessages of ResultMessage<'M> []
                with 
                override msg.ToString() =
                    match msg with
                    | NoMsg          ->  ""
                    | ErrorMsg  m    ->  m      |> sprintf "Error    : %s"
                    | Warning   m    ->  m      |> sprintf "Warning  : %s"
                    | Info      m    ->  m
                    | Message   m    ->  m      |> sprintf "%O"
                    | ExceptMsg(m,p) -> (m, p) ||> sprintf "Exception: %s, %s"
                    | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat "\n"
            
            [< AutoOpen >]
            module ResultMessageHelpers =
                let inline errorMsgf fmt = Printf.ksprintf ErrorMsg fmt
                let inline warningf  fmt = Printf.ksprintf Warning  fmt
                let inline infof     fmt = Printf.ksprintf Info     fmt
            
            module ResultMessage =
            
                let inline noMsg    msg = msg |> function NoMsg -> true |_-> false
                let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)
                /// converts Messages to other type of ResultMessage
                let rec bindMessage f msg = 
                    match msg with
                    | NoMsg          ->  NoMsg
                    | Message   m    ->  f         m
                    | ErrorMsg  m    ->  ErrorMsg  m
                    | Info      m    ->  Info      m
                    | Warning   m    ->  Warning   m
                    | ExceptMsg(m,p) ->  ExceptMsg(m,p)
                    | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages
            
                /// a Message is converted to ErrorMsg
                let freeMessageF f msg = msg |> bindMessage f
                /// a Message is converted to ErrorMsg
                let freeMessage    msg = msg |> freeMessageF (sprintf "%O" >> ErrorMsg)
                /// a Message is converted to Warning
                let freeMessageW   msg = msg |> freeMessageF (sprintf "%O" >> Warning )
                /// a Message is converted to Info
                let freeMessageI   msg = msg |> freeMessageF (sprintf "%O" >> Info    )
            
                let rec isInfoF f msg =
                    match msg with
                    | Info      _    ->  true
                    | Message   m    ->  f m
                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)
                    | _              ->  false
                /// a Message is not considered Info
                let isInfo  msg = msg |> isInfoF (fun _ -> false)
                /// a Message is considered Info
                let isInfoI msg = msg |> isInfoF (fun _ -> true )
            
                let rec isWarningOrInfoF f msg =
                    match msg with
                    | Warning   _    ->  true
                    | Message   m    ->  f m
                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)
                    | _              ->  false
                /// a Message is not considered a Warning
                let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)
                /// a Message is considered a Warning
                let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )
            
                let rec isFatalF f msg =
                    match msg with
                    | NoMsg
                    | Info      _    
                    | Warning   _    ->  false
                    | Message   m    ->  f m
                    | RMessages ms   ->  ms |> Seq.exists (isFatalF f)
                    | _              ->  true
                    //|>! printfn "%A = %A" msg
                /// a Message is considered fatal
                let isFatal  msg = msg |> isFatalF (fun _ -> true )
                /// a Message is not considered fatal
                let isFatalW msg = msg |> isFatalF (fun _ -> false)
            
                let rec countF f msg =
                    match msg with
                    | NoMsg          ->  0, 0, 0
                    | Info      _    ->  0, 0, 1
                    | Warning   _    ->  0, 1, 0
                    | Message   m    ->  f m
                    | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)
                    | _              ->  1, 0, 0
            
                /// a Message is considered an error
                let count  msg = msg |> countF (fun _ -> 1, 0, 0)
                /// a Message is considered a Warning
                let countW msg = msg |> countF (fun _ -> 0, 1, 0)
                /// a Message is considered Info
                let countI msg = msg |> countF (fun _ -> 0, 0, 1)
                
                let addMsg a b =
                    match a, b with
                    | NoMsg        , c
                    | c            , NoMsg         ->  c
                    | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages
                    |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages
                    | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages
                    |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages
            
                let reduceMsgs ms = (NoMsg, ms) ||> Seq.fold addMsg
            
                let summaryF f msg =
                    match countF f msg with
                    | 0, 0, _
                    | 1, 0, 0
                    | 0, 1, 0 -> ""
                    | e, 0, _ -> sprintf "Errors   : %d\n" e
                    | 0, w, _ -> sprintf "Warnings : %d\n" w
                    | e, w, _ -> sprintf "Errors   : %d, Warnings: %d\n" e w
            
                /// returns a string with a count of errors and warnings, if more than one
                let summarizedF f msg = [ msg.ToString() ; summaryF f msg ] |> Seq.filter ((<>) "") |> String.concat "\n"
                /// a Message is considered an error
                let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)
                /// a Message is considered a Warning
                let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)
                /// a Message is considered Info
                let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)
                
            module Memoize =
            
                /// returns 3 functions:
                ///    checkO  : ('p->'v option) 
                ///    getOrAdd: ('p->('p->'v)->'v) 
                ///    clear   : (unit->unit)
                [<Inline>]
                let getStoreWithDict (cache: System.Collections.Generic.Dictionary<_, _>) =
                    let checkO v     = let mutable res = Unchecked.defaultof<_>
                                       let ok          = cache.TryGetValue(v, &res)
                                       if  ok then Some res else None
                    let store  v res = cache.[v] <- res
                                       res
                    let getOrAdd p f = checkO p |> Option.defaultWith (fun () -> f p |> store p )
                    (checkO, getOrAdd), cache.Clear
            
                /// creates a Dictionary to store memoized values
                /// returns 3 functions:
                ///    checkO  : ('p->'v option) 
                ///    getOrAdd: ('p->('p->'v)->'v) 
                ///    clear   : (unit->unit)
                [<Inline>]
                let getStore() = getStoreWithDict (System.Collections.Generic.Dictionary<_, _>() )
            
                /// Memoizes function f using the provided cache
                /// getCache() returns 1 function:
                ///    getOrAdd: ('p->('p->'v)->'v) 
                [< Inline >]
                let memoizeStore (getOrAdd:('key -> ('key -> 'value) -> 'value) ) f =
                    fun p -> getOrAdd p f
            
            
                /// Memoizes the function f using a Dictionary
                /// Returns the memoized function and a clear() function
                /// The dictionary can be reset using the clear() function
                [< Inline >]
                let memoizeResetable f =
                    let (check, getOrAdd), clear = getStore()
                    let memoF = memoizeStore getOrAdd f
                    memoF, clear
            
                /// Memoizes the function f using the provided Dictionary
                [<Inline>]
                let memoizeWithDict dict f =
                    let (check, getOrAdd), clear = getStoreWithDict dict
                    let memoF = memoizeStore getOrAdd f
                    memoF
            
                /// Memoizes the function f and returns Dictionary
                [<Inline>]
                let memoizeDict f =
                    let dict = System.Collections.Generic.Dictionary<_, _>() 
                    let (check, getOrAdd), clear = getStoreWithDict dict
                    let memoF = memoizeStore getOrAdd f
                    memoF, dict
            
                /// Memoizes the function f using a Dictionary
                [<Inline>]
                let memoize f = memoizeResetable f |> fst
            
            
            [< AutoOpen >]
            module Monads =
                module Seq =    
                    let rtn = Seq.singleton
                    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)
                    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v
                    let absorbO  vOS              = vOS |> Seq.choose id
                    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)
                    let ofOption vO = 
                        match vO with
                        | Some v -> Seq.singleton v
                        | None   -> Seq.empty
                
                /// Extensions to Async
                module Async =
                    let [< Inline >] inline rtn   v    = async.Return v
                    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)
                    let [< Inline >] inline map   f    = bind (f >> rtn)
                    /// Executes f Synchronously
                    [< Inline "throw 'iterS cannot be used in JavaScript!'" >] 
                    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously
                    /// Executes f Asynchronously
                    let [< Inline >] inline iterA f             = map f >> Async.Start
                    let apply fA vA = async {
                        let! fChild = Async.StartChild fA
                        let! vChild = Async.StartChild vA
                        let! f = fChild
                        let! v = vChild 
                        return f v 
                    }
                    let sleepThen f milliseconds = async {
                        do! Async.Sleep milliseconds
                        return f()
                    }
                    let (>>=)                              v f = bind f v
                    let traverseSeq             f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))
                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList
                    let inline sequenceSeq                  sq = traverseSeq id sq
                    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)
                    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v
                
                
                module Result =
                    open Result
                
                    let errorf fmt = Printf.ksprintf Error fmt
                
                    let rtn                          = Ok
                    let join                       r = Result.bind id r
                    let flatten                    r = Result.bind id r
                    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None
                    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e
                    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d
                    let failIfTrue               m v = if     v then m |> Error  else Ok () 
                    let failIfFalse              m v = if not v then m |> Error  else Ok () 
                    let iter                  fE f r = r   |> map  f |> defaultWith fE                                                 : unit
                    let get                        r = r   |>          defaultWith (string >> failwith)
                    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)
                    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)
                    let absorbO               f  vOR = vOR |> bind (ofOption f)
                    let (>>=)                    r f = bind f r
                    let traverseSeq           f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))
                                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList
                    let inline sequenceSeq        sq = traverseSeq id sq
                        
                    
                    type Builder() =
                        member inline this.Return          x       = rtn  x
                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)
                        member        this.Bind           (w , r ) = Result.bind  r w
                        member inline this.Zero           ()       = rtn ()
                        member inline this.Delay           f       = f
                        member inline this.Combine        (a, b)   = bind b a
                        member inline this.Run             f       = Ok () |> bind f
                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e
                        member this.TryFinally(body, compensation) = try body() finally   compensation()
                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body
                        member this.While(guard, body) =
                            let rec whileLoop guard body =
                                if guard() then body() |> bind (fun () -> whileLoop guard body)
                                else rtn   ()
                            whileLoop guard body
                        member this.For(sequence:seq<_>, body) =
                            this.Using(sequence.GetEnumerator(),fun enum -> 
                                this.While(enum.MoveNext, 
                                    this.Delay(fun () -> body enum.Current)))
                                    
                    let result = Builder()
                    
                    module Operators =
                        let inline (|>>) v f   = map   f v
                        let inline (>>=) v f   = bind  f v
                        let inline (>>>) f g v = f v |>> g
                        let inline (>=>) f g v = f v >>= g
                        let inline rtn   v     = rtn    v
                        let result = result
                
                
                    
                    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error
                    /// bind version that protects against exceptions
                    let bindP                 f    r = match r with
                                                        | Ok   v -> try   f v
                                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error
                                                        | Error e ->      e                                        |> Error
                    /// map version that protects against exceptions
                    let inline mapP           f    m = bindP (f >> rtn) m            
                    let iterP                 fE f r = r   |> mapP f |> defaultWith fE                                                 : unit    
                    
                    type BuilderP() =
                        member inline this.Return          x       = rtn  x
                        member inline this.ReturnFrom      x       =     (x:Result<_,_>)
                        member        this.Bind           (w , r ) = Result.bind  r w
                        member inline this.Zero           ()       = rtn ()
                        member inline this.Delay           f       = f
                        member inline this.Combine        (a, b)   = bind b a
                        member inline this.Run             f       = Ok () |> bindP f
                        member this.TryWith   (body, handler     ) = try body() with e -> handler     e
                        member this.TryFinally(body, compensation) = try body() finally   compensation()
                        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body
                        member this.While(guard, body) =
                            let rec whileLoop guard body =
                                if guard() then body() |> bind (fun () -> whileLoop guard body)
                                else rtn   ()
                            whileLoop guard body
                        member this.For(sequence:seq<_>, body) =
                            this.Using(sequence.GetEnumerator(),fun enum -> 
                                this.While(enum.MoveNext, 
                                    this.Delay(fun () -> body enum.Current)))
                                    
                    let resultP = BuilderP()
                    
                    
                type FusionM<'T, 'S, 'M> = FM of ('S * ResultMessage<'M> -> 'T option * 'S * ResultMessage<'M>)
                
                module FusionM =
                    let inline rtn               v   = FM(fun (s ,r ) -> Some v, s, NoMsg)
                    let        bind              f m = FM(fun (s1,m1) -> 
                                                          try
                                                              let (FM fm1)  = m
                                                              let v2O, s2, m2 = fm1 (s1, m1)
                                                              match v2O with
                                                              | None    -> None, s2, m2
                                                              | Some v2 ->
                                                              let (FM fm2) = f v2
                                                              let v3O, s3, m3 = fm2 (s2, ResultMessage.addMsg m1 m2)
                                                              v3O, s3,                       ResultMessage.addMsg m2 m3
                                                          with e ->
                                                              let me = ExceptMsg(e.Message, e.StackTrace)
                                                              None, s1,                      ResultMessage.addMsg m1 me
                                                       )
                    let inline map          f     m  = bind (f >> rtn) m
                
                    let inline wrap               f  = FM f
                    let inline getFun         (FM f) =    f
                    let inline from                m = m : FusionM<_, _, _>
                
                    let inline run               s m = getFun m (s, NoMsg)
                
                    let inline OkF               v   = FM(fun (s,r) -> Some v , s , NoMsg)
                    let inline OkFMsg            v m = FM(fun (s,r) -> Some v , s , m    )
                    let inline ErrorF              m = FM(fun (s,r) -> None   , s , m    )
                
                    let inline getS               () = FM(fun (s,r) -> Some s , s , NoMsg)
                    let inline getR               () = FM(fun (s,r) -> Some r , s , NoMsg)
                    let inline putS               s1 = FM(fun (s,r) -> Some (), s1, NoMsg)
                    let inline check              () = FM(fun (s,r) -> (if ResultMessage.isFatal    r then None else Some ())  , s , NoMsg)
                
                    let inling getOption          m  = FM(fun (s1,m1) ->
                                                           try
                                                               let (FM fm1)  = m
                                                               let        v2O, s2, m2 = fm1 (s1, m1)
                                                               Some v2O, s2, m2
                                                           with e ->
                                                               let me = ExceptMsg(e.Message, e.StackTrace)
                                                               None, s1, ResultMessage.addMsg m1 me
                                                       )
                
                
                    let inline ofResultRM          r = match r with Ok   v -> OkF    v  | Error e -> ErrorF                           e
                    let inline ofResultM           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (Message                  e)
                    let inline ofResultS           r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg                 e)
                    let inline ofResult            r = match r with Ok   v -> OkF    v  | Error e -> ErrorF (ErrorMsg <| sprintf "%A" e)
                    let inline ofOption         f  o = match o with Some v -> OkF    v  | None    -> ErrorF (f()                       )
                    let inline ofMessage           m =                        OkFMsg ()                     (Message                  m)
                    let inline ofResultMessage     m =                        OkFMsg ()                                               m
                    let inline ofFusionM           m = from m
                
                    let        freeMessageF     f  m = FM(fun (s1,m1) -> 
                                                          try
                                                              let (FM fm1)  = m
                                                              let v2O, s2, m2 = fm1 (s1, ResultMessage.freeMessage    m1)
                                                              v2O, s2,                   ResultMessage.freeMessageF f m2
                                                          with e ->
                                                              let me = ExceptMsg(e.Message, e.StackTrace)
                                                              None, s1,                      ResultMessage.addMsg m1 me |> ResultMessage.freeMessage
                                                       )
                    let inline freeMessage         m = m |> freeMessageF (sprintf "%O" >> ErrorMsg )
                    let inline freeMessageW        m = m |> freeMessageF (sprintf "%O" >> Warning  )
                
                    let mapState           get set m = FM(fun (s1, r) -> 
                                                            let vO, s2, r = getFun m (get s1, r)
                                                            vO, set s1 s2, r
                                                        )
                
                    let iterReader     fM f  v     m  = m |> map f |> run v |> fun (vO, _, m) -> vO |> Option.iter id ; if m <> NoMsg then fM m
                
                    let memoizeRm      getStore fRm p = FM(fun (r:'r, m) ->
                                                            let (checkO:'p->'v option), (getOrAdd:'p->('p->'v)->'v) = getStore r
                                                            let store p v = getOrAdd p (fun _ -> v)
                                                            checkO p 
                                                            |> Option.map rtn 
                                                            |> Option.defaultWith (fun () -> fRm p |> map (store p) )
                                                            |> run r
                                                        )
                
                    let inline apply           fR    vR = fR |> bind (swap map  vR)
                    let (>>=)                       v f = bind f v
                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))
                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList
                    let inline sequenceSeq           sq = traverseSeq id sq
                    
                    let inline readerFun             f  = getS() |> map f
                    let mapReader           v      m  = m |> mapState (fun _ -> v) (fun s _ -> s)
                    let runReader           v      m  = m |> run v |> fun (vO, _, m) -> vO |> Option.map(fun v -> v, m) |> Result.ofOption (fun () -> m)
                    let runResult                  m  = m |> runReader        ()
                    let iterResult          fM f   m  = m |> iterReader  fM f ()
                    let iterResultPrint            m  = m |> iterReader  (ResultMessage.summarized >> print) print ()
                    
                    let inline insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)
                    let inline insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v
                    let inline insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)
                    let inline insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)
                    let inline absorbR (vvRm)                         = vvRm  |> bind ofResultRM
                    let inline absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR
                    
                    module Operators =
                        let inline (<*>) f v   = apply f v
                        let inline (|>>) v f   = map   f v
                        let inline (>>=) v f   = bind  f v
                        let inline (>>>) f g v = f v |>> g
                        let inline (>=>) f g v = f v >>= g
                        let inline rtn   v     = rtn    v
                    
                    module Builder =
                        type Builder() =
                            member inline __.Return      x                  = rtn     x
                            member inline __.ReturnFrom  x                  = from    x
                            member        __.Bind       (w , r )            = bind    r w
                            member inline __.Zero       ()                  = rtn ()
                            member inline __.Delay       f                  = f
                            member inline __.Combine    (a, b)              = bind b a
                            member inline __.Run         f                  = wrap(fun m -> f() |> getFun <|m )
                            member __.While(guard, body) =
                                let rec whileLoop guard body =
                                    if guard() then body() |> bind (fun () -> whileLoop guard body)
                                    else rtn   ()
                                whileLoop guard body
                            member this.TryWith   (body, handler     ) = wrap(fun r -> try body() |> getFun <| r with e -> handler     e            )
                            member this.TryFinally(body, compensation) = wrap(fun r -> try body() |> getFun <| r finally   compensation()           )
                            member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )
                                        let body' = fun () -> body disposable
                                        this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )
                            member this.For(sequence:seq<_>, body) =
                                this.Using(sequence.GetEnumerator(),fun enum -> 
                                    this.While(enum.MoveNext, 
                                        this.Delay(fun () -> body enum.Current)))
                    
                    let fusion = Builder.Builder()
                        
                    
                    
                /// Based on Nick Palladino's https://github.com/palladin/Eff
                
                [< AutoOpen >]
                module Eff =
                    type Effect  = abstract Extend : (Effect -> Effect) -> Effect
                
                    type Eff<'H, 'a> = Eff of (('a -> Effect) -> Effect) 
                        with  member this.Create = match this with Eff create -> create
                
                    let inline rtn  v : Eff<'H, 'a> = Eff (fun k -> k v)
                    let bind  (f: 'a -> Eff<'H, 'b>) (effA: Eff<'H, 'a>) : Eff<'H, 'b> = 
                                        Eff (fun kb -> 
                                                let (Eff effKa) = effA
                                                effKa (fun a -> 
                                                    let (Eff effKb) = f a
                                                    effKb kb
                                                )
                                            )
                    let inline map   f  m  = bind (f >> rtn) m
                    let inline apply fR vR = fR |> bind (fun f -> map f vR)
                
                    type Done<'a>(v : 'a) =
                        member self.Value = v
                        interface Effect with member self.Extend(_) : Effect = self :> _
                
                    let done'  (v : 'a) : Effect = new Done<'a>(v) :> _ 
                    //let return'(v : 'a) : Eff<'H, 'c> = Eff( fun _ -> done' v )
                    let return' v = Eff( fun _ -> done' v )
                
                    let run<'H, 'a> (eff: Eff<'H, 'a>) : 'a =
                        match eff.Create done' with
                        | :? Done<'a> as done' -> done'.Value
                        | v                    -> failwithf "Unhandled effect %A" v
                
                    let inline runResult<'H, 'a> eff = 
                        try run<'H, 'a> eff |> Ok
                        with e -> Error(e.ToString())
                
                
                    let inline ( <*> ) f v   = apply f v
                    let inline ( |>> ) v f   = map   f v
                    let inline ( >>= ) v f   = bind  f v
                    let inline ( >-> ) f g v = f v |>> g
                    let inline ( >=> ) f g v = f v >>= g
                    
                    #if TEE
                    let inline ( |>>!) v f   = map   (tee f                       ) v
                    let inline ( >>=!) v f   = bind  (fun w -> f w |>> fun () -> w) v
                    #endif
                    
                    let inline join m = m |> bind id
                    
                    let traverseSeq            f     sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))
                                                          Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |>> Seq.ofList
                    let inline sequenceSeq           sq = traverseSeq id sq
                    
                    let inline insertO    vvO               = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)
                    let inline insertR   (vvR:Result<_,_>)  = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v
                    let inline insertFst (fst, vEf)         = vEf   |> map (fun v -> fst, v)
                    let inline insertSnd (vEf, snd)         = vEf   |> map (fun v -> v, snd)
                    
                    let inline bindO (f:'a->Eff<'H,'b>) (ef:Eff<'H,'a option>) = bind (Option.map f >> insertO) ef
                    let rec whileLoop cond fEf =
                        if   cond () 
                        then fEf  () |> bind (fun () -> whileLoop cond fEf)
                        else rtn  ()
                    
                    
                    type EffBuilder<'H>() =
                        member __.ReturnFrom            vEf        : Eff<'H, _   > =           vEf
                        member __.Return                v          : Eff<'H, _   > = rtn       v  
                        member __.Zero                  ()         : Eff<'H, unit> = rtn       () 
                        member __.Bind                 (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf
                        member __.Combine              (vEf,  fEf) : Eff<'H, _   > = bind fEf  vEf
                        member __.Delay                       fEf                  = fEf
                        member __.Run                         fEf  : Eff<'H, _   > = rtn () |> bind fEf
                        member this.TryWith   (body, handler     ) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)
                        member this.TryFinally(body, compensation) : Eff<'H,_> = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )
                        member this.Using     (disposable, body  ) : Eff<'H,_> = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )
                                    let body' = fun () -> body disposable
                                    this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )
                        member __.While   (guard , fEf) : Eff<'H, unit> = whileLoop guard fEf 
                        member th.For  (s: 'a seq, fEf) : Eff<'H, unit> = th.Using(s.GetEnumerator (), fun enum ->
                                                                                        th.While(enum.MoveNext,
                                                                                            th.Delay(fun () -> fEf enum.Current)))
                    
                    let eff<'H> = EffBuilder<'H>()
                    
                    //type EffBuilder<'H>() =
                    //    member self.Zero      (                 ) = rtn ()
                    //    member self.Return    (v   :         'A ) = rtn v
                    //    member self.ReturnFrom eff                = eff
                    //    member self.Bind      (eff, f           ) = bind f eff
                    //    member self.Combine   (first, second    ) = bind (fun () -> second) first
                    //    member __.Combine   (vEf,  fEf) : Eff<'H  , 'm> = bind fEf  vEf
                    //    member self.Delay (f : unit -> Eff<'U, 'A>) : Eff<'U, 'A> =  Eff (fun k -> let (Eff cont) = f () in cont k)
                    ////    member inline __.Delay       f                  = f
                    //    member __.While(guard, body) =
                    //        let rec whileLoop guard body =
                    //            if guard() then body() |> bind (fun () -> whileLoop guard body)
                    //            else rtn   ()
                    //        whileLoop guard body
                    //    member this.TryWith   (body, handler     ) = Eff(fun k -> try body() |> function Eff(f) -> f k with e -> handler e |> function Eff(f) -> f k)
                    //    member this.TryFinally(body, compensation) = Eff(fun k -> try body() |> function Eff(f) -> f k finally   compensation()           )
                    //    member this.Using     (disposable, body  ) = //wrap(fun r -> using (disposable:#System.IDisposable) (fun u -> body u |> getFun <| r) )
                    //                let body' = fun () -> body disposable
                    //                this.TryFinally(body', fun () -> if disposable :> obj <> null then (disposable:#System.IDisposable).Dispose() )
                    //    member this.For(sequence:seq<_>, body) =
                    //        this.Using(sequence.GetEnumerator(),fun enum -> 
                    //            this.While(enum.MoveNext, 
                    //                fun () -> this.Delay(fun () -> body enum.Current)))
                    //
                    //
                    //let eff<'H> = new EffBuilder<'H>()
                    
                    //type EA<'H, 'a, 'b> = 'a -> Eff<'H, 'b>
                    /// Equal to (|>) 
                    //let (>|>) (ea:EA<_,_,_>) f : EA<_,_,_> = ea |> f
                    /// Equal to (>>)
                    //let (>>>) = (>>)
                    
                    module EA =
                        let tee (f: 'a -> Eff<'H, unit>) : 'a -> Eff<'H, 'a> = (fun v -> f v |> map (fun () -> v) )
                    
                    //    let mapOutput  f (ea: EA<_,_, _>) : EA<_,_,          _   > = ea >> (bind (f >> rtn) )
                    //    let bindOutput(f: EA<_,_, _>) (ea: EA<_,_, _>) : EA<_,_, _> = ea >> (bind  f  )
                    //    let mapBoth    f (ea: EA<_,_, _>) : EA<_,_,          _   > = fun i -> i |> mapOutput (f i) ea
                    //    let bindBoth   f (ea: EA<_,_, _>) : EA<_,_,          _   > = mapBoth f  ea |> bindOutput id
                    //
                    //    let mapO         (ea: EA<_,_, _>) : EA<_,_,          _   > = Option.map ea >> insertO
                    //
                    //    let mapFst     f (a, b) = (f a,   b)
                    //    let mapSnd     f (a, b) = (  a, f b)
                    //
                    //    let bindFst    (f:EA<_,_,_>) (a, b) = eff {
                    //        let! fa = f a
                    //        return (fa, b)
                    //    }
                    //
                    //    let bindSnd    (f:EA<_,_,_>) (a, b) = eff {
                    //        let! fb = f b
                    //        return (a, fb)
                    //    }
                    //
                    //    let lift    f : EA<_,_,_> = f >> rtn
                    //    let pairWith v ea : EA<_,_,_> =
                    //        ea
                    //        >-> fun fst -> fst, v
                    //
                    //    let getResult ea:EA<_,_,_> = ea >-> Ok
                    
                    
                    module Reader =
                        type Reader< 'E> = interface end // this acts as a reminder to add a handler for the Effect
                        type Reader2<'E> = interface end // this acts as a reminder to add a handler for the Effect
                        type Reader3<'E> = interface end // this acts as a reminder to add a handler for the Effect
                        type Reader4<'E> = interface end // this acts as a reminder to add a handler for the Effect
                        type Reader5<'E> = interface end // this acts as a reminder to add a handler for the Effect
                    
                        type Ask<'E>(k : 'E -> Effect) =
                            member self.K = k
                            interface Effect with
                                member self.Extend extension : Effect = new Ask<'E>(k >> extension) :> _
                    
                        let ask () : Eff<'H, 'E> when 'H :> Reader< 'E> = Eff (fun k -> Ask(k) :> _ )
                        let ask2() : Eff<'H, 'E> when 'H :> Reader2<'E> = Eff (fun k -> Ask(k) :> _ )
                        let ask3() : Eff<'H, 'E> when 'H :> Reader3<'E> = Eff (fun k -> Ask(k) :> _ )
                        let ask4() : Eff<'H, 'E> when 'H :> Reader4<'E> = Eff (fun k -> Ask(k) :> _ )
                        let ask5() : Eff<'H, 'E> when 'H :> Reader5<'E> = Eff (fun k -> Ask(k) :> _ )
                    
                        let readerHandler0<'E, 'H, 'a> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = 
                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function
                                | :? Done<'a> as done' -> done'.Value        |>      exitK
                                | :? Ask<'E>  as ask   -> ask.K env          |> loop exitK
                                | effect               -> effect.Extend        (loop exitK)
                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)
                    
                        let readerHandler< 'E, 'H, 'a when 'H :> Reader< 'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = readerHandler0<'E, 'H, 'a> env eff
                        let readerHandler2<'E, 'H, 'a when 'H :> Reader2<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = readerHandler0<'E, 'H, 'a> env eff
                        let readerHandler3<'E, 'H, 'a when 'H :> Reader3<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = readerHandler0<'E, 'H, 'a> env eff
                        let readerHandler4<'E, 'H, 'a when 'H :> Reader4<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = readerHandler0<'E, 'H, 'a> env eff
                        let readerHandler5<'E, 'H, 'a when 'H :> Reader5<'E>> (env:'E) (eff: Eff<'H, 'a>) : Eff<'H, 'a> = readerHandler0<'E, 'H, 'a> env eff
                    
                        let readerFun f = ask() |> map f 
                    module State = 
                        type State<'S> = interface end // this acts as a reminder to add a handler for the Effect
                        type Put<  'S>(v : 'S, k : unit -> Effect) =
                            member self.Value = v
                            member self.K = k
                            interface Effect with
                                member self.Extend extension = new Put<'S>(v, k >> extension) :> _
                    
                        type Get<  'S>(k : 'S -> Effect) =
                            member self.K = k
                            interface Effect with
                                member self.Extend extension = new Get<'S>(k >> extension) :> _
                    
                        let get(    ) : Eff<'H, 'S  > when 'H :> State<'S> = Eff (fun k -> new Get<'S>(k   ) :> _)
                        let put(s:'S) : Eff<'H, unit> when 'H :> State<'S> = Eff (fun k -> new Put<'S>(s, k) :> _)
                    
                        let stateHandler<'H, 'S, 'a when 'H :> State<'S>> (state: 'S) (eff: Eff<'H, 'a>) : Eff<'H, 'S * 'a> = 
                            let rec loop (exitK:'S * 'a -> Effect) (state:'S) : Effect -> Effect = function
                                | :? Done<'a> as done'  -> (state, done'.Value) |>       exitK
                                | :? Put< 'S> as put    -> put.K ()             |>  loop exitK put.Value
                                | :? Get< 'S> as get    -> get.K state          |>  loop exitK state 
                                | effect                -> effect.Extend           (loop exitK state)
                            Eff (fun exitK              -> eff.Create done'     |>  loop exitK state)
                    
                        let refHandler<'H, 'S, 'a when 'H :> State<'S>> (state: 'S) (eff: Eff<'H,'a>) : Eff<'H, 'a> = 
                            let valueRef = ref state
                            let rec loop exitK : Effect -> Effect = function
                                | :? Done<'a> as done'  -> done'.Value      |>      exitK
                                | :? Put< 'S> as put    -> valueRef := put.Value
                                                           put.K ()           |> loop exitK 
                                | :? Get< 'S> as get    -> get.K !valueRef    |> loop exitK  
                                | effect                -> effect.Extend        (loop exitK)
                            Eff (fun exitK              -> eff.Create done'   |> loop exitK)
                    
                    
                    module Log = 
                        type Log< 'L> = interface end  // this acts as a reminder to add a handler for the Log Effects
                        type Log2<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects
                        type Log3<'L> = interface end  // this acts as a reminder to add a handler for the Log Effects
                    
                        type LogEntry<'L>(v : 'L, k : unit -> Effect) =
                            member self.Value = v
                            member self.K     = k
                            interface Effect with
                                member self.Extend extension  : Effect = new LogEntry<'L>(v, k >> extension) :> _
                    
                        let log (s:'L)  : Eff<'H, unit> when 'H :> #Log< 'L> = Eff (fun k -> LogEntry(s, k) :> _ )
                        let logf fmt = Printf.ksprintf log fmt
                        let log2 (s:'L) : Eff<'H, unit> when 'H :> #Log2<'L> = Eff (fun k -> LogEntry(s, k) :> _ )
                        let log3 (s:'L) : Eff<'H, unit> when 'H :> #Log3<'L> = Eff (fun k -> LogEntry(s, k) :> _ )
                    
                        let pureLogHandler0<'L, 'H, 'a> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = 
                            let rec loop (exitK:('a * list<'L>) -> Effect) (ls: list<'L>) : Effect -> Effect = function
                                | :? Done<    'a> as done' -> (done'.Value, ls)  |>       exitK
                                | :? LogEntry<'L> as log   -> log.K ()           |>  loop exitK (log.Value :: ls)  
                                | effect                   -> effect.Extend         (loop exitK ls               )
                            Eff (fun exitK                 -> eff.Create done'   |>  loop exitK []               )
                    
                        let consoleLogHandler0<'L, 'H, 'a> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =
                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function
                                | :? Done<    'a> as done' -> done'.Value        |>      exitK
                                | :? LogEntry<'L> as log   -> printfn "Log: %A" log.Value
                                                              log.K ()           |> loop exitK
                                | effect                   -> effect.Extend        (loop exitK)
                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)
                    
                        let loggerLogHandler0<'L, 'H, 'a> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> =
                            let rec loop (exitK: 'a -> Effect) : Effect -> Effect = function
                                | :? Done<    'a> as done' -> done'.Value        |>      exitK
                                | :? LogEntry<'L> as log   -> logger log.Value
                                                              log.K ()           |> loop exitK
                                | effect                   -> effect.Extend        (loop exitK)
                            Eff (fun exitK                 -> eff.Create done'   |> loop exitK)
                    
                        let pureLogHandler< 'L, 'H, 'a when 'H :> Log< 'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = pureLogHandler0<'L, 'H, 'a> eff
                        let pureLogHandler2<'L, 'H, 'a when 'H :> Log2<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = pureLogHandler0<'L, 'H, 'a> eff
                        let pureLogHandler3<'L, 'H, 'a when 'H :> Log3<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a * list<'L>> = pureLogHandler0<'L, 'H, 'a> eff
                    
                    
                        let consoleLogHandler< 'L, 'H, 'a when 'H :> Log< 'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> = consoleLogHandler0<'L, 'H, 'a> eff
                        let consoleLogHandler2<'L, 'H, 'a when 'H :> Log2<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> = consoleLogHandler0<'L, 'H, 'a> eff
                        let consoleLogHandler3<'L, 'H, 'a when 'H :> Log3<'L>> (eff: Eff<'H, 'a>) : Eff<'H, 'a> = consoleLogHandler0<'L, 'H, 'a> eff
                    
                        let loggerLogHandler< 'L, 'H, 'a when 'H :> Log< 'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> = loggerLogHandler0<'L, 'H, 'a> logger eff
                        let loggerLogHandler2<'L, 'H, 'a when 'H :> Log2<'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> = loggerLogHandler0<'L, 'H, 'a> logger eff
                        let loggerLogHandler3<'L, 'H, 'a when 'H :> Log3<'L>> logger (eff: Eff<'H, 'a>) : Eff<'H, 'a> = loggerLogHandler0<'L, 'H, 'a> logger eff
                    
                    module Rsl = 
                    
                    
                        type Rsl<'M> = interface end
                        
                        type IRsl<'M> = abstract Value : 'M
                    
                        type Fail<'a,'M>(v : 'M, k : 'a -> Effect) =
                            member self.Value = v
                            member self.K     = k
                            interface Effect   with member __.Extend extension : Effect = new Fail<'a,'M>(v, k >> extension) :> _
                            interface IRsl<'M> with member __.Value = v
                    
                        let fail (s:'M) : Eff<'H, _> when 'H :> #Rsl<'M> = Eff (fun k -> new Fail<_,_>(s, k) :> _)
                        let failf fmt = Printf.ksprintf fail fmt
                        let inline ofResult (res:Result<'a,'b>) : Eff<'c,'a> = eff {
                            match res with
                            | Ok    v   ->  return v
                            | Error msg ->  let! m = fail msg
                                            return failwith "this code should be unreachable"
                        }
                        
                        let rslHandler<'U, 'M, 'A when 'U :> Rsl<'M>> (eff: Eff<'U, 'A>) : Eff<'U, _> = 
                            let rec loop (exitK:(Result<'A,'M>) -> Effect) : Effect -> Effect = function
                                | :? Done<    'A> as done' -> Ok    done'.Value |>       exitK
                                | :? IRsl<    'M> as fail  -> Error fail .Value |>       exitK
                                | effect                   -> effect.Extend        (loop exitK)
                            Eff (fun exitK                 -> eff.Create done'  |>  loop exitK)
                    
                        let inline getResult   v                = v     |> rslHandler
                        let inline absorbR     vvEf             = vvEf  |> bind ofResult
                        let inline absorbO   f vOEf             = vOEf  |> map (Result.ofOption  f) |> absorbR
                    
                    module Asy = 
                        type Asy = interface end // this acts as a reminder to add a handler for the Effect
                    
                        type AsynG =
                            abstract RunSync      : unit               -> Effect
                            abstract RunAsync<'a> : (Effect -> Effect) -> Effect
                    
                        [< Inline "console.log('RunSynch Not implemented in JavaSacript')" >]
                        let runSynch v = Async.RunSynchronously v
                    
                        type Asyn<'v>(v : Async<'v>, k : ('v -> Effect) ) =
                            member __.Value = v
                            member __.K     = k
                            interface Effect with member __.Extend   extension = new Asyn<_>(v, k >> extension) :> _
                            interface AsynG  with 
                                member __.RunSync  ()        = runSynch v |> k
                                member __.RunAsync<'a> exitK = done' (v |> Async.bind (fun v -> k v |> exitK :?> Done<Async<'a>> |> fun don -> don.Value ) )
                    
                        let inline ofAsync (v:Async<'a>) : Eff<'H, 'a> when 'H :> Asy= Eff (fun k -> new Asyn<'a>(v, k) :> _)
                    
                        /// This handler uses RunSynchronously to resolve Asyncs
                        let syncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, 'a> =
                            let rec loop (exitK:'a -> Effect) : Effect -> Effect = function
                                | :? Done<'a> as done' -> done'.Value        |>      exitK
                                | :? AsynG    as asy   -> asy.RunSync()      |> loop exitK
                                | effect               -> effect.Extend        (loop exitK)
                            Eff (fun exitK             -> eff.Create done'   |> loop exitK)
                    
                        /// this should be the last handler before Eff.run
                        let asyncHandler0<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = 
                            let rec loop (exitK:(Async<'a>) -> Effect) : Effect -> Effect = function
                                | :? Done<'a> as done' -> done'.Value |> async.Return |>      exitK
                                | :? AsynG    as asy   -> asy.RunAsync<'a>              (loop exitK)
                                | effect               -> effect.Extend                 (loop exitK)
                            Eff (fun exitK             -> eff.Create done'            |> loop exitK)
                    
                        let asyncHandler<'H, 'a when 'H :> Asy> (eff: Eff<'H, 'a>) : Eff<'H, Async<'a>> = 
                            Async.rtn () 
                            |>  ofAsync 
                            >>= fun () -> eff 
                            |>  asyncHandler0
                    
                [< AutoOpen >]
                module EffReadLogRslAsy =
                
                    type ReaderLogRslAsy<'read, 'log, 'err>() = interface Reader.Reader<'read> interface Log.Log<'log> interface Rsl.Rsl<'err> interface Asy.Asy
                
                    let inline runReaderLRA readV eff = 
                        eff
                        |> Reader.readerHandler readV
                        |> Log.pureLogHandler
                        |> Rsl.rslHandler
                        |> Asy.asyncHandler
                        |> Eff.run<ReaderLogRslAsy<_,_,_>,_>
                
                //    let inline ofResultRM mr = eff {
                //        match mr with
                //        | Ok    v    -> return v
                //        | Error rmsg ->        
                //        match rmsg with
                //        | NoMsg          -> do! Rsl.fail <| ErrorMsg "Failed! (no explanation)"
                //        | RMessages msgs -> for msg in msgs do do! Log.log msg
                //                            do! Rsl.fail <| ErrorMsg (ResultMessage.summarized rmsg)
                //        | msg            -> do! Rsl.fail    msg
                //        return Unchecked.defaultof<_>
                //    }
                //
                //    let inline ofAsyncResultRM mra = Asy.ofAsync mra >>= ofResultRM
                //
                //    let inline ofFusionReader (fr:FusionM<'v,'s,'m>) = eff {
                //        let! (s: 's)       = Reader.ask()
                //        let! (v: 'v), rmsg = fr |> FusionM.runReader s |> Rsl.ofResult
                //        match rmsg with
                //        | NoMsg          -> ()
                //        | RMessages msgs -> for msg in msgs do do! Log.log msg
                //        | msg            ->                    do! Log.log msg
                //        return v
                //    }
                
                    let executeConsoleSync1 rdr monad =
                        monad
                        |> Reader.readerHandler rdr
                        |> Log.consoleLogHandler
                        |> Rsl.rslHandler
                        |> Asy.syncHandler
                        |> fun (eff : Eff<ReaderLogRslAsy<_,_,_>,_>) -> Eff.run eff
                        |> Result.iter print id
                
                    type ReaderLogRslAsy<'r1, 'r2, 'r3, 'r4, 'r5, 'log, 'err>() = 
                        interface Reader.Reader< 'r1>
                        interface Reader.Reader2<'r2>
                        interface Reader.Reader3<'r3>
                        interface Reader.Reader4<'r4>
                        interface Reader.Reader5<'r5>
                        interface Log.Log<'log> 
                        interface Rsl.Rsl<'err> 
                        interface Asy.Asy
                
                    let executeConsoleSync (rdr5:'r5) (rdr4:'r4) (rdr3:'r3) (rdr2:'r2) (rdr1:'r1) monad =
                        monad
                        |>(if typedefof<'r1> = typedefof<unit> then id else Reader.readerHandler  rdr1 )
                        |>(if typedefof<'r2> = typedefof<unit> then id else Reader.readerHandler2 rdr2 )
                        |>(if typedefof<'r3> = typedefof<unit> then id else Reader.readerHandler3 rdr3 )
                        |>(if typedefof<'r4> = typedefof<unit> then id else Reader.readerHandler4 rdr4 )
                        |>(if typedefof<'r5> = typedefof<unit> then id else Reader.readerHandler5 rdr5 )
                        |> Log.consoleLogHandler
                        |> Rsl.rslHandler
                        |> Asy.syncHandler
                        |> fun (eff : Eff<ReaderLogRslAsy<_,_,_,_,_,_,_>,_>) -> Eff.run eff
                        |> Result.iter print id
                
                type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>
                
                /// A computation expression to build an Async<Result<'ok, 'error>> value
                module AsyncResult =
                    let mapError fE v  = v |> Async.map (Result.mapError fE)
                    let freeMessage v  = v |> Async.map  Result.freeMessage
                
                    let rtn        v   = async.Return(Ok v  )
                    let rtnR       vR  = async.Return    vR
                    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA
                    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA
                    let bind  fRA  vRA = async { 
                        let! vR       = vRA
                        match   vR with
                        | Ok    v -> return! fRA v
                        | Error m -> return  Error m 
                    }
                    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {
                        try 
                            let!  vR = vRA
                            match vR with
                            | Ok    v -> return! fRA   v
                            | Error m -> return  Error m
                        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error
                    }
                    let inline map  f m = bind  (f >> rtn) m            
                    let inline mapP f m = bindP (f >> rtn) m            
                    let rec whileLoop cond fRA =
                        if   cond () 
                        then fRA  () |> bind (fun () -> whileLoop cond fRA)
                        else rtn  ()
                    let (>>=)                              v f = bind f v
                    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))
                                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList
                    let inline sequenceSeq                  sq = traverseSeq id sq
                    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)
                    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v
                    let absorbR   vRRA                         = vRRA |> Async.map  Result.join
                    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)
                
                type AsyncResultBuilder() =
                    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA
                    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR
                    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  
                    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () 
                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA
                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)
                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA
                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)
                    member __.Delay            fRA                            = fRA
                    member __.Run              fRA                            = AsyncResult.rtn () |> AsyncResult.bind fRA
                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { try return! fRA() with e -> return! hnd e  }
                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { try return! fRA() finally   fn  () }
                    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)
                    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA 
                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->
                                                                                    th.While(enum.MoveNext,
                                                                                      th.Delay(fun () -> fRA enum.Current)))
                let asyncResult = AsyncResultBuilder()
                
                type AsyncResultBuilderP() =
                    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA
                    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR
                    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  
                    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () 
                    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA
                    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)
                    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA
                    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)
                    member __.Delay            fRA                                          = fRA
                    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA
                    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }
                    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }
                    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)
                    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA 
                    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->
                                                                                              th.While(enum.MoveNext,
                                                                                                th.Delay(fun () -> fRA enum.Current)))
                let asyncResultP = AsyncResultBuilderP()
                
                [<AutoOpen>]
                module Extensions =      
                    // Having Async<_> members as extensions gives them lower priority in
                    // overload resolution between Async<_> and Async<Result<_,_>>.
                    type AsyncResultBuilder with
                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA
                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)
                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)
                
                    type AsyncResultBuilderP with
                      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA
                      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)
                      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)
                
                
                
            type System.String with
                member this.Substring2(from, n) = 
                    if   n    <= 0           then ""
                    elif from <  0           then this.Substring2(0, n + from)
                    elif from >= this.Length then ""
                    else this.Substring(from, min n (this.Length - from))
                member this.Left             n  = if n < 0 
                                                  then this.Substring2(0, this.Length + n)
                                                  else this.Substring2(0, n              )
                member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)
                member this.toUnderscore        = this |> Seq.mapi(fun i c -> if i > 0 && System.Char.IsUpper(c) then [ '_' ; c ] else [ c ])  |> Seq.collect id |> Seq.toArray |> System.String
            
            module String =
                let splitByChar (c: char) (s: string) = s.Split c
                let splitInTwoO spl txt = 
                    let i = (txt:string).IndexOf (spl:string)
                    if  i = -1 then None else
                    (txt.Left(i), txt.Substring (i + spl.Length) )
                    |> Some
                let delimitedO  op cl txt =
                    splitInTwoO op txt
                    |> Option.bind(fun (bef, sec) ->
                        splitInTwoO cl sec
                        |> Option.map(fun (mid, aft) -> bef, mid, aft)
                    )
                let contains     sub  (whole: string) = whole.Contains sub
                let trim                  (s: string) = s.Trim()
                let append     (a: string)(b: string) =  a + b
                let skipFirstLine (txt:string) = txt.IndexOf '\n' |> fun i -> if i < 0 then "" else txt.[i + 1..]
                let unindent (s:string) =
                    let lines = s.Split '\n'
                    let n     = lines 
                                |> Seq.tryFind (fun l -> l.Trim() <> "")
                                |> Option.defaultValue ""
                                |> Seq.tryFindIndex ((<>) ' ') 
                                |> Option.defaultValue 0
                    lines 
                    |> Seq.map    (fun l -> if l.Length <= n then "" else l.Substring n)
                    |> Seq.filter (fun s -> s.StartsWith "# 1 " |> not)
                let indent n (s:string) =
                    s.Split '\n'
                    |> Seq.map ((+) (String.replicate n " "))
                let unindentStr = unindent >> String.concat "\n"
                let indentStr i = indent i >> String.concat "\n" 
                let skipLastLine =
                       splitByChar '\n' 
                    >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]
                    >> String.concat "\n"
                let (|StartsWith|_|) (start:string) (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None
                let (|EndsWith  |_|) (ends :string) (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None
                
                let thousands n =
                    let v = n.ToString()
                    let r = v.Length % 3 
                    let s = if r = 0 then 3 else r
                    [   yield v.[0.. s - 1]
                        for i in 0..(v.Length - s)/ 3 - 1 do
                            yield v.[i * 3 + s .. i * 3 + s + 2]
                    ] |> String.concat ","
            
            let mapFst     (f: 'a->'c) (a:'a, b:'b) = (f a,   b)
            let mapSnd     (f: 'b->'c) (a:'a, b:'b) = (  a, f b)
            
            [< Inline "$a + '/' + $b" >]
            let inline (+/+) a b = System.IO.Path.Combine(a, b)
            
            module ParseO =
                let tryParseWith tryParseFunc = tryParseFunc >> function
                        | true, v    -> Some v
                        | false, _   -> None
            
            
                /// Javascript adds time zone information when parsing a date and that can change the result
                let parseDateO2  = (fun s -> s + "T00:00:00") >> tryParseWith System.DateTime.TryParse
                let parseDateO   = tryParseWith System.DateTime.TryParse
                let parseIntO    = tryParseWith System.Int32   .TryParse
                let parseInt64O  = tryParseWith System.Int64   .TryParse
                let parseSingleO = tryParseWith System.Single  .TryParse
                let parseDoubleO = tryParseWith System.Double  .TryParse
                let parseGuidO   = tryParseWith System.Guid    .TryParse
                // etc.
                
                // active patterns for try-parsing strings
                let (|Date  |_|) = parseDateO
                let (|Int   |_|) = parseIntO
                let (|Int64 |_|) = parseInt64O
                let (|Single|_|) = parseSingleO
                let (|Double|_|) = parseDoubleO
                let (|Guid  |_|) = parseGuidO
                
            module Serializer =
                open System
            
                type JsonIntermediate = {
                    tryFloat    : unit   ->  float                option
                    tryInt      : unit   ->  int64                option
                    tryString   : unit   ->  string               option
                    tryBool     : unit   ->  bool                 option
                    tryArray    : unit   -> (JsonIntermediate []) option
                    tryField    : string ->  JsonIntermediate     option
                    isObject    : unit   ->  bool
                    isNull      : unit   ->  bool
                }
            
                type SerS<'T> = ('T                 -> string   )        //      Serialization function
                type SerD<'T> = (JsonIntermediate   -> 'T option)        //    deSerialization function
                type Ser< 'T> = SerS<'T> * SerD<'T>                      // both Serialization functions
            
                let serialize (ser: Ser<_>) v = fst ser v
                let (|Field|_|) field j = j.tryField field
            
                let [< Inline >] inline sprintU v = sprintf "%A"       v
                let [< Inline >] inline sprintQ v = sprintf "\"%A\""   v
                let              inline sprintA v = String.concat ", " v |> sprintf "[%s]"
            
                let toJsonString (v:string) =
                    seq {
                        yield '"'
                        if String.IsNullOrEmpty v |> not then
                            for i = 0 to v.Length - 1 do
                                let c = v.[i]
                                let ci = int c
                                if ci >= 0 && ci <= 7 || ci = 11 || ci >= 14 && ci <= 31 then
                                    yield! sprintf "\\u%04x" ci
                                else 
                                match c with
                                | '\b' -> yield! "\\b"
                                | '\t' -> yield! "\\t"
                                | '\n' -> yield! "\\n"
                                | '\f' -> yield! "\\f"
                                | '\r' -> yield! "\\r"
                                | '"'  -> yield! "\\\""
                                | '\\' -> yield! "\\\\"
                                | _    -> yield c
                        yield '"'
                    } |> Seq.toArray|> String
            
                let serString : Ser<string  > = toJsonString          , (fun j -> j.tryString()                         )
                let serFloat  : Ser<float   > = sprintU               , (fun j -> j.tryFloat ()                         )
                let serInt    : Ser<int     > = sprintU               , (fun j -> j.tryInt   () |> Option.map int       )
                let serInt64  : Ser<int64   > = sprintf "%d"          , (fun j -> j.tryInt   ()                         )
                let serBool   : Ser<bool    > = sprintU               , (fun j -> j.tryBool  ()                         )
                let serDate   : Ser<DateTime> = (date2Long >> sprintU), (fun j -> j.tryInt   () |> Option.map long2Date )
            
                let [< Inline >] inline serId  (get: 'a -> System.Guid) (set:System.Guid -> 'a) (print: 'a->string) : Ser<'a> =
                    let s               = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head
                    let sQ              = sprintf "%A" s
                    let serialize   gid = get gid |> string |> sprintf "{%10s :%A}" sQ
                    let deserialize j   = j.tryField s 
                                          |> Option.bind (fun jf -> jf.tryString() ) 
                                          |> Option.bind ParseO.parseGuidO 
                                          |> Option.map  set
                    serialize, deserialize
            
                let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = 
                    serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc j -> deser j |> Option.map (fun v -> set v rc) ) 
                    
                let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =
                    if isNull (init :> obj) then failwith "Initial record is null"
                    let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf "%A: %s" n (ser dim)) |> String.concat ", " |> sprintf "{%s}"
                    let deserialize j   = fields |> Seq.fold (fun dim (n, _ser,  deser) -> j.tryField n |> Option.bind (deser dim) |> Option.defaultValue dim)   init |> Some
                    serialize, deserialize
                
                let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.ofArray)
                let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser))                          )
                let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Seq.toList )
                let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                                 ), (fun j -> j.tryArray () |> Option.map (Array.choose (snd ser)) |> Option.map Set        )
                let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue "null"              ), (fun j -> (if j.isNull() then None else              snd ser j)|> Some                  )
                let serDup(serFst,serSnd): Ser<'a * 'b    > = (fun (f,s  ) -> sprintf "[%s, %s]" (fst serFst f) (fst serSnd s) ), (fun j -> j.tryArray () 
                                                                                                                                            |> function 
                                                                                                                                                | Some [| j1 ; j2 |] -> match snd serFst j1, snd serSnd j2 with
                                                                                                                                                                        | Some f, Some s -> Some(f, s) |_->None
                                                                                                                                                | _ -> None )
                let serTrp(sF,sS,sT)      : Ser<'a *'b*'c > = (fun (f,s,t) -> sprintf "[%s, %s, %s]" (fst sF f) (fst sS s)  (fst sT t)) , (fun j -> j.tryArray () 
                                                                                                                                                    |> function 
                                                                                                                                                        | Some [| j1 ;j2; j3|]   -> match snd sF j1, snd sS j2, snd sT j3 with
                                                                                                                                                                                    | Some f, Some s, Some t -> Some(f, s, t) |_-> None
                                                                                                                                                        | _ -> None ) 
                let serMap serKey serElm : Ser<Map<'k, 'e>> =   serDup(serKey, serElm)
                                                                |> serSeq 
                                                                |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Option.map Map) )
            
            
            [<System.Runtime.CompilerServices.Extension >]
            type MailboxProcessorExt =
                [<System.Runtime.CompilerServices.Extension ; Inline "throw 'PostAndReply not available in JavaScript'" >]
                static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)
                [<System.Runtime.CompilerServices.Extension>]
                static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)
            //    [<System.Runtime.CompilerServices.Extension>]
            ///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })
            
            module Mailbox =
            
                /// A simple Mailbox processor to serially process Async tasks
                /// use:
                ///      let logThisMsgA = Mailbox.iterA (printfn "%A") (fun msg -> async { printfn "Log: %s" msg } )
                ///      logThisMsgA.Post "message Async"
                ///      
                let iterA hndl f =
                    MailboxProcessor.Start(fun inbox ->
                        async {
                            while true do
                                try       let!   msg = inbox.Receive()
                                          do!  f msg
                                with e -> hndl e
                        }
                    )
                    
                /// A simple Mailbox processor to serially process tasks
                /// use:
                ///      let logThisMsg = Mailbox.iter (printfn "%A") (printfn "Log: %s")
                ///      logThisMsg.Post "message"
                ///      
                let iter hndl f = iterA hndl (fun msg -> async { f msg } )
                
                /// A simple Mailbox processor to serially and synchronously process tasks
                /// use:
                ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> 
                ///                                async { return msg.ToUpper() } )
                ///
                ///      toUpperCaseA.PostAndReply(fun reply -> reply, "message") 
                ///      |> printfn "%s"
                ///
                ///      toUpperCaseA.PostAndReply "message"
                ///      |> printfn "%s"
                ///
                ///      async {
                ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> 
                ///                                                        reply, "message")
                ///          printfn "Async: %s" res
                ///      } |> Async.RunSynchronously
                ///
                ///      async {
                ///          let! res = toUpperCaseA.PostAndAsyncReply "message"
                ///          printfn "Async: %s" res
                ///      } |> Async.RunSynchronously    
                ///      
                let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {
                    let! r = f msg
                    replyChannel.Reply r
                })
                
                /// A simple Mailbox processor to serially and synchronously process tasks
                /// use:
                ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )
                ///      
                ///      toUpperCase.PostAndReply(fun reply -> reply, "message") 
                ///      |> printfn "%s"
                ///      
                ///      toUpperCase.PostAndReply "message"
                ///      |> printfn "%s"
                ///      
                ///      async {
                ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> 
                ///                                                       reply, "message")
                ///          printfn "Async: %s" res
                ///      } |> Async.RunSynchronously
                ///      
                ///      async {
                ///          let! res = toUpperCase.PostAndAsyncReply "message"
                ///          printfn "Async: %s" res
                ///      } |> Async.RunSynchronously
                ///      
                let call hndl f = callA hndl (fun msg -> async { return f msg } )
                
                /// A Mailbox processor that maintains a state
                let foldA hndl f initState =
                    MailboxProcessor.Start(fun inbox ->
                        let rec loop state : Async<unit> = async {
                            try       let! msg      = inbox.Receive()
                                      let! newState = f state msg
                                      return! loop newState
                            with e -> return! loop (hndl e state)
                        }
                        loop initState
                    )
            
                /// A Mailbox processor that maintains a state
                let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState
                
                /// A Mailbox processor that maintains a state (pass an error handler not a folder function)
                /// use: 
                ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)
                ///      agent |> Mailbox.StateFull.getState
                let stateFull hndl initState =
                    MailboxProcessor.Start(fun inbox ->
                        let rec loop state : Async<unit> = async {
                            try       let! f        = inbox.Receive()
                                      let! newState = f state
                                      return! loop newState
                            with e -> return! loop (hndl e state)
                        }
                        loop initState
                    )
                    
                let defHandler ex st = print ex ; st
                    
                module StateFull =
                    let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })
                    let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })
                    let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })
                    let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })
                    let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> 
                                                                                                fun v -> async {
                                                                                                    let! st, r = f v
                                                                                                    reply.Reply r
                                                                                                    return st 
                                                                                                })
                    let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })
                    [< Inline "throw 'getState not available in JavaScript'" >]
                    let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })
                    /// synchronous version pf applyReply
                    [< Inline "throw 'applyReplyS not available in JavaScript'" >]
                    let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> 
                                                                                                fun v -> async {
                                                                                                    let st, r = f v
                                                                                                    reply.Reply r
                                                                                                    return st 
                                                                                                })
            
            type FsCode = FsCode of string
            
            module FsCode =
            
                type PreproDirective =
                | PrepoCd     of string
                | PrepoR      of string
                | PrepoDefine of string
                | PrepoLoad   of string
                | PrepoLine   of string //* int
                | PrepoNoWarn of string
                | PrepoI      of string
                | PrepoIf     of string
                | PrepoElIf   of string
                | PrepoElse   
                | PrepoEndIf
                | PrepoLight  of bool
                | PrepoOther  of string
                | NoPrepo
                
                let extractDefines(FsCode code) = 
                    if code.StartsWith "////-d:" 
                    then code.[4..code.IndexOf '\n' - 1]
                    else ""
            
                let separatePrepros (code:string[]) =
                    let  quoted (line:string) = line.Trim().Split([| "\""       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line
                    let  rest   (line:string) = line.Trim() |> String.splitInTwoO " " |> Option.map snd |> Option.defaultValue "" |> fun s -> s.Trim()
                    let  comment = ((+)"//") 
                    let  prepro (line:string) = 
                        match true with 
                        | true when line       .StartsWith("#define") -> (comment line, line |> rest   |> PrepoDefine)
                        | true when line       .StartsWith("#cd"    ) -> (comment line, line |> quoted |> PrepoCd    )
                        | true when line       .StartsWith("#r"     ) -> (comment line, line |> quoted |> PrepoR     )
                        | true when line       .StartsWith("#load"  ) -> (comment line, line |> quoted |> PrepoLoad  )
                        | true when line       .StartsWith("#nowarn") -> (comment line, line |> quoted |> PrepoNoWarn)
                        | true when line.Trim().StartsWith("# "     ) -> (comment line, line |> quoted |> PrepoLine  )
                        | true when line.Trim().StartsWith("#line"  ) -> (comment line, line |> quoted |> PrepoLine  )
                        | true when line       .StartsWith("#I"     ) -> (comment line, line |> quoted |> PrepoI     )
                        | true when line       .StartsWith("#if"    ) -> (        line, line |> rest   |> PrepoIf    )
                        | true when line       .StartsWith("#elif"  ) -> (        line, line |> rest   |> PrepoElIf  )
                        | true when line       .StartsWith("#else"  ) -> (        line,                   PrepoElse  )
                        | true when line       .StartsWith("#endif" ) -> (        line,                   PrepoEndIf )
                        | true when line       .StartsWith("#light" ) -> (        line, false          |> PrepoLight )
                        | true when line       .StartsWith("#"      ) -> (comment line, line           |> PrepoOther )
                        | _                                           -> (        line,                   NoPrepo    ) 
                    code |> Array.map prepro
            
                type PrepState = 
                | LevelZero
                | TrueValue of PrepState
                | Looking   of PrepState
                | Found     of PrepState
            
                let isActive = function
                | LevelZero
                | TrueValue _ -> true
                | Looking   _ -> false
                | Found     _ -> false
            
                let prev = function
                | LevelZero    -> LevelZero
                | TrueValue pr -> pr
                | Looking   pr -> pr
                | Found     pr -> pr
            
                let filterPreps (preps:PreproDirective seq) =
                    let  defines  = preps |> Seq.choose (function | PrepoDefine d -> Some d | _ -> None) |> Seq.distinct |> Seq.toArray
                    let isDefined (def:string) =    defines |> Seq.contains (def.Replace("!","").Trim()) |> (if def.Trim().StartsWith "!" then not else id)
                    (LevelZero, preps) 
                    ||> Seq.mapFold(fun st prep ->
                        match st, prep with
                        | TrueValue _ , PrepoIf    def             
                        | LevelZero   , PrepoIf    def -> None     , if isDefined def then TrueValue st else Looking st
                        | Looking   _ , PrepoIf    _             
                        | Found     _ , PrepoIf    _   -> None     , Found st
                        |           _ , PrepoEndIf     -> None     , prev  st
                        | TrueValue pr, PrepoElIf  _
                        | TrueValue pr, PrepoElse      -> None     , Found     pr
                        | Looking   pr, PrepoElIf  def -> None     , if isDefined def then TrueValue st else Looking pr
                        | Looking   pr, PrepoElse      -> None     , TrueValue pr
                        | Found     pr, PrepoElIf  _
                        | Found     pr, PrepoElse      -> None     , Found     pr
                        | TrueValue _ , _             
                        | LevelZero   , _              -> Some prep, st
                        | _                            -> None     , st
                        )
                    |>  fst
                    |>  Seq.choose id
                    |>  Seq.toArray
            
                let getTopDirectives (fsNass:(string * PreproDirective) seq) =
                    let  directs  = fsNass |> Seq.map snd |> Seq.filter (function 
                                        | PrepoDefine _
                                        | PrepoR      _ 
                                        | PrepoI      _
                                        | PrepoNoWarn _
                                        | PrepoCd     _ 
                                        | PrepoIf     _
                                        | PrepoEndIf  
                                        | PrepoElIf   _
                                        | PrepoElse    -> true
                                        |_             -> false) |> Seq.toArray
                    let  code     = fsNass |> Seq.map fst |> Seq.toArray
                    code, directs
                    
                let separateDirectives (fsNass:PreproDirective seq) =
                    let  defines  = fsNass |> Seq.choose (function | PrepoDefine d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray
                    let  preps    = filterPreps fsNass
                    let  assembs  = preps  |> Seq.choose (function | PrepoR      assemb -> Some assemb | _ -> None) |> Seq.distinct |> Seq.toArray
                    let  prepoIs  = preps  |> Seq.choose (function | PrepoI      d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray
                    let  nowarns  = preps  |> Seq.choose (function | PrepoNoWarn d      -> Some d      | _ -> None) |> Seq.distinct |> Seq.toArray
                    let  cd       = preps  |> Seq.choose (function | PrepoCd     dir    -> Some dir    | _ -> None) |> Seq.tryHead
                    assembs, defines, prepoIs, nowarns, cd
                    
                let getSourceDir srcDir (lines:string[]) =
                    match lines.[0], Array.tryItem 1 lines with
                    |         String.StartsWith "////#cd @\"" dirq, _ 
                    | _, Some(String.StartsWith "////#cd @\"" dirq) ->  dirq.Trim()
                                                                        |> function
                                                                        | String.EndsWith "\"" dir
                                                                        |                      dir ->
                                                                        match dir with
                                                                        | String.StartsWith "\\" _
                                                                        | String.StartsWith "/"  _            -> dir
                                                                        | _ when Seq.tryItem 1 dir = Some ':' -> dir
                                                                        | _ -> srcDir  +/+                       dir
                    | _                                                     -> srcDir
            
            
            type SnippetId = SnippetId of System.Guid with member x.Id = match x with SnippetId id -> id
                                                           static member Empty = SnippetId System.Guid.Empty
            
            type Snippet = {
                snpId           : SnippetId    
                snpName         : string
                snpContent      : string
                snpParentIdO    : SnippetId option
                snpPredIds      : SnippetId Set
                snpProperties   : (string* string) []
                snpModified     : System.DateTime
            }
            
            type SnippetReference =
            | RefSnippetId   of SnippetId
            | RefSnippetPath of string[]
            
            type Reduced = ((SnippetId * string * int * int) [] * string [] * FsCode.PreproDirective [] ) option
            
            type SnippetCollection = {
                generation       : System.DateTime
                ordered          : Snippet seq
                fetcher          : SnippetId -> Snippet Option
                predecesorsCache : unit -> ((SnippetId -> SnippetId list option) * (SnippetId -> (SnippetId -> SnippetId list) -> SnippetId list))
                reducedCache     : unit -> (((bool * SnippetId * Set<SnippetId>) -> Reduced option) * ((bool * SnippetId * Set<SnippetId>) -> ((bool * SnippetId * Set<SnippetId>) -> Reduced) -> Reduced))
                prepCode         : Snippet -> string                             
            }
            
            module Snippet =
                open System
                open FusionM
                open Operators
            
                let getNextModified() = DateTime.Now
                //let getNextGeneration, setGeneration = 
                //    let mutable generation  = 1
                //    (fun () -> generation <- generation + 1 ; generation)
                //  , (fun n  -> generation <- n                          )  
                let New name content parentO = 
                    {
                        snpId           = SnippetId <| System.Guid.NewGuid()   
                        snpName         = name
                        snpContent      = content
                        snpParentIdO    = parentO
                        snpPredIds      = Set.empty
                        snpProperties   = Array.empty
                        snpModified     = getNextModified()
                    }
                let defaultSnippet              = {
                    snpId           = SnippetId <| System.Guid.Empty
                    snpName         = ""
                    snpContent      = ""
                    snpParentIdO    = None
                    snpPredIds      = Set.empty
                    snpProperties   = Array.empty
                    snpModified     = Utc1970_01_01
                }    
                let snippetName name (content: string) =
                    if name <> "" then name else 
                    content.Split([| '\n' |], System.StringSplitOptions.RemoveEmptyEntries)
                    |> Seq.map    (fun l -> l.Trim())
                    |> Seq.filter (fun l -> not (l.StartsWith("#") || l.StartsWith("[<") || l.StartsWith("//")))
                    |> Seq.tryHead
                    |> Option.defaultValue "<empty>"    
                let nameSanitized snp =
                    let illegal = [|'"'   ; '<'   ; '>'   ; '|'   ; '\000'; '\001'; '\002'; '\003'; '\004'; '\005'; '\006';
                                    '\007'; '\b'  ; '\009'; '\010'; '\011'; '\012'; '\013'; '\014'; '\015';
                                    '\016'; '\017'; '\018'; '\019'; '\020'; '\021'; '\022'; '\023'; '\024';
                                    '\025'; '\026'; '\027'; '\028'; '\029'; '\030'; '\031'; ':'   ; '*'   ; '?';
                                    '\\'  ; '/'|] //"
                    snp.snpName 
                    |> String.filter (fun c -> not <| Array.contains c illegal)
                    |> fun c -> c + " " + snp.snpId.Id.ToString()
                let propertyO       n snp = snp.snpProperties |> Array.tryPick (fun (name, value) -> if name = n then Some value else None)
                let tieFighter            = "|" + "-" + "|"
                let propertyPair      prv = (prv:string).Split([| tieFighter |], StringSplitOptions.None) |> fun vs -> vs.[0], vs |> Array.tryItem 1 |> Option.defaultValue vs.[0]
                let propertyPairO   n snp = propertyO n snp |> Option.map propertyPair
                let snippetORm        sid = readerFun (fun { fetcher    = ftch } -> ftch sid                                               )
                let parentORm         snp = readerFun (fun { fetcher    = ftch } -> snp.snpParentIdO |> Option.bind ftch                   )
                let predecessorsRm    snp = readerFun (fun { fetcher    = ftch } -> snp.snpPredIds   |> Seq.choose  ftch                   )
                let maxGenerationRm   ()  = readerFun (fun { ordered    = snps } -> snps |> Seq.map (fun s -> s.snpModified  ) |> Seq.max  )
                let modifiedRm        snp = readerFun (fun { generation = gen  } -> snp.snpModified   > gen                                )
                let childrenRm        sid = readerFun (fun { ordered    = snps } -> snps |> Seq.filter(fun s -> s.snpParentIdO = Some sid) )
                let orderedRm         ()  = readerFun (fun { ordered    = snps } -> snps                                                   )
                let prepareCodeRm     snp = readerFun (fun { prepCode   = prep } -> prep snp                                               )
                let snippetRm         sid = snippetORm sid |> absorbO (fun () -> sprintf "Snippet not found %A" sid |> ErrorMsg)
                let snippetNameRm     sid = snippetRm  sid |>> (fun snp -> snippetName snp.snpName snp.snpContent)
                let rec pathRm        sid = snippetORm sid 
                                            |>> Option.map parentORm 
                                            >>= insertO 
                                            |>> Option.bind id
                                            |>> Option.map (fun prn -> pathRm prn.snpId |>> fun rest -> prn.snpId :: rest ) 
                                            >>= insertO 
                                            |>> Option.defaultValue []
                let snippetFromPathORm pth = fusion {
                    let! snps = orderedRm()
                    return
                        snps
                        |> Seq.mapFold (fun (path, prntO) snp -> 
                                           if path |> Array.length = 0                       then None    , ([||]      , prntO         ) else
                                           let name = snippetName snp.snpName snp.snpContent
                                           if  name <> path.[0] || snp.snpParentIdO <> prntO then None    , (path      , prntO         ) else
                                           if path |> Array.length > 1                       then None    , (path.[1..], Some snp.snpId) else
                                                                                                  Some snp, ([||]      , prntO         )                               
                                       ) 
                                       (pth, None)
                        |> fst
                        |> Seq.choose id
                        |> Seq.tryHead
                }
                let snippetFromRefORm     = function
                                            | RefSnippetId   sid -> snippetORm         sid
                                            | RefSnippetPath pth -> snippetFromPathORm pth
                let predsLRm (sid : SnippetId) = fusion {
                        let mutable ins  = [sid]  
                        let mutable outs = [   ]
                        while not ins.IsEmpty do
                            match ins with
                            | []         -> ()
                            | hd :: rest -> if outs |> List.contains hd then
                                                ins  <- rest
                                            else
                                                let! snpO  = snippetORm hd
                                                let  preds = snpO 
                                                             |> Option.map(fun snp -> Seq.toList snp.snpPredIds @ Option.toList snp.snpParentIdO ) 
                                                             |> Option.defaultValue []
                                                ins  <- rest @ preds
                                                outs <- hd::outs
                        return outs
                    }
                let predsLRmMemo()        = memoizeRm (fun c -> c.predecesorsCache()) predsLRm 
            //    let predsLRmMemo<'m>  : SnippetId -> ReaderMResult<SnippetId list,SnippetCollection,'m>        
            //        = ReaderM.memoizeRm (fun c -> c.predecesorsCache()) predsLRm 
            //#if FIX_GENERIC
            //    (predsLRmMemo : (SnippetId -> Monads.ReaderMonads.ReaderMResult<SnippetId list,SnippetCollection,string>) )
            //#endif    
                let uniquePredsRm     snp = predsLRmMemo() snp.snpId
                let predsGenerationRm snp = fusion {
                                                let! preds = uniquePredsRm snp >>= traverseSeq snippetRm
                                                return preds (* |> Seq.append [ snp ] *) |> Seq.map (fun snp -> snp.snpModified  ) |> Seq.max 
                                            }
                let rec modifiedRecRm snp = fusion {
                    let! modified         = modifiedRm     snp
                    if modified then return true else
                    let! predIds          = uniquePredsRm  snp
                    let! predOs           = predIds |> Seq.map snippetORm                  |> sequenceSeq
                    let! mods             = predOs  |> Seq.choose id |> Seq.map modifiedRm |> sequenceSeq
                    return Seq.contains true mods
                }
                let rec propertyHierORm n snp = fusion {
                    match propertyO n snp with
                    | Some v -> return Some (snp, propertyPair v)
                    | None   -> let! parentO = parentORm   snp
                                match parentO with
                                | Some p -> let!   propO = propertyHierORm n p
                                            return propO |> Option.map(fun (sn, (_, next)) -> sn, (next, next) )
                                | None   -> return None
                }
                let indentRm          snp =
                    let rec indentMeChildNextRm          snp = fusion {
                        let  propIndentChildren = "IndentChildren"
                        let  currO, nextO       = propertyPairO propIndentChildren snp |> function Some (curr, next) ->  ParseO.parseIntO curr, ParseO.parseIntO next | _-> None, None 
                        let! parentO            = parentORm   snp
                        match parentO with
                        | Some p -> let! _, (me, next) = indentMeChildNextRm p
                                    return me, (me + (currO |> Option.defaultValue next), nextO |> Option.defaultValue next)
                        | None   -> return 0 , (      currO |> Option.defaultValue 4    , nextO |> Option.defaultValue 4   )
                    }
                    indentMeChildNextRm snp |>> fst
                let levelRm           snp = 
                    let rec levelRm2 snp lv = fusion {
                        let!  parentO = parentORm snp
                        match parentO with
                        | None   -> return  lv
                        | Some p -> return! levelRm2 p (lv + 1)
                    }
                    levelRm2 snp 0
                let ancestorsRm   snp = 
                    let rec  ancestorsRm2 snp lst = fusion {
                        let! parentO = parentORm snp
                        match parentO with
                        | Some p -> return! ancestorsRm2 p <| p::lst
                        | None   -> return  lst
                    }
                    ancestorsRm2 snp []
                let separateCodeRm snp = fusion {
                    let! indent        = indentRm snp
                    let  indentF, prfx = if indent = 0         then (id, "") else (Array.map    (fun (l, pr) -> String.replicate indent " " + l, pr), sprintf"(%d)" indent)
                    let! code          = prepareCodeRm snp
                    //let  name          = nameSanitized snp
                    let  code, directs =
                        code.Split('\n')
                        |> FsCode.separatePrepros
                        |> indentF
                        |> FsCode.getTopDirectives
                    return
                        [| snp.snpId, snippetName snp.snpName snp.snpContent, code.Length, indent |] , code, directs
                }
                let addSeps (lines1:(SnippetId*string*int*int)[], code1:string[], directs1:FsCode.PreproDirective[])
                            (lines2:(SnippetId*string*int*int)[], code2:string[], directs2:FsCode.PreproDirective[]) =
                    Array.append lines1   lines2
                  , Array.append code1    code2
                  , Array.append directs1 directs2
                let reducedCodeRm  snippets = fusion {
                    let! parts    = snippets |> traverseSeq separateCodeRm
                    let  reduced  = parts
                                    |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||] ] else snps
                                    |> Seq.reduce addSeps
                                    |> fun (lines, code                                         , directs) ->
                                           (lines, code |> String.concat "\n" |> Array.singleton, directs)
                    return reduced
                }
                let finishCode (lines:(SnippetId*string*int*int)[],code:string[], directs:FsCode.PreproDirective[]) =
                    let assembs, defines, prepIs, nowarns, cdO = FsCode.separateDirectives directs
                    let config = defines |> Seq.sort |> Seq.map ((+)"-d:") |> String.concat " "
                    let part1  =
                      [ if config <> "" then yield "////" + config
                        if cdO.IsSome   then yield sprintf "////#cd @\"%s\"" cdO.Value
                        yield! prepIs  |> Seq.map (sprintf "#I @\"%s\""    )
                        yield! assembs |> Seq.map (sprintf "#r @\"%s\""    )
                        yield! nowarns |> Seq.map (sprintf "#nowarn \"%s\"" )
                      ]
                    Seq.append part1 code |> String.concat "\n"
                  , lines 
                    |> Seq.mapFold (fun firstLine (id, name, len, ind) -> ((id, name), (ind, firstLine, firstLine + len)), firstLine + len) part1.Length
                    |> fst
                    |> Seq.toArray
                //let codeAndStartsRm   snpIds = reader {
                //    let! snippets = orderedRm() |>> Seq.filter(fun snp -> snpIds |> Seq.contains snp.snpId)
                //    let! reduced  = reducedCodeRm snippets
                //    return finishCode reduced
                //}
                //let codeFsxRm         snippets = codeAndStartsRm snippets |> ReaderM.map fst
                let reducedOthersORm (before, snpId, snpIds) = fusion {
                    let  skipTake = if before then Seq.takeWhile else Seq.skipWhile
                    let! snippets = orderedRm() |>> skipTake (fun snp -> snp.snpId <> snpId) |>> Seq.filter(fun snp -> snp.snpId <> snpId && snpIds |> Set.contains snp.snpId) 
                    if snippets |> Seq.isEmpty then return None else
                    let! reduced = reducedCodeRm snippets
                    return Some reduced
                }
                let reducedOthersORmMemo() = memoizeRm (fun c -> c.reducedCache()) reducedOthersORm 
            //    let reducedOthersORmMemo<'m> : bool * SnippetId * Set<SnippetId> -> ReaderMResult<Reduced,SnippetCollection,'m> 
            //        = ReaderM.memoizeRm (fun c -> c.reducedCache()) reducedOthersORm 
                let fastReducedRm  curIdO lastIdO = fusion {
                    let!  curSnippetO  = curIdO  |> Option.map snippetORm |> insertO
                    let! lastSnippetO  = lastIdO |> Option.map snippetORm |> insertO
                    match (Option.bind id curSnippetO, Option.bind id lastSnippetO) with
                    | _              , None
                    | None           , _                -> return! reducedCodeRm Seq.empty
                    | Some curSnippet, Some lastSnippet ->
                    let! preds = uniquePredsRm lastSnippet
                    let  preds = Set preds
                    let! reducedBeforeO = reducedOthersORmMemo() (true , curSnippet.snpId, preds)
                    let! reducedAfterO  = reducedOthersORmMemo() (false, curSnippet.snpId, preds)
                    let! currentCode    = separateCodeRm           curSnippet
                    let part1 = reducedBeforeO |> Option.map (swap addSeps currentCode) |> Option.defaultValue currentCode
                    return      reducedAfterO  |> Option.map (     addSeps part1      ) |> Option.defaultValue part1
                }
                let fastCodeRm  curIdO lastIdO = fusion {
                    let! reduced  = fastReducedRm curIdO lastIdO
                    return finishCode reduced
                }
                let codeFsxRm    curId = fastCodeRm  (Some curId) (Some curId) |>> fst
                
        /// Essentials that cannot run in Javascript (WebSharper)
        [< AutoOpen >]
        module LibraryNoJS =
            let rec getNamespace (t:System.Type) =
                match t.DeclaringType with
                | null -> match t.Namespace with null -> "" | ns -> ns + "."
                | dt   -> getNamespace dt + dt.Name + "."
            
            let rec getTypeName (t:System.Type) =
                if t.IsArray then getTypeName (t.GetElementType()) + "[]" else
                let ns    = getNamespace t
                let name  = if   t.Name = "FSharpOption`1"                then "Option"
                            elif t.Name = "FSharpList`1"                  then "List"
                            elif ns     = "Microsoft.FSharp.Core."
                              || ns     = "Microsoft.FSharp.Collections." then t.Name   
                            else  ns + t.Name
                let name2 = name.Split('`').[0]
                let parms = t.GenericTypeArguments |> Seq.map getTypeName |> String.concat ","
                if parms = "" then name2 else sprintf "%s<%s>" name2 parms
            
            //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp.Data\lib\net45\FSharp.Data.dll"
            module Serializer =
                open Serializer
                open FSharp.Data
            
                let rec getJsonIntermediate df di ds db da (j:JsonValue) : JsonIntermediate =
                    let jsonInt = getJsonIntermediate df di ds db da
                    {
                        tryFloat    = fun () -> (match j with JsonValue.Float   v ->       v |> Some | JsonValue.Number v -> float v |> Some    |_-> None) |> Option.orElseWith df
                        tryInt      = fun () -> (match j with JsonValue.Float   v -> int64 v |> Some | JsonValue.Number v -> int64 v |> Some    |_-> None) |> Option.orElseWith di
                        tryString   = fun () -> (match j with JsonValue.String  v ->       v |> Some                                            |_-> None) |> Option.orElseWith ds
                        tryBool     = fun () -> (match j with JsonValue.Boolean v ->       v |> Some                                            |_-> None) |> Option.orElseWith db
                        tryArray    = fun () -> (match j with JsonValue.Array   v ->       v |> Array.map jsonInt |> Some                       |_-> None) |> Option.orElseWith (fun () -> da  jsonInt   )
                        tryField    = fun fl -> j.TryGetProperty fl |> Option.map jsonInt                                                                 
                        isObject    = fun () -> (match j with JsonValue.Record  _ ->       true |_-> false)
                        isNull      = fun () -> (match j with JsonValue.Null      ->       true |_-> false)
                    }
            
            
                let deserialize df di ds db da (ser: Serializer.Ser<_>) js = 
                    JsonValue.TryParse js //|>! print
                    |> Option.map  (getJsonIntermediate df di ds db da)
                    |> Option.bind (snd ser)
            
                let tryDeserialize ser = 
                    deserialize
                        (fun _   -> None)
                        (fun _   -> None)
                        (fun _   -> None)
                        (fun _   -> None)
                        (fun _   -> None)
                        ser
            
                let deserializeWithDefs ser = 
                    deserialize
                        (fun _   -> Some 0.0                          )
                        (fun _   -> Some 0L                           )
                        (fun _   -> Some ""                           )
                        (fun _   -> Some false                        )
                        (fun _   -> Some [||]                         )
                        ser
            
                let deserializeWithFail ser = 
                    deserialize
                        (fun _   -> failwith  "Error expecting float"    )
                        (fun _   -> failwith  "Error expecting int"      )
                        (fun _   -> failwith  "Error expecting string"   )
                        (fun _   -> failwith  "Error expecting bool"     )
                        (fun _   -> failwith  "Error expecting array"    )
                        ser
            
                open FSharp.Reflection
            
                let inline serObj ((ser, deser):Ser<'T>) : string * Ser<obj> = typeof<'T> |> getTypeName, (unbox >> ser, deser >> Option.map box)
            
                let serDU<'DU when 'DU : equality> (sers : (string * Ser<obj>) seq) =
                    let cases  = FSharpType.GetUnionCases             typeof<'DU>
                    let dCases =
                        cases
                        |> Array.map (fun case ->
                            if case.GetFields().Length = 0 then
                                let serC         _ = sprintf "{%A:1}" case.Name
                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some 
                                case.Tag, (serC, deserC)
                            else
                                let sers2 =
                                    case.GetFields() |> Array.map(fun fld ->
                                        let tn = fld.PropertyType  |> getTypeName
                                        sers 
                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)
                                        |> Option.defaultWith (fun () -> 
                                            sers |> Seq.map fst |> String.concat ", "
                                            |> failwithf "serDU: Could not find Ser<%s> for %s. Provided: %s" tn (typeof<'DU> |> getTypeName) 
                                        )
                                    ) 
                                let getValues      = box<'DU> >> FSharpValue.PreComputeUnionReader case 
                                let setValues      = FSharpValue.PreComputeUnionConstructor case >> unbox<'DU>
                                let serC (v:'DU) =
                                    Seq.zip (getValues v) sers2
                                    |> Seq.map (fun (vi, seri) -> fst seri vi )
                                    |> String.concat ", "
                                    |> sprintf "{%A:[%s]}" case.Name
                                let deserC (j:JsonIntermediate) = 
                                    match j with 
                                    | Field case.Name j2 ->
                                        match j2.tryArray () with
                                        | None -> None
                                        | Some js -> 
                                        Array.zip js sers2
                                        |> Array.choose (fun (ji, seri) -> snd seri ji)
                                        |> setValues
                                        |> Some
                                    |_-> None 
                                case.Tag, (serC, deserC)
                        ) |> dict
                    let readTag   = box<'DU> >> FSharpValue.PreComputeUnionTagReader typeof<'DU> >> fun i -> dCases.[i]
                    let serDU   v = (readTag v |> fst) v
                    let deserDU j =
                        let case =  cases |> Seq.tryPick(fun case -> match j with Field case.Name _ -> Some case |_-> None) |> Option.defaultWith (fun () -> failwithf "Could not find DU element %A" j)
                        snd dCases.[case.Tag] j
                    serDU, deserDU
            
                let serDUt (sers : (string * Ser<obj>) seq) (ttype:System.Type) =
                    let cases  = FSharpType.GetUnionCases ttype
                    let dCases =
                        cases
                        |> Array.map (fun case ->
                            if case.GetFields().Length = 0 then
                                let serC         _ = sprintf "{%A:1}" case.Name
                                let deserC       _ = FSharpValue.MakeUnion(case, [||]) :?> 'DU |> Some 
                                case.Tag, (serC, deserC)
                            else
                                let sers2 =
                                    case.GetFields() |> Array.map(fun fld ->
                                        let tn = fld.PropertyType |> getTypeName
                                        sers 
                                        |> Seq.tryPick(fun (nm, ser) -> if nm = tn then Some ser else None)
                                        |> Option.defaultWith (fun () -> 
                                            sers |> Seq.map fst |> String.concat ", "
                                            |> failwithf "serDU: Could not find Ser<%s> for %s. Provided: %s" tn (ttype |> getTypeName) 
                                        )
                                    ) 
                                let getValues      = FSharpValue.PreComputeUnionReader case 
                                let setValues      = FSharpValue.PreComputeUnionConstructor case
                                let serC v =
                                    Seq.zip (getValues v) sers2
                                    |> Seq.map (fun (vi, seri) -> fst seri vi )
                                    |> String.concat ", "
                                    |> sprintf "{%A:[%s]}" case.Name
                                let deserC (j:JsonIntermediate) = 
                                    match j with 
                                    | Field case.Name j2 ->
                                        match j2.tryArray () with
                                        | None -> None
                                        | Some js -> 
                                        Array.zip js sers2
                                        |> Array.choose (fun (ji, seri) -> snd seri ji)
                                        |> setValues
                                        |> Some
                                    |_-> None 
                                case.Tag, (serC, deserC)
                        ) |> dict
                    let readTag   = FSharpValue.PreComputeUnionTagReader ttype >> fun i -> dCases.[i]
                    let serDU   v = (readTag v |> fst) v
                    let deserDU j =
                        let case =  cases |> Seq.pick(fun case -> match j with Field case.Name _ -> Some case |_-> None)
                        snd dCases.[case.Tag] j
                    serDU, deserDU
                    
            module Default =
                open FSharp.Reflection
            
                let defaults vs = vs |> Seq.map (fun v -> v.GetType().FullName, v ) |> dict
            
                let defs = 
                    defaults [
                        box 0
                        box 0L
                        box 0.
                        box 0.F
                        box ""
                        box false
                        box System.Guid.Empty
                        box System.DateTime.MinValue
                    ]
            
                let rec defaultValue defs (t:System.Type) : obj =
                    match (defs:System.Collections.Generic.IDictionary<string, obj>).TryGetValue t.FullName with
                    | true , v -> v
                    | false, _ ->
                    if t.IsArray then 
                        System.Array.CreateInstance(t.GetElementType(), 0) |> box
                    elif t.IsEnum then
                        (System.Enum.GetValues t).GetValue [| 0 |] |> box
                    else
                    let c = t.GetConstructor System.Type.EmptyTypes
                    if  isNull c |> not then
                        c.Invoke [||]
                    elif FSharpType.IsRecord t then
                        FSharpType.GetRecordFields t
                        |> Array.map (fun fld -> fld.PropertyType )
                        |> createArray (defaultValue defs)
                        |> fun os -> FSharpValue.MakeRecord(t, os)
                    elif FSharpType.IsTuple t then
                        FSharpType.GetTupleElements t
                        |> createArray (defaultValue defs)
                        |> fun os -> FSharpValue.MakeTuple(os, t)
                    elif FSharpType.IsUnion t then
                        let case = FSharpType.GetUnionCases t |> Seq.head
                        case.GetFields()
                        |> Array.map (fun fld -> fld.PropertyType )
                        |> createArray (defaultValue defs)
                        |> fun os -> FSharpValue.MakeUnion(case, os)
                    else failwithf "Could no create default for %s" t.FullName
            
                and createArray defs (ts : System.Type []) = ts |> Array.map defs
            
                let inline value<'T> : 'T = typeof<'T> |> defaultValue defs |> unbox
            
            
        /// Essentials that run in Javascript (WebSharper)
        //#define WEBSHARPER 
        [< JavaScript ; AutoOpen >]
        module LibraryJS =
            module Date =
                let toYYYYMMDD     sep (date:System.DateTime) = sprintf "%d%s%02d%s%02d" date.Year sep  date.Month sep date.Day
                let toHHMM             (date:System.DateTime) = sprintf "%02d:%02d" date.Hour  date.Minute
                let toYYYYMMDDHHMM sep (date:System.DateTime) = sprintf "%s %s" (toYYYYMMDD sep date) (toHHMM date)
                
        /// Essentials that part runs in Javascript and part runs in the server
        [< AutoOpen >]
        module Library2 =
            [<WebSharper.JavaScript>]
            module WebSockets =
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Microsoft.Owin\lib\net451\Microsoft.Owin.dll"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\Owin.WebSocket.dll"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\WebSharper.Owin.WebSocket.dll"
                //#define WEBSHARPER
                open WebSharper
                
                let MessageBrokerId  = "<MessageBroker>"
                
                type Address = Address of address:string
                with member this.txt = match this with Address txt -> txt
                
                let MessageBrokerAddress = Address MessageBrokerId
                
                /// Requests made to Message Broker
                [< NamedUnionCases "type" >]
                type BrokerRequest = 
                    | BRGetConnections  /// request for list of connections
                    | BRGetProcessId    /// request PID of broker process
                
                /// Replies from Message Broker
                [< NamedUnionCases "type" >]
                type BrokerReply = 
                    | BRConnections  of string[]
                    | BRPid          of int
                    | BRString       of string
                  //  | BRPleaseClose  
                
                [< NamedUnionCases "type" >]
                type MessageType = 
                    | MsgInformation             // does not expect a reply, payload may or may not be structured
                    | MsgRequest                 // expects a reply, structured payload
                    | MsgReply                   // structured payload.
                    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this
                    | MsgRequestForId            // expects reply as Information with id
                    | MsgRequestForEcho          // expects reply as Information with same payload
                
                /// Replies from Message Broker
                [< NamedUnionCases "type" >]
                type BrokerMessage = 
                    | BMOk
                    | BMOnlyBrokerShouldUse
                    | BMDestinationNotFound of Address  
                    | BMWebSocketError      of string
                    | BMReceiverCantReply
                    | BMUnexpectedMsgType   of MessageType
                    | BMUnexpectedResponse  of string
                
                [< NamedUnionCases "type" >]
                type Replier = 
                    | NoReply
                    | Broker
                    | Receiver
                
                [< NamedUnionCases "type" >]
                type MessageGeneric = {
                    from          : Address
                    destination   : Address
                    msgType       : MessageType
                    subtype       : string      // free short string that provides information to deserialize payload
                    id            : System.Guid
                    payload       : string
                    replier       : Replier
                }
                
                [< Inline >]
                let inline processPayload f (payload:string) : string =
                    if payload = "" then Unchecked.defaultof<_> else Json.Deserialize payload
                    |> f
                    |> Json.Serialize
                            
                [<  Inline >]
                let newMsgSerialized dst payload = {
                    from          = Address ""
                    destination   = dst
                    msgType       = MsgRequest
                    subtype       = ""
                    id            = System.Guid.NewGuid()
                    payload       = payload
                    replier       = NoReply
                }
                
                [< Inline >]
                let inline payload        pl  msg = { msg with payload       = Json.Serialize pl }
                let inline from           frm msg = { msg with from          = frm               }
                let inline destination    dst msg = { msg with destination   = dst               }
                let inline msgType        typ msg = { msg with msgType       = typ               }
                let inline subtype        sub msg = { msg with subtype       = sub               }
                let inline replier        rpl msg = { msg with replier       = rpl               }
                let inline msgId          id  msg = { msg with id            = id                }
                
                [<  Inline >]
                let inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst
                
                [<  Inline >]
                let inline msgPayload msg = Json.Deserialize msg.payload
                
                let mapPayload f msg = { msg with payload = f msg.payload }
                
                let inline makeReply msg =
                    msg
                    |> msgType MsgReply
                    |> replier NoReply
                
                [<  Inline >]
                let inline respond pyld msg =
                    msg
                    |> makeReply
                    |> payload  pyld
                
                type IServer =
                    abstract member Post  : MessageGeneric -> unit
                    abstract member Close : unit           -> unit
                
                type CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>
                
                
                open System
                open System.Threading
                open System.Net.WebSockets
                
                [< JavaScript false >]
                module Client =
                    let startStateFull receive initAndfolder =
                        async {
                            let! initState, folder = initAndfolder
                            let agentBox = Mailbox.foldA (fun ex st -> print ex; st) folder initState
                            let finish a = agentBox.Post CMessage.Close ; printfn "%A" a
                            let error  a = agentBox.Post CMessage.Error ; finish a
                            Async.StartWithContinuations(receive agentBox, finish, error, error)
                        }
                
                    type WebSocketServer<'S2C, 'C2S>(uri:string) =
                        let conn = new ClientWebSocket()
                        let chunkSize = 8192
                        let send (txt:string)  =
                            async {
                                let buffer = System.Text.Encoding.UTF8.GetBytes txt
                                let chunks = buffer.Length / chunkSize
                                for i = 0 to chunks do
                                    let last = i = chunks
                                    let size = if last then buffer.Length % chunkSize else chunkSize
                                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask
                            }
                        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =
                            let buffer : byte[] = Array.create chunkSize 0uy
                            let builder         = System.Text.StringBuilder()
                            let keepgo          = ref true
                            async {
                                receiverBox.Post CMessage.Open
                                while conn.State = WebSocketState.Open && !keepgo do
                                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask
                                    match result.MessageType with
                                    | WebSocketMessageType.Close -> keepgo := false
                                    | WebSocketMessageType.Text ->
                                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]
                                        builder.Append txt |> ignore
                                        if result.EndOfMessage then
                                            let txt = builder.ToString()
                                            builder.Clear() |> ignore
                                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post
                                    | _ -> ()
                                return "WebSocketServer receive Closed."
                            }
                        let brokerBox = Mailbox.iterA print (Json.Serialize >> send)
                        let connect initAndfolder =
                            async {
                                printfn "Connecting %s" uri
                                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask
                                printfn "Connected %A" WebSocketState.Open
                                do! startStateFull receive initAndfolder
                            }
                        member this.WebSocket        = conn
                        member this.Post (msg: 'C2S) = brokerBox.Post msg
                        member this.Connect          = connect
                
                    let ConnectStateful<'S2C, 'C2S> uri getInitAndfolder =
                        async {
                            let  server          = WebSocketServer uri
                            do!  server.Connect (getInitAndfolder server)
                            return server
                        }
                
                    let ConnectStatefulFS uri clientId (f:IServer -> _) =
                        let uri2 = sprintf "ws://%s?ClientId=%s" uri clientId
                        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =
                            f { new IServer with
                                  member this.Post  v = serverP.Post v
                                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) 
                                                        |> Async.AwaitTask |> Async.RunSynchronously            
                               }
                        ConnectStateful uri2 func
                        |> Async.map ignore
                        
                //#I @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Owin\lib\net40"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Owin\lib\net40\Owin.dll"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Microsoft.Owin\lib\net451\Microsoft.Owin.dll"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\Owin.WebSocket.dll"
                //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\WebSharper.Owin.WebSocket\lib\net461\WebSharper.Owin.WebSocket.dll"
                
                open System
                open WebSharper.Owin.WebSocket
                open WebSharper.Owin.WebSocket.Client
                
                //#define FSS_SERVER
                //#define WEBSHARPER
                
                type  Server = WebSocketServer<MessageGeneric,MessageGeneric>
                
                type ClientTypeFSharp    = FSharp
                #if WEBSHARPER
                type ClientTypeFSStation = FSStation
                type ClientTypeJScript   = JScript
                
                [< Inline >]
                let ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =
                    let uri2 = sprintf "ws://%s?ClientId=%s" uri clientId
                    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =
                        f { new IServer with
                              member this.Post  v = serverP.Post v
                              member this.Close() = serverP.Connection.Close 1000 // Normal Closure
                           }
                    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)
                    ConnectStateful endPoint func
                    |> Async.map ignore
                #endif
                
                module ReplyHandler =
                    type WaitForReplyMsg =
                        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))
                        | Reply  of Guid *   MessageGeneric
                        | Excpn  of Guid *   exn
                        | Cancel of Guid *   OperationCanceledException
                        
                    type Handler (defProc) =
                        let waitingAgent =    
                            Mailbox.fold Mailbox.defHandler (fun waitingForReply action ->
                                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def
                                                      Map.remove  key     waitingForReply
                                match action with
                                | Add   (key, fns) -> Map.add     key fns waitingForReply
                                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)
                                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore
                                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore
                            ) Map.empty
                        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post
                        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post
                        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post
                        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post
                
                [< Inline "window.location.href" >]
                let getEndPoint() = 
                #if FSS_SERVER
                    "No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp"
                #else
                    "http://localhost:9005/#/Snippet/a2c4b946-c09e-4dd6-b93f-d4762f5eb25f"
                #endif
                
                let extractEndPoint() = 
                    let ep : string = getEndPoint()
                    let ep2 = ep.Substring(ep.IndexOf "//" + 2)
                    ep2.Split('/').[0]
                
                type WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>
                        , clientId:string, ?timeout:int, ?endPoint:string) =    
                    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + "/ws")
                    let clientAddress = Address clientId
                    let wsTimeout     = defaultArg timeout 60000
                
                    let mutable out = printfn "%s"
                    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around 
                    let mutable serverO : IServer option = None
                    let mutable payloadProcessorO : (string -> Async<string>) option = None
                    let waiting = ReplyHandler.Handler (fun msg -> printfn "Reply from '%s': %s" msg.from.txt msg.payload)
                
                    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)
                    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )
                
                    let processReply      msg = waiting.Reply msg.id msg
                    let mapPayloadWrap (fW: _ -> Async<_> ) msg =
                        async {
                            let! r  = fW msg.payload
                            return msg |> mapPayload (fun _ -> r)
                        }
                    let processMessage msg =
                        //printfn "%A" msg
                        match msg.msgType with
                        | MsgFromBroker     
                        | MsgReply           -> processReply msg
                        | MsgInformation     -> printfn "Information from '%s': %s" msg.from.txt (msgPayload msg)
                        | MsgRequest         -> match payloadProcessorO with 
                                                | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it
                                                | Some processor ->
                                                msg |> mapPayloadWrap processor |> Async.iterA (makeReply >> reply) 
                        | MsgRequestForEcho  -> msg |> mapPayload     id        |> msgType MsgInformation |> reply
                        | MsgRequestForId    -> msg |> respond        clientId  |> msgType MsgInformation |> reply
                    
                    let connectToWebSocketServer() =
                        printfn "in connectToWebSocketServer"
                        async {
                            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {
                                return 0, fun state wsmsg -> async {
                                    try match wsmsg with
                                        | CMessage.Message msg -> processMessage msg
                                        | CMessage.Open        -> printfn "WebSocket %s connection open."   clientId ; serverO <- Some server
                                        | CMessage.Close       -> printfn "WebSocket %s connection closed." clientId ; close()
                                        | CMessage.Error       -> printfn "WebSocket %s connection error!"  clientId
                                    with e -> printfn "msg: %A \nexn:%A" wsmsg e 
                                    return state
                                }
                            }
                            printfn "connectToWebSocketServer with server"
                            
                        }
                
                    let checkServer = Mailbox.callA print ( fun () -> async {
                        printfn "getServer"
                        if serverO.IsNone then
                            printfn "getServer Connecting"
                            do! connectToWebSocketServer()
                            do! Async.Sleep 200
                        return serverO |> Result.ofOption (fun () -> ErrorMsg "could not connect to Server")
                    })        
                
                    let getServer() : AsyncResult<IServer, _> = checkServer.PostAndAsyncReply(fun reply -> reply, ())
                        
                    let postR (server: IServer) rpl msg = 
                        let m = msg |> from clientAddress |> replier rpl 
                        try       server.Post m
                        with e -> serverO <- None
                                  raise e
                
                    let sendAndForget msg = asyncResult {
                        let! server = getServer()
                        msg |> postR server NoReply
                    }
                        
                    let sendAndReply rpl msg = asyncResult {
                        let! server  = getServer()
                        let  replyA  = Async.FromContinuations(fun fns -> 
                            waiting.Add msg.id fns
                            msg |> postR server rpl
                            if wsTimeout > 0 then
                                async {
                                    do! Async.Sleep wsTimeout
                                    waiting.Raise msg.id (TimeoutException(sprintf "Did not receive reply in %d seconds for Message: %A" (wsTimeout / 1000) msg) :> exn)
                                } |> Async.Start
                        )
                        return! replyA
                    }
                        
                    let sendAndVerify msg = asyncResult {
                        let! reply   = sendAndReply Broker msg 
                        do!  match reply.msgType with
                             | MsgFromBroker  -> let  bm = msgPayload reply
                                                 if   bm = BMOk 
                                                 then Result.Ok    () 
                                                 else Result.Error <| ResultMessage.Message bm
                             | _              ->      Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)
                    }
                    
                    let sendGetReply msg =
                        asyncResult {
                            let! reply   = sendAndReply Receiver msg 
                            let! result =
                                match reply.msgType with
                                | MsgReply      -> Result.Ok     reply.payload
                                | MsgFromBroker -> let bm = msgPayload reply
                                                   Result.Error <| ResultMessage.Message bm
                                | _             -> Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)
                            return result
                        }
                
                    let getListeners() =
                        asyncResult {
                            let  msg    = newMsg MessageBrokerAddress BRGetConnections
                            let! reply  = sendGetReply msg
                            match Json.Deserialize<BrokerReply> reply with
                            | BRConnections listeners -> return listeners
                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf "%A" r)
                        } 
                        
                    let getProcessId() =
                        asyncResult {
                            let  msg    = newMsg MessageBrokerAddress BRGetProcessId
                            let! reply  = sendGetReply msg
                            match Json.Deserialize<BrokerReply> reply with
                            | BRPid pid -> return pid
                            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf "%A" r)
                        } 
                        
                    let sendMsg msg =
                        asyncResult {
                            if msg.replier = NoReply
                            then do!     sendAndForget msg
                                 return  ""
                            else return! sendGetReply  msg
                        }
                    member this.MBListeners            = getListeners()
                    member this.MBProcessId            = getProcessId()
                    member this.EndPoint               = wsEndPoint
                    member this.ClientId               = clientId
                    member this.SendMsg           msg  = sendMsg msg
                    [<  Inline >]
                    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget
                    [<  Inline >]
                    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify
                    [<  Inline >]
                    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> AsyncResult.map Json.Deserialize
                    member this.Out with set fout      = out <- fout
                    [<  Inline >]
                    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Async.map Json.Serialize))
                                                         newMsg MessageBrokerAddress "Registering Processor" 
                                                         |> msgType MsgInformation
                                                         |> sendAndForget |> AsyncResult.iterA (string >> failwith) id
                    interface IDisposable with
                        member this.Dispose() = close()
                
                #if FSS_SERVER   
                    [< JavaScript false >]
                    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)
                #endif
                    [< JavaScript false >]
                    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)
                #if WEBSHARPER
                    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)
                #endif
                
                
            [< JavaScript >]
            type FSMessage =
            | MsgGetId
            | MsgGetSnippets     of SnippetReference[]
            | MsgGetCode         of SnippetReference
            | MsgGetPredecessors of SnippetReference
            | MsgAction          of string[]
            | MsgGetUrl
            | MsgGetValue        of string
            | MsgSetValue        of string * string
            | MsgGetModified     of SnippetReference
            
            [< JavaScript >]
            type FSResponse =
            | RespString         of string
            | RespSnippets       of Snippet[]
            | RespDateTime       of System.DateTime
            
            module FSharpStationClient =
                open WebSockets
            
                let mutable fsharpStationAddress = Address "FSharpStation1564764915205"
            
                let [< Rpc >] setAddress address = async { 
                    fsharpStationAddress <- address 
                    printfn "set %A" fsharpStationAddress
                }
            
                let fsharpStationClient, sendMessage : WSMessagingClient * (FSMessage -> AsyncResult<FSResponse, _>) = 
                    let client =
            #if WEBSHARPER 
                        if IsClient then 
                            new WSMessagingClient("FSharpStationClientJS"       )
                        else
            #endif            
            #if FSS_SERVER            
                            new WSMessagingClient("FSharpStationClientFSStation", FSStation)
            #else
                            new WSMessagingClient("FSharpStationClientFSharp"   , FSharp)
            #endif
                    client, fun m -> client.SendGetReply fsharpStationAddress m |> AsyncResult.absorbR
            
                let respString response = asyncResult { 
                    match response with
                    | RespString code -> return code
                    | _               -> return! Error <| ErrorMsg (sprintf "Unexpected %A" response)
                }
            
                let respDateTime response = asyncResult { 
                    match response with
                    | RespDateTime time -> return time
                    | _                 -> return! Error <| ErrorMsg (sprintf "Unexpected %A" response)
                }
            
                let respSnippet response = asyncResult { 
                    match response with
                    | RespSnippets [| snp |] -> return snp
                    | _                      -> return! Error <| ErrorMsg (sprintf "Unexpected %A" response)
                }
            
                let getCode path = 
                    path
                    |> String.splitByChar '/'
                    |> RefSnippetPath
                    |> MsgGetCode
                    |> sendMessage
                    |> AsyncResult.bind respString
            
                let getModified path = 
                    path
                    |> String.splitByChar '/'
                    |> RefSnippetPath
                    |> MsgGetModified
                    |> sendMessage
                    |> AsyncResult.bind respDateTime
            
                let getSnippet path = 
                    path
                    |> String.splitByChar '/'
                    |> RefSnippetPath
                    |> Array.singleton
                    |> MsgGetSnippets
                    |> sendMessage
                    |> AsyncResult.bind respSnippet
            
                let getUrl      () = MsgGetUrl            |> sendMessage |> AsyncResult.bind respString
                let getValue vrw   = MsgGetValue vrw      |> sendMessage |> AsyncResult.bind respString
                let setValue var v = MsgSetValue (var, v) |> sendMessage |> AsyncResult.bind respString
            
                let execJS      js          = sendMessage (MsgAction [| "ExecJS"      ; js              |]) |> AsyncResult.bind respString
                let setProperty path prop v = sendMessage (MsgAction [| "SetProperty" ; path ; prop ; v |]) |> AsyncResult.bind respString
                let sendOutput  txt         = sendMessage (MsgAction [| "AddOutput"   ; txt             |])
                let actionCall0 act         = sendMessage (MsgAction [|  act                            |])
                let actionCall1 act p1      = sendMessage (MsgAction [|  act          ; p1              |])
                let actionCall2 act p1 p2   = sendMessage (MsgAction [|  act          ; p1   ; p2       |])
                                        
                let getBrokerProcessId() = fsharpStationClient.MBProcessId
    
    //#cd @"D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer"
    module ProzperServer =
    
        [< AutoOpen ; JavaScript >]
        module Basico =
            type IdAliado     = IdAliado     of string          with member this.Id = match this with IdAliado    id -> id
            type IdAuthorize  = IdAuthorize  of string          with member this.Id = match this with IdAuthorize id -> id
            type IdAddress    = IdAddress    of string          with member this.Id = match this with IdAddress   id -> id
            type IdPayment    = IdPayment    of string          with member this.Id = match this with IdPayment   id -> id
        
            type VariableAmbienteI   = 
                    abstract getVar  : string -> string
                    abstract member CarpetaRaiz          : unit     -> string
        
            let variableAmbienteE v  = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.getVar     v 
            let carpetaRaiz       () = Reader.ask() |>> fun (h:#VariableAmbienteI) -> h.CarpetaRaiz()
        
        
        [< AutoOpen ; JavaScript >]
        module TypesV0 =
            type LatestType = TypeV0
        
            type IdAliado       = IdAliado       of string          with member this.Id = match this with IdAliado       id -> id
            type IdAuthorize    = IdAuthorize    of string          with member this.Id = match this with IdAuthorize    id -> id
            type IdAddress      = IdAddress      of string          with member this.Id = match this with IdAddress      id -> id
            type IdPayment      = IdPayment      of string          with member this.Id = match this with IdPayment      id -> id
            type IdSubscription = IdSubscription of string          with member this.Id = match this with IdSubscription id -> id
        
            type StatusAliado =
            | CuentaCreada
            | Activo
            | Inactivo
            | Cancelado
                with
                    override this.ToString() = sprintf "%A" this
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | "CUENTACREADA"             -> CuentaCreada
                        | "ACTIVO"                   -> Activo
                        | "CANCELADO"                -> Cancelado
                        | _                          -> Inactivo
        
            type TipoAliado =
            | Master
            | Regular
                with
                    override this.ToString() = sprintf "%A" this
        
            type Pais =
            | USA
            | Venezuela 
            | Argentina
            | OtroP of string
                with 
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | ""               -> None    
                        | "EEUU" | "UNITED STATES"  | "UNITED STATES OF AMERICA" | "US" | "E.E.U.U." | "AMERICA"
                        | "USA"            -> Some <| USA
                        | "VENEZUELA"      -> Some <| Venezuela
                        | "ARGENTINA"      -> Some <| Argentina
                        | _                -> Some <| (OtroP <| s.Trim() )
                    override this.ToString() = match this with OtroP s -> s | v -> sprintf "%A" v
        
            type Estado =
            | Texas
            | Florida
            | OtroS of string
                with 
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | ""               -> None    
                        | "TX"
                        | "TEXAS"          -> Some <| Texas
                        | "FL"
                        | "FLORIDA"        -> Some <| Florida
                        | _                -> Some <| (OtroS <| s.Trim() )
                    override this.ToString() = match this with OtroS s -> s | v -> sprintf "%A" v
        
            type Territorio =
            | Estado of Estado
        
            type Emisor =
            | Pais       of Pais
            | Territorio of Territorio
        
            type Documento =
            | Pasaporte        of string
            | Cedula           of string
            | LicenciaConducir of string
        
            type Identificacion = {
                emisor    : Emisor
                documento : Documento
                emision   : System.DateTime
                vence     : System.DateTime
            }
        
            type TipoArchivo =
            | Contrato
            | Autorizacion
            | Pasaporte
            | Cedula
            | LicenciaConducir
            | FormaW9
            | FormaW8BEN
            | Otro            of string
                with 
                    static member Parse (s:string) = 
                        match s with
                        | String.StartsWith "Otro " r -> Otro r
                        | "Contrato"                  -> Contrato
                        | "FormaW9"                   -> FormaW9
                        | "FormaW8BEN"                -> FormaW8BEN
                        | "Autorizacion"              -> Autorizacion
                        | "Pasaporte"                 -> Pasaporte
                        | "Cedula"                    -> Cedula
                        | "LicenciaConducir"          -> LicenciaConducir
                        | _                           -> Otro <| s.Trim()
                    override this.ToString() = match this with Otro s -> s | v -> sprintf "%A" v
        
            type StatusArchivo =
            | Subido
            | Verificado
            | Rechazado 
            | Expirado  
            | Cancelado  
            | Cambiado
                with 
                    static member Parse (s:string) = 
                        match s with
                        | "Cambiado"   -> Cambiado
                        | "Expirado"   -> Expirado 
                        | "Cancelado"  -> Cancelado
                        | "Verificado" -> Verificado 
                        | "Rechazado"  -> Rechazado  
                        | _            -> Subido
                    override this.ToString() = sprintf "%A" this
        
            type Archivo = {
                idAliado    : IdAliado
                tipo        : TipoArchivo
                nombre      : string
                modificado  : System.DateTime
                tamano      : int64
                status      : StatusArchivo
                comentario  : string
            }
        
            type Mes =
            | Enero      =  1
            | Febrero    =  2
            | Marzo      =  3
            | Abril      =  4
            | Mayo       =  5
            | Junio      =  6
            | Julio      =  7
            | Agosto     =  8
            | Septiembre =  9
            | Octubre    = 10
            | Noviembre  = 11
            | Diciembre  = 12
        
            type Expiracion = {
                anio : int
                mes  : Mes
            } with
                member this.Id = sprintf "%04d-%02d" this.anio (int this.mes)
                static member TryParse (txt:string) =
                    let create century (anio:string) (mes:string) =
                        {
                            anio = century   + int anio
                            mes  = enum<Mes>  (int mes )
                        } |> Some
                    if txt.Length = 4 || txt.Length = 5 then 
                        create 2000 (txt.Right 2) (txt.Left  2)
                    elif txt.Length = 7 then
                        txt.Split[| '-' ; '/' |]
                        |> function 
                            | [| py ; pm |] when py.Length = 4 -> create 0 py pm
                            | [| pm ; py |] when py.Length = 4 -> create 0 py pm
                            |_-> None
                    else None
        
        
            type NumeroCuenta   = NumeroCuenta  of string       with member this.Id = match this with NumeroCuenta  id -> id
            type NumeroTarjeta  = NumeroTarjeta of string       with member this.Id = match this with NumeroTarjeta id -> id
            type RoutingNumber  = RoutingNumber of string       with member this.Id = match this with RoutingNumber id -> id 
        
            type TipoTarjeta     = 
            | Visa
            | MasterCard
            | Amex
            | Otra of string
                with 
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | ""                 -> None    
                        | "VISA"             -> Some <| Visa
                        | "MASTERCARD"       -> Some <| MasterCard
                        | "AMEX"
                        | "AMERICAN EXPRESS" -> Some <| Amex
                        | _                  -> Some <| (Otra <| s.Trim() )
                    override this.ToString() = match this with Otra s -> s | v -> sprintf "%A" v
        
            type TipoCuenta     = 
            | Ahorro
            | Corriente
            | Otra of string
                with 
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | ""               -> None    
                        | "SAVINGS"
                        | "AHORRO"         -> Some <| Ahorro
                        | "CHECKING"
                        | "CORRIENTE"      -> Some <| Corriente
                        | _                -> Some <| (Otra <| s.Trim() )
                    override this.ToString() = match this with Otra s -> s | v -> sprintf "%A" v
        
            type CuentaBancaria = {
                titular     : string
                banco       : string
                tipo        : TipoCuenta
                numero      : NumeroCuenta
                routing     : RoutingNumber
            }
        
            type TarjetaCredito = {
                titular     : string
                tipoTarjeta : TipoTarjeta
                numero      : NumeroTarjeta
                expiracion  : Expiracion
            }
        
            type ConceptoPago =
            | PagoAfiliacion
            | PagoComision
            | Otro of string
                with
                    static member tryParse (s:string) = 
                        match s.Trim().ToUpper() with
                        | ""               -> None    
                        | "PAGOAFILIACION" -> Some <| PagoAfiliacion
                        | "PAGOCOMISION"   -> Some <| PagoComision
                        | _                -> Some <| (ConceptoPago.Otro <| s.Trim() )
                    override this.ToString() = match this with Otro s -> s | v -> sprintf "%A" v
        
            type Transaccion = {
                fechaPago      : System.DateTime
                ano            : int
                periodo        : int
                monto          : int
                idAliado       : IdAliado
                concepto       : ConceptoPago
                transaccion    : string
                statusTran     : string
            }
        
            type TipoDireccion = 
            | Habitacion
            | Oficina
            | ServicioPostal
            | Otro of string
                with 
                    static member tryParse (s:string) = 
                        match s.Trim() with
                        | ""               -> None    
                        | "Habitacion"     -> Some <| Habitacion
                        | "Oficina"        -> Some <| Oficina
                        | "ServicioPostal" -> Some <| ServicioPostal
                        | s                -> Some <| Otro s
                    override this.ToString() = match this with Otro s -> s | v -> sprintf "%A" v
        
            type ZonaPostal = ZonaPostal of string
                with 
                    static member tryParse (s:string) = if s.Trim() <> "" then Some (ZonaPostal <| s.Trim()) else None
                    override this.ToString() = match this with ZonaPostal s -> s
        
            type Direccion = {
                authorizeIdR  : Result<IdAddress, string>
                tipoDireccion : TipoDireccion
                linea1        : string
                linea2        : string
                ciudad        : string
                estado        : Estado
                pais          : Pais
                zonaPostal    : ZonaPostal
            }
        
            type TipoTelefono =
            | Movil
            | Oficina
            | Habitacion
            | Voip
                with 
                    static member tryParse = function
                        | "Movil"      -> Some Movil
                        | "Oficina"    -> Some Oficina
                        | "Habitacion" -> Some Habitacion
                        | _            -> None    
                    override this.ToString() = sprintf "%A" this
        
            type Telefono          = {
                tipoTelefono : TipoTelefono
                codigoPais   : string
                codigoArea   : string
                numero       : string
                extension    : string
                mensajes     : bool
            }
        
            type CorreoElectronico = {
                email       : string
                enviado     : System.DateTime option
                recibido    : System.DateTime option
            }
                with override this.ToString() = this.email
        
            type Contacto =
            | Direccion         of Direccion
            | CorreoElectronico of CorreoElectronico
            | Telefono          of Telefono
            | Mensajeria        of string
            | PaginaWeb         of string
            | SocialMedia       of string
        
            type Genero =
            | Masculino
            | Femenino
            | Empresa
                with 
                    static member tryParse (s:string) = 
                        match s.Trim() with
                        | "Masculino"      -> Some <| Masculino
                        | "Femenino"       -> Some <| Femenino
                        | "Empresa"        -> Some <| Empresa
                        | _                -> None    
        
            type DatosPersonales = {
                titulo          : string option
                nombre1         : string
                nombre2         : string
                apellido1       : string
                apellido2       : string
                nacionalidad    : Pais
                genero          : Genero
                fechaNacimiento : System.DateTime
            }
        
            type CuentaPago =
            | CuentaBancaria            of CuentaBancaria
            | TarjetaCredito            of TarjetaCredito
            | TransferenciaElectronica  of string
                with
                    member this.MaskedCuenta =
                        match this with
                        | TarjetaCredito           tc -> tc.numero.Id
                        | CuentaBancaria           cb -> cb.numero.Id
                        | TransferenciaElectronica te -> te
                    member this.TipoCorto =
                        match this with
                        | TarjetaCredito           tc -> "TC"
                        | CuentaBancaria           bc -> "CB"
                        | TransferenciaElectronica te -> "TE"
                    member this.TipoLargo =
                        match this with
                        | TarjetaCredito           tc -> "Tarjeta de Credito"
                        | CuentaBancaria           bc -> "Cuenta Bancaria"
                        | TransferenciaElectronica te -> "Transferencia Electronica"
                    member this.AutorizacionPre = sprintf "Autorizacion %s %s" this.TipoCorto this.MaskedCuenta
        
            type StatusFormaPago =
            | NuevaFormaPago
            | Registrada      of          System.DateTime option
            | RegistroFallido of string * System.DateTime option
        
            type Subscripcion = {
                idSubscripcion  : IdSubscription
                inicio          : System.DateTime
                monto           : int
                descripcion     : string
                status          : int
            } with 
                member this.Short = sprintf "%s %s $%d.00 %s %d" this.idSubscripcion.Id (Date.toYYYYMMDD "-" this.inicio) this.monto this.descripcion this.status
        
            type FormaPago = {
                nombre          : string
                authorizeIdR    : Result<IdPayment, string>
                cuentaPago      : CuentaPago
                subscripcion    : Subscripcion option
            }
        
            type TipoMensaje = 
            | Alerta
            | Informacion
            | Saludo
        
            type Remitente =
            | Prozper
            | Aliado of IdAliado
            | OtroR  of string
        
            type Mensaje = {
                tipo      : TipoMensaje
                leido     : System.DateTime option
                fecha     : System.DateTime
                texto     : string
                remitente : Remitente
            }
        
            type PremisasCalculo = {
                comisionReferidosRegular     : int
                comisionReferidosMaster      : int
                comisionDescendientesMaster  : int
                comisionDescendientesRegular : int
                montoAfiliacion              : int
                numeroReferidosMaster        : int
                diaCorte1                    : int
                diaCorte2                    : int
            }
        
            let premisasCalculo = {
                comisionReferidosRegular     = 15
                comisionReferidosMaster      = 25
                comisionDescendientesMaster  = 25
                comisionDescendientesRegular =  0
                montoAfiliacion              = 75
                numeroReferidosMaster        = 31
                diaCorte1                    = 26
                diaCorte2                    = 28
            }
        
            let telVacio = {            
                tipoTelefono = Movil
                codigoPais   = ""
                codigoArea   = ""
                numero       = ""
                extension    = ""
                mensajes     = false
            }
        
            let dirVacio = {
                authorizeIdR  = Error ""
                tipoDireccion = TipoDireccion.Habitacion
                linea1        = ""
                linea2        = ""
                ciudad        = ""
                estado        = OtroS ""
                pais          = OtroP ""
                zonaPostal    = ZonaPostal ""
            }
        
            let tarVacio = {            
                tipoTarjeta  = Visa
                numero       = NumeroTarjeta ""
                expiracion   = { anio = 2000 ; mes = Mes.Enero }
                titular      = ""
            }
        
            let ctaVacio = {            
                banco        = ""
                numero       = NumeroCuenta ""
                tipo         = Ahorro
                titular      = ""
                routing      = RoutingNumber ""
            }
        
            type DiaPago =
            |   Dia01
            |   Dia05
            |   Dia10
            |   Dia15
            |   Dia20
            |   Dia25
        
            type IdForAuthorize = IdForAuthorize of string  with member this.Id = match this with IdForAuthorize id -> id
        
            type Aliado = {
                id              :      IdAliado
                idPadreO        :      IdAliado       option
                idForAuthorize  :      IdForAuthorize option
                influyente      :      string         option
                datosPersonales :      DatosPersonales
                contactos       :      Contacto       []
                identificacion  :      Identificacion []
                isInternal      :      bool
                status          :      StatusAliado
                diaPago         :      DiaPago
                tipo            :      TipoAliado
                fechaRegistro   :      System.DateTime
                fechaStatus     :      System.DateTime
                nReferidos      :      int
                nRefActivos     :      int
                nDescendientes  :      int
                nDescActivos    :      int
                comision        :      int
                nivel           :      int
                documentos      :      int
                docPendientes   :      int
            }
        
            type Modelo = {
                idAliado      : IdAliado
                aliados       : Aliado []
                anoActual     : int
                periodoActual : int
                premisas      : PremisasCalculo
                nevento       : int64
            }
        
            let modeloVacio = {
                idAliado      = IdAliado ""
                aliados       = [||]
                anoActual     = System.DateTime.Now.Year
                periodoActual = System.DateTime.Now.Month
                premisas      = premisasCalculo
                nevento       = 0L
            }
        
            let correoVacio = {
                email       = ""
                enviado     = None
                recibido    = None
            }
        
        [< JavaScript >]
        module Aliado =
            open Operators
        
            //let statusActual ano mes al  =
            //    al.transacciones.Value
            //    |> Array.tryFind (fun t -> t.idAliado = al.id 
            //                            && t.ano      = ano
            //                            && t.periodo  = mes
            //                            && t.concepto = PagoAfiliacion)
            //    |> Option.map    (fun _ ->  Activo )
            //    |> Option.defaultValue    Inactivo
        
            open System.Collections.Generic
        
            let premisas pre al =
                let comRef, comDes = match al.tipo  with
                                     | Regular -> pre.comisionReferidosRegular, pre.comisionDescendientesRegular
                                     | Master  -> pre.comisionReferidosMaster , pre.comisionDescendientesMaster
                match al.status with
                | Activo -> comRef, comDes
                | _      -> 0     , 0
        
            let comision pre al = 
                let comRef, comDes = premisas pre al
                al.nRefActivos * comRef, al.nDescActivos * comDes
        
            type Buscar = {
                hijosDe        : (IdAliado -> IdAliado [])
                nivelDe        : (IdAliado option -> int)
                aliado         : (IdAliado -> Aliado)
                aliadoO        : (IdAliado -> Aliado option)
                hijos          : (Aliado -> Aliado [])
                descendientes  : (Aliado -> Aliado [])
            }
        
            let busqueda aliados =
                let padres               = aliados 
                                           |> Seq.map(fun al -> al.idPadreO, al.id) 
                                           |> Seq.groupBy fst 
                                           |> Seq.map(fun (pO, ch) -> pO, ch |> Seq.map snd |> Seq.toArray) |> Map
                let aliadosMap           = aliados |> Seq.map (fun al -> al.id, al) |> Map
                let aliadoO          id  = match aliadosMap.TryGetValue id with
                                           | true, al -> Some al
                                           | _        -> None
                let aliado           id  = try aliadosMap.[id] with e -> failwithf "buscarAliado failed: %A" id
                let hijosDe          idO = match padres.TryGetValue (Some idO) with
                                           | true, hijos -> hijos
                                           | _           -> [||]
                let rec nivelDe      idO = idO |> Option.bind aliadoO |> Option.map (fun al -> 1 + nivelDe al.idPadreO) |> Option.defaultValue 0
                let hijos             al = hijosDe al.id |> Array.choose aliadoO
                let rec descendientes al =
                    [|
                        for h in hijos al do
                            yield                h
                            yield! descendientes h
                    |]
                {
                    hijosDe       = hijosDe       
                    nivelDe       = nivelDe       
                    aliado        = aliado        
                    aliadoO       = aliadoO       
                    hijos         = hijos         
                    descendientes = descendientes 
                }
        
            let diaPago (registro:System.DateTime) =
                let  diaMes = registro.Day
                if   diaMes  =  1 then Dia01
                elif diaMes <=  5 then Dia05
                elif diaMes <= 10 then Dia10
                elif diaMes <= 15 then Dia15
                elif diaMes <= 20 then Dia20
                elif diaMes <= 25 then Dia25
                else                   Dia01
        
            let dia = function
            | Dia01 ->  1
            | Dia05 ->  5
            | Dia10 -> 10
            | Dia15 -> 15
            | Dia20 -> 20
            | Dia25 -> 25
        
            let actualizarAliados (transAll:Transaccion []) modelo =
                let buscar             = busqueda modelo.aliados
                let pre                = modelo.premisas
                let trans              = transAll |> Array.filter (fun tr -> tr.fechaPago > System.DateTime.Today.AddMonths -1 )
                let statusActual    al = 
                    match al.status with
                    | Activo
                    | Inactivo -> if trans
                                     |> Seq.exists(fun tr -> tr.idAliado = al.id && tr.monto >= pre.montoAfiliacion ) 
                                    then Activo else Inactivo
                    | st       -> st
                let rec aliadoActualizado alid =
                    let al             = buscar.aliado alid
                    let hijos          = buscar.hijosDe al.id |> Seq.map aliadoActualizadoM |> Seq.cache
                    let status         = statusActual al
                    let nReferidos     = hijos |> Seq.length
                    let nRefActivos    = hijos |> Seq.filter (fun al -> al.status = Activo && al.tipo = Regular) |> Seq.length
                    let nDescendientes = hijos |> Seq.sumBy  (fun al -> al.nDescendientes + al.nReferidos )
                    let nDescActivos   = hijos |> Seq.sumBy  (fun al -> al.nDescActivos   + al.nRefActivos)
                    let tipo           = if nRefActivos >= pre.numeroReferidosMaster then Master else Regular
                    let nivel          = 1 + buscar.nivelDe al.idPadreO
                    let al0 =
                        { al with
                            status         = status
                            tipo           = tipo
                            nReferidos     = nReferidos    
                            nRefActivos    = nRefActivos   
                            nDescendientes = nDescendientes
                            nDescActivos   = nDescActivos  
                            diaPago        = diaPago al.fechaRegistro
                            //fechaStatus    = System.DateTime()
                            nivel          = nivel
                        }
                    let comRef, comDes = comision pre al0
                    let al1 = { al0 with comision = comRef + comDes}
                    {al1 with status = if al1.status = Inactivo && al1.comision >= pre.montoAfiliacion then Activo else al1.status }
        
                and aliadoActualizadoM = Memoize.memoize aliadoActualizado
        
                modelo.aliados 
                |> Seq.map (fun al -> al.id)
                |> Seq.map aliadoActualizadoM
                |> Seq.toArray
        
            //let actualizarModelEf () = eff {
            //    let! modelo     = State.get()
            //    do! State.put { modelo with aliados = actualizarAliados modelo }
            //    ()
            //}
        
            let empty = {
                datosPersonales = {
                                        titulo          = None
                                        nombre1         = ""
                                        nombre2         = ""
                                        apellido1       = ""
                                        apellido2       = ""
                                        nacionalidad    = USA
                                        genero          = Masculino
                                        fechaNacimiento = System.DateTime(2000, 1, 1)
                                    }
                id              =  IdAliado ""
                idPadreO        =  None
                idForAuthorize  =  None
                influyente      =  None
                contactos       =  [||]
                identificacion  =  [||]
                isInternal      =  false
                status          =  Inactivo
                tipo            =  Regular
                fechaRegistro   =  System.DateTime(2000, 1, 1)
                fechaStatus     =  System.DateTime(2000, 1, 1)
                diaPago         =  Dia01
                nReferidos      =  0
                nRefActivos     =  0
                nDescendientes  =  0
                nDescActivos    =  0
                comision        =  0
                nivel           =  0
                documentos      =  0
                docPendientes   =  0
            }
        
            let nombre dp = 
                let titulo   = dp.titulo |> Option.map ((+) " ") |> Option.defaultValue ""
                let apellido = if dp.apellido1 = "" then "" else (dp.apellido1 + " " + dp.apellido2).Trim() + ", "
                titulo + apellido + dp.nombre1 + " " + dp.nombre2
        
            let nombre2 dp = 
                let titulo   = dp.titulo |> Option.map ((+) " ") |> Option.defaultValue ""
                titulo + (dp.nombre1 + " " + dp.nombre2).Trim() + " " + (dp.apellido1 + " " + dp.apellido2).Trim()
        
            let correo al  =
                al.contactos |> Seq.choose(function | CorreoElectronico correo -> Some correo.email |_-> None ) |> Seq.tryHead |> Option.defaultValue ""
                
        module Serializador =
            open Serializer
            open System
        
            [< AutoOpen >]
            module TypesV0 =
                open TypesV0
            
                let serDate : Ser<System.DateTime> = 
                    (  fun (d:System.DateTime ) -> d.ToString("u") |> sprintf "%A"                )
                    , (fun (j:JsonIntermediate) -> j.tryString() |> Option.bind ParseO.parseDateO )
        
                let serIdAliado          = serDU<IdAliado         > [   serObj serString            ]    
                let serIdAuthorized      = serDU<IdAuthorize      > [   serObj serString            ]    
                let serIdForAuthorize    = serDU<IdForAuthorize   > [   serObj serString            ]    
                let serIdPayment         = serDU<IdPayment        > [   serObj serString            ]    
                let serIdAddress         = serDU<IdAddress        > [   serObj serString            ]    
                let serTipoAliado        = serDU<TipoAliado       > [   serObj serString            ]
                let serPais              = serDU<Pais             > [   serObj serString            ]    
                let serEstado            = serDU<Estado           > [   serObj serString            ]    
                let serTerritorio        = serDU<Territorio       > [   serObj serEstado            ]   
                let serEmisor            = serDU<Emisor           > [   serObj serPais
                                                                        serObj serTerritorio        ]
                let serDocumento         = serDU<Documento        > [   serObj serString            ]    
                let serNumeroCuenta      = serDU<NumeroCuenta     > [   serObj serString            ]    
                let serNumeroTarjeta     = serDU<NumeroTarjeta    > [   serObj serString            ]
                let serRoutingNumber     = serDU<RoutingNumber    > [   serObj serString            ]    
                let serTipoCuenta        = serDU<TipoCuenta       > [   serObj serString            ]    
                let serStatusAliado      = serDU<StatusAliado     > [   serObj serString            ]    
                let serConceptoPago      = serDU<ConceptoPago     > [   serObj serString            ]    
                let serTipoDireccion     = serDU<TipoDireccion    > [   serObj serString            ]    
                let serZonaPostal        = serDU<ZonaPostal       > [   serObj serString            ]    
                let serTipoTelefono      = serDU<TipoTelefono     > [   serObj serString            ]    
                let serGenero            = serDU<Genero           > [   serObj serString            ]    
                let serTipoMensaje       = serDU<TipoMensaje      > [   serObj serString            ]
                let serDiaPago           = serDU<DiaPago          > [                               ]
                let serTipoArchivo       = serDU<TipoArchivo      > [   serObj serString            ]    
                let serStatusArchivo     = serDU<StatusArchivo    > [   serObj serString            ]    
        
                let serMes : Ser<Mes>    = (int >> fst serInt), (snd serInt >> Option.map enum<_> )
        
                let serIdAuthorizedR     = serDU<Result<IdAuthorize, string>> [   serObj serString ; serObj serIdAuthorized ]    
                let serIdPaymentR        = serDU<Result<IdPayment  , string>> [   serObj serString ; serObj serIdPayment    ]    
                let serIdAddressR        = serDU<Result<IdAddress  , string>> [   serObj serString ; serObj serIdAddress    ]    
        
                let serExpiracion: Ser<Expiracion> =
                    [|
                        serInt        |> serField "anio"    (fun s -> s.anio   ) (fun v s -> { s with anio    = v } )   
                        serMes        |> serField "mes"     (fun s -> s.mes    ) (fun v s -> { s with mes     = v } )          
                    |] |> serRecord tarVacio.expiracion
        
        
                let serIdentificacion : Ser<Identificacion> = 
                    [|
                        serEmisor    |> serField "emisor"    (fun s -> s.emisor    ) (fun v s -> { s with emisor    = v } )
                        serDocumento |> serField "documento" (fun s -> s.documento ) (fun v s -> { s with documento = v } )
                        serDate      |> serField "emision"   (fun s -> s.emision   ) (fun v s -> { s with emision   = v } )
                        serDate      |> serField "vence"     (fun s -> s.vence     ) (fun v s -> { s with vence     = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serCuentaBancaria : Ser<CuentaBancaria> =
                    [|
                        serString        |> serField "titular" (fun (s:CuentaBancaria) -> s.titular) (fun v s -> { s with titular = v } )   
                        serString        |> serField "banco"   (fun  s                 -> s.banco  ) (fun v s -> { s with banco   = v } )   
                        serTipoCuenta    |> serField "tipo"    (fun  s                 -> s.tipo   ) (fun v s -> { s with tipo    = v } )        
                        serNumeroCuenta  |> serField "numero"  (fun  s                 -> s.numero ) (fun v s -> { s with numero  = v } )          
                        serRoutingNumber |> serField "routing" (fun  s                 -> s.routing) (fun v s -> { s with routing = v } )           
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serTarjetaCredito : Ser<TarjetaCredito> =
                    [|
                        serExpiracion    |> serField "expiracion" (fun s -> s.expiracion) (fun v s -> { s with expiracion = v } )   
                        serString        |> serField "titular"    (fun s -> s.titular   ) (fun v s -> { s with titular    = v } )   
                        serNumeroTarjeta |> serField "numero"     (fun s -> s.numero    ) (fun v s -> { s with numero     = v } )          
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serTransaccion : Ser<Transaccion> = 
                    [|
                        serDate          |> serField "fechaPago"   (fun s -> s.fechaPago  ) (fun v s -> { s with fechaPago   = v } ) 
                        serInt           |> serField "ano"         (fun s -> s.ano        ) (fun v s -> { s with ano         = v } )
                        serInt           |> serField "periodo"     (fun s -> s.periodo    ) (fun v s -> { s with periodo     = v } )
                        serInt           |> serField "monto"       (fun s -> s.monto      ) (fun v s -> { s with monto       = v } )
                        serIdAliado      |> serField "idAliado"    (fun s -> s.idAliado   ) (fun v s -> { s with idAliado    = v } )     
                        serConceptoPago  |> serField "concepto"    (fun s -> s.concepto   ) (fun v s -> { s with concepto    = v } )         
                        serString        |> serField "transaccion" (fun s -> s.transaccion) (fun v s -> { s with transaccion = v } )   
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serDireccion : Ser<Direccion> = 
                    [|
                        serTipoDireccion |> serField "tipoDireccion" (fun s -> s.tipoDireccion) (fun v s -> { s with tipoDireccion = v } )
                        serString        |> serField "linea1"        (fun s -> s.linea1       ) (fun v s -> { s with linea1        = v } )
                        serString        |> serField "linea2"        (fun s -> s.linea2       ) (fun v s -> { s with linea2        = v } )
                        serString        |> serField "ciudad"        (fun s -> s.ciudad       ) (fun v s -> { s with ciudad        = v } )
                        serPais          |> serField "pais"          (fun s -> s.pais         ) (fun v s -> { s with pais          = v } )
                        serZonaPostal    |> serField "zonaPostal"    (fun s -> s.zonaPostal   ) (fun v s -> { s with zonaPostal    = v } )
                        serEstado        |> serField "estado"        (fun s -> s.estado       ) (fun v s -> { s with estado        = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serTelefono : Ser<Telefono> =
                    [|
                        serTipoTelefono |> serField "tipoTelefono" (fun s -> s.tipoTelefono) (fun v s -> { s with tipoTelefono = v } )
                        serString       |> serField "codigoPais"   (fun s -> s.codigoPais  ) (fun v s -> { s with codigoPais   = v } )
                        serString       |> serField "codigoArea"   (fun s -> s.codigoArea  ) (fun v s -> { s with codigoArea   = v } )
                        serString       |> serField "numero"       (fun s -> s.numero      ) (fun v s -> { s with numero       = v } )
                        serString       |> serField "extension"    (fun s -> s.extension   ) (fun v s -> { s with extension    = v } )
                        serBool         |> serField "mensajes"     (fun s -> s.mensajes    ) (fun v s -> { s with mensajes     = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serCuentaPago        = serDU<CuentaPago       > [   serObj serString              
                                                                        serObj serTarjetaCredito
                                                                        serObj serCuentaBancaria    ]
                let serRemitente         = serDU<Remitente        > [   serObj serIdAliado
                                                                        serObj serString            ]
        
                let serFormaPago : Ser<FormaPago> =
                    [|
                        serCuentaPago            |> serField "cuentaPago"  (fun s -> s.cuentaPago   ) (fun v s -> { s with cuentaPago   = v } )
                        serString                |> serField "nombre"      (fun s -> s.nombre       ) (fun v s -> { s with nombre       = v } )
                        serIdPaymentR            |> serField "authorizeId" (fun s -> s.authorizeIdR ) (fun v s -> { s with authorizeIdR = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serDatosPersonales : Ser<DatosPersonales> =
                    [|
                        serString        |> serOpt  |> serField "titulo"          (fun s -> s.titulo         ) (fun v s -> { s with titulo          = v } )
                        serString                   |> serField "nombre1"         (fun s -> s.nombre1        ) (fun v s -> { s with nombre1         = v } )
                        serString                   |> serField "nombre2"         (fun s -> s.nombre2        ) (fun v s -> { s with nombre2         = v } )
                        serString                   |> serField "apellido1"       (fun s -> s.apellido1      ) (fun v s -> { s with apellido1       = v } )
                        serString                   |> serField "apellido2"       (fun s -> s.apellido2      ) (fun v s -> { s with apellido2       = v } )
                        serPais                     |> serField "nacionalidad"    (fun s -> s.nacionalidad   ) (fun v s -> { s with nacionalidad    = v } )
                        serGenero                   |> serField "genero"          (fun s -> s.genero         ) (fun v s -> { s with genero          = v } )
                        serDate                     |> serField "fechaNacimiento" (fun s -> s.fechaNacimiento) (fun v s -> { s with fechaNacimiento = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serMensaje : Ser<Mensaje> =
                    [|
                        serTipoMensaje           |> serField "tipo"      (fun (s:Mensaje) -> s.tipo     ) (fun v s -> { s with tipo      = v } )
                        serDate        |> serOpt |> serField "leido"     (fun (s:Mensaje) -> s.leido    ) (fun v s -> { s with leido     = v } )
                        serDate                  |> serField "fecha"     (fun (s:Mensaje) -> s.fecha    ) (fun v s -> { s with fecha     = v } )
                        serString                |> serField "texto"     (fun (s:Mensaje) -> s.texto    ) (fun v s -> { s with texto     = v } )
                        serRemitente             |> serField "remitente" (fun (s:Mensaje) -> s.remitente) (fun v s -> { s with remitente = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serPremisasCalculo : Ser<PremisasCalculo> =
                    [|
                        serInt  |> serField "comisionReferidosRegular"     (fun s -> s.comisionReferidosRegular    ) (fun v s -> { s with comisionReferidosRegular     = v } )
                        serInt  |> serField "comisionReferidosMaster"      (fun s -> s.comisionReferidosMaster     ) (fun v s -> { s with comisionReferidosMaster      = v } )
                        serInt  |> serField "comisionDescendientesMaster"  (fun s -> s.comisionDescendientesMaster ) (fun v s -> { s with comisionDescendientesMaster  = v } )
                        serInt  |> serField "comisionDescendientesRegular" (fun s -> s.comisionDescendientesRegular) (fun v s -> { s with comisionDescendientesRegular = v } )
                        serInt  |> serField "montoAfiliacion"              (fun s -> s.montoAfiliacion             ) (fun v s -> { s with montoAfiliacion              = v } )
                        serInt  |> serField "numeroReferidosMaster"        (fun s -> s.numeroReferidosMaster       ) (fun v s -> { s with numeroReferidosMaster        = v } )
                        serInt  |> serField "diaCorte1"                    (fun s -> s.diaCorte1                   ) (fun v s -> { s with diaCorte1                    = v } )
                        serInt  |> serField "diaCorte2"                    (fun s -> s.diaCorte2                   ) (fun v s -> { s with diaCorte2                    = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serCorreoElectronico : Ser<CorreoElectronico> = 
                    [|
                        serString         |> serField "email"    (fun s -> s.email    ) (fun v s -> { s with email    = v } )
                        serDate |> serOpt |> serField "enviado"  (fun s -> s.enviado  ) (fun v s -> { s with enviado  = v } )
                        serDate |> serOpt |> serField "recibido" (fun s -> s.recibido ) (fun v s -> { s with recibido = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serContacto          = serDU<Contacto         > [   serObj serString     
                                                                        serObj serTelefono
                                                                        serObj serCorreoElectronico
                                                                        serObj serDireccion         ] 
        
                let serArchivo : Ser<Archivo> = 
                    [|
                        serString                      |> serField "nombre"          (fun (s:Archivo)-> s.nombre) (fun v s -> { s with nombre          = v } )
                        serIdAliado                    |> serField "id"              (fun s -> s.idAliado       ) (fun v s -> { s with idAliado        = v } )
                        serDate                        |> serField "modificado"      (fun s -> s.modificado     ) (fun v s -> { s with modificado      = v } )
                        serString                      |> serField "comentario"      (fun s -> s.comentario     ) (fun v s -> { s with comentario      = v } )
                        serStatusArchivo               |> serField "status"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )
                        serTipoArchivo                 |> serField "tipo"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )
                        serInt64                       |> serField "tamano"          (fun s -> s.tamano         ) (fun v s -> { s with tamano          = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serAliado : Ser<Aliado> =
                    [|
                        serIdAliado                    |> serField "id"              (fun s -> s.id             ) (fun v s -> { s with id              = v } )
                        serIdForAuthorize   |> serOpt  |> serField "idForAuthorize"  (fun s -> s.idForAuthorize ) (fun v s -> { s with idForAuthorize  = v } )
                        serIdAliado         |> serOpt  |> serField "idPadreO"        (fun s -> s.idPadreO       ) (fun v s -> { s with idPadreO        = v } )
                        serIdentificacion   |> serArr  |> serField "identificacion"  (fun s -> s.identificacion ) (fun v s -> { s with identificacion  = v } )
                        serString           |> serOpt  |> serField "influyente"      (fun s -> s.influyente     ) (fun v s -> { s with influyente      = v } )
                        serDatosPersonales             |> serField "datosPersonales" (fun s -> s.datosPersonales) (fun v s -> { s with datosPersonales = v } )
                        serContacto         |> serArr  |> serField "contactos"       (fun s -> s.contactos      ) (fun v s -> { s with contactos       = v } )
                        //serFormaPago        |> serArr  |> serField "formasPago"      (fun s -> s.formasPago     ) (fun v s -> { s with formasPago      = v } )
                        //serTransaccion      |> serArr  |> serField "transacciones"   (fun s -> s.transacciones  ) (fun v s -> { s with transacciones   = v } )
                        //serMensaje          |> serArr  |> serField "mensajes"        (fun s -> s.mensajes       ) (fun v s -> { s with mensajes        = v } )
                        serBool                        |> serField "isInternal"      (fun s -> s.isInternal     ) (fun v s -> { s with isInternal      = v } )
                        serStatusAliado                |> serField "status"          (fun s -> s.status         ) (fun v s -> { s with status          = v } )
                        serTipoAliado                  |> serField "tipo"            (fun s -> s.tipo           ) (fun v s -> { s with tipo            = v } )
                        serDate                        |> serField "fechaRegistro"   (fun s -> s.fechaRegistro  ) (fun v s -> { s with fechaRegistro   = v } )
                        serDate                        |> serField "fechaStatus"     (fun s -> s.fechaStatus    ) (fun v s -> { s with fechaStatus     = v } )
                        serDiaPago                     |> serField "diaPago"         (fun s -> s.diaPago        ) (fun v s -> { s with diaPago         = v } )
                        serInt                         |> serField "nReferidos"      (fun s -> s.nReferidos     ) (fun v s -> { s with nReferidos      = v } )
                        serInt                         |> serField "nRefActivos"     (fun s -> s.nRefActivos    ) (fun v s -> { s with nRefActivos     = v } )
                        serInt                         |> serField "nDescendientes"  (fun s -> s.nDescendientes ) (fun v s -> { s with nDescendientes  = v } )
                        serInt                         |> serField "nDescActivos"    (fun s -> s.nDescActivos   ) (fun v s -> { s with nDescActivos    = v } )
                        serInt                         |> serField "comision"        (fun s -> s.comision       ) (fun v s -> { s with comision        = v } )
                        serInt                         |> serField "nivel"           (fun s -> s.nivel          ) (fun v s -> { s with nivel           = v } )
                        serInt                         |> serField "documentos"      (fun s -> s.documentos     ) (fun v s -> { s with documentos      = v } )
                        serInt                         |> serField "docPendientes"   (fun s -> s.docPendientes  ) (fun v s -> { s with docPendientes   = v } )                
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
                let serModelo : Ser<Modelo> = 
                    [|
                        serInt64                      |> serField "nevento"       (fun s -> s.nevento       ) (fun v s -> { s with nevento       = v } )
                        serIdAliado                   |> serField "idAliado"      (fun s -> s.idAliado      ) (fun v s -> { s with idAliado      = v } )
                        //serAliado           |> serArr |> serField "aliados"       (fun s -> s.aliados       ) (fun v s -> { s with aliados       = v } )
                        serInt                        |> serField "anoActual"     (fun s -> s.anoActual     ) (fun v s -> { s with anoActual     = v } )
                        serInt                        |> serField "periodoActual" (fun s -> s.periodoActual ) (fun v s -> { s with periodoActual = v } )
                        serPremisasCalculo            |> serField "premisas"      (fun s -> s.premisas      ) (fun v s -> { s with premisas      = v } )
                    |] |> serRecord LibraryNoJS.Default.value<_>
        
        
        module ObtenerEstado =
            open Serializador
        
            type EstadoI<'H> =
                    abstract member UltimoEstado        : unit          -> Eff<'H, int64 option>
        //            abstract member LeerEventos          : int64    ->  Eff<'H, (int64 * string * string * string * string * System.DateTime) []>
        //            abstract member LeerTipos            : unit     ->  string           []
        //            abstract member LeerEventosTipos     : unit     -> (string * string) []
                    abstract member GuardarEstado       : int64         -> string ->  Eff<'H, unit>
                    abstract member GuardarAliado       : string        -> string ->  Eff<'H, unit>
                    abstract member ObtenerEstado       : unit          -> Eff<'H, (int64 * string) option>
                    abstract member ObtenerAliados      : unit          -> Eff<'H, string     [] >
                    abstract member LeerTransacciones   : unit          -> Eff<'H, Transaccion[] >
                    abstract member SalvarTransacciones : Transaccion[] -> Eff<'H, unit          >
        
            let guardarEstadoE   (nevento, serialModelo) = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarEstado nevento serialModelo
            let obtenerEstado0E  ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerEstado    ()                  
            let obtenerAliadosE  ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.ObtenerAliados   ()                  
            let guardarAliadoE   id json                 = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.GuardarAliado    id json             
            let ultimoEstadoE    ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.UltimoEstado     ()
            let leerTransaccsE   ()                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.LeerTransacciones()
            let salvarTransaccsE ts                      = Reader.ask() >>= fun (h:#EstadoI<_>) -> h.SalvarTransacciones ts
        
            let aliadosPrevio = System.Collections.Generic.Dictionary<_,_>()
        
            let guardarAliados aliados = eff {
                let mutable first = true
                for (aliado:Aliado) in aliados do
                    let previoO = Dict.tryGetValue aliado.id aliadosPrevio
                    if previoO <> Some aliado then
                        if first then 
                            first <- false
                            printfn "previo = %A" previoO 
                            printfn "nuevo  = %A" aliado
                        do! aliado |> Serializer.serialize serAliado |> guardarAliadoE aliado.id.Id
                    if previoO.IsSome then aliadosPrevio.Remove aliado.id |> ignore
                    aliadosPrevio.Add(aliado.id, aliado)
                    ()
            }
        
            let actualizarAliadosPrevio aliados = eff {
                aliadosPrevio.Clear()
                for aliado in aliados do
                    aliadosPrevio.Add(aliado.id, aliado)
            }
        
            let guardarEstado nevento modelo = 
                eff {
                    let! trans = leerTransaccsE()
                    return!
                        { modelo with nevento = nevento ; aliados = Aliado.actualizarAliados trans modelo } 
                        |> EA.tee (fun e -> guardarAliados e.aliados)
                        |>> fun (modelo:Modelo) -> nevento, modelo |> Serializer.serialize serModelo
                        >>= guardarEstadoE
                }
        
            let private obtenerAliados () = eff {
                let! aliadoss = obtenerAliadosE()
                let  aliados  = aliadoss |> Array.choose (Serializer.deserializeWithDefs serAliado)
                do! actualizarAliadosPrevio aliados
                return aliados
            }
        
            let obtenerEstado00E() = eff {
                let! estadoPO = obtenerEstado0E()
                let! estadoSinAliados = 
                    estadoPO 
                    |> Option.map snd                                       
                    |> Option.map (Serializer.deserializeWithDefs serModelo)
                    |> Option.defaultValue  (Some modeloVacio)              
                    |> Result.ofOption  (fun () -> "Modelo no fue deserializado")
                    |> Rsl.ofResult
                let! aliados = obtenerAliados()
                //let! trans = leerTransaccsE()
                let  estado = { estadoSinAliados with aliados = aliados }
                //return { estado with aliados = Aliado.actualizarAliados trans estado } 
                return estado
            }
        
            let mutable private estadoActual : Modelo option = None
        
            let resetEstadoActual() = estadoActual <- None
        
            let obtenerEstado() = eff{
                let! estado = ultimoEstadoE()
                match estado, estadoActual with
                | Some n, Some e when n = e.nevento -> return e
                |_-> return! obtenerEstado00E() |>>! (fun e -> estadoActual <- Some e)
            }
        
            //let obtenerUsuario (aid: (_*_) []) : string =  aid 
                //|>  Seq.tryFind(fun (n,v) -> n = "http://schemas.microsoft.com/identity/aid/objectidentifier") 
                //|>  Option.map snd
                //|>  Option.defaultWith (fun () -> failwith "Usuario no autenticado")
        
            let obtenerAliadoEstado (aid:IdAliado) =
                obtenerEstado()
                |>> fun modelo -> 
                        modelo.aliados 
                        |> Array.tryFind (fun al -> al.id = aid ) 
                        |> Option.map (fun v -> v, modelo) 
                |> Rsl.absorbO (fun () -> "Aliado no fue encontrado")
        
            //let obtenerAliadoEstado    aid       = obtenerUsuario       aid |>  obtenerAliadoEstado0
            let obtenerAliado          aid       = obtenerAliadoEstado  aid |>> fst
            //let obtenerAliadoEstadoId (IdAliado id) = obtenerAliadoEstado id
            //let pairAliadoEstado       aid   ev  = obtenerAliadoEstado  aid |>> fun s -> s, ev
            //let pairAliado             aid   ev  = obtenerAliado        aid |>> fun a -> a, ev
        
            let obtenerSubModelo esAdmin (aliado:Aliado, modelo:Modelo) = 
                let buscar = Aliado.busqueda modelo.aliados
                if esAdmin then modelo else
                let subAliados = (if aliado.tipo = Master then buscar.descendientes else buscar.hijos) aliado
                { modelo with 
                    idAliado = aliado.id
                    aliados  = Array.append [| aliado |] subAliados 
                }
        
            let obtenerEstadoParaUsuario aid esAdmin =
                obtenerAliadoEstado aid
                |>> obtenerSubModelo esAdmin
        
        
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\other\AuthorizeNet\lib\AuthorizeNet.dll"
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Newtonsoft.Json\lib\netstandard2.0\Newtonsoft.Json.dll"
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp.Data\lib\net45\FSharp.Data.dll"
        
        module Authorize =
            open System
            open AuthorizeNet
            open AuthorizeNet.Api.Controllers
            open AuthorizeNet.Api.Contracts.V1
            open AuthorizeNet.Api.Controllers.Bases
        
            type AuthorizeI<'H>     = abstract execute : IApiOperation<'A, 'B> -> 'B
                                      abstract prepare : unit                  -> Eff<'H, unit>
        
            let authorizeMerchantId (aliado:Aliado) =
                match aliado.idForAuthorize with
                | Some v ->        v .Id                .Left(20)
                | None   -> aliado.id.Id.Replace("-","").Left(20)
        
            let executeE (controller: IApiOperation<_,_> ) = Reader.ask() |>> fun (h:#AuthorizeI<_>) -> h.execute controller
            let prepareE (                               ) = Reader.ask() >>= fun (h:#AuthorizeI<_>) -> h.prepare ()
            let inline executeGetResponse controller : Eff<_, 'b> = eff {
                let! response = executeE controller
                if response = null then 
                    return! Rsl.failf "%s Failed, Response = null" ( controller.GetType().Name )
                elif response.messages.resultCode = messageTypeEnum.Ok then
                    return response
                elif response.messages.message <> null then
                    return! Rsl.failf "%s Error: %s %s"  ( controller.GetType().Name ) response.messages.message.[0].code response.messages.message.[0].text
                else
                    return! Rsl.failf "%s Error: resultCode = %A, no messages" ( controller.GetType().Name ) response.messages.resultCode
            }
        
            let ( |*> ) request controllerF =
                prepareE()
                |>> fun () -> controllerF request
                >>= executeGetResponse 
        
            let ( >*= ) requestEf controllerF = 
                requestEf 
                >>= fun request -> request |*> controllerF
        
            let buscarPerfil aliado =
                getCustomerProfileRequest( merchantCustomerId  = authorizeMerchantId aliado ) 
                |*> getCustomerProfileController
                |>> fun response -> response.profile, match response.subscriptionIds with null -> [||] | v -> v
                
        
            let buscarIdAuthorize aliado =
                buscarPerfil aliado
                |>> fun (p,_) -> IdAuthorize p.customerProfileId
        
            let registrarAliadoNuevo (aliado:Aliado, paymentProfile : customerPaymentProfileType) =
                let email = aliado.contactos 
                            |> Seq.choose(function CorreoElectronico cor -> Some cor.email |_-> None) 
                            |> Seq.tryHead |> Option.defaultValue ""
                let customerProfile = 
                    customerProfileType(        merchantCustomerId  = authorizeMerchantId aliado
                                            ,   email               = email 
                                            ,   paymentProfiles     = [| paymentProfile |] )
                createCustomerProfileRequest(   profile             = customerProfile
                                            ,   validationMode      = validationModeEnum.liveMode )
                |*> createCustomerProfileController 
                |>> fun response -> response.customerPaymentProfileIdList.[0]
        
            let registrarPagoNuevo (IdAuthorize id, pp : customerPaymentProfileType) =
                createCustomerPaymentProfileRequest(customerProfileId = id
                                                ,   paymentProfile    = pp
                                                ,   validationMode    = validationModeEnum.liveMode)
                |*> createCustomerPaymentProfileController
                |>> fun response -> response.customerPaymentProfileId
        
            let pagoTipoTarjeta (tar:TarjetaCredito) =
                let creditCard = creditCardType(cardNumber      = tar.numero.Id
                                            ,   expirationDate  = tar.expiracion.Id               )
                paymentType( Item = creditCard ), tar.titular
        
            let pagoTipoCuenta  (cta:CuentaBancaria) =
                let  bankAccount = bankAccountType(  accountNumber   = cta.numero .Id
                                                ,   routingNumber   = cta.routing.Id
                                            //,   accountType     = bankAccountTypeEnum.checking
                                            //,   echeckType      = echeckTypeEnum.WEB
                                                ,   nameOnAccount   = cta.titular
                                                ,   bankName        = cta.banco)
                paymentType( Item = bankAccount  ), cta.titular
        
            let datosTitularO (aliado:Aliado) (titular:string) =
                aliado.contactos 
                |> Seq.tryPick(function | Direccion dir -> Some dir |_-> None)
                |> Option.map (fun direccion -> 
                    customerAddressType(firstName = (titular.Split ' ').[0]
                                    ,   lastName  = (titular.Split ' ' |> Seq.skip 1 |> String.concat " ")
                                    ,   address   = direccion.linea1
                                    ,   city      = direccion.ciudad
                                    ,   state     = direccion.estado    .ToString()
                                    ,   zip       = direccion.zonaPostal.ToString()
                                    ,   country   = direccion.pais      .ToString()
                                    )
                )
        
            let perfilPago (tipoPago: paymentType, titular: string) (aliado:Aliado) =
                datosTitularO aliado titular
                |> Option.map (fun datosTitular ->
                    aliado,
                    customerPaymentProfileType( payment = tipoPago
                                            ,   billTo  = datosTitular )
                )
        
            let registrarFormaPago (al, pp) =
                buscarIdAuthorize al
                |> Rsl.getResult
                >>= function
                    | Ok p -> registrarPagoNuevo   (p , pp)
                    |_     -> registrarAliadoNuevo (al, pp)
        
            let crearFormaPago aid (tipoPago: paymentType, titular : string) =
                ObtenerEstado.obtenerAliado aid
                |>> perfilPago (tipoPago, titular)
                |>  Rsl.absorbO (fun () -> "No se encontro direccion")
                >>= registrarFormaPago
        
            let registrarTarjeta         aid (tc:TarjetaCredito) =
                pagoTipoTarjeta tc
                |>  crearFormaPago aid
                |>> fun _ -> "Tarjeta registrada."
        
            let registrarCuenta          aid (cta: CuentaBancaria) =
                pagoTipoCuenta cta
                |>  crearFormaPago aid
                |>> fun _ -> "Cuenta registrada."
        
            let validarFormaPago         aid (IdPayment idp) =
                ObtenerEstado.obtenerAliado aid
                >>= buscarIdAuthorize
                |>> fun (IdAuthorize idm)  ->
                        validateCustomerPaymentProfileRequest(  customerProfileId        = idm
                                                            ,   customerPaymentProfileId = idp
                                                            ,   validationMode           = validationModeEnum.liveMode
                        )
                >*= validateCustomerPaymentProfileController
                |>> fun response -> response.directResponse
        
            let obtenerAliadoEstadoPerfilSubIds idAl =
                ObtenerEstado.obtenerAliadoEstado idAl
                >>= fun (al,md) ->
                        buscarPerfil al
                        |>> fun (pe,subIds) -> al, md, pe, subIds
        
            let getSubscription sid =
                ARBGetSubscriptionRequest(subscriptionId = sid, refId = sid)
                |*> ARBGetSubscriptionController
        
            let obtenerAliadoEstadoPerfilSubActivos idAl =
                obtenerAliadoEstadoPerfilSubIds     idAl
                >>= fun  (al : Aliado, md : Modelo, pe, subIds)  ->
                        subIds
                        |> traverseSeq getSubscription 
                        |>> Seq.filter (fun s -> s.subscription.status = ARBSubscriptionStatusEnum.active)
                        |>> fun subs -> (al, md, pe, subs)
        
            let obtenerAliadoEstadoPerfilSubActiva  idAl =
                obtenerAliadoEstadoPerfilSubActivos idAl
                |>> fun  (al : Aliado, md : Modelo, pe, subs)  ->
                        subs
                        |> Seq.tryHead
                        |> fun subO -> (al, md, pe, subO)
        
            let obtenerFormasDePagoId aid =
                obtenerAliadoEstadoPerfilSubActivos aid
                |>> fun (al, md, perfil, subs) ->
                        if perfil.paymentProfiles = null then [||] else perfil.paymentProfiles
                        |> Array.choose (fun pago ->
                            match pago.payment.Item with
                            | :? AuthorizeNet.Api.Contracts.V1.creditCardMaskedType as cc -> 
                                TarjetaCredito {
                                    titular       = pago.billTo.firstName + " " + pago.billTo.lastName
                                    tipoTarjeta   = TipoTarjeta.tryParse cc.cardType |> Option.defaultValue Visa
                                    numero        = NumeroTarjeta cc.cardNumber
                                    expiracion    = { anio = 0 ; mes = Mes.Enero}
                                } |> Some
                            | :? AuthorizeNet.Api.Contracts.V1.bankAccountMaskedType as ba -> 
                                CuentaBancaria {
                                    titular     = ba.nameOnAccount
                                    banco       = ba.bankName
                                    tipo        = match ba.accountType with
                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.businessChecking
                                                    | AuthorizeNet.Api.Contracts.V1.bankAccountTypeEnum.checking          -> Corriente
                                                    |_-> Ahorro
                                    numero      = NumeroCuenta  ba.accountNumber
                                    routing     = RoutingNumber ba.routingNumber
                                } |> Some
                            |_-> None
                            |> Option.map (fun cta ->
                                {
                                    nombre        = ""
                                    authorizeIdR  = pago.customerPaymentProfileId |> IdPayment |> Ok
                                    cuentaPago    = cta
                                    subscripcion  = subs 
                                                    |> Seq.tryFind(fun sub -> sub.subscription.profile.paymentProfile.customerPaymentProfileId = pago.customerPaymentProfileId)
                                                    |> Option.map (fun sub -> {
                                                        idSubscripcion = IdSubscription sub.refId 
                                                        monto          = int sub.subscription.amount
                                                        descripcion    =     sub.subscription.name
                                                        inicio         =     sub.subscription.paymentSchedule.startDate
                                                        status         = int sub.subscription.status
                                                    })
                                }
                            )
                        )
                |>  Rsl.getResult
                |>> Result.defaultValue [||]
        
        //    let obtenerFormasDePago aid =
        //        fun () -> ObtenerEstado.obtenerAliado aid
        //        >=> obtenerFormasDePagoId
        
            let obtenerFormasDePagoPara (alIds:_[]) = eff {
                let! fps =
                    alIds 
                    |> traverseSeq (fun id -> eff {
                        let! fp = obtenerFormasDePagoId id
                        return id, fp
                    })
                return fps |> Seq.toArray 
            }
        
            let crearSubscripcion aid (IdPayment idp) = 
                obtenerAliadoEstadoPerfilSubActiva aid 
                >>= fun  (al : Aliado, md : Modelo, pe, subO)  -> eff {
                        let start = DateTime(DateTime.Today.Year, DateTime.Today.Month, Aliado.dia al.diaPago)
                                    |> fun start -> if start < DateTime.Today               then start.AddMonths 1 else start
                                    |> fun start -> if start < al.fechaRegistro.AddMonths 1 then start.AddMonths 1 else start
                        let sub   = if subO.IsNone then 
                                        ARBSubscriptionType(
                                                amount                  = decimal md.premisas.montoAfiliacion
                                            ,   name                    = "Afiliacion Mensual Prozper"
                                            ,   paymentSchedule         = paymentScheduleType(  interval                    = paymentScheduleTypeInterval(length = int16 1, unit = ARBSubscriptionUnitEnum.months) 
                                                                                            ,   totalOccurrences            = int16 240
                                                                                            ,   startDate                   = start)
                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId
                                                                                            ,   customerPaymentProfileId    = idp)
                                        )
                                    else
                                        ARBSubscriptionType(
                                                amount                  = decimal md.premisas.montoAfiliacion
                                            ,   name                    = "Afiliacion Mensual Prozper"
                                            ,   profile                 = customerProfileIdType(customerProfileId           = pe.customerProfileId
                                                                                            ,   customerPaymentProfileId    = idp)
                                        )
                        return sub, subO
                    }
        
            let createSubscription sub =
                ARBCreateSubscriptionRequest(subscription = sub)
                |*> ARBCreateSubscriptionController
                |>> fun response -> response.subscriptionId
        
            let updateSubscription subId sub =
                ARBUpdateSubscriptionRequest(subscription = sub, subscriptionId = subId)
                |*> ARBUpdateSubscriptionController
                |>> fun _response -> subId
        
            let actualizarSubscripcion aid idp =
                crearSubscripcion aid idp
                >>= function
                    | subT, None     -> createSubscription           subT
                    | subT, Some sub -> updateSubscription sub.refId subT // usando refId para guardar subscriptionId
        
            let getBatchDetalles bid = 
                getTransactionListRequest(  batchId = bid )
                |*> getTransactionListController
                |>> fun response -> response.transactions
        
            let buscarPerfilPorProfileId pid =
                getCustomerProfileRequest(  customerProfileId = string pid )
                |*> getCustomerProfileController
                |>> fun response -> response.profile
        
            let getSubscriptions active =
                ARBGetSubscriptionListRequest(searchType = (if active then ARBGetSubscriptionListSearchTypeEnum.subscriptionActive else ARBGetSubscriptionListSearchTypeEnum.subscriptionInactive) )
                |*> ARBGetSubscriptionListController
                |>> fun response -> response.subscriptionDetails
                >>= traverseSeq (fun s -> buscarPerfilPorProfileId s.customerProfileId |>> (fun p -> s, p) )
        
            let cancelarSubscripcion sid =
                ARBCancelSubscriptionRequest(subscriptionId = sid)
                |*> ARBCancelSubscriptionController
        
            let borrarFormaPago aid (IdPayment idp) =
                obtenerAliadoEstadoPerfilSubActiva aid 
                >>= fun (al : Aliado, md : Modelo, pe, subO)  -> eff {
                        match subO with
                        | Some sub when sub.subscription.profile.paymentProfile.customerPaymentProfileId = idp -> 
                                let! _ = cancelarSubscripcion sub.refId
                                do!      Log.logf "Subscripcion cancelada %s" idp
                                return al
                        |_->    return al
                }
                >>= buscarIdAuthorize
                |>> fun (IdAuthorize idm)  ->
                        deleteCustomerPaymentProfileRequest(customerProfileId        = idm
                                                        ,   customerPaymentProfileId = idp
                        )
                >*= deleteCustomerPaymentProfileController
                |>> fun response -> "Forma de pago borrada."
        
            let toTransaccion aid (tr:transactionSummaryType) = {
                fechaPago   = tr.submitTimeLocal
                ano         = tr.submitTimeLocal.Year
                periodo     = tr.submitTimeLocal.Month
                monto       = int (tr.settleAmount * 100.00M)
                idAliado    = aid
                concepto    = ConceptoPago.Otro tr.accountNumber
                transaccion = tr.transId
                statusTran  = tr.transactionStatus
            }
        
            let obtenerTransacciones nO =
                let n = Option.defaultValue 0 nO
                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths (-n-1) 
                                         ,   lastSettlementDate  = System.DateTime.Today.AddMonths (-n  ) )
                |*> getSettledBatchListController
                |>> fun response -> response.batchList
                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )
                |>> Seq.collect (snd >> Seq.filter(fun tr -> tr.subscription <> null || tr.profile <> null) )// >> Seq.map (toTransaccion <| IdAliado ""))
        
            let ResultToOption r = r |> Result.map Some |> Result.defaultValue None
            let getOption eff = Rsl.getResult eff |>> ResultToOption
        
            let actualizarTransacciones nO = eff {
                let! modelo   = ObtenerEstado.obtenerEstado()
                let! ts       = obtenerTransacciones nO
                let! perfs    = modelo.aliados |> traverseSeq (fun  al -> buscarPerfil al |>> (fun (p, subs) -> al, p, subs) |> getOption) |>> (Seq.choose id >> Seq.toArray)
                let  subs     = perfs          |> Seq.collect (fun (al,_   ,sbs) -> sbs |>  Seq.map (fun sb -> sb, al.id )   ) |>  Seq.toArray
                let  ids      = perfs          |> Seq.map     (fun (al,perf, _ ) ->        perf.customerProfileId, al.id     ) |>  Seq.toArray
                do!     ts 
                        |> Seq.choose(fun tr ->
                            if   tr.subscription <> null then subs |> Seq.tryFind (fst >> (=) (string tr.subscription.id   ) ) |> Option.map snd
                            elif tr.profile      <> null then ids  |> Seq.tryFind (fst >> (=) tr.profile.customerProfileId   ) |> Option.map snd
                            else None
                            |> Option.map (swap toTransaccion tr) )
                        |> Seq.toArray
                        |> ObtenerEstado.salvarTransaccsE
            }
        
            let obtenerTransaccionesPara aid isAdmin = eff {
                let! modelo   = ObtenerEstado.obtenerEstadoParaUsuario aid isAdmin
                let  aids     = modelo.aliados |> Seq.map(fun al -> al.id) |> Set
                let! ts       = ObtenerEstado.leerTransaccsE ()
                return ts |> Array.filter (fun tr -> aids |> Set.contains tr.idAliado)
            }
        
            let getSubscriptionTransactions () =
                getSettledBatchListRequest(  firstSettlementDate = System.DateTime.Today.AddMonths -1 
                                         ,   lastSettlementDate = System.DateTime.Now)
                |*> getSettledBatchListController
                |>> fun response -> response.batchList
                >>= traverseSeq (fun b -> getBatchDetalles b.batchId |>> (fun ts -> b, ts) )
                |>>(Seq.map   (fun (b,ts) -> b, ts |> Seq.filter(fun t -> t.subscription <> null) )
                 >> Seq.filter(fun (b,ts) ->    ts |> Seq.isEmpty |> not )
                   )
        
            let SubsYTransacciones () =
                getSubscriptionTransactions()
                |>> Seq.collect (fun (b, ts) -> ts |> Seq.map (fun t -> b, t))
                >>= fun ts -> eff {
                        let! subs = getSubscriptions true
                        return ts, subs 
                    }
                >>=! (fun (ts, subs) -> eff {
                        let orphans = ts |> Seq.filter(fun (b,t) -> subs |> Seq.exists (fun (s,p) -> s.id = t.subscription.id) |> not) |> Seq.toArray
                        for b, t in orphans do
                            do! Log.logf "Huerfano: %A" (
                                        b.batchId
                                        , t.accountNumber
                                        , t.accountType
                                        , t.firstName
                                        , t.lastName
                                        , t.settleAmount
                                        , t.subscription.id
                                        , t.subscription.payNum
                                        , t.transactionStatus
                                        , t.transId )
                    })
                |>> fun (ts, subs) ->  subs |> Seq.map(fun (sub,p) -> sub,p, ts |> Seq.filter (fun (b,t) -> t.subscription.id = sub.id) )
        
            //type H() =
            //    interface Rsl.Rsl<string>
            //    interface Log.Log<string>
            //    interface VariableAmbienteI with member __.getVar  v  = failwith "VariableAmbienteI.getVar not implemented"
            //    interface AuthorizeI<H>     with member __.execute c  = failwith "AuthorizeI<H>.Execute not implemented"
            //                                     member __.prepare () = failwith "AuthorizeI<H>.Prepare not implemented"
            //    interface EstadoI with
            //            member __.UltimoEvento      ()  = failwith "EstadoI.UltimoEvento not implemented"
            //            member __.UltimoEstado      ()  = failwith "EstadoI.UltimoEstado not implemented"
            //            member __.LeerEventos       p   = failwith "EstadoI.LeerEventos not implemented"
            //            member __.LeerTipos         ()  = failwith "EstadoI.LeerTipos not implemented"
            //            member __.LeerEventosTipos  ()  = failwith "EstadoI.LeerEventosTipos not implemented"
            //            member __.GuardarEstado     p q = failwith "EstadoI.GuardarEstado not implemented"
            //            member __.GuardarAliado     p q = failwith "EstadoI.GuardarAliado not implemented"
            //            member __.ObtenerEstado     ()  = failwith "EstadoI.ObtenerEstado not implemented"
            //            member __.ObtenerAliados    ()  = failwith "EstadoI.ObtenerAliados not implemented"
        
            let voidTransaction tid =
                transactionRequestType(transactionType = "voidTransaction", refTransId = tid)
                |>  fun trt -> createTransactionRequest(transactionRequest = trt)
                |*> createTransactionController
        
            let obtenerTransaccionesReq aid req =
                req
                |*>  getTransactionListForCustomerController
                |>>  fun resp ->
                        if resp.transactions = null then [||] else 
                        resp.transactions
                        |> Array.map (toTransaccion aid)
        
            let obtenerTransaccionesAliado aid =
                ObtenerEstado.obtenerAliado aid
                >>=  buscarPerfil
                >>=! fun (perfil,_) -> Log.logf "Perfil: %A %A %A" perfil.customerProfileId perfil.description perfil.email
                |>>  fun (perfil,_) -> getTransactionListForCustomerRequest( customerProfileId = perfil.customerProfileId)
                >>=  obtenerTransaccionesReq aid
        
            let xobtenerTransaccionesForPayment aid pid =
                ObtenerEstado.obtenerAliado aid
                >>=  buscarPerfil
                >>=! fun (perfil,_) -> Log.logf "Perfil: %A %A %A" perfil.customerProfileId perfil.description perfil.email
                |>>  fun (perfil,_) -> getTransactionListForCustomerRequest( customerProfileId = perfil.customerProfileId, customerPaymentProfileId = pid)
                >>=  obtenerTransaccionesReq aid          
        
            let xxobtenerTransaccionesPara aid = eff {
                let! perfil, subs = ObtenerEstado.obtenerAliado aid >>= buscarPerfil
                let! ats = getSubscriptionTransactions ()
                let! ts2 = obtenerTransaccionesAliado aid
                let  ts  = ats |> Seq.collect( fun (a,ts) -> ts) 
                return 
                    ts
                    |> Seq.filter (fun tr -> subs |> Seq.contains (string tr.subscription.id) )
                    |> Seq.map (toTransaccion aid)
                    |> Seq.append ts2
                    |> Seq.toArray
            }
        
        
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation/packages/prozper/WindowsAzure.Storage/lib/net45/Microsoft.WindowsAzure.Storage.dll"
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll"
        module Azure =
            open System
            open System.IO
        //    open Microsoft.Azure
        //    open Microsoft.Azure.Storage
        //    //open Microsoft.Azure.Storage.Table
        //    open Microsoft.Azure.Storage.Queue
        //    open Microsoft.Azure.Storage.Blob
        //    open Microsoft.Azure.Storage.Core
            open Microsoft.WindowsAzure.Storage
            open Microsoft.WindowsAzure.Storage.Queue
            open Microsoft.WindowsAzure.Storage.Table
        
            let storageSetting      =  "APPSETTING_AzureWebJobsStorage"
            let aliadosTableName    =  "Aliados"
            let eventosTableName    =  "Eventos"
            let mensajesTableName   =  "Mensajes"
            let estadoTableName     =  "Modelo"
            let transacTableName    =  "Transacciones"
            let archivosTableName   =  "Archivos"
            let correosQueueName    =  "correos"
            let mensajesQueueName   =  "mensajes"
            let storageAccountE()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse
            let storageAccountC()   = variableAmbienteE storageSetting |>> CloudStorageAccount.Parse
            let tableClientE   ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudTableClient()
            let queueClientE   ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudQueueClient()
            let blobClientE    ()   = storageAccountE() |>> fun storageAccount -> storageAccount.CreateCloudBlobClient ()
            let fileClientE    ()   = storageAccountC() |>> fun storageAccount -> storageAccount.CreateCloudFileClient ()
            let aliadosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(aliadosTableName )
            let mensajesTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(mensajesTableName)
            let eventosTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(eventosTableName )
            let estadoTableE   ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(estadoTableName  )
            let transacTableE  ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(transacTableName )
            let archivosTableE ()   = tableClientE   () |>> fun tableClient    -> tableClient.GetTableReference(archivosTableName)
            let queueCorreosE  ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(correosQueueName )
            let queueMensajesE ()   = queueClientE   () |>> fun queueClient    -> queueClient.GetQueueReference(mensajesQueueName)
        
            type Correo = {
                Subject       : string
                Content       : string
                CustomerEmail : string
            }
        
            type Mensaje = {
                remitente     : string
                destinatario  : string
                tema          : string
                contenido     : string
            }
        
            let enviarCorreoAzure (recipiente:string) (tema:string) (contenido:string)  = 
                {   Subject       = tema
                    Content       = contenido 
                    CustomerEmail = recipiente
                }
                |> Newtonsoft.Json.JsonConvert.SerializeObject
                |> CloudQueueMessage
                |> (fun m -> queueCorreosE() >>= fun queueCorreos -> queueCorreos.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)
        
            let enviarMensaje (mensaje:Mensaje) = 
                mensaje
                |> Newtonsoft.Json.JsonConvert.SerializeObject
                |> CloudQueueMessage 
                |> (fun m -> queueMensajesE() >>= fun queueMensajes -> queueMensajes.AddMessageAsync m |> Async.AwaitTask |> Asy.ofAsync)
        
            type AliadoE(id, aliado: string) =
                inherit TableEntity(partitionKey="Aliado", rowKey=id)
                new() = AliadoE(null, null)
                member val Aliado = aliado with get, set
        
            type MensajeE(mensaje: Mensaje, id) =
                inherit TableEntity(partitionKey= mensaje.destinatario, rowKey=id)
                new(mensaje) = MensajeE(mensaje, System.Guid.NewGuid().ToString())
                new() = MensajeE(  {    remitente     = ""
                                        destinatario  = ""
                                        tema          = ""
                                        contenido     = ""
                                    }  )
                member val id           = id                    with get, set
                member val Remitente    = mensaje.remitente     with get, set
                member val Destinatario = mensaje.destinatario  with get, set
                member val Tema         = mensaje.tema          with get, set
                member val Contenido    = mensaje.contenido     with get, set
        
            type TransacE(transac: Transaccion) =
                inherit TableEntity(partitionKey= transac.idAliado.Id, rowKey=transac.transaccion)
                new() = TransacE({  fechaPago      = System.DateTime.MinValue
                                    ano            = 0
                                    periodo        = 0
                                    monto          = 0
                                    idAliado       = IdAliado ""
                                    concepto       = ConceptoPago.Otro ""
                                    transaccion    = "-"
                                    statusTran     = ""
                            })
                member val fechaPago      = transac.fechaPago             with get, set
                member val ano            = transac.ano                   with get, set
                member val periodo        = transac.periodo               with get, set
                member val monto          = transac.monto                 with get, set
                member val idAliado       = transac.idAliado.Id           with get, set
                member val concepto       = transac.concepto.ToString()   with get, set
                member val transaccion    = transac.transaccion           with get, set
                member val statusTran     = transac.statusTran            with get, set
        
            type ArchivoE(archivo: Archivo) =
                inherit TableEntity(partitionKey= archivo.idAliado.Id, rowKey= archivo.nombre)
                new() = ArchivoE({  idAliado    = IdAliado ""
                                    tipo        = TipoArchivo.Otro ""
                                    nombre      = ""
                                    modificado  = System.DateTime.MinValue
                                    tamano      = 0L
                                    status      = StatusArchivo.Subido
                                    comentario  = ""
                            })
                member val modificado = archivo.modificado           with get, set
                member val tamano     = archivo.tamano               with get, set
                member val comentario = archivo.comentario           with get, set
                member val tipo       = archivo.tipo  .ToString()    with get, set
                member val status     = archivo.status.ToString()    with get, set
        
            type EstadoE(n:int64, estado: string) =
                inherit TableEntity(partitionKey= "EstadoActual", rowKey= "Estado")
                new() = EstadoE(0L, "")
                member val nevento      = n      with get, set
                member val estado       = estado with get, set
        
            type EstadoNE(n:int64) =
                inherit TableEntity(partitionKey= "EstadoActual", rowKey= "EstadoActual")
                new() = EstadoNE(0L)
                member val nevento      = n      with get, set
        
            type EventoE(n:int64, usuario:string, nombre:string, evento:string, tipo:string) =
                inherit TableEntity(partitionKey= "Evento", rowKey= sprintf "%08d" n)
                new() = EventoE(0L, "", "", "", "")
                member val nevento      = n       with get, set
                member val usuario      = usuario with get, set
                member val nombre       = nombre  with get, set
                member val tipo         = tipo    with get, set
                member val evento       = evento  with get, set
        
            type EventoNE(n:int64) =
                inherit TableEntity(partitionKey= "Actual", rowKey= "Actual")
                new() = EventoNE(0L)
                member val nevento      = n      with get, set
        
            let executeE      tbE  op = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteAsync      op |> Async.AwaitTask |> Asy.ofAsync
            let executeQueryE tbE (op:TableQuery<_>) = tbE() >>= fun (tb:CloudTable) -> tb.ExecuteQuerySegmentedAsync(op, null) |> Async.AwaitTask |> Asy.ofAsync
        
            let guardarAliado id contenido = 
                TableOperation.InsertOrReplace <| AliadoE(id, contenido)
                |> executeE aliadosTableE
        
            let guardarMensaje mensaje =
                TableOperation.InsertOrReplace <| MensajeE(mensaje)
                |> executeE mensajesTableE
        
            let guardarTransac transac =
                TableOperation.InsertOrReplace <| TransacE(transac)
                |> executeE transacTableE
        
            let guardarTransacs (ts: Transaccion seq) = 
                ts 
                |> traverseSeq guardarTransac
                |>> Seq.iter ignore
        
            let obtenerTransacs() = 
                TableQuery<TransacE>()
                |>  executeQueryE transacTableE
                |>> (Seq.map (fun tr -> {  
                                    fechaPago      = tr.fechaPago  
                                    ano            = tr.ano        
                                    periodo        = tr.periodo    
                                    monto          = tr.monto      
                                    idAliado       = IdAliado tr.idAliado   
                                    concepto       = ConceptoPago.tryParse tr.concepto |> Option.defaultValue (ConceptoPago.Otro "")
                                    transaccion    = tr.transaccion
                                    statusTran     = tr.statusTran 
                            }
                ) >> Seq.toArray)
        
            let guardarArchivo archivo =
                TableOperation.InsertOrReplace <| ArchivoE(archivo)
                |> executeE archivosTableE
        
            let obtenerArchivos() = 
                TableQuery<ArchivoE>()
                |>  executeQueryE archivosTableE
                |>> (Seq.map (fun tr -> {  
                                    idAliado    = IdAliado tr.PartitionKey
                                    nombre      = tr.RowKey
                                    modificado  = tr.modificado
                                    tamano      = tr.tamano    
                                    comentario  = tr.comentario
                                    tipo        = tr.tipo   |> TipoArchivo  .Parse
                                    status      = tr.status |> StatusArchivo.Parse 
                            }
                ) >> Seq.toArray)
        
            let obtenerAliados() =
                TableQuery<AliadoE>()
                |>  executeQueryE aliadosTableE
                |>> (Seq.map (fun al -> al.Aliado) >> Seq.toArray)
        
            let borrarAliado aid =
                TableOperation.Delete(AliadoE(aid, "", ETag = "*") )
                |> executeE aliadosTableE
        
            let guardarEstado (n:int64) s =
                let op1 = TableOperation.InsertOrReplace <| EstadoE( n, s)
                let op2 = TableOperation.InsertOrReplace <| EstadoNE(n   )
                executeE estadoTableE op1
                >>= fun _ -> executeE estadoTableE op2
        
            let ultimoEstado() =
                TableQuery<EstadoNE>()
                  .Where(
                      TableQuery.CombineFilters(
                          TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, "EstadoActual"),
                          TableOperators.And,
                          TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.Equal,"EstadoActual")
                  ))
                |> executeQueryE estadoTableE
                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )
        
            let obtenerEstado() =
                TableQuery<EstadoE>()
                  .Where(
                      TableQuery.CombineFilters(
                          TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, "EstadoActual"),
                          TableOperators.And,
                          TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.Equal,"Estado")
                  ))
                |> executeQueryE estadoTableE
                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento, e.estado) )
        
            let ultimoEvento() = //obtenerTextoArchivo archivoUltimoEvento |> Option.bind ParseO.parseInt64O 
                TableQuery<EventoNE>()
                  .Where(
                      TableQuery.CombineFilters(
                          TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, "Actual"),
                          TableOperators.And,
                          TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.Equal,"Actual")
                  ))
                |> executeQueryE eventosTableE
                |>> (Seq.tryHead >> Option.map (fun e -> e.nevento) )
        
            let nuevoEvento (usuario:string) (nombre:string) (evento:string) (tipo:string) =
                ultimoEvento()
                |>> Option.defaultValue 0L
                |>> (+) 1L
                >>= fun nextEvento ->
                    EventoE( nextEvento, usuario, nombre, evento, tipo)
                    |>  TableOperation.InsertOrReplace
                    |>  executeE eventosTableE
                    |>> fun _ -> EventoNE(nextEvento   )
                    |>> TableOperation.InsertOrReplace
                    >>= executeE eventosTableE
                    |>> fun _ -> nextEvento
        
            let getMimeO (name :string)=
                match name.ToLower() with
                | String.EndsWith ".pdf"  _ -> Some "application/pdf"
                | String.EndsWith ".rtf"  _ -> Some "application/rtf"
                | String.EndsWith ".pbm"  _ -> Some "image/x-portable-bitmap"
                | String.EndsWith ".bmp"  _ -> Some "image/bmp"
                | String.EndsWith ".gif"  _ -> Some "image/gif"
                | String.EndsWith ".tif"  _
                | String.EndsWith ".tiff" _ -> Some "image/tiff"
                | String.EndsWith ".png"  _ -> Some "image/png"
                | String.EndsWith ".jpe"  _ 
                | String.EndsWith ".jpeg" _ 
                | String.EndsWith ".jpg"  _ -> Some "image/jpeg"
                | String.EndsWith ".png"  _ -> Some "image/png"
                | String.EndsWith ".html" _ -> Some "text/html"
                | _-> None
        
            let obtenerListaDocs (IdAliado alid) = eff {
                let! bcli      = blobClientE()
                let  container = bcli.GetContainerReference "documentos"
                let  dir       = container.GetDirectoryReference  alid
                let! blobs     = dir.ListBlobsSegmentedAsync   null |> Async.AwaitTask |> Asy.ofAsync
                let! archivos  = obtenerArchivos() |>> Array.filter (fun a -> a.idAliado.Id = alid)
                return
                    blobs.Results
                    |> Seq.choose (fun blob ->
                        blob.Uri.GetComponents(UriComponents.Path, UriFormat.Unescaped) 
                        |> String.splitInTwoO (alid + "/")
                        |> Option.map snd
                        |> Option.map (fun nombre ->
                            let ref = dir.GetBlockBlobReference nombre
                            ref.FetchAttributes()
                            archivos
                            |> Seq.tryFind (fun a -> a.nombre = nombre) 
                            |> Option.map  (fun a ->
                                if a.modificado = ref.Properties.LastModified.Value.DateTime && a.tamano = ref.Properties.Length then a else
                                { a with 
                                    modificado  = ref.Properties.LastModified.Value.DateTime
                                    tamano      = ref.Properties.Length
                                    status      = StatusArchivo.Cambiado
                                }
                            )
                            |> Option.defaultWith ( fun () -> {  
                                idAliado    = IdAliado alid
                                nombre      = nombre
                                modificado  = ref.Properties.LastModified.Value.DateTime
                                tamano      = ref.Properties.Length
                                comentario  = ""
                                tipo        = TipoArchivo.Otro "-"
                                status      = StatusArchivo.Subido
                            })
                        )
                    )
                    |> Seq.toArray
            }
        
            let subirBlob fromFile toContainerName toFile =
                blobClientE()
                >>= fun bcli ->
                        bcli                          .GetContainerReference toContainerName
                        |>  fun container -> container.GetBlockBlobReference toFile
                        |>  fun blob      -> blob     .UploadFromFileAsync   fromFile |> Async.AwaitTask |> Asy.ofAsync |>> fun () -> blob
                        >>= fun blob      -> eff { 
                                match getMimeO toFile with
                                | None -> ()
                                |   Some mime ->    blob.Properties.ContentType <- mime
                                                    do! blob.SetPropertiesAsync() |> Async.AwaitTask |> Asy.ofAsync
                            }
        
            let obtenerPropiedadesBlob toContainerName toFile = eff {
                let! bcli = blobClientE()
                let  blob =
                        bcli                         .GetContainerReference toContainerName
                        |> fun container -> container.GetBlockBlobReference toFile
                let! exists = blob.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync
                return if exists then Some blob.Properties else None
            }
        
            let obtenerPropiedadesArchivo shareName toFile = eff {
                let! fcli = fileClientE   () 
                let  file =
                        fcli                 .GetShareReference        shareName
                        |> fun share -> share.GetRootDirectoryReference()
                        |> fun dir   -> dir  .GetFileReference         toFile
                let! exists = file.ExistsAsync() |> Async.AwaitTask |> Asy.ofAsync
                return if exists then Some file.Properties else None
            }
        
            let subirArchivo fromFile shareName toFile =
                fileClientE   () 
                >>= fun fcli ->
                        fcli                 .GetShareReference        shareName
                        |> fun share -> share.GetRootDirectoryReference()
                        |> fun dir   -> dir  .GetFileReference         toFile
                        |> fun file  -> file .UploadFromFileAsync    fromFile |> Async.AwaitTask |> Asy.ofAsync
        
        
        //    let setAmbiente() =
        //        {
        //            new IAmbiente with 
        //                member __.UltimoEvento      ()  = ultimoEvento()
        //                member __.UltimoEstado      ()  = ultimoEstado()
        //                member __.LeerTipos         ()  = [||]   
        //                member __.LeerEventosTipos  ()  = [||]   
        //                member __.NuevoEvento       (usuario:string) (nombre:string) (evento:string) (tipo:string) = nuevoEvento usuario nombre evento tipo
        //                member __.LeerEventos       n   = AsyncResultM.errorMsgf "ambienteAzure.LeerEventos not implemented"
        //                member __.GuardarEstado     n s = guardarEstado n s
        //                member __.ObtenerEstado     ()  = obtenerEstado
        //                member __.GuardarAliado     i s = guardarAliado i s
        //                member __.ObtenerAliados    ()  = obtenerAliados
        //                member __.NombreAmbiente    ()  = "azure"
        //                member __.CarpetaRaiz       ()  = carpeta
        //                member __.EnviarCorreo    r t c = enviarCorreoAzure r t c
        //                member __.EnviarMensaje d r t c = enviarMensaje  { 
        //                                                        remitente     = d 
        //                                                        destinatario  = r 
        //                                                        tema          = t 
        //                                                        contenido     = c 
        //                                                    }
        //                member __.ObtenerTransacciones      id = AsyncResultM.errorMsgf "Ambiente.ObtenerTransacciones: not implemented"
        //                member __.ObtenerMensajes           id = AsyncResultM.errorMsgf "Ambiente.ObtenerMensajes: not implemented"
        //                member __.ObtenerListaDocs          id = obtenerListaDocs id
        //                member __.VariableAmbiente           v = System.Environment.GetEnvironmentVariable v
        //                member __.Prepare                   () = Authorize.prepareAuthorizeNetEnvironment()
        //        }
        //
        
            let invokeE nameF (f:'a->Eff<'H, 'b>) (p:'a) =
                try 
                    f p |> Ok
                with e ->
                    Error (sprintf "Exception! %s %s" <| nameF p <| e.ToString())
                |> Rsl.ofResult
                |> join
        
            let invokeR nameF (f:'a->'b) (p:'a) =
                try 
                    f p |> Ok
                with e ->
                    Error (sprintf "Exception! %s %s" <| nameF p <| e.ToString())
                |> Rsl.ofResult
        
            let invokeVerboseR nameF (f:'a->'b) (p:'a) = eff {
                try 
                    do! Log.logf "invokeVerboseR: %s" (nameF p)
                    let r = f p 
                    do! Log.logf "%s %A" (nameF p) r
                    return r
                with e ->
                    return!
                        Error (sprintf "Exception! %s %s" <| nameF p <| e.ToString())
                        |> Rsl.ofResult
            }
        
            let invokeL nameF (f:'a->'b) (p:'a) =
                try 
                    f p |> Log.logf "%s %A" (nameF p) //|>> ignore 
                with e ->
                    Error (sprintf "Exception! %s %s" <| nameF p <| e.ToString())
                    |> Rsl.ofResult
        
            let invokeLE nameF (f:'a->Eff<'H, 'b>) (p:'a) =
                try 
                    f p 
                    >>= Log.logf "%s %A" (nameF p) 
                    |>  Ok
                with e ->
                    Error (sprintf "Exception! %s %s" <| nameF p <| e.ToString())
                |> Rsl.ofResult
                |> join
        
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\FSharp.Data\lib\net45\FSharp.Data.dll"
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\other\Microsoft.IdentityModel.Clients.ActiveDirectory\lib\net45\Microsoft.IdentityModel.Clients.ActiveDirectory.dll"
        //#r @"D:\Abe\CIPHERWorkspace\FSharpStation\packages\Newtonsoft.Json\lib\net45\Newtonsoft.Json.dll"
        
        //#r @"System.Net.Http.dll"
        //#r @"System.Core.dll"
        
        //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.dll"
        //#r @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\System.Core.dll"
        
        
        
        //#r @"D:\Abe\CIPHERWorkspace\AzureFunctions\packages\NETStandard.Library\build\netstandard2.0\ref\netstandard.dll"
        //#r @"D:\Abe\CIPHERWorkspace\AzureFunctions\packages\NETStandard.Library\build\net452\ref\netstandard.dll"
        
        module FSIReader =
            open Authorize
            open FSharp.Data
            open AuthorizeNet
            open AuthorizeNet.Api.Controllers
            open AuthorizeNet.Api.Contracts.V1
            open AuthorizeNet.Api.Controllers.Bases
            open Azure
        
            let [< Literal >] jsonSettings = @"D:\Abe\CIPHERWorkspace\AzureFunctions\Suave\bin\Debug\netstandard2.0\local.settings.json"
        
            type LocalJson          = JsonProvider<jsonSettings>
        
            type AR<'V> = Eff<AzureReader,'V>
            and  AzureReader(?environment : string, ?moreSettings: Map<string, string>) =
                let settings0 = 
                        LocalJson.GetSample().Values.JsonValue.Properties()
                        |> Seq.choose (function (k, JsonValue.String s) -> Some(k, s) |_-> None)
                        |> Map
                let settings = 
                    match moreSettings with
                    | None      -> settings0
                    | Some more -> (settings0, more) ||> Seq.fold(fun map kvp -> Map.add kvp.Key kvp.Value map )
                let prepareEnvironment env id transactionKey =
                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.RunEnvironment         <- env
                    printfn "Prepare environment %A %A %A %A" env id ItemChoiceType.transactionKey transactionKey
                    ApiOperationBase<ANetApiRequest, ANetApiResponse>.MerchantAuthentication <- 
                        new merchantAuthenticationType( name            = id
                                                    ,   ItemElementName = ItemChoiceType.transactionKey
                                                    ,   Item            = transactionKey )
                let mutable environmentNameO = None
                let prepararE = eff {
                    let! env =  eff {
                                    match environment with
                                    | Some v -> return v.ToUpper()
                                    |_       -> return! variableAmbienteE "Authorize_Environment"
                                }
                    let  environment, environmentName, idV, tranKeyV =
                        match env with
                        | "P" ->(   AuthorizeNet.Environment.PRODUCTION
                                ,   "PRODUCTION"
                                ,   "Authorize_Id_Production"          
                                ,   "Authorize_Transaction_Production" 
                                )
                        |_->    (   AuthorizeNet.Environment.SANDBOX
                                ,   "SANDBOX"
                                ,   "Authorize_Id_Sandbox"          
                                ,   "Authorize_Transaction_Sandbox" 
                                )
                    let! id      = variableAmbienteE idV
                    let! tranKey = variableAmbienteE tranKeyV
                    environmentNameO <- Some environmentName
                    prepareEnvironment environment id tranKey
                }
                interface Reader.Reader<AzureReader> 
                interface Log.Log<string> 
                interface Rsl.Rsl<string>
                interface Asy.Asy
                interface AuthorizeI<AzureReader> with
                    member __.execute controller = 
                        controller.Execute()
                        controller.GetApiResponse()
                    member __.prepare () = if environmentNameO.IsNone then prepararE else rtn ()
                interface ObtenerEstado   .EstadoI<AzureReader> with
                    member __.UltimoEstado                        () = invokeE  (fun _ -> "UltimoEstado"       )  Azure.ultimoEstado                  ()
                    member __.GuardarAliado                     id s = invokeLE (fun _ -> "GuardarAliado"      ) (Azure.guardarAliado id  :_->AR<_>) s
                    member __.GuardarEstado                      n s = invokeLE (fun _ -> "GuardarEstado"      ) (Azure.guardarEstado  n  :_->AR<_>) s
                    member __.ObtenerEstado                       () = invokeE  (fun _ -> "ObtenerEstado"      )  Azure.obtenerEstado                 ()
                    member __.ObtenerAliados                      () = invokeE  (fun _ -> "ObtenerAliados"     )  Azure.obtenerAliados                ()
                    member __.LeerTransacciones                   () = invokeE  (fun _ -> "LeerTransacciones"  )  Azure.obtenerTransacs               ()
                    member __.SalvarTransacciones                 ts = invokeE  (fun _ -> "SalvarTransacciones")  Azure.guardarTransacs               ts
                interface VariableAmbienteI with 
                    member __.getVar v = if settings.ContainsKey v then settings.[v] else failwithf "Variable not found: %s" v
                    member __.CarpetaRaiz() = "."
        
            //and  ReaderLogRsl = inherit Reader.Reader<AzureReader> inherit Log.Log<string> inherit Rsl.Rsl<string>
        
            let run  reader (eff:Eff<_,_>) = 
                eff
                |> Reader.readerHandler reader
                |> Log.consoleLogHandler
                |> Rsl.rslHandler 
                |> Asy.syncHandler
                |> Eff.run<AzureReader,_>
        
            let reader = AzureReader()
        
            let runNow (eff:Eff<_,_>) = 
                eff
                |> Reader.readerHandler reader
                |> Log.consoleLogHandler
                |> Rsl.rslHandler 
                |> Asy.syncHandler
                |> Eff.run<AzureReader,_>
                |> function
                    | Ok    v -> v
                    | Error m -> failwith m
        
        
//#define FSharpStation1564764915205
let inline tee    f v   = f v ; v
let inline  (|>!) v f   = f v ; v
let inline  (>>!) g f   = g >> fun v -> f v ; v

let inline print v = 
    match box v with
    | :? string as s -> printfn "%s" s
    | __             -> printfn "%A" v


(* Rules:

    textStorage: (type, location, path, name)
        - read
        - write?
        - delete
        - create?
        - Properties: time, size?, otras

    binaryStorage(LocalFile, "D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer", "bin", "ProzperServer.dll") 
        <.. FSStationWSCompileDll 
                textStorage(Snippet, ".", "FsRoot/Applications/ProzperServer", "ProzperServer")
                [ CompilationParams ]

    binaryStorage(AzureShare, share, "site/wwwroot/bin", "*")
        <.. Copy binaryStorage(LocalFile, "D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer", "bin", "*")

    textStorage(LocalFile, "D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer", "bin", "ProzperServer.dll") 
        <.. FSStationWSCompileJS
                textStorage(Snippet, ".", "FsRoot/Applications/ProzperServer", "ProzperServer")
                [ CompilationParams ]

    binaryStorage(LocalFile, "D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer", "bin", "ProzperServer.dll") 
        <.. CopiarData
                binaryStorage(LocalFile, "D:\Abe\CIPHERWorkspace\FSharpStation/projects/ProzperServer", "bin", "ProzperServer.dll") 

*)

module Test =
    open FsRoot
    open System
    open System.IO

    type RuleId = RuleId of string

    [< RequireQualifiedAccess >]
    type TargetInfo =
    | FileInfo of name: Option<DateTime * int64>
    | TextInfo of txt:  string

    let localFileData file =
        let  fileInfo = FileInfo file
        if   fileInfo.Exists 
        then Some (fileInfo.LastWriteTimeUtc, fileInfo.Length)
        else None

    type LocalFile  = LocalFile  of name: string                    
    type AzureBlob  = AzureBlob  of name: string * container: string
    type AzureShare = AzureShare of name: string * share    : string
    type NeedAll    = NeedAll    of name: string
    type Snippet    = Snippet    of path: string * isCode   : bool
    type LocalFile  with member this.Name      = match this with LocalFile  name             ->                   name
    type AzureBlob  with member this.Name      = match this with AzureBlob (name, container) -> container + "/" + name
    type AzureShare with member this.Name      = match this with AzureShare(name, share    ) -> share     + "/" + name
    type NeedAll    with member this.Name      = match this with NeedAll    name             ->                   name
    type Snippet    with member this.Name      = match this with Snippet   (name, isCode   ) -> (if isCode then "Code:" else "Content:") + name
    type LocalFile  with member this.GetInfo() = match this with LocalFile  name             -> name |> localFileData                                                                                                                                       |>  TargetInfo.FileInfo |> rtn
    type AzureBlob  with member this.GetInfo() = match this with AzureBlob (name, container) -> name |> ProzperServer.Azure.obtenerPropiedadesBlob    container |>> Option.map (fun props -> props.LastModified.GetValueOrDefault().DateTime, props.Length) |>> TargetInfo.FileInfo
    type AzureShare with member this.GetInfo() = match this with AzureShare(name, share    ) -> name |> ProzperServer.Azure.obtenerPropiedadesArchivo share     |>> Option.map (fun props -> props.LastModified.GetValueOrDefault().DateTime, props.Length) |>> TargetInfo.FileInfo
    type NeedAll    with member this.GetInfo() = match this with NeedAll    name             -> TargetInfo.TextInfo name |> rtn
    type Snippet    with member this.GetInfo() = match this with Snippet   (name, isCode   ) ->
                                                                    if isCode then
                                                                        FSharpStationClient.getModified name |> AsyncResult.map (fun mdf -> mdf, -1L)  
                                                                    else
                                                                        FSharpStationClient.getSnippet  name |> AsyncResult.map (fun snp -> snp.snpModified, int64 snp.snpContent.Length)
                                                                    |> Async.map Result.toOption
                                                                    |> Asy.ofAsync
                                                                    |>> TargetInfo.FileInfo

    let getSnippetTxt snippet = eff {
        match snippet with
        | Snippet(snippetName, multi) ->
        if multi then
            let! codeR      = FSharpStationClient.getCode snippetName |> Asy.ofAsync
            let! code0      = codeR |> Result.mapError (sprintf "%A") |> Rsl.ofResult
            //let! _, code    = code0 |> String.splitInTwoO "<<STARTHTML>>" |> Result.ofOption (fun () -> "<<STARTHTML>> not found" ) |> Rsl.ofResult
            return code0
        else
            let! snippetR   = FSharpStationClient.getSnippet snippetName |> Asy.ofAsync
            let! snippet    = snippetR |> Result.mapError (sprintf "%A") |> Rsl.ofResult
            return snippet.snpContent
    }

    [< RequireQualifiedAccess >]
    type Target =
    | LocalFile  of LocalFile
    | AzureBlob  of AzureBlob  
    | AzureShare of AzureShare 
    | Snippet    of Snippet
    | NeedAll    of NeedAll  
    with    
        member this.Name      =
            match this with 
            | LocalFile  tgt -> tgt.Name
            | AzureBlob  tgt -> tgt.Name
            | AzureShare tgt -> tgt.Name
            | NeedAll    tgt -> tgt.Name
            | Snippet    tgt -> tgt.Name
        member this.GetInfo() = 
            match this with 
            | LocalFile  tgt -> tgt.GetInfo()
            | AzureBlob  tgt -> tgt.GetInfo()
            | AzureShare tgt -> tgt.GetInfo()
            | NeedAll    tgt -> tgt.GetInfo()
            | Snippet    tgt -> tgt.GetInfo()
        member this.SaveTextFO         () =
            match this with
            | LocalFile (LocalFile .LocalFile  name     )-> Some (fun txt -> File.WriteAllText(name, txt) |> rtn )
            | Snippet   (Snippet   .Snippet(path, false))-> Some (fun txt -> FSharpStationClient.actionCall2 "FSharpStation.setSnippetContent" path txt |> Async.map (Result.mapError (sprintf "%A")) |> Asy.ofAsync >>= Rsl.ofResult |>> ignore)
            | _                                          -> None
        member this.SaveFromFileFO     () =
            match this with
            | LocalFile (LocalFile .LocalFile  name     )-> Some (fun fname -> eff {
                                                                let! info = (LocalFile.LocalFile fname).GetInfo()
                                                                match info with TargetInfo.FileInfo(Some _) -> File.Delete name |_-> ()
                                                                return  File.Copy(fname, name)
                                                            })
            | AzureBlob (AzureBlob .AzureBlob (name, cn))-> Some (fun fname -> ProzperServer.Azure.subirBlob    fname cn name )
            | AzureShare(AzureShare.AzureShare(name, sh))-> Some (fun fname -> ProzperServer.Azure.subirArchivo fname sh name )
            | _                                          -> None
        member this.GetTextFO          () =
            match this with
            | LocalFile (LocalFile .LocalFile name      )-> Some (fun () -> File.ReadAllText name    |> rtn)
            | Snippet    snippet                         -> Some (fun () -> getSnippetTxt    snippet       )
            | _                                          -> None
        member this.GetLocalFileNameFO () =
            match this with
            | LocalFile (LocalFile .LocalFile name      )-> Some (fun () -> name |>  rtn )
            | _                                          -> None

    type RuleKey = 
    | File2File of string * string

    type RuleResult =
    | FileCopied
    | FilesSeemEqual
    | UpToDate
    | NothingToDo
    | ErrorResult of string

    type RuleState = {
        dependencies : Set<Target>
        steps        : Set<RuleId>
    }

    type RuleHistory = {
        ruleId       : RuleId
        dependencies : (Target * TargetInfo) []
        steps        : RuleId []
        started      : DateTime
        finished     : DateTime
        result       : RuleResult
    }

    type RuleInformation = 
    | FileCopy of string * string
    | NoInformation

    type Rule<'H> = {
        ruleId           : RuleId
        ruleAction       : unit -> Eff<'H, RuleResult>
        ruleTargets      : Target []
        ruleInformation  : RuleInformation
    } with
        static member Empty = {
            ruleId           = RuleId ""
            ruleAction       = fun () -> rtn UpToDate
            ruleTargets      = [||]
            ruleInformation  = NoInformation
        }

    type IHistoryDB =
        abstract ClearHistory   : unit                 -> unit
        abstract AddRuleHistory : RuleId * RuleHistory -> unit
        abstract TryGetHistory  : RuleId -> RuleHistory option

    let clearHistory   ()      = Reader.ask () |>> (fun (db:#IHistoryDB) -> db.ClearHistory  ()         )
    let addRuleHistory rid his = Reader.ask () |>> (fun (db:#IHistoryDB) -> db.AddRuleHistory(rid, his) )
    let tryGetHistory  rid     = Reader.ask () |>> (fun (db:#IHistoryDB) -> db.TryGetHistory  rid       )
    let getRule        ()      = Reader.ask2() |>> (fun (rule:Rule<_>  ) -> rule                        )

    type IRules<'H> =
        abstract GetRules : unit         -> Rule<'H> seq
        abstract SetRules : Rule<'H> seq -> unit

    let getRules ()  = Reader.ask() |>> (fun (rls:#IRules<_>) -> rls.GetRules ()  )
    let setRules rs  = Reader.ask() |>> (fun (rls:#IRules<_>) -> rls.SetRules rs  )

    module Target =
        open System
        open System.IO
        open ProzperServer

        //let getInfo, resetGetInfo = Memoize.memoizeResetable getInfo_NotMem
        let resetGetInfo () = ()

        let tryFindRule tgt = eff {
            let! rules = getRules()
            return rules |> Seq.tryFind (fun rul -> rul.ruleTargets |> Seq.contains tgt )
        }

    module Rule =
        open FsRoot

        let getDepsSteps()           = State.get() |>> fun (st:RuleState) -> st.dependencies, st.steps
        let setDepsSteps(deps, stps) = State.put { dependencies = deps ; steps = stps } 

        let addDepsSteps deps0 stps0 = eff {
            let! deps, stps = getDepsSteps()
            do!               setDepsSteps(Set deps0 |> Set.union deps, Set stps0 |> Set.union stps)
        }

        let getHistory() : Eff<_, Map<RuleId, RuleHistory>> = State.get()

        let run (rule:Rule<_>) = eff {
            //do!  Log.logf "Running rule %A %A" rule.ruleId rule.ruleInformation
            let  started   = DateTime.Now
            let! preD,preS = getDepsSteps()
            do!              setDepsSteps (Set.empty, Set.empty)
            let! result    = try rule.ruleAction() |> Reader.readerHandler2 rule
                             with e -> ErrorResult e.Message |> rtn
            let! deps,stps = getDepsSteps()
            let  steps     = Set.add rule.ruleId stps
            do!              setDepsSteps(Set.union preD deps, Set.union preS steps )
            let  finished  = DateTime.Now
            let! infs      = deps |> Set.union (Set rule.ruleTargets) |> traverseSeq (fun tgt -> tgt.GetInfo() |>> fun inf -> tgt, inf)
            let  h         = {
                    ruleId       = rule.ruleId
                    dependencies = infs  |> Seq.toArray
                    steps        = steps |> Seq.toArray
                    result       = result
                    started      = started
                    finished     = finished
                }
            do!             addRuleHistory rule.ruleId h
            return h.result
        }

        let checkHistory hisO = eff {
            match hisO with
            | None   -> return false
            | Some h -> let! different =
                            h.dependencies
                            |>  traverseSeq (fun (tgt, info) -> tgt.GetInfo() |>> (<>) info )
                            |>> Seq.exists id
                        if different then return false else
                        let! rids = h.dependencies |>  traverseSeq (fun (tgt, _) -> Target.tryFindRule tgt)
                        return rids |> Seq.choose id |> Seq.exists (fun r -> h.steps |> Seq.contains r.ruleId |> not) |> not
        }

        let runIfNecessary (rule:Rule<_>) = eff {
            let! hisO  = tryGetHistory rule.ruleId
            let! check = checkHistory hisO
            if   check
            then 
                do! addDepsSteps (hisO.Value.dependencies |> Seq.map fst) hisO.Value.steps
                return  UpToDate
            else return! run rule
        }

        let updateTarget tgt = eff {
            let!  ruleO = Target.tryFindRule tgt
            match ruleO with
            | None      -> return  UpToDate
            | Some rule -> return! runIfNecessary rule
        }

        let need tgt = eff {
            do!  addDepsSteps [ tgt ] []
            let! res = updateTarget tgt
            return! tgt.GetInfo()
        }

        let getTarget() = eff {
            let! (rule:Rule<_>) = getRule()
            match Seq.tryHead rule.ruleTargets with
            | None        -> return! Rsl.ofResult (Error (sprintf "Rule has no Target: %A" rule) )
            | Some target -> return target
        }

    module Example =

        let copyFrom source = eff {
            let! target   = Rule.getTarget()
            let! data1    = Rule.need source
            let! data2    = target.GetInfo()
            match data1, data2 with
            | TargetInfo.FileInfo(Some(mod1, len1)), TargetInfo.FileInfo(Some(mod2, len2)) 
                when (len1 = len2 || len1 = -1L || len2 = -1L) && mod2 >= mod1 ->
                do!         Log.logf "Files seem equal: %s = %s" source.Name target.Name
                return      FilesSeemEqual
            |_->
            do!             Log.logf "Copying %s to %s ..." source.Name target.Name
            match source.GetLocalFileNameFO(), source.GetTextFO(), target.SaveFromFileFO(), target.SaveTextFO() with
            | Some getFile, _, Some saveFile, _  -> let! fname = getFile()
                                                    do!          saveFile fname
            | _, Some getText, _, Some saveText  -> let! txt   = getText()
                                                    do!          saveText txt
            | _, Some getText, Some saveFile, _  -> let! txt   = getText()
                                                    let  fname = Path.GetTempFileName()
                                                    do           File.WriteAllText(fname, txt)
                                                    try 
                                                        do!      saveFile fname
                                                    finally
                                                        File.Delete fname
            |_                                   -> failwithf "Cannot copy from %s to %s"  source.Name target.Name
            do              Target.resetGetInfo()
            return          FileCopied
        }

        let createCopyRule (file1:Target) (file2:Target) =
            let rid = RuleId file2.Name
            {
                ruleId            = rid
                ruleInformation   = FileCopy (file1.Name, file2.Name)
                ruleTargets       = [| file2 |]
                ruleAction        = fun () -> copyFrom file1
            }

        let needAllFrom (sources: Target seq) = eff {
            let! target   = Rule.getTarget()
            do!             sources |> traverseSeq Rule.need |>> Seq.iter ignore
            return          NothingToDo
        }

        let createNeedAllRule  (sources: Target seq) (tgt:Target) =
            let rid = RuleId tgt.Name
            {
                ruleId            = rid
                ruleInformation   = NoInformation
                ruleTargets       = [| tgt |]
                ruleAction        = fun () -> needAllFrom sources
            }

        let tgtMain = NeedAll   "Main" |> Target.NeedAll

        open ProzperServer

        let rules() : Eff<'H, Rule<'H> list> = eff {
            let! share     = variableAmbienteE "share"
            let! container = variableAmbienteE "container"
            let  tgta      = Snippet(   "FSI ZONE/pre"            , true     ) |> Target.Snippet
            let  tgt0      = Snippet(   "FSI ZONE/x"              , false    ) |> Target.Snippet
            let  tgt1      = LocalFile  "D:\Abe\CIPHERWorkspace\FSharpStation/src/file1.txt"             |> Target.LocalFile
            let  tgt2      = LocalFile  "D:\Abe\CIPHERWorkspace\FSharpStation/src/file2.txt"             |> Target.LocalFile
            let  tgt3      = AzureShare("site/wwwroot/file3.txt"  , share    ) |> Target.AzureShare 
            let  tgt3b     = AzureBlob ("file3.txt"               , container) |> Target.AzureBlob 
            return [
                createCopyRule       tgt2 tgt3b
                createCopyRule       tgt2 tgt3
                createCopyRule       tgt1 tgt2
                createCopyRule       tgt0 tgt1
                createCopyRule       tgta tgt0
                createNeedAllRule    [ tgt3 ; tgt3b ] tgtMain
            ]
        }

//#r @"D:\Abe\CIPHERWorkspace\FSharpStation/packages/prozper/Newtonsoft.Json/lib/net45/Newtonsoft.Json.dll"
module HandlerEff = 
    open FsRoot
    open Test
    open ProzperServer
    open FSIReader

    type HandlerEff<'rdr> = 
        inherit State.State<RuleState> 
        inherit Log.Log<string> 
        inherit Rsl.Rsl<string>
        inherit Reader.Reader<'rdr> 
        inherit Reader.Reader2<Rule<HandlerEff<'rdr>>>
        inherit Asy.Asy

    let readHistory fname =
        try 
            System.IO.File.ReadAllText fname
            |> Newtonsoft.Json.JsonConvert.DeserializeObject<(RuleId * RuleHistory)[]>
            |> Array.map (fun (rid,rh) -> rid,{ rh with steps = match rh.steps with null -> [||] |_-> rh.steps})
        with e ->
            print e.Message
            [||]

    type TestReader(historyFile:string, ivar:AzureReader) =
        let mutable history  = Map<RuleId, RuleHistory> []
        let mutable rules    : Rule<HandlerEff<TestReader>> list = []

        do  history <- readHistory historyFile |> Map

        interface IHistoryDB with
            member __.ClearHistory  ()            = history <- Map.empty
            member __.AddRuleHistory(rid, his)    = history <- history |> Map.add rid his
                                                    history
                                                    |> Seq.map (fun kv -> kv.Key, kv.Value)
                                                    |> Seq.toArray
                                                    |> Newtonsoft.Json.JsonConvert.SerializeObject
                                                    |> fun txt -> System.IO.File.WriteAllText(historyFile, txt)
            member __.TryGetHistory  rid          = if history |> Map.containsKey rid then Some( history.[rid] ) else None
        interface IRules<HandlerEff<TestReader>> with
            member __.GetRules      ()            = rules        |> Seq.ofList
            member __.SetRules      rls           = rules <- rls |> Seq.toList
        interface FsRoot.ProzperServer.Basico.VariableAmbienteI with
            member __.getVar        var           = (ivar :> VariableAmbienteI) .getVar var
            member __.CarpetaRaiz   ()            = (ivar :> VariableAmbienteI) .CarpetaRaiz ()

        member __.History = history

    let executeRA rdr (monad : Eff<_, 'b>) =
        eff {
            let! rules = Example.rules()
            do!          setRules rules
            let! r     = monad
            do           Target.resetGetInfo()
            return r
        }
        |>   Reader.readerHandler   rdr
        |>   Log.consoleLogHandler
        |>   State.refHandler { dependencies = Set.empty ; steps = Set.empty }
        |>   Rsl.rslHandler
        |>   Asy.asyncHandler
        |>   fun eff -> Eff.run (eff : Eff<HandlerEff<_>,_>)
    let executeA  rdr (monad : Eff<_, 'b>) = async {
        let! vR   = executeRA rdr monad
        return      match vR with
                    | Ok    v ->          v
                    | Error m -> failwith m
    }
    let execute rdr (monad : Eff<_, 'b>) : 'b = executeA rdr monad |> Async.RunSynchronously

    let settingsDes  = [
        "share"     , "prozper0a1d0"
        "container" , "prozperblobs"
        "jsFile"    , "prozperDes.js"
    ]
    let settingsProd = [   
        "share"     , "prozperab74"  
        "container" , "prozperblobs"
        "jsFile"    , "prozperProd.js"
    ]

    let historyFile = @"D:\Abe\CIPHERWorkspace\FSharpStation/src/history.txt"

    let azureReader settings = FsRoot.ProzperServer.FSIReader.AzureReader(moreSettings = Map settings )

    let readerProd() = TestReader(historyFile, azureReader settingsProd)
    let readerDes () = TestReader(historyFile, azureReader settingsDes )

    let mutable lastRdr : TestReader option = None
    let runWithReader rdr =
        lastRdr <- Some rdr
        Example.tgtMain |> Test.Rule.need |> execute rdr |> print

    let history() = readHistory historyFile