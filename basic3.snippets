{"snippets": [{"snpId": {"SnippetId" :"bc0d0abf-9c94-48bb-b46e-92e5d539b172"}, "snpName": "READ ME! ", "snpContent": "/* NO! DON'T READ ME! GO ON DIRECTLY TO THE TUTORIALS BELOW!!!!! */\n\n\n\n- Organize your code in snippets, group them by theme, keep everything in one place, all your projects big and small\n- Develop and refine over time your personal library of functions, create your own project scaffolding\n- Use snippet predecessors to assemble your solution\n- Create one big code infrastructure that can be reused and refined over and over.\n- Code, try, test, compile, run your code\n- Intellisense (for now):\n    - Tooltips (double-click or F2)\n    - Error highlighting\n    - Auto completion (ctrl-space)\n    - Find Definition\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n\n- Run FSI and Run Fable show in the Output pane what is printed out with printfn\n- Run WebSharper printfn's output can be seen in the console. The Output pane shows the compilation messages.\n- Run WebSharper shows in Ws Result pane or in a new browser the html produced by calling the RunNode class.\n\n- Parse F# is necessary when changing the predecessors\n\n- F# Station is intended to be used locally not through the Internet\n- Evaluate F# is disabled when not used locally", "snpParentIdO": null, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b4b48226-deb9-44da-98de-e2bf5b7cd889"}, "snpName": "PENDING", "snpContent": "- Add back skins/Layouts\n- change package placement: remove all absolute references\n- Add . to start suggestions\n- separate parsing from Monaco\n- When calling fsi.exe fails it does not return error to client\n- add auto-scroll for output\n\nCompilation:\n- create or copy .config file\n- Copy FSharp.Core\n- try Fake\n\n- Solve late parsing issue\n- Implement global find\n\n- Save snippets as files\n\n- Auto-compilation of snippets\n- speed up add/remove/move snippets (a good improvement was made by memoizing getParentIdO function)\n\n---------------------------\n- color different current selection\n- Accellerate input (introduce delay to avoid)\n- Solve wrong highlight of errors\n- make Output messages in real time\n- Add dirty flag, refresh protection\n- Add back Snippet properties\n- confirm Snippet deletion\n- Implemented property inheritance with next level |-| (Tie fighter)\n- bug with code not updating\n- capture exceptions and report in Output\n- include Snippet name in messages\n- highlight snippets with errors\n- confirm  dirty  flag before loading file\n- find out how to handle Template placement\n- Linked fileName to Load File\n- check the cache when producing code\n", "snpParentIdO": null, "snpPredIds": [], "snpProperties": [], "snpGeneration": 175}, {"snpId": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpName": "FsRoot", "snpContent": "/// Root namespace for all code\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n", "snpParentIdO": null, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}, "snpName": "", "snpContent": "#if WEBSHARPER\n//#define NOFRAMEWORK --noframework\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n//#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n\n#I @\"..\\packages\\WebSharper\\lib\\net461\"\n#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\ntype on   = WebSharper.UI.Html.on\ntype attr = WebSharper.UI.Html.attr\n#else\n/// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\nmodule WebSharper =\n    type RpcAttribute() =\n        let a = 1\n    type JavaScriptAttribute(translate:bool) =\n        let a = 1\n        new() = JavaScriptAttribute true\n    type InlineAttribute(code:string) =\n        let a = 1\n        new() = InlineAttribute \"\"\n    type DirectAttribute(code:string) =\n        let a = 1\n\nopen WebSharper\n\n#endif", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 215}, {"snpId": {"SnippetId" :"44b60b89-0535-4591-aa79-f910fe6807ad"}, "snpName": "Libraries", "snpContent": "", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpName": "Library", "snpContent": "/// Essentials that can be converted to JavaScript with WebSharper\n[< JavaScript ; AutoOpen >]\nmodule Library =\n    let Error = Result.Error", "snpParentIdO": {"SnippetId" :"44b60b89-0535-4591-aa79-f910fe6807ad"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}, "snpName": "swap  (__)", "snpContent": "let [<Inline>] inline swap f a b = f b a\n\n/// swap: for use with operators: [1..5] |> List.map (__ (/) 2)\nlet [<Inline>] inline __   f a b = f b a\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, "snpName": "tee  (|>!)  (>>!) print", "snpContent": "/// call a function but return the input value\n/// for logging, debugging\n/// use: (5 * 8) |> tee (printfn \"value = %d\") |> doSomethingElse\nlet [<Inline>] inline tee f v = f v ; v\n\n/// tee: call a function but return the input value\n/// for logging, debugging\n/// use: (5 * 8) |!> printfn \"value = %d\" |> doSomethingElse\nlet [<Inline>] inline  (|>!) v f   = f v ; v\nlet [<Inline>] inline  (>>!) g f   = g >> fun v -> f v ; v\n\nlet inline print v = \n    match box v with\n    | :? string as s -> printfn \"%s\" s\n    | __             -> printfn \"%A\" v\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 223}, {"snpId": {"SnippetId" :"beee1304-d287-4b81-841f-9289cb3572c1"}, "snpName": "Log nowStamp", "snpContent": "[< Inline \"(function (n) { return n.getFullYear() + '-' + ('0'+(n.getMonth()+1)).slice(-2) + '-' +  ('0'+n.getDay()).slice(-2) + ' '+('0'+n.getHours()).slice(-2)+ ':'+('0'+n.getMinutes()).slice(-2)+ ':'+('0'+n.getSeconds()).slice(-2)+ ':'+('00'+n.getMilliseconds()).slice(-3) })(new Date(Date.now()))\" >]\nlet nowStamp() = \n    let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n    t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nlet [<Inline>] inline traceT t v = tee (printfn \"%s %s: %A\" (nowStamp()) t) v\nlet [<Inline>] inline trace   v = traceT \"trace\" v\nlet [<Inline>] inline traceI  v = trace          v |> ignore\n\nmodule Log =\n    let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n    let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n    let [<Inline>] inline InA    n f p = async { return! In  n f p }\n    let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n    let [<Inline>] inline InOut  n     = In  n >> Out  n\n    let [<Inline>] inline InOutA n f p = async {\n        let!   r = InA n f  p\n        do         Out n id r |> ignore\n        return r \n      }\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, "snpName": "ResultMessage", "snpContent": "/// Extensible type for error messages, warnings and exceptions\ntype ResultMessage<'M> =\n    | NoMsg\n    | ErrorMsg  of string\n    | Warning   of string\n    | Info      of string\n    | Message   of 'M\n    | ExceptMsg of string * string\n    | RMessages of ResultMessage<'M> []\n    with \n    override msg.ToString() =\n        match msg with\n        | NoMsg          ->  \"\"\n        | ErrorMsg  m    ->  m      |> sprintf \"Error    : %s\"\n        | Warning   m    ->  m      |> sprintf \"Warning  : %s\"\n        | Info      m    ->  m\n        | Message   m    ->  m      |> sprintf \"%O\"\n        | ExceptMsg(m,p) -> (m, p) ||> sprintf \"Exception: %s, %s\"\n        | RMessages ms   ->  ms     |> Seq.filter (function NoMsg -> false |_-> true) |> Seq.map (fun m -> m.ToString()) |> String.concat \"\\n\"\n\nmodule ResultMessage =\n\n    let inline noMsg    msg = msg |> function NoMsg -> true |_-> false\n    let inline exclnoMsg ms = ms |> Seq.filter (noMsg >> not)\n    /// converts Messages to other type of ResultMessage\n    let rec bindMessage f msg = \n        match msg with\n        | NoMsg          ->  NoMsg\n        | Message   m    ->  f m\n        | ErrorMsg  m    ->  ErrorMsg  m\n        | Info      m    ->  Info      m\n        | Warning   m    ->  Warning   m\n        | ExceptMsg(m,p) ->  ExceptMsg(m,p)\n        | RMessages ms   ->  ms     |> Array.map (bindMessage f) |> RMessages\n\n    /// a Message is converted to ErrorMsg\n    let freeMessage  msg = msg |> bindMessage (sprintf \"%O\" >> ErrorMsg)\n    /// a Message is converted to Warning\n    let freeMessageW msg = msg |> bindMessage (sprintf \"%O\" >> Warning )\n    /// a Message is converted to Info\n    let freeMessageI msg = msg |> bindMessage (sprintf \"%O\" >> Info    )\n\n    let rec isInfoF f msg =\n        match msg with\n        | Info      _    ->  true\n        | Message   m    ->  f m\n        | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (isInfoF f)\n        | _              ->  false\n    /// a Message is not considered Info\n    let isInfo  msg = msg |> isInfoF (fun _ -> false)\n    /// a Message is considered Info\n    let isInfoI msg = msg |> isInfoF (fun _ -> true )\n\n    let rec isWarningOrInfoF f msg =\n        match msg with\n        | Warning   _    ->  true\n        | Message   m    ->  f m\n        | RMessages ms   ->  ms |> exclnoMsg |> Seq.forall (fun m -> isWarningOrInfoF f m || isInfoF f m)\n        | _              ->  false\n    /// a Message is not considered a Warning\n    let isWarningOrInfo  msg = msg |> isWarningOrInfoF (fun _ -> false)\n    /// a Message is considered a Warning\n    let isWarningOrInfoW msg = msg |> isWarningOrInfoF (fun _ -> true )\n\n    let rec isFatalF f msg =\n        match msg with\n        | NoMsg\n        | Info      _    \n        | Warning   _    ->  false\n        | Message   m    ->  f m\n        | RMessages ms   ->  ms |> Seq.exists (isFatalF f)\n        | _              ->  true\n        |>! printfn \"%A = %A\" msg\n    /// a Message is considered fatal\n    let isFatal  msg = msg |> isFatalF (fun _ -> true )\n    /// a Message is not considered fatal\n    let isFatalW msg = msg |> isFatalF (fun _ -> false)\n\n    let rec countF f msg =\n        match msg with\n        | NoMsg          ->  0, 0, 0\n        | Info      _    ->  0, 0, 1\n        | Warning   _    ->  0, 1, 0\n        | Message   m    ->  f m\n        | RMessages ms   ->  ms |> exclnoMsg |> Seq.map (countF f) |> Seq.fold (fun (f, w, i) (fm, wm, im) -> f + fm, w + wm, i + im) (0, 0, 0)\n        | _              ->  1, 0, 0\n\n    /// a Message is considered an error\n    let count  msg = msg |> countF (fun _ -> 1, 0, 0)\n    /// a Message is considered a Warning\n    let countW msg = msg |> countF (fun _ -> 0, 1, 0)\n    /// a Message is considered Info\n    let countI msg = msg |> countF (fun _ -> 0, 0, 1)\n    \n    let addMsg a b =\n        match a, b with\n        | NoMsg        , c\n        | c            , NoMsg         ->  c\n        | RMessages mas, RMessages mbs ->  Array.append    mas      mbs   |> RMessages\n        |           ma , RMessages mbs ->  Array.append [| ma |]    mbs   |> RMessages\n        | RMessages mas,           mb  ->  Array.append    mas   [| mb |] |> RMessages\n        |           ma ,           mb  ->               [| ma   ;   mb |] |> RMessages\n\n    let reduceMsgs ms = ms |> Seq.fold addMsg NoMsg\n\n    let summaryF f msg =        \n        match countF f msg with\n        | 0, 0, _\n        | 1, 0, 0\n        | 0, 1, 0 -> \"\"\n        | e, 0, _ -> sprintf \"Errors   : %d\\n\" e\n        | 0, w, _ -> sprintf \"Warnings : %d\\n\" w\n        | e, w, _ -> sprintf \"Errors   : %d, Warnings: %d\\n\" e w\n\n    /// returns a string with a count of errors and warnings, if more than one\n    let summarizedF f msg = summaryF f msg + msg.ToString()\n    /// a Message is considered an error\n    let summarized  msg = msg |> summarizedF (fun _ -> 1, 0, 0)\n    /// a Message is considered a Warning\n    let summarizedW msg = msg |> summarizedF (fun _ -> 0, 1, 0)\n    /// a Message is considered Info\n    let summarizedI msg = msg |> summarizedF (fun _ -> 0, 0, 1)\n    ", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 227}, {"snpId": {"SnippetId" :"045a7205-0f3e-46fe-9b72-87d0a5f84f79"}, "snpName": "Memoize", "snpContent": "module Memoize =\n    /// creates a Dictionary to store memoized values\n    /// returns 3 functions:\n    ///    checkO: ('p->'v option) \n    ///    store : ('p->'v->'v)\n    ///    clear : (unit->unit)\n    [<Inline>]\n    let checkStore() =\n        let cache        = System.Collections.Generic.Dictionary<_, _>()\n        let checkO v     = let mutable res = Unchecked.defaultof<_>\n                           let ok          = cache.TryGetValue(v, &res)\n                           if  ok then Some res else None\n        let store  v res = cache.[v] <- res\n                           res\n        (checkO, store), cache.Clear\n\n\n    /// Memoizes function f using the provided data store\n    /// getStore() returns 2 functions:\n    ///     checkO: ('p->'v option)\n    ///     store : ('p->'v->'v)\n    [< Inline >]\n    let memoizeStore getStore f =\n        let (checkO:'p->'v option), (store:'p->'v->'v) = getStore()\n        fun p -> checkO p |> Option.defaultWith (fun () -> f p |> store p )\n\n\n    /// Memoizes the function f using a Dictionary\n    /// Returns the memoized function and a clear() function\n    /// The dictionary can be reset using the clear() function\n    [< Inline >]\n    let memoizeResetable f =\n        let store, clear = checkStore()\n        memoizeStore (fun () -> store) f\n      , clear\n\n    /// Memoizes the function f using a Dictionary\n    [<Inline>]\n    let memoize f = memoizeResetable f |> fst\n\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 117}, {"snpId": {"SnippetId" :"c99a4630-f3cc-46e1-8977-06ec20d898ea"}, "snpName": "delayed", "snpContent": "/// returns a function that delays its execution\r\n/// runs only once even if multiple calls happen before the delay\r\nlet delayed delay doF =\r\n    let cancellationTokenSourceO = ref None\r\n    fun parm -> \r\n        let asy = async {\r\n            do! Async.Sleep delay\r\n            doF parm\r\n        } \r\n        !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\r\n        cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\r\n        Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\r\n\r\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 156}, {"snpId": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpName": "Monads", "snpContent": "[< AutoOpen >]\nmodule Monads =", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c3a93d4f-7073-4a24-a38b-71e87ad1978f"}, "snpName": "Seq", "snpContent": "module Seq =    \n    let rtn = Seq.singleton\n    let insertO  vSO              = vSO |> Option.map(Seq.map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vSR:Result<_,_>) = vSR |> function | Error m -> rtn (Error m) | Ok v -> Seq.map Ok v\n    let absorbO  vOS              = vOS |> Seq.choose id\n    let absorbR  vOS              = vOS |> Seq.choose (function Ok v -> Some v |_-> None)\n    ", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"33fd1557-50fd-46a5-a431-e0ae117f2903"}, "snpName": "Option", "snpContent": "module Option =\n    open Option\n    \n    let rtn    = Some\n    let iter f = map f >> Option.defaultValue ()\n    \n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertR (vOR:Result<_,_>)              = vOR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let absorbR  vRO                           = vRO |> function Some(Ok v) -> Some v |_-> None\n    ", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"c3a93d4f-7073-4a24-a38b-71e87ad1978f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}, "snpName": "Async", "snpContent": "/// Extensions to Async\nmodule Async =\n    let [< Inline >] inline rtn   v    = async.Return v\n    let [< Inline >] inline bind  f vA = async.Bind(  vA, f)\n    let [< Inline >] inline map   f    = bind (f >> rtn)\n    /// Executes f Synchronously\n    [< Inline \"throw 'iterS cannot be used in JavaScript!'\" >] \n    let inline iterS (f: 'a->unit) = map f >> Async.RunSynchronously\n    /// Executes f Asynchronously\n    let [< Inline >] inline iterA f             = map f >> Async.Start\n    let apply fA vA = async {\n        let! fChild = Async.StartChild fA\n        let! vChild = Async.StartChild vA\n        let! f = fChild\n        let! v = vChild \n        return f v \n    }\n    let sleepThen f milliseconds = async {\n        do! Async.Sleep milliseconds\n        return f()\n    }\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq      f           sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vAO                           = vAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vAR:Result<_,_>)              = vAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"c3a93d4f-7073-4a24-a38b-71e87ad1978f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, "snpName": "Result", "snpContent": "module Result =\n    open Result\n\n    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\n    let rtn                          = Ok\n    let toOption                   r = r   |> function Ok v -> Some v |       _ -> None\n    let defaultWith              f r = r   |> function Ok v ->      v | Error e -> f e\n    let defaultValue             d r = r   |> function Ok v ->      v | Error _ -> d\n    let failIfTrue               m v = if     v then m |> Error  else Ok () \n    let failIfFalse              m v = if not v then m |> Error  else Ok () \n    /// bind version that protects against exceptions\n    let bindP                 f    r = match r with\n                                       | Ok    v -> try   f v\n                                                    with  e -> ExceptMsg (e.Message, e.StackTrace) |> Error\n                                       | Error e ->       e                                        |> Error\n    /// map version that protects against exceptions\n    let inline mapP           f    m = bindP (f >> rtn) m            \n    let iter                  fE f r = r   |> mapP f |> defaultWith fE                                                 : unit\n    let get                        r = r   |>          defaultWith (string >> failwith)\n    let ofOption              f   vO = vO  |> Option.map Ok           |> Option.defaultWith (f >> Error)\n    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> Ok None)\n    let absorbO               f  vOR = vOR |> bindP (ofOption f)\n    let (>>=)                    r f = bind f r\n    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq        sq = traverseSeq id sq\n        \n    \n    type Builder() =\n        member inline this.Return          x       = rtn  x\n        member inline this.ReturnFrom      x       =     (x:Result<_,_>)\n        member        this.Bind           (w , r ) = bindP  r w\n        member inline this.Zero           ()       = rtn ()\n        member inline this.Delay           f       = f\n        member inline this.Combine        (a, b)   = bind b a\n        member inline this.Run             f       = Ok () |> bindP f\n        member this.TryWith   (body, handler     ) = try body() with e -> handler     e\n        member this.TryFinally(body, compensation) = try body() finally   compensation()\n        member this.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))\n                    \n    let result = Builder()\n    \n    module Operators =\n        let inline (|>>) v f   = mapP  f v\n        let inline (>>=) v f   = bindP f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let result = result\n\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"c3a93d4f-7073-4a24-a38b-71e87ad1978f"}], "snpProperties": [], "snpGeneration": 215}, {"snpId": {"SnippetId" :"553ce707-0b71-4948-b990-96f0bf91255d"}, "snpName": "ResultM", "snpContent": "type ResultM<'v, 'm> = ResultM of Option<'v> * ResultMessage<'m>\r\n\r\nlet inline OkM              v    = ResultM (Some v, NoMsg)\r\nlet inline OkMWithMsg       v m  = ResultM(Some v, m)\r\n//let inline OkMWithMsgs      v ms = ms |> ResultMessage.reduceMsgs |> OkMWithMsg v\r\n\r\nlet inline ErrorM             m  = ResultM (None  , m    )\r\n//let inline ErrorMWithMsgs     ms = ms |> ResultMessage.reduceMsgs |> ErrorM\r\nlet (|OkM|ErrorM|)             r = match r with\r\n                                    | ResultM(Some v, m) -> OkM   (v, m)\r\n                                    | ResultM(None  , e) -> ErrorM e\r\nmodule ResultM =\r\n\r\n    type CheckError<'T> = CheckErrorF of ('T -> bool)\r\n    let checkError   () = CheckErrorF (fun _ -> true )\r\n    let checkErrorW  () = CheckErrorF (fun _ -> false)\r\n\r\n    let inline rtn                 v = OkM v\r\n    let inline rtnM                m = OkMWithMsg () m\r\n    let inline rtnr               vR = vR  |> Result.map OkM          |> Result.defaultWith       ErrorM\r\n    let freeMessage                r = r   |> function Ok v -> Ok v   | Error e -> ResultMessage.freeMessage e |> Error\r\n    let inline toResult            r = match r with\r\n                                       | ResultM(Some v, _) -> Ok     v\r\n                                       | ResultM(None  , e) -> Error  e\r\n    let inline toResultD           r = match r with\r\n                                       | ResultM(Some v, m) -> Ok    (v, m)\r\n                                       | ResultM(None  , e) -> Error  e\r\n    let toOption                   r = r   |> function ResultM (v,_) -> v\r\n    let defaultWith              f r = r   |> toResult |> Result.defaultWith   f\r\n    let defaultValue             d r = r   |> toResult |> Result.defaultValue  d\r\n    let map         f  (ResultM (v, m)) = ResultM (v |> Option.map f, m)\r\n    let mapMessage  fM (ResultM (v, m)) = ResultM (v, fM m)\r\n    let bind                  f    r = match r with\r\n                                       | ResultM(Some v, m) -> f v |> mapMessage (ResultMessage.addMsg m)\r\n                                       | ResultM(None  , e) -> ResultM(None  , e)\r\n    /// bind version that protects against exceptions\r\n    let bindP                 f    r = match r with\r\n                                       | ResultM(Some v, m) -> try f v |> mapMessage (ResultMessage.addMsg m)\r\n                                                               with  e -> ExceptMsg (e.Message, e.StackTrace) |> ErrorM\r\n                                       | ResultM(None  , e) -> ResultM(None  , e)\r\n    let bindM                 f    m = rtnM m |> bindP f\r\n\r\n    let check (CheckErrorF k) vR = vR |> function ResultM(Some _, m) when ResultMessage.isFatalF k m -> ErrorM m |_-> vR\r\n\r\n    /// map version that protects against exceptions\r\n    let inline mapP           f    m = bindP (f >> rtn) m\r\n    let iter                  fM f r = r   |> mapP f |> function ResultM(Some (), m) | ResultM(None, m) -> fM m  : unit\r\n    let get                        r = r   |>          defaultWith (string >> failwith)\r\n    let ofOption              f   vO = vO  |> Option.map OkM          |> Option.defaultWith (f >> ErrorM)\r\n    let ofResult                  vR = vR  |> rtnr\r\n    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> OkM None)\r\n    let absorbO               f  vOR = vOR |> bindP (ofOption f)\r\n    let addMsg                  m  r = r |> mapMessage (ResultMessage.addMsg m)\r\n    let failIfFatalMsgF         f  r = r |> function OkM (v, m) when ResultMessage.isFatalF f m -> ErrorM m |_-> r\r\n    let failIfFatalMsg             r = r |> function OkM (v, m) when ResultMessage.isFatal    m -> ErrorM m |_-> r\r\n    let failIfFatalMsgW            r = r |> function OkM (v, m) when ResultMessage.isFatalW   m -> ErrorM m |_-> r\r\n    let (>>=)                    r f = bind f r\r\n    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\r\n                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\r\n    let inline sequenceSeq        sq = traverseSeq id sq\r\n        \r\n    \r\n    type Builder() =\r\n        member inline __.Return          x       = rtn  x\r\n        member inline __.ReturnFrom      x       =     (x:Result<_,_>)\r\n        member inline __.ReturnFrom      x       = rtnM x\r\n        member        __.Bind           (w , r ) = bindP  r w\r\n        member        __.Bind           (w , r ) = bindM  r w\r\n        member inline __.Zero           ()       = rtn ()\r\n        member inline __.Delay           f       = f\r\n        member inline __.Combine        (a, b)   = a |> bind b\r\n        member inline __.Run             f       = OkM () |> bindP f\r\n        member __.TryWith   (body, handler     ) = try body() with e -> handler     e\r\n        member __.TryFinally(body, compensation) = try body() finally   compensation()\r\n        member __.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\r\n        member __.While(guard, body) =\r\n            let rec whileLoop guard body =\r\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\r\n                else rtn   ()\r\n            whileLoop guard body\r\n        member this.For(sequence:seq<_>, body) =\r\n            this.Using(sequence.GetEnumerator(),fun enum -> \r\n                this.While(enum.MoveNext, \r\n                    this.Delay(fun () -> body enum.Current)))\r\n                    \r\n    module Operators =\r\n        let inline (|>>) v f   = mapP  f v\r\n        let inline (>>=) v f   = bindP f v\r\n        let inline (>>>) f g v = f v |>> g\r\n        let inline (>=>) f g v = f v >>= g\r\n        let inline rtn   v     = rtn    v\r\n\r\n[< AutoOpen >]\r\nmodule ResultMAutoOpen =\r\n    open ResultM\r\n    \r\n    let resultM = Builder()\r\n    \r\n\r\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}], "snpProperties": [], "snpGeneration": 227}, {"snpId": {"SnippetId" :"0419185e-976b-415a-a5bc-e992739fdb62"}, "snpName": "Update", "snpContent": "\r\ntype UpdateMonad<'T, 'TState, 'TUpdate> = UM of ('TState -> 'T * 'TUpdate)\r\n\r\nmodule UpdateM =\r\n    let inline unit<    ^U when ^U:(static member Unit   : unit    -> ^U )> ()  = \r\n                               (^U:(static member Unit   : unit    -> ^U )  ()  ) \r\n    let inline combine< ^U when ^U:(static member Combine: ^U * ^U -> ^U )> a  b = \r\n                               (^U:(static member Combine: ^U * ^U -> ^U ) (a, b)) \r\n    let inline apply<'S,^U when ^U:(static member Apply  : 'S * ^U -> 'S )> s  a = \r\n                               (^U:(static member Apply  : ^S * ^U -> ^S ) (s, a)) \r\n\r\n    let inline (++) a b = combine a b\r\n\r\n    let inline rtn v = UM (fun _ -> (v, unit()))\r\n    let inline bind f (UM u1f) =  \r\n        UM (fun s -> \r\n          let (x, u1 ) = u1f s\r\n          let (UM u2f) = f   x\r\n          let (y, u2 ) = u2f (apply s u1)\r\n          (y, u1 ++ u2))\r\n\r\n    let inline map f m = m |> bind (f >> rtn)\r\n\r\n    type ReaderUpdate = NoUpdate\r\n        with\r\n        static member inline Unit()                      = NoUpdate\r\n        static member inline Combine(NoUpdate, NoUpdate) = NoUpdate\r\n        static member inline Apply(s, NoUpdate)          = s\r\n\r\n    let inline read()           = UM (fun s -> s, NoUpdate)\r\n    let inline readRun s (UM f) = f s |> snd\r\n\r\n    type WriterUpdate< ^TLog> = Log of list< ^TLog>\r\n        with\r\n        static member inline Unit()                = Log []\r\n        static member inline Combine(Log a, Log b) = Log(List.append a b)    /// Combines two logs (operation of the monoid)\r\n        static member inline Apply((), _)          = ()                      /// Applying updates to state does not affect the state\r\n    \r\n    let inline write  v = UM (fun s -> (), Log [v] )                      /// Writes the specified value to the log \r\n    let inline writeRun (UM f) = match f () with (v, Log l) -> v, l\r\n\r\n    type StateState<'T> = State of 'T\r\n    \r\n    type StateUpdate<'T> = \r\n      | SetNop\r\n      | Set of 'T \r\n      static member inline Unit()        = SetNop\r\n      static member inline Combine(a, b) = match b with Set _ -> b       | _ -> a\r\n      static member inline Apply  (c, p) = match p with Set n -> State n | _ -> c \r\n\r\n    let inline set    s        = UM (fun _         -> (), Set s  )\r\n    let inline get   ()        = UM (fun (State s) ->  s, SetNop )\r\n    let inline setRun s (UM f) = f (State s) |> snd      \r\n\r\n    type ReaderWriterUpdate< ^TLog> = \r\n      | Log of list< ^TLog>\r\n      static member inline Unit   ()             = Log []\r\n      static member inline Combine(Log a, Log b) = Log(List.append a b)\r\n      static member inline Apply  (s, Log _)     = s\r\n\r\n    let inline readRW       ()       = UM (fun s -> s, Log [ ])\r\n    let inline writeRW      v        = UM (fun s -> s, Log [v])\r\n    let inline readWriteRun s (UM f) = match f s with (v, Log l) -> v, l\r\n\r\n    type UpdateBuilder() = \r\n      member inline x.Return(v) : UpdateMonad<'S, 'U, 'T> = rtn v\r\n      member inline x.Bind(u, f) = bind f u\r\n      member inline x.Zero() = x.Return(())    \r\n      member inline x.Delay(f) = x.Bind(x.Zero(), f)\r\n      member inline x.Combine(c1, c2) = x.Bind(c1, fun () -> c2)\r\n      member inline x.ReturnFrom(m : UpdateMonad<'S, 'P, 'T>) = m\r\n      member inline x.Using(r,f) = UM(fun s -> use rr = r in let (UM g) = f rr in g s)\r\n      //member inline x.For(sq:seq<'V>, f:'V -> UpdateMonad<'S, 'P, unit>) = \r\n      //  let rec loop (en:System.Collections.Generic.IEnumerator<_>) = \r\n      //    if en.MoveNext() then x.Bind(f en.Current, fun _ -> loop en)\r\n      //    else x.Zero()\r\n      //  x.Using(sq.GetEnumerator(), loop)\r\n      //member inline x.While(t, f:unit -> UpdateMonad<'S, 'P, unit>) =\r\n      //  let rec loop () = if t() then x.Bind(f(), loop)\r\n      //                           else x.Zero()\r\n      //  loop()\r\n\r\n[< AutoOpen >]\r\nmodule UpdateMBuilder =\r\n    /// Instance of the computation builder\r\n    /// that defines the update { .. } block\r\n    let update = UpdateM.UpdateBuilder()      \r\n\r\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 227}, {"snpId": {"SnippetId" :"3f5aa563-e468-4d13-a027-8a5ff3a44106"}, "snpName": "ResultU", "snpContent": "\r\n[< AutoOpen >]\r\nmodule ResultUType =\r\n    open UpdateM\r\n\r\n    type UpdRM<'m> = Upd of ResultMessage<'m> with\r\n        static member inline Unit()                = Upd NoMsg\r\n        static member inline Combine(Upd a, Upd b) = Upd (ResultMessage.addMsg a b)\r\n        static member inline Apply  (    c, Upd p) =      ResultMessage.addMsg c p\r\n\r\n    type ResultU<'v, 'm> = UpdateMonad<'v option, ResultMessage<'m>, UpdRM<'m>>\r\n\r\n    let inline OkU                  v   = UM (fun _ -> Some v, Upd NoMsg )             : ResultU<_,_>\r\n    let inline OkUWithMsg           v m = UM (fun _ -> Some v, Upd m     )             : ResultU<_,_>\r\n    let inline ErrorU                 m = UM (fun _ -> None  , Upd m     )             : ResultU<_,_>\r\n    let run (r:ResultU<_,_>)            = match r with UM f -> f NoMsg\r\n    let (|OkU|ErrorU|)                r = match run r with\r\n                                          | Some v, Upd m -> OkU(v, m)\r\n                                          | None  , Upd m -> ErrorU m\r\n\r\nmodule ResultU =\r\n    open UpdateM\r\n\r\n    type CheckError<'T> = CheckErrorF of ('T -> bool)\r\n    let checkError   () = CheckErrorF (fun _ -> true )\r\n    let checkErrorW  () = CheckErrorF (fun _ -> false)\r\n\r\n    let inline getM  ()                = UM (fun s ->  Some s, Upd NoMsg) : ResultU<_,_>\r\n\r\n    let inline run                  r  = run r\r\n    let inline rtn                  v  = OkU        v\r\n    let inline rtnM                 m  = OkUWithMsg () m\r\n    let inline rtnr                vR  = vR |> Result.map OkU |> Result.defaultWith ErrorU\r\n    let mapMessage fM (r:ResultU<_,_>) = UM(fun _ -> \r\n                                            let (UM rf) = r\r\n                                            match rf NoMsg with v, (Upd m) -> v, fM m |> Upd ) : ResultU<_,_>\r\n    let freeMessage                  r = r |> mapMessage ResultMessage.freeMessage\r\n    let inline toResult              r = match r with\r\n                                         | OkU   (v, _) -> Ok     v\r\n                                         | ErrorU    m  -> Error  m\r\n    let inline toResultD             r = match r with\r\n                                         | OkU   (v, m) -> Ok (v, m)\r\n                                         | ErrorU    m  -> Error  m\r\n    let toOption                     r = r |> run |> fst\r\n    let defaultWith                f r = r |> toResult |> Result.defaultWith   f\r\n    let defaultValue               d r = r |> toResult |> Result.defaultValue  d\r\n    let bind (f:_->ResultU<_,_>) (r:ResultU<_,_>) : ResultU<_,_> = UM (fun s -> \r\n                                            let   (UM u1f) = r\r\n                                            match u1f s with\r\n                                            | None  , u1 -> None, u1\r\n                                            | Some v, u1 -> \r\n                                            let   (UM u2f) = f v\r\n                                            let   (y, u2 ) = u2f (apply s u1)\r\n                                            (y, u1 ++ u2)\r\n                                         )                                              \r\n\r\n    let bindM                 f    m = rtnM m |> bind f\r\n\r\n    let checkUF                    k = UM ( fun m -> if ResultMessage.isFatalF k m then (None, Upd NoMsg) else (Some (), Upd NoMsg) ) : ResultU<_,_>\r\n    let checkU                       = UM ( fun m -> if ResultMessage.isFatal    m then (None, Upd NoMsg) else (Some (), Upd NoMsg) ) : ResultU<_,_>\r\n    let checkUW                      = UM ( fun m -> if ResultMessage.isFatalW   m then (None, Upd NoMsg) else (Some (), Upd NoMsg) ) : ResultU<_,_>\r\n    let inline map            f    m = bind (f >> rtn) m\r\n    let iter                  fM f r = r   |> map f |> function OkU((), m) | ErrorU m -> fM m  : unit\r\n    let get                        r = r   |>          defaultWith (string >> failwith)\r\n    let ofOption              f   vO = vO  |> Option.map OkU          |> Option.defaultWith (f >> ErrorU)\r\n    let ofResult                  vR = vR  |> rtnr\r\n    let insertO                  vRO = vRO |> Option.map(map Some)    |> Option.defaultWith(fun () -> OkU None)\r\n    let absorbO               f  vOR = vOR |> bind (ofOption f)\r\n    let addMsg                  m  r = r |> mapMessage (ResultMessage.addMsg m)\r\n    //let failIfFatalMsgF         f  r = r |> function OkU (v, m) when ResultMessage.isFatalF f m -> ErrorU m |_-> r\r\n    //let failIfFatalMsg             r = r |> function OkU (v, m) when ResultMessage.isFatal    m -> ErrorU m |_-> r\r\n    //let failIfFatalMsgW            r = r |> function OkU (v, m) when ResultMessage.isFatalW   m -> ErrorU m |_-> r\r\n    let (>>=)                    r f = bind f r\r\n    let rec    traverseSeq    f   sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\r\n                                       Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\r\n    let inline sequenceSeq        sq = traverseSeq id sq\r\n        \r\n    \r\n    type Builder() =\r\n        member inline __.Return          x       = rtn  x\r\n        member inline __.ReturnFrom      x       =     (x:Result<_,_>)\r\n        member inline __.ReturnFrom      x       = rtnM x\r\n        member        __.Bind           (w , r ) = bind  r w\r\n        member        __.Bind           (w , r ) = bindM  r w\r\n        member inline __.Zero           ()       = rtn ()\r\n        member inline __.Delay           f       = f\r\n        member inline __.Combine        (a, b)   = a |> bind b\r\n        member inline __.Run             f       = OkU () |> bind f\r\n        member __.TryWith   (body, handler     ) = try body() with e -> handler     e\r\n        member __.TryFinally(body, compensation) = try body() finally   compensation()\r\n        member __.Using     (disposable, body  ) = using (disposable:#System.IDisposable) body\r\n        member __.While(guard, body) =\r\n            let rec whileLoop guard body =\r\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\r\n                else rtn   ()\r\n            whileLoop guard body\r\n        member this.For(sequence:seq<_>, body) =\r\n            this.Using(sequence.GetEnumerator(),fun enum -> \r\n                this.While(enum.MoveNext, \r\n                    this.Delay(fun () -> body enum.Current)))\r\n                    \r\n    module Operators =\r\n        let inline (|>>) v f   = map  f v\r\n        let inline (>>=) v f   = bind f v\r\n        let inline (>>>) f g v = f v |>> g\r\n        let inline (>=>) f g v = f v >>= g\r\n        let inline rtn   v     = rtn    v\r\n\r\n[< AutoOpen >]\r\nmodule ResultMAutoOpen =\r\n    open ResultU\r\n    \r\n    let resultU = Builder()\r\n    \r\n\r\n", "snpParentIdO": {"SnippetId" :"0419185e-976b-415a-a5bc-e992739fdb62"}, "snpPredIds": [{"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}], "snpProperties": [], "snpGeneration": 229}, {"snpId": {"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, "snpName": "AsyncResult", "snpContent": "type AsyncResult<'v, 'm> = Async<Result<'v, 'm>>\n\n/// A computation expression to build an Async<Result<'ok, 'error>> value\nmodule AsyncResult =\n    let mapError fE v  = v |> Async.map (Result.mapError fE)\n    let freeMessage v  = v |> Async.map  Result.freeMessage\n\n    let rtn        v   = async.Return(Ok v  )\n    let rtnR       vR  = async.Return    vR\n    let iterS fE f vRA = Async.iterS (Result.iter fE f) vRA\n    let iterA fE f vRA = Async.iterA (Result.iter fE f) vRA\n    let bind  fRA  vRA = async { \n        let! vR       = vRA\n        return! match   vR with\n                | Ok    v -> fRA v\n                | Error m -> async { return Error m }\n    }\n    let bindP (fRA:'a -> Async<Result<'b,ResultMessage<'c>>>)  (vRA: Async<Result<'a,ResultMessage<'c>>>) : Async<Result<'b,ResultMessage<'c>>>= async {\n        try \n            let!  vR = vRA\n            match vR with\n            | Ok    v -> return! fRA   v\n            | Error m -> return  Error m\n        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> Error\n    }\n    let inline map  f m = bind  (f >> rtn) m            \n    let inline mapP f m = bindP (f >> rtn) m            \n    let rec whileLoop cond fRA =\n        if   cond () \n        then fRA  () |> bind (fun () -> whileLoop cond fRA)\n        else rtn  ()\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let absorbR   vRRA                         = vRRA |> Async.map (Result.bindP   id)\n    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\n\ntype AsyncResultBuilder() =\n    member __.ReturnFrom vRA        : Async<Result<'v  , 'm>> =                       vRA\n    member __.ReturnFrom vR         : Async<Result<'v  , 'm>> = AsyncResult.rtnR      vR\n    member __.Return     v          : Async<Result<'v  , 'm>> = AsyncResult.rtn       v  \n    member __.Zero       ()         : Async<Result<unit, 'm>> = AsyncResult.rtn       () \n    member __.Bind      (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n    member __.Bind      (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n    member __.Combine   (vRA,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA  vRA\n    member __.Combine   (vR ,  fRA) : Async<Result<'b  , 'm>> = AsyncResult.bind fRA (vR  |> AsyncResult.rtnR)\n    member __.Delay            fRA                            = fRA\n    member __.Run              fRA                            = fRA ()\n    member __.TryWith   (fRA , hnd) : Async<Result<'a  , 'm>> = async { return! try fRA() with e -> hnd e  }\n    member __.TryFinally(fRA , fn ) : Async<Result<'a  , 'm>> = async { return! try fRA() finally   fn  () }\n    member __.Using(resource , fRA) : Async<Result<'a  , 'm>> = async.Using(resource,       fRA)\n    member __.While   (guard , fRA) : Async<Result<unit, 'a>> = AsyncResult.whileLoop guard fRA \n    member th.For  (s: 'a seq, fRA) : Async<Result<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                    th.While(enum.MoveNext,\n                                                                      th.Delay(fun () -> fRA enum.Current)))\nlet asyncResult = AsyncResultBuilder()\n\ntype AsyncResultBuilderP() =\n    member __.ReturnFrom vRA        : Async<Result<'v  , ResultMessage<_>>> =                       vRA\n    member __.ReturnFrom vR         : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtnR      vR\n    member __.Return     v          : Async<Result<'v  , ResultMessage<_>>> = AsyncResult.rtn       v  \n    member __.Zero       ()         : Async<Result<unit, ResultMessage<_>>> = AsyncResult.rtn       () \n    member __.Bind      (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n    member __.Bind      (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n    member __.Combine   (vRA,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA  vRA\n    member __.Combine   (vR ,  fRA) : Async<Result<'b  , ResultMessage<_>>> = AsyncResult.bindP fRA (vR  |> AsyncResult.rtnR)\n    member __.Delay            fRA                                          = fRA\n    member __.Run              fRA                                          = AsyncResult.rtn () |> AsyncResult.bindP fRA\n    member __.TryWith   (fRA , hnd) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() with e -> hnd e  }\n    member __.TryFinally(fRA , fn ) : Async<Result<'a  , ResultMessage<_>>> = async { return! try fRA() finally   fn  () }\n    member __.Using(resource , fRA) : Async<Result<'a  , ResultMessage<_>>> = async.Using(resource,       fRA)\n    member __.While   (guard , fRA) : Async<Result<unit, ResultMessage<_>>> = AsyncResult.whileLoop guard fRA \n    member th.For  (s: 'a seq, fRA) : Async<Result<unit, ResultMessage<_>>> = th.Using(s.GetEnumerator (), fun enum ->\n                                                                              th.While(enum.MoveNext,\n                                                                                th.Delay(fun () -> fRA enum.Current)))\nlet asyncResultP = AsyncResultBuilderP()\n\n[<AutoOpen>]\nmodule Extensions =      \n    // Having Async<_> members as extensions gives them lower priority in\n    // overload resolution between Async<_> and Async<Result<_,_>>.\n    type AsyncResultBuilder with\n      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, 'b>> =                       Async.map Ok vA\n      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, 'c>> = AsyncResult.bind fRA (Async.map Ok vA)\n\n    type AsyncResultBuilderP with\n      member __.ReturnFrom (vA: Async<'a>     ) : Async<Result<'a, ResultMessage<_>>> =                        Async.map Ok vA\n      member __.Bind       (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP  fRA (Async.map Ok vA)\n      member __.Combine    (vA: Async<'a>, fRA) : Async<Result<'b, ResultMessage<_>>> = AsyncResult.bindP fRA (Async.map Ok vA)\n\n\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"ef65b9ea-9bcc-483f-833e-803e14f0194e"}, "snpName": "AsyncResultM", "snpContent": "type AsyncResultM<'v, 'm> = Async<ResultM<'v, 'm>>\r\n\r\n/// A computation expression to build an Async<Result<'ok, 'error>> value\r\nmodule AsyncResultM =\r\n    let mapError fE v  = v |> Async.map (ResultM.mapMessage fE)\r\n    let freeMessage v  = v |> Async.map  ResultM.freeMessage\r\n\r\n    let rtn         v   = async.Return(OkM v  )\r\n    let rtnr        vR  = async.Return(ResultM.rtnr vR)\r\n    let rtnR        vR  = async.Return    vR\r\n    let rtnM        vM  = async.Return(ResultM.rtnM vM)\r\n    let rtnrA       vrA = vrA |> Async.map    ResultM.ofResult\r\n    let iterS  fE f vRA = Async.iterS (ResultM.iter fE f) vRA\r\n    let iterA  fE f vRA = Async.iterA (ResultM.iter fE f) vRA\r\n    let iterpS    f vRA = vRA |> iterS (ResultMessage.summarized >> print) f\r\n    let iterpA    f vRA = vRA |> iterA (ResultMessage.summarized >> print) f\r\n    let bind  (fRA:'a -> Async<ResultM<'b,'c>>)  (vRA: Async<ResultM<'a,'c>>) : Async<ResultM<'b,'c>>= async {\r\n        try \r\n            let!  vR = vRA\r\n            match vR with\r\n            | OkM   (v, m) -> return! fRA   v |> Async.map (ResultM.addMsg m)\r\n            | ErrorM    m  -> return  ErrorM m\r\n        with  e -> return  ExceptMsg (e.Message, e.StackTrace) |> ErrorM\r\n    }\r\n    let inline bindr  f a  = rtnr   a |> bind f : AsyncResultM<_,_>\r\n    let inline bindM  f a  = rtnM   a |> bind f : AsyncResultM<_,_>\r\n    let inline bindrA f a  = rtnrA  a |> bind f : AsyncResultM<_,_>\r\n    let inline bindR  f a  = rtnR   a |> bind f : AsyncResultM<_,_>\r\n    let inline map    f m = bind  (f >> rtn) m            \r\n    let rec whileLoop cond fRA =\r\n        if   cond () \r\n        then fRA  () |> bind (fun () -> whileLoop cond fRA)\r\n        else rtn  ()\r\n    let (>>=)                              v f = bind f v\r\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\r\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\r\n    let inline sequenceSeq                  sq = traverseSeq id sq\r\n    let insertO   vRAO                         = vRAO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\r\n    let insertR ( vRAR:Result<_,_>)            = vRAR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\r\n    let absorbR   vRRA                         = vRRA |> Async.map (Result.bindP   id)\r\n    let absorbO f vORA                         = vORA |> Async.map (Result.absorbO  f)\r\n    type AsyncResultMBuilder() =\r\n        member __.ReturnFrom vRA        : Async<ResultM<'v  , 'm>> =           vRA\r\n        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnr      vR\r\n        member __.ReturnFrom vR         : Async<ResultM<unit, 'm>> = rtnM      vR\r\n        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnR      vR\r\n        member __.ReturnFrom vR         : Async<ResultM<'v  , 'm>> = rtnrA     vR\r\n        member __.Return     v          : Async<ResultM<'v  , 'm>> = rtn       v  \r\n        member __.Zero       ()         : Async<ResultM<unit, 'm>> = rtn       () \r\n        member __.Bind      (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\r\n        member __.Bind       (w , r )                              = bindr   r w\r\n        member __.Bind       (w , r )                              = bindM   r w\r\n        member __.Bind       (w , r )                              = bindR   r w\r\n        member __.Bind       (w , r )                              = bindrA  r w\r\n        member __.Combine   (vRA,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA  vRA\r\n        member __.Combine   (vR ,  fRA) : Async<ResultM<'b  , 'm>> = bind fRA (vR  |> rtnR)\r\n        member __.Delay            fRA                             = fRA\r\n        member __.Run              fRA                             = fRA ()\r\n        member __.TryWith   (fRA , hnd) : Async<ResultM<'a  , 'm>> = async { return! try fRA() with e -> hnd e  }\r\n        member __.TryFinally(fRA , fn ) : Async<ResultM<'a  , 'm>> = async { return! try fRA() finally   fn  () }\r\n        member __.Using(resource , fRA) : Async<ResultM<'a  , 'm>> = async.Using(resource,       fRA)\r\n        member __.While   (guard , fRA) : Async<ResultM<unit, 'a>> = whileLoop guard fRA \r\n        member th.For  (s: 'a seq, fRA) : Async<ResultM<unit, 'b>> = th.Using(s.GetEnumerator (), fun enum ->\r\n                                                                        th.While(enum.MoveNext,\r\n                                                                            th.Delay(fun () -> fRA enum.Current)))\r\n\r\n[<AutoOpen>]\r\nmodule AsyncResultMAutoOpen =\r\n    open AsyncResultM\r\n\r\n    let asyncResultM = AsyncResultMBuilder()\r\n\r\n    // Having Async<_> members as extensions gives them lower priority in\r\n    // overload resolution between Async<_> and Async<Result<_,_>>.\r\n    type AsyncResultMBuilder with\r\n    member __.ReturnFrom (vA: Async<_>     ) : Async<ResultM<_,_>> =           Async.map OkM vA\r\n    member __.Bind       (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\r\n    member __.Combine    (vA: Async<_>, fRA) : Async<ResultM<_,_>> = bind fRA (Async.map OkM vA)\r\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [{"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}, {"SnippetId" :"553ce707-0b71-4948-b990-96f0bf91255d"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpName": "ReaderMonads", "snpContent": "[< AutoOpen >]\nmodule ReaderMonads =\n\n", "snpParentIdO": {"SnippetId" :"502dda4b-f486-419d-8ab4-35173ee50cf6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3173b988-9ac9-49c1-b5d1-137bee4d947f"}, "snpName": "ReaderMBasic", "snpContent": "\ntype ReaderMBasic<'T, 'R, 'M> = ReaderMB of ('R -> 'T)\n\n/// There are several versions of the Reader Monads\n/// All have at least 2 type parameters: \n/// - the monad type \n/// - the Resource type that is passed when run\n/// - the Message or Error type for those that involve Result\n/// For ReaderMBasic and ReaderMAsync the third is a dummy type so that all have 3 parameters\n/// The purpose of this is to be able to develop generic code that can use any of the 4 Reader types:\n/// ReaderMBasic, ReaderMAsync, ReaderMResult, ReaderMAsyncResult.\n/// just by referencing the corresponding module\n\nmodule ReaderMBasic =\n    let inline wrap                         f  = ReaderMB f\n    let inline getFun                       f  =  f |> function ReaderMB g -> g\n    let inline ofFun                        f  =  f                                           |> wrap\n    let inline rtn                          a  = (fun _ -> a                                ) |> wrap\n    let inline bind                       f a  = (fun m -> getFun a m |> f   |> getFun <| m ) |> wrap\n    let inline delayRun        f               = (fun m ->               f() |> getFun <| m ) |> wrap\n    let inline map             f            m  = bind (f >> rtn) m                             : ReaderMBasic<_,_,_>\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                     : ReaderMBasic<_,_,_>\n    let inline run          rsrc             a = getFun a (rsrc: 'R)                           :             'T\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vvO                           = vvO  |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vvR:Result<_,_>)              = vvR  |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst (fst, vRm)                   = vRm  |> map (fun v -> fst, v)\n    let insertSnd (vRm, snd)                   = vRm  |> map (fun v -> v, snd)\n    let absorbR (vvRm)                         = vvRm |> map  Result.get\n    let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\n    let inline iter                f t         = run t >> (f: _ -> unit)\n    let memoizeRm               getCache fRm p = (fun r -> \n                                                     let checkO, store = getCache r\n                                                     checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                                                 ) |> wrap\n\n    type Builder() =\n        member inline this.Return      x                  = rtn  x\n        member inline this.ReturnFrom  x                  =     (x:ReaderMBasic<_,_,_>)\n        member        this.Bind       (w , r )            = bind   r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = (fun r -> try body() |> run r with e -> handler     e            ) |> wrap\n        member this.TryFinally(body, compensation) = (fun r -> try body() |> run r finally   compensation()           ) |> wrap \n        member this.Using     (disposable, body  ) = (fun r -> using (disposable:#System.IDisposable) (body >> run r) ) |> wrap\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))\n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (<*>) f v   = apply f v\n        let inline (|>>) v f   = map   f v\n        let inline (>>=) v f   = bind  f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMBasic<'T, 'R, 'M>\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"62fab179-4e0c-4bef-b0b7-e0baf0ff1971"}, "snpName": "ReaderMAsync", "snpContent": "type ReaderMAsync<'T, 'R, 'M> = ReaderMA of ('R->Async<'T>)\n\nmodule ReaderMAsync =\n    let inline wrap                         f  = ReaderMA f\n    let inline getFun                       f  =  f |> function ReaderMA g -> g\n    let inline ofFun                        f  = (f >> Async.rtn                                              ) |> wrap\n    let inline rtn                          a  = (fun _ -> a |> Async.rtn                                     ) |> wrap\n    let inline rtnA                         r  = (fun _ -> r                                                  ) |> wrap\n    let inline bind            f            a  = (fun m -> getFun a m |> Async.bind (fun v -> getFun (f v) m) ) |> wrap\n    let inline bindA           f            a  = rtnA  a |> bind f                                               : ReaderMAsync<_,_,_>\n    let inline delayRun        f               = (fun m -> f() |> getFun <| m                                 ) |> wrap\n    let inline map             f            m  = bind (f >> rtn) m                                               : ReaderMAsync<_,_,_>\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                                       : ReaderMAsync<_,_,_>\n    let inline getAsync                     a  = (fun m -> getFun a m |> Async.rtn)                  |> ReaderMA : ReaderMAsync<Async<_>,_,_>\n    let inline getAsync2                    a  = map Async.rtn a                                                 : ReaderMAsync<Async<_>,_,_>\n    let inline run          rsrc            a  = getFun a rsrc                                                   :        Async<_>\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vvO                           = vvO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vvR:Result<_,_>)              = vvR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst (fst, vRm)                   = vRm |> map (fun v -> fst, v)\n    let insertSnd (vRm, snd)                   = vRm |> map (fun v -> v, snd)\n    let absorbR (vvRm)                         = vvRm |> map  Result.get\n    let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\n    let inline iterA               f t         = run t >> Async.iterA f\n    let inline iterS               f t         = run t >> Async.iterS f\n    let memoizeRm               getCache fRm p = (fun r -> \n                                                     let checkO, store = getCache r\n                                                     checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                                                 ) |> wrap\n\n    type Builder() =\n        member inline this.Return      x                  = rtn   x\n        member inline this.ReturnFrom  x                  =      (x:ReaderMAsync<_,_,_>)\n        member inline this.ReturnFrom  x                  = rtnA  x\n        member        this.Bind       (w , r )            = bind   r w\n        member        this.Bind       (w , r )            = bindA  r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = (fun r -> async.TryWith   (body() |> run r,   handler                ) ) |> wrap\n        member this.TryFinally(body, compensation) = (fun r -> async.TryFinally(body() |> run r,   compensation           ) ) |> wrap\n        member this.Using     (disposable, body  ) = (fun r -> async.Using((disposable:#System.IDisposable), body >> run r) ) |> wrap\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))\n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (<*>) f v   = apply f v\n        let inline (|>>) v f   = map   f v\n        let inline (>>=) v f   = bind  f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMAsync<'T, 'R, 'M>\n        ", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"3173b988-9ac9-49c1-b5d1-137bee4d947f"}, {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}, "snpName": "ReaderMResult", "snpContent": "type ReaderMResult<'T, 'R, 'M> = ReaderMR of ('R -> Result<'T, 'M>)\n\nmodule ReaderMResult =\n    let inline wrap                         f  = ReaderMR f\n    let inline getFun                       f  =  f |> function ReaderMR g -> g\n    let inline ofFun                        f  = (f >> Result.rtn                                              ) |> wrap\n    let inline rtn                          a  = (fun _ -> a |> Result.rtn                                     ) |> wrap\n    let inline rtnR                         r  = (fun _ -> r                                                   ) |> wrap\n    let inline bind            f            a  = (fun m -> getFun a m |> Result.bind (fun v -> getFun (f v) m) ) |> wrap\n    let inline bindR           f            a  = rtnR a |> bind f                                                 : ReaderMResult<_,_,_>\n    let inline delayRun        f               = (fun m ->  f() |> getFun <| m                                 ) |> wrap\n    let inline map             f            m  = bind (f >> rtn) m                                                : ReaderMResult<_,_,_>\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                                        : ReaderMResult<_,_,_>\n    let inline getResult                    a  = (fun m -> getFun a m |> Result.Ok )                 |> ReaderMR  : ReaderMResult<Result<_,'m>,_,'m>\n    let inline getResult2                   a  = map Result.Ok a                                                  : ReaderMResult<Result<_,'m>,_,'m>\n    let inline run          rsrc             a = getFun a rsrc                                                    :        Result<_,_>\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\n    let insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\n    let absorbR (vvRm)                         = vvRm  |> bind rtnR\n    let absorbO f vORm                         = vORm  |> map (Result.ofOption  f) |> absorbR\n    let mapError                          fE v = wrap(v |> getFun >> (Result.mapError fE))\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\n    let inline iter             fE f t       a = a     |> run t |> Result.iter fE f\n    //let memoizeRm               getCache fRm p = (fun r -> \n    //                                                 let (checkO:'p->'v option), (store:'p->'v->'v), (clear:unit->unit) = getCache r\n    //                                                 checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n    //                                             ) |> wrap\n    let memoizeRm               getStore fRm p = (fun (r:'r) ->\n                                                     let (checkO:'p->'v option), (store:'p->'v->'v) = getStore r\n                                                     checkO p |> Option.map rtn |> Option.defaultWith (fun () -> fRm p |> map (store p) )\n                                                     |> run r\n                                                 ) |> wrap \n\n    type Builder() =\n        member inline this.Return      x                  = rtn   x\n        member inline this.ReturnFrom  x                  =      (x:ReaderMResult<_,_,_>)\n        member inline this.ReturnFrom  x                  = rtnR  x\n        member        this.Bind       (w , r )            = bind   r w\n        //member        this.Bind       (w , r )            = bindR  r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = (fun r -> try body() |> run r with e -> handler     e            ) |> wrap\n        member this.TryFinally(body, compensation) = (fun r -> try body() |> run r finally   compensation()           ) |> wrap\n        member this.Using     (disposable, body  ) = (fun r -> using (disposable:#System.IDisposable) (body >> run r) ) |> wrap\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))\n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (<*>) f v   = apply f v\n        let inline (|>>) v f   = map   f v\n        let inline (>>=) v f   = bind  f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMResult<'T, 'R, 'M>\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"3173b988-9ac9-49c1-b5d1-137bee4d947f"}, {"SnippetId" :"553ce707-0b71-4948-b990-96f0bf91255d"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"385e6acf-5509-4b7a-9dc3-d85d8efd5ccf"}, "snpName": "ReaderMResultM", "snpContent": "type ReaderMResultM<'T, 'R, 'M> = ReaderMRM of ('R -> ResultM<'T, 'M>)\r\n\r\nmodule ReaderMResultM =\r\n    let inline wrap                         f  = ReaderMRM f\r\n    let inline getFun                       f  =  f |> function ReaderMRM g -> g\r\n    let inline ofFun                        f  = (f >> ResultM.rtn                                              ) |> wrap\r\n    let inline rtn                          a  = (fun _ -> a |> ResultM.rtn                                     ) |> wrap\r\n    let inline rtnR                         r  = (fun _ -> r                                                    ) |> wrap\r\n    let inline bind            f            a  = (fun m -> getFun a m |> ResultM.bind (fun v -> getFun (f v) m) ) |> wrap\r\n    let inline bindR           f            a  = rtnR a |> bind f                                                 : ReaderMResultM<_,_,_>\r\n    let inline delayRun        f               = (fun m ->  f() |> getFun <| m                                  ) |> wrap\r\n    let inline map             f            m  = bind (f >> rtn) m                                                : ReaderMResultM<_,_,_>\r\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                                        : ReaderMResultM<_,_,_>\r\n    let inline getResult                    a  = (fun m -> getFun a m |> OkM )                            |> wrap : ReaderMResultM<ResultM<_,'m>,_,'m>\r\n    let inline getResult2                   a  = map OkM a                                                        : ReaderMResultM<ResultM<_,'m>,_,'m>\r\n    let inline run          rsrc             a = getFun a rsrc                                                    :        ResultM<_,_>\r\n    let (>>=)                              v f = bind f v\r\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\r\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\r\n    let inline sequenceSeq                  sq = traverseSeq id sq\r\n    let insertO  vvO                           = vvO   |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\r\n    let insertR (vvR:Result<_,_>)              = vvR   |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\r\n    let insertFst (fst, vRm)                   = vRm   |> map (fun v -> fst, v)\r\n    let insertSnd (vRm, snd)                   = vRm   |> map (fun v -> v, snd)\r\n    let absorbR (vvRm)                         = vvRm  |> bind rtnR\r\n    let absorbO f vORm                         = vORm  |> map (ResultM.ofOption  f) |> absorbR\r\n    let mapMessage                        fE v = wrap(v |> getFun >> (ResultM.mapMessage fE))\r\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\r\n    let inline iter             fE f t       a = a     |> run t |> ResultM.iter fE f\r\n    //let memoizeRm               getCache fRm p = (fun r -> \r\n    //                                                 let (checkO:'p->'v option), (store:'p->'v->'v), (clear:unit->unit) = getCache r\r\n    //                                                 checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\r\n    //                                             ) |> wrap\r\n    let memoizeRm               getStore fRm p = (fun (r:'r) ->\r\n                                                     let (checkO:'p->'v option), (store:'p->'v->'v) = getStore r\r\n                                                     checkO p |> Option.map rtn |> Option.defaultWith (fun () -> fRm p |> map (store p) )\r\n                                                     |> run r\r\n                                                 ) |> wrap \r\n\r\n    type Builder() =\r\n        member inline this.Return      x                  = rtn   x\r\n        member inline this.ReturnFrom  x                  =      (x:ReaderMResultM<_,_,_>)\r\n        member inline this.ReturnFrom  x                  = rtnR  x\r\n        member        this.Bind       (w , r )            = bind   r w\r\n        //member        this.Bind       (w , r )            = bindR  r w\r\n        member inline this.Zero       ()                  = rtn ()\r\n        member inline this.Delay       f                  = f\r\n        member inline this.Combine    (a, b)              = bind b a\r\n        member inline this.Run         f                  = delayRun f\r\n        member this.While(guard, body) =\r\n            let rec whileLoop guard body =\r\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\r\n                else rtn   ()\r\n            whileLoop guard body\r\n        member this.TryWith   (body, handler     ) = (fun r -> try body() |> run r with e -> handler     e            ) |> wrap\r\n        member this.TryFinally(body, compensation) = (fun r -> try body() |> run r finally   compensation()           ) |> wrap\r\n        member this.Using     (disposable, body  ) = (fun r -> using (disposable:#System.IDisposable) (body >> run r) ) |> wrap\r\n        member this.For(sequence:seq<_>, body) =\r\n            this.Using(sequence.GetEnumerator(),fun enum -> \r\n                this.While(enum.MoveNext, \r\n                    this.Delay(fun () -> body enum.Current)))\r\n\r\n    let reader = Builder()\r\n    \r\n    module Operators =\r\n        let inline (<*>) f v   = apply f v\r\n        let inline (|>>) v f   = map   f v\r\n        let inline (>>=) v f   = bind  f v\r\n        let inline (>>>) f g v = f v |>> g\r\n        let inline (>=>) f g v = f v >>= g\r\n        let inline rtn   v     = rtn    v\r\n        let reader = reader\r\n        type ReaderM<'T, 'R, 'M> = ReaderMResultM<'T, 'R, 'M>\r\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"553ce707-0b71-4948-b990-96f0bf91255d"}, {"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"a7e4ee55-8458-49ba-96f7-b61f8f268e4f"}, "snpName": "ReaderMAsyncResult", "snpContent": "type ReaderMAsyncResult<'T, 'R, 'M> = ReaderMAR of ('R -> AsyncResult<'T, 'M>)\n\nmodule ReaderMAsyncResult =\n    let inline wrap                         f  = ReaderMAR f\n    let inline getFun                       f  =  f |> function ReaderMAR g -> g\n    let inline ofFun                        f  = (f >> AsyncResult.rtn                                              )  |> wrap \n    let inline rtn                          a  = (fun _ -> a |> AsyncResult.rtn                                     )  |> wrap\n    let inline rtnR                         r  = (fun _ -> r |> Async.rtn                                           )  |> wrap \n    let inline rtnA                         r  = (fun _ -> r |> Async.map Ok                                        )  |> wrap \n    let inline rtnRA                        r  = (fun _ -> r                                                        )  |> wrap \n    let inline rtnRmr                       r  = (fun m -> ReaderMResult.getFun r m |> Async.rtn                    )  |> wrap \n    let inline bind            f            a  = (fun m -> getFun a m |> AsyncResult.bindP(fun v -> getFun (f v) m) )  |> wrap \n    let inline bindR           f            a  = rtnR   a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n    let inline bindA           f            a  = rtnA   a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n    let inline bindRA          f            a  = rtnRA  a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n    let inline bindRmr         f            a  = rtnRmr a |> bind f                                                     : ReaderMAsyncResult<_,_,_>\n    let inline delayRun        f               = (fun m -> f() |> getFun <|m                                        )  |> wrap \n    let inline map             f            m  = bind (f >> rtn) m                                                      : ReaderMAsyncResult<_,_,_>\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                                              : ReaderMAsyncResult<_,_,_>\n    let inline getResult                    a  = (fun m -> getFun a m |> Async      .map  Result     .Ok ) |> ReaderMAR : ReaderMAsyncResult<Result<_,_>     ,_,_>\n    let inline getAsync                     a  = (fun m -> getFun a m |> AsyncResult.mapP Async.rtn      ) |> ReaderMAR : ReaderMAsyncResult<Async<_>        ,_,_>\n    let inline getAsyncResult               a  = (fun m -> getFun a m |> AsyncResult.mapP AsyncResult.rtn) |> ReaderMAR : ReaderMAsyncResult<AsyncResult<_,_>,_,_>\n    let inline run          rsrc            a  = getFun a rsrc                                                          :        AsyncResult<_,_>\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vvO                           = vvO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vvR:Result<_,_>)              = vvR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst (fst, vRm)                   = vRm |> map (fun v -> fst, v)\n    let insertSnd (vRm, snd)                   = vRm |> map (fun v -> v, snd)\n    let absorbR (vvRm)                         = vvRm |> bind rtnR\n    let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n    let mapError                          fE v = wrap(v |> getFun >> (AsyncResult.mapError fE))\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\n    let inline iterA            fE f t         = run t >> AsyncResult.iterA fE f\n    let inline iterS            fE f t         = run t >> AsyncResult.iterS fE f\n    let memoizeRm               getCache fRm p = (fun r -> \n                                                     let checkO, store = getCache r\n                                                     checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\n                                                 ) |> wrap\n\n    type Builder() =\n        member inline this.Return      x                  = rtn     x\n        member inline this.ReturnFrom  x                  =        (x:ReaderMAsyncResult<_,_,_>)\n        member inline this.ReturnFrom  x                  = rtnR    x\n        member inline this.ReturnFrom  x                  = rtnRA   x\n        member inline this.ReturnFrom  x                  = rtnRmr  x\n        member        this.Bind       (w , r )            = bind    r w\n        member        this.Bind       (w , r )            = bindR   r w\n        member        this.Bind       (w , r )            = bindRA  r w\n        member        this.Bind       (w , r )            = bindRmr r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = (fun r -> async.TryWith   (body() |> run r,   handler                ) ) |> wrap\n        member this.TryFinally(body, compensation) = (fun r -> async.TryFinally(body() |> run r,   compensation           ) ) |> wrap\n        member this.Using     (disposable, body  ) = (fun r -> async.Using((disposable:#System.IDisposable), body >> run r) ) |> wrap\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))\n\n    [< AutoOpen >]\n    module Extension =\n\n        type Builder with\n            member inline this.ReturnFrom  x                  = rtnA    x\n            member        this.Bind       (w , r )            = bindA   r w\n\n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (<*>) f v   = apply f v\n        let inline (|>>) v f   = map   f v\n        let inline (>>=) v f   = bind  f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMAsyncResult<'T, 'R, 'M>\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3173b988-9ac9-49c1-b5d1-137bee4d947f"}, {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"18664e7f-f138-49c5-9eff-c90fdff5f218"}, "snpName": "ReaderMAsyncResultM", "snpContent": "type ReaderMAsyncResultM<'T, 'R, 'M> = ReaderMARM of ('R -> AsyncResultM<'T, 'M>)\r\n\r\nmodule ReaderMAsyncResultM =\r\n    let inline wrap                         f  = ReaderMARM f\r\n    let inline getFun                       f  =  f |> function ReaderMARM g -> g\r\n    let inline ofFun                        f  = (f >> AsyncResultM.rtn                                              )  |> wrap \r\n    let inline rtn                          a  = (fun _ -> a |> AsyncResultM.rtn                                     )  |> wrap\r\n    let inline rtnr                         r  = (fun _ -> r |> ResultM.ofResult |> Async.rtn                        )  |> wrap \r\n    let inline rtnR                         r  = (fun _ -> r |> Async.rtn                                            )  |> wrap \r\n    let inline rtnA                         r  = (fun _ -> r |> Async.map OkM                                        )  |> wrap \r\n    let inline rtnrA                        r  = (fun _ -> r |> Async.map ResultM.ofResult                           )  |> wrap \r\n    let inline rtnRA                        r  = (fun _ -> r                                                         )  |> wrap \r\n    let inline rtnRm                        r  = (fun m -> ReaderMResult .getFun r m |> ResultM.ofResult |> Async.rtn)  |> wrap \r\n    let inline rtnRmm                       r  = (fun m -> ReaderMResultM.getFun r m |> Async.rtn                    )  |> wrap \r\n    let inline bind            f            a  = (fun m -> getFun a m |> AsyncResultM.bind(fun v -> getFun (f v) m)  )  |> wrap \r\n    let inline bindr           f            a  = rtnr   a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindR           f            a  = rtnR   a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindA           f            a  = rtnA   a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindrA          f            a  = rtnrA  a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindRA          f            a  = rtnRA  a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindRm          f            a  = rtnRm  a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline bindRmm         f            a  = rtnRmm a |> bind f                                                     : ReaderMAsyncResultM<_,_,_>\r\n    let inline delayRun        f               = (fun m -> f() |> getFun <|m                                         )  |> wrap \r\n    let inline map             f            m  = bind (f >> rtn) m                                                      : ReaderMAsyncResultM<_,_,_>\r\n    let inline apply           fR           vR = fR |> bind (swap map  vR)                                              : ReaderMAsyncResultM<_,_,_>\r\n    let inline getResult                    a  = (fun m -> getFun a m |> Async       .map              OkM    ) |> wrap : ReaderMAsyncResultM<ResultM<_,_>     ,_,_>\r\n    let inline getAsync                     a  = (fun m -> getFun a m |> AsyncResultM.map Async.rtn           ) |> wrap : ReaderMAsyncResultM<Async<_>        ,_,_>\r\n    let inline getAsyncResult               a  = (fun m -> getFun a m |> AsyncResultM.map AsyncResultM.rtn    ) |> wrap : ReaderMAsyncResultM<AsyncResultM<_,_>,_,_>\r\n    let inline run          rsrc            a  = getFun a rsrc                                                          :        AsyncResultM<_,_>\r\n    let (>>=)                              v f = bind f v\r\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\r\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\r\n    let inline sequenceSeq                  sq = traverseSeq id sq\r\n    let insertO  vvO                           = vvO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\r\n    let insertR (vvR:Result<_,_>)              = vvR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\r\n    let insertFst (fst, vRm)                   = vRm |> map (fun v -> fst, v)\r\n    let insertSnd (vRm, snd)                   = vRm |> map (fun v -> v, snd)\r\n    let absorbR (vvRm)                         = vvRm |> bind rtnR\r\n    let absorbO f vORm                         = vORm |> map (ResultM.ofOption  f) |> absorbR\r\n    let mapMessage                        fE v = wrap(v |> getFun >> (AsyncResultM.mapError fE))\r\n    let mapResource                       fR v = wrap ( fR >> (v    |> getFun) )\r\n    let inline iterA            fE f t         = run t >> AsyncResultM.iterA fE f\r\n    let inline iterS            fE f t         = run t >> AsyncResultM.iterS fE f\r\n    let memoizeRm               getCache fRm p = (fun r -> \r\n                                                     let checkO, store = getCache r\r\n                                                     checkO p |> Option.defaultWith(fun () -> (fRm p |> getFun) r |> store p)\r\n                                                 ) |> wrap\r\n\r\n    type Builder() =\r\n        member inline __.Return      x                  = rtn     x\r\n        member inline __.ReturnFrom  x                  =        (x:ReaderMAsyncResultM<_,_,_>)\r\n        member inline __.ReturnFrom  x                  = rtnr    x\r\n        member inline __.ReturnFrom  x                  = rtnR    x\r\n        member inline __.ReturnFrom  x                  = rtnrA   x\r\n        member inline __.ReturnFrom  x                  = rtnRA   x\r\n        member inline __.ReturnFrom  x                  = rtnRm  x\r\n        member inline __.ReturnFrom  x                  = rtnRmm  x\r\n        member        __.Bind       (w , r )            = bind    r w\r\n        member        __.Bind       (w , r )            = bindr   r w\r\n        member        __.Bind       (w , r )            = bindR   r w\r\n        member        __.Bind       (w , r )            = bindrA  r w\r\n        member        __.Bind       (w , r )            = bindRA  r w\r\n        member        __.Bind       (w , r )            = bindRm r w\r\n        member        __.Bind       (w , r )            = bindRmm r w\r\n        member inline __.Zero       ()                  = rtn ()\r\n        member inline __.Delay       f                  = f\r\n        member inline __.Combine    (a, b)              = bind b a\r\n        member inline __.Run         f                  = delayRun f\r\n        member __.While(guard, body) =\r\n            let rec whileLoop guard body =\r\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\r\n                else rtn   ()\r\n            whileLoop guard body\r\n        member __.TryWith   (body, handler     ) = (fun r -> async.TryWith   (body() |> run r,   handler                ) ) |> wrap\r\n        member __.TryFinally(body, compensation) = (fun r -> async.TryFinally(body() |> run r,   compensation           ) ) |> wrap\r\n        member __.Using     (disposable, body  ) = (fun r -> async.Using((disposable:#System.IDisposable), body >> run r) ) |> wrap\r\n        member this.For(sequence:seq<_>, body) =\r\n            this.Using(sequence.GetEnumerator(),fun enum -> \r\n                this.While(enum.MoveNext, \r\n                    this.Delay(fun () -> body enum.Current)))\r\n\r\n    let reader = Builder()\r\n    \r\n    module Operators =\r\n        let inline (<*>) f v   = apply f v\r\n        let inline (|>>) v f   = map   f v\r\n        let inline (>>=) v f   = bind  f v\r\n        let inline (>>>) f g v = f v |>> g\r\n        let inline (>=>) f g v = f v >>= g\r\n        let inline rtn   v     = rtn    v\r\n        let reader = reader\r\n        type ReaderM<'T, 'R, 'M> = ReaderMAsyncResultM<'T, 'R, 'M>\r\n\r\n        [< AutoOpen >]\r\n        module Extension =\r\n\r\n            type Builder with\r\n                member inline this.ReturnFrom  x                  = rtnA    x\r\n                member        this.Bind       (w , r )            = bindA   r w\r\n\r\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"385e6acf-5509-4b7a-9dc3-d85d8efd5ccf"}, {"SnippetId" :"ef65b9ea-9bcc-483f-833e-803e14f0194e"}, {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"097a550e-ed26-421c-aeb1-f6fb5ae9c574"}, "snpName": "old ReaderMBasic3", "snpContent": "type ReaderMBasic3<'T, 'R, 'M> = ReaderMB3 of ('R->'T)\n\nmodule ReaderMBasic3 =\n    type ReaderM2<'T, 'R> = ReaderMBasic<'T, 'R>\n    type ReaderM<'T, 'R, 'M> = ReaderMBasic3<'T, 'R, 'M>\n    module ReaderM2 = ReaderMBasic\n    let readerM = ReaderMB3\n\n////// The rest is identical to ReaderMAsync3\n\n    let inline getFun                 a  = a |> function ReaderMB3 f -> f                    \n    let inline toM2                   a  = getFun a |> ReaderM2.ofFun                  : ReaderM2<_,_>\n    let inline ofFun                  f  = f |> ReaderM2.ofFun |> readerM              : ReaderM<_,_,_>\n    let inline rtnM2                  a  = readerM a                                   : ReaderM<_,_,_>\n    let inline rtn                    a  = rtnM2  (a |> ReaderM2.rtn                 ) : ReaderM<_,_,_>\n    let inline bindM2      f          a  = readerM(a |> ReaderM2.bind (f   >> toM2 ) ) : ReaderM<_,_,_>\n    let inline bind        f (ReaderM a) = bindM2 f a                                  : ReaderM<_,_,_>\n    let inline delayRun    f             = readerM(                    f() |> toM2   ) : ReaderM<_,_,_>\n    let inline map         f          m  = bind (f >> rtn) m                           : ReaderM<_,_,_>\n    let inline apply       fR         vR = fR |> bind (swap map  vR)                   : ReaderM<_,_,_>\n    let inline run      rsrc (ReaderM a) = ReaderM2.run rsrc a\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 List.foldBack folder (Seq.toList sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq         sq = traverseSeq id sq\n    let insertO                   vvO = vvO  |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR                   vvR = vvR  |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst          (fst, vRm) = vRm  |> map (fun v -> fst, v)\n    let insertSnd          (vRm, snd) = vRm  |> map (fun v -> v, snd)\n    let absorbR                  vvRm = vvRm |> toM2 |> ReaderM2.absorbR   |> ReaderM  : ReaderM<_,_,_>\n    let absorbO f                vORm = vORm |> toM2 |> ReaderM2.absorbO f |> ReaderM  : ReaderM<_,_,_>\n\n    type Builder() =\n        member inline this.Return      x                  = rtn   x\n        member inline this.ReturnFrom  (x:ReaderM<_,_,_>) =       x\n        member inline this.ReturnFrom  x                  = rtnM2 x\n        member        this.Bind       (w , r )            = bind   r w\n        member        this.Bind       (w , r )            = bindM2 r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = ReaderM(ReaderM2.reader.TryWith   (body >> toM2 , handler     ) )\n        member this.TryFinally(body, compensation) = ReaderM(ReaderM2.reader.TryFinally(body >> toM2, compensation) )\n        member this.Using     (disposable, body  ) = ReaderM(ReaderM2.reader.Using((disposable:#System.IDisposable), body >> toM2))\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (|>>) v f   = map  f v\n        let inline (>>=) v f   = bind f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMBasic3<'T, 'R, 'M>\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"80cf876e-9132-49fd-8b82-3ccc1275d291"}, "snpName": "old ReaderMAsync3", "snpContent": "type ReaderMAsync3<'T, 'R, 'M> = ReaderM of ReaderMAsync<'T, 'R>\n\nmodule ReaderMAsync3 =\n    type ReaderM2<'T, 'R> = ReaderMAsync<'T, 'R>\n    type ReaderM<'T, 'R, 'M> = ReaderMAsync3<'T, 'R, 'M>\n    module ReaderM2 = ReaderMAsync\n\n////// The rest is identical to ReaderMBasic3\n\n    let inline toM2                   a  = a |> function ReaderM f -> f                : ReaderM2<_,_>\n    let inline getFun                 a  = a |> function ReaderM f -> f                : ReaderM2<_,_>\n    let inline ofFun                  f  = f |> ReaderM2.ofFun |> ReaderM              : ReaderM<_,_,_>\n    let inline rtnM2                  a  = ReaderM a                                   : ReaderM<_,_,_>\n    let inline rtn                    a  = rtnM2  (a |> ReaderM2.rtn                 ) : ReaderM<_,_,_>\n    let inline bindM2      f          a  = ReaderM(a |> ReaderM2.bind (f   >> toM2 ) ) : ReaderM<_,_,_>\n    let inline bind        f (ReaderM a) = bindM2 f a                                  : ReaderM<_,_,_>\n    let inline delayRun    f             = ReaderM(                    f() |> toM2   ) : ReaderM<_,_,_>\n    let inline map         f          m  = bind (f >> rtn) m                           : ReaderM<_,_,_>\n    let inline apply       fR         vR = fR |> bind (swap map  vR)                   : ReaderM<_,_,_>\n    let inline run      rsrc (ReaderM a) = ReaderM2.run rsrc a\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 List.foldBack folder (Seq.toList sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq         sq = traverseSeq id sq\n    let insertO                   vvO = vvO  |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR                   vvR = vvR  |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst          (fst, vRm) = vRm  |> map (fun v -> fst, v)\n    let insertSnd          (vRm, snd) = vRm  |> map (fun v -> v, snd)\n    let absorbR                  vvRm = vvRm |> toM2 |> ReaderM2.absorbR   |> ReaderM  : ReaderM<_,_,_>\n    let absorbO f                vORm = vORm |> toM2 |> ReaderM2.absorbO f |> ReaderM  : ReaderM<_,_,_>\n\n    type Builder() =\n        member inline this.Return      x                  = rtn   x\n        member inline this.ReturnFrom  (x:ReaderM<_,_,_>) =       x\n        member inline this.ReturnFrom  x                  = rtnM2 x\n        member        this.Bind       (w , r )            = bind   r w\n        member        this.Bind       (w , r )            = bindM2 r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = ReaderM(ReaderM2.reader.TryWith   (body >> toM2 , handler     ) )\n        member this.TryFinally(body, compensation) = ReaderM(ReaderM2.reader.TryFinally(body >> toM2, compensation) )\n        member this.Using     (disposable, body  ) = ReaderM(ReaderM2.reader.Using((disposable:#System.IDisposable), body >> toM2))\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (|>>) v f   = map  f v\n        let inline (>>=) v f   = bind f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n        let reader = reader\n        type ReaderM<'T, 'R, 'M> = ReaderMAsync3<'T, 'R, 'M>\n    \n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [{"SnippetId" :"62fab179-4e0c-4bef-b0b7-e0baf0ff1971"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"74b57624-711d-41e3-be71-c5234fcbbf7f"}, "snpName": "old ReaderMonad", "snpContent": "type ReaderM<'T, 'R, 'M> = ReaderM of ('R -> Async<Result<'T, 'M>>)\n\nmodule ReaderM =\n    let inline rtn                          a  = ReaderM(fun _ -> a   |>             AsyncResult.rtn)\n    let inline rtnR                         a  = ReaderM(fun _ -> a   |>             Async      .rtn)\n    let inline rtnA                         a  = ReaderM(fun _ -> a   |> Async.map   Result     .Ok )\n    let inline getResult           (ReaderM a) = ReaderM(fun m -> a m |> Async.map   Result     .Ok )\n    let inline bind            f   (ReaderM a) = ReaderM(fun m -> a m |> AsyncResult.bind (f >> function ReaderM b -> b m) )\n    let inline bindR           f            a  = ReaderM(fun m -> a |> Async.rtn |> AsyncResult.bind (f >> function ReaderM b -> b m) )\n    let inline bindRA          f            a  = ReaderM(fun m -> a   |> AsyncResult.bind (f >> function ReaderM b -> b m) )\n    let inline delayRun        f               = ReaderM(fun m ->                         match f() with ReaderM b -> b m  )\n    let inline map             f            m  = bind (f >> rtn) m\n    let inline apply           fR           vR = fR |> bind (swap map  vR)\n    let inline run          rsrc   (ReaderM a) = a rsrc\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 List.foldBack folder (Seq.toList sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n    let insertO  vvO                           = vvO |> Option.map(map Some) |> Option.defaultWith(fun () -> rtn None)\n    let insertR (vvR:Result<_,_>)              = vvR |> function | Error m -> rtn (Error m) | Ok v -> map Ok v\n    let insertFst (fst, vRm)                   = vRm |> map (fun v -> fst, v)\n    let insertSnd (vRm, snd)                   = vRm |> map (fun v -> v, snd)\n    let absorbR (vvRm)                         = vvRm |> bind rtnR\n    let absorbO f vORm                         = vORm |> map (Result.ofOption  f) |> absorbR\n    let inline iterS            fE f t         = run t >> AsyncResult.iterS fE f\n    let inline iterA            fE f t         = run t >> AsyncResult.iterA fE f\n\n    type Builder() =\n        member inline this.Return      x                  = rtn  x\n        member inline this.ReturnFrom  (x:ReaderM<_,_,_>) =      x\n        member inline this.ReturnFrom  x                  = rtnR x\n        member inline this.ReturnFrom  x                  = rtnA x\n        member        this.Bind       (w , r )            = bind   r w\n        member        this.Bind       (w , r )            = bindR  r w\n        member        this.Bind       (w , r )            = bindRA r w\n        member inline this.Zero       ()                  = rtn ()\n        member inline this.Delay       f                  = f\n        member inline this.Combine    (a, b)              = bind b a\n        member inline this.Run         f                  = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith   (body, handler     ) = ReaderM(fun r -> async.TryWith   (body |> run r, handler     ) )\n        member this.TryFinally(body, compensation) = ReaderM(fun r -> async.TryFinally(body |> run r, compensation) )\n        member this.Using(disposable:#System.IDisposable, body) = ReaderM(fun r -> async.Using(disposable, body >> run r))\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    let reader = Builder()\n    \n    module Operators =\n        let inline (|>>) v f   = map  f v\n        let inline (>>=) v f   = bind f v\n        let inline (>>>) f g v = f v |>> g\n        let inline (>=>) f g v = f v >>= g\n        let inline rtn   v     = rtn    v\n    \n\nlet reader = ReaderM.reader\n\n", "snpParentIdO": {"SnippetId" :"25b556cb-9ddf-4234-a61b-6a52ac671b23"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}, "snpName": "String", "snpContent": "type System.String with\n    member this.Substring2(from, n) = \n        if   n    <= 0           then \"\"\n        elif from <  0           then this.Substring2(0, n + from)\n        elif from >= this.Length then \"\"\n        else this.Substring(from, min n (this.Length - from))\n    member this.Left             n  = this.Substring2(0, n)\n    member this.Right            n  = this.Substring2(max 0 (this.Length - n), this.Length)\n\nmodule String =\n    let splitByChar (c: char) (s: string) = s.Split c\n    let splitInTwoO spl txt = \n        let i = (txt:string).IndexOf (spl:string)\n        if  i = -1 then None else\n        (txt.Left(i), txt.Substring (i + spl.Length) )\n        |> Some\n    let delimitedO  op cl txt =\n        splitInTwoO op txt\n        |> Option.bind(fun (bef, sec) ->\n            splitInTwoO cl sec\n            |> Option.map(fun (mid, aft) -> bef, mid, aft)\n        )\n    let contains     sub  (whole: string) = whole.Contains sub\n    let trim                  (s: string) = s.Trim()\n    let append     (a: string)(b: string) =  a + b\n    let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n    let unindent (s:string) =\n        let lines = s.Split '\\n'\n        let n     = lines \n                    |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                    |> Option.defaultValue \"\"\n                    |> Seq.tryFindIndex ((<>) ' ') \n                    |> Option.defaultValue 0\n        lines \n        |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n        |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n    let indent n (s:string) =\n        s.Split '\\n'\n        |> Seq.map ((+) (String.replicate n \" \"))\n    let unindentStr = unindent >> String.concat \"\\n\"\n    let indentStr i = indent i >> String.concat \"\\n\" \n    let skipLastLine =\n           splitByChar '\\n' \n        >> fun s -> s.[0 .. (max 0 (s.Length - 2)) ]\n        >> String.concat \"\\n\"\n    let (|StartsWith|_|) start (s:string) = if s.StartsWith start then Some s.[start.Length..                          ] else None\n    let (|EndsWith  |_|) ends  (s:string) = if s.EndsWith   ends  then Some s.[0           ..s.Length - ends.Length - 1] else None\n    \n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 169}, {"snpId": {"SnippetId" :"287b94ba-e7c6-48f0-95f5-9de3685c4036"}, "snpName": "(+/+)", "snpContent": "[< Inline \"$a + '/' + $b\" >]\nlet inline (+/+) a b = System.IO.Path.Combine(a, b)\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"014e7d5e-9b89-406d-a193-b2a77d817215"}, "snpName": "SortWith", "snpContent": "///    let ls = [ \"d1d\"; \"a\"; \"b\"; \"c\"; \"a3a\"; \"b2b\"; \"c1c\"]\r\n///    \r\n///    ls |> List.sortWith ( asc Seq.length)            |> print // [\"a\"; \"b\"; \"c\"; \"dd\"; \"aa\"; \"bb\"; \"cc\"]\r\n///    ls |> List.sortWith (desc Seq.length &> asc (Seq.tryItem 1) &> asc  id) |> print // [\"aa\"; \"bb\"; \"cc\"; \"dd\"; \"a\"; \"b\"; \"c\"]\r\n///    ls |> List.sortWith ( asc Seq.length &> desc id) |> print // [\"c\"; \"b\"; \"a\"; \"dd\"; \"cc\"; \"bb\"; \"aa\"]\r\nmodule SortWith =\r\n    let asc   f    a b = compare (f a) (f b)\r\n    let desc  f    a b = compare (f b) (f a)\r\n    let (&>) c1 c2 a b = match c1 a b with 0 -> c2 a b | r -> r\r\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 226}, {"snpId": {"SnippetId" :"6c60faf9-d558-4928-812d-711f349c4a90"}, "snpName": "ParseO", "snpContent": "module ParseO =\n    let tryParseWith tryParseFunc = tryParseFunc >> function\n            | true, v    -> Some v\n            | false, _   -> None\n    \n    let parseDateO   = tryParseWith System.DateTime.TryParse\n    let parseIntO    = tryParseWith System.Int32   .TryParse\n    let parseSingleO = tryParseWith System.Single  .TryParse\n    let parseDoubleO = tryParseWith System.Double  .TryParse\n    let parseGuidO   = tryParseWith System.Guid    .TryParse\n    // etc.\n    \n    // active patterns for try-parsing strings\n    let (|Date  |_|) = parseDateO\n    let (|Int   |_|) = parseIntO\n    let (|Single|_|) = parseSingleO\n    let (|Double|_|) = parseDoubleO\n    let (|Guid  |_|) = parseGuidO\n    ", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}, "snpName": "Mailbox", "snpContent": "[<System.Runtime.CompilerServices.Extension >]\ntype MailboxProcessorExt =\n    [<System.Runtime.CompilerServices.Extension ; Inline \"throw 'PostAndReply not available in JavaScript'\" >]\n    static member PostAndReply     (agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndReply     ((fun reply -> reply, msg), ?timeout= timeout)\n    [<System.Runtime.CompilerServices.Extension>]\n    static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg, ?timeout) = agent.PostAndAsyncReply((fun reply -> reply, msg), ?timeout= timeout)\n//    [<System.Runtime.CompilerServices.Extension>]\n///    static member PostF(agent:MailboxProcessor<_>, f, ?timeout) = agent.Post(fun v -> async { return f v })\n\nmodule Mailbox =\n\n    /// A simple Mailbox processor to serially process Async tasks\n    /// use:\n    ///      let logThisMsgA = Mailbox.iterA (printfn \"%A\") (fun msg -> async { printfn \"Log: %s\" msg } )\n    ///      logThisMsgA.Post \"message Async\"\n    ///      \n    let iterA hndl f =\n        MailboxProcessor.Start(fun inbox ->\n            async {\n                while true do\n                    try       let!   msg = inbox.Receive()\n                              do!  f msg\n                    with e -> hndl e\n            }\n        )\n        \n    /// A simple Mailbox processor to serially process tasks\n    /// use:\n    ///      let logThisMsg = Mailbox.iter (printfn \"%A\") (printfn \"Log: %s\")\n    ///      logThisMsg.Post \"message\"\n    ///      \n    let iter hndl f = iterA hndl (fun msg -> async { f msg } )\n    \n    /// A simple Mailbox processor to serially and synchronously process tasks\n    /// use:\n    ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n    ///                                async { return msg.ToUpper() } )\n    ///\n    ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n    ///      |> printfn \"%s\"\n    ///\n    ///      toUpperCaseA.PostAndReply \"message\"\n    ///      |> printfn \"%s\"\n    ///\n    ///      async {\n    ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n    ///                                                        reply, \"message\")\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///\n    ///      async {\n    ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously    \n    ///      \n    let callA hndl f = iterA hndl (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n        let! r = f msg\n        replyChannel.Reply r\n    })\n    \n    /// A simple Mailbox processor to serially and synchronously process tasks\n    /// use:\n    ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n    ///      \n    ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n    ///      |> printfn \"%s\"\n    ///      \n    ///      toUpperCase.PostAndReply \"message\"\n    ///      |> printfn \"%s\"\n    ///      \n    ///      async {\n    ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n    ///                                                       reply, \"message\")\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///      \n    ///      async {\n    ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///      \n    let call hndl f = callA hndl (fun (msg:string) -> async { return f msg } )\n    \n    /// A Mailbox processor that maintains a state\n    let foldA hndl f initState =\n        MailboxProcessor.Start(fun inbox ->\n            let rec loop state : Async<unit> = async {\n                try       let! msg      = inbox.Receive()\n                          let! newState = f state msg\n                          return! loop newState\n                with e -> return! loop (hndl e state)\n            }\n            loop initState\n        )\n\n    /// A Mailbox processor that maintains a state\n    let fold hndl f initState = foldA hndl (fun state msg -> async { return f state msg } ) initState\n    \n    /// A Mailbox processor that maintains a state (pass an error handler not a folder function)\n    /// use: \n    ///      agent |> Mailbox.StateFull.apply (fun state -> state + 1)\n    ///      agent |> Mailbox.StateFull.getState\n    let stateFull hndl initState =\n        MailboxProcessor.Start(fun inbox ->\n            let rec loop state : Async<unit> = async {\n                try       let! f        = inbox.Receive()\n                          let! newState = f state\n                          return! loop newState\n                with e -> return! loop (hndl e state)\n            }\n            loop initState\n        )\n        \n    let defHandler ex st = print ex ; st\n        \n    module StateFull =\n        let getStateA     (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n        let setState    v (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun _ -> async { return    v })\n        let applyA      f (agent: MailboxProcessor<'a->Async<'a>>) = agent.Post(fun v -> async { return! f v })\n        let apply       f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyA (fun v -> async { return  f v })\n        let applyReplyA f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndAsyncReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                    fun v -> async {\n                                                                                        let! st, r = f v\n                                                                                        reply.Reply r\n                                                                                        return st \n                                                                                    })\n        let applyReply  f (agent: MailboxProcessor<'a->Async<'a>>) = agent |> applyReplyA (fun v -> async { return  f v })\n        [< Inline \"throw 'getState not available in JavaScript'\" >]\n        let getState      (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply     (fun (reply:AsyncReplyChannel<_>) -> fun v -> async { reply.Reply v ; return v })\n        /// synchronous version pf applyReply\n        [< Inline \"throw 'applyReplyS not available in JavaScript'\" >]\n        let applyReplyS f (agent: MailboxProcessor<'a->Async<'a>>) = agent.PostAndReply(fun (reply:AsyncReplyChannel<'r>) -> \n                                                                                    fun v -> async {\n                                                                                        let st, r = f v\n                                                                                        reply.Reply r\n                                                                                        return st \n                                                                                    })\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a98f07ba-8de4-4baa-9714-793169bf36ac"}, "snpName": "ResourceAgent", "snpContent": "type ResourceAgentState<'R, 'C> = {\n    useCount      : int\n    limitCount    : int\n    resource      : 'R\n    configuration : 'C\n}\n\ntype ResourceAgent<'R, 'C when 'C : equality>(maxUseCount, ctor: 'C -> 'R, configuration, ?cleanup, ?isAlive, ?respawnAfter) =\n    let clean                          = defaultArg cleanup ignore\n    let alive                          = defaultArg isAlive (fun _ -> true)\n    let initConfig                     = configuration\n    let respawnRightAfter              = defaultArg respawnAfter true\n    let respawn                  state = clean state.resource\n                                         { state with useCount = 0 ; resource = ctor state.configuration }\n    let check                cfg state = if state.useCount < state.limitCount && alive state.resource && cfg = state.configuration\n                                         then state \n                                         else respawn { state with configuration = cfg }\n    let increment                state = { state with useCount = state.useCount + 1 }\n                                         |> if respawnRightAfter then (check state.configuration) else id\n    let agent                          = Mailbox.stateFull (fun ex st -> print ex ; respawn st)  \n                                            {   useCount      = 0\n                                                limitCount    = maxUseCount\n                                                configuration = initConfig\n                                                resource      = ctor initConfig\n                                            }\n    [< Inline \"throw 'Process not available in JavaScript'\" >]\n    member oo.Process      (work,?cfg) = oo.ProcessA(work, ?cfg=cfg) |> Async.RunSynchronously\n    member oo.ProcessA     (work,?cfg) = oo.AsyncProcessA((fun v -> async { return work v }), ?cfg=cfg)\n    member __.AsyncProcessA(work,?cfg) = agent \n                                        |> Mailbox.StateFull.applyReplyA(fun st -> async { \n                                             let  st2 = st |> check (defaultArg cfg st.configuration) \n                                             let! res = work st2.resource\n                                             return increment st2, res \n                                         })\n    member __.State                    = agent |> Mailbox.StateFull.getState\n    member oo.LimitCount    with get() = oo.State.limitCount\n    member oo.Configuration with get() = oo.State.configuration\n    member __.LimitCount    with set n = agent |> Mailbox.StateFull.apply(fun s -> { s with limitCount    = n })\n    member oo.Configuration with set c = if c <> oo.Configuration then agent |> Mailbox.StateFull.apply(fun s -> respawn { s with configuration = c})\n    member __.Respawn               () = agent |> Mailbox.StateFull.apply respawn\n    interface System.IDisposable with\n        member this.Dispose () = try clean this.State.resource with _ -> ()\n\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9e25a970-d1dd-4569-aeb7-46641e44237e"}, "snpName": "AgentReaderMonad", "snpContent": "module AgentReaderM =\n    module ReaderM = ReaderMAsyncResult\n    open ReaderM.Operators\n\n    let createAgentRm           f  v = ReaderM.ofFun(fun (agent:ResourceAgent<_,_>, cfg) -> agent.AsyncProcessA((fun resource -> f resource v), cfg) )\n    let fromResourceRm          f    = ReaderM.wrap (fun (agent:ResourceAgent<_,_>, cfg) -> agent.AsyncProcessA( ReaderM.getFun f             , cfg) ) : ReaderM<_,_,_>\n    let run            agent cfg                 m = ReaderM.run (agent,       cfg          ) m\n    let runSameConfig (agent:ResourceAgent<_,_>) m = ReaderM.run (agent, agent.Configuration) m\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"a7e4ee55-8458-49ba-96f7-b61f8f268e4f"}, {"SnippetId" :"a98f07ba-8de4-4baa-9714-793169bf36ac"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c3be67ee-321f-4eb2-ba98-345957897fec"}, "snpName": "CommArg", "snpContent": "[< AutoOpen >]\nmodule CommArgRoot =\n    module ReaderM = ReaderMResult\n\n    open ReaderM.Operators\n\n    type CommArgId = CommArgId of System.Guid\n    \n    type CommArgBuild =\n        | TInt    of (int    -> string)\n        | TString of (string -> string)\n        | TBool   of (bool   -> string)\n        | TFloat  of (float  -> string)\n    \n    type CommArg = {\n        cargId : CommArgId\n        name   : string\n        unique : bool\n        build  : CommArgBuild\n    }\n    type CommArgValue<'T,  'M> = ReaderM<'T, CommArgCollection<     'M>, ResultMessage<'M>> \n    and  ArgValueTuple<    'M> = CommArg *   CommArgValue<obj,      'M>\n    and  CommArgCollection<'M> = CommArgCollection of ArgValueTuple<'M> seq\n        with \n            member oo.CommArgs = match oo with CommArgCollection v -> v\n    \n    type TypedCommArg<'T> = TypedCommArg of CommArg\n        with\n        member oo.CommArg = match oo with TypedCommArg v -> v\n        static member (/=) (arg: TypedCommArg<'T>, v:                        'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, ReaderM.rtn v                     |> ReaderM.map box)\n        static member (/=) (arg: TypedCommArg<'T>, v: CommArgValue<          'T, _>) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg,             v                     |> ReaderM.map box)\n        static member (/=) (arg: TypedCommArg<'T>, f: CommArgCollection<'M>->'T    ) : ArgValueTuple<'M> = match arg with TypedCommArg arg -> (arg, ReaderM.ofFun(fun coll -> f coll) |> ReaderM.map box)\n    \n    module CommArg  =\n        let New0 (name, unique, build) = {\n            cargId = CommArgId <| System.Guid.NewGuid()\n            name   = name\n            unique = unique\n            build  = build\n        }\n        let NewInt   (name, unique, build): TypedCommArg<int   > = New0(name, unique, build |> TInt   ) |> TypedCommArg\n        let NewString(name, unique, build): TypedCommArg<string> = New0(name, unique, build |> TString) |> TypedCommArg\n        let NewBool  (name, unique, build): TypedCommArg<bool  > = New0(name, unique, build |> TBool  ) |> TypedCommArg\n        let NewFloat (name, unique, build): TypedCommArg<float > = New0(name, unique, build |> TFloat ) |> TypedCommArg\n        let argumentRm (a:CommArg) (vRm:CommArgValue<obj,_>) = reader {\n            let! v = vRm\n            return\n                match a.build with\n                | TInt    f -> unbox<int   > v |> f\n                | TString f -> unbox<string> v |> f\n                | TBool   f -> unbox<bool  > v |> f\n                | TFloat  f -> unbox<float > v |> f\n        }\n        let argumentTRm(a,v) = argumentRm a v\n        let getIntR    (TypedCommArg a) (o:obj) = \n            match a.build with\n            | TInt    _ -> unbox<int   > o |> Ok\n            | _         -> Error <| ErrorMsg \"expecting TInt\"\n        let getStringR (TypedCommArg a) (o:obj) = \n            match a.build with\n            | TString _ -> unbox<string> o |> Ok\n            | _         -> Error <| ErrorMsg \"expecting TString\"\n        let getBoolR   (TypedCommArg a) (o:obj) = \n            match a.build with\n            | TBool   _ -> unbox<bool  > o |> Ok\n            | _         -> Error <| ErrorMsg \"expecting TBool\"\n        let getFloatR  (TypedCommArg a) (o:obj) = \n            match a.build with\n            | TFloat  _ -> unbox<float > o |> Ok\n            | _         -> Error <| ErrorMsg \"expecting TFloat\"\n    \n    module CommArgCollection =\n        open ReaderM.Operators\n    \n        let trueForAll                        _ = true\n        let contains      (TypedCommArg arg) (CommArgCollection args) = args |> Seq.map (fun (a,_) -> a.cargId) |> Seq.contains arg.cargId\n        let argsRm                           () = ReaderM.ofFun(fun (CommArgCollection args) -> args                 )\n        let existsRm                          f = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.exists f )\n        let filterRm                          p = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.filter p )\n        let argumentsRm                  filter = filterRm filter >>= ReaderM.traverseSeq CommArg.argumentTRm\n        let containsAnyOfRm (ids:CommArgId Set) = ReaderM.ofFun(fun (CommArgCollection args) -> args |> Seq.exists (fun (a,_) -> Set.contains a.cargId ids) )\n        let argumentNotFound  targ = fun () -> match targ with | TypedCommArg arg -> sprintf \"argument not found: %s\" arg.name |> ErrorMsg\n        let tryFindArgO   (TypedCommArg arg) (CommArgCollection args) = Seq.tryFind (fun (a,_) -> a.cargId = arg.cargId) args \n        let tryFindArgORm     targ = ReaderM.ofFun(fun coll -> tryFindArgO targ coll |> Option.map ReaderM.insertFst |> ReaderM.insertO)|> ReaderM.bind id\n        let tryGetIntORm      targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getIntR    targ o)) |>> Result.insertO |> ReaderM.absorbR\n        let tryGetStringORm   targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getStringR targ o)) |>> Result.insertO |> ReaderM.absorbR\n        let tryGetBoolORm     targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getBoolR   targ o)) |>> Result.insertO |> ReaderM.absorbR\n        let tryGetFloatORm    targ = tryFindArgORm   targ |>> (Option.map (fun (_, o) -> CommArg.getFloatR  targ o)) |>> Result.insertO |> ReaderM.absorbR\n        let findArgRm         targ = tryFindArgORm   targ |>  ReaderM.absorbO (argumentNotFound targ)\n        let getIntRm          targ = tryGetIntORm    targ |>  ReaderM.absorbO (argumentNotFound targ)\n        let getStringRm       targ = tryGetStringORm targ |>  ReaderM.absorbO (argumentNotFound targ)\n        let getFloatRm        targ = tryGetFloatORm  targ |>  ReaderM.absorbO (argumentNotFound targ)\n        let getBoolRm   def   targ = tryGetBoolORm   targ |>> Option.defaultValue def\n        [< Inline \"throw 'getBoolR not available in JavaScript'\" >]\n        let getBoolR def targ args = getBoolRm def targ |> ReaderM.run args //|> Async.RunSynchronously //|> Result. Option.defaultValue false\n    \n        let addPair(commArg:CommArg, vRm:ReaderM<obj, CommArgCollection<_>, _>) (CommArgCollection args) =\n            args\n            |> if commArg.unique then Seq.filter (fun (a,_) -> a.cargId <> commArg.cargId) else id\n            |> Seq.append <| [ commArg, vRm ]\n            |> Seq.toArray\n            |> Seq.ofArray\n            |> CommArgCollection\n        let append (args1: CommArgCollection<'M>) (args2: CommArgCollection<'M> ) = args2.CommArgs |> Seq.fold (swap (unbox >> addPair)) args1\n        let addPairs pairs collection = append collection (CommArgCollection pairs)\n            \n    //    let produceRm = ReaderM(fun (CommArgCollection args) ->\n    //        args\n    //        |> ReaderM.traverseSeq (fun (a, vRm) -> CommArg.produceRm a vRm |> ReaderM.map (fun v -> a, v))\n    //        |> ReaderM.map Seq.toArray\n    //        |> ReaderM.run (CommArgCollection args)\n    //    )\n    \n    type  CommArgCollection<'M> with\n        static member (+) (args: CommArgCollection<_>, args2                    ) = args |> CommArgCollection.addPairs args2\n        static member (+) (args: CommArgCollection<_>, arg                      ) = args |> CommArgCollection.addPair  arg  \n        static member (+) (args: CommArgCollection<_>, (CommArgCollection args2)) = args |> CommArgCollection.addPairs args2\n    \n    ", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"183d8f05-34c8-4816-a9fc-8708c2649ac2"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}, {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"37faf742-82b0-41ef-977d-262def7e1901"}, "snpName": "FsCode", "snpContent": "type FsCode = FsCode of string\n\nmodule FsCode =\n\n    type PreproDirective =\n    | PrepoCd     of string\n    | PrepoR      of string\n    | PrepoDefine of string\n    | PrepoLoad   of string\n    | PrepoLine   of string //* int\n    | PrepoNoWarn of string\n    | PrepoI      of string\n    | PrepoIf     of string\n    | PrepoElse   \n    | PrepoEndIf\n    | PrepoLight  of bool\n    | PrepoOther  of string\n    | NoPrepo\n    \n    let extractDefines(FsCode code) = \n        if code.StartsWith \"////-d:\" \n        then code.[4..code.IndexOf '\\n' - 1]\n        else \"\"\n\n    let separatePrepros (code:string[]) =\n        let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n        let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n        let  comment = ((+)\"//\") \n        let  prepro (line:string) = match true with \n                                    | true when line.StartsWith(\"#define\"       ) -> (comment line, line |> define |> PrepoDefine)\n                                    | true when line.StartsWith(\"#cd\"           ) -> (comment line, line |> quoted |> PrepoCd    )\n                                    | true when line.StartsWith(\"#r\"            ) -> (comment line, line |> quoted |> PrepoR     )\n                                    | true when line.StartsWith(\"#load\"         ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                    | true when line.StartsWith(\"#nowarn\"       ) -> (comment line, line |> quoted |> PrepoNoWarn)\n                                    | true when line.Trim().StartsWith(\"# \"     ) -> (comment line, line |> quoted |> PrepoLine  )\n                                    | true when line.Trim().StartsWith(\"#line\"  ) -> (comment line, line |> quoted |> PrepoLine  )\n                                    | true when line.StartsWith(\"#I\"            ) -> (comment line, line |> quoted |> PrepoI     )\n                                    | true when line.StartsWith(\"#if\"           ) -> (        line, line           |> PrepoIf    )\n                                    | true when line.StartsWith(\"#else\"         ) -> (        line,                   PrepoElse  )\n                                    | true when line.StartsWith(\"#endif\"        ) -> (        line,                   PrepoEndIf )\n                                    | true when line.StartsWith(\"#light\"        ) -> (        line, false          |> PrepoLight )\n                                    | true when line.StartsWith(\"#\"             ) -> (comment line, line           |> PrepoOther )\n                                    | _                                           -> (        line,                   NoPrepo    ) \n        code |> Array.map prepro\n        \n    let separateDirectives (fsNass:(string * PreproDirective) seq) =\n        let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n        let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n        let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n        let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n        let  cd       = fsNass |> Seq.choose (snd >> (function | PrepoCd   dir -> Some dir    | _ -> None)) |> Seq.tryHead\n        let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n        code, assembs, defines, prepoIs, nowarns, cd\n        \n    let getSourceDir srcDir (lines:string[]) =\n        match lines.[0], Array.tryItem 1 lines with\n        |         String.StartsWith \"////#cd @\\\"\" dirq, _ \n        | _, Some(String.StartsWith \"////#cd @\\\"\" dirq) ->  dirq.Trim()\n                                                            |> function\n                                                            | String.EndsWith \"\\\"\" dir\n                                                            |                      dir ->\n                                                            match dir with\n                                                            | String.StartsWith \"\\\\\" _\n                                                            | String.StartsWith \"/\"  _            -> dir\n                                                            | _ when Seq.tryItem 1 dir = Some ':' -> dir\n                                                            | _ -> srcDir  +/+                       dir\n        | _                                                     -> srcDir\n\n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 66}, {"snpId": {"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}, "snpName": "Snippet", "snpContent": "type SnippetId = SnippetId of System.Guid with member x.Id = match x with SnippetId id -> id\n                                               static member Empty = SnippetId System.Guid.Empty\n\ntype Snippet = {\n    snpId           : SnippetId    \n    snpName         : string\n    snpContent      : string\n    snpParentIdO    : SnippetId option\n    snpPredIds      : SnippetId Set\n    snpProperties   : (string* string) []\n    snpGeneration   : int\n}\n\ntype SnippetReference =\n| RefSnippetId   of SnippetId\n| RefSnippetPath of string[]\n\ntype Reduced = ((SnippetId * string * int * int) [] * string [] * string [] * string [] * string [] * string [] * string option) option\n\ntype SnippetCollection = {\n    generation       : int\n    ordered          : Snippet seq\n    fetcher          : SnippetId -> Snippet Option\n    predecesorsCache : unit -> (SnippetId -> SnippetId list option) \n                             * (SnippetId -> SnippetId list -> SnippetId list)\n    reducedCache     : unit -> ((bool * SnippetId * Set<SnippetId>) -> Reduced option) \n                             * ((bool * SnippetId * Set<SnippetId>) -> Reduced -> Reduced)\n    prepCode         : Snippet -> string                             \n}\n\nmodule Snippet =\n    open System\n    module ReaderM = ReaderMResult\n    open ReaderM.Operators\n\n    let getNextGeneration, setGeneration = \n        let mutable generation  = 1\n        (fun () -> generation <- generation + 1 ; generation)\n      , (fun n  -> generation <- n                          )  \n    let New name content parentO = \n        {\n            snpId           = SnippetId <| System.Guid.NewGuid()   \n            snpName         = name\n            snpContent      = content\n            snpParentIdO    = parentO\n            snpPredIds      = Set.empty\n            snpProperties   = Array.empty\n            snpGeneration   = getNextGeneration()\n        }\n    let defaultSnippet              = {\n        snpId           = SnippetId <| System.Guid.Empty\n        snpName         = \"\"\n        snpContent      = \"\"\n        snpParentIdO    = None\n        snpPredIds      = Set.empty\n        snpProperties   = Array.empty\n        snpGeneration   = 0\n    }    \n    let snippetName name (content: string) =\n        if name <> \"\" then name else \n        content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n        |> Seq.map    (fun l -> l.Trim())\n        |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n        |> Seq.tryHead\n        |> Option.defaultValue \"<empty>\"    \n    let nameSanitized snp =\n        let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                        '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                        '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                        '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                        '\\\\'  ; '/'|] //\"\n        snp.snpName \n        |> String.filter (fun c -> not <| Array.contains c illegal)\n        |> fun c -> c + \" \" + snp.snpId.Id.ToString()\n    let propertyO       n snp = snp.snpProperties |> Array.tryPick (fun (name, value) -> if name = n then Some value else None)\n    let propertyPairO   n snp = propertyO n snp |> Option.map(fun v -> v.Split([| @\"|-|\" |], StringSplitOptions.RemoveEmptyEntries) |> fun vs -> vs.[0], vs |> Array.tryItem 1 |> Option.defaultValue vs.[0])\n    let snippetORm        sid = ReaderM.ofFun (fun { fetcher    = ftch } -> ftch sid                                               )\n    let parentORm         snp = ReaderM.ofFun (fun { fetcher    = ftch } -> snp.snpParentIdO |> Option.bind ftch                   )\n    let predecessorsRm    snp = ReaderM.ofFun (fun { fetcher    = ftch } -> snp.snpPredIds   |> Seq.choose  ftch                   )\n    let maxGenerationRm   ()  = ReaderM.ofFun (fun { ordered    = snps } -> snps |> Seq.map (fun s -> s.snpGeneration) |> Seq.max  )\n    let modifiedRm        snp = ReaderM.ofFun (fun { generation = gen  } -> snp.snpGeneration > gen                                )\n    let childrenRm        sid = ReaderM.ofFun (fun { ordered    = snps } -> snps |> Seq.filter(fun s -> s.snpParentIdO = Some sid) )\n    let orderedRm         ()  = ReaderM.ofFun (fun { ordered    = snps } -> snps                                                   )\n    let prepareCodeRm     snp = ReaderM.ofFun (fun { prepCode   = prep } -> prep snp                                               )\n    let snippetRm         sid = snippetORm sid |> ReaderM.absorbO (fun () -> sprintf \"Snippet not found %A\" sid |> ErrorMsg)\n    let rec pathRm        sid = snippetORm sid \n                                |>> Option.map parentORm \n                                >>= ReaderM.insertO \n                                |>> Option.bind id\n                                |>> Option.map (fun prn -> pathRm prn.snpId |>> fun rest -> prn.snpId :: rest ) \n                                >>= ReaderM.insertO \n                                |>> Option.defaultValue []\n    let snippetFromPathORm pth = reader {\n        let! snps = orderedRm()\n        return\n            snps\n            |> Seq.mapFold (fun (path, prntO) snp -> \n                               if path |> Array.length = 0                       then None    , ([||]      , prntO         ) else\n                               let name = snippetName snp.snpName snp.snpContent\n                               if  name <> path.[0] || snp.snpParentIdO <> prntO then None    , (path      , prntO         ) else\n                               if path |> Array.length > 1                       then None    , (path.[1..], Some snp.snpId) else\n                                                                                      Some snp, ([||]      , prntO         )                               \n                           ) \n                           (pth, None)\n            |> fst\n            |> Seq.choose id\n            |> Seq.tryHead\n    }\n    let snippetFromRefORm     = function\n                                | RefSnippetId   sid -> snippetORm         sid\n                                | RefSnippetPath pth -> snippetFromPathORm pth\n    let predsLRm (sid : SnippetId) = reader {\n            let mutable ins  = [sid]  \n            let mutable outs = [   ]\n            while not ins.IsEmpty do\n                match ins with\n                | []         -> ()\n                | hd :: rest -> if outs |> List.contains hd then\n                                    ins  <- rest\n                                else\n                                    let! snpO  = snippetORm hd\n                                    let  preds = snpO \n                                                 |> Option.map(fun snp -> Seq.toList snp.snpPredIds @ Option.toList snp.snpParentIdO ) \n                                                 |> Option.defaultValue []\n                                    ins  <- rest @ preds\n                                    outs <- hd::outs\n            return outs\n        }\n    let predsLRmMemo          = ReaderM.memoizeRm (fun c -> c.predecesorsCache()) predsLRm \n#if FIX_GENERIC\n    (predsLRmMemo : (SnippetId -> Monads.ReaderMonads.ReaderMResult<SnippetId list,SnippetCollection,string>) )\n#endif    \n    let uniquePredsRm     snp = predsLRmMemo snp.snpId\n    let rec modifiedRecRm snp = reader {\n        let! modified         = modifiedRm     snp\n        if modified then return true else\n        let! predIds          = uniquePredsRm  snp\n        let! predOs           = predIds |> Seq.map snippetORm                  |> ReaderM.sequenceSeq\n        let! mods             = predOs  |> Seq.choose id |> Seq.map modifiedRm |> ReaderM.sequenceSeq\n        return Seq.contains true mods\n    }\n    let rec propertyHierORm n snp = reader {\n        match propertyO n snp with\n        | Some v -> return Some (v.Split([| @\"|-|\" |], StringSplitOptions.RemoveEmptyEntries) |> fun vs -> vs.[0], if vs.Length > 0 then vs.[1] else vs.[0])\n        | None   -> let! parentO = parentORm   snp\n                    match parentO with\n                    | Some p -> let!   propO = propertyHierORm n p\n                                return propO |> Option.map(fun (_, next) -> next, next) \n                    | None   -> return None\n    }\n    let indentRm          snp =\n        let rec indentMeChildNextRm          snp = reader {\n            let  propIndentChildren = \"IndentChildren\"\n            let  currO, nextO       = propertyPairO propIndentChildren snp |> function Some (curr, next) ->  ParseO.parseIntO curr, ParseO.parseIntO next | _-> None, None \n            let! parentO            = parentORm   snp\n            match parentO with\n            | Some p -> let! _, (me, next) = indentMeChildNextRm p\n                        return me, (me + (currO |> Option.defaultValue next), nextO |> Option.defaultValue next)\n            | None   -> return 0 , (      currO |> Option.defaultValue 4    , nextO |> Option.defaultValue 4   )\n        }\n        indentMeChildNextRm snp |> ReaderM.map fst\n    let levelRm           snp = \n        let rec levelRm2 snp lv = reader {\n            let!  parentO = parentORm snp\n            match parentO with\n            | None   -> return  lv\n            | Some p -> return! levelRm2 p (lv + 1)\n        }\n        levelRm2 snp 0\n    let ancestorsRm   snp = \n        let rec  ancestorsRm2 snp lst = reader {\n            let! parentO = parentORm snp\n            match parentO with\n            | Some p -> return! ancestorsRm2 p <| p::lst\n            | None   -> return  lst\n        }\n        ancestorsRm2 snp []\n    let separateCodeRm snp = reader {\n        let! indent        = indentRm snp\n        let  indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let! code          = prepareCodeRm snp\n        //let  name          = nameSanitized snp\n        let  code, assembs, defines, prepIs, nowarns, cdO =\n            code.Split('\\n')\n            |> FsCode.separatePrepros\n            |> indentF\n            |> FsCode.separateDirectives\n        return\n            [| snp.snpId, snippetName snp.snpName snp.snpContent, code.Length, indent |] , code, assembs, defines, prepIs, nowarns,cdO\n    }\n    let addSeps (lines1:(SnippetId*string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[], cdO1:string option)\n                (lines2:(SnippetId*string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[], cdO2:string option) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n      , cdO1 |> function None -> cdO2 |_-> cdO1\n    let reducedCodeRm  snippets = reader {\n        let! parts    = snippets |> ReaderM.traverseSeq separateCodeRm\n        let  reduced  = parts\n                        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||], None ] else snps\n                        |> Seq.reduce addSeps\n                        |> fun (lines, code                                         , assembs, defines, prepIs, nowarns, cdO) ->\n                               (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns, cdO)\n        return reduced\n    }\n    let finishCode (lines:(SnippetId*string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[], cdO: string option) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            if cdO.IsSome   then yield sprintf \"////#cd @\\\"%s\\\"\" cdO.Value\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\" )\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (id, name, len, ind) -> ((id, name), (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    //let codeAndStartsRm   snpIds = reader {\n    //    let! snippets = orderedRm() |>> Seq.filter(fun snp -> snpIds |> Seq.contains snp.snpId)\n    //    let! reduced  = reducedCodeRm snippets\n    //    return finishCode reduced\n    //}\n    //let codeFsxRm         snippets = codeAndStartsRm snippets |> ReaderM.map fst\n    let reducedOthersORm (before, snpId, snpIds) = reader {\n        let  skipTake = if before then Seq.takeWhile else Seq.skipWhile\n        let! snippets = orderedRm() |>> skipTake (fun snp -> snp.snpId <> snpId) |>> Seq.filter(fun snp -> snp.snpId <> snpId && snpIds |> Set.contains snp.snpId) \n        if snippets |> Seq.isEmpty then return None else\n        let! reduced = reducedCodeRm snippets\n        return Some reduced\n    }\n    let reducedOthersORmMemo = ReaderM.memoizeRm (fun c -> c.reducedCache()) reducedOthersORm \n    let fastReducedRm  curIdO lastIdO = reader {\n        let!  curSnippetO  = curIdO  |> Option.map snippetORm |> ReaderM.insertO\n        let! lastSnippetO  = lastIdO |> Option.map snippetORm |> ReaderM.insertO\n        match (Option.bind id curSnippetO, Option.bind id lastSnippetO) with\n        | _              , None\n        | None           , _                -> return! reducedCodeRm Seq.empty\n        | Some curSnippet, Some lastSnippet ->\n        let! preds = uniquePredsRm lastSnippet\n        let  preds = Set preds\n        let! reducedBeforeO = reducedOthersORmMemo (true , curSnippet.snpId, preds)\n        let! reducedAfterO  = reducedOthersORmMemo (false, curSnippet.snpId, preds)\n        let! currentCode    = separateCodeRm           curSnippet\n        let part1 = reducedBeforeO |> Option.map (swap addSeps currentCode) |> Option.defaultValue currentCode\n        return      reducedAfterO  |> Option.map (     addSeps part1      ) |> Option.defaultValue part1\n    }\n    let fastCodeRm  curIdO lastIdO = reader {\n        let! reduced  = fastReducedRm curIdO lastIdO\n        return finishCode reduced\n    }\n    let codeFsxRm    curId = fastCodeRm  (Some curId) (Some curId) |> ReaderM.map fst\n    ", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"045a7205-0f3e-46fe-9b72-87d0a5f84f79"}, {"SnippetId" :"37faf742-82b0-41ef-977d-262def7e1901"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"6c60faf9-d558-4928-812d-711f349c4a90"}, {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 67}, {"snpId": {"SnippetId" :"fc37fa2a-f517-4945-82f3-8ce10c8cbb33"}, "snpName": "Tree", "snpContent": "/// Tree structure to implement a hierarchical user interface\nmodule Tree =\n\n    type Node<'I> = {\n        id              : unit-> 'I\n        isExpanded      : unit-> bool\n        canHaveChildren : unit-> bool\n        children        : unit-> Node<'I> seq\n        path            : unit-> 'I list                    // list of parents excluding itself\n        parentO         : Node<'I> seq -> Node<'I> option\n        newChildren     : Node<'I> []  -> Node<'I>         // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n    }\n\n    let [<Inline>] inline toNode    (o: obj) = o :?> Node<_>\n    let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n\n    let rec listNodes level (nodes: Node<'I> seq) = seq {\n        for node in nodes do\n            yield node, level\n            if node.isExpanded() then\n                yield! node.children() |> listNodes (level + 1)\n    }\n\n    let removeNode (node:Node<_>) nodes = // better use version removeNode2\n        let path = node.path()\n        let rec chRemove (n:Node<_>) =\n            if                  n.id() = node.id() then None\n            elif List.contains (n.id())  path      then Some (n.newChildren (n.children() |> Seq.choose chRemove |> Seq.toArray) )\n            else                                        Some n\n        nodes |> Seq.choose chRemove\n\n    let removeNodes p nodes =\n        let rec folder (children, noparent) (n:Node<_>) =\n            let ch, np = n.children() |> Seq.fold folder ([], noparent)\n            if p n then (                                                children, ch @ np)\n            else        (n.newChildren (ch |> Seq.rev |> Seq.toArray) :: children,      np)\n        let res, noparent = nodes |> Seq.fold folder ([], [])\n        noparent @ res |> List.rev\n\n    let addNodeToSeq after p node (nodes:Node<'I> seq)  =\n        seq [ for n in nodes do\n                if p n then\n                    if after then yield n    ; yield node\n                    else          yield node ; yield n\n                else              yield n\n        ]\n        \n    let addToParent after p (node:Node<'I>) (parent :Node<'I>) (nodes:Node<'I> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildren\n\n    let addSibling  after   (node:Node<'I>) (sibling:Node<'I>) (nodes:Node<'I> seq) =\n        let theSibling (n:Node<'I>) = n.id() = sibling.id()\n        match sibling.path() with\n        | [   ]          -> addNodeToSeq after theSibling node nodes \n        | parent :: path -> \n        let rec mapAdd (n:Node<'I>) =\n            if                  n.id() = parent then n.children() |> addToParent after theSibling node n\n            elif List.contains (n.id()) path    then n.newChildren (n.children() |> Seq.map mapAdd |> Seq.toArray) \n            else                                     n\n        nodes |> Seq.map mapAdd\n\n    let tryFind p (nodes:Node<'I> seq) =\n        let rec folder res (node:Node<'I>) =\n            match  res with\n            | Some _ -> traceI \"already solved\" ; res\n            | None   -> traceI \"not solved yet\" ; if p node |> traceT \"predicate\" then Some node else node.children() |> Seq.fold folder None\n        nodes\n        |> Seq.fold folder None\n    let tryFindId (id:'I) (nodes:Node<'I> seq) = tryFind (fun n -> n.id() = id) nodes\n\n    let moveToSibling after (node:Node<'I>) (sibling:Node<'I>) (nodes:Node<'I> seq) =\n        nodes\n        |> removeNode node\n        |> addSibling after node sibling\n\n    let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<'I> seq) =\n        nodes\n        |> tryFindId nodeId\n        |> Option.bind(fun node ->\n            nodes\n            |> tryFindId siblingId\n            |> Option.map(fun sibling -> moveToSibling after node sibling nodes)\n        )\n        |> Option.defaultValue nodes\n\n    let addChild append (node:Node<'I>) (parentN:Node<'I>) (nodes:Node<'I> seq) =\n        let path = parentN.path()\n        let rec mapAppend (n:Node<'I>) =\n            if   n.id() = parentN.id()       then \n                if append                    then n.children() |> Seq.append <| [ node ]  |> Seq.toArray |> n.newChildren\n                else                              n.children() |> Seq.append    [ node ]  |> Seq.toArray |> n.newChildren\n            elif List.contains (n.id()) path then n.children() |> Seq.map mapAppend       |> Seq.toArray |> n.newChildren\n            else                              n\n        nodes |> Seq.map mapAppend\n\n    let indentNode (node:Node<'I>) (nodes:Node<'I> seq) =\n        node.parentO nodes\n        |> Option.map (fun parent -> parent.children() )\n        |> Option.defaultValue nodes\n        |> Seq.takeWhile (fun            n -> node.id() <> n.id())\n        |> Seq.fold      (fun newParentO n -> if n.canHaveChildren() then Some n else newParentO) None\n        |> Option.map(fun newParent ->\n            nodes\n            |> removeNode node \n            |> addChild true node newParent\n        )\n        |> Option.defaultValue nodes\n\n    let outdentNode (node:Node<'I>) (nodes:Node<'I> seq) =\n        node.parentO nodes\n        |> Option.map(fun parent -> moveToSibling true node parent nodes )\n        |> Option.defaultValue nodes\n        \n    let removeNodeOutdentChildren (node:Node<_>) nodes =\n        node.children()\n        |> Seq.fold (swap outdentNode) nodes\n        |> removeNode node", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"beee1304-d287-4b81-841f-9289cb3572c1"}, {"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"268771dc-ecc7-4dde-881b-e0b94deb30ea"}, "snpName": "Hole", "snpContent": "/// Adapted from here http://fssnip.net/7V5   Usage:\n/// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n///         \n/// abs  1 |> printfn \"%A\" // 1\n/// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\ntype Hole = Hole with\n    [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n    static member inline (?) (Hole, id) : 'T = \n        sprintf \"Incomplete hole '%s'\" id        \n        |> exn\n        |> raise\n        \n", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7f466863-bdb1-49fd-b0a5-e8f426c6efff"}, "snpName": "TreeReader", "snpContent": "/// Tree structure to implement a hierarchical user interface but using readerMonad\nmodule TreeReader =\n    module ReaderM = ReaderMResult    \n    open ReaderM.Operators\n\n    type Node<'I, 'R, 'T> = {\n        id                : unit                 -> 'I\n        isExpandedRm      : unit                 -> ReaderM<bool                   , 'R, 'T>\n        canHaveChildrenRm : unit                 -> ReaderM<bool                   , 'R, 'T>\n        childrenRm        : unit                 -> ReaderM<Node<'I, 'R, 'T> seq   , 'R, 'T>\n        pathRm            : unit                 -> ReaderM<'I list                , 'R, 'T>  // list of parents excluding itself\n        parentORm         : Node<'I, 'R, 'T> seq -> ReaderM<Node<'I, 'R, 'T> option, 'R, 'T>\n        newChildrenRm     : Node<'I, 'R, 'T> []  -> ReaderM<Node<'I, 'R, 'T>       , 'R, 'T>  // set new children, make sure to exclude children not listed and maintain the order of the children (if desirable)\n    }\n\n    let [<Inline>] inline toNode    (o: obj) = o :?> Node<_,_,_>\n    let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n\n    let rec listNodes level (nodes: Node<_,_,_> seq) =\n        nodes\n        |> Seq.map(fun node -> \n            node.isExpandedRm() \n            >>= (fun exp -> if exp then node.childrenRm() |>> Seq.toArray >>= listNodes (level + 1) else rtn Seq.empty)\n            |>> (fun nodes -> Seq.append [ node, level ] nodes)\n        ) \n        |> ReaderM.sequenceSeq\n        |>> Seq.collect id\n\n    let removeNode (node:Node<_,_,_>) nodes = reader { // better use version removeNode2\n        let! path = node.pathRm()\n        let rec chRemove (n:Node<_,_,_>) = reader {\n            if                  n.id() = node.id() then return  None\n            elif List.contains (n.id())  path      then return! n.childrenRm()\n                                                                |>> Seq.toArray\n                                                                |>> Seq.map chRemove \n                                                                >>= ReaderM.sequenceSeq \n                                                                |>> Seq.choose id \n                                                                |>> Seq.toArray\n                                                                >>= n.newChildrenRm  \n                                                                |>> Some\n            else                                        return  Some n\n        }\n        return! nodes |> Seq.map chRemove |> ReaderM.sequenceSeq |>> Seq.choose id\n    }\n\n    let removeNodes p nodes = reader {\n        let rec folder pair (n:Node<_,_,_>) = reader {\n            let! children, noparent = pair\n            let! children2 = n.childrenRm() |>> Seq.toArray\n            let! ch, np = children2 |> Seq.fold folder (rtn ([], noparent) )\n            if p n then return (        children, ch @ np)\n                   else let! xxx = n.newChildrenRm (ch |> Seq.rev |> Seq.toArray)\n                        return ( xxx :: children,      np)\n        }\n        let! res, noparent = nodes |> Seq.fold folder (rtn ([], []) )\n        return noparent @ res |> List.rev\n    }\n\n    let addNodeToSeq after p node (nodes:Node<_,_,_> seq)  =\n        seq [ for n in nodes do\n                if p n then\n                    if after then yield n    ; yield node\n                    else          yield node ; yield n\n                else              yield n\n        ]\n        \n    let addToParent after p (node:Node<_,_,_>) (parent :Node<_,_,_>) (nodes:Node<_,_,_> seq)  = nodes |> addNodeToSeq after p node |> Seq.toArray |> parent.newChildrenRm\n\n    let addSibling  after   (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n        let theSibling (n:Node<_,_,_>) = n.id() = sibling.id()\n        sibling.pathRm() >>= function\n        | [   ]          -> rtn <| addNodeToSeq after theSibling node nodes \n        | parent :: path -> \n        let rec mapAdd (n:Node<_,_,_>) =\n            if                  n.id() = parent then     n.childrenRm() |>> Seq.toArray >>= addToParent after theSibling node n\n            elif List.contains (n.id()) path    then     n.childrenRm() |>> Seq.toArray |>> Seq.map mapAdd >>= ReaderM.sequenceSeq |>> Seq.toArray >>= n.newChildrenRm \n            else                                     rtn n\n        nodes |> Seq.map mapAdd |> ReaderM.sequenceSeq\n\n    let tryFind p (nodes:Node<_,_,_> seq) = \n        let rec folder resRm (node:Node<_,_,_>) =\n            resRm >>= function\n            | Some v -> rtn (Some v)\n            | None   ->\n            if p node then rtn <| Some node else \n            node.childrenRm() >>= Seq.fold folder (rtn None)\n        nodes                 |>  Seq.fold folder (rtn None)\n        \n    let tryFindId (id:'I) (nodes:Node<_,_,_> seq) = tryFind (fun n -> n.id() = id) nodes\n\n    let moveToSibling after (node:Node<_,_,_>) (sibling:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n        nodes\n        |>  removeNode node\n        >>= addSibling after node sibling\n\n    let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<_,_,_> seq) = reader {\n        let!  nodeO = nodes |> tryFindId nodeId\n        match nodeO with\n        | None         -> return nodes\n        | Some node    ->\n        let!  siblingO = nodes |> tryFindId siblingId\n        match siblingO with\n        | None         -> return nodes\n        | Some sibling -> return! moveToSibling after node sibling nodes\n    }\n\n    let addChild append (node:Node<_,_,_>) (parentN:Node<_,_,_>) (nodes:Node<_,_,_> seq) = reader {\n        let! path = parentN.pathRm()\n        let rec mapAppend (n:Node<_,_,_>) =\n            if   n.id() = parentN.id()       then \n                if append                    then n.childrenRm() |>> Seq.toArray |>> swap Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n                else                              n.childrenRm() |>> Seq.toArray |>>      Seq.append [ node ]                         |>> Seq.toArray >>= n.newChildrenRm\n            elif List.contains (n.id()) path then n.childrenRm() |>> Seq.toArray |>>      Seq.map mapAppend   >>= ReaderM.sequenceSeq |>> Seq.toArray >>= n.newChildrenRm\n            else                                  rtn n\n        return! nodes |> Seq.map mapAppend |> ReaderM.sequenceSeq\n    }\n\n    let indentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) = \n        node.parentORm nodes >>= function\n        | None        -> rtn nodes\n        | Some parent -> parent.childrenRm() |>> (Seq.toArray >> Seq.ofArray)\n        |>> Seq.takeWhile (fun              n -> node.id() <> n.id())\n        >>= Seq.fold      (fun newParentORm n -> n.canHaveChildrenRm() >>= (fun can -> if can then rtn(Some n) else newParentORm)) (rtn None)\n        >>= function\n        | None           -> rtn nodes\n        | Some newParent ->\n        nodes\n        |>  removeNode node \n        >>= addChild true node newParent\n\n    let outdentNode (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n        node.parentORm nodes\n        |>> Option.map          (fun parent -> moveToSibling true node parent nodes )\n        >>= Option.defaultValue (rtn nodes)\n        \n    let removeNodeOutdentChildren (node:Node<_,_,_>) (nodes:Node<_,_,_> seq) =\n        node.childrenRm()\n        |>> Seq.toArray\n        >>= Seq.fold (fun nodes node -> nodes >>= (outdentNode node) ) (rtn nodes)\n        >>= removeNode node\n        \n    ", "snpParentIdO": {"SnippetId" :"22bcdc5c-7f7c-4000-b0ad-c81b5c0270d0"}, "snpPredIds": [{"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpName": "LibraryNoJS", "snpContent": "/// Essentials that cannot run in Javascript (WebSharper)\n[< AutoOpen >]\nmodule LibraryNoJS =", "snpParentIdO": {"SnippetId" :"44b60b89-0535-4591-aa79-f910fe6807ad"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"46850b4a-0f77-476c-b2ae-abe08218496b"}, "snpName": "Regex", "snpContent": "[< AutoOpen >]\r\nmodule Regex =\r\n    open System.Text.RegularExpressions\r\n\r\n    let (|Regex|_|) pattern input =\r\n        if input = null then None else\r\n        try \r\n            let m = Regex.Match(input, pattern)\r\n            if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\r\n            else None\r\n        with e -> None\r\n\r\n    let (|Regexs|) pattern input =\r\n        if input = null then [| |] else\r\n        try \r\n            let ms = Regex.Matches(input, pattern)\r\n            [| for m in ms do yield m.Value |] \r\n        with e -> [| |]\r\n", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 208}, {"snpId": {"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}, "snpName": "RunProcess", "snpContent": "module RunProcess =\n    open System.Diagnostics\n    open System.Text\n\n    let startProcess p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    let startProcessDir p ops dir =\n        let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    type ShellResponse =\n        | ShellDidNotStart \n        | ShellExit                  of int * stdout: string * stderr:string\n        | ShellNoExit                of       stdout: string * stderr:string\n        | ShellCrashed               of       stdout: string * stderr:string\n        with \n        override msg.ToString() = \n            match msg with\n            | ShellDidNotStart                 -> [ \"Shell did not start\" ]\n            | ShellExit        (cod, out, err) -> [ if cod <> 0 then yield sprintf \"exit(%d)\" cod\n                                                    yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n            | ShellCrashed     (     out, err) -> [ yield \"Shell crashed!\" ; yield out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n            | ShellNoExit      (     out, err) -> [ yield                          out ; if err <> \"\" then yield \"ERROR:\" ; yield err ]\n            |> String.concat \"\\n\"\n    \n    type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl, ?priorityClass) =\n        let proc                              = new Process()\n        let bufferOutput                      = new StringBuilder()\n        let bufferError                       = new StringBuilder()\n        let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\")                  |> ignore\n        let consume (sb: StringBuilder)       = sb.ToString() |>! (fun _ -> sb.Clear() |> ignore)\n        let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n        let outputHandler                     = append bufferOutput |> dataHandler\n        let errorHandler                      = append bufferError  |> dataHandler\n        do  startInfo.RedirectStandardInput  <- true\n            startInfo.RedirectStandardOutput <- true\n            startInfo.RedirectStandardError  <- true\n            startInfo.UseShellExecute        <- false\n            proc.StartInfo                   <- startInfo\n            proc.EnableRaisingEvents         <- true\n            outputHandler                    |>             proc.OutputDataReceived.AddHandler\n            errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n            Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n            Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n    //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n          \n        new          (program, args, ?priorityClass) = let startInfo                     = new ProcessStartInfo()\n                                                       do  startInfo.FileName           <- program\n                                                           startInfo.Arguments          <- args\n                                                       new ShellEx(startInfo, ?priorityClass = priorityClass)\n        member ____.Start                         () = let r = proc.Start() \n                                                       priorityClass |> Option.iter (fun p -> proc.PriorityClass <- p)\n                                                       proc.BeginOutputReadLine()\n                                                       proc.BeginErrorReadLine ()\n                                                       r\n        member ____.WaitToFinish                  () = proc.WaitForExit()\n                                                       let    output  = (consume bufferOutput).Trim()\n                                                       let    error   = (consume bufferError ).Trim()\n                                                       ((if proc.HasExited then proc.ExitCode else -99999), output, error)\n        member ____.WaitForInputIdle              () = proc.WaitForInputIdle()\n        member this.StartAndWait                  () = let _started = this.Start()\n                                                       this.WaitToFinish()\n        member this.StartAndWaitS                 () = this.StartAndWait()\n                                                       |>! fun _ -> (this :> System.IDisposable).Dispose()\n                                                       |> ShellExit\n        member this.stdOutErr2Result exit out errs   = if exit <> 0\n                                                       then Result.Error <| ErrorMsg(\n                                                               [| if out  <> \"\"              then yield \"stdout: \" + out           \n                                                                  if errs <> \"\"              then yield errs                       \n                                                                  if errs  = \"\" || exit <> 1 then yield sprintf \"ExitCode: %d\" exit\n                                                               |] |> String.concat \"\\n\")\n                                                       else Result.Ok (out, errs)\n        member this.StartAndWaitR                 () = let r = this.StartAndWait()\n                                                       (this :> System.IDisposable).Dispose()\n                                                       r |||> this.stdOutErr2Result\n        member this.RunToFinish                   () = this.StartAndWaitS().ToString()\n        member this.RunOutputToFileR            file = proc.OutputDataReceived.RemoveHandler outputHandler\n                                                       use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n                                                       let _started = proc.Start() \n                                                       proc.BeginErrorReadLine ()\n                                                       proc.StandardOutput.BaseStream.CopyTo stream\n                                                       this.WaitToFinish()\n                                                       |> ShellExit\n        member this.RunOutputToFile             file = this.RunOutputToFileR file\n                                                       |> fun v -> v.ToString() \n        member ____.Send                (txt:string) = proc.StandardInput.WriteLine txt\n        member ____.Output                        () = consume bufferOutput\n        member ____.Error                         () = consume bufferError\n        member ____.Response(out:string, err:string) = match out.Trim(), err.Trim() with\n                                                       | good, \"\"  -> Result.Ok    <| good               \n                                                       | good, bad -> Result.Error <| Message(ShellNoExit(good, bad))\n        member this.Response                      () = this.Response(this.Output(), this.Error())\n        member this.SendAndWait (send, wait, ?onErr) =\n            let waitOnError = defaultArg onErr false\n            let eventWait   = if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                              |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.Ok v else None) with _ -> None)\n            let eventAll    = Event.merge eventWait  (Event.map (fun _ -> Result.Error <| Message (ShellCrashed(this.Output(), this.Error()))) proc.Exited)\n            asyncResult {\n                //do! Result.tryProtection()\n                async { \n                    do!    Async.Sleep 20 \n                    this.Send send        } |> Async.Start\n                let! (waited:string) = Async.AwaitEvent eventAll\n                do!   Async.Sleep 200\n                return! if waitOnError\n                        then this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                        else this.Response()\n            }\n        member ____.HasExited = try proc.HasExited with _ -> true\n        member ____.Abort()   = try proc.Kill   () with _ -> ()\n        interface System.IDisposable with\n            member ____.Dispose () =\n                try proc.Kill   () with _ -> ()\n                try proc.Close  () with _ -> ()\n                try proc.Dispose() with _ -> ()\n    \n    \n    let runAndWaitS p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.StartAndWaitS() \n    \n    let runToFinish p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n        shell.RunToFinish() \n    \n    let runOutputToFile p ops file =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.RunOutputToFile file \n    \n    ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5b38de4c-d07e-4e30-9009-b0d60c55246b"}, "snpName": "CopyIfMust", "snpContent": "module CopyIfMust =\n    open System.IO\n    \n    let copyIfNotExistsToFile from dest =\n        let fit = FileInfo dest\n        if not fit.Exists then\n            File.Copy(from, dest, true )\n    \n    let toFile from dest =\n        let fit = FileInfo dest\n        let must = \n            match fit.Exists with \n            | false -> true\n            | true  ->\n                let fif = FileInfo dest\n                fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n        if must then\n            File.Copy(from, dest, true )\n    \n    let toDir from destDir =\n        let dest = Path.Combine(destDir, Path.GetFileName(from))\n        toFile from dest\n    ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3af10c2d-9854-4233-bc2b-9aa5213735a0"}, "snpName": "timeMe", "snpContent": "let timeMe order round f p =\n    let before = System.DateTime.UtcNow\n    let r = f p\n    let dur = System.DateTime.UtcNow - before\n    let rnd = if round then order / 2 else 0\n    (dur.Hours * 3_600_000 + dur.Minutes * 60_000 + dur.Seconds * 1000 + dur.Milliseconds + rnd ) / order, r", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3bc3bc4c-8ab8-4370-b0a0-7fd337ffa24c"}, "snpName": "TempFileName", "snpContent": "type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member __.Name = fn\n    interface System.IDisposable with\n        member __.Dispose() = \n            //printfn \"trying to delete %s\"  fn\n            if System.IO.File.Exists fn then (*printfn \"deleting %s\"  fn ;*) System.IO.File.Delete fn \n        \n        ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}, "snpName": "FsCode", "snpContent": "module FsCode =\n    open CommArg\n    open CommArgCollection\n    open FsCode\n    open System.IO\n        \n    let flag t f p = function true -> p + t |_-> p + f\n    let flagpm   p = flag \"+\" \"-\" p\n\n    let intRootDir       = NewString(\"RootDir\"      , true , sprintf  \"++root:%s\"        )\n    let intSnippet       = NewString(\"Snippet\"      , true , sprintf  \"++snippet:%s\"     )\n    let intCreateDir     = NewBool  (\"CreateDir\"    , true , fun v ->  if v then \"++createdirectory\" else \"\")\n    let intDirectory     = NewString(\"Directory\"    , true , sprintf  \"++directory:%s\"   )\n    let intName          = NewString(\"Name\"         , true , sprintf  \"++name:%s\"        )\n    let intExtension     = NewString(\"Extension\"    , true , sprintf  \"++extension:%s\"   )\n    let intFileName      = NewString(\"Filename\"     , true , sprintf  \"++filename:%s\"    )\n    let intOutputFile    = NewString(\"OutputFile\"   , true , sprintf  \"++fileout:%s\"     )\n    let intConfig        = NewString(\"Config\"       , true , sprintf  \"++config:%s\"      )\n    let intCopyConfig    = NewBool  (\"CopyConfig\"   , true , flagpm   \"++copyconfig\"     )\n    let intWebSharper    = NewBool  (\"WebSharper\"   , true , flagpm   \"++websharper\"     )\n    let intStaticLinkAll = NewBool  (\"StaticLinkAll\", true , flagpm   \"++staticlinkall\"  )\n    let intCopyAssem     = NewBool  (\"CopyAssem\"    , true , flagpm   \"++copyassemblies\" )\n    let intShowArgs      = NewBool  (\"ShowArgs\"     , true , flagpm   \"++showargs\"       )\n    let intRemLineDir    = NewBool  (\"RemLineDir\"   , true , flagpm   \"++remlinedir\"     )\n    \n    let internalArgs = \n        Set [\n            intSnippet      .CommArg.cargId\n            intDirectory    .CommArg.cargId\n            intName         .CommArg.cargId\n            intExtension    .CommArg.cargId\n            intFileName     .CommArg.cargId\n            intOutputFile   .CommArg.cargId\n            intConfig       .CommArg.cargId\n            intWebSharper   .CommArg.cargId\n            intStaticLinkAll.CommArg.cargId\n            intCopyAssem    .CommArg.cargId\n            intShowArgs     .CommArg.cargId\n        ]\n\n    let fscIOption     = NewString(\"IOption\"   , false, sprintf \"-I:%A\"          )\n    let fscReference   = NewString(\"Reference\" , false, sprintf \"-r:%A\"          )\n    let fscSource      = NewString(\"Source\"    , false, sprintf \"%A\"             )\n    let fscTarget      = NewString(\"Target\"    , true , sprintf \"--target:%s\"    )\n    let fscPlatform    = NewString(\"Platform\"  , true , sprintf \"--platform:%s\"  )\n    let fscOutput      = NewString(\"Output\"    , true , sprintf \"-o:%A\"          )\n    let fscDebug       = NewString(\"Debug\"     , true , sprintf \"--debug:%s\"     )\n    let fscDefine      = NewString(\"Define\"    , false, sprintf \"--define:%s\"    )\n    let fscStaticLink  = NewString(\"StaticLink\", false, sprintf \"--staticlink:%s\")\n    let fscGenFSharp1  = NewString(\"GenFSharp1\", false, sprintf \"-%s\"            )\n    let fscGenFSharp2  = NewString(\"GenFSharp2\", false, sprintf \"--%s\"           )\n    \n    let FSharpArgs = \n        Set [\n              fscIOption   .CommArg.cargId\n              fscReference .CommArg.cargId\n              fscSource    .CommArg.cargId\n              fscTarget    .CommArg.cargId\n              fscPlatform  .CommArg.cargId\n              fscOutput    .CommArg.cargId\n              fscDebug     .CommArg.cargId\n              fscDefine    .CommArg.cargId\n              fscStaticLink.CommArg.cargId\n              fscGenFSharp1.CommArg.cargId\n              fscGenFSharp2.CommArg.cargId\n    ] \n    \n    let wscWebSite      = NewString(\"Website\"     , true , sprintf \"--wsoutput:%A\"              )\n    let wscProjectPath  = NewString(\"WsProject\"   , true , sprintf \"--project:%A\"               )\n    let wscProjectType  = NewString(\"ProjectType\" , true , sprintf \"--ws:%s\"                    )\n    let wscGenWSharper  = NewString(\"GenWSharper\" , false, sprintf \"--%s\"                       )\n    let wscJSMap        = NewBool  (\"JSMap\"       , false, flagpm  \"--jsmap\"                    )\n    let wscDeadCodeElim = NewBool  (\"DeadCodeElim\", false, flagpm  \"--dce\"                      )\n    let wscWarnOnly     = NewBool  (\"WarnOnly\"    , false, flagpm  \"--wswarnonly\"               )\n    let wscDownloadResc = NewBool  (\"DownloadResc\", false, flagpm  \"--dlres\"                    )\n    let wscPrintJS      = NewBool  (\"PrintJS\"     , false, flagpm  \"--printjs\"                  )\n    let wscClosures     = NewBool  (\"Closures\"    , false, flagpm  \"--closures\"                 )\n    let wscClosrMoveTop = NewBool  (\"ClosrMoveTop\", false, flag    \"--closures:movetotop\" \"\" \"\" )\n    let wscJsOutput     = NewString(\"JsOutput\"    , true , sprintf \"--jsoutput:%A\"              )\n\n    let WebSharpArgs = \n        Set [\n              wscWebSite     .CommArg.cargId\n              wscProjectPath .CommArg.cargId\n              wscProjectType .CommArg.cargId\n              wscGenWSharper .CommArg.cargId\n              wscJSMap       .CommArg.cargId\n              wscDeadCodeElim.CommArg.cargId\n              wscWarnOnly    .CommArg.cargId\n              wscDownloadResc.CommArg.cargId\n              wscPrintJS     .CommArg.cargId\n              wscClosures    .CommArg.cargId\n              wscClosrMoveTop.CommArg.cargId\n              wscJsOutput    .CommArg.cargId\n        ] \n    \n    let dllOptions   () = CommArgCollection [ fscTarget      /= \"library\"                                                                     ] \n    let exeOptions   () = CommArgCollection [ fscTarget      /= \"exe\"     ; intCopyAssem /= true ; intCopyConfig /= true ]\n    let winExeOptions() = CommArgCollection [ fscTarget      /= \"winexe\"  ; intCopyAssem /= true ; intCopyConfig /= true ]\n    \n    module ReaderM = ReaderMResult\n    open ReaderM.Operators\n    \n    let gS v = getStringRm     v\n    let gB v = getBoolRm false v\n\n    let genericOptions () = \n      CommArgCollection\n        [\n//           intSnippet     /= \"Test\"\n            intRootDir     /= Path.GetFullPath \"..\"\n            intName        /= (rtn (fun s     -> String.splitByChar '/' s |> Array.last ) <*> gS intSnippet                                       )\n            intDirectory   /= (rtn (fun r     -> r                                      ) <*> gS intRootDir                                       )\n            intFileName    /= (rtn (fun d n   -> d +/+ \"src\" +/+ n + \".fs\"              ) <*> gS intDirectory  <*> gS intName                     )\n            fscOutput      /= (rtn (fun d n e -> d +/+ \"bin\" +/+ n + \".\" + e            ) <*> gS intDirectory  <*> gS intName <*> gS intExtension )\n            intExtension   /= (rtn (function \"library\" -> \"dll\" |_-> \"exe\"              ) <*> gS fscTarget                                        )\n            intOutputFile  /= (rtn               Path.GetFileName                         <*> gS fscOutput                                        )\n            intConfig      /= (rtn (fun o     -> o + \".config\"                          ) <*> gS intOutputFile                                    )\n            intWebSharper  /=       containsAnyOfRm WebSharpArgs\n            fscSource      /=       gS intFileName\n        ]\n        \n    let siteOptions ()=\n      CommArgCollection\n        [|\n           wscProjectType /=       \"Site\"\n           wscWebSite     /= (rtn (fun d -> d +/+ \"website\" ) <*> gS intDirectory )\n           wscProjectPath /=       gS intName\n           wscJSMap       /=       true\n           wscJsOutput    /= (rtn (fun d n   -> d +/+ n + \"0.js\" ) <*> gS wscWebSite    <*> gS intName                     )\n        |] \n     \n    let wsProjectOptions ()=\n      CommArgCollection\n        [|\n           wscProjectPath /= gS intName\n        |] \n     \n    let debugOptions() = \n      CommArgCollection\n        [|\n           fscGenFSharp1  /= \"g\"\n           fscDebug       /= \"full\"\n           fscDefine      /= \"DEBUG\"\n           fscDefine      /= \"TRACE\"\n           fscGenFSharp2  /= \"optimize-\"\n           fscGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions () =\n      CommArgCollection\n        [|\n           //@\"--noframework\"\n           fscGenFSharp2  /= \"warn:3\"\n           fscGenFSharp2  /= \"warnaserror:76\"\n           fscGenFSharp2  /= \"vserrors\"\n           fscGenFSharp2  /= \"utf8output\"\n           fscGenFSharp2  /= \"fullpaths\"\n           fscGenFSharp2  /= \"flaterrors\"\n           fscGenFSharp2  /= \"subsystemversion:6.00\"\n           fscGenFSharp2  /= \"highentropyva+\"\n           intRemLineDir  /= true\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions()\n        + dllOptions  ()\n        + otherOptions()\n        + intSnippet     /= snp\n        \n    let compileOptionsDllDebug   (snp:string) = compileOptionsDll      snp + debugOptions ()       \n    let compileOptionsExeDebug    snp         = compileOptionsDllDebug snp + exeOptions   ()\n    let compileOptionsWinExeDebug snp         = compileOptionsDllDebug snp + winExeOptions()\n        \n    let prepOptions (args:CommArgCollection<_>) (assembs : string [], defines : string [], prepoIs : string []) =\n        let staticLinksAll = CommArgCollection.getBoolR false intStaticLinkAll args\n        args + [\n            yield! prepoIs |> Array.map ((/=) fscIOption  ) \n            yield! assembs |> Array.map ((/=) fscReference)\n            yield! defines |> Array.map ((/=) fscDefine   )\n            if staticLinksAll = Ok true then \n                yield! assembs |> Array.map (fun f -> fscStaticLink /= System.IO.Path.GetFileNameWithoutExtension f)\n        ]\n        \n    let processArgs code assembs nowarns = reader {        \n        let! show      = gB intShowArgs\n        if show      then let! args = argumentsRm (fun _ -> true)\n                          args |> Seq.sort |> Seq.iter (printfn \"%s\")\n        let! workDir   = getStringRm intDirectory\n        let! fileName  = gS intFileName\n        let! output    = gS fscOutput\n        let! copyAssem = gB intCopyAssem\n        let! createDir = gB intCreateDir\n        let  srcDir    = Path.GetDirectoryName fileName\n        let  outDir    = Path.GetDirectoryName output\n        if createDir then \n                         Directory.CreateDirectory workDir |> ignore\n                         Directory.CreateDirectory  srcDir |> ignore\n                         Directory.CreateDirectory  outDir |> ignore\n        let  code2     = [\n                            yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n                            yield! code \n                         ] |> String.concat \"\\n\"\n        do               File.WriteAllText(fileName, code2)\n        if copyAssem then assembs |> Array.iter (fun f -> outDir |> CopyIfMust.toDir f)      \n    }\n    ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"287b94ba-e7c6-48f0-95f5-9de3685c4036"}, {"SnippetId" :"37faf742-82b0-41ef-977d-262def7e1901"}, {"SnippetId" :"5b38de4c-d07e-4e30-9009-b0d60c55246b"}, {"SnippetId" :"c3be67ee-321f-4eb2-ba98-345957897fec"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"e38ca94f-ab85-4c33-a0fd-4c5190a6ea42"}, "snpName": "FsiEvaluator", "snpContent": "module FsiEvaluator =\n    open System.Diagnostics\n    open RunProcess\n    \n    \n    let inline (+/+) a b = System.IO.Path.Combine(a, b)\n\n    [< Literal >]\n    let endToken = \"xXxY\" + \"yYyhH\"\n    type FsiExe(config:string, workingDir, ?outHndl, ?errHndl) =\n        let mutable silent             = false\n        let fsiexe                     = @\"..\\packages\\FSharp.Compiler.Tools\\tools\" +/+ if config.Contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n        let startInfo                  = ProcessStartInfo(fsiexe, config, WorkingDirectory= workingDir)\n        let outHndlS                   = outHndl |> Option.map(fun outh v -> if silent then () else outh v)\n        let errHndlS                   = errHndl |> Option.map(fun errh v -> if silent then () else errh v)\n        let shell                      = new ShellEx(startInfo, ?outHndl = outHndlS, ?errHndl = errHndlS)  // --noninteractive\n        do  startInfo.CreateNoWindow  <- false\n            shell.Start() |> ignore\n        member __.Eval (FsCode code)   = asyncResult {\n                                             shell.Send code\n                                             shell.Send \";;\"\n                                             return! shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                                         }\n        member oo.IsAlive              = not shell.HasExited\n        member oo.Abort()              = shell.Abort()\n        member oo.EvalSilent code      = asyncResult {\n                                            try     silent <- true\n                                                    return! oo.Eval code\n                                            finally silent <- false\n                                         }\n        interface System.IDisposable with\n            member this.Dispose ()     = (shell :> System.IDisposable).Dispose()\n\n    module ReaderM = ReaderMAsyncResult\n    open ReaderM.Operators\n\n    let evaluateRm   code = (fun (fsi:FsiExe) -> fsi.Eval       code) |> ReaderM.wrap : ReaderM<_,_,_>\n    let evalSilentRm code = (fun (fsi:FsiExe) -> fsi.EvalSilent code) |> ReaderM.wrap : ReaderM<_,_,_>\n", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}, {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}, {"SnippetId" :"a7e4ee55-8458-49ba-96f7-b61f8f268e4f"}, {"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}], "snpProperties": [], "snpGeneration": 177}, {"snpId": {"SnippetId" :"53b5a650-4b7f-471d-8cb4-63c4e0ed0ad6"}, "snpName": "FsiCodePresence", "snpContent": "module FsiCodePresence =\n    module ReaderM = ReaderMAsyncResult\n    open FsiEvaluator\n    open ReaderM.Operators\n\n    let installPresenceRm() = \n        \"\"\"\n        module CodePresence =\n            let mutable present : Map<string, string>  = Map.empty\n            let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n            let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n        \"\"\"\n        |>  String.unindentStr\n        |>  FsCode\n        |>  evalSilentRm \n        |>> ignore\n\n    let addPresenceRm (name:string) (v:string) = reader {\n        let  code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v |> FsCode\n        let! res  = evalSilentRm code\n        match res with\n        | \"ok\" -> ()\n        | _    -> do! installPresenceRm()\n                  do! evalSilentRm code |>> ignore\n    }\n            \n    let getPresenceRm (name:string)   = reader {\n        let! res = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n                   |> FsCode\n                   |> evalSilentRm\n                   |> ReaderM.getResult\n        match res with\n        | Error v                -> do! installPresenceRm()\n                                    return None\n        | Ok v when v = endToken -> do! installPresenceRm()\n                                    return None\n        | Ok \"--\"                -> return None\n        | Ok v                   -> return Some v\n    }\n", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"e38ca94f-ab85-4c33-a0fd-4c5190a6ea42"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a1a3625f-748c-4e87-aaa2-fbe07392235d"}, "snpName": "FsCompiler", "snpContent": "#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\FSharp.Compiler.Service.dll\"\n\nmodule FsCompiler =\n    module ReaderM = ReaderMAsyncResultM\n    open ReaderM.Operators\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open CommArg\n    open FsCode\n    open CommArgCollection\n    \n    let compileRm() = reader {\n        let! args       = argumentsRm (fun (arg,_) -> Set.contains arg.cargId FSharpArgs)\n        let! msgs, exit = args\n                          |> Seq.append [| \"IGNORED_Fsc.exe\" |]\n                          |> Seq.map (fun (s:string) -> s.Replace(\"\\\"\",\"\"))\n                          |> Seq.toArray\n                          |> FSharpChecker.Create().Compile\n        do! msgs |> Seq.map Message |> OkMWithMsgs () \n        do! exit <> 0 |> ResultM.failIfTrue NoMsg\n    }         \n    let compile args = compileRm() |> ReaderM.run args\n    ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"18664e7f-f138-49c5-9eff-c90fdff5f218"}, {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}, {"SnippetId" :"c3be67ee-321f-4eb2-ba98-345957897fec"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}, "snpName": "WsCompiler", "snpContent": "module WsCompiler =\n    module ReaderM = ReaderMAsyncResultM\n    open ReaderM.Operators\n    open System.IO\n    open CommArg\n    open FsCode\n    open CommArgCollection\n    \n    let compileRm() = reader {\n        let  allArgIds  = Set.union WebSharpArgs FSharpArgs \n        let! args       = argumentsRm <| fun (arg,_) -> Set.contains arg.cargId allArgIds\n        let! createDir  = getBoolRm false intCreateDir\n        if createDir then let! site = getStringRm wscWebSite\n                          Directory.CreateDirectory(site) |> ignore\n        let! out, err   = args\n                          |> String.concat \"  \"\n                          |> fun ops -> (new RunProcess.ShellEx(@\"..\\packages\\WebSharper.FSharp\\tools\\net461\\wsfsc.exe\", ops, priorityClass = System.Diagnostics.ProcessPriorityClass.RealTime)).StartAndWaitR()\n        return if out = \"\" then \"Compiled!\" else out + err\n    }\n    let compile args = compileRm() |> ReaderM.run args\n    ", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"18664e7f-f138-49c5-9eff-c90fdff5f218"}, {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}, {"SnippetId" :"c3be67ee-321f-4eb2-ba98-345957897fec"}, {"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}], "snpProperties": [], "snpGeneration": 224}, {"snpId": {"SnippetId" :"64c13907-9cf6-4abf-adad-a43a33b21c42"}, "snpName": "WsTranslate", "snpContent": "module WsTranslate =\n    module ReaderM = ReaderMAsyncResult\n    open ReaderM.Operators\n    open System\n    open System.IO\n    open FsCode\n    open CommArgCollection\n    \n    let translateJs (CommArgCollection args) (FsCode codeFs) = asyncResult {\n        let  code           = codeFs.Split '\\n'\n        let  defines0       = (FsCode.extractDefines <| FsCode codeFs).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n        let  fs, assembs, defines1, prepIs, nowarns, _ = separatePrepros code |> separateDirectives\n        let  defines        = Array.append defines0 defines1\n        let  name           = \"testing\"\n        let  args1          = compileOptionsDll name\n                              + siteOptions()\n                              + wscProjectType /= \"bundle\"\n                              + wscWebSite     /= @\"..\\website\\testing\"\n                              + wscProjectPath /= (getStringRm intFileName |> ReaderMResult.map (fun f -> Path.GetDirectoryName f +/+ @\"wsconfig.json\"))\n                              + args\n        let  args2          = prepOptions args1 (assembs, defines, prepIs)\n        return! reader {\n            let! source     = getStringRm fscSource\n            let! outputJs   = getStringRm wscJsOutput\n            let! output     = getStringRm fscOutput\n            let! directory  = getStringRm intDirectory\n            let! wsconfig   = getStringRm wscProjectPath\n            //use temp1 = new TempFileName(source            )\n            //use temp2 = new TempFileName(outputJs          )\n            use temp3 = new TempFileName(output            )\n            use temp4 = new TempFileName(output + \".failed\")\n            use temp5 = new TempFileName(wsconfig          )\n            //use temp6 = new TempFileName(Path.ChangeExtension(outputJs, \"min.js\"   ) )\n            //use temp7 = new TempFileName(Path.ChangeExtension(outputJs, \"head.js\"  ) )\n            //use temp8 = new TempFileName(Path.ChangeExtension(outputJs, \"head.html\") )\n            //use temp9 = new TempFileName(Path.ChangeExtension(outputJs, \"css\"      ) )\n            File.WriteAllText(wsconfig, sprintf \"\"\"\n                {\n                  \"$schema\"         : \"https://websharper.com/wsconfig.schema.json\",\n                  \"outputDir\"       : \"%s\"\n                }\n            \"\"\"  <| Path.GetDirectoryName(outputJs).Replace(@\"\\\", @\"\\\\\") )\n            do!  processArgs fs assembs nowarns\n            let! res        = WsCompiler.compileRm()\n            return res, File.ReadAllText outputJs\n          } |> ReaderM.run args2\n    }\n//                  \"jsOutput\": %A\n    \n", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"3bc3bc4c-8ab8-4370-b0a0-7fd337ffa24c"}, {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}, {"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 207}, {"snpId": {"SnippetId" :"5c9f3c72-0dd9-47c9-9bf2-7130d92b5bc4"}, "snpName": "WsTranslate2", "snpContent": "#I @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Core.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.FSharp.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\System.Reflection.Metadata.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\FSharp.Compiler.Service.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Pdb.dll\"\r\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Mdb.dll\"\r\n//#r @\"System.Reflection.Metadata.dll\"\r\n\r\nmodule WsTranslate2 =\r\n    open System\r\n    open System.IO\r\n    open System.Reflection\r\n    \r\n    module Re = WebSharper.Core.Resources\r\n    module P  = WebSharper.PathConventions\r\n    open WebSharper.Compiler\r\n    open WebSharper.Compiler.FrontEnd\r\n    open WebSharper.Core\r\n    open WebSharper.Core.Resources\r\n    open WebSharper.Compiler.CommandTools\r\n    open Microsoft.FSharp.Compiler.SourceCodeServices\r\n    open Microsoft.FSharp.Compiler\r\n\r\n    let getIndentFile input =\r\n        match input with\r\n        | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\r\n        | _                                                 -> 0         , input    \r\n            \r\n    type WebSharperError   = AST.SourcePos option * CompilationError\r\n    type WebSharperWarning = AST.SourcePos option * CompilationWarning\r\n    type TranslatorError =\r\n        | MustProvideAssemblyOutputPath\r\n        | MustProvideProjectPath\r\n        | NothingToTranslateToJavaScript\r\n        | WebSharperCompilerReturnedNone\r\n        | OutputAssemblyNotFound         of string\r\n        | FSharpError                    of string\r\n        | FSharpWarning                  of string\r\n        | WebSharperError                of string\r\n        | WebSharperWarning              of string\r\n\r\n    let countTranslatorError =\r\n        function\r\n        | FSharpWarning     _\r\n        | WebSharperWarning _ -> 0, 1, 0\r\n        |                   _ -> 1, 0, 0\r\n\r\n    let fSharpError2TranslatorError (error : FSharpErrorInfo) =\r\n        let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \r\n        sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \r\n            file \r\n            error.StartLineAlternate (error.StartColumn - indent) \r\n            error.EndLineAlternate   (error.EndColumn   - indent) \r\n            error.Subcategory error.ErrorNumber error.Message\r\n        |> (if   error.Severity = FSharpErrorSeverity.Error  \r\n            then FSharpError\r\n            else FSharpWarning\r\n        )\r\n        |> Message\r\n        \r\n    let webSharperError2TranslatorError: WebSharperError -> ResultMessage<_> =\r\n        fun                              (posO, error)   ->\r\n            posO \r\n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\r\n            |> Option.defaultValue \"\"\r\n            |> sprintf \"%s%s\" <| error.ToString()\r\n            |> WebSharperError\r\n            |> Message\r\n            \r\n    let webSharperWarning2TranslatorError: WebSharperWarning -> ResultMessage<_> =\r\n        fun                                (posO, error)     ->\r\n            posO \r\n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\r\n            |> Option.defaultValue \"\"\r\n            |> sprintf \"%s%s\" <| error.ToString()\r\n            |> WebSharperWarning\r\n            |> Message\r\n            \r\n    let PrintGlobalError err = eprintfn \"WebSharper error FS9001: %s\" (ErrorPrinting.NormalizeErrorString err)\r\n\r\n    let CompileToJsW: WsConfig -> AsyncResultM<string, TranslatorError> =\r\n        fun           config   -> asyncResultM {\r\n            if config.ProjectFile  = null then do! Message  MustProvideProjectPath\r\n            if config.AssemblyFile = null then do! Message  MustProvideAssemblyOutputPath\r\n            do!  AsyncResultM.getResultM() |> ResultM.failIfFatalMsg\r\n            let  fsharpChecker       = FSharpChecker.Create( keepAssemblyContents = true)\r\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs |> Array.append [| \"fsc.exe\" |] )\r\n            do!  errors |> Seq.map fSharpError2TranslatorError |> ResultMessage.reduceMsgs\r\n            if exitCode = 0 then do! ErrorM NoMsg\r\n            if File.Exists config.AssemblyFile |> not then do! Message (OutputAssemblyNotFound config.AssemblyFile) \r\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\r\n            do   System.IO.File.Delete config.AssemblyFile\r\n            let  paths               = [   for r in config.References -> \r\n                                               Path.GetFullPath r\r\n                                           yield Path.GetFullPath config.AssemblyFile\r\n                                       ]        \r\n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\r\n            let  loader              = Loader.Create aR (printfn \"%s\")\r\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\r\n            let wsRefsMeta =\r\n                System.Threading.Tasks.Task.Run(fun () ->\r\n                    let mutable refError = false\r\n                    let wsRefs, metas = \r\n                        refs |> List.choose (fun r -> \r\n                            match TryReadFromAssembly FullMetadata r with\r\n                            | None -> None\r\n                            | Some (Ok m) -> Some (r, m)\r\n                            | Some (Error e) ->\r\n                                refError <- true\r\n                                PrintGlobalError e\r\n                                None\r\n                        ) |> List.unzip\r\n                    if refError then None\r\n                    elif List.isEmpty metas then Some ([], [], WebSharper.Core.Metadata.Info.Empty) \r\n                    else\r\n                        try\r\n                            Some (\r\n                                wsRefs, metas,\r\n                                { \r\n                                    WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\r\n                                        Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\r\n                                }\r\n                            )\r\n                        with e ->\r\n                            refError <- true\r\n                            PrintGlobalError (\"Error merging WebSharper metadata: \" + e.Message)\r\n                            None\r\n                )\r\n            let  refMeta = wsRefsMeta.ContinueWith(fun (t: System.Threading.Tasks.Task<_>) -> \r\n                                match t.Result with \r\n                                | Some (_, _, m) -> Some m \r\n                                | _ -> None )\r\n            let  referencedAsmNames     = paths\r\n                                          |> Seq.map (fun i -> \r\n                                              let n = Path.GetFileNameWithoutExtension(i)\r\n                                              n, i\r\n                                          ) |> Map.ofSeq\r\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\r\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\r\n                    //printfn \"assemblyResolveHandler %s\" e.Name\r\n                    let assemblyName    = AssemblyName(e.Name).Name\r\n                    match Map.tryFind assemblyName referencedAsmNames with\r\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\r\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\r\n                    | Some p                                   -> Assembly.LoadFrom(p)\r\n                    | _                                        -> null\r\n                )\r\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\r\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\r\n                                        .Compile(refMeta, config.CompilerArgs, config, config.ProjectFile) \r\n                                |> Result.ofOption (fun () -> Message WebSharperCompilerReturnedNone )\r\n            do!  comp.Errors   |> Seq.map webSharperError2TranslatorError   |> ResultMessage.reduceMsgs\r\n            do!  comp.Warnings |> Seq.map webSharperWarning2TranslatorError |> ResultMessage.reduceMsgs\r\n            do!  comp.Errors   |> Seq.isEmpty |> Result.failIfFalse NoMsg\r\n            let  assem       = loader.LoadRaw assemblyBytes None\r\n            let  getRefMeta()= match wsRefsMeta.Result with | Some (_, _, m) -> m | _ -> WebSharper.Core.Metadata.Info.Empty\r\n            let jsO, currentMeta, sources = ModifyAssembly (Some comp) \r\n                                              (getRefMeta()) \r\n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \r\n                                              config.SourceMap config.AnalyzeClosures assem\r\n            let! js, jsMin   = jsO |> ResultM.ofOption (fun () -> Message NothingToTranslateToJavaScript)\r\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\r\n            use  stringW     = new System.IO.StringWriter()\r\n            use  writer      = new HtmlTextWriter(stringW)\r\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\r\n            let ctx : Resources.Context =\r\n                {\r\n                    WebRoot                 = \"\"\r\n                    DebuggingEnabled        = true\r\n                    DefaultToHttp           = false\r\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\r\n\r\n                    GetAssemblyRendering    = fun name ->\r\n                        //printfn \"GetAssemblyRendering %s\" name\r\n                        if name = thisProject || name = config.ProjectFile\r\n                        then WebSharper.Core.Resources.Rendering.Skip else\r\n                        name\r\n                        |> P.AssemblyId.Create\r\n                        |> pu.JavaScriptPath \r\n                        |> Re.RenderLink\r\n                    GetWebResourceRendering = fun ty resource ->\r\n                        //printfn \"GetWebResourceRendering %A\" ty\r\n                        let id = P.AssemblyId.Create(ty)\r\n                        let kind =\r\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\r\n                                then P.ResourceKind.Script\r\n                                else P.ResourceKind.Content\r\n                        P.EmbeddedResource.Create(kind, id, resource)\r\n                        |> pu.EmbeddedPath\r\n                        |> Re.RenderLink\r\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\r\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\r\n                    ScriptBaseUrl = None\r\n                }            \r\n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\r\n            //js.RenderDependencies(ctx, writer)\r\n            let  includes = stringW.ToString()\r\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\r\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\r\n                            |> String.concat \", \"\r\n            let  f        = js.[1..js.Length - 7] \r\n            return          (sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f)\r\n        }\r\n    \r\n    let compileMainW: string[] -> AsyncResultM<_, _> =\r\n      fun             argv     ->\r\n        let resSplit (r:string) = \r\n            match r.Split(',') with \r\n            | [| res           |] -> (res, None         )\r\n            | [| res; fullName |] -> (res, Some fullName)\r\n            | _ -> argError (\"Unexpected value --resource:\" + r)\r\n        let wsArgs    = ref WsConfig.Empty\r\n        let refs      = ResizeArray()\r\n        let resources = ResizeArray()\r\n        let fscArgs   = ResizeArray()\r\n        let cArgv     =\r\n            [|\r\n                let isRNext = ref false\r\n                for a in argv do\r\n                    match a.Replace(\"\\\"\", \"\") with\r\n                    | \"-r\"   -> isRNext := true\r\n                    | v      -> if !isRNext then\r\n                                    isRNext := false   \r\n                                    yield \"-r:\" + v\r\n                                else\r\n                                    yield v\r\n            |]\r\n        for a in cArgv do\r\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\r\n            try\r\n                match a with\r\n                | \"--wig\"                          -> setProjectType WIG\r\n                | \"--bundle\"                       -> setProjectType Bundle\r\n                | \"--bundleonly\"                   -> setProjectType BundleOnly\r\n                | \"--html\"                         -> setProjectType Html\r\n                | \"--site\"                         -> setProjectType Website\r\n                | StartsWith \"--ws:\" wsProjectType ->\r\n                    match wsProjectType.ToLower() with\r\n                    | \"site\" \r\n                    | \"web\" \r\n                    | \"website\" \r\n                    | \"export\"                     -> setProjectType Website\r\n                    | \"extension\"                  \r\n                    | \"interfacegenerator\"         -> setProjectType WIG\r\n                    | \"bundle\"                     -> setProjectType Bundle\r\n                    | \"html\"                       -> setProjectType Html\r\n                    | \"ignore\"                     -> ()\r\n                    | \"library\"                    -> ()\r\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\r\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\r\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\r\n                | StartsWith \"--jsoutput:\"       j -> wsArgs := { !wsArgs with JSOutputPath  = Some j }\r\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\r\n                | \"--jsmap+\"\r\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \r\n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \r\n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \r\n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\r\n                | \"--debug\"                      \r\n                | \"--debug+\"                     \r\n                | \"--debug:full\"                 \r\n                | \"-g\"                           \r\n                | \"-g+\"                          \r\n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\r\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\r\n                | StartsWith \"-o:\"               o \r\n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile  = o      } ; fscArgs.Add a\r\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\r\n                | StartsWith \"-r:\"               r             \r\n                | StartsWith \"--reference:\"      r -> refs     .Add (Path.GetFullPath r)                ; fscArgs.Add a\r\n                | StartsWith \"--resource:\"       r -> resources.Add (resSplit         r)                ; fscArgs.Add a\r\n                | _                                ->                                                     fscArgs.Add a  \r\n            with e ->\r\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\r\n        fscArgs.Add \"--define:FSHARP41\"\r\n        wsArgs := \r\n            { !wsArgs with \r\n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\r\n                Resources    = resources.ToArray()\r\n                CompilerArgs = fscArgs  .ToArray() \r\n            }\r\n        CompileToJsW !wsArgs\r\n\r\n    module ReaderM = ReaderMAsyncResultM\r\n    open ReaderM.Operators\r\n    open CommArg\r\n    open FsCode\r\n    open CommArgCollection\r\n\r\n    let translateRm() = reader {\r\n        let  allArgIds  = Set.union WebSharpArgs FSharpArgs \r\n        let! args       = argumentsRm <| fun (arg,_) -> Set.contains arg.cargId allArgIds\r\n        let! createDir  = getBoolRm false intCreateDir\r\n        if createDir then let! site = getStringRm wscWebSite\r\n                          Directory.CreateDirectory(site) |> ignore\r\n        let! js         = args |> Seq.toArray |> compileMainW\r\n        return js\r\n    }\r\n    \r\n    let translate args (FsCode codeFs)  = \r\n        let  code           = codeFs.Split '\\n'\r\n        let  defines0       = (FsCode.extractDefines <| FsCode codeFs).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \r\n        let  fs, assembs, defines1, prepIs, nowarns, _ = separatePrepros code |> separateDirectives\r\n        let  defines        = Array.append defines0 defines1\r\n        let  name           = \"testing\"\r\n        let  args1          = compileOptionsDll name\r\n                              + siteOptions()\r\n                              + wscProjectType /= \"site\"\r\n                              + wscWebSite     /= Path.GetFullPath @\"..\\website\\testing\"\r\n                              + wscProjectPath /= (getStringRm intFileName |> ReaderMResult.map (fun f -> Path.GetDirectoryName f +/+ @\"wsconfig.json\"))\r\n                              + args\r\n        let  args2          = prepOptions args1 (assembs, defines, prepIs)\r\n        reader { \r\n            do!  processArgs fs assembs nowarns\r\n            return! translateRm()\r\n         } |> ReaderM.run args2\r\n", "snpParentIdO": {"SnippetId" :"7a447fb5-74db-4cc5-bfa6-4a1529840b30"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"18664e7f-f138-49c5-9eff-c90fdff5f218"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"46850b4a-0f77-476c-b2ae-abe08218496b"}, {"SnippetId" :"6ea8bf32-4429-4608-a74a-4969ef2b74e3"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpName": "LibraryJS", "snpContent": "/// Essentials that run in Javascript (WebSharper)\n#define WEBSHARPER\n[< JavaScript ; AutoOpen >]\nmodule LibraryJS =", "snpParentIdO": {"SnippetId" :"44b60b89-0535-4591-aa79-f910fe6807ad"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c5472475-cbbd-40f8-909e-d2f5ad8b3b61"}, "snpName": "JsCode", "snpContent": "type JsCode = JsCode of string\ntype Url    = Url    of string", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8b5e4cbc-0f4f-43fb-ad55-e2949e15119d"}, "snpName": "Promise", "snpContent": "module Promise =\n    let ofAsyncResult (v: Async<Result<'a,'b>>) : Promise<'a> =\n        new Promise<'a>(fun (resolve, reject) ->\n            Async.StartWithContinuations(v, (function Ok ok -> resolve ok | Error er -> reject <| sprintf \"%A\" er), reject, reject)\n        )", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"628752e6-932e-41f0-a2fd-73955df4560b"}, "snpName": "View", "snpContent": "module View =\n    let insertWO = \n        function\n        | Some v -> View.Map Some v\n        | None   -> View.Const None\n    let [<Inline>] inline consistent   (vl:View<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        View.Sink setPrior vl\n        !prior |> View.FromVar\n\n    let bind = View.Bind\n    let map  = View.Map\n    let rtn  = View.Const\n\n    let (>>=)                              v f = bind f v\n    let rec    traverseSeq     f            sq = let folder head tail = f head >>= (fun h -> tail >>= (fun t -> List.Cons(h,t) |> rtn))\n                                                 Array.foldBack folder (Seq.toArray sq) (rtn List.empty) |> map Seq.ofList\n    let inline sequenceSeq                  sq = traverseSeq id sq\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 154}, {"snpId": {"SnippetId" :"3bfc9588-d56a-42fc-a95c-8c27b60cf85a"}, "snpName": "bindVarEditor", "snpContent": "/// binds an Editor with a Var<string> to avoid annoying jumps to the end when fast typing\r\n/// onChange gets called when the editor changes but not when the var changes\r\nlet bindVarEditor setEvent getVal setVal onChange (var:Var<string>) =\r\n    let editorChanged = ref 0L\r\n    let varChanged    = ref 0L\r\n    setEvent(fun _ ->\r\n        let v = getVal() \r\n        if var.Value <> v then editorChanged := !editorChanged + 1L; var.Value <- v; onChange() \r\n    )\r\n    var.View |> View.Sink (fun _ ->\r\n        if  !editorChanged > !varChanged then varChanged := !editorChanged\r\n        elif getVal() <> var.Value then setVal var.Value\r\n    )\r\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 158}, {"snpId": {"SnippetId" :"284c34e4-1422-44f3-8988-922dd98c16af"}, "snpName": "isUndefined", "snpContent": "[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = v.GetType() = v.GetType()\n    \n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e487b618-571d-4d63-a061-539b291364b9"}, "snpName": "findRootElement", "snpContent": "module Element =\n    let  findRootElement (e:Dom.Element) =\n        if isUndefined e.GetRootNode then JS.Document.Body\n        else\n            let root = e.GetRootNode()\n            if isUndefined root?body \n            then root.FirstChild :?> Dom.Element\n            else root?body  |> unbox<Dom.Element>", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"284c34e4-1422-44f3-8988-922dd98c16af"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ebb5ddf2-0325-4e33-90e5-f5f033206d78"}, "snpName": "newWindowEvalRA", "snpContent": "module RunJs =\n    let newWindow (Url url) = \n        JS.Apply JS.Window \"open\"  [| url |]\n        |> function\n           | null   -> Error <| ErrorMsg \"Could not open new browser, Popup blocker may be active\"\n           | window -> Ok    window\n        \n    let eval  window (JsCode js) = try JS.Apply window \"eval\"  [| (js:string) |]           with e -> printfn \"%A\" e ; sprintf \"%A\" e\n    let focus window             = try JS.Apply window \"focus\" [|             |] |> ignore with e -> printfn \"%A\" e\n    \n    let newWindowEvalRA url js = asyncResult {\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"c5472475-cbbd-40f8-909e-d2f5ad8b3b61"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"252a58ec-9bb6-4617-b763-f084761cfc9d"}, "snpName": "Serializer", "snpContent": "module Serializer =\n    \n    type SerS<'T> = ('T  -> string)        //      Serialization function\n    type SerD<'T> = (obj -> 'T    )        //    deSerialization function\n    type Ser< 'T> = SerS<'T> * SerD<'T>    // both Serialization functions\n    \n    let inline ifUndef  def v   = if isUndefined v then def   else   v\n    let inline ifUndefF def f v = if isUndefined v then def v else f v\n    \n    let (|Exists|_|) field o = if isUndefined o?(field) then None else Some o?(field)\n    \n    let deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n\n    let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n    let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n    let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n    \n    let serFloat  : Ser<float > = sprintU        , (unbox >> ifUndef 0.0   )\n    let serInt    : Ser<int   > = sprintU        , (unbox >> ifUndef 0     )\n    let serBool   : Ser<bool  > = sprintU        , (unbox >> ifUndef false )\n    let serString : Ser<string> = Json.Serialize , (unbox >> ifUndef \"\"    )\n\n    let [< Inline >] inline serId  (get: 'a->System.Guid) (set:System.Guid->'a) (print: 'a->string) : Ser<'a> =\n        let s           = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n        let sQ          = sprintf \"%A\" s\n        let serialize   = fun id       -> get id |> sprintf \"{%10s :%A}\" sQ\n        let deserialize = fun (x: obj) -> x?(s) |> deserGuid |> set\n        serialize, deserialize\n\n    let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * SerS<'D> * ('D -> SerD<'D>) = \n        serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc o -> set (deser o) rc) \n        \n    let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n        let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n        let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, _ser,  deser) ->  deser dim (o?(n)) )   init\n        serialize, deserialize\n    \n    let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser))               )\n    let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toArray)\n    let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toList )\n    let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Set        )\n    let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\") , (unbox<obj  > >> ifUndefF (fun _ -> None     ) (         snd ser   >> Some      ))\n    let serDup serFst serSnd : Ser<'a * 'b    > = (fun (f,s) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s)), (unbox<obj[]> >> ifUndefF (fun _ -> snd serFst null, snd serSnd null ) (fun os -> snd serFst os.[0], snd serSnd os.[1] ) )\n    let serMap serKey serElm : Ser<Map<'k, 'e>> = serDup serKey serElm |> serSeq |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Map)       )\n\n    let serVarField (name:string) (var:'D->Var<'e>) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n        serFuncs |> fun (ser, deser) -> name, (var >> Var.Get >> ser), (fun rc o -> var rc |> Var.Set <| deser o ; rc)\n\n    let serLMdField (name:string) (lmd:'D->ListModel<_,'e>) serE  : string * SerS<'D> * ('D -> SerD<'D>) = \n        let serS              = serSeq serE\n        let serializer   rc   = lmd rc |> (fun lm -> lm.Value) |> fst serS\n        let deserializer rc b = lmd rc |> (fun lm -> lm.Set  ) <| snd serS b ; rc\n        name, serializer, deserializer\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"284c34e4-1422-44f3-8988-922dd98c16af"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2edc3f10-d756-43b3-b576-0fe4b01b83fb"}, "snpName": "LoadFiles", "snpContent": "module LoadFiles =\n\n    let createScript fn =\n        let fileRef = JS.Document.CreateElement(\"script\")\n        fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n        fileRef.SetAttribute(\"src\" , fn                 )\n        fileRef\n    \n    let createCss fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n        fileRef.SetAttribute(\"type\", \"text/css\"       )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    let createHtml fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"import\"         )\n        fileRef.SetAttribute(\"type\", \"text/html\"      )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    let LoadFile(file: string) =\n        let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n        match file with\n        | EndsWith \".js\"   ()\n        | EndsWith \".fsx\"  ()\n        | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                createScript file |> Some\n        | EndsWith \".css\"  ()-> createCss    file |> Some\n        | EndsWith \".html\" ()-> createHtml   file |> Some\n        | _                  -> None\n        |> Option.map         (fun ref -> \n            Async.FromContinuations <| \n                fun (cont, econt, _ccont) -> \n                    try \n                        ref?onload <- cont\n                        JS.Document.Head.AppendChild ref |> ignore\n                    with e -> econt e\n        )\n        |> Option.defaultWith (fun ()  -> async { return () })\n    \n    let LoadFilesAsync(files: string []) =\n        async {\n            if IsClient then\n                for file in files do\n                    do! LoadFile file\n        }\n    ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"284c34e4-1422-44f3-8988-922dd98c16af"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, "snpName": "REGEX", "snpContent": "let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n\nmodule REGEX =\n    let getStartWord (line:string) ch =\n        match line.Substring(0, ch) with\n        | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n        | _                                      -> \"\"          \n    \n    let getEndWord (line:string) ch =\n        match line.Substring(ch) with\n        | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n        | _                                      -> \"\"          ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b7d0bb6e-877c-4923-b4d3-eb34b718200a"}, "snpName": "Hoverable", "snpContent": "[< JavaScript >]\nmodule Hoverable =\n    open WebSharper.UI.Html\n\n    [<NoComparison ; NoEquality>]\n    type Hoverable         = { hover : Var<bool>        } with\n        static member  New() = { hover = Var.Create false }\n        member inline this.Attributes = [ attr.classDynPred (View.Const \"hovering\") this.hover.View\n                                          on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n                                          on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n                                        ]   \n        member inline this.Content    (ds: Doc seq) = div this.Attributes ds\n        member inline this.Content    ( e: Elt    ) = e.OnMouseEnter(fun _ _ -> e.AddClass    \"hovering\") // THIS ONE ADDS ONE EXTRA SPACE\n                                                       .OnMouseLeave(fun _ _ -> e.RemoveClass \"hovering\") // THAT THIS ONE DOES NOT REMOVE      \n        //member inline this.Content    ( e: Elt    ) = e.WithAttrs this.Attributes\n        static member  Demo  = Hoverable.New().Content(Elt.div [ attr.style \"flex-flow: column;\" ] [ text \"Hover over me!\" ])\n\n    let hoverable (e:Elt) = Hoverable.New().Content e\n    ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f70d0c1a-4f68-424b-ae63-c28b83538567"}, "snpName": "ResizeObserver", "snpContent": "[< JavaScript >]\nmodule ResizeObserver =\n\n    [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n    let implementedResizeObserver() = false\n    \n    [< Inline \"new ResizeObserver($_f)\" >]\n    let newResizeObserver (_f: unit->unit) = X<_> \n    \n    [< Inline \"$_ro.observe($_el)\" >]\n    let RObserve _ro (_el:Dom.Element) = X<_> \n    \n    let mutable observers : obj list = []\n    \n    let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n    \n    let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n    \n    let dimsChanged (el:Dom.Element) = \n        let dims = ref <| el.GetBoundingClientRect()\n        fun () ->\n            let ndims = el.GetBoundingClientRect()\n            if domRect2Tuple !dims = domRect2Tuple ndims then false\n            else dims := ndims    ; true\n    \n    let addResizeObserver f el =\n        if implementedResizeObserver() then\n            let ro =  newResizeObserver f\n            observers <- ro::observers\n            RObserve ro el\n        else\n            let changed = dimsChanged el\n            async {\n                while isValidElement el do\n                    do! Async.Sleep 110\n                    if changed() then f()\n            } |> Async.Start\n            ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ae69698e-36ef-498d-b532-34605cd07c67"}, "snpName": "TabStrip", "snpContent": "[< JavaScript >]\nmodule TabStrip =\n    let reorderList (ts:'a list) drag drop =\n        if drop < drag then\n           ts.[0       ..drop - 1     ]\n         @    [      ts.[drag]        ]\n         @ ts.[drop    ..drag - 1     ]\n         @ ts.[drag + 1..ts.Length - 1]\n        else\n           ts.[0..drag - 1            ]\n         @ ts.[drag + 1..drop         ]\n         @    [      ts.[drag]        ]\n         @ ts.[drop + 1..ts.Length - 1]\n    \n    let reorderArray (ts:'a []) drag drop =\n       (if drop < drag then\n          [|\n           ts.[0       ..drop - 1     ]\n           [|        ts.[drag]       |]\n           ts.[drop    ..drag - 1     ]\n           ts.[drag + 1..ts.Length - 1]\n          |]\n        else\n          [|\n           ts.[0..drag - 1            ]\n           ts.[drag + 1..drop         ]\n           [|        ts.[drag]       |]\n           ts.[drop + 1..ts.Length - 1]\n          |]\n       )|> Array.collect id \n    \n    \n    [< NoComparison >]\n    type TabStrip =\n        { selected  : Var<int>\n          tabs      : Var<(System.Guid * (string * Elt)) []>\n          top       : bool\n          horizontal: bool\n          id        : System.Guid\n        } \n    \n    let draggedTab: (TabStrip * int) option ref = ref None\n    \n    let uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n    \n    let selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n    \n    let setSelectedPanel group panelO = \n        selectedPanels.Value <- \n            match panelO with\n            | Some panel -> selectedPanels.Value.Add    (group, panel)\n            | None       -> selectedPanels.Value.Remove  group\n    \n    let mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\n    let RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n    \n    open WebSharper.UI.Html\n    open Hoverable\n    \n    type TabStrip with\n        member this.moveTab from drag drop =\n            let ts = this.tabs.Value\n            let ft = from.tabs.Value\n            let newTabsT =\n                [|\n                 ts.[0       ..drop - 1     ]\n                 [|        ft.[drag]       |]\n                 ts.[drop    ..ts.Length - 1]\n                |]\n                |> Array.collect id\n            let newTabsF =\n                [|\n                 ft.[0       ..drag - 1     ]\n                 ft.[drag + 1..ft.Length - 1]\n                |]\n                |> Array.collect id\n            from.tabs.Value     <- newTabsF\n            this.tabs.Value     <- newTabsT\n            this.selected.Value <- drop\n            if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n            RaiseTabMoved from this\n    \n        member this.reorder drop =\n            match !draggedTab with\n            | None                                      -> ()\n            | Some( from, drag) when from.id <> this.id -> this.moveTab from drag drop\n            | Some(_from, drag)                         ->\n            this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n            let sel = this.selected.Value\n            this.selected.Value <- if    sel = drag                then drop\n                                   elif (sel < drag && sel < drop)\n                                     || (sel > drag && sel > drop) then sel \n                                   elif  sel < drag                then sel + 1\n                                   else                                 sel - 1\n                                   \n        static member New(tabs)    =\n            { selected   = Var.Create 0\n              tabs       = tabs \n              top        = false \n              horizontal = true\n              id         = System.Guid.NewGuid() \n            } \n        static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n        member this.Top         = { this with top        = true  }\n        member this.Bottom      = { this with top        = false }\n        member this.SetTop    t = { this with top        = t     }\n        member this.Horizontal  = { this with horizontal = true  }\n        member this.Vertical    = { this with horizontal = false }\n        member this.Selected    = View.Map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs.View this.selected.View\n        member this.Select    n = this.selected.Value <- n\n        member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n        member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n        member this.Render      =\n            let strip =\n                this.tabs.View\n                |> Doc.BindView (\n                    fun tabs ->\n                        div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\n                                                    (if this.top        then \"top\"        else \"bottom\"  ) \n                                                    (if this.horizontal then \"horizontal\" else \"vertical\")\n                            ]\n                            [\n                              for i, (_uid, (txt, _)) in  tabs |> Seq.indexed  do\n                                  yield Hoverable.New().Content (\n                                    Elt.div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected.View\n                                              attr.draggable \"true\"\n                                              on.dragOver(fun _  ev -> ev.PreventDefault()                            )\n                                              on.drag    (fun _  _  ->                     draggedTab := Some(this, i))\n                                              on.drop    (fun _e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                              on.click   (fun _  _  ->                       this.selected.Value <- i ) \n                                            ]\n                                            [ text txt ]) :> Doc\n                            ] \n                )\n            View.Sink (setSelectedPanel this.id) this.Selected\n            let content = \n                this.tabs.View\n                |> Doc.BindView (fun tabs ->\n                   tabs\n                   |> Seq.map (fun (uid, (_txt, sub)) -> \n//                         sub.WithAttrs(\n//                           [ attr.styleDyn <| View.Map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels.View\n//                             attr.id       <| uid2s uid\n//                           ]) :> Doc)\n                         sub.SetAttribute(\"id\", uid2s uid)\n                         selectedPanels.View\n                         |> View.Sink (fun sels -> sub.SetStyle(\"display\", if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"none\") ) \n                         sub :> Doc)\n                    |> div [ attr.``class`` \"tab-children\" ; attr.id <| uid2s this.id ]\n                 )\n            let css = @\"\n.tab-panel {\n overflow  : hidden   ;\n display   : flex     ;\n flex-flow : column   ;\n background: lightgray;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n        \"\n            div [ attr.``class`` \"tab-panel\" \n                  on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n                  on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n                ]\n                [\n                  (if     this.top then strip else Elt.Empty)\n                  div [ attr.``class`` \"tab-content\" ] [ content ]\n                  (if not this.top then strip else Elt.Empty)\n                  Elt.Element \"style\" [] [ text css ]\n                ]\n                ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"b7d0bb6e-877c-4923-b4d3-eb34b718200a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ed1a05f2-053a-4498-b313-94f586895f39"}, "snpName": "WebComponent", "snpContent": "[< JavaScriptExport >]\nmodule WebComponent =\n\n    [< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\n    let ReflectConstruct () = X<_>\n    \n    [< Inline \"\"\"console.log('defineWebComponent: ' + $_nm);\n                Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n                Object.setPrototypeOf($_c, $global.HTMLElement);\n                Object.setPrototypeOf($_o.prototype, $_c.prototype);\n                $global.customElements.define($_nm, $_o)\"\"\" >]\n    let defineWebComponent _nm _o _c = X<_>\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 86}, {"snpId": {"SnippetId" :"6088955d-501d-4b86-adaf-59b978665fee"}, "snpName": "WcTabStrip", "snpContent": "\nmodule WcTabStrip =\n    open WebSharper.UI.Html\n    open TabStrip\n    type WcTabStripT () =\n        let mutable added = false\n        do printfn \"WcTabStripT initializer\"\n        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n        static member Constructor() = \n            let this = ReflectConstruct()\n            WcTabStripT.NewPointer?call this\n            this\n        member this.connectedCallback() = \n            printfn \"my-el connected %A %A\" added this?outerHTML\n            if not added then\n                let el : Dom.Element = this |> box |> unbox\n                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                let top  = el.HasAttribute \"bottom\" |> not\n                let elsh = JS.Document.CreateElement \"div\"\n                let tabs = [ for i in 1..el.ChildNodes.Length do \n                                  let node = el.ChildNodes.[i - 1]\n                                  if node.NodeType = Dom.NodeType.Element then\n                                      let elem = node :?> Dom.Element\n                                      let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                      yield (tabName, elem)\n                           ]\n                TabStrip.New(tabs |> Seq.map (fun (nm,nd) -> nm, Doc.Static nd :> Doc |> Seq.singleton |> Elt.div []) )\n                |> (fun ts -> if top then ts.Top.Render else ts.Bottom.Render)\n                |> Doc.Run elsh\n                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                added <- true\n    let init =\n        lazy\n            let x = WcTabStripT().connectedCallback\n            if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n    ", "snpParentIdO": {"SnippetId" :"ed1a05f2-053a-4498-b313-94f586895f39"}, "snpPredIds": [{"SnippetId" :"ae69698e-36ef-498d-b532-34605cd07c67"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"bada8694-5447-472a-835e-60d522f6d9d9"}, "snpName": "WcTabStrip2", "snpContent": "module WcTabStrip =\r\n    open WebSharper.UI.Html\r\n    //open TabStrip\r\n    open Hoverable\r\n\r\n    let css = @\"\r\n.tab-panel {\r\n overflow  : hidden   ;\r\n display   : flex     ;\r\n flex-flow : column   ;\r\n background: lightgray;\r\n height    : 100%    ;\r\n width     : 100%    ;\r\n}\r\n.tab-content {\r\n flex      : 1 1     ;\r\n overflow  : auto    ;\r\n position  : relative;\r\n}\r\n.tab-children {\r\n height    : 100%    ;\r\n width     : 100%    ;\r\n position  : absolute;\r\n display   : grid    ;\r\n}\r\n.tab-strip {\r\n padding   : 0pt     ;\r\n flex      : 0 0     ;\r\n}\r\n.tab {\r\n border     : 0.2pt solid transparent;\r\n padding    : 0pt 4pt;\r\n display    : inline-block;\r\n font-family: sans-serif;\r\n font-weight: 200;\r\n font-size  : small;\r\n color      : #666;\r\n cursor     : pointer;\r\n}\r\n.top>.tab {\r\n border-radius: 2pt 2pt 0pt 0pt;\r\n border-bottom-width: 0pt;\r\n vertical-align: bottom;\r\n}\r\n.bottom>.tab {\r\n border-top-width: 0pt;\r\n border-radius: 0pt 0pt 2pt 2pt;\r\n vertical-align: top;\r\n}\r\n.horizontal>.tab:not(:first-child) {\r\n border-left-width: 0pt;\r\n}\r\n.tab.hovering {\r\n background: red;\r\n}\r\n.tab.selected {\r\n background: white;\r\n border-left-width: 0.2pt;\r\n color: black;\r\n font-weight: 500;\r\n border-color: black;\r\n}\r\n.horizontal>.tab.selected {\r\n border-left-width: 0.2pt;\r\n}\r\n::slotted(*              ) { \r\n width : 100%;\r\n height: 100%;\r\n}\r\n        \"\r\n\r\n    let tabStrip (selected:Var<int>) top horizontal tabs content =\r\n        let strip =\r\n            div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\r\n                                        (if top        then \"top\"        else \"bottom\"  ) \r\n                                        (if horizontal then \"horizontal\" else \"vertical\")\r\n                ]\r\n                [ for i, (txt, _) in  tabs |> Seq.indexed  do\r\n                      yield Hoverable.New().Content (\r\n                          Elt.div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i + 1 then \" selected\" else \"\")) selected.View\r\n                                    attr.draggable \"true\"\r\n                                    on.click   (fun _  _  -> selected.Value <- i + 1 ) \r\n                                  ]\r\n                                  [ text txt ]) :> Doc\r\n                ] \r\n        div [ attr.``class`` \"tab-panel\" \r\n                //on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\r\n                //on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\r\n            ]\r\n            [   if     top then yield strip\r\n                yield div [ attr.``class`` \"tab-content\" ] [ content ]\r\n                if not top then yield strip\r\n                yield Elt.Element \"style\" [] [ text css ] :> Doc\r\n                yield Elt.Element \"style\" [] \r\n                        [ Doc.TextView <| View.Map (sprintf \"\"\"\r\n                              ::slotted(*              ) { display: none }\r\n                              ::slotted(*:nth-child(%d)) { display: grid }\r\n                           \"\"\") selected.View \r\n                        ] \r\n                    :> Doc\r\n            ]\r\n\r\n    type WcTabStripT () =\r\n        let mutable added = false\r\n        let selected = Var.Create 1\r\n        do printfn \"WcTabStripT initializer\"\r\n        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcTabStrip.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\r\n        static member Constructor() = \r\n            let this = ReflectConstruct()\r\n            WcTabStripT.NewPointer?call this\r\n            this\r\n        member this.connectedCallback() = \r\n            //printfn \"my-el connected %A %A\" added this?outerHTML\r\n            if not added then\r\n                let el : Dom.Element = this |> box |> unbox\r\n                let shadowRoot       = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\r\n                let elsh = JS.Document.CreateElement \"div\"\r\n                shadowRoot.AppendChild elsh |> ignore\r\n                let addTab () =\r\n                    //printfn \"my-el modified %A %A\" added this?outerHTML\r\n                    let top  = el.HasAttribute \"bottom\" |> not\r\n                    let tabs = [ for i in 1..el.ChildNodes.Length do \r\n                                    let node = el.ChildNodes.[i - 1]\r\n                                    if node.NodeType = Dom.NodeType.Element then\r\n                                        let elem = node :?> Dom.Element\r\n                                        let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\r\n                                        yield (tabName, elem)\r\n                                ]\r\n                    while elsh.ChildNodes.Length > 0 do\r\n                        elsh.RemoveChild elsh.LastChild |> ignore\r\n                    Elt.Element \"slot\" [] []\r\n                    |> tabStrip selected top true tabs\r\n                    |> Doc.Run elsh\r\n                addTab()\r\n                el.AddEventListener(\"DOMSubtreeModified\", delayed 50 addTab)\r\n                added <- true\r\n    let init =\r\n        lazy\r\n            let x = WcTabStripT().connectedCallback\r\n            if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\r\n    ", "snpParentIdO": {"SnippetId" :"ed1a05f2-053a-4498-b313-94f586895f39"}, "snpPredIds": [{"SnippetId" :"b7d0bb6e-877c-4923-b4d3-eb34b718200a"}, {"SnippetId" :"c99a4630-f3cc-46e1-8977-06ec20d898ea"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"48cbe0de-d55e-4187-8c13-c6fb1684e4d4"}, "snpName": "WcSplitter", "snpContent": "module WcSplitter =    \n    open ResizeObserver\n    \n    type Layout = View<string> -> (Dom.Element -> unit) -> (Dom.Element -> unit) -> (Dom.MouseEvent -> unit) -> View<string> -> Doc\n    \n    let mutable layoutHorizontal : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n    let mutable layoutVertical   : Layout = fun partSizes afterRender afterRenderSp mouseDown gap -> Doc.Empty\n    \n    type WcSplitterT () =\n        let mutable added = false\n        do printfn \"WcSplitterT initializer\"\n        [< Inline \"\"\"$global.FsRoot.LibraryJS.WebComponent.WcSplitter.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n        static member Constructor() = \n            let this = ReflectConstruct()\n            WcSplitterT.NewPointer?call this\n            this\n        member this.connectedCallback() = \n            //printfn \"my-el connected %A %A\" added this?outerHTML\n            if not added then\n                let el : Dom.Element = this |> box |> unbox\n                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                let elsh        = JS.Document.CreateElement \"div\"\n                let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n                let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n                let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n                let first       =    el.HasAttribute \"second\"   |> not\n                let vertical    =    el.HasAttribute \"vertical\"\n                let size        = ref        (0.0, 0.0)\n                let padding     = ref         0.0\n                let gap         = Var.Create  0.0\n                let sizeCalc (sh:Dom.Element) : float * float =\n                    let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                                 else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                    let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                    let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                    gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                    padding := pt + pb\n                    el.GetBoundingClientRect() \n                    |> fun r -> \n                         match vertical, first with\n                         | true , true  ->  r.Width , r.Height \n                         | true , false -> -r.Width , r.Height\n                         | false, true  ->  r.Height, r.Width\n                         | false, false -> -r.Height, r.Width\n                let dragging : bool               ref = ref false   \n                let startP   : float              ref = ref 0.0\n                let start    : float              ref = ref 0.0\n                let domElem  : Dom.Element option ref = ref None                 \n                let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                let drag (ev: Dom.Event) =\n                    ev :?> Dom.MouseEvent\n                    |> mouseCoord\n                    |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                    |> fun v   -> value.Value <- min maxV (max minV v)\n                   \n                let rec finishDragging (_: Dom.Event) =\n                    if !dragging then\n                        dragging := false\n                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                let startDragging (ev: Dom.MouseEvent) =\n                    if not !dragging then\n                        dragging := true\n                        startP   := value.Value\n                        start    := mouseCoord ev\n                        size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                        ev.PreventDefault()\n                    //div [\n                    //    SomeAttr  <| on.mouseDown startDragging\n                    //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                    //    style     <| styleSplitter !gap\n                    //    style        \"z-index: 10; background-color: #eef\"\n                    //]\n                let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                             , (sz - gap - pad) * (100.0 - spl) / 100.0\n                let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n                let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n                //div [ \n                //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                //    style <| Val.map styleSizes value\n                //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                //    slot [ name \"splitter\" ; splitter                                               ]\n                //]\n                let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n                //addResizeObserver recalc el\n                (if vertical then layoutVertical else layoutHorizontal)\n                    <| View.Map styleSizes value.View\n                    <| fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc()\n                    <| fun  sp              -> domElem :=          Some sp ; recalc()\n                    <| fun  me              -> startDragging me\n                    <| View.Map (sprintf \"%Apx\") gap.View\n                |> Doc.Run elsh\n                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                added <- true\n    let init layoutH layoutV =\n        let x = WcSplitterT().connectedCallback\n        layoutHorizontal <- layoutH\n        layoutVertical   <- layoutV\n        if IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n    ", "snpParentIdO": {"SnippetId" :"ed1a05f2-053a-4498-b313-94f586895f39"}, "snpPredIds": [{"SnippetId" :"f70d0c1a-4f68-424b-ae63-c28b83538567"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"cf5e8897-67ea-4ff2-af55-7cf7b7c71b50"}, "snpName": "CodeMirror", "snpContent": "module CodeMirror =\n    open WebSharper.UI.Html\n\n    type Pos = { line: int ; ch  : int }\n    let inline cmPos(l, c) = { line = l ; ch  = c }\n    \n    type Editor() =\n        do ()\n      with\n        [< Inline \"$global.CodeMirror($_elt)\"       >] static member SetupEditor _elt                          : Editor          = X<_>\n        [< Inline \"$cdmr.getValue()\"                >] member cdmr.GetValue()                                  : string          = X<_>\n        [< Inline \"$cdmr.setValue($_v)\"             >] member cdmr.SetValue(_v:string)                         : unit            = X<_>\n        [< Inline \"$cdmr.refresh()\"                 >] member cdmr.Refresh()                                   : unit            = X<_>\n        [< Inline \"$cdmr.setOption($_o, $_v)\"       >] member cdmr.SetOption(_o:string, _v:obj)                : unit            = X<_>\n        [< Inline \"$cdmr.getOption($_o)\"            >] member cdmr.GetOption(_o:string)                        : obj             = X<_>\n        [< Inline \"$cdmr.getCursor()\"               >] member cdmr.GetCursor()                                 : Pos             = X<_>\n        [< Inline \"$cdmr.setCursor($_line, $_col)\"  >] member cdmr.SetCursor(_line:int, _col:int)              : unit            = X<_>\n        [< Inline \"$cdmr.performLint()\"             >] member cdmr.PerformLint()                               : unit            = X<_>\n        [< Inline \"$cdmr.focus()\"                   >] member cdmr.Focus()                                     : unit            = X<_>\n        [< Inline \"$cdmr.getLine($_l)\"              >] member cdmr.GetLine(_l:int)                             : string          = X<_>\n        [< Inline \"$cdmr.getDoc().clearHistory()\"   >] member cdmr.ClearHistory()                              : unit            = X<_>\n        [< Inline \"$cdmr.on($_event, $_f)\"          >] member cdmr.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n        [< Inline \"$cdmr.on($_event, $_f)\"          >] member cdmr.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n        [< Inline \"$cdmr.addKeyMap($_keyMap)\"       >] member cdmr.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n        [< Inline \"$cdmr.getWrapperElement()\"       >] member cdmr.GetWrapperElement()                         : Dom.Element     = X<_>\n        [< Inline \"$cdmr.replaceSelection($_v, $_s)\">] member cdmr.ReplaceSelection(_v:string, _s:string)                        = ()\n        [< Inline \"while($cdmr.getAllMarks().length > 0) { $cdmr.getAllMarks()[0].clear() }\" >] member cdmr.RemoveMarks() : unit = X<_>\n        [< Inline \"$cdmr.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n        member cdmr.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n    \n    [<NoComparison ; NoEquality>]\n    type CodeMirror = {\n        var             : Var<string>\n        onChange        : (unit   -> unit)\n        onRender        : (Editor -> unit) option\n        mutable editorO :  Editor option\n        disabled        : View<bool>\n    }\n    \n    let newVar var = \n        { var      = var \n          onChange = ignore\n          onRender = None\n          editorO  = None\n          disabled = V false\n        }\n    let includes =\n       [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n          //\"/EPFileX/codemirror/scripts/intellisense.js\"                      \n          \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n          \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n          \"/EPFileX/codemirror/scripts/codemirror/mode/none.js\"            \n          \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n          \"/EPFileX/codemirror/scripts/codemirror/mode/css.js\"            \n          \"/EPFileX/codemirror/scripts/codemirror/mode/javascript.js\"            \n          \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"            \n          \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n          \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n          \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n          \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n          \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n          \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n          \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n          \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n          \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n       |]        \n    let render cdmr             =\n        div [ on.afterRender (fun elchild ->\n                     async {\n                         do! LoadFiles.LoadFilesAsync includes\n                         let editor        = Editor.SetupEditor elchild.ParentElement\n                         elchild.ParentNode.RemoveChild elchild |> ignore\n                         cdmr.editorO     <- Some editor\n                         cdmr.onRender |> Option.iter (fun onrender -> onrender editor)\n                         cdmr.var |> bindVarEditor (fun f -> editor.On(\"changes\",(f:Editor * obj -> unit)) )  editor.GetValue (fun v -> editor.SetValue v ; editor.ClearHistory() ) cdmr.onChange\n                         cdmr.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                     } |> Async.Start\n                  )    \n            ] []\n    let inline setVar   v   cdmr = { cdmr with var       = v      }\n    let inline onChange f   cdmr = { cdmr with onChange  = f      }\n    let inline onRender f   cdmr = { cdmr with onRender  = Some f }\n    let inline disabled dis cdmr = { cdmr with disabled  = dis    }\n    let inline var          cdmr = cdmr.var\n    let newText(v:string)             = newVar (Var.Create v)\n    let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                        |> newVar\n                                        |> disabled(V (Option.isNone v.V))\n\n    module Hint =\n        type Hint = {\n            text        : string\n            displayText : string\n            className   : string\n        }\n        \n        type Response  = {\n            list           : Hint []\n            from           : Pos   \n            ``to``         : Pos   \n        }\n        \n        type Func      = FuncWithArgs<Editor * (Response -> unit) * obj,  unit>\n        \n        type Options   = {\n            hint           : Func\n            completeSingle : bool   \n            container      : Dom.Element\n        }\n        \n        [< Inline \"($_v.hint.async = 1, $_ed.showHint($_v))\"          >]\n        let showHint_ (_ed:Editor) _v : unit       = X<_>\n        let showHints ( ed:Editor) getHints completeSingle _ =\n            showHint_   ed\n                {  completeSingle = completeSingle\n                   hint           = Func getHints\n                   container      = ed.GetWrapperElement() |> Element.findRootElement\n                }\n\n    module Lint =\n        type Response  = {\n            message        : string\n            severity       : string\n            from           : Pos   \n            ``to``         : Pos   \n        }\n        \n        type Func      = FuncWithArgs<string * (Response[] -> unit) * obj * Editor,  unit>\n        \n        [< Inline \"($_ed.setOption('lint', { async: 1, getAnnotations: $_f, container: $_elm }))\"          >]\n        let setLint_(_ed:Editor) (_f:Func) (_elm:Dom.Element)  : unit = X<_>\n        let setLint ( ed:Editor)   getAnnotations       = \n            setLint_  ed (Func getAnnotations) (ed.GetWrapperElement() |> Element.findRootElement)\n        \n                        \n                ", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"2edc3f10-d756-43b3-b576-0fe4b01b83fb"}, {"SnippetId" :"3bfc9588-d56a-42fc-a95c-8c27b60cf85a"}, {"SnippetId" :"e487b618-571d-4d63-a061-539b291364b9"}], "snpProperties": [], "snpGeneration": 158}, {"snpId": {"SnippetId" :"f0e7bfb2-3e35-4979-b803-20a280dc2086"}, "snpName": "Monaco", "snpContent": "module Monaco =\n    open WebSharper.UI.Html\n\n    type Position = {\n        column     : int\n        lineNumber : int\n    }\n    type Range = {\n        startColumn     : int\n        endColumn       : int\n        startLineNumber : int\n        endLineNumber   : int\n    }\n    type Uri = {\n        authority : string\n        fragment  : string\n        fsPath    : unit->string\n        path      : string\n        query     : string\n        scheme    : string\n    }  with\n        [< Inline \"$global.monaco.Uri.parse($_s)\" >] static member Parse(_s)      : Uri   = X<_>\n        [< Inline \"$global.monaco.Uri.file($_f)\"  >] static member File(_f)       : Uri   = X<_>\n    type Location = {\n        range : Range\n        uri   : Uri\n    }\n    type FindMatch = {\n        matches : string []\n        range   : Range\n    }\n    type WordAtPosition = {\n        endColumn   : int\n        startColumn : int\n        word        : string\n    }\n    type Model = {\n        uri         : Uri\n    }\n      with\n        [< Inline \"$mo.findMatches($_s, $_o, $_r, $_c, $_w, $_p, $_l)\" >] member mo.FindMatches(_s: string, _o: bool, _r: bool, _c: bool, _w: string, _p: bool, _l: int): FindMatch[] = X<_>\n        [< Inline \"$mo.getWordAtPosition($_p)                        \" >] member mo.GetWordAtPosition(_p: Position) : WordAtPosition = X<_>\n        [< Inline \"$mo.getLineContent($_l)                           \" >] member mo.GetLineContent(   _l: int     ) : string         = X<_>\n        [< Inline \"$mo.getValue()                                    \" >] member mo.GetValue()                      : string         = X<_>\n        [< Inline \"$mo.setValue($_v)                                 \" >] member mo.SetValue(_v:string)             : unit           = X<_>\n        [< Inline \"$mo.dispose()                                     \" >] member mo.Dispose()                       : unit           = X<_>\n        \n    type MarkDownString = {\n        value      : string\n        isTrusted  : bool\n    }\n    type MarkerSeverity =\n    | Error   = 8\n    | Hint    = 1\n    | Info    = 2\n    | Warning = 4\n    type MarkerData = {\n        startColumn        : int\n        endColumn          : int\n        startLineNumber    : int\n        endLineNumber      : int\n        severity           : MarkerSeverity\n        message            : string\n        //code : string\n        //relatedInformation : string\n        //source             : string\n        //tags               : MarkerTag[]\n    }\n    type CompletionItemKind =\n    | Class       = 6\n    | Color       = 15\n    | Constructor = 3\n    | Enum        = 12\n    | Field       = 4\n    | File        = 16\n    | Folder      = 18\n    | Function    = 2\n    | Interface   = 7\n    | Keyword     = 13\n    | Method      = 1\n    | Module      = 8\n    | Property    = 9\n    | Reference   = 17\n    | Snippet     = 14\n    | Text        = 0\n    | Unit        = 10\n    | Value       = 11\n    | Variable    = 5\n    type CompletionItem = {\n        kind                : CompletionItemKind\n        label               : string\n        //additionalTextEdits : string\n        //command             : string\n        //commitCharacters    : string\n        detail              : string\n        //documentation       : string\n        //filterText          : string\n        //insertText          : string\n        //range               : string\n        //sortText            : string\n        //textEdit            : string\n    }\n    type Hover = {\n        contents   : MarkDownString []\n        range      : Range\n    }\n    \n    open WebSharper.Core.Resources\n\n    type MonacoResources() =\n        inherit BaseResource(@\"/EPFileX/monaco/package/min/vs/loader.js\")\n\n    [< Require(typeof<MonacoResources>) >]\n    type Editor() =\n        do ()\n      with\n        [< Inline \"$global.require.config({ paths: { 'vs': '/EPFileX/monaco/package/min/vs' }});\" >] static member RequireConfig ()     : unit    = X<_>\n        [< Inline \"$global.require(['vs/editor/editor.main'], $_s, $_f)\"                          >] static member Require(_s, _f)      : unit    = X<_>\n        [< Inline \"$global.monaco.editor.create($_elt, $_op, $_ov)\"                               >] static member Create _elt _op _ov  : Editor  = X<_>\n        [< Inline \"$global.monaco.editor.createModel($_t, $_l, $_u)\">] static member CreateModel(_t:string, _l:string, _u:Uri)          : Model   = X<_>\n        [< Inline \"$global.monaco.editor.getModel($_u)\"             >] static member GetModel(_u:Uri)                                   : Model   = X<_>\n        [< Inline \"$global.monaco.editor.getModels()\"               >] static member GetModels()                                        : Model[] = X<_>\n        [< Inline \"$global.monaco.editor.setModelLanguage($_m, $_l)\">] static member SetModelLanguage(_m:Model, _l:string)              : unit    = X<_>\n        [< Inline \"$global.monaco.editor.setTheme($_t)\"                                           >] static member SetTheme(_t:string)  : unit    = X<_>\n        [< Inline \"$global.monaco.languages.registerHoverProvider($_l, $_p)\"          >] static member RegisterHoverProvider         (_l: string, _p: obj): System.IDisposable   = X<_>\n        [< Inline \"$global.monaco.languages.registerDefinitionProvider($_l, $_p)\"     >] static member RegisterDefinitionProvider    (_l: string, _p: obj): System.IDisposable   = X<_>\n        [< Inline \"$global.monaco.languages.registerCompletionItemProvider($_l, $_p)\" >] static member RegisterCompletionItemProvider(_l: string, _p: obj): System.IDisposable   = X<_>\n        [< Inline \"$global.monaco.editor.setModelMarkers($_m,$_o,$_k)\"       >] static member SetModelMarkers(_m:Model, _o:string, _k:MarkerData[]):unit = X<_>\n        \n        [< Inline \"$monc.getValue()                  \" >] member monc.GetValue()                                  : string          = X<_>\n        [< Inline \"$monc.setValue($_v)               \" >] member monc.SetValue(_v:string)                         : unit            = X<_>\n        [< Inline \"$monc.onDidChangeModelContent($_f)\" >] member monc.OnDidChangeModelContent(_f:obj->unit)       : unit            = X<_>\n        [< Inline \"$monc.getModel()                  \" >] member monc.GetModel()                                  : Model           = X<_>  \n        [< Inline \"$monc.setModel($_m)               \" >] member monc.SetModel(_m:Model)                          : unit            = X<_>  \n        [< Inline \"$monc.layout()                    \" >] member monc.Layout()                                    : unit            = X<_>\n        [< Inline \"$monc.updateOptions($_o)\"           >] member monc.UpdateOptions(_o:obj)                       : unit            = X<_>\n        [< Inline \"$monc.setPosition($_p)            \" >] member monc.SetPosition(_p:Position)                    : unit            = X<_>\n        [< Inline \"$monc.focus()                     \" >] member monc.Focus()                                     : unit            = X<_>\n        \n//        [< Inline \"$monc.refresh()\"                 >] member monc.Refresh()                                   : unit            = X<_>\n//        [< Inline \"$monc.setOption($_o, $_v)\"       >] member monc.SetOption(_o:string, _v:obj)                : unit            = X<_>\n//        [< Inline \"$monc.getOption($_o)\"            >] member monc.GetOption(_o:string)                        : obj             = X<_>\n//        //[< Inline \"$monc.getCursor()\"               >] member monc.GetCursor()                                 : Pos             = X<_>\n//        [< Inline \"$monc.performLint()\"             >] member monc.PerformLint()                               : unit            = X<_>\n//        [< Inline \"$monc.focus()\"                   >] member monc.Focus()                                     : unit            = X<_>\n//        [< Inline \"$monc.getLine($_l)\"              >] member monc.GetLine(_l:int)                             : string          = X<_>\n//        [< Inline \"$monc.getDoc().clearHistory()\"   >] member monc.ClearHistory()                              : unit            = X<_>\n//        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f:(Editor * obj)->unit) : unit            = X<_>\n//        [< Inline \"$monc.on($_event, $_f)\"          >] member monc.On(_event: string, _f: Editor       ->unit) : unit            = X<_>\n//        [< Inline \"$monc.addKeyMap($_keyMap)\"       >] member monc.AddKeyMap(_keyMap: obj)                     : unit            = X<_>\n//        [< Inline \"$monc.getWrapperElement()\"       >] member monc.GetWrapperElement()                         : Dom.Element     = X<_>\n//        [< Inline \"$monc.replaceSelection($_v, $_s)\">] member monc.ReplaceSelection(_v:string, _s:string)                        = ()\n//        [< Inline \"while($monc.getAllMarks().length > 0) { $monc.getAllMarks()[0].clear() }\" >] member monc.RemoveMarks() : unit = X<_>\n//        [< Inline \"$monc.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n//        member monc.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n    \n    [<NoComparison ; NoEquality>]\n    type MonacoConfig = {\n        var             : Var<string>\n        onChange        : (unit   -> unit)\n        onRender        : (Editor -> unit) option\n        mutable editorO :  Editor option\n        disabled        : View<bool>\n        options         : obj\n        overrides       : obj\n    }\n    \n    [< Inline \"var m = $global.require('vs/base/common/lifecycle'); return new m.ImmortalReference($_v);\" >]\n    let newImmortalReference _v = X<_>\n    \n    let newVar var    = \n        { var         = var \n          onChange    = ignore\n          onRender    = None\n          editorO     = None\n          disabled    = V false\n          options     = null\n          overrides   = null\n        }\n    //let includes = [| @\"/EPFileX/monaco/package/min/vs/loader.js\" |]\n    let loader = async {\n        if IsClient then\n            //do! LoadFiles.LoadFilesAsync includes\n            Editor.RequireConfig()\n            do! Async.FromContinuations(fun (success, failed, cancelled) -> Editor.Require(success, failed))\n    }\n    let render monc             =\n        div [ on.afterRender (fun elchild ->\n                 async {\n                     do! loader\n                     let editor        = Editor.Create elchild.ParentElement monc.options monc.overrides\n                     ResizeObserver.addResizeObserver editor.Layout elchild.ParentElement\n                     elchild.ParentNode.RemoveChild elchild |> ignore\n                     monc.editorO     <- Some editor\n                     monc.onRender |> Option.iter (fun onrender -> onrender editor)\n                     monc.var |> bindVarEditor editor.OnDidChangeModelContent editor.GetValue editor.SetValue monc.onChange\n                     //monc.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                 } |> Async.Start\n              )    \n            ] []\n    let inline setVar   v   monc = { monc with var       = v      }\n    let inline onChange f   monc = { monc with onChange  = f      }\n    let inline onRender f   monc = { monc with onRender  = Some f }\n    let inline disabled dis monc = { monc with disabled  = dis    }\n    let inline var          monc = monc.var\n    let newText(v:string)             = newVar (Var.Create v)\n    let newVarO(v:Var<string option>) = Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )\n                                        |> newVar\n                                        |> disabled(V (Option.isNone v.V))\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"2edc3f10-d756-43b3-b576-0fe4b01b83fb"}, {"SnippetId" :"3bfc9588-d56a-42fc-a95c-8c27b60cf85a"}, {"SnippetId" :"f70d0c1a-4f68-424b-ae63-c28b83538567"}], "snpProperties": [], "snpGeneration": 223}, {"snpId": {"SnippetId" :"91de3802-48c5-43ca-a03a-477dfefc99be"}, "snpName": "AppFramework", "snpContent": "[< JavaScriptExport >]\r\nmodule AppFramework =\r\n\r\n    type PlugInVar = {\r\n        varName        : string\r\n        varVar         : Var<string>\r\n    }\r\n\r\n    type PlugInView = {\r\n        viwName        : string\r\n        viwView        : View<string>\r\n    }\r\n\r\n    type DocFunction =\r\n    | LazyDoc of Lazy<Doc>\r\n    | FunDoc1 of (                                        string -> Doc) * string                                     \r\n    | FunDoc2 of (                              string -> string -> Doc) * string * string                            \r\n    | FunDoc3 of (                    string -> string -> string -> Doc) * string * string * string                   \r\n    | FunDoc4 of (          string -> string -> string -> string -> Doc) * string * string * string * string          \r\n    | FunDoc5 of (string -> string -> string -> string -> string -> Doc) * string * string * string * string * string  \r\n\r\n\r\n    type PlugInDoc = {\r\n        docName        : string\r\n        docDoc         : DocFunction\r\n    }\r\n\r\n    type ActFunction =\r\n    | FunAct0 of (                                         unit -> unit)\r\n    | FunAct1 of (                                          obj -> unit) * string\r\n    | FunAct2 of (                                   obj -> obj -> unit) * string * string\r\n\r\n    type PlugInAction = {\r\n        actName        : string\r\n        actFunction    : ActFunction\r\n        actEnabled     : View<bool>\r\n    }\r\n\r\n    type PlugInQuery = {\r\n        qryName        : string\r\n        qryFunction    : obj -> obj\r\n    }\r\n\r\n    type PlugIn = {\r\n        plgName        : string\r\n        plgVars        : PlugInVar   []\r\n        plgViews       : PlugInView  []\r\n        plgDocs        : PlugInDoc   []\r\n        plgActions     : PlugInAction[]\r\n        plgQueries     : PlugInQuery []\r\n    }\r\n\r\n    let plugIns = ListModel (fun plg -> plg.plgName)\r\n\r\n    let mainDocV = Var.Create \"AppFramework.AppFwkClient\"\r\n\r\n    open WebSharper.UI.Templating\r\n\r\n    let [< Literal >] TemplateFileName =  @\"..\\website\\AppFramework.html\" \r\n\r\n    type AppFwkTemplate = Templating.Template<TemplateFileName, ClientLoad.Inline, ServerLoad.WhenChanged, LegacyMode.New>\r\n\r\n    let defaultPlugIn = {\r\n            plgName    = \"\"\r\n            plgVars    = [| |]\r\n            plgViews   = [| |]\r\n            plgDocs    = [| |]\r\n            plgActions = [| |]\r\n            plgQueries = [| |]\r\n        }\r\n\r\n    let selectionPlugInO = Var.Create <| Some \"AppFramework\"\r\n    let currentPlugInW   = selectionPlugInO.View |>  View.Map2(fun _ -> Option.bind plugIns.TryFindByKey >> Option.defaultValue defaultPlugIn ) plugIns.View\r\n    let currentPlugInV   = Var.Make currentPlugInW plugIns.Add\r\n\r\n    let renderPlugIns() = plugIns.DocLens(fun name plug -> \r\n        AppFwkTemplate.Tile()\r\n            .Name(     name                                                      )\r\n            .Select(   fun _ -> selectionPlugInO.Set <| Some name                )\r\n            .Selected( if selectionPlugInO.V = Some name then \"selected\" else \"\" )\r\n            .Doc() \r\n    )\r\n\r\n    let renderVars() = \r\n        currentPlugInW\r\n        |> View.Map (fun plg -> plg.plgVars |> Seq.map (fun v -> plg, v))\r\n        |> Doc.BindSeqCachedBy (fun (plg, var) -> plg.plgName, var.varName) (fun (plg, var) -> \r\n            AppFwkTemplate.NameValueInput()\r\n                .Name(    var.varName  ) \r\n                .Value(   var.varVar   )\r\n                .Doc() \r\n        ) \r\n\r\n    let renderViews() = \r\n        currentPlugInW\r\n        |> View.Map (fun plg -> plg.plgViews |> Seq.map (fun v -> plg, v))\r\n        |> Doc.BindSeqCachedBy (fun (plg, viw) -> plg.plgName, viw.viwName) (fun (plg, viw) -> \r\n            AppFwkTemplate.NameValue()\r\n                .Name(    viw.viwName  )\r\n                .Value(   viw.viwView  )\r\n                .Doc() \r\n        ) \r\n\r\n    let renderDocs() =\r\n        currentPlugInW\r\n        |> View.Map (fun plg -> plg.plgDocs |> Seq.map (fun v -> plg, v))\r\n        |> Doc.BindSeqCachedBy (fun (plg, doc) -> plg.plgName, doc.docName) (fun (plg, doc) -> \r\n            let parms = match doc.docDoc with\r\n                        | LazyDoc _                          -> \"\"\r\n                        | FunDoc1(_, p1                    ) -> [ p1                ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n                        | FunDoc2(_, p1 , p2               ) -> [ p1; p2            ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n                        | FunDoc3(_, p1 , p2 , p3          ) -> [ p1; p2; p3        ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n                        | FunDoc4(_, p1 , p2 , p3 , p4     ) -> [ p1; p2; p3; p4    ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n                        | FunDoc5(_, p1 , p2 , p3 , p4 , p5) -> [ p1; p2; p3; p4; p5] |> String.concat \", \" |> sprintf \"(%s)\"\r\n            AppFwkTemplate.Tile()\r\n                .Name(     doc.docName + parms)\r\n                .Select(   fun _ -> currentPlugInW |> View.Get (fun plg ->  mainDocV.Set <| plg.plgName + \".\" + doc.docName ) )\r\n                .Doc() \r\n        ) \r\n\r\n    let callFunction p1 p2 actF =\r\n        match actF with\r\n        | FunAct0(f      ) -> f ()\r\n        | FunAct1(f, _   ) -> f p1\r\n        | FunAct2(f, _, _) -> f p1 p2\r\n\r\n    let renderActions() = \r\n        currentPlugInW\r\n        |> View.Map (fun plg -> plg.plgActions |> Seq.map (fun v -> plg, v))\r\n        |> Doc.BindSeqCachedBy (fun (plg, act) -> plg.plgName, act.actName) (fun (plg, act) -> \r\n            let parms = match act.actFunction with\r\n                        | FunAct0(_        ) -> \"\"\r\n                        | FunAct1(_, p1    ) -> [ p1      ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n                        | FunAct2(_, p1, p2) -> [ p1 ; p2 ] |> String.concat \", \" |> sprintf \"(%s)\"\r\n            act.actEnabled\r\n            |> View.Map (function\r\n                | true  -> AppFwkTemplate.Action() \r\n                            .Name(     act.actName + parms                             )\r\n                            .Click(    fun ev -> act.actFunction |> callFunction ev () )\r\n                            .Doc() \r\n                | false -> AppFwkTemplate.ActionDisabled() \r\n                            .Name(     act.actName                                 )\r\n                            .Click(    fun ev -> act.actFunction |> callFunction ev () )\r\n                            .Doc() \r\n            ) |> Doc.EmbedView\r\n        ) \r\n\r\n    let renderQueries() = \r\n        currentPlugInW\r\n        |> View.Map (fun plg -> plg.plgQueries |> Seq.map (fun v -> plg, v))\r\n        |> Doc.BindSeqCachedBy (fun (plg, qry) -> plg.plgName, qry.qryName) (fun (plg, qry) -> \r\n            AppFwkTemplate.Tile()\r\n                .Name(    qry.qryName  )\r\n                .Select(   fun _ -> () |> box |> qry.qryFunction |> unbox |> JS.Alert )\r\n                .Doc() \r\n        ) \r\n\r\n    let AppFwkClient = \r\n        lazy\r\n            AppFwkTemplate.AppFwkClient()\r\n                .PlugIns(     renderPlugIns()           )\r\n                .PlugInName(  currentPlugInW.V.plgName  )\r\n                .Vars(        renderVars()              )\r\n                .Views(       renderViews()             ) \r\n                .Docs(        renderDocs()              )\r\n                .Actions(     renderActions()           )\r\n                .Queries(     renderQueries()           )\r\n                .Doc()\r\n\r\n    let getLazyDoc doc =\r\n        match doc.docDoc with\r\n        | LazyDoc ldoc -> ldoc.Value\r\n        | _ -> Html.div [] [ Html.text <| sprintf \"Doc with parameters not allowed here: %A\" doc ]\r\n\r\n    let getMainClientDoc() =\r\n        plugIns.View\r\n        |> View.Map2(fun mainDoc plgs -> \r\n            plgs |> Seq.tryPick(fun plg ->\r\n                plg.plgDocs |> Seq.tryFind(fun doc -> plg.plgName + \".\" + doc.docName = mainDoc) |> Option.map getLazyDoc\r\n            )\r\n            |> Option.defaultValue AppFwkClient.Value\r\n        ) mainDocV.View\r\n        |> Doc.EmbedView\r\n\r\n    let mainDoc() = \r\n            AppFwkTemplate.AppFramework()\r\n                .MainDoc(     mainDocV.View                                     )\r\n                .GoClient(    fun _ -> mainDocV.Set \"AppFramework.AppFwkClient\" )\r\n                .MainClient(  getMainClientDoc()                                )\r\n                .Doc()\r\n\r\n    open WebComponent\r\n\r\n    let horizontal : WcSplitter.Layout = fun partSizes afterRender afterRenderSp mouseDown gap ->\r\n        AppFwkTemplate.WCompSplitterHor()\r\n            .PartSizes(    partSizes)\r\n            .AfterRender(  afterRender)\r\n            .AfterRenderSp(afterRenderSp)\r\n            .MouseDown(    fun te -> mouseDown te.Event)\r\n            .Gap(          gap)\r\n            .Doc()\r\n    let vertical   : WcSplitter.Layout = fun partSizes afterRender afterRenderSp mouseDown gap ->\r\n        AppFwkTemplate.WCompSplitterVer()\r\n            .PartSizes(    partSizes)\r\n            .AfterRender(  afterRender)\r\n            .AfterRenderSp(afterRenderSp)\r\n            .MouseDown(    fun te -> mouseDown te.Event)\r\n            .Gap(          gap)\r\n            .Doc()\r\n\r\n    let newVar name var = { varName = name ; varVar      = var }\r\n    let newViw name viw = { viwName = name ; viwView     = viw }\r\n    let newDoc name doc = { docName = name ; docDoc      = LazyDoc doc }\r\n    let newQry name qry = { qryName = name ; qryFunction = qry }\r\n    let newAct name fnc = {\r\n        actName        = name\r\n        actFunction    = FunAct0 fnc\r\n        actEnabled     = View.Const true\r\n    }\r\n\r\n    let newActF name fncF = {\r\n        actName        = name\r\n        actFunction    = fncF\r\n        actEnabled     = View.Const true\r\n    }\r\n    \r\n    let newDocF name docF = { docName = name ; docDoc = docF }\r\n\r\n    let tryGetPlugIn plgName = plugIns.TryFindByKey plgName\r\n\r\n    let tryGetVar plgName varName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgVars    |> Array.tryFind (fun var -> var.varName = varName))\r\n    let tryGetViw plgName viwName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgViews   |> Array.tryFind (fun viw -> viw.viwName = viwName))\r\n    let tryGetAct plgName actName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgActions |> Array.tryFind (fun act -> act.actName = actName))\r\n    let tryGetDoc plgName docName = tryGetPlugIn plgName |> Option.bind (fun plg -> plg.plgDocs    |> Array.tryFind (fun doc -> doc.docName = docName))\r\n    let tryGetVoV plgName varName = \r\n        tryGetVar plgName varName \r\n        |> Option.map (fun var -> Some var.varVar)\r\n        |> Option.defaultWith (fun () -> \r\n            tryGetViw plgName varName \r\n            |> Option.map (fun viw -> Var.Make viw.viwView ignore)\r\n        )\r\n    let tryGetWoW plgName viwName = \r\n        tryGetViw plgName viwName \r\n        |> Option.map (fun viw -> Some viw.viwView)\r\n        |> Option.defaultWith (fun () -> \r\n            tryGetVar plgName viwName \r\n            |> Option.map (fun var -> var.varVar.View )\r\n        )\r\n\r\n    let actHello = newAct \"Hello\"       (fun ()      -> JS.Window.Alert \"Hello!\")\r\n    let qryDocs  = newQry \"getDocNames\" (fun (_:obj) -> plugIns.Value |> Seq.collect (fun plg -> plg.plgDocs |> Seq.map (fun doc -> plg.plgName + \".\" + doc.docName)) |> Seq.toArray |> box)\r\n\r\n    if IsClient then\r\n        plugIns.Add {\r\n            plgName    = \"AppFramework\"\r\n            plgVars    = [| newVar \"mainDocV\"     mainDocV     |]\r\n            plgViews   = [|                                    |]\r\n            plgDocs    = [| newDoc \"AppFwkClient\" AppFwkClient |]\r\n            plgActions = [| actHello                           |]\r\n            plgQueries = [| qryDocs                            |]\r\n        }\r\n\r\n    let getMainDoc =\r\n      lazy\r\n        WcSplitter.init horizontal vertical\r\n        WcTabStrip.init.Value\r\n        mainDoc()\r\n\r\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"48cbe0de-d55e-4187-8c13-c6fb1684e4d4"}, {"SnippetId" :"bada8694-5447-472a-835e-60d522f6d9d9"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"ea9f36c3-bc3e-4bbb-a0c9-60db1f17a382"}, "snpName": "LayoutEngine", "snpContent": "[< JavaScriptExport >]\r\ntype LayoutEngine = {\r\n    lytName       : string\r\n    lytDefinition : Var<string>\r\n}\r\n\r\n[< JavaScriptExport >]\r\nmodule LayoutEngine =\r\n    open WebSharper.UI\r\n    module AF = AppFramework\r\n\r\n    let (|Identifier|_|) =\r\n        function\r\n        | REGEX \"^[$a-zA-Z_][0-9a-zA-Z_\\.\\-$]*$\" \"\" [| id |] -> Some id\r\n        | _                                                  -> None\r\n\r\n    let (|Vertical|Horizontal|Grid|Elem|Nothing|) =\r\n        function\r\n        | s when s = \"vertical\"   -> Vertical\r\n        | s when s = \"horizontal\" -> Horizontal\r\n        | s when s = \"grid\"       -> Grid\r\n        | Identifier id           -> Elem id\r\n        |                       _ -> Nothing\r\n\r\n    let (|Doc|Button|Input|TextArea|Select|Nothing|) =\r\n        function\r\n        | s when s = \"Doc\"        -> Doc\r\n        | s when s = \"button\"     -> Button\r\n        | s when s = \"input\"      -> Input\r\n        | s when s = \"textarea\"   -> TextArea\r\n        | s when s = \"select\"     -> Select\r\n        |                       _ -> Nothing\r\n\r\n    type Measures = \r\n    | Fixed    of pixel: float * first: bool\r\n    | Variable of min:   float * value: float * max: float\r\n\r\n    let (|Measures|_|) txt =\r\n        String.splitByChar '-' txt\r\n        |> function\r\n        | [|                     ParseO.Double v                     |] -> Some <| Fixed    (     v, true )\r\n        | [| \"\";                 ParseO.Double v                     |] -> Some <| Fixed    (     v, false)\r\n        | [| ParseO.Double min ; ParseO.Double v ; ParseO.Double max |] -> Some <| Variable (min, v, max  )\r\n        | _                                                             -> None\r\n\r\n    let fixedSplitter vertical pixel first (doc1:Doc) (doc2:Doc) =\r\n        let sizes = sprintf (if first then \"%fpx calc(100%% - %fpx)\" else \"calc(100%% - %fpx) %fpx\") pixel pixel\r\n        if vertical then \r\n            AF.AppFwkTemplate.FixedSplitterVer()\r\n                .PartSizes( sizes)\r\n                .First(     doc1 )\r\n                .Second(    doc2 )\r\n                .Doc()\r\n        else \r\n            AF.AppFwkTemplate.FixedSplitterHor()\r\n                .PartSizes( sizes)\r\n                .First(     doc1 )\r\n                .Second(    doc2 )\r\n                .Doc()\r\n\r\n    let variableSplitter vertical min value max doc1 doc2 =\r\n        Doc.Element \"wcomp-splitter\" [\r\n            if vertical then yield Attr.Create \"vertical\"    \"\"\r\n            yield                  Attr.Create \"min\"      <| string min\r\n            yield                  Attr.Create \"value\"    <| string value\r\n            yield                  Attr.Create \"max\"      <| string max\r\n        ] [ doc1 ; doc2 ]\r\n        :> Doc\r\n        \r\n    let errDoc txt = Html.div [] [ Html.text txt ]\r\n\r\n    let splitName lytNm = String.splitByChar '.' >>  (fun a -> if a.Length = 1 then (lytNm, a.[0]) else (a.[0],a.[1]) )\r\n\r\n    //let getLDoc name =\r\n    //    splitName name\r\n    //    ||> AF.tryGetDoc \r\n    //    |>  Option.map         AF.getLazyDoc\r\n    //    |>  Option.defaultWith(fun ()  -> sprintf \"missing %s\" name |> errDoc )                            \r\n\r\n    //let xxhookOrText =\r\n    //    function\r\n    //    | Identifier id -> hookDoc id\r\n    //    | txt           -> Doc.TextNode txt\r\n\r\n    let splitTokens line =\r\n        line\r\n        |> String.splitByChar '\"'\r\n        |> Seq.mapi(fun i s -> \r\n            if i % 2 = 1 then [| \" \" + s |] else\r\n            s.Trim()\r\n            |> fun t -> if t = \"\" then [||] else\r\n                        t.Split([| ' ' |], System.StringSplitOptions.RemoveEmptyEntries)\r\n        )\r\n        |> Seq.collect id\r\n        |> Seq.toList\r\n\r\n    type TextData = \r\n    | TDPlain of string\r\n    | TDView  of View<string>\r\n    | TDAct   of AF.PlugInAction\r\n\r\n    let rec getTextData lytNm txt =\r\n        txt\r\n        |> String.delimitedO \"${\" \"}\"\r\n        |> Option.map(fun (bef, name, aft) ->\r\n            let plg, n = splitName lytNm name\r\n            AF.tryGetWoW plg n\r\n            |> Option.map(fun txW ->\r\n                match bef, getTextData lytNm aft with\r\n                | \"\", TDPlain \"\"   -> TDView <|                                    txW\r\n                | _ , TDPlain b    -> TDView <| View.Map  (fun a   -> bef + a + b) txW\r\n                | _ , TDView  tx2W -> TDView <| View.Map2 (fun a b -> bef + a + b) txW tx2W\r\n                | _ , TDAct   act  -> TDAct act\r\n                )\r\n            |> Option.defaultWith(fun () -> \r\n                AF.tryGetAct plg n\r\n                |> Option.map TDAct\r\n                |> Option.defaultWith(fun () -> sprintf \"%s ${Missing %s}%s\" bef name aft |> TDPlain)\r\n            )\r\n        )\r\n        |> Option.defaultValue (TDPlain txt)\r\n\r\n    let getAttrs lytNm attrs = [\r\n        yield!  attrs\r\n                |> String.splitByChar ';'\r\n                |> Seq.map(String.splitByChar '=')\r\n                |> Seq.choose(\r\n                    function \r\n                    | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" ->\r\n                            match getTextData lytNm <| value.Trim() with\r\n                            | TDPlain v   -> Attr.Create  (name.Trim()) (v.Trim()) \r\n                            | TDView  vw  -> Attr.Dynamic (name.Trim()) vw\r\n                            | TDAct   act -> Attr.Handler (name.Trim()) (fun el ev -> act.actFunction |> AF.callFunction el ev )\r\n                            |> Some\r\n                    |_      -> None )\r\n        yield!  attrs\r\n                |> String.splitByChar ';'\r\n                |> Seq.map(String.splitByChar ':')\r\n                |> Seq.choose(\r\n                    function \r\n                    | [| name ; value |] when name.Trim() <> \"\" && value.Trim() <> \"\" -> \r\n                            match getTextData lytNm <| value.Trim() with\r\n                            | TDPlain v   -> Attr.Style        (name.Trim()) (v.Trim()) \r\n                            | TDView  vw  -> Attr.DynamicStyle (name.Trim()) vw\r\n                            | TDAct   act -> Attr.Style        (name.Trim()) (sprintf \"${%s}\" act.actName)\r\n                            |> Some\r\n                    |_      -> None )\r\n    ] \r\n\r\n    let getDocF parms (doc:AF.PlugInDoc) =\r\n        match doc.docDoc, parms with\r\n        | AF.LazyDoc ldoc                  ,                               rest -> ldoc.Value       , rest\r\n        | AF.FunDoc1(f1, _                ), p1                         :: rest -> f1 p1            , rest\r\n        | AF.FunDoc2(f2, _ , _            ), p1 :: p2                   :: rest -> f2 p1 p2         , rest\r\n        | AF.FunDoc3(f3, _ , _ , _        ), p1 :: p2 :: p3             :: rest -> f3 p1 p2 p3      , rest          \r\n        | AF.FunDoc4(f4, _ , _ , _ , _    ), p1 :: p2 :: p3 :: p4       :: rest -> f4 p1 p2 p3 p4   , rest     \r\n        | AF.FunDoc5(f5, _ , _ , _ , _ , _), p1 :: p2 :: p3 :: p4 :: p5 :: rest -> f5 p1 p2 p3 p4 p5, rest\r\n        | _ -> Html.div [] [ Html.text <| sprintf \"Parameters do not coincide with definition %A - %A\" doc parms ], []\r\n\r\n    let getDocFinal parms doc = \r\n        match getDocF parms doc with\r\n        | res, [] -> res\r\n        | _ -> sprintf \"Too many parameters %A %A\" doc parms |> errDoc\r\n\r\n    let turnToView f = AF.mainDocV.View |> View.Map f |> Doc.EmbedView\r\n\r\n    let getOneDoc lytNm docs =\r\n        match docs with\r\n        | Identifier id :: parms -> let plg, nm = splitName lytNm id\r\n                                    AF.tryGetDoc plg nm\r\n                                    |>  Option.map (getDocF parms)\r\n                                    |>  Option.defaultWith  (fun ()  ->\r\n                                        AF.tryGetWoW plg nm\r\n                                        |>  Option.map (fun txtW -> Doc.TextView txtW, parms)\r\n                                        |> fun vv -> vv\r\n                                        |>  Option.defaultWith  (fun () -> sprintf \"Missing doc: %s\" id |> errDoc, parms) )\r\n        | txt           :: rest  -> match getTextData lytNm txt with\r\n                                    | TDPlain v   -> Doc.TextNode v , rest\r\n                                    | TDView  vw  -> Doc.TextView vw, rest\r\n                                    | TDAct   act -> sprintf \"Unexpected action: %s\" act.actName |> errDoc, rest\r\n        | []                     -> Doc.Empty, []\r\n\r\n    let rec getDocs lytNm docs =\r\n        match docs with\r\n        | [] -> []\r\n        | _  -> \r\n        match getOneDoc lytNm docs with\r\n        | res, rest -> res :: getDocs lytNm rest\r\n\r\n    let pairOfDocs lytNm docs =\r\n        AF.mainDocV.View \r\n        |> View.Map (fun _ -> getDocs lytNm docs )\r\n        |> View.Map (\r\n            function \r\n            | [ doc1 ; doc2 ] -> doc1, doc2\r\n            | _               -> sprintf \"splitter expects exactly 2 elements %A\" docs |> errDoc, \"part 2\" |> errDoc\r\n        ) |> (fun dsW -> View.Map fst dsW |> Doc.EmbedView, View.Map snd dsW |> Doc.EmbedView )\r\n\r\n    let singleDoc lytNm docs =\r\n        AF.mainDocV.View \r\n        |> View.Map (fun _ -> getDocs lytNm docs )\r\n        |> View.Map (\r\n            function \r\n            | [ doc1 ] -> doc1\r\n            | _        -> sprintf \"expected exactly 1 element %A\" docs |> errDoc\r\n        ) |> Doc.EmbedView\r\n\r\n    let createSplitter(lytNm, vertical, measures, docs) =\r\n        let doc1, doc2 = pairOfDocs lytNm docs\r\n        match measures with\r\n        | Fixed    (pixel,    first) ->    fixedSplitter vertical pixel first   doc1 doc2\r\n        | Variable (min, value, max) -> variableSplitter vertical min value max doc1 doc2\r\n\r\n    let createElement(lytNm, element, attrs, docs) =\r\n        turnToView (fun _ -> getDocs lytNm docs |> Doc.Concat)\r\n        |> Seq.singleton\r\n        |> Doc.Element element (getAttrs lytNm attrs) \r\n        :> Doc\r\n\r\n    let createButton( lytNm, actName, attrs, text) = \r\n        turnToView <| fun _ ->\r\n            splitName lytNm actName\r\n            ||> AF.tryGetAct\r\n            |>  Option.map          (fun act -> fun () -> act.actFunction |> AF.callFunction () ()  )\r\n            |>  Option.defaultValue ignore\r\n            |> Doc.Button text (getAttrs lytNm attrs)\r\n\r\n    let createInput( lytNm, varName, attrs ) = \r\n        turnToView <| fun _ ->\r\n            splitName lytNm varName\r\n            ||> AF.tryGetVoV\r\n            |>  Option.map          (           Doc .Input     (getAttrs lytNm attrs)             )\r\n            |>  Option.defaultWith  (fun ()  -> sprintf \"Missing var: %s\" varName |> errDoc )\r\n\r\n    let createTextArea( lytNm, varName, attrs ) = \r\n        turnToView <| fun _ ->\r\n            splitName lytNm varName\r\n            ||> AF.tryGetVoV\r\n            |>  Option.map          (           Doc .InputArea (getAttrs lytNm attrs)             )\r\n            |>  Option.defaultWith  (fun ()  -> sprintf \"Missing var: %s\" varName |> errDoc )\r\n\r\n    let createDoc( lytNm, docName, parms) =\r\n        turnToView <| fun _ ->\r\n            let plg, nm = splitName lytNm docName\r\n            AF.tryGetDoc plg nm\r\n            |>  Option.map (getDocFinal parms)\r\n            |>  Option.defaultWith  (fun ()  -> sprintf \"Missing doc: %s\" docName |> errDoc )\r\n\r\n    let createSplitterM = Memoize.memoize createSplitter\r\n    let createButtonM   = Memoize.memoize createButton\r\n    let createInputM    = Memoize.memoize createInput\r\n    let createTextAreaM = Memoize.memoize createTextArea\r\n    let createElementM  = Memoize.memoize createElement\r\n    let createDocM      = Memoize.memoize createDoc\r\n\r\n    let createDocO lytNm (line:string) =\r\n        try\r\n            match splitTokens line with\r\n            |   Identifier name :: Vertical   :: Measures measures          :: docs    -> Some <| (name, createSplitterM(lytNm, true , measures, docs) )\r\n            |   Identifier name :: Horizontal :: Measures measures          :: docs    -> Some <| (name, createSplitterM(lytNm, false, measures, docs) )\r\n            | [ Identifier name ;  Button     ;  Identifier act    ;  attrs ;  text  ] -> Some <| (name, createButtonM(  lytNm, act, attrs, text) )\r\n            | [ Identifier name ;  Input      ;  Identifier var    ;  attrs          ] -> Some <| (name, createInputM(   lytNm, var, attrs      ) )\r\n            | [ Identifier name ;  TextArea   ;  Identifier var    ;  attrs          ] -> Some <| (name, createTextAreaM(lytNm, var, attrs      ) )\r\n            |   Identifier name :: Doc        :: doc                        :: parms   -> Some <| (name, createDocM(     lytNm, doc, parms      ) )\r\n            |   Identifier name :: Grid       :: cols :: rows      :: attrs :: docs    -> None\r\n            |   Identifier name :: Elem elem                       :: attrs :: docs    -> Some <| (name, createElementM(lytNm, elem, attrs, docs) )\r\n            | _                                                                        -> None\r\n        with e -> \r\n            printfn \"%A\" e\r\n            None\r\n\r\n    let createDocs lytNm txt =\r\n        txt\r\n        |> String.splitByChar '\\n'\r\n        |> Seq.choose (createDocO lytNm)\r\n        |> Seq.map (fun (a,b) -> AF.newDoc a (lazy b) )\r\n\r\n    let getText lytNm txtName =\r\n        match txtName with\r\n        | Identifier id -> let plg, nm = splitName lytNm id \r\n                           AF.tryGetViw plg nm\r\n                           |> Option.map (fun viw -> Doc.TextView viw.viwView    )\r\n                           |> Option.defaultWith (fun () -> \r\n                           AF.tryGetVar plg nm\r\n                           |> Option.map (fun var -> Doc.TextView var.varVar.View)\r\n                           |> Option.defaultWith (fun () -> Html.text id))\r\n        | txt           -> Html.text txt\r\n\r\n    let inputFile lytNm attrs labelName actName doc =\r\n        splitName lytNm actName\r\n        ||> AF.tryGetAct\r\n        |> Option.map(fun act -> \r\n            Html.div (getAttrs lytNm attrs) [\r\n                Html.div                [ attr.``class`` \"input-group\"       ] [\r\n                    Html.span           [ attr.``class`` \"input-group-btn\"   ] [ \r\n                        Html.label      [ attr.``class`` \"btn\"               ] [ \r\n                            getText lytNm labelName\r\n                            Html.input  [ attr.``class`` \"form-control\" \r\n                                          attr.``type`` \"file\" \r\n                                          Attr.Style \"display\" \"none\" \r\n                                          Html.on.click (fun el ev -> el?value <- \"\")\r\n                                          Html.on.change(fun el ev -> act.actFunction |> AF.callFunction el () )\r\n                                          ] []\r\n                        ]\r\n                    ]\r\n                    (if doc <> \"\" then singleDoc lytNm [ doc ] else Doc.Empty)\r\n                ]\r\n            ]\r\n        ) |> Option.defaultWith(fun () ->  sprintf \"Action not found %s\" actName |> errDoc )\r\n\r\n    let inputLabel lytNm attrs labelName varName =\r\n        splitName  lytNm varName\r\n        ||> AF.tryGetVar\r\n        |> Option.map(fun var -> \r\n            Html.div (getAttrs lytNm attrs) [\r\n                Html.div      [ attr.``class`` \"input-group\"       ] [\r\n                    Html.span [ attr.``class`` \"input-group-addon\" ] [ getText lytNm labelName ]\r\n                    Doc.Input [ attr.``class`` \"form-control\"      ]   var.varVar\r\n                ]\r\n            ]\r\n        ) |> Option.defaultWith(fun () ->  sprintf \"Var not found %s\" varName |> errDoc )\r\n\r\n    let none x = Html.span [][]\r\n\r\n    let addLayout (lyt:LayoutEngine) =\r\n        lyt.lytDefinition.View |> View.Sink(fun txt ->\r\n            AF.plugIns.Add { \r\n                plgName    = lyt.lytName\r\n                plgVars    = [| AF.newVar \"Layout\" lyt.lytDefinition  |]\r\n                plgViews   = [|                                       |]\r\n                plgDocs    = [| yield! createDocs lyt.lytName txt\r\n                                yield  AF.newDocF \"InputFile\"  <| AF.FunDoc4(inputFile  lyt.lytName, \"attrs\", \"Label\", \"Action\", \"[Doc]\")\r\n                                yield  AF.newDocF \"InputLabel\" <| AF.FunDoc3(inputLabel lyt.lytName, \"attrs\", \"Label\", \"Var\"            )\r\n                                yield  AF.newDocF \"none\"       <| AF.FunDoc1(none      , \"x\"                                )\r\n                             |]\r\n                plgActions = [|                                       |]\r\n                plgQueries = [|                                       |]\r\n            }\r\n            AF.mainDocV.Set AF.mainDocV.Value\r\n        )\r\n\r\n    let newLyt name lyt = {\r\n        lytName       = name\r\n        lytDefinition = Var.Create lyt\r\n    }\r\n\r\n    let addNewLayout (name:obj) (layout:obj) = \r\n        (if layout <> null then unbox layout else \"\"\"\r\nsplit horizontal 0-50-100 AppFramework.AppFwkClient Hello\r\nHello h1 \"color:blue; class=btn-primary\" \"How are you today?\" Ask\r\nAsk Doc InputLabel \"placeholder=Type you answer here...\" \"Answer:\" AppFramework.mainDocV  \r\n\"\"\"     |> String.unindentStr)\r\n        |> newLyt (if layout <> null then unbox name else System.Guid.NewGuid() |> string |> fun s -> \"Lyt_\" + s.Replace(\"-\", \"\"))\r\n        |> addLayout\r\n\r\n    if IsClient then\r\n        AF.tryGetPlugIn \"AppFramework\"\r\n        |> Option.iter(fun plg ->\r\n            { plg with plgActions = plg.plgActions |> Array.append <| [| AF.newActF \"AddLayout\" <| AF.FunAct2(addNewLayout, \"[Name]\", \"[Layout]\") |]}\r\n            |> AF.plugIns.Add\r\n        )\r\n", "snpParentIdO": {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, "snpPredIds": [{"SnippetId" :"045a7205-0f3e-46fe-9b72-87d0a5f84f79"}, {"SnippetId" :"6c60faf9-d558-4928-812d-711f349c4a90"}, {"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"91de3802-48c5-43ca-a03a-477dfefc99be"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, "snpName": "LibraryMixed", "snpContent": "/// Essentials that part runs in Javascript and part runs in the server\n[< AutoOpen >]\nmodule Library2 =", "snpParentIdO": {"SnippetId" :"44b60b89-0535-4591-aa79-f910fe6807ad"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 172}, {"snpId": {"SnippetId" :"886b5dd6-4b3c-4897-b473-8f066f776fe0"}, "snpName": "FsiAgent", "snpContent": "module FsiAgent =\n    module ReaderM = ReaderMAsyncResult\n    open FsiEvaluator\n    open FsiCodePresence\n    open ReaderM.Operators\n\n    [< JavaScript >]\n    type Config = Config of workDir:string * parms:string\n\n    let queueOutput send =\n        let output        = new System.Text.StringBuilder()\n        let append    txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n        let consume   ()  = let v = output.ToString()\n                            output.Clear() |> ignore\n                            v\n        let queue         = Mailbox.iter print (fun msg -> \n                                match msg with\n                                | Some txt -> append txt\n                                | None     -> let txt2send =  consume()\n                                              if  txt2send <> \"\" then send txt2send\n                            )\n        fun          txt -> txt |> Some |> queue.Post\n                            async { do! Async.Sleep 100\n                                    queue.Post None } |> Async.Start\n\n    let mutable outHndl      = ignore\n    let mutable errHndl      = ignore\n\n    let setQueueHandlers send =\n        let queue = queueOutput send \n        outHndl <-                  queue\n        errHndl <- ((+) \"Err: \") >> queue\n\n    let ctor (Config (workDir, config)) = \n        new FsiExe(config, workDir, outHndl, errHndl) \n\n    let fsiExeL = lazy new ResourceAgent<_, _>( 70\n                                             , ctor\n                                             , Config (\".\", \"--nologo --quiet\")\n                                             , (fun fsi    -> (fsi :> System.IDisposable).Dispose())\n                                             , (fun fsi    ->  fsi.IsAlive                         )\n                                             )\n\n    [< JavaScript >]\n    let extractConfig workDir (FsCode fsCode) = \n        Config(\n            FsCode.getSourceDir workDir <| String.splitByChar '\\n' fsCode\n          , FsCode.extractDefines (FsCode fsCode)\n            |> ((+) \" --nologo --quiet \")\n        )\n\n    [< Rpc >]\n    let evalCode workDir code = asyncResult {\n        let config = extractConfig workDir code\n        return!\n            evaluateRm code\n            //|> (fun vv -> vv)\n            |> AgentReaderM.fromResourceRm\n            //|> (fun vv -> vv)\n            |> AgentReaderM.run fsiExeL.Value config\n    }\n\n    [< Rpc >]\n    let evalCodeSameConfig code = asyncResult {\n        return!\n            evaluateRm code\n            |> AgentReaderM.fromResourceRm\n            |> AgentReaderM.runSameConfig fsiExeL.Value\n    }\n\n    [< Rpc >]\n    let evalCodeWithPresence workDir presenceKey presenceValue presenceCodeF code = asyncResult {\n        let config = extractConfig workDir code\n        return!\n            reader {        \n                let! currentValueO = getPresenceRm presenceKey\n                if   currentValueO <> Some presenceValue then\n                    let presenceCode   = presenceCodeF()\n                    let presenceConfig = extractConfig workDir presenceCode\n                    if  presenceConfig <> config then\n                        do! Result.Error (ErrorMsg <| sprintf \"Presence and code configs are different: %A <--> %A\" presenceConfig config)\n                    do! evaluateRm    presenceCode |>> ignore\n                    do! addPresenceRm presenceKey presenceValue\n                return! evaluateRm code\n            }\n            |> AgentReaderM.fromResourceRm\n            |> AgentReaderM.run fsiExeL.Value config\n    }\n \n    [<Rpc>]    \n    let abortFsiExe  () = fsiExeL.Value.Process(fun fsi -> fsi.Abort() )\n    \n    [<Rpc>]    \n    /// like abortFsiExe but prevents respawning until next command\n    let disposeFsiExe() = ((fsiExeL.Value.State.resource) :> System.IDisposable).Dispose()\n\n", "snpParentIdO": {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, "snpPredIds": [{"SnippetId" :"53b5a650-4b7f-471d-8cb4-63c4e0ed0ad6"}, {"SnippetId" :"9e25a970-d1dd-4569-aeb7-46641e44237e"}, {"SnippetId" :"a7e4ee55-8458-49ba-96f7-b61f8f268e4f"}, {"SnippetId" :"a98f07ba-8de4-4baa-9714-793169bf36ac"}, {"SnippetId" :"e38ca94f-ab85-4c33-a0fd-4c5190a6ea42"}], "snpProperties": [], "snpGeneration": 60}, {"snpId": {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, "snpName": "WebSockets", "snpContent": "[<WebSharper.JavaScript>]\nmodule WebSockets =", "snpParentIdO": {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b34cfa8d-400d-4b9c-b2ed-4b4d0e6b742d"}, "snpName": "Message Types", "snpContent": "#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper\n\nlet MessageBrokerId  = \"<MessageBroker>\"\n\ntype Address = Address of address:string\nwith member this.txt = match this with Address txt -> txt\n\nlet MessageBrokerAddress = Address MessageBrokerId\n\n/// Requests made to Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerRequest = \n    | BRGetConnections  /// request for list of connections\n    | BRGetProcessId    /// request PID of broker process\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerReply = \n    | BRConnections  of string[]\n    | BRPid          of int\n    | BRString       of string\n  //  | BRPleaseClose  \n\n[< NamedUnionCases \"type\" >]\ntype MessageType = \n    | MsgInformation             // does not expect a reply, payload may or may not be structured\n    | MsgRequest                 // expects a reply, structured payload\n    | MsgReply                   // structured payload.\n    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n    | MsgRequestForId            // expects reply as Information with id\n    | MsgRequestForEcho          // expects reply as Information with same payload\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerMessage = \n    | BMOk\n    | BMOnlyBrokerShouldUse\n    | BMDestinationNotFound of Address  \n    | BMWebSocketError      of string\n    | BMReceiverCantReply\n    | BMUnexpectedMsgType   of MessageType\n    | BMUnexpectedResponse  of string\n\n[< NamedUnionCases \"type\" >]\ntype Replier = \n    | NoReply\n    | Broker\n    | Receiver\n\n[< NamedUnionCases \"type\" >]\ntype MessageGeneric = {\n    from          : Address\n    destination   : Address\n    msgType       : MessageType\n    subtype       : string      // free short string that provides information to deserialize payload\n    id            : System.Guid\n    payload       : string\n    replier       : Replier\n}\n\n[< Inline >]\nlet inline processPayload f (payload:string) : string =\n    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n    |> f\n    |> Json.Serialize\n            \n[<  Inline >]\nlet newMsgSerialized dst payload = {\n    from          = Address \"\"\n    destination   = dst\n    msgType       = MsgRequest\n    subtype       = \"\"\n    id            = System.Guid.NewGuid()\n    payload       = payload\n    replier       = NoReply\n}\n\n[< Inline >]\nlet inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\nlet inline from           frm msg = { msg with from          = frm               }\nlet inline destination    dst msg = { msg with destination   = dst               }\nlet inline msgType        typ msg = { msg with msgType       = typ               }\nlet inline subtype        sub msg = { msg with subtype       = sub               }\nlet inline replier        rpl msg = { msg with replier       = rpl               }\nlet inline msgId          id  msg = { msg with id            = id                }\n\n[<  Inline >]\nlet inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n\n[<  Inline >]\nlet inline msgPayload msg = Json.Deserialize msg.payload\n\nlet mapPayload f msg = { msg with payload = f msg.payload }\n\nlet inline makeReply msg =\n    msg\n    |> msgType MsgReply\n    |> replier NoReply\n\n[<  Inline >]\nlet inline respond pyld msg =\n    msg\n    |> makeReply\n    |> payload  pyld\n\ntype IServer =\n    abstract member Post  : MessageGeneric -> unit\n    abstract member Close : unit           -> unit\n\ntype CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n", "snpParentIdO": {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 181}, {"snpId": {"SnippetId" :"580c84e5-f8ba-467a-8e26-45ca810cb06d"}, "snpName": "Broker", "snpContent": "\ntype SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n\n[< JavaScript false >]\nmodule Broker =\n    open WebSharper\n    open WebSharper.Owin.WebSocket.Server\n    open System.Collections.Generic\n    \n    type SomeState = {\n        info       : string\n    }\n    \n    type IClient =\n        abstract member Post : MessageGeneric -> unit\n        abstract member Ip   : unit           -> string\n        abstract member Id   : unit           -> string\n        abstract member Close: unit           -> unit\n\n    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n#if FSS_SERVER                          \n        static let mutable fssWebSocketO : BrokerAgent option = None\n#endif\n        do printfn \"WebSocket server start\"\n        let addConnection, removeConnection, getConnections =\n            let connectionsAgent = Mailbox.stateFull (fun ex st -> print ex ; st) Map.empty\n            (fun   clientAddress uniqueId client -> connectionsAgent |> Mailbox.StateFull.apply (Map.add clientAddress (uniqueId, client))       )\n           ,(fun                 uniqueId        -> connectionsAgent |> Mailbox.StateFull.apply (Map.filter (fun _ (uid, _) -> uid <> uniqueId)) )\n           ,(fun ()                              -> connectionsAgent |> Mailbox.StateFull.getState                                               )\n        let processBrokerRequest req = \n            match req with\n            | BRGetConnections -> getConnections() |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n            | BRGetProcessId   -> System.Diagnostics.Process.GetCurrentProcess().Id |> BRPid\n            \n        let respondFromBroker pyld msg =\n            msg\n            |> respond     pyld\n            |> msgType     MsgFromBroker\n            |> subtype     \"FromBroker\"\n\n        let post reply msg =\n            match getConnections() |> Map.tryFind msg.destination with\n            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n            \n        let clientConnect (client: IClient) = async {\n            let clientId = client.Id()\n            printfn \"clientConnect: %A\" clientId\n            let uniqueId = System.Guid.NewGuid()\n            printfn \"New Connection from %s\" clientId                           \n            let clientAddress = Address clientId\n            getConnections()\n            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                printfn \"Closing old connection from %s\" clientId\n                kp.Value \n                |> fun (_, conn) -> conn.Close()\n            )\n            addConnection clientAddress uniqueId client\n            \n            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n            let checkReply msg = if msg.replier = Broker then\n                                        msg |> respondFromBroker BMOk |> reply\n            let forward msg = msg |> from clientAddress |> post reply\n                              checkReply msg\n            let respondMsg (msg:MessageGeneric) =\n                checkReply msg\n                printfn \"%A\" msg\n                match msg.msgType with\n                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                | MsgFromBroker     -> ()\n            let clientIp = client.Ip()\n            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                match wsmsg with\n                | Message msg ->\n                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                    else                                             forward    msg     \n                    return state\n                | Error exn -> \n                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                    return state\n                | Close ->\n                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                    removeConnection uniqueId\n                    return state\n            }\n        }\n        member this.Post msg = post (fun m -> printfn \"%s\" m.payload) msg\n        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n            let inline tryGetValue key (dict) =\n                dict \n                :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n                |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n            clientConnect { new IClient with\n                                member this.Post v  = client.Post v\n                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                member this.Id()    = client.Connection.Context.Request.Query \n                                                      |> tryGetValue  \"ClientId\" \n                                                      |> Option.bind         Array.tryHead \n                                                      |> Option.defaultValue \"\"\n                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                          }\n#if FSS_SERVER\n        static member FssWebSocketO                = fssWebSocketO\n        static member FssWebSocketO with set value = fssWebSocketO <- value\n        member this.ConnectLocal clientId receiver = \n            clientConnect { new IClient with\n                                member this.Post v  = receiver v \n                                member this.Ip()    = \"(server)\"\n                                member this.Id()    = clientId\n                                member this.Close() = () // probably shouldn't be called at all\n                          }\n\n    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n        async {\n            match BrokerAgent.FssWebSocketO with \n            | None -> raise (exn \"FssWebSocketO is not set\")\n            | Some serverP ->\n            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n            let  brokerBox                   = Mailbox.foldA Mailbox.defHandler brokerFunc brokerInitState\n            let! clientInitState, clientFunc = f { new IServer with\n                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                       member this.Close()  = ()\n                                                 }\n            let  clientBox    = Mailbox.foldA Mailbox.defHandler clientFunc clientInitState\n            clientBoxO <- Some clientBox\n            clientBox.Post CMessage.Open\n        }\n#endif        \n        \n        ", "snpParentIdO": {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}, {"SnippetId" :"b34cfa8d-400d-4b9c-b2ed-4b4d0e6b742d"}], "snpProperties": [], "snpGeneration": 181}, {"snpId": {"SnippetId" :"6cf646b6-e625-43bf-8473-d7eb553af0b9"}, "snpName": "WebSocketClient (.Net)", "snpContent": "open System\nopen System.Threading\nopen System.Net.WebSockets\n\n[< JavaScript false >]\nmodule Client =\n    let startStateFull receive initAndfolder =\n        async {\n            let! initState, folder = initAndfolder\n            let agentBox = Mailbox.foldA (fun ex st -> print ex; st) folder initState\n            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n            let error  a = agentBox.Post CMessage.Error ; finish a\n            Async.StartWithContinuations(receive agentBox, finish, error, error)\n        }\n\n    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n        let conn = new ClientWebSocket()\n        let chunkSize = 8192\n        let send (txt:string)  =\n            async {\n                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                let chunks = buffer.Length / chunkSize\n                for i = 0 to chunks do\n                    let last = i = chunks\n                    let size = if last then buffer.Length % chunkSize else chunkSize\n                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n            }\n        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n            let buffer : byte[] = Array.create chunkSize 0uy\n            let builder         = System.Text.StringBuilder()\n            let keepgo          = ref true\n            async {\n                receiverBox.Post CMessage.Open\n                while conn.State = WebSocketState.Open && !keepgo do\n                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                    match result.MessageType with\n                    | WebSocketMessageType.Close -> keepgo := false\n                    | WebSocketMessageType.Text ->\n                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                        builder.Append txt |> ignore\n                        if result.EndOfMessage then\n                            let txt = builder.ToString()\n                            builder.Clear() |> ignore\n                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                    | _ -> ()\n                return \"WebSocketServer receive Closed.\"\n            }\n        let brokerBox = Mailbox.iterA print (Json.Serialize >> send)\n        let connect initAndfolder =\n            async {\n                printfn \"Connecting %s\" uri\n                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                printfn \"Connected %A\" WebSocketState.Open\n                do! startStateFull receive initAndfolder\n            }\n        member this.WebSocket        = conn\n        member this.Post (msg: 'C2S) = brokerBox.Post msg\n        member this.Connect          = connect\n\n    let ConnectStateful<'S2C, 'C2S> uri getInitAndfolder =\n        async {\n            let  server          = WebSocketServer uri\n            do!  server.Connect (getInitAndfolder server)\n            return server\n        }\n\n    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =\n            f { new IServer with\n                  member this.Post  v = serverP.Post v\n                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                        |> Async.AwaitTask |> Async.RunSynchronously            \n               }\n        ConnectStateful uri2 func\n        |> Async.map ignore\n        ", "snpParentIdO": {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}, {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}, {"SnippetId" :"b34cfa8d-400d-4b9c-b2ed-4b4d0e6b742d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"48e111a3-1b92-4da3-8353-ae73ece0bca0"}, "snpName": "WsMessagingClient", "snpContent": "#I @\"..\\packages\\Owin\\lib\\net40\"\n#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen System\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\n//#define FSS_SERVER\n//#define WEBSHARPER\n\ntype  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n\ntype ClientTypeFSharp    = FSharp\n#if WEBSHARPER\ntype ClientTypeFSStation = FSStation\ntype ClientTypeJScript   = JScript\n\n[< Inline >]\nlet ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n        f { new IServer with\n              member this.Post  v = serverP.Post v\n              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n           }\n    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n    ConnectStateful endPoint func\n    |> Async.map ignore\n#endif\n\nmodule ReplyHandler =\n    type WaitForReplyMsg =\n        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n        | Reply  of Guid *   MessageGeneric\n        | Excpn  of Guid *   exn\n        | Cancel of Guid *   OperationCanceledException\n        \n    type Handler (defProc) =\n        let waitingAgent =    \n            Mailbox.fold Mailbox.defHandler (fun waitingForReply action ->\n                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def\n                                      Map.remove  key     waitingForReply\n                match action with\n                | Add   (key, fns) -> Map.add     key fns waitingForReply\n                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)\n                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore\n                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore\n            ) Map.empty\n        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post\n        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post\n        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post\n        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post\n\n[< Inline \"window.location.href\" >]\nlet getEndPoint() = \n#if FSS_SERVER\n    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n#else\n    \"##FSHARPSTATION_ENDPOINT##\"\n#endif\n\nlet extractEndPoint() = \n    let ep : string = getEndPoint()\n    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n    ep2.Split('/').[0]\n\ntype WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n        , clientId:string, ?timeout:int, ?endPoint:string) =    \n    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n    let clientAddress = Address clientId\n    let wsTimeout     = defaultArg timeout 60000\n\n    let mutable out = printfn \"%s\"\n    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n    let mutable serverO : IServer option = None\n    let mutable payloadProcessorO : (string -> Async<string>) option = None\n    let waiting = ReplyHandler.Handler (fun msg -> printfn \"Reply from '%s': %s\" msg.from.txt msg.payload)\n\n    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n\n    let processReply      msg = waiting.Reply msg.id msg\n    let mapPayloadWrap (fW: _ -> Async<_> ) msg =\n        async {\n            let! r  = fW msg.payload\n            return msg |> mapPayload (fun _ -> r)\n        }\n    let processMessage msg =\n        //printfn \"%A\" msg\n        match msg.msgType with\n        | MsgFromBroker     \n        | MsgReply           -> processReply msg\n        | MsgInformation     -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n        | MsgRequest         -> match payloadProcessorO with \n                                | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                                | Some processor ->\n                                msg |> mapPayloadWrap processor |> Async.iterA (makeReply >> reply) \n        | MsgRequestForEcho  -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n        | MsgRequestForId    -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n    \n    let connectToWebSocketServer() =\n        printfn \"in connectToWebSocketServer\"\n        async {\n            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                return 0, fun state wsmsg -> async {\n                    try match wsmsg with\n                        | CMessage.Message msg -> processMessage msg\n                        | CMessage.Open        -> printfn \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                        | CMessage.Close       -> printfn \"WebSocket %s connection closed.\" clientId ; close()\n                        | CMessage.Error       -> printfn \"WebSocket %s connection error!\"  clientId\n                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                    return state\n                }\n            }\n            printfn \"connectToWebSocketServer with server\"\n            \n        }\n\n    let checkServer = Mailbox.callA print ( fun () -> async {\n        printfn \"getServer\"\n        if serverO.IsNone then\n            printfn \"getServer Connecting\"\n            do! connectToWebSocketServer()\n            do! Async.Sleep 200\n        return serverO |> Result.ofOption (fun () -> ErrorMsg \"could not connect to Server\")\n    })        \n\n    let getServer() : AsyncResult<IServer, _> = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n        \n    let postR (server: IServer) rpl msg = \n        let m = msg |> from clientAddress |> replier rpl \n        try       server.Post m\n        with e -> serverO <- None\n                  raise e\n\n    let sendAndForget msg = asyncResult {\n        let! server = getServer()\n        msg |> postR server NoReply\n    }\n        \n    let sendAndReply rpl msg = asyncResult {\n        let! server  = getServer()\n        let  replyA  = Async.FromContinuations(fun fns -> \n            waiting.Add msg.id fns\n            msg |> postR server rpl\n            if wsTimeout > 0 then\n                async {\n                    do! Async.Sleep wsTimeout\n                    waiting.Raise msg.id (TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn)\n                } |> Async.Start\n        )\n        return! replyA\n    }\n        \n    let sendAndVerify msg = asyncResult {\n        let! reply   = sendAndReply Broker msg \n        do!  match reply.msgType with\n             | MsgFromBroker  -> let  bm = msgPayload reply\n                                 if   bm = BMOk \n                                 then Result.Ok    () \n                                 else Result.Error <| ResultMessage.Message bm\n             | _              ->      Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n    }\n    \n    let sendGetReply msg =\n        asyncResult {\n            let! reply   = sendAndReply Receiver msg \n            let! result =\n                match reply.msgType with\n                | MsgReply      -> Result.Ok     reply.payload\n                | MsgFromBroker -> let bm = msgPayload reply\n                                   Result.Error <| ResultMessage.Message bm\n                | _             -> Result.Error <| ResultMessage.Message (BMUnexpectedMsgType reply.msgType)\n            return result\n        }\n\n    let getListeners() =\n        asyncResult {\n            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n            let! reply  = sendGetReply msg\n            match Json.Deserialize<BrokerReply> reply with\n            | BRConnections listeners -> return listeners\n            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n        } \n        \n    let getProcessId() =\n        asyncResult {\n            let  msg    = newMsg MessageBrokerAddress BRGetProcessId\n            let! reply  = sendGetReply msg\n            match Json.Deserialize<BrokerReply> reply with\n            | BRPid pid -> return pid\n            | r -> return! Result.Error <| ResultMessage.Message (BMUnexpectedResponse <| sprintf \"%A\" r)\n        } \n        \n    let sendMsg msg =\n        asyncResult {\n            if msg.replier = NoReply\n            then do!     sendAndForget msg\n                 return  \"\"\n            else return! sendGetReply  msg\n        }\n    member this.MBListeners            = getListeners()\n    member this.MBProcessId            = getProcessId()\n    member this.EndPoint               = wsEndPoint\n    member this.ClientId               = clientId\n    member this.SendMsg           msg  = sendMsg msg\n    [<  Inline >]\n    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n    [<  Inline >]\n    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n    [<  Inline >]\n    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> AsyncResult.map Json.Deserialize\n    member this.Out with set fout      = out <- fout\n    [<  Inline >]\n    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Async.map Json.Serialize))\n                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                         |> msgType MsgInformation\n                                         |> sendAndForget |> AsyncResult.iterA (string >> failwith) id\n    interface IDisposable with\n        member this.Dispose() = close()\n\n#if FSS_SERVER   \n    [< JavaScript false >]\n    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n    [< JavaScript false >]\n    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#if WEBSHARPER\n    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n\n", "snpParentIdO": {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"6cf646b6-e625-43bf-8473-d7eb553af0b9"}], "snpProperties": [], "snpGeneration": 181}, {"snpId": {"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, "snpName": "FSharpStationClient", "snpContent": "[< JavaScript >]\ntype FSMessage =\n| MsgGetId\n| MsgGetSnippets     of SnippetReference[]\n| MsgGetCode         of SnippetReference\n| MsgGetPredecessors of SnippetReference\n| MsgAction          of string[]\n| MsgGetUrl\n\n[< JavaScript >]\ntype FSResponse =\n| RespString         of string\n| RespSnippets       of Snippet[]\n\nmodule FSharpStationClient =\n    open WebSockets\n\n    let mutable fsharpStationAddress = Address \"##FSHARPSTATION_ID##\"\n\n    let [< Rpc >] setAddress address = async { \n        fsharpStationAddress <- address \n        printfn \"set %A\" fsharpStationAddress\n    }\n\n    let fsharpStationClient, sendMessage : WSMessagingClient * (FSMessage -> AsyncResult<FSResponse, _>) = \n        let client =\n#if WEBSHARPER \n            if IsClient then \n                new WSMessagingClient(\"FSharpStationClientJS\"       )\n            else\n#endif            \n#if FSS_SERVER            \n                new WSMessagingClient(\"FSharpStationClientFSStation\", FSStation)\n#else\n                new WSMessagingClient(\"FSharpStationClientFSharp\"   , FSharp)\n#endif\n        client, fun m -> client.SendGetReply fsharpStationAddress m |> AsyncResult.absorbR\n\n    let respString response = asyncResult { \n        match response with\n        | RespString code -> return code\n        | _               -> return! Error <| ErrorMsg (sprintf \"Unexpected %A\" response)\n    }\n\n    let getCode path = \n        path\n        |> String.splitByChar '/'\n        |> RefSnippetPath\n        |> MsgGetCode\n        |> sendMessage\n        |> AsyncResult.bind respString\n\n    let getUrl () = sendMessage MsgGetUrl |> AsyncResult.bind respString\n\n    let sendOutput    txt = [| \"AddOutput\" ; txt |]\n                            |> MsgAction\n                            |> sendMessage\n                            \n    let getBrokerProcessId() = fsharpStationClient.MBProcessId", "snpParentIdO": {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, "snpPredIds": [{"SnippetId" :"48e111a3-1b92-4da3-8353-ae73ece0bca0"}, {"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"343a4c7f-ba13-4370-b7db-59dc22ba562e"}, "snpName": "FsAutoComplete", "snpContent": "module FsAutoComplete =", "snpParentIdO": {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7fdf570d-b418-4a71-afb9-5fc1302aadb0"}, "snpName": "Message types", "snpContent": "[<JavaScript ; AutoOpen >]\nmodule CommTypes =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment  : string\n        Footer   : string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName    : string\n        StartLine   : int\n        EndLine     : int\n        StartColumn : int\n        EndColumn   : int\n        Severity    : string\n        Message     : string\n        Subcategory : string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n    ", "snpParentIdO": {"SnippetId" :"343a4c7f-ba13-4370-b7db-59dc22ba562e"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"534f7a8c-81d0-4dea-ac82-ac109abfdd84"}, "snpName": "HttpRequest", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Newtonsoft.Json\n\nopen Utils\n\n[<JavaScript ; AutoOpen >]\nmodule MsgTypes =\n\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n    type ProjectRequest       = { FileName  : string                                                                                                               }\n    type LintRequest          = { FileName  : string                                                                                                               }\n    type HelptextRequest      = { Symbol    : string                                                                                                               }\n    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n\n    type FARequest =\n        | FarParse         of ParseRequest         \n        | FarDeclarations  of DeclarationsRequest  \n        | FarCompletion    of CompletionRequest    \n        | FarPosition      of PositionRequest      \n        | FarProject       of ProjectRequest       \n        | FarLint          of LintRequest          \n        | FarHelptext      of HelptextRequest      \n        | FarWorkspacePeek of WorkspacePeekRequest    \n\nlet toJson =\n    function\n    | FarParse         data -> JsonConvert.SerializeObject data \n    | FarDeclarations  data -> JsonConvert.SerializeObject data \n    | FarCompletion    data -> JsonConvert.SerializeObject data \n    | FarPosition      data -> JsonConvert.SerializeObject data \n    | FarProject       data -> JsonConvert.SerializeObject data \n    | FarLint          data -> JsonConvert.SerializeObject data \n    | FarHelptext      data -> JsonConvert.SerializeObject data \n    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n\nlet fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\nlet jsonData2Obj item = item?Data.ToString() |> fromJson\n\nlet HttpRequestCall (url:string) (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        //printfn \"<---\\n%s\\n\" data\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //print msg\n        //printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n        let jsonV  = JsonValue.Parse msg\n        return       jsonV\n    }\n\nlet KindError msg = KError { Code = 0 ; Message = msg }\n\nlet json2Kind (v:JsonValue) = \n    let item =JsonValue.Parse <| v.AsString()\n    match item?Kind.AsString() with\n    | \"info\"             -> jsonData2Obj item |> KInfo\n    | \"error\"            -> jsonData2Obj item |> KError\n    | \"errors\"           -> jsonData2Obj item |> KErrors\n    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n    | \"completion\"       -> jsonData2Obj item |> KCompletion\n    | \"signature\"        -> jsonData2Obj item |> KTypeSig\n    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n    | \"helptext\"         -> jsonData2Obj item |> KHelpText\n    | \"declarations\"     -> jsonData2Obj item |> KDeclarations\n    | \"symboluse\"        -> jsonData2Obj item |> KSymbolUse\n    | _                  -> KindError <| v.ToString()\n\nlet UrlAddress = \"http://localhost:9001/\"\n\n[< Rpc >]\nlet FSAutocompleteCall0 cmd (req: FARequest) : Async<Result<Kind [],ResultMessage<Kind[]>>> = asyncResult {\n        let  data          = req |> toJson\n        let! jsonV         = HttpRequestCall (UrlAddress + cmd) data\n        return               jsonV.AsArray() |> Array.map json2Kind\n    } \n\n[<JavaScript ; AutoOpen>]\nmodule Calls =\n    let FSAutocompleteCall cmd f req = asyncResult {\n            let! several       = FSAutocompleteCall0 cmd req\n            let  goods, others = several |> Array.partition (f >> Option.isSome)\n            let! good          = goods   |> Seq.choose f |> Seq.tryHead |> Result.ofOption (fun () -> others |> Message)\n            return               good, others\n        } \n    \n    let parseCode        file code asy ver   = FSAutocompleteCall \"parse\"               (function KErrors        v -> Some v |_-> None)\n                                                     <| FarParse       { FileName        = file\n                                                                         IsAsync         = asy   \n                                                                         Lines           = code           \n                                                                         Version         = ver\n                                                                       }\n    let toolTip          file lin col filter = FSAutocompleteCall \"tooltip\"             (function KToolTip       v -> Some v |_-> None)\n                                                     <| FarPosition    { FileName        = file\n                                                                         Line            = lin         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                       }\n    let signature        file lin col filter = FSAutocompleteCall \"signature\"           (function KTypeSig v -> Some v |_-> None)\n                                                     <| FarPosition    { FileName        = file\n                                                                         Line            = lin         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                       }\n    let signatureData    file lin col filter = FSAutocompleteCall \"signatureData\"       (function KSignatureData v -> Some v |_-> None)\n                                                     <| FarPosition    { FileName        = file\n                                                                         Line            = lin         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                       }\n    let completion  tx kw file ln col filter = FSAutocompleteCall \"completion\"          (function KCompletion    v -> Some v |_-> None)\n                                                      <| FarCompletion { FileName        = file\n                                                                         Line            = ln         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                         SourceLine      = tx\n                                                                         IncludeKeywords = kw\n                                                                        }\n    \n    let findTypeDecl     file lin col filter = FSAutocompleteCall \"findtypedeclaration\" (function KFindDecl    v -> Some v |_-> None)\n                                                      <| FarPosition    { FileName       = file\n                                                                          Line           = lin         \n                                                                          Column         = col\n                                                                          Filter         = filter\n                                                                        }\n    let findDeclaration  file lin col filter = FSAutocompleteCall \"finddeclaration\"     (function KFindDecl    v -> Some v |_-> None)\n                                                      <| FarPosition    { FileName       = file\n                                                                          Line           = lin         \n                                                                          Column         = col\n                                                                          Filter         = filter\n                                                                        }\n    let declarations    file code ver        = FSAutocompleteCall \"declarations\"       (function KDeclarations v -> Some v |_-> None)\n                                                      <| FarDeclarations{ FileName       = file\n                                                                          Lines          = code         \n                                                                          Version        = ver\n                                                                        }\n    let helpText               symbol        = FSAutocompleteCall \"helptext\"            (function KHelpText     v -> Some v |_-> None)\n                                                      <| FarHelptext    { Symbol         = symbol\n                                                                        }\n    let symbolUse       file lin col filter  = FSAutocompleteCall \"symboluse\"           (function KSymbolUse     v -> Some v |_-> None)\n                                                     <| FarPosition    { FileName        = file\n                                                                         Line            = lin         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                       }\n    let symbolUseProject file lin col filter = FSAutocompleteCall \"symboluseproject\"    (function KSymbolUse     v -> Some v |_-> None)\n                                                     <| FarPosition    { FileName        = file\n                                                                         Line            = lin         \n                                                                         Column          = col\n                                                                         Filter          = filter\n                                                                       }\n    \n    ", "snpParentIdO": {"SnippetId" :"343a4c7f-ba13-4370-b7db-59dc22ba562e"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}, {"SnippetId" :"7fdf570d-b418-4a71-afb9-5fc1302aadb0"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, "snpName": "Testing", "snpContent": "", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 204}, {"snpId": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpName": "TestingNoJS", "snpContent": "//#r @\"D:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\2.1.2\\netstandard.dll\"\n#r @\"C:\\Users\\Abelardo\\.nuget\\packages\\fuchu\\1.0.3\\lib\\fuchu.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\Unquote\\lib\\net45\\Unquote.dll\"\n\n// passes option --noframework to FSI and defines NOFRAMEWORK\n#define NOFRAMEWORK --noframework\n/// Testing area using TapRunner, NUnit and Unquote\nmodule TestingNoJS =\n    open Fuchu\n    open Swensen.Unquote\n\n    /// captures printoutfn for testing purposes\n    module StdOut =\n        let stdout = System.Text.StringBuilder()\n        let out (s:string) = stdout.Append s |> ignore\n        let call func parm =\n            stdout.Clear() |> ignore\n            func parm, stdout.ToString()\n        let run f p = call f p |> snd\n\n    /// used to capture print outs for testing. like printfn\n    let printoutfn  fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\" |>! printf \"%s\"|> StdOut.out)\n    /// silent version of printoutfn\n    let printoutfns fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\"                |> StdOut.out)\n    let printout      v = printoutfn \"%A\" v\n    let runTestList name (tests:Test seq) = \n        printfn \"Testing %s, %d tests...\" name (Seq.length tests) \n        run <| testList name tests \n    #if TESTALL\n    let mutable allTests : Test list = []\n    let runTests name (tests:Test seq) = allTests <- (testList name tests) :: allTests\n    #else\n    let runTests = runTestList\n    #endif      ", "snpParentIdO": {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ce272f6c-42f6-437e-8397-e12713d32986"}, "snpName": "Async", "snpContent": "let sleepSecondsA n = async {\n    let before = System.DateTime.UtcNow\n    return! Async.sleepThen (fun () -> System.DateTime.UtcNow - before) (n * 1000) \n}\n\nlet timeSpanToSeconds (dif:System.TimeSpan) = dif.Seconds\n\n[\n    testCase \"Async sleepThen, map & iter\" <|fun()->\n        let test n =\n            sleepSecondsA n \n            |> Async.map   timeSpanToSeconds\n            |> Async.iterS (printoutfn \"I slept for %d seconds\")\n        StdOut.run test 5 =! \"I slept for 5 seconds\\n\"\n\n    testCase \"Async apply\" <|fun()->\n        let (<*>) = Async.apply\n        (Async.rtn timeSpanToSeconds\n         <*> sleepSecondsA 5\n         |> Async.RunSynchronously) =! 5\n]|> runTests \"Async\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"4a8a65d9-16ab-41fc-9e4e-10348e3ffb40"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2b9eb737-e698-4faa-88ef-957201603717"}, "snpName": "Message", "snpContent": "[\n    testCase  \"ErrorMsg\"   <|fun()-> ErrorMsg(     \"Hello\")              .ToString()  =! \"Error    : Hello\" \n    testCase  \"Warning\"    <|fun()-> Warning(      \"Hello\")              .ToString()  =! \"Warning  : Hello\" \n    //testCase  \"ExceptMsg\"  <|fun()-> ExceptMsg(exn \"Hello\")              .ToString()  =! \"Exception: Hello\"\n    testCase  \"Message\"    <|fun()-> Message(      \"Hello\")              .ToString()  =!            \"Hello\" \n]|> runTests \"Message\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"3ad77be4-b1a7-4cd0-aad0-43808f4b55f6"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f1601861-090a-427c-9bba-1a1848680d0d"}, "snpName": "AsyncResult", "snpContent": "let hello i =\n    printoutfns \"before \"\n    async {\n        printoutfns \"wrap \"\n        let! h =  async { printoutfns \"Hello1 %d\" i } \n        return i + 1\n    }\n    \nlet whileA() = \n    let mutable i = 0\n    async {\n        let! a = async { return 2 }\n        while (printoutfns \"<%d>\" i ; i <= a) do\n            printoutfns \"%d: \" i\n            let! z = hello i \n            i <- z\n            printoutfns \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet xasyncIf () =\n    asyncResult {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello2 i =\n    printoutfns \"before \"\n    asyncResult {\n        printoutfns \"wrap \"\n        let hA  =  async { printoutfns \"Hello1 %d\" i } \n        let! h  =  hA\n        return i + 1\n    }\n\nlet helllo i =\n    asyncResult {\n        let h = hello i\n        return! h\n    }\n\nlet helo i =\n    asyncResult {\n        do! asyncResult { return () }\n        return i\n    }\n\nlet whileRA() = \n    let mutable i = 0\n    asyncResult {\n        let! a = async { return Result.Ok 2 } \n        while (printoutfns \"<%d>\" i ; i <= a) do\n            printoutfns \"%d: \" i\n            let! z = hello2 i\n            i <- z\n            printoutfns \" z = %d\" z\n        return! Async.rtn   ()\n    } |> Async.RunSynchronously\n\nlet whileRARA() =\n    let mutable i = 0\n    let aAR = async { return Result.Ok 2 }\n    aAR |> Async.map Result.Ok |> AsyncResult.bind (fun aR ->\n        aR |> Async.rtn |> AsyncResult.bind (fun a ->\n            let pred () = printoutfns \"<%d>\" i ; i <= a \n            let body = fun () ->\n                printoutfns \"%d: \" i\n                let zW = hello i\n                zW |> Async.map Result.Ok |> AsyncResult.bind (fun z ->\n                    i <- z\n                    printoutfns \" z = %d\" i\n                    AsyncResult.rtn   ()\n                )\n            let r = AsyncResult.whileLoop pred body\n            r\n        )\n    ) |> Async.RunSynchronously\n    \nlet forA() = \n    async {\n        let! a = async { return 2 }\n        for i = 0 to a do\n            printoutfns \"%d: \" i\n            let! z = hello i \n            printoutfns \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet forRA() = \n    asyncResult {\n        let! a = async { return Result.Ok 2 }\n        for i = 0 to a do\n            printoutfns \"%d: \" i\n            let! z = hello i\n            printoutfns \" z = %d\" z\n        return! AsyncResult.rtn   ()\n    } |> Async.RunSynchronously\n    \n[    \n    testCase \"whileRARA must be equal to whileA\" <|fun()-> StdOut.run whileRARA ()  =! StdOut.run whileA ()\n    testCase \"whileRA   must be equal to whileA\" <|fun()-> StdOut.run whileRA   ()  =! StdOut.run whileA ()\n    testCase \"forRA     must be equal to forA\"   <|fun()-> StdOut.run forRA     ()  =! StdOut.run forA   ()\n]|> runTests \"AsyncResult\"\n   ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bf5219ac-639f-4a9b-9a69-c51a1daf3006"}, "snpName": "RunProcess", "snpContent": "[\n    testCase \"ShellDidNotStart\"   <|fun()-> RunProcess.ShellDidNotStart              .ToString()  =! \"Shell did not start\" \n    testCase \"ShellExit0\"         <|fun()-> RunProcess.ShellExit(0, \"Hello\",\"\"      ).ToString()  =! \"Hello\" \n    testCase \"ShellExit0Err\"      <|fun()-> RunProcess.ShellExit(0, \"Hello\",\"ErrMsg\").ToString()  =! \"Hello\\nERROR:\\nErrMsg\" \n    testCase \"ShellExit1\"         <|fun()-> RunProcess.ShellExit(1, \"Hello\",\"\"      ).ToString()  =! \"exit(1)\\nHello\" \n    testCase \"ShellExit1Err\"      <|fun()-> RunProcess.ShellExit(1, \"\"     ,\"ErrMsg\").ToString()  =! \"exit(1)\\n\\nERROR:\\nErrMsg\" \n    testCase \"ShellCrashed\"       <|fun()-> RunProcess.ShellCrashed(\"Hello\",\"\"      ).ToString()  =! \"Shell crashed!\\nHello\" \n    testCase \"ShellCrashedErr\"    <|fun()-> RunProcess.ShellCrashed(\"\"     ,\"ErrMsg\").ToString()  =! \"Shell crashed!\\n\\nERROR:\\nErrMsg\" \n    testCase \"runToFinish err\"    <|fun()-> RunProcess.runToFinish \"cmd.exe\" \"@/c xswda\"          =! \"exit(1)\\n\\nERROR:\\n'xswda' is not recognized as an internal or external command,\\noperable program or batch file.\"\n    testCase \"runToFinish dir\"    <|fun()-> RunProcess.runToFinish \"cmd.exe\" \"@/c dir /kg\"        =! \"exit(1)\\n\\nERROR:\\nInvalid switch - \\\"kg\\\".\"\n    testCase \"runToFinish dir err\"<|fun()-> RunProcess.runToFinish \"cmd.exe\" \"@/c dir\"           <>! \"\" \n    testCase \"runToFinish hello\"  <|fun()-> RunProcess.runToFinish \"cmd.exe\" \"@/c echo Hello\"     =! \"Hello\" \n]|> runTests \"RunProcess\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"843a8e69-1379-4727-981c-b428b5d6102a"}, "snpName": "String", "snpContent": "[\n    testCase \"splitByChar\"       <|fun()-> String.splitByChar 'l' \"lello\"          =! [| \"\" ; \"e\" ; \"\" ; \"o\"|]\n    testCase \"contains true\"     <|fun()-> String.contains \"el\" \"Hello\"            =! true\n    testCase \"contains false\"    <|fun()-> String.contains \"Hello\" \"el\"            =! false\n    testCase \"trim\"              <|fun()-> String.trim \"   Hello \"                 =! \"Hello\"\n    testCase \"skipFirstLine\"     <|fun()-> String.skipFirstLine \"Hello\\nHi\"        =! \"Hi\"\n    testCase \"skipLastLine\"      <|fun()-> String.skipLastLine  \"Hello\\nHi\"        =! \"Hello\"\n    testCase \"unindentStr\"       <|fun()-> String.unindentStr \"\n                                                          Hello\n                                                            there\n                                             \"                              =! \"\\nHello\\n  there\\n\"\n    testCase \"indentStr\"         <|fun()-> String.indentStr 2 \"\\nHello\\n  there\\n\" =! \"  \\n  Hello\\n    there\\n  \"\n    testCase \"Substring2(-2, 4)\" <|fun()-> \"Hello\".Substring2(-2,4)                =! \"He\"\n    testCase \"Substring2(-2, 9)\" <|fun()-> \"Hello\".Substring2(-2,9)                =! \"Hello\"\n    testCase \"Left 3\"            <|fun()-> \"Hello\".Left(3)                         =! \"Hel\"\n    testCase \"Left 9\"            <|fun()-> \"Hello\".Left(9)                         =! \"Hello\"\n    testCase \"Right 3\"           <|fun()-> \"Hello\".Right(3)                        =! \"llo\"\n    testCase \"Right 9\"           <|fun()-> \"Hello\".Right(9)                        =! \"Hello\"\n]|> runTests \"Strings\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d038c52e-fb70-4754-a88e-be738ff8a156"}, "snpName": "swap", "snpContent": "[\n    testCase \"swap\" <|fun()-> [1..5] |> List.map (__ (/) 2) =! [ 0 ; 1 ; 1 ; 2 ; 2]\n]|> runTests \"swap\"\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"e8c919fa-0248-4bad-b472-3170282496d7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3a042f94-e371-482e-b8ee-4f01a582b2e4"}, "snpName": "Hole", "snpContent": "        \nlet absWip n = if n >= 0 then n else Hole?TODO_AbsForNegativeValue    \n        \n[\n    testCase \"absWip  1\" <|fun()->                absWip  1 =! 1\n    testCase \"absWip -1\" <|fun()-> raisesWith (<@ absWip -1 @>) (fun (e:System.NotImplementedException)-> <@ true @>)\n]|> runTests \"Hole\"\n ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"268771dc-ecc7-4dde-881b-e0b94deb30ea"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f8c52adc-a0fb-4afd-a07a-ba5a1468643e"}, "snpName": "ParseO", "snpContent": "let testPattern =\n    function\n    | ParseO.Int    v -> sprintf \"%A\" v\n    | ParseO.Single v -> sprintf \"%A\" v\n    | ParseO.Double v -> sprintf \"%A\" v\n    | ParseO.Date   v -> sprintf \"%A\" v\n    |               v -> sprintf \"%A\" v    \n\n[\n    testCase \"parseIntO ok\"      <|fun()-> ParseO.parseIntO    \"4\"      =! Some 4\n    testCase \"parseIntO no\"      <|fun()-> ParseO.parseIntO    \"4.\"     =! None\n    testCase \"parseSingleO ok\"   <|fun()-> ParseO.parseSingleO \"4.\"     =! Some 4.f\n    testCase \"parseSingleO no\"   <|fun()-> ParseO.parseSingleO \"4h\"     =! None\n    testCase \"parseDoubleO ok\"   <|fun()-> ParseO.parseDoubleO \"4.\"     =! Some 4.\n    testCase \"parseDoubleO no\"   <|fun()-> ParseO.parseDoubleO \"4h\"     =! None\n    testCase \"parseDateO ok\"     <|fun()-> ParseO.parseDateO \"12/31/11\" =! Some ( System.DateTime(2011, 12, 31) )\n    testCase \"parseDateO no\"     <|fun()-> ParseO.parseDateO \"31/12/11\" =! None\n    testCase \"testPattern Date\"  <|fun()-> testPattern       \"12/31/11\" =! \"12/31/2011 12:00:00 AM\"\n    testCase \"testPattern Int\"   <|fun()-> testPattern       \"12\"       =! \"12\"\n    testCase \"testPattern Single\"<|fun()-> testPattern       \"12.3111\"  =! \"12.3111f\"\n    testCase \"testPattern Double\"<|fun()-> testPattern       \"12.3e108\" =! \"1.23e+109\"\n    testCase \"testPattern None\"  <|fun()-> testPattern       \"Hello\"    =! \"\\\"Hello\\\"\"\n]|> runTests \"ParseO\"\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"6c60faf9-d558-4928-812d-711f349c4a90"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"913ea19d-e4e6-4019-b56b-0985943bc856"}, "snpName": "memoize", "snpContent": "\nlet slowSquare n =\n    async {\n        do! Async.Sleep 100\n        return n * n\n    } |> Async.RunSynchronously\n\nlet memoSquare    = Memoize.memoize slowSquare\nlet memoSquareR   = Memoize.ResetableMemoize slowSquare\n\nlet uniqueNum     = [ 1 ;  2 ; 3 ;  4 ;  5 ]\nlet repeatedNum   = [ 5 ; 10 ; 5 ; 20 ; 10 ]\nlet timeMeTenth v = timeMe 100 false v\n\n[\n    testCase \"slowSquare  unique\" <|fun()-> uniqueNum   |> timeMeTenth (List.map slowSquare      ) =! (5, [1;    4;  9;  16;  25])\n    testCase \"memoSquare  unique\" <|fun()-> uniqueNum   |> timeMeTenth (List.map memoSquare      ) =! (5, [1;    4;  9;  16;  25])\n    testCase \"memoSquareR unique\" <|fun()-> uniqueNum   |> timeMeTenth (List.map memoSquareR.Call) =! (5, [1;    4;  9;  16;  25])\n    testCase \"slowSquare  repeat\" <|fun()-> repeatedNum |> timeMeTenth (List.map slowSquare      ) =! (5, [25; 100; 25; 400; 100])\n    testCase \"memoSquare  repeat\" <|fun()-> repeatedNum |> timeMeTenth (List.map memoSquare      ) =! (2, [25; 100; 25; 400; 100])\n    testCase \"memoSquareR repeat\" <|fun()-> memoSquareR.ClearCache()\n                                            repeatedNum |> timeMeTenth (List.map memoSquareR.Call) =! (3, [25; 100; 25; 400; 100])\n]|> runTests \"memoize\"\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"045a7205-0f3e-46fe-9b72-87d0a5f84f79"}, {"SnippetId" :"3af10c2d-9854-4233-bc2b-9aa5213735a0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"914e0aa7-eb60-483c-9b1f-d0ea3814585e"}, "snpName": "TempFileName", "snpContent": "module TempFileName =\n    module ReaderM = ReaderMAsyncResult\n    open ReaderM.Operators\n\n    let createAndRead txt = asyncResult {\n      return! asyncResult {\n        use file = new TempFileName()\n        do! Async.Sleep 1000\n        do! Async.Sleep 1000\n        System.IO.File.WriteAllText(file.Name, txt)\n        let txt = System.IO.File.ReadAllText(file.Name)\n        return System.IO.File.Exists file.Name, txt, file.Name |>! print\n      }\n    }\n    \n    let createAndCheck () =\n        createAndRead \"Hello\" \n        |> Async.RunSynchronously \n        |> Result.map (fun (before, txt, fname) -> before, System.IO.File.Exists fname, txt)\n    \n    let createAndReadRm txt = asyncResult {\n      return! reader {\n        do!  Async.Sleep 1000 |> ReaderM.rtnA\n        use file = new TempFileName()\n        do!  Async.Sleep 1000 |> ReaderM.rtnA\n        do!  Async.Sleep 1000 |> ReaderM.rtnA\n        System.IO.File.WriteAllText(file.Name, txt)\n        let txt = System.IO.File.ReadAllText(file.Name)\n        return System.IO.File.Exists file.Name, txt, file.Name |>! print\n       } |> ReaderM.run ()\n    }\n    \n    let createAndCheck2 () =\n        createAndReadRm \"Hello\"\n        |> Async.RunSynchronously \n        |> Result.map (fun (before, txt, fname) -> before, System.IO.File.Exists fname, txt)\n    \n    \n    [\n        testCase \"createAndDeleteTempFile\"   <|fun()-> createAndCheck () =! Ok(true, false, \"Hello\")\n        testCase \"createAndDeleteTempFileRm\" <|fun()-> createAndCheck2() =! Ok(true, false, \"Hello\")\n    ]|> runTests \"TempFileName\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"3bc3bc4c-8ab8-4370-b0a0-7fd337ffa24c"}, {"SnippetId" :"4e5cb303-7196-461f-8cf4-74922fb76531"}, {"SnippetId" :"a7e4ee55-8458-49ba-96f7-b61f8f268e4f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1f979f5c-a46b-4e1e-a5e2-17b689e07d76"}, "snpName": "Mailbox", "snpContent": "let logThisMsgA  = Mailbox.iterA       print (fun  msg         -> async { printoutfn \"Log: %s\" msg   } )\nlet logThisMsg   = Mailbox.iter        print (fun  msg         ->         printoutfn \"Log: %s\" msg     )\nlet toUpperCaseA = Mailbox.callA       print (fun (msg:string) -> async { return msg.ToUpper()       } )\nlet toUpperCase  = Mailbox.call        print (fun (msg:string) ->                msg.ToUpper()         )\nlet addTo        = Mailbox.fold        (fun e st -> print e ; st) (fun st v -> st + v |>! printoutfn \"%d\" ) 0\nlet totalize     = Mailbox.stateFull   (fun e st -> print e ; st)  0\n\n[\n    testCase \"iterA\"     <|fun()-> StdOut.run (fun () ->\n                                   logThisMsgA.Post \"message Async1\"\n                                   logThisMsgA.Post \"message Async2\"\n                                   Async.Sleep 100 |> Async.RunSynchronously) () =! \"Log: message Async1\\nLog: message Async2\\n\"\n    testCase \"iter \"     <|fun()-> StdOut.run (fun () ->\n                                   logThisMsg .Post \"message 1\"\n                                   logThisMsg .Post \"message 2\"\n                                   Async.Sleep 100 |> Async.RunSynchronously) () =! \"Log: message 1\\nLog: message 2\\n\"\n    testCase \"callA\"     <|fun()-> toUpperCaseA.PostAndReply      \"Hello\"                           =! \"HELLO\"\n    testCase \"call \"     <|fun()-> toUpperCaseA.PostAndReply      \"Hello\"                           =! \"HELLO\"\n    testCase \"callA A\"   <|fun()-> toUpperCaseA.PostAndAsyncReply \"Hello\" |> Async.RunSynchronously =! \"HELLO\"\n    testCase \"call  A\"   <|fun()-> toUpperCaseA.PostAndAsyncReply \"Hello\" |> Async.RunSynchronously =! \"HELLO\"\n    testCase \"fold   \"   <|fun()-> StdOut.run (fun () ->\n                                   addTo.Post 9\n                                   addTo.Post 13\n                                   Async.Sleep 100 |> Async.RunSynchronously) () =! \"9\\n22\\n\"\n    testCase \"stateFull\" <|fun()-> totalize |> Mailbox.StateFull.apply ((+) 7)\n                                   totalize |> Mailbox.StateFull.apply ((+)11)\n                                   totalize |> Mailbox.StateFull.getState =! 18\n    testCase \"stateFullReply\" <|fun()-> \n                                   totalize |> Mailbox.StateFull.applyReply(fun st -> st + 2, sprintf \"old=%d\" st)\n                                   |> Async.RunSynchronously =! \"old=18\"\n]|> runTests \"Mailbox\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"4978150b-d7ac-40f1-b1f5-e4c0773a7d56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"94cdd95e-6113-4260-867f-1f071c4709c9"}, "snpName": "ResourceAgent", "snpContent": "let agent = new ResourceAgent<_,_>(3, (fun n -> ref n |> fun vr -> fun () -> vr := !vr + 1; !vr), 0)\n\n[\n    testCase \"Process\" <|fun()-> StdOut.run (fun () ->\n                                 agent.Process (fun f -> f() |> printout)\n                                 agent.Process (fun f -> f() |> printout)\n                                 agent.Process (fun f -> f() |> printout)\n                                 agent.Process (fun f -> f() |> printout)\n                                 Async.Sleep 100 |> Async.RunSynchronously) () =! \"1\\n2\\n3\\n1\\n\"\n]|> runTests \"ResourceAgent\"", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"a98f07ba-8de4-4baa-9714-793169bf36ac"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"21847254-3329-4667-8ae5-3a168be25062"}, "snpName": "fsiAgent", "snpContent": "module FsiAgent =\n    open FsiEvaluator\n    open FsiAgent\n    \n    let getRAtoString   = \n        Async.RunSynchronously \n        //>>! print\n        >>! fun _-> disposeFsiExe()\n        >> (function | Ok v -> v | Error e -> sprintf \"%A\\n\" e) \n        //>>! printfn \":%s:\"\n        >>  String.skipLastLine\n        //>>! printfn \":%s:\"\n        \n    let presenceCodeF() = FsCode \"let pr v = printfn \\\"%A\\\" v\"\n    \n    let fsCode = String.unindentStr >> FsCode\n    \n    let codeWithRefsValid = fsCode \"\"\"\n        #r @\"..\\..\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\"\n        open Newtonsoft.Json\n        \n        let getJsonNetJson value =\n            sprintf \"!%s!\" (JsonConvert.SerializeObject(value))\n        printfn \"%s\" <| getJsonNetJson \"Hello\"\n        \"\"\"\n    \n    let codeWithRefsInvalid = fsCode \"\"\"\n        #r @\"..\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\"\n        open Newtonsoft.Json\n        \n        let getJsonNetJson value =\n            sprintf \"!%s!\" (JsonConvert.SerializeObject(value))\n        printfn \"%s\" <| getJsonNetJson \"Hello\"\n        \"\"\"\n    \n    [\n        testCase \"Fsi evalCode\"             <|fun()-> FsCode \"printfn \\\"Hello\\\"\" |> evalCode             |> getRAtoString =! \"Hello\"\n        testCase \"Fsi evalCodeSameConfig\"   <|fun()-> FsCode \"printfn \\\"Hello\\\"\" |> evalCodeSameConfig   |> getRAtoString =! \"Hello\"\n        testCase \"Fsi evalCodeWithPresence\" <|fun()-> FsCode \"pr      \\\"Hello\\\"\" \n                                                      |> evalCodeWithPresence \"testFsiAgent\" \"v0.1\" presenceCodeF\n                                                      |> getRAtoString =! \"\\\"Hello\\\"\"\n        testCase \"Fsi codeWithRefs valid\"   <|fun()-> codeWithRefsValid   |> evalCode |> getRAtoString  =! \"!\\\"Hello\\\"!\"\n        testCase \"Fsi codeWithRefs invalid\" <|fun()-> codeWithRefsInvalid |> evalCode |> getRAtoString |> fun s -> s.Contains \"was not found or is invalid\" =! true\n    ]|> runTests \"fsiAgent\"\n    ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"886b5dd6-4b3c-4897-b473-8f066f776fe0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cdb289a4-b2cd-4488-be03-758125305ae0"}, "snpName": "CommArg", "snpContent": "module CommArg =\n    module ReaderM = ReaderMResult\n    \n    open ReaderM.Operators\n    open CommArgCollection\n\n    let test1       = CommArg.NewInt   (\"test1\", true , sprintf \"--T1 %d\")\n    let test2       = CommArg.NewInt   (\"test2\", false, sprintf \"--T2 %d\")\n    let test3       = CommArg.NewInt   (\"test3\", false, sprintf \"--T3 %d\")\n    let test4       = CommArg.NewInt   (\"test4\", false, sprintf \"--T4 %d\")\n    let test5       = CommArg.NewString(\"test5\", false, sprintf \"--T5 %A\")\n    let test6       = CommArg.NewBool  (\"test6\", false, sprintf \"--T6 %A\")\n    let test7       = CommArg.NewFloat (\"test7\", false, sprintf \"--T7 %A\")\n    let test8       = CommArg.NewFloat (\"test8\", false, sprintf \"--T8 %A\")\n    let test9       = CommArg.NewString(\"test9\", false, sprintf \"--T9 %A\")\n    \n    let pairs       = [ test1 /= 4\n                        test1 /= 5 \n                        test2 /= 6 \n                        test2 /= 7 \n                        test2 /= (fun (CommArgCollection coll) -> coll |> Seq.length)\n                        test2 /= reader {\n                                    let! iO = tryGetIntORm test1\n                                    let  i  = iO |> Option.defaultValue 0 \n                                    return i * 12\n                                 }                                       \n                        test4 /= (getIntRm    test3 |>> ( * ) 12           )\n                        test5 /= (getIntRm    test2 |>> sprintf \"Value %d\" )\n                        test6 /= (getIntRm    test2 |>> (=)    8           )\n                        test7 /= (getIntRm    test2 |>> float              )\n                        test9 /= (getStringRm test5 |>> (+) \"Hello \"       )\n                      ] :  (CommArg * ReaderM<obj,CommArgCollection<obj>,ResultMessage<obj>>) list\n    let args        = CommArgCollection pairs |> addPairs pairs |> addPairs  pairs\n    let allArgsRm   = argumentsRm trueForAll\n    let notAllArgsRm= argumentsRm (fun (arg,_) -> arg.cargId <> test4.CommArg.cargId)\n    let produce vRm = \n        ReaderM.run args vRm\n        |> Result.map (fun (arg,v) -> sprintf \"%s %A\" arg.name v)\n        |> function Ok v -> v | Error m -> sprintf \"%A\" m\n    let produceCollection vRm = \n        ReaderM.run args vRm\n        |> Result.map (String.concat \"\\n\" )\n        |> function Ok v -> v | Error m -> sprintf \"%A\" m\n    \n\n    [\n        testCase \"CommArg test1\"             <|fun()-> produce (CommArgCollection.findArgRm test1) =! \"test1 5\"\n        testCase \"CommArg test2\"             <|fun()-> produce (CommArgCollection.findArgRm test2) =! \"test2 6\"\n        testCase \"CommArg test3\"             <|fun()-> produce (CommArgCollection.findArgRm test3) =! \"ErrorMsg \\\"argument not found: test3\\\"\"\n        testCase \"CommArg test5\"             <|fun()-> produce (CommArgCollection.findArgRm test5) =! \"test5 \\\"Value 6\\\"\"\n        testCase \"CommArgCollection not all\" <|fun()-> produceCollection notAllArgsRm              =! \"--T2 6\\n--T2 7\\n--T2 28\\n--T2 60\\n--T5 \\\"Value 6\\\"\\n--T6 false\\n--T7 6.0\\n--T9 \\\"Hello Value 6\\\"\\n--T2 6\\n--T2 7\\n--T2 28\\n--T2 60\\n--T5 \\\"Value 6\\\"\\n--T6 false\\n--T7 6.0\\n--T9 \\\"Hello Value 6\\\"\\n--T1 5\\n--T2 6\\n--T2 7\\n--T2 28\\n--T2 60\\n--T5 \\\"Value 6\\\"\\n--T6 false\\n--T7 6.0\\n--T9 \\\"Hello Value 6\\\"\"\n        testCase \"CommArgCollection all\"     <|fun()-> produceCollection allArgsRm                 =! \"ErrorMsg \\\"argument not found: test3\\\"\"\n    ]|> runTests \"fsiAgent\"\n    \n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"4e5cb303-7196-461f-8cf4-74922fb76531"}, {"SnippetId" :"c3be67ee-321f-4eb2-ba98-345957897fec"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e0b45416-8f3f-4986-b207-999d8fa0d101"}, "snpName": "FsCompiler", "snpContent": "module FsCompiler =\n    open LibraryNoJS.FsCompiler\n    open FsCode\n  \n    let args() =\n          [\n              fscDebug      /= \"full\"\n              fscDefine     /= \"DEBUG\"\n              fscDefine     /= \"TRACE\"\n              fscTarget     /= \"winexe\"\n              fscGenFSharp1 /= \"g\"\n              fscGenFSharp2 /= \"warn:3\"\n              fscGenFSharp2 /= \"warnaserror:76\"\n              fscGenFSharp2 /= \"vserrors\"\n              fscGenFSharp2 /= \"utf8output\"\n              fscGenFSharp2 /= \"fullpaths\"\n              fscGenFSharp2 /= \"flaterrors\"\n              fscGenFSharp2 /= \"subsystemversion:6.00\"\n              fscGenFSharp2 /= \"highentropyva+\"\n              fscGenFSharp2 /= \"optimize-\"\n              fscGenFSharp2 /= \"tailcalls-\"\n              fscSource     /= @\"Compiled\\Calculate primes\\Calculate primes.fs\"\n              fscOutput     /= @\"Compiled\\Calculate primes\\Calculate primes.exe\"\n              fscIOption    /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n              fscIOption    /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n          ]\n  \n    [\n      testCase \"Success\" <| fun() ->\n          args()\n          |> Seq.ofList\n          |> CommArgCollection\n          |> compile\n          |> Async.RunSynchronously\n          |> sprintf \"%A\"\n          =! \"Ok\\n  [|D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (40,26)-(40,32) typecheck warning The value 'holder' is unused;\\n    D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (72,14)-(72,20) typecheck warning The value 'isDone' is unused;\\n    D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (106,14)-(106,18) typecheck warning The value 'args' is unused;\\n    D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (126,31)-(126,35) typecheck warning The value 'args' is unused;\\n    D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (127,31)-(127,35) typecheck warning The value 'args' is unused;\\n    D:\\\\Abe\\\\CIPHERWorkspace\\\\FSharpStation\\\\bin\\\\Compiled\\\\Calculate primes\\\\Calculate primes.fs (128,31)-(128,35) typecheck warning The value 'args' is unused|]\"\n\n      testCase \"fail\"     <| fun() ->\n          args()\n          |> Seq.filter (fun (arg,_) -> arg.cargId <> fscSource.CommArg.cargId)\n//          |>! (Seq.iter print)\n          |> CommArgCollection\n          |> compile\n          |> Async.RunSynchronously\n          |> sprintf \"%A\"\n          =! \"Error\\n  (Message [|commandLineArgs (0,1)-(0,1) parameter error No inputs specified|])\"\n    ]|> runTests \"FsCompiler\"\n    ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"a1a3625f-748c-4e87-aaa2-fbe07392235d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ef7163b3-0aae-4046-80b4-98195a490e7b"}, "snpName": "WsCompiler", "snpContent": "module WsCompiler =\n    open LibraryNoJS.WsCompiler\n    open FsCode\n  \n    let removeTimes s = \n        s \n        |> String.splitByChar '\\n'\n        |> Seq.map (String.splitByChar ':' >> Seq.head)\n        |> String.concat \"\\n\"\n        \n    let compileArgs (args: unit-> #seq<ArgValueTuple<_>>) = \n        args()\n        |> Seq.cast\n        |> CommArgCollection\n        //|>! fun args -> ReaderM.iterS (Seq.iter print) print args (CommArgCollection.argumentsRm CommArgCollection.trueForAll)\n        |> compile\n        |> Async.RunSynchronously\n        |>! print\n        |> Result.map removeTimes\n        |> sprintf \"%A\"\n\n    let args () =\n          [\n              fscSource      /= @\"Compiled\\ClientServerDemo\\ClientServerDemo.fs\"\n              fscOutput      /= @\"Compiled\\ClientServerDemo\\ClientServerDemo.exe\"\n              wscProjectType /= \"site\"\n              wscWebSite     /= @\"Compiled\\ClientServerDemo\\website\"\n              wscProjectPath /= \"ClientServerDemo\"\n              wscGenWSharper /= \"jsmap+\"          \n              fscDebug       /= \"full\"\n              fscDefine      /= \"DEBUG\"\n              fscDefine      /= \"TRACE\"\n              fscDefine      /= \"WEBSHARPER\"\n              fscTarget      /= \"exe\"\n              fscGenFSharp1  /= \"g\"\n              fscGenFSharp2  /= \"warn:3\"\n              fscGenFSharp2  /= \"warnaserror:76\"\n              fscGenFSharp2  /= \"vserrors\"\n              fscGenFSharp2  /= \"utf8output\"\n              fscGenFSharp2  /= \"fullpaths\"\n              fscGenFSharp2  /= \"flaterrors\"\n              fscGenFSharp2  /= \"subsystemversion:6.00\"\n              fscGenFSharp2  /= \"highentropyva+\"\n              fscGenFSharp2  /= \"optimize-\"\n              fscGenFSharp2  /= \"tailcalls-\"\n              fscGenFSharp2  /= \"noframework\"\n              fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n              fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n              fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n              fscIOption     /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n              fscIOption     /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n              fscIOption     /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\"\n              fscIOption     /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n              fscReference   /= @\"..\\packages\\Owin.Compression\\lib\\net452\\Owin.Compression.dll\"\n              fscReference   /= @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n              fscReference   /= @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n              fscReference   /= @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n              fscReference   /= @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n              fscReference   /= @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n              fscReference   /= @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n              fscReference   /= @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n          ]\n\n    [\n        testCase \"fail\"    <|fun()-> (fun () -> args() |> Seq.skip 1) |> compileArgs  =! \"Error (ErrorMsg \\\"parameter error FS0207: No inputs specified\\\")\"\n        testCase \"success\" <|fun()->            args                  |> compileArgs  =! \"Ok\\n  \\\"F# compilation\\nChecking project\\nWaiting on merged metadata\\nParsing with FCS\\nAnalyzing function arguments\\nResolving names\\nWebSharper translation\\nSource position transformations\\nPackaging assembly\\nWriting .js and .map.js\\nWriting .min.js and .min.map.js\\nHashing resources\\nSerializing metadata\\nWriting resources into assembly\\nunpacking into D\\nUnpacking\\\"\"\n    ]|> runTests \"WsCompiler\"\n\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"81abdec6-6b53-4888-8490-25c185d718e2"}, "snpName": "WsTranslate", "snpContent": "module WsTranslate =\n    open WsTranslate\n    open FsCode\n    \n    let code =\n        //\"\"\"\n        //    #I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n        //    #I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n        //    #I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\"\n        //    #I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n        //    #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n        //    #r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n        //    #r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n        //    module FSSGlobal\n        //      open WebSharper\n        //      open WebSharper.JavaScript\n        //      open WebSharper.UI\n        //      open WebSharper.UI.Client\n        //      open WebSharper.UI.Html\n        //      type on   = WebSharper.UI.Html.on\n        //      type attr = WebSharper.UI.Html.attr\n        //      \n        //      [<assembly: JavaScriptExport>]\n        //      do ()\n        //      \n        //      [<JavaScript>]\n        //      module Useful =\n        //        let [<Inline>] inline swap f a b = f b a\n        //        let [<Inline>] inline __   f a b = f b a\n        //      [<JavaScript>]\n        //      module Template      =\n        //        [<NoComparison ; NoEquality>]\n        //        type Button = {\n        //            _class  : string\n        //            _type   : string\n        //            style   : string\n        //            text    : string\n        //            onClick : Dom.Element -> Dom.MouseEvent -> unit\n        //            disabled: bool\n        //            id      : string\n        //        } with\n        //          static member inline New txt = \n        //              { _class   = \"btn\" \n        //                _type    = \"button\" \n        //                style    = \"\"\n        //                text     = txt\n        //                onClick  = fun _ _ -> ()\n        //                disabled = false\n        //                id       = \"\"\n        //              }\n        //          member        this.Render     =         \n        //            button [ attr.``type``  <| this._type\n        //                     attr.``class`` <| this._class\n        //                     attr.id        <| this.id  \n        //                     attr.style     <| this.style\n        //                     on.click <@ this.onClick @>\n        //                   ]\n        //                   [ text  <| this.text \n        //                   ] \n        //          member inline this.Id          id   = { this with id       = id             }\n        //          member inline this.Class       clas = { this with _class   = clas           }\n        //          member inline this.Type        typ  = { this with _type    = typ            }\n        //          member inline this.Style       sty  = { this with style    = sty            }\n        //          member inline this.Text        txt  = { this with text     = txt            }\n        //          member inline this.Disabled    dis  = { this with disabled = dis            }\n        //          member inline this.OnClick     f    = { this with onClick  = f              }\n        //          \n        //      [<JavaScript >]\n        //      module Snippets =\n        //        Template.Button\n        //           .New(    \"Press me!\"                         )\n        //           .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n        //           .Style(  \"font-size: 48px\"                   )\n        //           .Render\n        //        |> Doc.RunAppend JS.Document.Body\n        //           \n        //        let m = Var.Create 0\n        //        \n        //        View.Sink (fun currentValue -> printfn \"Value is now %d\" currentValue) m.View\n        //        \n        //        //[<SPAEntryPoint>]\n        //        let main() = \n        //            printfn \"Value starts as  %d\" m.Value\n        //            async {\n        //                m.Value <- 1\n        //                do! Async.Sleep 1000\n        //                m.Value <- 2\n        //            } |> Async.Start\n        //    \"\"\" //|> ignore\n        \"\"\"\n            #I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n            #I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n            #r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n            #r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n            #I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\"\n            #I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n            #r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n            module Hello\n                open WebSharper\n                [< assembly: JavaScriptExport >]\n                do ()\n                \n                let run() = printfn \"Hello\"\n        \"\"\"        \n        \n    let translateCode code =\n        code\n        |> String.unindentStr\n        |> String.skipFirstLine\n        |> FsCode\n        |> translateJs (CommArgCollection [ intShowArgs /= false ; fscGenFSharp2 /= \"noframework\" ])\n        |> Async.RunSynchronously\n        |> Result.map (fun (_, s:string) -> s.Replace(\"\\r\", \"\"))\n        |> function Ok v -> \"Compiled!\\n\" + sprintf \"%A\" v | Error v -> sprintf \"%A\" v\n    \n    let codeJs = \"(function()\\n{\\n \\\"use strict\\\";\\n var Global,Hello,console;\\n Global=self;\\n Hello=Global.Hello=Global.Hello||{};\\n console=Global.console;\\n Hello.run=function()\\n {\\n  (function($1)\\n  {\\n   return $1(\\\"Hello\\\");\\n  }(function(s)\\n  {\\n   console.log(s);\\n  }));\\n };\\n}());\"\n    [\n        testCase \"fail\"    <|fun()-> translateCode (code + \"xxx\")|> String.contains codeJs =! true\n        testCase \"success\" <|fun()-> translateCode  code         |> String.contains codeJs =! true\n    ]|> runTests \"WsTranslate\"\n\n\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"64c13907-9cf6-4abf-adad-a43a33b21c42"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c5b91125-2dda-43cc-b9d2-76bf71e26685"}, "snpName": "", "snpContent": "#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\nmodule FSSGlobal =\n  open WebSharper\n  open WebSharper.JavaScript\n  open WebSharper.UI\n  open WebSharper.UI.Client\n  open WebSharper.UI.Html\n  type on   = WebSharper.UI.Html.on\n  type attr = WebSharper.UI.Html.attr\n  \n  [<assembly: JavaScriptExport>]\n  do ()\n  \n  [<JavaScript>]\n  module Useful =\n    let [<Inline>] inline swap f a b = f b a\n    let [<Inline>] inline __   f a b = f b a\n  [<JavaScript>]\n  module Template      =\n    [<NoComparison ; NoEquality>]\n    type Button = {\n        _class  : string\n        _type   : string\n        style   : string\n        text    : string\n        onClick : Dom.Element -> Dom.MouseEvent -> unit\n        disabled: bool\n        id      : string\n    } with\n      static member inline New txt = \n          { _class   = \"btn\" \n            _type    = \"button\" \n            style    = \"\"\n            text     = txt\n            onClick  = fun _ _ -> ()\n            disabled = false\n            id       = \"\"\n          }\n      member        this.Render     =         \n        button [ attr.``type``  <| this._type\n                 attr.``class`` <| this._class\n                 attr.id        <| this.id  \n                 attr.style     <| this.style\n                 on.click <@ this.onClick @>\n               ]\n               [ text  <| this.text \n               ] \n      member inline this.Id          id   = { this with id       = id             }\n      member inline this.Class       clas = { this with _class   = clas           }\n      member inline this.Type        typ  = { this with _type    = typ            }\n      member inline this.Style       sty  = { this with style    = sty            }\n      member inline this.Text        txt  = { this with text     = txt            }\n      member inline this.Disabled    dis  = { this with disabled = dis            }\n      member inline this.OnClick     f    = { this with onClick  = f              }\n      \n  [<JavaScript>]\n  module Snippets =\n    Template.Button\n       .New(    \"Press me!\"                         )\n       .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n       .Style(  \"font-size: 48px\"                   )\n       .Render\n    |> Doc.RunAppend JS.Document.Body\n       \n    let m = Var.Create 0\n    \n    View.Sink (fun currentValue -> printfn \"Value is now %d\" currentValue) m.View\n    \n    [<SPAEntryPoint>]\n    let main() = \n        printfn \"Value starts as  %d\" m.Value\n        async {\n            m.Value <- 1\n            do! Async.Sleep 1000\n            m.Value <- 2\n        } |> Async.Start", "snpParentIdO": {"SnippetId" :"81abdec6-6b53-4888-8490-25c185d718e2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"244ac98a-1c0e-4af9-b645-b6ae4f625260"}, "snpName": "WebSockets", "snpContent": "#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n\nmodule WebSockets =\n    open WebSharper.Owin.WebSocket\n    open WebSharper.Owin.WebSocket.Client\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n    open WebSharper.Owin.WebSocket\n    open WebSharper.UI.Server\n    open WebSharper.UI.Html\n    \n    type EndPointServer = \n        | Hello\n        | About\n    \n    open WebSockets\n    let url = \"http://localhost:9097/\"\n    let rootdir = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\RuleEditorNew\\website\"\n    let site()  = WebSharper.Application.MultiPage(fun context (s:EndPointServer) -> printfn \"Serving page: %A\" s ;Content.Page(Body = [ text <| sprintf \"Hello, This is a WebSocket server: %A\" s], Title= \"WEBSOCKET SERVER\") )\n    let server (url:string) = \n        let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n        let broker = Broker.BrokerAgent epWebSocket\n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                               , Sitelet             = (Some <| site())\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootdir)))\n                .UseWebSocket(  epWebSocket, broker.Start)\n            |> ignore)\n\n    let startMsgBroker =\n      lazy \n        async {\n          try\n            let n = 50\n            use runningServer = server url\n            printfn \"Listening for %d seconds on %s\" n url\n            do! Async.Sleep (n * 1000)\n          finally\n            printfn \"Closing %s\" url\n        } |> Async.Start\n\n    let get3Listeners() =\n        startMsgBroker.Value\n        //asyncResult {\n        //    use client1 = new WSMessagingClient(\"TestWebSocket1\", endPoint= \"localhost:9097/ws\")\n        //    use client2 = new WSMessagingClient(\"TestWebSocket2\", endPoint= \"localhost:9097/ws\")\n        //    use client3 = new WSMessagingClient(\"TestWebSocket3\", endPoint= \"localhost:9097/ws\")\n        //    printfn \"Started WebSockets client\"\n        //    do! Async.Sleep 3000\n        //    let! listeners1 = client1.MBListeners\n        //    let! listeners2 = client2.MBListeners\n        //    let! listeners3 = client3.MBListeners\n        //    //listeners3 |> Seq.iter print\n        //    //printfn \"Finished WebSockets client\"\n        //    return listeners3\n        //} |> Async.RunSynchronously |> Result.toOption |> Option.defaultValue [||]\n        [||]\n\n    [\n        testCase \"3 listeners\" <|fun()-> get3Listeners() =! [| \"TestWebSocket1\" ; \"TestWebSocket2\" ; \"TestWebSocket3\"  |]\n    ]|> runTests \"WebSockets\"\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"48e111a3-1b92-4da3-8353-ae73ece0bca0"}, {"SnippetId" :"580c84e5-f8ba-467a-8e26-45ca810cb06d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"83796d20-f00f-4b0c-8e5f-39ef8b83694a"}, "snpName": "FsAutoComplete .net", "snpContent": "module FsAutoComplete =\n    open FsAutoComplete\n    open FsAutoComplete.CommTypes\n\n    let fname = \"Test.Fsx\"\n    let code = String.unindent \"\"\"\n        let hello(world:string) = sprintf \"Hello %s!\" world\n        hello \"World\"\n        this\n        \"\"\" |> Seq.skip 1 |> Seq.toArray \n    \n    [\n        testCase \"parse\"            <|fun()-> parseCode               fname code true 0      |> Async.RunSynchronously =! Ok    ({File = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";      Errors =       [|{FileName = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";          StartLine = 3;          EndLine = 3;          StartColumn = 1;          EndColumn = 5; Severity=\"Error\" ; Message =           \"The value or constructor 'this' is not defined. Maybe you want one of the following:\\r\\n   ThisAssembly\";          Subcategory = \"typecheck\";}|];},   [|KInfo \"Background parsing started\"|])\n        testCase \"declarations\"     <|fun()-> declarations            fname code      0      |> Async.RunSynchronously =! Ok    ([|{Declaration = {UniqueName = \"Test_1_of_1\";                         Name = \"Test\";                         Glyph = \"Module\";                         GlyphChar = \"N\";                         IsTopLevel = true;                         File = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";                         EnclosingEntity = \"M\";                         IsAbstract = false;};          Nested = [|{UniqueName = \"Test_1_of_1\";                      Name = \"hello\";                      Glyph = \"Field\";                      GlyphChar = \"F\";                      IsTopLevel = false;                      File = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";                      EnclosingEntity = \"M\";                      IsAbstract = false;}|];}|], [||])\n        testCase \"completion\"       <|fun()-> completion  \"hel\" false fname 2 4 \"StartsWith\" |> Async.RunSynchronously =! Ok    ([|{Name = \"hello\";                  ReplacementText = \"hello\";                  Glyph = \"Method\";                  GlyphChar = \"M\";}|],   [|KHelpText {Name = \"hello\";                Overloads = [[{Signature = \"val hello : world:string -> string\";                               Comment = \"\"; Footer=box null |> unbox}]];}|])\n        testCase \"tooltip\"          <|fun()-> toolTip                 fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    ([|[|{Signature = \"val hello: \\n   world: string \\n       -> string\";                  Comment = \"\"; Footer = \"Full name: Test.hello\\nAssembly: Test\"}|]|], [||])\n        testCase \"finddeclaration\"  <|fun()-> findDeclaration         fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    ({File = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";           Line = 1;           Column = 5;}, [||])\n        //testCase \"findtypedecl\"     <|fun()-> findTypeDecl            fname 1 18 \"\"          |> Async.RunSynchronously =! Error (Message [|KInfo \"Request cancelled (exn was System.InvalidOperationException: not a named type\\r\\n   at <StartupCode$FSharp-Compiler-Service>.$Symbols.get_TypeDefinition@1891.Invoke(Unit unitVar0)\\r\\n   at Microsoft.FSharp.Compiler.SourceCodeServices.Impl.protect[a](FSharpFunc`2 f)\\r\\n   at <StartupCode$FsAutoComplete-Core>.$CompilerServiceInterface.r@76.Invoke(FSharpType f) in D:\\Abe\\CIPHERWorkspace\\Repos\\FSAutoComplete\\src\\FsAutoComplete.Core\\CompilerServiceInterface.fs:line 76\\r\\n   at Microsoft.FSharp.Core.OptionModule.Map[T,TResult](FSharpFunc`2 mapping, FSharpOption`1 option)\\r\\n   at <StartupCode$FsAutoComplete-Core>.$CompilerServiceInterface.TryFindTypeDeclaration@70-1.Invoke(FSharpOption`1 _arg3) in D:\\Abe\\CIPHERWorkspace\\Repos\\FSAutoComplete\\src\\FsAutoComplete.Core\\CompilerServiceInterface.fs:line 76\\r\\n   at Microsoft.FSharp.Control.AsyncBuilderImpl.args@506-1.Invoke(a a))\"|])\n        testCase \"helptext\"         <|fun()-> helpText                          \"hello\"      |> Async.RunSynchronously =! Ok    ({Name = \"hello\"; Overloads = [[{Signature = \"val hello : world:string -> string\"; Comment = \"\"; Footer=box null |> unbox }]];}, [||])\n        testCase \"finddecl err\"     <|fun()-> findDeclaration         fname 3 4 \"\"           |> Async.RunSynchronously =! Error (Message [|KError {Code = 1; Message = \"Could not find declaration\";}|])\n        testCase \"findtypedecl err\" <|fun()-> findTypeDecl            fname 2 4 \"\"           |> Async.RunSynchronously =! Error (Message [|KInfo \"Request cancelled (exn was System.InvalidOperationException: not a named type\\r\\n   at <StartupCode$FSharp-Compiler-Service>.$Symbols.get_TypeDefinition@1891.Invoke(Unit unitVar0)\\r\\n   at Microsoft.FSharp.Compiler.SourceCodeServices.Impl.protect[a](FSharpFunc`2 f)\\r\\n   at <StartupCode$FsAutoComplete-Core>.$CompilerServiceInterface.r@76.Invoke(FSharpType f) in D:\\Abe\\CIPHERWorkspace\\Repos\\FSAutoComplete\\src\\FsAutoComplete.Core\\CompilerServiceInterface.fs:line 76\\r\\n   at Microsoft.FSharp.Core.OptionModule.Map[T,TResult](FSharpFunc`2 mapping, FSharpOption`1 option)\\r\\n   at <StartupCode$FsAutoComplete-Core>.$CompilerServiceInterface.TryFindTypeDeclaration@70-1.Invoke(FSharpOption`1 _arg3) in D:\\Abe\\CIPHERWorkspace\\Repos\\FSAutoComplete\\src\\FsAutoComplete.Core\\CompilerServiceInterface.fs:line 76\\r\\n   at Microsoft.FSharp.Control.AsyncBuilderImpl.args@506-1.Invoke(a a))\"|])\n        testCase \"signature\"        <|fun()-> signature               fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    (\"val hello : world:string -> string\", [||])\n        testCase \"signatureData\"    <|fun()-> signatureData           fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    ({OutputType = \"string\"; Parameters = [[{Name = \"world\"; Type = \"string\";}]];}, [||])\n        testCase \"symboluse\"        <|fun()-> symbolUse               fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    ({Name = \"hello\";       Uses =        [{FileName = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";          StartLine = 1;          StartColumn = 5;          EndLine = 1;          EndColumn = 10;          IsFromDefinition = true;          IsFromAttribute = false;          IsFromComputationExpression = false;          IsFromDispatchSlotImplementation = false;          IsFromPattern = false;          IsFromType = false;};         {FileName = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";          StartLine = 2;          StartColumn = 1;          EndLine = 2;          EndColumn = 6;          IsFromDefinition = false;          IsFromAttribute = false;          IsFromComputationExpression = false;          IsFromDispatchSlotImplementation = false;          IsFromPattern = false;          IsFromType = false;}];}, [||])\n        testCase \"symboluseproject\" <|fun()-> symbolUseProject        fname 2 4 \"\"           |> Async.RunSynchronously =! Ok    ({Name = \"hello\";       Uses =        [{FileName = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";          StartLine = 1;          StartColumn = 5;          EndLine = 1;          EndColumn = 10;          IsFromDefinition = true;          IsFromAttribute = false;          IsFromComputationExpression = false;          IsFromDispatchSlotImplementation = false;          IsFromPattern = false;          IsFromType = false;};         {FileName = \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\Test.Fsx\";          StartLine = 2;          StartColumn = 1;          EndLine = 2;          EndColumn = 6;          IsFromDefinition = false;          IsFromAttribute = false;          IsFromComputationExpression = false;          IsFromDispatchSlotImplementation = false;          IsFromPattern = false;          IsFromType = false;}];}, [||])\n    ]|> runTests \"FsAutoComplete\"\n    ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"534f7a8c-81d0-4dea-ac82-ac109abfdd84"}, {"SnippetId" :"cf92aeb9-d7f6-4c50-b495-345004a0d611"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e2b1aad1-d603-491f-8892-801f606b4ff8"}, "snpName": "Snippet", "snpContent": "module Snippet =\n    module ReaderM = ReaderMResult\n\n    let snippet0 = { Snippet.New \"test0\" \"module Hello =\"                             None                 with snpId = SnippetId <| System.Guid.Parse \"00000000-0000-0000-0000-000000000001\" }\n    let snippet1 = { Snippet.New \"test1\" \"let hello world = sprintf \\\"Hello, %s!\\\" \" (Some snippet0.snpId) with snpId = SnippetId <| System.Guid.Parse \"00000000-0000-0000-0000-000000000002\" }\n    let snippet2 = { Snippet.New \"test2\" \"Hello.hello \\\"World\\\" \"                     None                 with snpId = SnippetId <| System.Guid.Parse \"00000000-0000-0000-0000-000000000003\" \n                                                                                                                snpPredIds = Set[ snippet1.snpId ] }\n    let snps     = [ snippet0\n                     snippet1\n                     snippet2 ]\n    let snpColl    = {\n        generation       = 0\n        ordered          = snps\n        fetcher          = fun id -> Seq.tryFind (fun snp -> snp.snpId = id) snps\n        predecesorsCache = Memoize.checkStore\n        reducedCache     = Memoize.checkStore\n        prepCode         = fun snp -> snp.snpContent\n    }\n    \n    let snpIds = snps |> Seq.map (fun snp -> snp.snpId)\n    \n    let run rm = rm |> ReaderM.run snpColl \n    [\n        testCase \"codeFsxRm\" <|fun()-> Snippet.codeFsxRm snippet2.snpId |> run =! Ok \"module Hello =\\n    let hello world = sprintf \\\"Hello, %s!\\\" \\nHello.hello \\\"World\\\" \"\n    ]|> runTests \"Snippet\"\n\n#define FIX_GENERIC", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"658c3bce-5862-4232-8799-f6600494d37b"}, "snpName": "Tree", "snpContent": "module Tree =\n    open Tree\n        \n    let mutable private snippets               = [||]\n    let mutable private hierarchy              = ([||])//:Node<>)\n    let mutable private generation             = 5\n    let mutable private currentSnippetIdOV     = (None:SnippetId option)\n    let mutable private collapsedV             = Set.empty\n    \n    let setCurrentSnippetIdO snpIdO    = currentSnippetIdOV <- snpIdO\n    let setHierarchy            nodes  = hierarchy <- nodes\n    let setSnippets             snps   = snippets  <- snps\n    let setSnippet              snp    = if snp.snpId.Id <> System.Guid.Empty then\n                                            snippets |> Array.tryFindIndex (fun s -> s.snpId = snp.snpId)\n                                            |> function\n                                            | Some i -> snippets.[i] <- snp\n                                            | None   -> snippets <- snippets |> Array.append <| [| snp |]\n    let getSnippetsGen              () = snippets, generation, collapsedV\n\n    let getParentIdO             snpId = snippets |> Array.tryFind (fun s -> s.snpId = snpId) |> Option.bind(fun s -> s.snpParentIdO)\n    let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                         getParentIdO snpId\n                                         |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                         |> Option.defaultValue false\n    let ftch              sid = snippets |> Array.tryFind (fun s -> s.snpId = sid) \n    let rec path          sid = ftch sid\n                                |> Option.bind (fun snp -> snp.snpParentIdO |> Option.bind ftch) \n                                |> Option.map  (fun prn -> path prn.snpId   |> fun rest -> prn.snpId :: rest ) \n                                |> Option.defaultValue []\n\n    let setChildren snpId ch =\n        let chIds = ch |> Array.map (fun s -> s.id())\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n        |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n        |> Seq.iter    setSnippet\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n        |> Seq.map    (fun s -> { s with snpParentIdO = None })\n        |> Seq.iter    setSnippet\n        let descendants, others = snippets |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n        let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n        [| yield! others.[0..index]\n           for chid in chIds do\n               yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n               yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n           yield! others.[index+1..]\n        |]\n        |> setSnippets\n\n    let rec treenode (snpId:SnippetId) =\n        {\n            id                 = fun () -> printfn \"id = %A\" snpId.Id ; snpId\n            isExpanded         = fun () -> not <| Set.contains snpId collapsedV\n            canHaveChildren    = fun () -> true\n            children           = fun () -> print snpId.Id ; snippets |> Seq.filter(fun s -> s.snpParentIdO = Some snpId) |> Seq.map (fun snp -> print snp.snpName ; treenode snp.snpId)\n            newChildren        = fun ch -> setChildren snpId ch\n                                           treenode    snpId\n            parentO            = fun _ns-> snippets |> Array.tryFind (fun s -> s.snpId = snpId) |> Option.bind (fun x -> x.snpParentIdO) |> Option.map treenode\n            path               = fun () -> path snpId\n        }\n        \n    let addSnippetRm snp = \n        setSnippet snp\n        let hier = hierarchy |> Seq.append [| treenode snp.snpId |]\n        currentSnippetIdOV\n        |>  Option.bind ftch\n        |> tee (fun _ -> traceI \"before moveToSibling2\")\n        |> function\n        | None     -> hier\n        | Some sbl -> hier |> Tree.moveToSibling2 true snp.snpId sbl.snpId\n        |> tee (fun _ -> traceI \"finished moveToSibling2\")\n        |> Seq.toArray\n        |> setHierarchy\n        \n    let newSnippet _ =\n        let snp = Snippet.New \"\" \"\" None\n        addSnippetRm snp\n        |> fun () -> currentSnippetIdOV <- (Some snp.snpId)\n        \n    async {\n        newSnippet()\n        do! Async.Sleep 500\n        newSnippet()\n    } |> Async.RunSynchronously\n    ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}, {"SnippetId" :"beee1304-d287-4b81-841f-9289cb3572c1"}, {"SnippetId" :"fc37fa2a-f517-4945-82f3-8ce10c8cbb33"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b0f688e7-c35c-42e3-bdd3-ffca42804587"}, "snpName": "TreeReader", "snpContent": "module TreeReader =\n    module ReaderM = ReaderMResult\n    open TreeReader\n    open ReaderM.Operators\n    \n    let mutable private snippets               = [||]\n    let mutable private hierarchy              = ([||] : Node<_,_,ResultMessage<obj>>[])\n    let mutable private generation             = 5\n    let mutable private currentSnippetIdOV     = (None:SnippetId option)\n    let mutable private collapsedV             = Set.empty\n    \n    let snippetsColl                () = { generation = generation ; ordered = snippets ; fetcher = fun id -> snippets |> Array.tryFind (fun s -> s.snpId = id) }\n    let handleError                 er = (er:ResultMessage<obj>) |> string |> exn |> raise\n    let iterReader                  rm = rm |> ReaderMResult      .iter handleError id (snippetsColl())\n       \n    let setCurrentSnippetIdO snpIdO    = currentSnippetIdOV <- snpIdO\n    let setHierarchy            nodes  = hierarchy <- nodes\n    let setSnippets             snps   = snippets  <- snps\n    let setSnippet              snp    = if snp.snpId.Id <> System.Guid.Empty then\n                                            snippets |> Array.tryFindIndex (fun s -> s.snpId = snp.snpId)\n                                            |> function\n                                            | Some i -> snippets.[i] <- snp\n                                            | None   -> snippets <- snippets |> Array.append <| [| snp |]\n    let getSnippetsGen              () = snippets, generation, collapsedV\n\n    let getParentIdO             snpId = snippets |> Array.tryFind (fun s -> s.snpId = snpId) |> Option.bind(fun s -> s.snpParentIdO)\n    let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                         getParentIdO snpId\n                                         |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                         |> Option.defaultValue false\n\n    let codeAndStartsRm            snp = Snippet.uniquePredsRm snp >>= Snippet.codeAndStartsRm \n\n    let setChildrenRm snpId ch = reader {\n        let chIds = ch |> Array.map (fun s -> s.id())\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n        |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n        |> Seq.iter    setSnippet\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n        |> Seq.map    (fun s -> { s with snpParentIdO = None })\n        |> Seq.iter    setSnippet\n        let descendants, others = snippets |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n        let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n        [| yield! others.[0..index]\n           for chid in chIds do\n               yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n               yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n           yield! others.[index+1..]\n        |]\n        |> setSnippets\n    }\n\n    let rec treenode (snpId:SnippetId) =\n        {\n            id                 = fun () -> printfn \"id = %A\" snpId.Id ; snpId\n            isExpandedRm       = fun () -> rtn (not <| Set.contains snpId collapsedV)\n            canHaveChildrenRm  = fun () -> rtn true\n            childrenRm         = fun () -> print snpId.Id ; Snippet.childrenRm snpId |>> Seq.map (fun snp -> print snp.snpName ; treenode snp.snpId)\n            newChildrenRm      = fun ch -> setChildrenRm snpId ch   |>> fun () -> \n                                           treenode      snpId\n            parentORm          = fun _ns-> Snippet.snippetORm snpId |>> Option.bind (fun x -> x.snpParentIdO) |>> Option.map treenode\n            pathRm             = fun () -> Snippet.pathRm snpId\n        }\n        \n    let addSnippetRm snp = \n        setSnippet snp\n        let hier = hierarchy |> Seq.append [| treenode snp.snpId |]\n        currentSnippetIdOV\n        |>  Option.map Snippet.snippetORm |>  ReaderM.insertO |>> Option.bind id\n        |>> tee (fun _ -> traceI \"before moveToSibling2\")\n        >>= function\n        | None     -> hier |> rtn\n        | Some sbl -> hier |> TreeReader.moveToSibling2 true snp.snpId sbl.snpId\n        |>> tee (fun _ -> traceI \"finished moveToSibling2\")\n        |>> Seq.toArray\n        |>> setHierarchy\n        \n    let newSnippet _ =\n        let snp = Snippet.New \"\" \"\" None\n        addSnippetRm snp\n        |>> fun () -> currentSnippetIdOV <- (Some snp.snpId)\n        |>  iterReader\n        \n    async {\n        newSnippet()\n        do! Async.Sleep 500\n        newSnippet()\n        do! Async.Sleep 500\n        newSnippet()\n        do! Async.Sleep 500\n        newSnippet()\n    } |> Async.RunSynchronously\n    ", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"7f466863-bdb1-49fd-b0a5-e8f426c6efff"}, {"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}, {"SnippetId" :"beee1304-d287-4b81-841f-9289cb3572c1"}, {"SnippetId" :"f85b70d0-9c9f-49bf-b169-bba338bd55e3"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b6a2849d-4b07-4e22-96b5-25b4253f2732"}, "snpName": "FSharpStationClient", "snpContent": "#define FIX_GENERIC\n#define RUN2\nmodule FSharpStationClient =\n\n    let printCode path =\n        path\n        |> FSharpStationClient.getCode\n        |> AsyncResult.iterS (printfn \"==>%A<==\") (printfn \"-->%A<--\")\n\n    printCode @\"FsRoot/Testing/TestingNoJS/StringX\"\n    printfn \"\\n\\n-----------------------\\n\\n\"\n    printCode @\"FsRoot/Applications/FSharpStation/FSharpStation3\"\n", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e576c119-cb3c-4189-a4fa-6cd675f771c8"}, "snpName": "Test all", "snpContent": "// include all desired tests as predecessors\n#define TESTALL\n\nrunTestList \"All Tests\" <| List.rev allTests", "snpParentIdO": {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}, "snpPredIds": [{"SnippetId" :"1f979f5c-a46b-4e1e-a5e2-17b689e07d76"}, {"SnippetId" :"21847254-3329-4667-8ae5-3a168be25062"}, {"SnippetId" :"244ac98a-1c0e-4af9-b645-b6ae4f625260"}, {"SnippetId" :"2b9eb737-e698-4faa-88ef-957201603717"}, {"SnippetId" :"3a042f94-e371-482e-b8ee-4f01a582b2e4"}, {"SnippetId" :"658c3bce-5862-4232-8799-f6600494d37b"}, {"SnippetId" :"81abdec6-6b53-4888-8490-25c185d718e2"}, {"SnippetId" :"83796d20-f00f-4b0c-8e5f-39ef8b83694a"}, {"SnippetId" :"843a8e69-1379-4727-981c-b428b5d6102a"}, {"SnippetId" :"913ea19d-e4e6-4019-b56b-0985943bc856"}, {"SnippetId" :"914e0aa7-eb60-483c-9b1f-d0ea3814585e"}, {"SnippetId" :"94cdd95e-6113-4260-867f-1f071c4709c9"}, {"SnippetId" :"b0f688e7-c35c-42e3-bdd3-ffca42804587"}, {"SnippetId" :"b6a2849d-4b07-4e22-96b5-25b4253f2732"}, {"SnippetId" :"bf5219ac-639f-4a9b-9a69-c51a1daf3006"}, {"SnippetId" :"cdb289a4-b2cd-4488-be03-758125305ae0"}, {"SnippetId" :"ce272f6c-42f6-437e-8397-e12713d32986"}, {"SnippetId" :"d038c52e-fb70-4754-a88e-be738ff8a156"}, {"SnippetId" :"e0b45416-8f3f-4986-b207-999d8fa0d101"}, {"SnippetId" :"e2b1aad1-d603-491f-8892-801f606b4ff8"}, {"SnippetId" :"ef7163b3-0aae-4046-80b4-98195a490e7b"}, {"SnippetId" :"f1601861-090a-427c-9bba-1a1848680d0d"}, {"SnippetId" :"f8c52adc-a0fb-4afd-a07a-ba5a1468643e"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpName": "TestingJS", "snpContent": "#define WEBSHARPER\n\n[< JavaScript >]\nmodule TestingJS =\n", "snpParentIdO": {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"54261e69-0cd7-43bc-966b-c19d56ce24e9"}, "snpName": "newWindowEvalRA", "snpContent": "module RunJs =\n    open RunJs\n    \n    [< SPAEntryPoint >]\n    let main() =\n        JsCode \"console.log('HeLLO')\"\n        |> newWindowEvalRA (Url \"http://localhost:9005/Main.html\")\n        |> AsyncResult.iterA ignore print\n", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"ebb5ddf2-0325-4e33-90e5-f5f033206d78"}], "snpProperties": [], "snpGeneration": 78}, {"snpId": {"SnippetId" :"ab75d2fd-e73a-401f-b463-1b81320c364d"}, "snpName": "button", "snpContent": "module Button =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n    \n    [< SPAEntryPoint >]\n    let main() =\n        div    [] [\n            text \"When you press the button \"\n            button [ on.click (fun _ _ -> JS.Alert \"Hello!\") ] [ text \"Press Me!\" ]\n            text \" It should respond 'Hello!'\"\n        ]\n        |> Doc.Run JS.Document.Body", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9cf160b2-be02-4e34-9e47-7686712b3813"}, "snpName": "REGEX", "snpContent": "module CodeMirror =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n\n    [< SPAEntryPoint >]\n    let main() =\n        let rexV   = Var.Create \"\"\"(Err|Warn|Info) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n        let parmsV = Var.Create \"g\"\n        let inputV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\"\n        div [] [\n            div [] [ div [] [ text \"RegEx:\"    ] ; Doc.InputAreaV [ attr.style \"width: 1000px; height:80px \" ] rexV.V   ]\n            div [] [          text \"Options: \"   ; Doc.InputV     [ attr.style \"width: 700px\"                ] parmsV.V ]\n            div [] [ div [] [ text \"Input:\"    ] ; Doc.InputAreaV [ attr.style \"width: 1000px; height:80px \" ] inputV.V ]\n            div [] [\n                View.Map3 (fun inp rx opt ->\n                    ul [] \n                       [ match inp with\n                         | REGEX rx opt m -> yield! m |> Array.map (text >> List.singleton >> (li [])) //|> Seq.map (fun x -> x :> Doc)\n                         | _              -> yield  text \"<no match>\" \n                       ]\n                    ) inputV.View rexV.View parmsV.View\n                |> Doc.BindView id\n            ]\n        ]\n        |> Doc.Run JS.Document.Body", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [{"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}], "snpProperties": [], "snpGeneration": 113}, {"snpId": {"SnippetId" :"e8da5a6c-c49a-494f-9dcb-8c9048a57cb8"}, "snpName": "CodeMirror", "snpContent": "module CodeMirror =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n    open CodeMirror\n\n    [<NoComparison ; NoEquality>]\n    type KeyMapAutoComplete = { \n        F2              : Editor -> unit \n        F11             : Editor -> unit \n        Tab             : Editor -> unit\n        ``Ctrl-Space``  : Editor -> unit\n        ``.``           : Editor -> unit\n    }\n\n    let codeMirrorNew    (var           : Var<string>                         ) \n                         (annotationsWO : View<Lint.Response []>        option) \n                         (showToolTipO  :(string -> int -> int -> unit) option) \n                         (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                       -> string -> int -> int -> unit) option) =\n    \n        let setDirtyCond() = ()\n        let getHints    _  = ()\n\n        let showToolTip (ed:CodeMirror.Editor) =\n            showToolTipO |> Option.iter(fun showToolTipF ->\n                let  pos   = ed.GetCursor()\n                let  l     = ed.GetLine pos.line\n                showToolTipF l pos.line pos.ch\n            )\n            \n        let getHints    (ed:CodeMirror.Editor, callback, _) =\n            getHintsO |> Option.iter(fun getHintsF ->\n                let  pos   = ed.GetCursor()\n                let  l     = ed.GetLine pos.line\n                let showHints hints posFrom posTo =\n                    let hs = hints\n                             |> Array.map(fun (txt, dsp, cls) -> \n                                {\n                                    Hint.Hint.text        = txt\n                                    Hint.Hint.displayText = dsp\n                                    Hint.Hint.className   = cls\n                                })\n                    callback {\n                        Hint.Response.list   = hs\n                        Hint.Response.from   = cmPos posFrom\n                        Hint.Response.``to`` = cmPos posTo\n                    }\n                getHintsF showHints l pos.line pos.ch\n            )\n            \n        CodeMirror.newVar var\n        |> onRender(fun ed ->\n              ed.AddKeyMap({  F2              = showToolTip\n                              F11             = fun ed -> ed.SetOption(\"fullScreen\", ed.GetOption(\"fullScreen\") |> unbox |> not) \n                              Tab             = fun ed -> ed.ReplaceSelection(\"    \", \"end\")\n                              ``Ctrl-Space``  =                                               Hint.showHints ed getHints false\n                              ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\")) >> Hint.showHints ed getHints false\n                           })\n              ed.SetOption(\"mode\"         , \"fsharp\"  )\n              ed.SetOption(\"theme\"        , \"rubyblue\")\n              ed.SetOption(\"lineNumbers\"  , true      )\n              ed.SetOption(\"matchBrackets\", true      )\n              ed.SetOption(\"gutters\"      , [| \"CodeMirror-lint-markers\" |])\n              ed.On(\"dblclick\", showToolTip)\n              annotationsWO\n              |> Option.iter(fun annotationsW ->\n                  View.Sink       (fun _ -> ed.PerformLint() |> ignore) annotationsW\n                  Lint.setLint ed (fun (_t, send, _o, _ed) -> annotationsW |> View.Get send)\n              )\n        )\n        \n    let transformAnnotations msgs =\n        let rex  = \"\"\"(Err|Warn|Info) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n        match msgs with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                     -> Some (ty, int fl, int fc, int tl, int tc, msg)\n            | _      -> None\n        )\n        |> Array.map (fun (ty, fl, fc, tl, tc, msg) ->\n                { Lint.Response.message  = msg\n                  Lint.Response.severity = match ty with \"Err\" -> \"error\" | \"Warn\" -> \"warning\" |_-> \"info\"\n                  Lint.Response.from     = cmPos(fl - 1, fc - 1) \n                  Lint.Response.``to``   = cmPos(tl - 1, tc - 1)\n                }\n          )        \n            \n    [< SPAEntryPoint >]\n    let main() =\n        let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\"\n        let codeMirror = codeMirrorNew  <| Var.Create \"Hello there.\\nHello there.\\nHello there.\\n\"\n                                        <| Some (V(transformAnnotations annotationsV.V))\n                                        <| None\n                                        <| None\n        div [] [\n            div [] [ codeMirror |> CodeMirror.render ]\n            div [] [ text codeMirror.var.V           ]\n            text \"These are the annotations that create tooltips, warnings and errors:\"\n            Doc.InputAreaV [] annotationsV.V\n        ]\n        |> Doc.Run JS.Document.Body\n        ", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [{"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"cf5e8897-67ea-4ff2-af55-7cf7b7c71b50"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d8bef94d-d50e-4c3d-8901-14e038358767"}, "snpName": "monaco", "snpContent": "module Monaco =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n    open Monaco\n    \n    type HoverProvider(ed:Editor) =\n        do()\n       with\n          member __.provideHover(model:Model, pos:Position, token:obj) =\n              let word = model.GetWordAtPosition pos\n              if isUndefined word then box null |> unbox else\n              {\n                  contents = { value = word?word |> sprintf \"The word is: %s\" ; isTrusted = true } |> Array.singleton\n                  range    = {\n                                startLineNumber = pos.lineNumber\n                                endLineNumber   = pos.lineNumber\n                                startColumn     = word.startColumn\n                                endColumn       = word.endColumn\n                             }\n              }\n\n    type CompletionItemProvider(ed:Editor) =\n        do()\n       with\n          member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj): CompletionItem[] =\n              let word = model.GetWordAtPosition pos\n              if isUndefined word then box null |> unbox else\n              [|\n                { kind = CompletionItemKind.Function ; label = \"Hello\"   ; detail = \"\"}\n                { kind = CompletionItemKind.Function ; label = \"How\"     ; detail = \"\"}\n                { kind = CompletionItemKind.Function ; label = \"Are\"     ; detail = \"\"}\n                { kind = CompletionItemKind.Function ; label = \"You\"     ; detail = \"\"}\n                { kind = CompletionItemKind.Function ; label = word?word ; detail = \"\"}\n\n              |]\n          member __.resolveCompletionItem(item: CompletionItem, token: obj): CompletionItem = { item with detail = \"more details\" }\n    type DefinitionProvider(ed:Editor) =\n        do()\n       with\n          member __.provideDefinition(model: Model, pos: Position, token: obj): Location =\n              let word = model.GetWordAtPosition pos\n              if isUndefined word then box null |> unbox else\n              let ms = model.FindMatches(word.word, false, false, true, \" <>()+-=.,/#@$%^&*\\\"\", false, 1)\n              if ms.Length = 0    then box null |> unbox else\n              { range = ms.[0].range\n                uri = model.uri\n              }\n\n    let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\\nHint (4, 7) - (4, 12): \\\"This shows over there as a hint\\\".\"\n    let transformAnnotations msgs =\n        let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n        match msgs with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                     -> Some (ty, int fl, int fc, int tl, int tc, msg)\n            | _      -> None\n        )\n        |> Array.map (fun (ty, fl, fc, tl, tc, msg) ->\n                { message  = msg\n                  severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                  startColumn     = fc\n                  endColumn       = tc\n                  startLineNumber = fl\n                  endLineNumber   = tl\n                }\n          )        \n            \n        \n    let monacoNew        (var           : Var<string>                         ) \n                         (annotationsWO : View<MarkerData []>           option) \n                         (showToolTipO  :(string -> int -> int -> unit) option) \n                         (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                       -> string -> int -> int -> unit) option) =\n    \n        let setDirtyCond() = ()\n        let getHints    _  = ()\n                            \n        Monaco.newVar var\n        |> onRender(fun ed -> \n            Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n            Editor.SetTheme(\"vs-dark\")\n            let hp = new HoverProvider         (ed)\n            let cp = new CompletionItemProvider(ed)\n            let dp = new DefinitionProvider    (ed)\n            hp.provideHover |> print\n            cp.provideCompletionItems |> print\n            cp.resolveCompletionItem  |> print\n            dp.provideDefinition      |> print\n            Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n            Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n            Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n            annotationsWO\n            |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) \n            )\n        )\n\n    [< SPAEntryPoint >]\n    let main() =\n        let var = Var.Create \"Hello there.\\nHello there.\\nHello there.\\nHello there.\\n\"\n        let monaco       = monacoNew    <| var\n                                        <| Some (V(if var.V = \"\" then [||] else transformAnnotations annotationsV.V))\n                                        <| None\n                                        <| None\n        div [] [\n            div [ attr.style \"height: 400px; width: 800px\" ] [ monaco |> Monaco.render ]\n            div [] [ text \"These are the annotations that create tooltips, warnings and errors:\" ]\n            Doc.InputAreaV [ attr.style \"height: 100px; width: 600px\" ] annotationsV.V\n            div [] [ text var.V           ]\n        ]\n        |> Doc.Run JS.Document.Body\n        ", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [{"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"f0e7bfb2-3e35-4979-b803-20a280dc2086"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 197}, {"snpId": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpName": "AppFramework", "snpContent": "#define WEBSHARPER\r\n\r\n", "snpParentIdO": {"SnippetId" :"fb098a04-742f-4cf9-894b-0d297f8304bd"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"b5cc70a5-9934-4e19-8964-d2e673283d74"}, "snpName": "TestAppFramework", "snpContent": "#r @\"..\\projects\\LayoutEngine\\bin\\LayoutEngine.dll\"\r\nopen FsRoot\r\n[< JavaScriptExport (typeof<WebComponent.WcSplitter.WcSplitterT>) >]\r\ndo()\r\n\r\n[< JavaScript >]\r\nmodule Test =\r\n    [< SPAEntryPoint >]\r\n    let main() =\r\n        AppFramework.getMainDoc.Value |> Doc.Run JS.Window.Document.Body \r\n", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 205}, {"snpId": {"SnippetId" :"d13d1035-6560-4f45-91d1-2703166e5f43"}, "snpName": "run TestAppFramework", "snpContent": "#define TEST13\r\n#define FIX_GENERIC\r\nmodule RunTestingJs =\r\n    \r\n    open System.IO\r\n    open RunProcess\r\n    open WsTranslate2\r\n    open FsCode\r\n    \r\n    [< Inline \"throw 'runTest is not intended for JavaScript client'\" >]\r\n    let runTest name = \r\n        asyncResultM {\r\n            let! url    = FSharpStationClient.getUrl()                                      |> AsyncResult.freeMessage\r\n            let! code   = FSharpStationClient.getCode <| \"FsRoot/Testing/TestingJS/\" + name |> AsyncResult.freeMessage\r\n            let  args   = [ intShowArgs    /= false\r\n                            fscGenFSharp2  /= \"noframework\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n                          ]\r\n            let! js = FsCode code |> translate (CommArgCollection args)\r\n            let  testFile = @\"..\\website\\testing\\testing.js\"\r\n            do   File.WriteAllText(testFile, js)\r\n            let modif   = File.GetLastWriteTime testFile\r\n            do   startProcess (sprintf \"%stesting/testing.html?q=%A\" url modif)     \"\" |> ignore\r\n        } |> AsyncResultM.iterpS id\r\n        \r\n    if not IsClient then\r\n        runTest \"AppFramework/TestAppFramework\"", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"5c9f3c72-0dd9-47c9-9bf2-7130d92b5bc4"}, {"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}], "snpProperties": [], "snpGeneration": 222}, {"snpId": {"SnippetId" :"6cb8e49b-86e5-4a2a-9006-5eca869c97d5"}, "snpName": "translate FSharpStation", "snpContent": "#cd @\"..\\projects\\FSharpStation\\src\"\r\n#define TRANSLATEFSharpStation11\r\n#define FIX_GENERIC\r\nmodule RunTestingJs =\r\n    \r\n    open System.IO\r\n    open RunProcess\r\n    open WsTranslate\r\n    open FsCode\r\n    \r\n    [< Inline \"throw 'runTest is not intended for JavaScript client'\" >]\r\n    let runTest name = \r\n        asyncResult {\r\n            let! code   = FSharpStationClient.getCode name\r\n            let  args   = [ intShowArgs    /= true\r\n                            wscProjectType /= \"html\"\r\n                            fscGenFSharp2  /= \"noframework\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\r\n                          ]\r\n            let! tx, js = FsCode code |> translateJs (CommArgCollection args)\r\n            printf \"%s\" tx\r\n        } |> Async.RunSynchronously |> printfn \"%A\"\r\n        \r\n    if not IsClient then\r\n        runTest \"FsRoot/Applications/FSharpStation/Sitelet\"", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"64c13907-9cf6-4abf-adad-a43a33b21c42"}], "snpProperties": [], "snpGeneration": 209}, {"snpId": {"SnippetId" :"ad082ad8-f989-4ef8-879e-19489c5e08ac"}, "snpName": "translate FSharpStation2", "snpContent": "#cd @\"..\\projects\\FSharpStation\\src\"\r\n#define TRANSLATEFSharpStation12\r\n#define FIX_GENERIC\r\nmodule RunTestingJs =\r\n    \r\n    module ReaderM = ReaderMResult\r\n    open ReaderM.Operators\r\n    open System.IO\r\n    open WsTranslate2\r\n    open FsCode\r\n    open CommArgCollection\r\n    \r\n    [< Rpc >]\r\n    let runTest name = \r\n        asyncResultM {\r\n            let! code   = FSharpStationClient.getCode name |> AsyncResult.freeMessage\r\n            let  args   = debugOptions()\r\n                        + [ intShowArgs    /= true\r\n                            wscProjectType /= \"site\"\r\n                            fscTarget      /= \"exe\"\r\n                            wscProjectPath /= \"FSharpStation\"\r\n                            fscGenFSharp2  /= \"noframework\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\r\n                            fscReference   /= @\"..\\packages\\fsharp.core\\lib\\net45\\FSharp.Core.dll\"\r\n                          ]\r\n            let! js     = FsCode code |> translate args\r\n            File.WriteAllText(\"code.js\", js)\r\n        } \r\n        \r\n    if not IsClient then\r\n        runTest \"FsRoot/Applications/FSharpStation/FSharpStation\"\r\n        |> AsyncResultM.iterS (ResultMessage.summarizedF countTranslatorError >> print) id", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"5c9f3c72-0dd9-47c9-9bf2-7130d92b5bc4"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"212887a1-7c22-4369-bdc3-90de933fe8f9"}, "snpName": "Documentation: Application definition", "snpContent": "An application centralizes the following:\r\n- Var(s)\r\n- View(s)    the equivalent of an Event\r\n- Action(s)\r\n    Name\r\n    Parameters\r\n    EnabledView\r\n    function\r\n- Pure Functions - for querying information\r\n\r\n\r\n\r\nEvery module or plug in:\r\n    consumes any of the above\r\n    and also registers its own set of them\r\n\r\n\r\n", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 179}, {"snpId": {"SnippetId" :"2d1ef999-641f-4479-81d5-e746ee2c1c4b"}, "snpName": "Documentation: Layout Engine", "snpContent": "Using Templates for actual implementation\r\n    - And the WcSplitter component to be able to get variables\r\n\r\na series of Layout definitions like this:\r\n\r\nLayouts: \r\n\r\n    lyt1  vertical   0-35-100 doc1 doc2 \r\n    lyt2  horizontal   45     doc1 doc2\r\n    grid1 grid   \"\" \"\" doc1 doc2 | button AddSnippet \"Add Snippet\" \"\" |\r\n\r\ntesta horizontal 0-40-90 AppFramework.AppFwkClient testb \r\ntestb vertical 0-18-70 a c\r\n\r\ntesta horizontal 0-8-70 AppFramework.AppFwkClient testb \r\ntestb vertical 0-8-70 FSharpStation.editor FSharpStation.Snippets\r\n\r\ntesta horizontal 0-8-70 AppFramework.AppFwkClient testb\r\ntestb vertical -170 FSharpStation.editor FSharpStation.Snippets\r\n\r\n\r\neditorButtons vertical -200 snippetsSnippet buttons\r\nbuttons div \"\" \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none btnRunFS\r\nsnippetsSnippet vertical 0-20-100 FSharpStation.Snippets snippet\r\nsnippet div \"\" \"\" FSharpStation.editor\r\n\r\nbtnAddSnippet    button FSharpStation.AddSnippet    \"\" \"\" \"Add Snippet   \"\r\nbtnDeleteSnippet button FSharpStation.DeleteSnippet \"\" \"\" \"Delete Snippet\"\r\nbtnIndentIn      button FSharpStation.IndentIn      \"\" \"\" \"Indent In  >> \"\r\nbtnIndentOut     button FSharpStation.IndentOut     \"\" \"\" \"Indent Out << \"\r\nbtnRunFS         button FSharpStation.RunFS         \"\" \"\" \"Run F#        \"\r\n\r\nnone    span \"\" \"\"\r\n\r\nsnippet horizontal 45 ", "snpParentIdO": {"SnippetId" :"cc5cc3ef-0050-49ce-a967-e07b80f3f6fc"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 179}, {"snpId": {"SnippetId" :"53cfa407-6a27-4ae7-abf7-1ea6b3c65a69"}, "snpName": "run TestingJS (manually refresh js sources)", "snpContent": "#define FIX_GENERIC\nmodule RunTestingJs =\n    \n    open System.IO\n    open RunProcess\n    open WsTranslate\n    open FsCode\n    \n    [< Inline \"throw 'runTest is not intended for JavaScript client'\" >]\n    let runTest name = \n        asyncResult {\n            let! url             = FSharpStationClient.getUrl()\n            let! code            = FSharpStationClient.getCode <| \"FsRoot/Testing/TestingJS/\" + name\n            let  args            = [ intShowArgs   /= false\n                                     fscGenFSharp2 /= \"noframework\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n                                   ]\n            let! tx, js          = FsCode code |> translateJs (CommArgCollection args)\n            File.WriteAllText(@\"..\\website\\testing.js\", js)\n            do   startProcess (url + \"/testing.html\")     \"\" |> ignore\n        } |> Async.RunSynchronously |> printfn \"%A\"\n        \n    if not IsClient then\n        runTest \"REGEX\"", "snpParentIdO": {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"64c13907-9cf6-4abf-adad-a43a33b21c42"}], "snpProperties": [], "snpGeneration": 113}, {"snpId": {"SnippetId" :"853910d0-fcf7-4517-9f1e-8dd721386d03"}, "snpName": "TestingMixed", "snpContent": "//#define NOFRAMEWORK --noframework\n#define WEBSHARPER\nmodule TestingMixed =", "snpParentIdO": {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c137c179-c203-49d5-908a-88fe4481ea08"}, "snpName": "monacoFsAutoComplete", "snpContent": "module Markdown =\n    open System.Text.RegularExpressions\n\n    let private stringReplacePatterns =\n        [ \"&lt;\", \"<\"\n          \"&gt;\", \">\"\n          \"&quot;\", \"\\\"\"\n          \"&apos;\", \"'\"\n          \"&amp;\", \"&\"\n          \"<summary>\", \"**Description**\\n\\n\"\n          \"</summary>\", \"\\n\"\n          \"<para>\", \"\\n\"\n          \"</para>\", \"\\n\"\n          \"<remarks>\", \"\"\n          \"</remarks>\", \"\\n\" ]\n\n    let private regexReplacePatterns =\n        let r pat = Regex(pat, RegexOptions.Compiled ||| RegexOptions.IgnoreCase)\n        let code (strings : string array) =\n            let str = strings.[0]\n            if str.Contains(\"\\n\") then\n                \"```forceNoHighlight\" + str + \"```\"\n            else\n                \"`\" + str + \"`\"\n        let returns = Array.item 0 >> sprintf \"\\n**Returns**\\n\\n%s\"\n        let param (s: string[]) = sprintf \"* `%s`: %s\"(s.[0].Substring(1, s.[0].Length - 2)) s.[1]\n        [ r\"<c>((?:(?!<c>)(?!<\\/c>)[\\s\\S])*)<\\/c>\", code\n          r\"\"\"<see\\s+cref=(?:'[^']*'|\"[^\"]*\")>((?:(?!<\\/see>)[\\s\\S])*)<\\/see>\"\"\", code\n          r\"\"\"<param\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/param>)[\\s\\S])*)<\\/param>\"\"\", param\n          r\"\"\"<typeparam\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/typeparam>)[\\s\\S])*)<\\/typeparam>\"\"\", param\n          r\"\"\"<exception\\s+cref=('[^']*'|\"[^\"]*\")>((?:(?!<\\/exception>)[\\s\\S])*)<\\/exception>\"\"\", param\n          r\"\"\"<a\\s+href=('[^']*'|\"[^\"]*\")>((?:(?!<\\/a>)[\\s\\S])*)<\\/a>\"\"\", fun s -> (s.[0].Substring(1, s.[0].Length - 2))\n\n          r\"<returns>((?:(?!<\\/returns>)[\\s\\S])*)<\\/returns>\", returns //\"\n        ]\n\n    /// Helpers to create a new section in the markdown comment\n    let private suffixXmlKey (tag : string) (value : string) (str : string) =\n        match str.IndexOf(tag) with\n        | x when x <> -1 -> let insertAt = if str.Chars(x - 1) = ' ' \n                                           then x - 1\n                                           else x\n                            str.[0..insertAt] + value + str.[insertAt + 1..]\n        | _              -> str\n\n    let private suffixTypeparam = suffixXmlKey \"<typeparam\" \"\\n**Type parameters**\\n\\n\"\n    let private suffixException = suffixXmlKey \"<exception\" \"\\n**Exceptions**\\n\\n\"\n    let private suffixParam = suffixXmlKey \"<param\" \"\\n**Parameters**\\n\\n\"\n\n    /// Replaces XML tags with Markdown equivalents.\n    /// List of standard tags: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/xml-documentation\n    let private replaceXml (str: string) : string =\n        let str =\n            str\n            |> suffixTypeparam\n            |> suffixException\n            |> suffixParam\n\n        let res =\n            regexReplacePatterns\n            |> List.fold (fun res (regex: Regex, formatter: string[] -> string) ->\n                // repeat replacing with same pattern to handle nested tags, like `<c>..<c>..</c>..</c>`\n                let rec loop res : string =\n                    match regex.Match res with\n                    | m when m.Success ->\n                        let [| firstGroup |], otherGroups =\n                            m.Groups\n                            |> Seq.cast<Group>\n                            |> Seq.map (fun g -> g.Value)\n                            |> Seq.toArray\n                            |> Array.splitAt 1\n                        loop <| res.Replace(firstGroup, formatter otherGroups)\n                    | _ -> res\n                loop res\n            ) str\n\n        stringReplacePatterns\n        |> List.fold (fun (res: string) (oldValue, newValue) ->\n            res.Replace(oldValue, newValue)\n        ) res\n\n    [< Rpc >]\n    let createCommentBlock (comment: string) = async {\n        return\n            comment\n            |> replaceXml\n    }\n\n[< JavaScript >]\nmodule Monaco =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n    open Monaco\n    open FsAutoComplete\n    \n    let fileName = \"test.fsx\"\n    \n    let fixMarkDown v =\n        v\n        |> String.splitByChar '\\n'\n        |> Seq.map (fun l -> l.Replace(\"\\t\", \"- \"))\n        |> Seq.map (fun l -> let i = l |> Seq.takeWhile ((=) ' ') |> Seq.length\n                             String.replicate i \"&nbsp;\" + l.[i..] )\n        |> String.concat \"\\n\\n\"\n        \n    let overDescriptions descs =\n                          descs \n                          |> Seq.collect id \n                          |> Seq.collect (fun (d:CommTypes.OverloadDescription) ->\n                              [ if d.Signature |> isUndefined |> not then yield \"```\\n\" + d.Signature + \"\\n```\" |> Async.rtn\n                                if d.Comment   |> isUndefined |> not then yield Markdown.createCommentBlock d.Comment |> Async.map fixMarkDown\n                                if d.Footer    |> isUndefined |> not then yield d.Footer |> fixMarkDown |> Async.rtn] )\n                          |> Async.sequenceSeq\n    \n    type HoverProvider(ed:Editor) =\n        do()\n       with\n          member __.provideHover(model:Model, pos:Position, token:obj) =\n            asyncResult {\n              let! descs, other = toolTip fileName pos.lineNumber pos.column \"\"\n              let! desc = overDescriptions descs \n              return\n                  {\n                      contents = desc |> Seq.map (fun d -> { value = d |>! print ; isTrusted = true }) |> Seq.toArray\n                      range    = (box null |> unbox)\n                  }\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n\n    let convertGlyphChar =\n        function\n        | \"C\" -> CompletionItemKind.Class\n        | \"E\" -> CompletionItemKind.Enum\n        | \"S\" -> CompletionItemKind.Value\n        | \"I\" -> CompletionItemKind.Interface\n        | \"N\" -> CompletionItemKind.Module\n        | \"M\" -> CompletionItemKind.Method\n        | \"P\" -> CompletionItemKind.Property\n        | \"F\" -> CompletionItemKind.Field\n        | \"T\" -> CompletionItemKind.Class\n        | \"K\" -> CompletionItemKind.Keyword\n        | _   -> 0 |> unbox\n\n    type CompletionItemProvider(ed:Editor) =\n        do()\n       with\n          member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj) =\n            asyncResult {\n              let txt = model.GetLineContent(pos.lineNumber)\n              let! comps, other = completion txt true fileName pos.lineNumber pos.column \"Contains\"\n              return comps \n                     |> Array.map(fun (comp:CommTypes.CompletionResponse) -> \n                         { kind   = convertGlyphChar comp.GlyphChar\n                           label  = comp.Name\n                           detail = \"\"\n                         } )\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n          member __.resolveCompletionItem(item: CompletionItem, token: obj) =\n            asyncResult {\n              let! comp, other = helpText item.label\n              let  desc =  (comp:CommTypes.HelpTextResponse).Overloads \n                           |> Seq.collect id\n                           |> Seq.collect (fun d -> \n                                 [ if d.Signature |> isUndefined |> not then yield d.Signature\n                                   if d.Comment   |> isUndefined |> not then yield d.Comment\n                                   if d.Footer    |> isUndefined |> not then yield d.Footer ]\n                           )\n                           |> String.concat \"\\n\" \n              return  { item with detail = desc}\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n    type DefinitionProvider(ed:Editor) =\n        do()\n       with\n          member __.provideDefinition(model: Model, pos: Position, token: obj): Promise<Location> =\n            asyncResult {\n              let! decl, others = findDeclaration fileName pos.lineNumber pos.column \"\"\n              let  decl : CommTypes.Location = decl\n              return \n                  { range = { startColumn     = decl.Column\n                              endColumn       = decl.Column\n                              startLineNumber = decl.Line\n                              endLineNumber   = decl.Line\n                            }\n                    uri   = model.uri\n                  }\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n\n    let annotationsV = Var.Create \"Err (1, 7) - (1, 12): \\\"This shows over there as an error\\\".\\nWarn (2, 7) - (2, 12): \\\"This shows over there as a warning\\\".\\nInfo (3, 7) - (3, 12): \\\"This shows over there as information\\\".\\nHint (4, 7) - (4, 12): \\\"This shows over there as a hint\\\".\"\n    let transformAnnotations msgs =\n        let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n        match msgs with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex \"\" [| _ ; ty ; fl;     fc;     tl;     tc; msg |] \n                     -> Some (ty, int fl, int fc, int tl, int tc, msg)\n            | _      -> None\n        )\n        |> Array.map (fun (ty, fl, fc, tl, tc, msg) ->\n                { message  = msg\n                  severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                  startColumn     = fc\n                  endColumn       = tc\n                  startLineNumber = fl\n                  endLineNumber   = tl\n                }\n          )        \n            \n        \n    let monacoNew        (var           : Var<string>                         ) \n                         (annotationsWO : View<MarkerData []>           option) \n                         (showToolTipO  :(string -> int -> int -> unit) option) \n                         (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                       -> string -> int -> int -> unit) option) =\n    \n        let setDirtyCond() = ()\n        let getHints    _  = ()\n                            \n        Monaco.newVar var\n        |> onRender(fun ed -> \n            Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n            Editor.SetTheme(\"vs\")\n            let hp = new HoverProvider         (ed)\n            let cp = new CompletionItemProvider(ed)\n            let dp = new DefinitionProvider    (ed)\n            hp.provideHover |> print\n            cp.provideCompletionItems |> print\n            cp.resolveCompletionItem  |> print\n            dp.provideDefinition      |> print\n            Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n            Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n            Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n            annotationsWO\n            |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) )\n        )\n\n    let parse c = \n      asyncResult {\n        let! errs, others = parseCode fileName (String.splitByChar '\\n' c) true 0\n        (errs:CommTypes.ErrorResponse).Errors\n        |> Seq.map (fun v -> \n           sprintf \"%s (%d, %d) - (%d, %d): \\\"%s:%s\\\".\"\n            <| match v.Severity with \"Error\" -> \"Err\" |_-> \"Warn\"\n            <|  v.StartLine\n            <|  v.StartColumn\n            <|  v.EndLine\n            <|  v.EndColumn\n            <|  v.Subcategory\n            <|  v.Message\n        )\n        |> String.concat \"\\n\"\n        |> annotationsV.Set\n        others |> Seq.iter print \n        ()\n      } |> AsyncResult.iterA print print\n\n    //[< SPAEntryPoint >]\n    let main() =\n        let var = Var.Create \"Hello there.\\nHello there.\\nHello there.\\nHello there.\\n\"\n        View.Sink ( parse) var.View\n        let monaco       = monacoNew    <| var\n                                        <| Some (V(if var.V = \"\" then [||] else transformAnnotations annotationsV.V))\n                                        <| None\n                                        <| None\n        div [] [\n            div [ attr.style \"height: 400px; width: 800px\" ] [ monaco |> Monaco.render ]\n            div [] [ text \"These are the annotations that create tooltips, warnings and errors:\" ]\n            Doc.InputAreaV [ attr.style \"height: 100px; width: 600px\" ] annotationsV.V\n            div [] [ text var.V           ]\n        ]\n        //|> Doc.Run JS.Document.Body\n\n\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n\nmodule Server =\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n    open WebSharper.UI.Server\n    open WebSharper.UI.Html\n    \n    type EndPointServer = \n        | Hello\n        | About\n    \n    let url = \"http://localhost:9095/\"\n    let rootdir = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\RuleEditorNew\\website\"\n    let site()  = WebSharper.Application.MultiPage(fun context (s:EndPointServer) -> \n                    printfn \"Serving page: %A\" s\n                    Content.Page(\n                        Title= ( sprintf \"Monaco test %A\" s)\n                      , Body = [ Html.client <@  Monaco.main() @> ]) \n                  )                      \n    let Main args =\n        use server = WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                               , Sitelet             = (Some <| site())\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n            |> ignore)\n        stdout.WriteLine(\"Starting, hit enter to finish\")\n        stdin.ReadLine() |> ignore\n        0\n    Main()\n", "snpParentIdO": {"SnippetId" :"853910d0-fcf7-4517-9f1e-8dd721386d03"}, "snpPredIds": [{"SnippetId" :"534f7a8c-81d0-4dea-ac82-ac109abfdd84"}, {"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"f0e7bfb2-3e35-4979-b803-20a280dc2086"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"811fd0bf-930b-4483-bf5e-8c5ce38ba757"}, "snpName": "compile monaco FsAutoComplete", "snpContent": "#r @\"Compiled\\FSCompilerDll\\FSCompilerDll.dll\"\nmodule RunTestingJs =\n    open FSSGlobal\n    \n    open System.IO\n    open WSMessagingBroker\n    open Useful\n    open UsefulDotNet\n    open UsefulDotNet.CompOptionsModule\n    open RunProcess\n    open WsCompiler\n    open FsCode\n    open CommArgCollection\n    \n    [< Inline \"throw 'runTest is not intended for JavaScript client'\" >]\n    let wsCompileSnippet snpName = \n        asyncResult {\n            let  fsClient        = FStationMessaging(\"Compile WebSharper\", \"##FSHARPSTATION_ID##\")\n            let! codeR           = fsClient.RequestCode snpName |> Wrap.toAsyncResult\n            let! code            = codeR |> Result.toResult fst (sprintf \"%A\" >> ErrorMsg)\n            let  defines0        = (FsCode.extractDefines <| FsCode code).Split([| \" \" ; \"-d:\" |], System.StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros true (String.splitByChar '\\n' code) |> separateDirectives\n            let  defines         = Array.append defines0 defines1\n            let  args            = [ intShowArgs   /= true\n                                     fscGenFSharp2 /= \"noframework\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n                                     fscReference  /= @\"C:\\Users\\Abelardo\\.nuget\\packages\\fsharp.core\\4.5.2\\lib\\net45\\FSharp.Core.dll\"\n                                   ]\n            let  args1           = compileOptionsExeDebug snpName \n                                 + siteOptions()\n                                 + args\n            let  args2           = prepOptions args1 (assembs, defines, prepIs)\n            return! reader {\n                let! workDir  = getStringRm intDirectory\n                do              Directory.CreateDirectory(workDir) |> ignore\n                do!             processArgs fs assembs nowarns\n                let! res      = compileRm()\n                do              print res\n                let! exeFile0 = getStringRm fscOutput\n                let! site0    = getStringRm wscWebSite\n                let  site     = System.IO.Path.GetFullPath site0\n                let  exeFile  = System.IO.Path.GetFullPath exeFile0\n                do   printfn    \"Starting %s\"     exeFile\n                let  url      = @\"http://localhost:9095/Hello\"\n                let  parms    = sprintf \"%A %A\" site url \n                do              startProcessDir   exeFile parms workDir |> ignore\n                do              startProcess      url     \"\"            |> ignore\n            } |> ReaderM.run args2\n        } |> Async.RunSynchronously |> printfn \"%A\"\n    wsCompileSnippet \"FsRoot/Testing/TestingMixed/monacoFsAutoComplete\"\n\n", "snpParentIdO": {"SnippetId" :"853910d0-fcf7-4517-9f1e-8dd721386d03"}, "snpPredIds": [{"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"60645418-08f5-45ce-a7a0-accafba4b65f"}, "snpName": "Actions", "snpContent": "", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 204}, {"snpId": {"SnippetId" :"b5511361-3f03-4f3a-bd64-002d53a75529"}, "snpName": "compile LayoutEngine.Dll", "snpContent": "#define TEST12341\r\n#cd @\"..\\projects\\LayoutEngine\\src\"\r\n#define FIX_GENERIC\r\nmodule RunTestingJs =\r\n    module ReaderM = ReaderMAsyncResultM\r\n    open ReaderM.Operators\r\n    \r\n    open System\r\n    open System.IO\r\n    open FsCode\r\n    open CommArgCollection\r\n    \r\n    [< Inline \"throw 'runTest is not intended for JavaScript client'\" >]\r\n    let runTest name = \r\n        asyncResultM {\r\n            let  snpName         = \"FsRoot/Libraries/\" + name\r\n            let! (codeFs:string) = FSharpStationClient.getCode snpName\r\n            let  args   = [ intShowArgs    /= true\r\n                            wscProjectType /= \"library\"\r\n                            fscGenFSharp2  /= \"noframework\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\r\n                            fscReference   /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n                          ]\r\n            let  code           = codeFs.Split '\\n'\r\n            let  defines0       = (FsCode.extractDefines <| FsCode codeFs).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \r\n            let  fs, assembs, defines1, prepIs, nowarns, _ = separatePrepros code |> separateDirectives\r\n            let  defines        = Array.append defines0 defines1\r\n            let  args1          = compileOptionsDll snpName\r\n                                + wscProjectPath /= (getStringRm intFileName |> ReaderMResult.map (fun f -> Path.GetDirectoryName f +/+ @\"wsconfig.json\"))\r\n                                + args\r\n            let  args2          = prepOptions args1 (assembs, defines, prepIs)\r\n            return! reader {\r\n                do!  processArgs fs assembs nowarns\r\n                let! res        = WsCompiler.compileRm()\r\n                return res\r\n            } |> ReaderM.run args2        \r\n        } |> AsyncResultM.iterS (ResultMessage.summarized >> printfn \"%s\") (printfn \"%A\")\r\n        \r\n    if not IsClient then\r\n        runTest \"LibraryJS/LayoutEngine\"", "snpParentIdO": {"SnippetId" :"60645418-08f5-45ce-a7a0-accafba4b65f"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}], "snpProperties": [], "snpGeneration": 218}, {"snpId": {"SnippetId" :"bcae90bc-64ae-4c5d-a4a4-d2b293407b03"}, "snpName": "Applications", "snpContent": "", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [["IndentChildren", "0 |-| 4"]], "snpGeneration": 47}, {"snpId": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpName": "FSharpStation", "snpContent": "#cd @\"..\\projects\\FSharpStation\\src\"\n#define WEBSHARPER\n[< JavaScript >]\nmodule FSharpStation =", "snpParentIdO": {"SnippetId" :"bcae90bc-64ae-4c5d-a4a4-d2b293407b03"}, "snpPredIds": [{"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [["Indent", "4"]], "snpGeneration": 183}, {"snpId": {"SnippetId" :"8a23262e-cdaf-47e3-a4ac-36a86f112175"}, "snpName": "FStation", "snpContent": "#nowarn \"1178\" \"1182\" \"3180\" \"52\"\nmodule FStation =\n\n    let [< Rpc >] getRootDir() = async {\n        //let res = let dir = System.Environment.CurrentDirectory\n                  //if dir.EndsWith @\"\\bin\" |> not then dir else\n                  //dir.[0..dir.Length - 5] |>! fun set -> System.Environment.CurrentDirectory <- set\n        return System.Environment.CurrentDirectory //res\n    }\n\n    [< Inline \"(Date.now())\" >]\n    let now() = 0\n    let id = \"FSharpStation\" + (now() |> string)\n\n    let mutable rootDir  = \".\"\n    let mutable srcDir   = \".\"\n    async {\n        let! dir = getRootDir()\n        rootDir   <- dir +/+ \"..\"\n        srcDir    <- dir +/+ \"..\\\\src\"\n        printfn \"fileName = %s\\\\%s.fsx\" srcDir id\n    } |> Async.Start\n    \n    let annotationsV = Var.Create \"\"\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"287b94ba-e7c6-48f0-95f5-9de3685c4036"}], "snpProperties": [], "snpGeneration": 214}, {"snpId": {"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}, "snpName": "Snippets", "snpContent": "module Snippets =\n    open TreeReader\n    module ReaderM = ReaderMResult\n    open ReaderM.Operators\n    \n    let private snippets               = ListModel<SnippetId, Snippet> (fun s -> s.snpId)\n    let private hierarchy              = Var.Create [||]\n    let private generation             = Var.Create 5\n    let private currentSnippetIdOV     = Var.Create (None:SnippetId option)\n    let private codeSnippetIdOV        = Var.Create (None:SnippetId option)\n    let private collapsedV             = Var.Create Set.empty\n    \n    let predsCache , clearPreds        = Memoize.checkStore()\n    let reducCache , clearReduc        = Memoize.checkStore()\n    let parentCache, clearParent       = Memoize.checkStore()\n    let clearPredsCache ()             = clearPreds ()\n                                         clearReduc ()\n                                         clearParent()\n    let prepCode                   snp = snp.snpContent\n                                            .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , FStation.id            )\n                                            .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href)\n    let snippetsColl                () = { generation       = generation.Value\n                                           ordered          = snippets.Value\n                                           fetcher          = snippets.TryFindByKey\n                                           predecesorsCache = fun _ -> predsCache\n                                           reducedCache     = fun _ -> reducCache\n                                           prepCode         = prepCode\n                                           }\n    let handleError                 er = (er:ResultMessage<string>) |> string |> exn |> raise\n    let iterReader                  rm = rm |> ReaderM.iter  handleError id (snippetsColl())\n    let runReaderResult             rm = rm |> ReaderM.run                  (snippetsColl()) \n    let runReader            handle rm = rm |> runReaderResult |> Result.defaultWith handle \n       \n    let setCurrentSnippetIdO snpIdO    = currentSnippetIdOV.Set snpIdO\n    let setSnippet                 snp = if snp.snpId.Id <> System.Guid.Empty then snippets.Add { snp with snpGeneration = generation.Value + 1 }\n    let getSnippetsGen              () = snippets.Value, generation.Value, collapsedV.Value\n\n    let getParentIdONotMemo      snpId = snippets.TryFindByKey snpId |> Option.bind(fun s -> s.snpParentIdO)\n    let getParentIdO                   = getParentIdONotMemo |> Memoize.memoizeStore (fun () -> parentCache) \n    let rec isDescendantOf ancId snpId = if snpId = ancId  then false else\n                                         getParentIdO snpId\n                                         |> Option.map (fun prnId -> prnId = ancId || isDescendantOf ancId prnId)\n                                         |> Option.defaultValue false\n\n    if IsClient then\n        currentSnippetIdOV.View |> View.Sink (\n            function\n            | None       -> ()\n            | Some curId ->\n            match codeSnippetIdOV.Value with\n            | None       -> codeSnippetIdOV.Set (Some curId)\n            | Some codId ->\n            codId\n            |>  Snippet.snippetORm\n            |>> Option.map Snippet.uniquePredsRm \n            >>= ReaderM.insertO\n            |>> Option.toList\n            |>> List.collect  id\n            |>> List.contains curId\n            |>> function false -> codeSnippetIdOV.Set (Some curId) |_->()\n            |>  iterReader\n            clearPredsCache()\n        )\n\n    if IsClient then\n        hierarchy.View |> View.Map (Array.map (fun n -> n.id()) ) |> View.consistent |> View.Sink (fun ids ->\n            clearPredsCache()\n            [| for sid in ids do\n                yield  snippets.FindByKey sid\n                yield! snippets.Value |> Seq.filter(fun snp -> isDescendantOf sid snp.snpId)\n            |]\n            |> snippets.Set\n        )\n\n    let CurrentSnippetIdW              = currentSnippetIdOV.View |> View.Map (fun sidO -> sidO |> Option.defaultValue Snippet.defaultSnippet.snpId)\n    let currentSnippetW                = currentSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n    let    codeSnippetW                =    codeSnippetIdOV.View  |> View.Bind (Option.map snippets.TryFindByKeyAsView >> View.insertWO) |> View.Map (Option.bind id >> Option.defaultValue Snippet.defaultSnippet)\n    let currentSnippetV                = Var.Make currentSnippetW setSnippet\n    let selectedClassW           snpId = V (if Some snpId = currentSnippetIdOV.V then \"selected\"    else \"\")\n    let codeSnippetClassW        snpId = V (if Some snpId =    codeSnippetIdOV.V then \"codeSnippet\" else \"\")\n    let findSnippetW             snpId = snippets.TryFindByKeyAsView snpId |> View.Map (Option.defaultValue Snippet.defaultSnippet)\n    let findSnippetV             snpId = Var.Make (findSnippetW snpId) setSnippet\n    let getHierarchyW                  = hierarchy.View \n                                         |> View.Map2(fun _ -> TreeReader.listNodes 0 >> runReader  handleError) collapsedV.View\n                                         |> View.Map (Seq.map (fun (tn,l) -> tn.id(), l) ) \n                                         |> View.Map  Seq.toArray\n    //let codeAndStartsRm            snp =  >>= Snippet.codeAndStartsRm \n    let codeAndStartsW                 = (codeSnippetW, snippets.View) \n                                         ||> View.MapAsync2 (fun _ _ -> async {\n                                            do! Async.Sleep 350\n                                            return\n                                               Snippet.fastCodeRm currentSnippetIdOV.Value codeSnippetIdOV.Value\n                                               |> runReader handleError\n                                         }) \n    let FsCodeW                        = codeAndStartsW |> View.Map fst\n    let codeStartsW                    = codeAndStartsW |> View.Map snd\n    let hasChangedW                snp = V (generation.V < snp.snpGeneration )\n    let SaveAsClassW                   = View.Map2 (fun snps gen -> if Seq.exists (fun snp -> snp.snpGeneration > gen) snps then \"btn-primary\" else \"\") \n                                            snippets  .View \n                                            generation.View\n                                            \n    let setChildrenRm snpId ch = reader {\n        let chIds = ch |> Array.map (fun s -> s.id())\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO <> Some snpId && (chIds |> Array.contains s.snpId))\n        |> Seq.map    (fun s -> { s with snpParentIdO = Some snpId })\n        |> Seq.iter    setSnippet\n        snippets\n        |> Seq.filter (fun s -> s.snpParentIdO = Some snpId && (chIds |> Array.contains s.snpId |> not))\n        |> Seq.map    (fun s -> { s with snpParentIdO = None })\n        |> Seq.iter    setSnippet\n        clearPredsCache()\n        let descendants, others = snippets.Value |> Seq.toArray |> Array.partition (fun s -> s.snpId |> isDescendantOf snpId)\n        let index = others |> Array.findIndex (fun s -> s.snpId = snpId)\n        [| yield! others.[0..index]\n           for chid in chIds do\n               yield  descendants |> Seq.find   (fun s -> s.snpId =                 chid)\n               yield! descendants |> Seq.filter (fun s -> s.snpId |> isDescendantOf chid)\n           yield! others.[index+1..]\n        |]\n        |> snippets.Set\n    }\n\n    let rec treenode (snpId:SnippetId) =\n        {\n            id                 = fun () -> snpId\n            isExpandedRm       = fun () -> rtn (not <| Set.contains snpId collapsedV.Value)\n            canHaveChildrenRm  = fun () -> rtn true\n            childrenRm         = fun () -> Snippet.childrenRm snpId |>> Seq.map (fun snp -> treenode snp.snpId)\n            newChildrenRm      = fun ch -> setChildrenRm snpId ch   |>> fun () -> \n                                           treenode      snpId\n            parentORm          = fun _ns-> Snippet.snippetORm snpId |>> Option.bind (fun x -> x.snpParentIdO) |>> Option.map treenode\n            pathRm             = fun () -> Snippet.pathRm snpId\n        }\n        \n    let isIndirectPredecessorW snpId = \n        currentSnippetW \n        |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                |>> Seq.contains snpId\n                                |>  runReader (fun _ -> false))\n    \n    let isIncludedPredecessorW snpId = \n        codeSnippetW \n        |> View.Map (fun snp -> Snippet.uniquePredsRm snp\n                                |>> Seq.contains snpId\n                                |>  runReader (fun _ -> false))\n    \n    let togglePredecessor predId =\n        let preds = Lens currentSnippetV.V.snpPredIds\n        preds.Value\n        |> (if Set.contains predId preds.Value then Set.remove else Set.add) predId\n        |> preds.Set\n        clearPredsCache()\n        \n    let expandClassRm snpId =\n        Snippet.childrenRm snpId        >>= fun chs -> \n        if Seq.isEmpty chs then rtn \"\" else\n        (treenode snpId).isExpandedRm() |>> fun exp -> \n        if exp then \"expanded\" else \"collapsed\"\n    \n    let expandClassW snpId = snippets.View |> View.Map2 (fun _ _ -> expandClassRm snpId |> runReader handleError) collapsedV.View\n    \n    let deleteCurrentSnippet _ =\n        currentSnippetIdOV.Value\n        |> Option.iter (fun snpId ->\n            hierarchy.Value\n            |>  TreeReader.removeNodeOutdentChildren (treenode snpId)\n            |>> Seq.toArray\n            |>> hierarchy.Set\n            |>> fun () -> snippets.RemoveByKey snpId\n            |>  iterReader\n        )\n        \n    let indentIn _ =\n        currentSnippetIdOV.Value\n        |> Option.iter(fun snpId ->\n            hierarchy.Value\n            |>  TreeReader.indentNode (treenode snpId)\n            |>> Seq.toArray\n            |>> hierarchy.Set\n            |>  iterReader\n        )\n           \n    let indentOut _ =\n        currentSnippetIdOV.Value\n        |> Option.iter(fun snpId ->\n            hierarchy.Value\n            |>  TreeReader.outdentNode (treenode snpId)\n            |>> Seq.toArray\n            |>> hierarchy.Set\n            |>  iterReader\n        )\n           \n    let moveNode fnid tnid =\n        hierarchy.Value\n        |>  TreeReader.moveToSibling2 false fnid tnid\n        |>> Seq.toArray\n        |>> hierarchy.Set\n        |>  iterReader\n\n    let updateGeneration() =\n        reader {\n            let! max = Snippet.maxGenerationRm()\n            generation.Set max\n        } |> iterReader\n\n    let setSnippetsGen snps coll =\n        collapsedV.Set coll\n        snippets  .Set snps\n        updateGeneration()\n        snps \n        |>  Seq.map(fun snp -> Snippet.parentORm snp |>> function None -> Some snp |_-> None )\n        |>  ReaderM.sequenceSeq\n        |>> Seq.choose id\n        |>> Seq.map (fun snp -> treenode snp.snpId)\n        |>> Seq.toArray\n        |>> hierarchy.Set\n        |>  iterReader\n\n    let addSnippetRm snp = \n        snippets.Add snp\n        let hier = hierarchy.Value |> Seq.append [| treenode snp.snpId |]\n        currentSnippetIdOV.Value\n        |>  Option.map Snippet.snippetORm |> ReaderM.insertO |>> Option.bind id\n        >>= function\n        | None     -> hier |> rtn\n        | Some sbl -> hier |> TreeReader.moveToSibling2 true snp.snpId sbl.snpId\n        |>> Seq.toArray\n        |>> hierarchy.Set\n        \n    let newSnippet _ =\n        let snp = Snippet.New \"\" \"\" None\n        addSnippetRm snp\n        |>> fun () -> currentSnippetIdOV.Set (Some snp.snpId)\n        |>  iterReader\n        \n    let toggleCollapse snpId =\n        if Set.contains snpId collapsedV.Value then Set.remove else Set.add\n        <| snpId\n        <| collapsedV.Value\n        |> collapsedV.Set\n\n    let expandParents snpId =\n        Snippet.pathRm snpId\n        |>> (fun path -> collapsedV.Value - Set path |> collapsedV.Set)\n        |> iterReader\n    ", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"628752e6-932e-41f0-a2fd-73955df4560b"}, {"SnippetId" :"7f466863-bdb1-49fd-b0a5-e8f426c6efff"}, {"SnippetId" :"8704847f-2a0f-4f3f-8182-ee656c8285c5"}, {"SnippetId" :"8a23262e-cdaf-47e3-a4ac-36a86f112175"}], "snpProperties": [], "snpGeneration": 40}, {"snpId": {"SnippetId" :"3941bba8-89a8-4ff0-9a8c-491f341483b4"}, "snpName": "DragDrop", "snpContent": "module DragDrop =\n\n    type DragInfo = \n        | DragNone\n        | DragNode of SnippetId\n    \n    let mutable drag        = DragNone\n    let setDragNone ()      = drag <- DragNone\n    let setDragNode tnid    = drag <- DragNode tnid\n    \n    let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n    \n    let [< Inline >] inline moveItem dropId elems getId item =\n        elems\n        |> Seq.filter (getId >> ((<>) (getId item)) )\n        |> Seq.toArray\n        |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                     [fst ; [| item |] ; snd])\n        |> Seq.collect id\n        |> Seq.toArray\n    \n    let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n    let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n    \n    let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n    ", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4fe4c1bb-5959-4eb9-a297-387e52ec289f"}, "snpName": "Templating", "snpContent": "[< AutoOpen >]\nmodule Templating =\n    open WebSharper.UI.Templating\n    let [< Literal >] rootdir = @\"..\\website\"\n\n    let [< Literal >] TemplatesFileName = rootdir + @\"\\Templates.html\"\n    type TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n    \n    if IsClient then printfn \"%s\" TemplatesFileName\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"287b94ba-e7c6-48f0-95f5-9de3685c4036"}, {"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}], "snpProperties": [], "snpGeneration": 72}, {"snpId": {"SnippetId" :"9c02fa05-0ca5-4da6-a759-1db8c49a080f"}, "snpName": "renderSnippets", "snpContent": "module RenderSnippets =\n    open Snippets\n    \n    let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then e?scrollIntoViewIfNeeded()) \n    \n    let snippets () = \n        Snippets.getHierarchyW\n        |> Doc.BindSeqCached (fun (snpId, l) ->\n            let snpW     = findSnippetW snpId\n            let nameW    = View.Do {\n                                let! snp     = snpW\n                                let! changed = Snippets.hasChangedW snp\n                                let  name    = Snippet.snippetName snp.snpName snp.snpContent\n                                return (if changed then \"*\" else \"\") + name\n                            }\n            //let pathW = V( Snippets.getHierarchyW |> (fun _ -> (Snippets.treenode snpId).path () |> Seq.map (fun n -> string n.Id) |> String.concat \" - \") )\n            let predW    = V(if currentSnippetV.V.snpPredIds |> Set.contains snpId then \"direct-predecessor\"   else\n                             if (isIndirectPredecessorW snpId).V                   then \"indirect-predecessor\" else \n                             if (isIncludedPredecessorW  snpId).V                  then \"included-predecessor\" else \"\" )\n            let errorW   = FStation.annotationsV.View |> View.Map (String.contains <| snpId.Id.ToString() >> function true -> \"ErrorMsg\" |_-> \"\" )\n            TemplateLib.Snippet()\n                .Name(          nameW                                                                                        )\n                .Indent(        string l                                                                                     )\n                .Parent(        expandClassW snpId                                                                           )\n                .Predecessor(   predW                                                                                        )\n                .Selected(    [ (selectedClassW snpId).V ; (codeSnippetClassW snpId).V ] |> String.concat \" \"                )\n                .ErrorMsg(      errorW                                                                                       )\n                .Select(        fun _  -> setCurrentSnippetIdO <| Some snpId                                                 )\n                .AfterRender(   scrollIntoView <| View.Map ((<>) \"\") (Snippets.selectedClassW snpId)                         )\n                .TogglePred(    fun ev -> togglePredecessor snpId                                                            )\n                .ToggleCollapse(fun ev -> Snippets.toggleCollapse snpId                                                      )\n                .Drag(          fun ev ->     DragDrop.setDragNode snpId            ; ev.Event.StopPropagation()             )\n                .DragOver(      fun ev -> if (DragDrop.getDragNIdO snpId).IsSome then ev.Event.PreventDefault ()             )\n                .Drop(          fun ev -> do                                          ev.Event.PreventDefault () \n                                          DragDrop.getDragNIdO snpId |> Option.iter(fun fr -> moveNode fr snpId)             )\n              .Doc()\n        )\n    \n    let render() = TemplateLib.SnippetList().Snippets( snippets() ).Doc()", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}, {"SnippetId" :"3941bba8-89a8-4ff0-9a8c-491f341483b4"}, {"SnippetId" :"4fe4c1bb-5959-4eb9-a297-387e52ec289f"}], "snpProperties": [], "snpGeneration": 119}, {"snpId": {"SnippetId" :"938cc087-2664-4d35-9df2-c0abf106bb63"}, "snpName": "renderProperties", "snpContent": "module RenderProperties =\r\n    open Snippets\r\n    \r\n    let addProperty () = Snippets.currentSnippetV.Set \r\n                            { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties \r\n                                                                                               [| \"\",\"\" |]                                              }\r\n    let remProperty i = Snippets.currentSnippetV.Set \r\n                            { Snippets.currentSnippetV.Value with snpProperties = Array.append Snippets.currentSnippetV.Value.snpProperties.[0  .. i-1] \r\n                                                                                               Snippets.currentSnippetV.Value.snpProperties.[i+1..    ] }\r\n    let properties() =\r\n        let propsV = Lens Snippets.currentSnippetV.V.snpProperties\r\n        let setName  i newName = propsV.Value.[i] <- (newName, snd propsV.Value.[i]) \r\n                                 propsV.Value |> propsV.Set\r\n        let setValue i newVal  = propsV.Value.[i] <- (fst propsV.Value.[i], newVal) \r\n                                 propsV.Value |> propsV.Set\r\n        V([| 0.. propsV.V.Length - 1|])\r\n        |> Doc.BindSeqCached (fun i ->\r\n            let nameV  = Var.Make <| V( fst propsV.V.[i])\r\n                                  <| setName  i\r\n            let valueV = Var.Make <| V( snd propsV.V.[i])\r\n                                  <| setValue i\r\n            TemplateLib.Property()\r\n                .Name(   nameV                   )\r\n                .Value(  valueV                  )\r\n                .Remove( fun ev -> remProperty i )\r\n              .Doc()\r\n        )\r\n\r\n    let render() = \r\n        TemplateLib.PropertyTable()\r\n            .Properties(  properties()           )\r\n            .AddProperty( fun _ -> addProperty() )\r\n            .Doc()    ", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}, {"SnippetId" :"4fe4c1bb-5959-4eb9-a297-387e52ec289f"}], "snpProperties": [], "snpGeneration": 119}, {"snpId": {"SnippetId" :"552ec529-0e20-496d-bb6f-2a98d9b1f313"}, "snpName": "Markdown", "snpContent": "[< JavaScript false >]\nmodule Markdown =\n    open System.Text.RegularExpressions\n\n    let private stringReplacePatterns =\n        [ \"&lt;\"      , \"<\"\n          \"&gt;\"      , \">\"\n          \"&quot;\"    , \"\\\"\"\n          \"&apos;\"    , \"'\"\n          \"&amp;\"     , \"&\"\n          \"<summary>\" , \"**Description**\\n\\n\"\n          \"</summary>\", \"\\n\"\n          \"<para>\"    , \"\\n\"\n          \"</para>\"   , \"\\n\"\n          \"<remarks>\" , \"\"\n          \"</remarks>\", \"\\n\" ]\n    let private regexReplacePatterns =\n        let r               pat = Regex(pat, RegexOptions.Compiled ||| RegexOptions.IgnoreCase)\n        let unquote  (s:string) = s.Substring(1, s.Length - 2)\n        let returns     strings = Array.item 0 strings |>                     sprintf \"\\n**Returns**\\n\\n%s\"\n        let param       strings = Array.item 0 strings |> unquote |> fun s -> sprintf \"* `%s`: %s\" s strings.[1]\n        let link        strings = Array.item 0 strings |> unquote\n        let code        strings = Array.item 0 strings |> fun s -> if String.contains \"\\n\" s then \"```forceNoHighlight\" + s + \"```\" else \"`\" + s + \"`\"\n        [ r \"<c>((?:(?!<c>)(?!<\\/c>)[\\s\\S])*)<\\/c>\"                                              , code\n          r \"\"\"<see\\s+cref=(?:'[^']*'|\"[^\"]*\")>((?:(?!<\\/see>)[\\s\\S])*)<\\/see>\"\"\"                , code\n          r \"\"\"<param\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/param>)[\\s\\S])*)<\\/param>\"\"\"            , param\n          r \"\"\"<typeparam\\s+name=('[^']*'|\"[^\"]*\")>((?:(?!<\\/typeparam>)[\\s\\S])*)<\\/typeparam>\"\"\", param\n          r \"\"\"<exception\\s+cref=('[^']*'|\"[^\"]*\")>((?:(?!<\\/exception>)[\\s\\S])*)<\\/exception>\"\"\", param\n          r \"\"\"<a\\s+href=('[^']*'|\"[^\"]*\")>((?:(?!<\\/a>)[\\s\\S])*)<\\/a>\"\"\"                        , link\n          r \"\"\"<returns>((?:(?!<\\/returns>)[\\s\\S])*)<\\/returns>\"\"\"                               , returns\n        ] // \"\n\n    /// Helpers to create a new section in the markdown comment\n    let private suffixXmlKey (tag : string) (value : string) (str : string) = \n        match str.IndexOf(tag) with\n        | x when x <> -1 -> let insertAt = if str.Chars(x - 1) = ' ' \n                                           then x - 1\n                                           else x\n                            str.[0..insertAt] + value + str.[insertAt + 1..]\n        | _              -> str\n\n    let private suffixTypeparam = suffixXmlKey \"<typeparam\" \"\\n**Type parameters**\\n\\n\"\n    let private suffixException = suffixXmlKey \"<exception\" \"\\n**Exceptions**\\n\\n\"\n    let private suffixParam = suffixXmlKey \"<param\" \"\\n**Parameters**\\n\\n\"\n\n    /// Replaces XML tags with Markdown equivalents.\n    /// List of standard tags: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/xml-documentation\n    let private replaceXml (str: string) : string =\n        let str =\n            str\n            |> suffixTypeparam\n            |> suffixException\n            |> suffixParam\n\n        let res = regexReplacePatterns\n                  |> List.fold (fun res (regex: Regex, formatter: string[] -> string) ->\n                      // repeat replacing with same pattern to handle nested tags, like `<c>..<c>..</c>..</c>`\n                      let rec loop res : string =\n                          match regex.Match res with\n                          | m when m.Success -> m.Groups\n                                                |> Seq.cast<Group>\n                                                |> Seq.map (fun g -> g.Value)\n                                                |> Seq.toArray\n                                                |> Array.splitAt 1\n                                                |> function \n                                                   | [| firstGroup |], otherGroups -> loop <| res.Replace(firstGroup, formatter otherGroups)\n                                                   |                              _-> res\n                          |                                                       _-> res\n                      loop res\n                  ) str\n        stringReplacePatterns\n        |> List.fold (fun (res: string) (oldValue, newValue) ->\n            res.Replace(oldValue, newValue)\n        ) res\n\n    [< Rpc >]\n    let createCommentBlock (comment: string) = async {\n        return\n            comment\n            |> replaceXml\n    }", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9882ea9a-2dc3-4459-8605-9b2dd0c89bdc"}, "snpName": "Monaco", "snpContent": "module Monaco =\n    open WebSharper.UI\n    open WebSharper.UI.Html\n    open FsAutoComplete\n    open Monaco\n    \n    let startsV  = Var.Create [||]\n    \n    let defaultStart = Option.defaultValue((SnippetId.Empty, \"\"), (0, 1, 0))\n    let getIndentAndFirst () =\n        let currId = Snippets.currentSnippetV.Value.snpId\n        let _, (indent, first, _) = startsV.Value |> Seq.tryFind (fst >> fst >> (=) currId) |> defaultStart\n        indent, first\n\n    let getSnipIdIndentAndFirst line =\n        let (snpId, _), (indent, first, _) = startsV.Value |> Seq.tryFind (fun (_, (_, first, last)) -> line >= first && line <= last) |> defaultStart\n        snpId, indent, first\n\n    let getModelUri txt uri =\n        let model = Editor.GetModel uri \n                    |> fun model -> if isUndefined model then None else Some model\n                    |> Option.defaultWith (fun () -> Editor.CreateModel(\"\", \"fsharp\", uri) )\n        if model.GetValue() <> txt then\n            model.SetValue txt\n        model\n\n    let getSnippetModel (sid:SnippetId) =\n        Uri.Parse(\"snpId:\" + sid.Id.ToString())\n        |> getModelUri (Snippet.snippetRm sid |> Snippets.runReader (string >> failwith)).snpContent\n\n    let fixMarkDown v =\n        v\n        |> String.splitByChar '\\n'\n        |> Seq.map (fun l -> l.Replace(\"\\t\", \"- \"))\n        |> Seq.map (fun l -> let i = l |> Seq.takeWhile ((=) ' ') |> Seq.length\n                             String.replicate i \"&nbsp;\" + l.[i..] )\n        |> String.concat \"\\n\\n\"\n        \n    let overDescriptions descs =\n                          descs \n                          |> Seq.collect id \n                          |> Seq.collect (fun (d:CommTypes.OverloadDescription) ->\n                              [ if d.Signature |> isUndefined |> not then yield \"```\\n\" + d.Signature + \"\\n```\" |> Async.rtn\n                                if d.Comment   |> isUndefined |> not then yield Markdown.createCommentBlock d.Comment |> Async.map fixMarkDown\n                                if d.Footer    |> isUndefined |> not then yield d.Footer |> fixMarkDown |> Async.rtn] )\n                          |> Async.sequenceSeq\n    \n    let mutable fileName = \"none.fsx\"\n\n    type HoverProvider(ed:Editor) =\n        do()\n       with\n          member __.provideHover(model:Model, pos:Position, token:obj) =\n            asyncResult {\n              let indent, first = getIndentAndFirst()\n              let! descs, other = toolTip fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n              let! desc = overDescriptions descs \n              return\n                  {\n                      contents = desc |> Seq.map (fun d -> { value = d |>! print ; isTrusted = true }) |> Seq.toArray\n                      range    = (box null |> unbox)\n                  }\n            } |> Promise.ofAsyncResult\n\n    let convertGlyphChar =\n        function\n        | \"C\" -> CompletionItemKind.Class\n        | \"E\" -> CompletionItemKind.Enum\n        | \"S\" -> CompletionItemKind.Value\n        | \"I\" -> CompletionItemKind.Interface\n        | \"N\" -> CompletionItemKind.Module\n        | \"M\" -> CompletionItemKind.Method\n        | \"P\" -> CompletionItemKind.Property\n        | \"F\" -> CompletionItemKind.Field\n        | \"T\" -> CompletionItemKind.Class\n        | \"K\" -> CompletionItemKind.Keyword\n        | _   -> 0 |> unbox\n\n    type CompletionItemProvider(ed:Editor) =\n        do()\n       with\n          member __.provideCompletionItems(model:Model, pos:Position, token:obj, context: obj) =\n            asyncResult {\n              let indent, first = getIndentAndFirst()\n              let txt = String.replicate indent \" \" + model.GetLineContent(pos.lineNumber)\n              let! comps, other = completion txt true fileName (pos.lineNumber + first) (pos.column + indent) \"Contains\"\n              return comps \n                     |> Array.map(fun (comp:CommTypes.CompletionResponse) -> \n                         { kind   = convertGlyphChar comp.GlyphChar\n                           label  = comp.Name\n                           detail = \"\"\n                         } )\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n          member __.resolveCompletionItem(item: CompletionItem, token: obj) =\n            asyncResult {\n              let! comp, other = helpText item.label\n              let  desc =  (comp:CommTypes.HelpTextResponse).Overloads \n                           |> Seq.collect id\n                           |> Seq.collect (fun d -> \n                                 [ if d.Signature |> isUndefined |> not then yield d.Signature\n                                   if d.Comment   |> isUndefined |> not then yield d.Comment\n                                   if d.Footer    |> isUndefined |> not then yield d.Footer ]\n                           )\n                           |> String.concat \"\\n\" \n              return  { item with detail = desc}\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n\n    type DefinitionProvider(ed:Editor) =\n        do()\n       with\n          member __.provideDefinition(model: Model, pos: Position, token: obj): Promise<Location> =\n            asyncResult {\n              let indent, first = getIndentAndFirst()\n              let! decl, others = findDeclaration fileName (pos.lineNumber + first) (pos.column + indent) \"\"\n              let  decl : CommTypes.Location = decl\n              let snpId, indent2, first2 = getSnipIdIndentAndFirst decl.Line\n              let uri           = Monaco.Uri.Parse <| \"snpId:\" + snpId.Id.ToString()\n              getSnippetModel snpId |> ignore\n              return \n                  { range = { startColumn     = decl.Column - indent2\n                              endColumn       = decl.Column - indent2\n                              startLineNumber = decl.Line   - first2\n                              endLineNumber   = decl.Line   - first2\n                            }\n                    uri   = uri\n                  }\n            } |> Async.map (function Ok v -> v | Error m -> failwith <| sprintf \"%A\" m ) |> Promise.OfAsync\n\n    let transformAnnotations snp msgs =\n        let rex  = \"\"\"(Err|Warn|Info|Hint) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*\\(\"\"\" + rexGuid + \"\"\"\\) \"([^\"]+?)\"\\.\"\"\" //\"\n        match msgs with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex \"\" [| _; ty;     fl;     fc;     tl;     tc; guid; msg |] \n                        -> Some (ty, int fl, int fc, int tl, int tc, guid, msg)\n            | _      -> None\n        )\n        |> Array.choose (fun (ty, fl, fc, tl, tc, guid, msg) ->\n            if ParseO.parseGuidO guid |> Option.map SnippetId <> Some snp.snpId then None else\n                Some {  message  = msg\n                        severity = match ty with \"Err\" -> MarkerSeverity.Error | \"Warn\" -> MarkerSeverity.Warning  | \"Hint\" -> MarkerSeverity.Hint |_-> MarkerSeverity.Info\n                        startColumn     = fc\n                        endColumn       = tc\n                        startLineNumber = fl\n                        endLineNumber   = tl\n                }\n          )        \n            \n    type MonacoOptions  = {\n        fontSize   : int\n        lineHeight : int\n    }\n    \n    let addProp prop (pojo:JSObject) = pojo.Add prop ; pojo\n    \n    let newPojo props =\n        let pojo = JSObject()\n        if IsClient then\n            props |> Seq.iter (swap addProp pojo >> ignore)\n        pojo\n\n    let gotoEditor (ed:Editor) codeId line col = async {\n        Snippets.expandParents codeId\n        Snippets.setCurrentSnippetIdO <| Some codeId\n        do! Async.Sleep 200\n        ed.Focus()\n        ed.SetPosition            { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n        ed?revealPositionInCenter { Monaco.Position.lineNumber = line ; Monaco.Position.column = col }\n    }\n\n    let openCodeEditor (input:obj, ed:Editor, sideBySide) =\n        async {\n            match input?resource?path with\n            | ParseO.Guid guid -> \n                 do! gotoEditor ed (SnippetId guid) input?options?selection?startLineNumber input?options?selection?startColumn\n                 return  ed  \n            |_-> return (null |> unbox<Editor>)\n        } |> Promise.OfAsync\n\n    [< Inline \"var m = require('vs/editor/standalone/browser/standaloneServices');\n               var n = new m.StaticServices.codeEditorService._factory();\n               n.openCodeEditor = FsRoot.FSharpStation.Monaco.openCodeEditor;\n               return n;\" >]\n    let getCodeEditorServiceImpl () = X<_>\n        \n    type ITextModelService  = {\n        setEditor                        : Editor -> unit\n        //registerTextModelContentProvider : obj\n        createModelReference             : obj\n    }\n    \n    let textModelResolverService() =\n        let mutable editorO = None\n        {\n            setEditor            = fun e   -> editorO <- Some e\n            createModelReference = fun uri -> \n                async {\n                    let model = getSnippetModel uri\n                    return Monaco.newImmortalReference(model)\n                } |> Promise.OfAsync\n        }\n\n    let monacoNew        (var           : Var<string>                         ) \n                         (annotationsWO : View<MarkerData []>           option) \n                         (showToolTipO  :(string -> int -> int -> unit) option) \n                         (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                       -> string -> int -> int -> unit) option) =\n    \n        let setDirtyCond() = ()\n        let getHints    _  = ()\n        \n        Monaco.newVar var\n        |> fun config -> \n            { config with options   = \n                              newPojo [   \"fontSize\"   => 12\n                                          \"lineHeight\" => 14 \n                                      ] \n                          //overrides = 0 \n                          overrides = \n                              newPojo [ \n                                  \"codeEditorService\"        => getCodeEditorServiceImpl()\n                                  \"textModelResolverService\" => textModelResolverService()\n                                  ]\n            }\n        |> onRender(fun ed -> \n            Editor.SetModelLanguage(ed.GetModel(), \"fsharp\")\n            Editor.SetTheme(\"vs\")\n            //ed.UpdateOptions { fontSize   = 12 ; lineHeight = 14 }        \n            let hp = new HoverProvider         (ed)\n            let cp = new CompletionItemProvider(ed)\n            let dp = new DefinitionProvider    (ed)\n            hp.provideHover |> print\n            cp.provideCompletionItems |> print\n            cp.resolveCompletionItem  |> print\n            dp.provideDefinition      |> print\n            Editor.RegisterHoverProvider         (\"fsharp\", hp ) |> ignore\n            Editor.RegisterCompletionItemProvider(\"fsharp\", cp ) |> ignore\n            Editor.RegisterDefinitionProvider    (\"fsharp\", dp ) |> ignore\n            annotationsWO\n            |> Option.iter( View.Sink (fun ms -> Editor.SetModelMarkers(ed.GetModel(), \"annotations\", ms)) )\n        )\n\n    let parse (code: string, starts: ((SnippetId * string) * (int * int * int)) []) =\n      asyncResult {\n        FStation.annotationsV.Value\n        |> String.skipFirstLine\n        |> (+) \"Parsing...\\n\"\n        |> FStation.annotationsV.Set\n        startsV.Set starts\n        let lines         = String.splitByChar '\\n' code\n        fileName         <- FsCode.getSourceDir FStation.srcDir lines +/+ FStation.id + \".fsx\"\n        let! errs, others = parseCode fileName lines true 0\n        (errs:CommTypes.ErrorResponse).Errors\n        |> Seq.map (fun v ->\n           let (sid, name), (indent, first, _) = starts |> Seq.tryFind(fun (_, (indent, first, last)) -> v.StartLine > first && v.StartLine <= last) |> defaultStart\n           sprintf \"%s (%d, %d) - (%d, %d) %s(%s) \\\"%s: %s\\\".\"\n            <| match v.Severity with \"Error\" -> \"Err\" |_-> \"Warn\"\n            <|  v.StartLine    - first\n            <|  v.StartColumn  - indent\n            <|  v.EndLine      - first\n            <|  v.EndColumn    - indent\n            <|    name\n            <|    sid.Id.ToString()\n            <|  v.Subcategory\n            <|  v.Message\n        )\n        |> Seq.append [ \"Parsed!\" ]\n        |> String.concat \"\\n\"\n        |> FStation.annotationsV.Set\n        others |> Seq.iter print \n        ()\n      } |> AsyncResult.iterA print print\n\n    let mutable editorConfigO : MonacoConfig option = None\n    \n    let getEditorConfigO () =\n        if IsClient \n        then monacoNew <| Lens Snippets.currentSnippetV.V.snpContent\n                       <| Some ( (Snippets.currentSnippetW, FStation.annotationsV.View) ||> View.Map2 transformAnnotations )\n                       <| None\n                       <| None\n             |> Some\n        else None\n        |>! fun edO -> editorConfigO <- edO\n\n    if IsClient then\n        Snippets.CurrentSnippetIdW |> View.Sink(fun sid ->\n            try\n                editorConfigO\n                |> Option.bind(fun config -> config.editorO                         )\n                |> Option.iter(fun editor -> getSnippetModel sid |> editor.SetModel \n                                             FStation.annotationsV.Set FStation.annotationsV.Value\n                )\n            with _ -> ()\n        )\n\n    let goto codeId line col = async {\n        match editorConfigO |> Option.bind (fun cfg -> cfg.editorO) with\n        | Some ed -> do! gotoEditor ed codeId line col\n        | _       -> ()\n    }\n\n        \n\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"09000830-3845-44bf-accf-ae933f2b9b2f"}, {"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}, {"SnippetId" :"287b94ba-e7c6-48f0-95f5-9de3685c4036"}, {"SnippetId" :"534f7a8c-81d0-4dea-ac82-ac109abfdd84"}, {"SnippetId" :"552ec529-0e20-496d-bb6f-2a98d9b1f313"}, {"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"8b5e4cbc-0f4f-43fb-ad55-e2949e15119d"}, {"SnippetId" :"f0e7bfb2-3e35-4979-b803-20a280dc2086"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 218}, {"snpId": {"SnippetId" :"7a6be31e-8838-4ac9-9848-74dfa7028574"}, "snpName": "JumpTo", "snpContent": "module JumpTo =\n\n    let rexGuid = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\).*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n    \n    let jumpToLine = \n        function\n        | REGEX rexGuid \"\" [| _ ; line ; col ; _ ; _ ; guid |] -> Monaco.goto <| SnippetId (System.Guid guid) <| int line <| int col \n                                                                  |> Async.Start\n        | _                                                    -> ()\n        \n    let jumpToRef (e:Dom.Element) =\n        let v : string = e?value |> unbox\n        let s : int    = e?selectionStart |> unbox\n        let lines = v.Split '\\n'\n        lines \n        |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n        |> fst\n        |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n        |> jumpToLine        ", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"812e315c-b4a5-414a-924e-b6a255537086"}, {"SnippetId" :"9882ea9a-2dc3-4459-8605-9b2dd0c89bdc"}], "snpProperties": [], "snpGeneration": 68}, {"snpId": {"SnippetId" :"6ee01ba8-84e7-4280-946c-63dbe3cb9aec"}, "snpName": "Serializer", "snpContent": "module Serializer =\n    open Serializer\n\n    let serSnippetId      = serId (fun (SnippetId      v) -> v) SnippetId      (sprintf \"%A\")     \n\n    let serSnippet   : Ser<Snippet  > = \n        [|\n            serSnippetId                                         |> serField \"snpId\"         (fun s -> s.snpId        ) (fun v s -> { s with snpId         = v } )\n            serString                                            |> serField \"snpName\"       (fun s -> s.snpName      ) (fun v s -> { s with snpName       = v } )\n            serString                                            |> serField \"snpContent\"    (fun s -> s.snpContent   ) (fun v s -> { s with snpContent    = v } )\n            serSnippetId                     |> serOpt           |> serField \"snpParentIdO\"  (fun s -> s.snpParentIdO ) (fun v s -> { s with snpParentIdO  = v } )\n            serSnippetId                     |> serSet           |> serField \"snpPredIds\"    (fun s -> s.snpPredIds   ) (fun v s -> { s with snpPredIds    = v } )\n            serString              |> serDup serString |> serArr |> serField \"snpProperties\" (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n            serInt                                               |> serField \"snpGeneration\" (fun s -> s.snpGeneration) (fun v s -> { s with snpGeneration = v } )\n        |] |> serRecord (Snippet.New \"\" \"\" None)\n    \n    type Model = {\n        snippets   : Snippet []\n        generation : int\n        collapsed  : SnippetId Set\n    }\n\n    let getModel(snippets, gen, coll) =  { snippets = snippets |> Seq.toArray ;  generation = gen ; collapsed = coll}\n\n    let serModel : Ser<Model> =\n        [|\n            serSnippet                       |> serArr           |> serField \"snippets\"   (fun m -> m.snippets  ) (fun v m -> { m with snippets   = v } )\n            serInt                                               |> serField \"generation\" (fun m -> m.generation) (fun v m -> { m with generation = v } )\n            serSnippetId                     |> serSet           |> serField \"collapsed\"  (fun m -> m.collapsed ) (fun v m -> { m with collapsed  = v } )\n        |] |> serRecord { snippets = [||] ; generation = 0 ; collapsed = Set.empty}\n        \n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"252a58ec-9bb6-4617-b763-f084761cfc9d"}, {"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}], "snpProperties": [], "snpGeneration": 6}, {"snpId": {"SnippetId" :"9719841d-2cf9-4ffa-a1a0-8b98d4b25f54"}, "snpName": "LoadSave", "snpContent": "module LoadSave =\n\n    let fileName  = Var.Create \"\"\n    let canLoad() = Snippets.SaveAsClassW |> View.TryGet = Some \"\" || JS.Confirm \"Changes have not been saved, do you really want to load?\"\n\n    let parseText txt =\n        try       txt\n                  |> Json.Parse\n                  |> snd Serializer.serModel \n                  |> fun mdl -> Snippets.setSnippetsGen mdl.snippets mdl.collapsed\n        with e -> JS.Alert <| e.ToString()\n                  printfn \"%A\" e\n\n    let loadTextFile element  =\n        if canLoad() then\n            FileList.OfElement element\n            |> fun files ->\n                if files.Length > 0 then\n                    let reader = TextFileReader()\n                    reader.Onload <- fun e -> e.Target?result |> parseText\n                    fileName.Set files.[0].Name\n                    files.[0] |> reader.ReadAsText\n\n    [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n    let saveAsJavaScript (_name:string) (_txt:string) = ()\n\n    let saveAs() = \n        let name = match fileName.Value.Split [| '/' ; '\\\\' |] |> Seq.last with \n                   | \"\"    -> \"noname.snippets\" \n                   | fname -> fname\n        Snippets.getSnippetsGen()\n        |> Serializer.getModel\n        |> fst Serializer.serModel\n        |> saveAsJavaScript name\n        Snippets.updateGeneration()\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"6ee01ba8-84e7-4280-946c-63dbe3cb9aec"}], "snpProperties": [], "snpGeneration": 75}, {"snpId": {"SnippetId" :"47149dff-c248-4229-8076-db0dc48a3b0e"}, "snpName": "Importer", "snpContent": "module Importer =\n    open Serializer\n\n    let serSnippetId2 : Ser<SnippetId> = sprintU, fun (x: obj) -> x?Item |> deserGuid |> SnippetId\n\n    let serSnippet2   : Ser<Snippet  > = \n        [|\n            serSnippetId2                                        |> serField \"id\"           (fun s -> s.snpId                     ) (fun v s -> { s with snpId         = if v = SnippetId.Empty then SnippetId <| System.Guid.NewGuid() else v } )\n            serString                                            |> serField \"name\"         (fun s -> s.snpName                   ) (fun v s -> { s with snpName       = v } )\n            serString                                            |> serField \"content\"      (fun s -> s.snpContent                ) (fun v s -> { s with snpContent    = v } )\n            serSnippetId2                    |> serOpt           |> serField \"parent\"       (fun s -> s.snpParentIdO              ) (fun v s -> { s with snpParentIdO  = if v = Some SnippetId.Empty then None else v } )\n            serSnippetId2                    |> serArr           |> serField \"predecessors\" (fun s -> s.snpPredIds |> Seq.toArray ) (fun v s -> { s with snpPredIds    = Set v } )\n            //serString                        |> serMap serString |> serField \"properties\"   (fun s -> s.snpProperties) (fun v s -> { s with snpProperties = v } )\n        |] |> serRecord (Snippet.New \"\" \"\" None)\n    \n    let serSnippets = serSnippet2 |> serArr\n\n    let parseText txt =\n        try       txt\n                  |> Json.Parse\n                  |> snd serSnippets\n                  |> fun snps -> Snippets.setSnippetsGen snps Set.empty\n        with e -> JS.Alert <| e.ToString()\n                  printfn \"%A\" e\n\n    let importFile element  =\n        if LoadSave.canLoad() then\n            FileList.OfElement element\n            |> fun files ->\n                if files.Length > 0 then\n                    let reader = TextFileReader()\n                    reader.Onload <- fun e -> e.Target?result |> parseText\n                    files.[0] |> reader.ReadAsText\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"6ee01ba8-84e7-4280-946c-63dbe3cb9aec"}, {"SnippetId" :"9719841d-2cf9-4ffa-a1a0-8b98d4b25f54"}], "snpProperties": [], "snpGeneration": 71}, {"snpId": {"SnippetId" :"c677b6fd-d833-43ee-a15c-62c60d8572e4"}, "snpName": "mainProgram", "snpContent": "#r \"..\\..\\LayoutEngine\\bin\\LayoutEngine.dll\"\nmodule MainProgram =\n    open FsRoot\n    open WebComponent\n    \n    let appendText (var:Var<string>) msg = \n        match var.Value, msg with\n        | \"\", m \n        | m , \"\" -> m\n        | v , m  -> v + \"\\n\" + m\n        |> var.Set\n        \n    let outputMsgs = Var.Create \"\"\n    let inline appendMsgs   msg = appendText outputMsgs msg\n\n    let runFsCode () = \n        let out (v:string) = appendMsgs <| v.Replace(FsiEvaluator.endToken, \"Done!\")\n        Snippets.FsCodeW \n        |> View.TryGet \n        |> Option.iter (fun code ->\n            asyncResultP {\n                outputMsgs.Set \"Running F#...\"\n                do!     FSharpStationClient.setAddress <| WebSockets.Address FStation.id\n                return! FsCode code |> FsiAgent.evalCode FStation.srcDir\n            } |> AsyncResult.iterA (sprintf \"Error:\\n%A\" >> out) ignore\n        )\n\n    let deleteSnippet() =\n        let snp = Snippets.currentSnippetV.Value\n        if  snp.snpId <> SnippetId.Empty \n        && JS.Confirm (sprintf \"Do you want to delete %s?\" <| Snippet.snippetName snp.snpName snp.snpContent) then \n            Snippets.deleteCurrentSnippet()\n\n    module AF = AppFramework\n\n    let hookVar plug name func obj =\n        AF.tryGetVar plug name\n        |> Option.map        (fun var -> printfn \"Var    %s.%s hooked\"    plug name ;  func obj var.varVar                  )\n        |> Option.defaultWith(fun ()  -> printfn \"Var    %s.%s not found\" plug name ;       obj                             )\n\n    let hookViw plug name func obj =\n        AF.tryGetViw plug name\n        |> Option.map        (fun viw -> printfn \"View   %s.%s hooked\"    plug name ;  func obj viw.viwView                 )\n        |> Option.defaultWith(fun ()  -> printfn \"View   %s.%s not found\" plug name ;       obj                             )\n\n    let hookAct plug name func obj =\n        AF.tryGetAct plug name\n        |> Option.map        (fun act -> printfn \"Action %s.%s hooked\"    plug name ;  func obj (fun _-> act.actFunction |> AF.callFunction () () ) )\n        |> Option.defaultWith(fun ()  -> printfn \"Action %s.%s not found\" plug name ;       obj                             )\n\n    let hookDoc plug name func obj =\n        AF.tryGetDoc plug name\n        |> Option.map        (fun doc -> printfn \"Doc    %s.%s hooked\"    plug name ;  func obj (AF.mainDocV.View |> View.Map (fun _ -> AF.getLazyDoc doc) |> Doc.EmbedView) )\n        |> Option.defaultWith(fun ()  -> printfn \"Doc    %s.%s not found\" plug name ;       obj                             )\n\n    let buttonsRight() =\n        TemplateLib.ButtonsRight()\n        |> hookAct \"FSharpStation\" \"AddSnippet\"    (fun tmp    -> tmp.AddSnippet                  )\n        |> hookAct \"FSharpStation\" \"RemoveSnippet\" (fun tmp    -> tmp.RemoveSnippet               )\n        |> hookAct \"FSharpStation\" \"IndentIn\"      (fun tmp    -> tmp.IndentIn                    )\n        |> hookAct \"FSharpStation\" \"IndentOut\"     (fun tmp    -> tmp.IndentOut                   )\n        |> hookAct \"FSharpStation\" \"RunFS\"         (fun tmp    -> tmp.RunFS                       )\n        |> (fun tmp -> tmp.Doc())\n\n    if IsClient then\n        Snippets.codeAndStartsW |> View.Sink (delayed 300 Monaco.parse)\n\n        View.Sink (fun m -> \n            JS.Window.Onbeforeunload <- \n                if m <> \"\" then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n                else null\n        ) Snippets.SaveAsClassW \n\n    let mainDoc() =\n        TemplateLib.Layout()\n            .LoadFileChanged(  fun ev -> LoadSave.loadTextFile ev.Target)\n            .LoadFileClear(    fun ev -> ev.Target?value <- \"\"          )\n            .ImportFileChanged(fun ev -> Importer.importFile ev.Target  )\n            .ImportFileClear(  fun ev -> ev.Target?value <- \"\"          )\n            .JumpRef(          fun ev -> JumpTo.jumpToRef ev.Target     )\n            //|> hookVar \"FSharpStation\" \"Content\"     (fun tmp -> tmp.Content     )\n            |> hookVar \"FSharpStation\" \"fileName\"      (fun tmp    -> tmp.Filename                    )\n            |> hookVar \"FSharpStation\" \"SnippetName\"   (fun tmp    -> tmp.Name                        )\n            |> hookVar \"FSharpStation\" \"Output\"        (fun tmp    -> tmp.Output                      )\n            |> hookVar \"FSharpStation\" \"Parser\"        (fun tmp    -> tmp.Parser                      )\n            |> hookViw \"FSharpStation\" \"FSCode\"        (fun tmp vw -> tmp.FSCode (Var.Make vw ignore) )\n            |> hookViw \"FSharpStation\" \"SaveNeeded\"    (fun tmp    -> tmp.SaveAsClass                 )\n            |> hookAct \"FSharpStation\" \"SaveAs\"        (fun tmp    -> tmp.SaveAs                      )\n            |> hookDoc \"FSharpStation\" \"editor\"        (fun tmp    -> tmp.CodeEditor                  )\n            |> hookDoc \"FSharpStation\" \"Snippets\"      (fun tmp    -> tmp.Snippets                    )            \n            |> hookDoc \"FSharpStation\" \"Properties\"    (fun tmp    -> tmp.Properties                  )            \n            |> hookDoc \"FSharpStation\" \"ButtonsRight\"  (fun tmp    -> tmp.ButtonsRight                )            \n            |> (fun tmp -> tmp.Doc())\n\n    \n    [< WebSharper.Sitelets.Website >]    \n    let mainProgram() =\n        AF.plugIns.Add {\n            AF.plgName    = \"FSharpStation\"\n            AF.plgVars    = [| AF.newVar  \"fileName\"        LoadSave.fileName\n                               AF.newVar  \"SnippetName\"     (Lens Snippets.currentSnippetV.V.snpName)\n                               AF.newVar  \"Content\"         (Lens Snippets.currentSnippetV.V.snpContent)\n                               AF.newVar  \"Output\"          outputMsgs\n                               AF.newVar  \"Parser\"          FStation.annotationsV\n                            |]  \n            AF.plgViews   = [| AF.newViw  \"FsCode\"          Snippets.FsCodeW\n                               AF.newViw  \"SaveNeeded\"      Snippets.SaveAsClassW\n                            |]  \n            AF.plgDocs    = [| AF.newDoc  \"mainDoc\"         (lazy mainDoc()                 )\n                               AF.newDoc  \"editor\"          (lazy (WebSharper.UI.Html.div [] [ Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty ]) )\n                               AF.newDoc  \"Snippets\"        (lazy RenderSnippets  .render() )\n                               AF.newDoc  \"Properties\"      (lazy RenderProperties.render() )\n                               AF.newDoc  \"ButtonsRight\"    (lazy buttonsRight           () )\n                            |]  \n            AF.plgActions = [| AF.newAct  \"AddSnippet\"      Snippets.newSnippet\n                               AF.newAct  \"RemoveSnippet\"   deleteSnippet       \n                               AF.newAct  \"IndentIn\"        Snippets.indentIn       \n                               AF.newAct  \"IndentOut\"       Snippets.indentOut\n                               AF.newAct  \"AddProperty\"     RenderProperties.addProperty\n                               AF.newAct  \"SaveAs\"          LoadSave.saveAs\n                               AF.newAct  \"RunFS\"           runFsCode\n                               AF.newActF \"LoadFile\"        <| AF.FunAct1 ((fun o -> unbox o |> LoadSave.loadTextFile), \"FileElement\")\n                               AF.newActF \"Import\"          <| AF.FunAct1 ((fun o -> unbox o |> Importer.importFile  ), \"FileElement\")\n                               AF.newActF \"JumpTo\"          <| AF.FunAct1 ((fun o -> unbox o |> JumpTo.jumpToRef     ), \"textarea\"   )\n                            |]\n            AF.plgQueries = [|                                               \n                            |]\n        }\n        \"\"\"\n            double           horizontal  0-50-100 AppFramework.AppFwkClient menuEditor\n\n            menuEditor       horizontal  65       menuLogo                  editorMessages\n            menuLogo         vertical    350      logo                      menu\n            logo             span       \"margin:0; color:gray; font-size: 55px; font-weight:530\" \"F# Station\"\n            editorMessages   horizontal 10-83-100 editorButtons             messages\n            messages         vertical   0-50-100  messagesLeft              messagesRight\n            editorButtons    vertical -200 snippetsSnippet buttons\n            buttons div      \"overflow: hidden; display: grid; grid-template-columns: 100%; grid-template-rows: repeat(15, calc(100% / 15)); bxackground-color: #eee; box-sizing: border-box; padding : 5px; grid-gap: 5px; margin-right: 21px\" btnSaveAs none x btnAddSnippet btnDeleteSnippet btnIndentIn btnIndentOut none x btnRunFS\n            snippetsSnippet  vertical   0-20-100  FSharpStation.Snippets    editorProperties\n            editorProperties vertical   0-100-100 snippet                   properties\n            properties       div        \"\"        FSharpStation.Properties\n            snippet          horizontal 35        Name                      FSharpStation.editor\n            menu             span  \"\" btnLoad btnImport\n            \n            btnSaveAs        button FSharpStation.SaveAs         \"class=btn ${FSharpStation.SaveNeeded}\" \"Save as...    \"\n            btnAddSnippet    button FSharpStation.AddSnippet     \"\"                  \"Add Snippet   \"\n            btnDeleteSnippet button FSharpStation.DeleteSnippet  \"\"                  \"Delete Snippet\"\n            btnIndentIn      button FSharpStation.IndentIn       \"\"                  \"Indent In  >> \"\n            btnIndentOut     button FSharpStation.IndentOut      \"\"                  \"Indent Out << \"\n            btnRunFS         button FSharpStation.RunFS          \"\"                  \"Run F#        \"\n \n            messagesLeft     wcomp-tabstrip                      \"\"                  Output FsCode\n            messagesRight    wcomp-tabstrip                      \"\"                  Parser\n \n            Output           textarea  FSharpStation.Output      \"tabname=Output ; placeholder=Output messages ; spellcheck=false\" \n            FsCode           textarea  FSharpStation.FsCode      \"tabname=F# Code; placeholder=F# Code         ; spellcheck=false\" \n            Parser           textarea  FSharpStation.Parser      \"tabname=Parser ; placeholder=Parser messages; dblclick=${FSharpStation.JumpTo} ; spellcheck=false\" \n            Name             Doc       InputLabel                \"\"     \"Name:\"        FSharpStation.SnippetName\n            btnLoad          Doc       InputFile                 \"\"     \"Load File...\" FSharpStation.LoadFile  FileName\n            btnImport        Doc       InputFile                 \"\"     \"Import...\"    FSharpStation.Import    \"\"\n            FileName         div                                 \"class=form-control\"  FSharpStation.fileName\n        \"\"\"\n        |> String.unindentStr\n        |> LayoutEngine.newLyt \"FStationLyt\"\n        |> LayoutEngine.addLayout\n        AF.mainDocV.Set \"FStationLyt.menuEditor\"\n\n        async {\n          do! Monaco.loader\n          //WcSplitter.init horizontal vertical\n          //WcTabStrip.init()\n          let editor = Monaco.getEditorConfigO() |> Option.map Monaco.render |> Option.defaultValue Doc.Empty\n          return AF.getMainDoc.Value\n        } |> Doc.Async\n\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"25d741d6-4ff8-4d7b-b4ab-3421eb78bb3c"}, {"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"47149dff-c248-4229-8076-db0dc48a3b0e"}, {"SnippetId" :"48cbe0de-d55e-4187-8c13-c6fb1684e4d4"}, {"SnippetId" :"4fe4c1bb-5959-4eb9-a297-387e52ec289f"}, {"SnippetId" :"7a6be31e-8838-4ac9-9848-74dfa7028574"}, {"SnippetId" :"886b5dd6-4b3c-4897-b473-8f066f776fe0"}, {"SnippetId" :"938cc087-2664-4d35-9df2-c0abf106bb63"}, {"SnippetId" :"9719841d-2cf9-4ffa-a1a0-8b98d4b25f54"}, {"SnippetId" :"9882ea9a-2dc3-4459-8605-9b2dd0c89bdc"}, {"SnippetId" :"9c02fa05-0ca5-4da6-a759-1db8c49a080f"}, {"SnippetId" :"bada8694-5447-472a-835e-60d522f6d9d9"}, {"SnippetId" :"c99a4630-f3cc-46e1-8977-06ec20d898ea"}], "snpProperties": [], "snpGeneration": 208}, {"snpId": {"SnippetId" :"e2c502cb-d20a-4e6c-b75c-836776fed43f"}, "snpName": "Messaging", "snpContent": "module Messaging =\n    module ReaderM = ReaderMResult\n    open ReaderM.Operators\n\n    let wsStationClient = if IsClient then new WebSockets.WSMessagingClient(FStation.id) else new WebSockets.WSMessagingClient(\"FStation.id\", WebSockets.FSStation)\n\n    let processMessage (msg: FSMessage) : Async<Result<FSResponse,ResultMessage<string>>>= \n        reader {\n            match msg with\n            | MsgGetId                          -> return  RespString FStation.id\n            | MsgGetSnippets               snrs -> let!    snps = snrs |> ReaderM.traverseSeq Snippet.snippetFromRefORm\n                                                   return  snps |> Seq.choose id |> Seq.toArray |> RespSnippets\n            | MsgGetCode                   snr  -> Snippets.clearPredsCache ()\n                                                   let!    snp  = Snippet.snippetFromRefORm snr |> ReaderM.absorbO (fun () -> ErrorMsg <| sprintf \"Snippet not found %A\" snr)\n                                                   return! Snippet.fastCodeRm (Some snp.snpId) (Some snp.snpId) |>> fst |>> RespString\n            | MsgGetPredecessors           snr  -> Snippets.clearPredsCache ()\n                                                   return  Hole ? TODO_GetPredecessors\n            | MsgAction [| \"AddOutput\" ; txt |] -> MainProgram.appendMsgs txt\n                                                   return  FSResponse.RespString \"Ok\"\n            | MsgGetUrl                         -> return  FSResponse.RespString JS.Document.BaseURI\n            | _                                 -> return  Hole ?(sprintf \"TODO message: %A\" msg)\n        } |> Snippets.runReaderResult |> Async.rtn\n    \n    if IsClient then\n        async {\n            do! Async.Sleep 1000\n            while true do\n                try         wsStationClient.ProcessIncoming processMessage\n                            do! Async.Sleep 60000\n                with   e -> printfn \"%s\" e.Message\n                            do! Async.Sleep 1000\n        } |> Async.Start\n        \n\n    if not IsClient then\n        FsiAgent.setQueueHandlers (fun (txt:string)  -> txt.Replace(FsiEvaluator.endToken, \"Done!\") \n                                                        |> FSharpStationClient.sendOutput \n                                                        |> AsyncResult.iterS print print)", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"268771dc-ecc7-4dde-881b-e0b94deb30ea"}, {"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"48e111a3-1b92-4da3-8353-ae73ece0bca0"}, {"SnippetId" :"c677b6fd-d833-43ee-a15c-62c60d8572e4"}], "snpProperties": [], "snpGeneration": 160}, {"snpId": {"SnippetId" :"50f04317-645e-4a55-8fe5-d914a8c3c865"}, "snpName": "Sitelet", "snpContent": "[< JavaScript false >]\r\nmodule Sitelet =\r\n    open WebSharper\r\n    open WebSharper.Sitelets\r\n    open WebSharper.UI\r\n    open WebSharper.UI.Server\r\n\r\n    type EndPointServer = | [< EndPoint \"/\" >] EP\r\n\r\n    let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\r\n        Content.Page(Title = \"Main Page\" \r\n                   , Body  = [\r\n                        Html.client <@ MainProgram.mainProgram() @>\r\n                        Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\r\n                     ])\r\n\r\n    [< Website >]\r\n    let MySampleWebsite : Sitelet<EndPointServer> = Sitelet.Content \"/\" EP (fun ctx -> content ctx EP)\r\n\r\n    [<Sealed>]\r\n    type Website() =\r\n        interface IWebsite<EndPointServer> with\r\n            member this.Sitelet = MySampleWebsite\r\n            member this.Actions = [ EP ]\r\n\r\n    [<assembly: Website(typeof<Website>)>]\r\n    do ()", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"c677b6fd-d833-43ee-a15c-62c60d8572e4"}], "snpProperties": [], "snpGeneration": 208}, {"snpId": {"SnippetId" :"a17730c1-09a7-48f8-bba8-a24ba4c61dd5"}, "snpName": "FSharpStation", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net451\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net451\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net451\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net451\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net451\\Microsoft.Owin.FileSystems.dll\"\n\n#define FSS_SERVER\n\n[< JavaScript false >]\nmodule Server =\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n    open WebSharper.Sitelets\n    open WebSharper.UI.Server\n    open WebSharper.UI.Templating\n    open WebSharper.UI.Html\n    open WebSharper.Owin.WebSocket\n    open WebSharper.Owin.WebSocket.Client\n    open WebSharper.Owin.WebSocket.Server\n    open WebSockets\n\n    type EndPointServer = | [< EndPoint \"/\" >] EP\n\n    let content (ctx:Context<EndPointServer>) (endpoint:EndPointServer) : Async<Content<EndPointServer>> =\n        Content.Page(Title = \"Main Page\" \n                   , Body  = [\n                        Html.client <@ MainProgram.mainProgram() @>\n                        Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                     ])\n\n    [< EntryPoint >]\n    let Main args =\n        printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n        let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9005/\"\n        let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue @\"..\\website\"\n        let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n        let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n        let broker = Broker.BrokerAgent epWebSocket\n        Broker.BrokerAgent.FssWebSocketO <- Some broker\n        use server = WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootdir\n                                               , Sitelet             = (Some <| Application.MultiPage content)\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseWebSocket(  epWebSocket, broker.Start, maxMessageSize = max)\n            |> ignore)\n        stdout.WriteLine(\"Listening on {0}, hit enter to finish\", url)\n        stdin.ReadLine() |> ignore\n        0\n\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"4fe4c1bb-5959-4eb9-a297-387e52ec289f"}, {"SnippetId" :"580c84e5-f8ba-467a-8e26-45ca810cb06d"}, {"SnippetId" :"b9e34661-f209-4a13-9718-b4ff0af05ebb"}, {"SnippetId" :"c677b6fd-d833-43ee-a15c-62c60d8572e4"}, {"SnippetId" :"e2c502cb-d20a-4e6c-b75c-836776fed43f"}], "snpProperties": [], "snpGeneration": 208}, {"snpId": {"SnippetId" :"89fdeebe-695c-4e76-a8ec-b48d4ef9512d"}, "snpName": "compile & run FSharpStation", "snpContent": "#define COMPILEFSharpStation14\n#define FIX_GENERIC\nmodule RunFSharpStation =\n    module ReaderM = ReaderMAsyncResultM\n    open ReaderM.Operators\n    \n    open System.IO\n    open RunProcess\n    open WsCompiler\n    open FsCode\n    open CommArgCollection\n    \n    let killProcess excludeId name =\n        System.Diagnostics.Process.GetProcessesByName name\n        |> Seq.filter (fun worker -> worker.Id <> excludeId)\n        |> Seq.iter (fun worker ->\n             worker.Kill       ()\n             worker.WaitForExit()\n             worker.Dispose    ())\n    \n    let wsCompileSnippet snpName = \n        asyncResultM {\n            let! code            = FSharpStationClient.getCode snpName\n            let! exclPid         = FSharpStationClient.getBrokerProcessId()\n            let  defines0        = (FsCode.extractDefines <| FsCode code).Split([| \" \" ; \"-d:\" |], System.StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs0, defines1, prepIs, nowarns, cdO = separatePrepros (String.splitByChar '\\n' code) |> separateDirectives\n            let  assembs         = Array.append assembs0 [| @\"..\\packages\\fsharp.core\\lib\\net45\\FSharp.Core.dll\" |]\n            let  defines         = Array.append defines0 defines1\n            let  args            = [ intShowArgs   /= true\n                                     intCreateDir  /= true\n                                     fscGenFSharp2 /= \"noframework\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n                                   ]\n            let  args1           = compileOptionsExeDebug snpName\n                                 + siteOptions()\n                                 + args\n            let  args2           = prepOptions args1 (assembs, defines, prepIs)\n            return! reader {\n                do!                processArgs fs assembs nowarns\n                let! name        = getStringRm intName\n                do                 killProcess exclPid name\n                let! res         = compileRm() \n                do                 print res\n                let! site0       = getStringRm wscWebSite\n                let  site        = Path.GetFullPath site0\n                let! exeFile0    = getStringRm fscOutput\n                let  exeFile     = Path.GetFullPath      exeFile0\n                let  startDir    = Path.GetDirectoryName exeFile0\n                let  url         = @\"http://localhost:9006\"\n                let  parms       = sprintf \"%A %A\" url site \n                do                 printfn \"Starting %s %s\" exeFile parms\n                do                 startProcessDir   exeFile parms startDir |> ignore\n                do                 startProcess      url     \"\"             |> ignore\n            } |> ReaderM.run args2\n        } |> AsyncResultM.iterpS id\n    wsCompileSnippet \"FsRoot/Applications/FSharpStation/FSharpStation\"\n\n", "snpParentIdO": {"SnippetId" :"d2b2edfb-4b2c-4cd8-984b-801fa86ec69f"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"badab874-2c63-4730-a64f-54371723101c"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 224}, {"snpId": {"SnippetId" :"39c19121-4cca-4db2-a4d5-99aef7da4163"}, "snpName": "Various", "snpContent": "", "snpParentIdO": {"SnippetId" :"4c4be76d-72f0-4ba5-b740-e22f7a48c525"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 46}, {"snpId": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpName": "OpenCv", "snpContent": "#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\OpenCvSharp3-AnyCPU\\lib\\net46\\OpenCvSharp.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\OpenCvSharp3-AnyCPU\\lib\\net46\\OpenCvSharp.Blob.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\OpenCvSharp3-AnyCPU\\lib\\net46\\OpenCvSharp.Extensions.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\OpenCvSharp3-AnyCPU\\lib\\net46\\OpenCvSharp.UserInterface.dll\"\r\n\r\nmodule OpenCv =\r\n\r\n    let path = System.Environment.GetEnvironmentVariable \"Path\"\r\n    let dir  = @\"D:\\Abe\\CIPHERWorkspace\\FSNetCore\\packages\\OpenCvSharp3-AnyCPU\\NativeDlls\\x64\\\"\r\n    if path.Contains (\";\" + dir + \";\") |> not then\r\n        System.Environment.SetEnvironmentVariable(\"Path\", path + \";\" + dir + \";\")\r\n\r\n    let inline (!>) (x:^a) : ^b = ((^a or ^b) : (static member op_Implicit : ^a -> ^b) x) ", "snpParentIdO": {"SnippetId" :"39c19121-4cca-4db2-a4d5-99aef7da4163"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 44}, {"snpId": {"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}, "snpName": "Data", "snpContent": "module Data =\r\n    let root = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStationN\\projects\\OpenCV\\Data\\\"\r\n\r\n    module Image =\r\n        let Lenna          = root + @\"Image\\lenna.png\"\r\n        let Girl           = root + @\"Image\\Girl.bmp\"\r\n        let Goryokaku      = root + @\"Image\\goryokaku.jpg\"\r\n        let Fruits         = root + @\"Image\\fruits.jpg\"\r\n        let TsukubaLeft    = root + @\"Image\\tsukuba_left.png\"\r\n        let TsukubaRight   = root + @\"Image\\tsukuba_right.png\"\r\n        let Shapes         = root + @\"Image\\shapes.png\"\r\n        let Asahiyama      = root + @\"Image\\asahiyama.jpg\"\r\n\r\n        let Lenna511       = root + @\"Image\\lenna511.png\"\r\n        let Mandrill       = root + @\"Image\\Mandrill.bmp\"\r\n        let Maltese        = root + @\"Image\\maltese.jpg\"\r\n        let Cake           = root + @\"Image\\cake.bmp\"\r\n        let Penguin1       = root + @\"Image\\penguin1.png\"\r\n        let Penguin1b      = root + @\"Image\\penguin1b.png\"\r\n        let Penguin2       = root + @\"Image\\penguin2.png\"\r\n        let Distortion     = root + @\"Image\\Calibration\\01.jpg\"\r\n        let Calibration    = root + @\"Image\\Calibration\\{0:D2}.jpg\"\r\n        let SurfBox        = root + @\"Image\\box.png\"\r\n        let SurfBoxinscene = root + @\"Image\\box_in_scene.png\"\r\n        let Square1        = root + @\"Image\\Squares\\pic1.png\"\r\n        let Square2        = root + @\"Image\\Squares\\pic2.png\"\r\n        let Square3        = root + @\"Image\\Squares\\pic3.png\"\r\n        let Square4        = root + @\"Image\\Squares\\pic4.png\"\r\n        let Square5        = root + @\"Image\\Squares\\pic5.png\"\r\n        let Square6        = root + @\"Image\\Squares\\pic6.png\"\r\n        let Yalta          = root + @\"Image\\yalta.jpg\"\r\n        let Depth16Bit     = root + @\"Image\\16bit.png\"\r\n        let Hand           = root + @\"Image\\hand_p.jpg\"\r\n        let Balloon        = root + @\"Image\\Balloon.png\"\r\n        let Newspaper      = root + @\"Image\\very_old_newspaper.png\"\r\n        let Binarization   = root + @\"Image\\binarization_sample.bmp\"\r\n        let Walkman        = root + @\"Image\\walkman.jpg\"\r\n        let Cat            = root + @\"Image\\cat.jpg\"\r\n        let Match1         = root + @\"Image\\match1.png\"\r\n        let Match2         = root + @\"Image\\match2.png\"\r\n\r\n    module Movie =\r\n        let Hara           = root + @\"Movie\\hara.flv\"\r\n        let Bach           = root + @\"Movie\\bach.mp4\"\r\n\r\n    module Text =\r\n        let Camera         = root + @\"Text\\camera.xml\"\r\n        let HaarCascade    = root + @\"Text\\haarcascade_frontalface_default.xml\"\r\n        let HaarCascadeAlt = root + @\"Text\\haarcascade_frontalface_alt.xml\"\r\n        let LatentSvmCat   = root + @\"Text\\cat.xml\"\r\n        let Mushroom       = root + @\"Text\\agaricus-lepiota.data\"\r\n        let LetterRecog    = root + @\"Text\\letter-recognition.data\"\r\n        let LbpCascade     = root + @\"Text\\lbpcascade_frontalface.xml\"\r\n", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 23}, {"snpId": {"SnippetId" :"61df2fa6-c659-4ee7-a208-0dd894516e58"}, "snpName": "SuperResolutionSample", "snpContent": "\r\nmodule SuperResolutionSample =\r\n    open OpenCvSharp;\r\n\r\n    let main() =\r\n        use capture = new VideoCapture()\r\n        capture.Set(CaptureProperty.FrameWidth , 640.) |> ignore\r\n        capture.Set(CaptureProperty.FrameHeight, 480.) |> ignore\r\n        capture.Open 0\r\n        if capture.IsOpened() |> not then failwith \"capture initialization failed\"\r\n        let fs = FrameSource.CreateCameraSource 0\r\n        let sr = SuperResolution.CreateBTVL1()\r\n        sr.SetInput fs\r\n        use normalWindow = new Window(\"normal\")\r\n        use srWindow     = new Window(\"super resolution\")\r\n        let normalFrame  = new Mat()\r\n        let srFrame      = new Mat()\r\n        let rec loop() =\r\n            capture.Read normalFrame  |> ignore\r\n            sr.NextFrame !> srFrame\r\n            if normalFrame.Empty() || srFrame.Empty() then () else\r\n            normalWindow.ShowImage normalFrame\r\n            srWindow    .ShowImage srFrame\r\n            if Cv2.WaitKey 100  = 27 then () else\r\n            loop()\r\n        loop()\r\n\r\n    main()                ", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 30}, {"snpId": {"SnippetId" :"fff64510-9c41-49dd-82ce-436c6f5da70e"}, "snpName": "SimpleCamera", "snpContent": "#define OPENCV1\r\nmodule SimpleCamera =\r\n    open System\r\n    open OpenCvSharp\r\n    open OpenCvSharp.UserInterface\r\n\r\n    let loopCamera f =\r\n        use capture   = new VideoCapture(0)\r\n        if capture.IsOpened() |> not then failwith \"capture initialization failed\"\r\n        use normalFrame  = new Mat()\r\n        let frameRate = 30\r\n        let sleepTime = 1000 / frameRate\r\n        let rec loop()   =\r\n            capture.Read normalFrame |> ignore\r\n            if normalFrame.Empty() then () else\r\n            f normalFrame\r\n            if Cv2.WaitKey sleepTime = 27 then () else\r\n            loop()\r\n        loop()\r\n\r\n    let main() =\r\n        use normalWindow = new Window(\"normal\")\r\n        loopCamera normalWindow.ShowImage\r\n\r\n    //main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 44}, {"snpId": {"SnippetId" :"e2ab8c63-aaae-4267-826e-5c2c1114bb36"}, "snpName": "SimpleFaceDetect", "snpContent": "#define FACEDETECT1\r\nmodule SimpleFaceDetect =\r\n    open OpenCvSharp\r\n\r\n    let haarCascade    = new CascadeClassifier(Data.Text.HaarCascade   )\r\n    let haarCascadeAlt = new CascadeClassifier(Data.Text.HaarCascadeAlt)\r\n    let lbpCascade     = new CascadeClassifier(Data.Text.LbpCascade    )\r\n\r\n    let imShow title res = Cv2.ImShow(title, res)\r\n\r\n    let gray   = new Mat()\r\n\r\n    let convertColorGray src =\r\n        Cv2.CvtColor(!> (src:Mat), !> gray, ColorConversionCodes.RGB2GRAY)\r\n        gray\r\n\r\n    let detectMultiScale (cascade:CascadeClassifier) (src:Mat) =\r\n        let gray   = convertColorGray src\r\n        cascade.DetectMultiScale(gray, 1.08, 2, HaarDetectionType.DoCannyPruning\r\n                                              + HaarDetectionType.ScaleImage\r\n                                              //+ HaarDetectionType.DoRoughSearch \r\n                                              + HaarDetectionType.FindBiggestObject\r\n                                              , !> (new Size(30, 30)) )\r\n\r\n    let drawEllipse (mat:Mat) (face:Rect) =\r\n        let center = new Point(face.X + face.Width / 2, face.Y + face.Height / 2 )\r\n        let axes   = new Size (         face.Width / 2,          face.Height / 2 )\r\n        Cv2.Ellipse(!> mat, center, axes, 0., 0., 360., new Scalar(255., 0., 255.), 4);\r\n\r\n    let circleFace (mat:Mat) (face:Rect) = drawEllipse mat face ; mat\r\n\r\n    let circleFaces (mat:Mat) faces = faces |> Seq.iter (drawEllipse mat) ; mat\r\n\r\n    let showFace  cascade title src = src |> detectMultiScale cascade |> Seq.tryHead |> Option.iter (circleFace  src >> imShow title)\r\n    let showFaces cascade title src = src |> detectMultiScale cascade                |> circleFaces src |> imShow title\r\n\r\n    let main() =    \r\n        use src         = new Mat(Data.Image.Yalta, ImreadModes.Color)\r\n        src.Clone() |> showFaces haarCascade \"Faces by Haar\"\r\n        src         |> showFaces lbpCascade  \"Faces by LBP\"\r\n        Cv2.WaitKey 0 |> ignore\r\n        Cv2.DestroyAllWindows()\r\n\r\n    //main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 26}, {"snpId": {"SnippetId" :"dd47f696-adf1-4a70-b9ec-2613415db8fe"}, "snpName": "FaceDetect", "snpContent": "module FaceDetect =\r\n    let main() =\r\n        SimpleCamera.loopCamera (SimpleFaceDetect.showFace SimpleFaceDetect.haarCascade \"Face (press <Esc> to stop)\")\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"e2ab8c63-aaae-4267-826e-5c2c1114bb36"}, {"SnippetId" :"fff64510-9c41-49dd-82ce-436c6f5da70e"}], "snpProperties": [], "snpGeneration": 44}, {"snpId": {"SnippetId" :"92350950-da39-45bf-b746-b6efaaee1ce5"}, "snpName": "Clahe", "snpContent": " module ClaheSample =\r\n    open OpenCvSharp\r\n\r\n    let main() =\r\n        let src   = new Mat(Data.Image.TsukubaLeft, ImreadModes.GrayScale)\r\n        let dst1  = new Mat()\r\n        let dst2  = new Mat()\r\n        let dst3  = new Mat()\r\n        use clahe = Cv2.CreateCLAHE()\r\n        clahe.ClipLimit     <- 20.\r\n        clahe.Apply(!> src, !> dst1)\r\n        clahe.ClipLimit     <- 40.\r\n        clahe.Apply(!> src, !> dst2)\r\n        clahe.TilesGridSize <- new Size(4., 4.)\r\n        clahe.Apply(!> src, !> dst3)\r\n        Window.ShowImages(\r\n            [| src   ; dst1         ; dst2         ; dst3          |]\r\n          , [| \"src\" ; \"dst clip20\" ; \"dst clip40\" ; \"dst tile4x4\" |])\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 28}, {"snpId": {"SnippetId" :"e3629d12-51a6-493c-80fe-1eb0af5cc083"}, "snpName": "BinarizerSample", "snpContent": "module BinarizerSample =\r\n    open System\r\n    open System.Diagnostics\r\n    open OpenCvSharp\r\n    open OpenCvSharp.Extensions\r\n\r\n    let main() =\r\n        use src     = Cv2.ImRead(Data.Image.Binarization, ImreadModes.GrayScale)\r\n        use niblack = new Mat()\r\n        use sauvola = new Mat()\r\n        use bernsen = new Mat()\r\n        use nick    = new Mat()\r\n        let kernelSize = 51\r\n        let sw = new Stopwatch()\r\n        sw.Start()\r\n        Binarizer.Niblack(src, niblack, kernelSize, -0.2)\r\n        sw.Stop()\r\n        Console.WriteLine(\"Niblack {0} ms\", sw.ElapsedMilliseconds)\r\n        sw.Restart()\r\n        Binarizer.Sauvola(src, sauvola, kernelSize, 0.1, 64.)\r\n        sw.Stop()\r\n        Console.WriteLine(\"Sauvola {0} ms\", sw.ElapsedMilliseconds)\r\n        sw.Restart()\r\n        Binarizer.Bernsen(src, bernsen, kernelSize, byte 50, byte 200)\r\n        sw.Stop()\r\n        Console.WriteLine(\"Bernsen {0} ms\", sw.ElapsedMilliseconds)\r\n        sw.Restart()\r\n        Binarizer.Nick(src, nick, kernelSize, -0.14)\r\n        sw.Stop()\r\n        Console.WriteLine(\"Nick {0} ms\", sw.ElapsedMilliseconds)\r\n        use srcW     = new Window(\"src\", WindowMode.AutoSize, src)\r\n        use NiblackW = new Window(\"Niblack\", WindowMode.AutoSize, niblack)\r\n        use SauvolaW = new Window(\"Sauvola\", WindowMode.AutoSize, sauvola)\r\n        use BernsenW = new Window(\"Bernsen\", WindowMode.AutoSize, bernsen)\r\n        use NickW    = new Window(\"Nick\", WindowMode.AutoSize, nick)\r\n        Cv2.WaitKey 5000\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 32}, {"snpId": {"SnippetId" :"15ef41a7-2184-4249-aba8-707215bece5f"}, "snpName": "BgSubtractorMOG", "snpContent": "module BgSubtractorMOG =\r\n    open OpenCvSharp\r\n\r\n    let main() =\r\n        use capture    = new VideoCapture(Data.Movie.Bach)\r\n        use mog        = BackgroundSubtractorMOG.Create()\r\n        use windowSrc  = new Window(\"src\")\r\n        use windowDst  = new Window(\"dst\")\r\n        use frame      = new Mat()\r\n        use fg         = new Mat()\r\n        let rec loop() =\r\n            capture.Read frame |> ignore\r\n            if frame.Empty() then () else\r\n            mog.Apply(!> frame, !> fg, 0.01)            \r\n            windowSrc.Image <- frame\r\n            windowDst.Image <- fg\r\n            if Cv2.WaitKey 50 = 27 then () else\r\n            loop()\r\n        loop()\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 32}, {"snpId": {"SnippetId" :"190379ea-bc8a-4858-9931-b8b54ab2b235"}, "snpName": "ConnectedComponentsSample", "snpContent": "module ConnectedComponentsSample =\r\n    open OpenCvSharp\r\n\r\n    let main() =\r\n        let src       = new Mat(Data.Image.Shapes, ImreadModes.Color)\r\n        let gray      = src.CvtColor ColorConversionCodes.BGR2GRAY\r\n        let binary    = gray.Threshold(0., 255., ThresholdTypes.Otsu + ThresholdTypes.Binary)\r\n        let labelView = src.EmptyClone()\r\n        let rectView  = binary.CvtColor(ColorConversionCodes.GRAY2BGR)\r\n        let cc        = Cv2.ConnectedComponentsEx(!> binary)\r\n        if cc.LabelCount <= 1 then () else\r\n        cc.RenderBlobs labelView \r\n        for blob in cc.Blobs |> Seq.skip 1  do\r\n            rectView.Rectangle(blob.Rect, Scalar.Red)\r\n        let maxBlob    = cc.GetLargestBlob()\r\n        let filtered   = new Mat()\r\n        cc.FilterByBlob(src, filtered, maxBlob) |> ignore\r\n        use srcW       = new Window(\"src\"          , src      )\r\n        use binaryW    = new Window(\"binary\"       , binary   )\r\n        use labelViewW = new Window(\"labels\"       , labelView)\r\n        use rectViewW  = new Window(\"bonding boxes\", rectView )\r\n        use filteredW  = new Window(\"maximum blob\" , filtered )\r\n        Cv2.WaitKey 5000 |> ignore\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 33}, {"snpId": {"SnippetId" :"23a82e5a-6c9d-4027-81be-3049654c42fa"}, "snpName": "HoughLinesSample", "snpContent": "module HoughLinesSample =\r\n    open System\r\n    open OpenCvSharp\r\n\r\n    let main() =\r\n        use imgGray = new Mat(Data.Image.Goryokaku, ImreadModes.GrayScale)\r\n        use imgStd  = new Mat(Data.Image.Goryokaku, ImreadModes.Color)\r\n        use imgProb = imgStd.Clone()\r\n        Cv2.Canny(!> imgGray, !> imgGray, 50., 200., 3, false)\r\n        let segStd = Cv2.HoughLines(!> imgGray, 1., Math.PI / 180., 50, 0., 0.)\r\n        let limit = Math.Min(segStd.Length, 10)\r\n        for i in 0..limit do\r\n            // Draws result lines\r\n            let rho   = segStd.[i].Rho\r\n            let theta = segStd.[i].Theta\r\n            let a     = Math.Cos(float theta) |> float32\r\n            let b     = Math.Sin(float theta) |> float32\r\n            let x0    = a * rho\r\n            let y0    = b * rho\r\n            let pt1   = new Point( Math.Round(x0 + (float32 1000) * (-b) |> float) |> int, Math.Round(y0 + (float32 1000.) * a |> float) |> int)\r\n            let pt2   = new Point( Math.Round(x0 - (float32 1000) * (-b) |> float) |> int, Math.Round(y0 - (float32 1000.) * a |> float) |> int)\r\n            imgStd.Line(pt1, pt2, Scalar.Red, 3, LineTypes.AntiAlias, 0)\r\n        let segProb = Cv2.HoughLinesP(!> imgGray, 1., Math.PI / 180., 50, 50., 10.)\r\n        for s in segProb do\r\n            imgProb.Line(s.P1, s.P2, Scalar.Red, 3, LineTypes.AntiAlias, 0)\r\n        use imgStdW  = new Window(\"Hough_line_standard\"     , WindowMode.AutoSize, imgStd )\r\n        use imgProbW = new Window(\"Hough_line_probabilistic\", WindowMode.AutoSize, imgProb)\r\n        Window.WaitKey 5000 |> ignore\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 35}, {"snpId": {"SnippetId" :"8d256d9b-54df-4e18-9090-49461c856943"}, "snpName": "BRISKSample", "snpContent": "\r\nmodule BRISKSample =\r\n    open OpenCvSharp\r\n\r\n    let main() =\r\n        use gray      = new Mat(Data.Image.Lenna, ImreadModes.GrayScale)\r\n        use dst       = new Mat(Data.Image.Lenna, ImreadModes.Color    )\r\n        let brisk     = BRISK.Create()\r\n        let keypoints = brisk.Detect gray\r\n        if keypoints = null then printfn \"nothing\" else\r\n        let color = new Scalar(0., 255., 0.)\r\n        for kpt in keypoints do\r\n            let r = kpt.Size / (float32 2.)\r\n            Cv2.Circle(!> dst, !> kpt.Pt, (int)r, color)\r\n            Cv2.Line(!> dst, \r\n                !> Point2f(kpt.Pt.X + r, kpt.Pt.Y + r), \r\n                !> Point2f(kpt.Pt.X - r, kpt.Pt.Y - r), \r\n                color)\r\n            Cv2.Line(!> dst, \r\n                !>  Point2f(kpt.Pt.X - r, kpt.Pt.Y + r), \r\n                !>  Point2f(kpt.Pt.X + r, kpt.Pt.Y - r), \r\n                color)\r\n        use dstW = new Window(\"BRISK features\", dst)\r\n        Cv2.WaitKey 5000 |> ignore\r\n\r\n    main()", "snpParentIdO": {"SnippetId" :"a84deee8-3a64-4ec5-b0e3-ff673896a197"}, "snpPredIds": [{"SnippetId" :"debc4ef5-69ad-4e13-990e-49c6ec2f225c"}], "snpProperties": [], "snpGeneration": 35}, {"snpId": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpName": "FSI ZONE", "snpContent": "", "snpParentIdO": null, "snpPredIds": [], "snpProperties": [["IndentChildren", "0 |-| 4"]], "snpGeneration": 230}, {"snpId": {"SnippetId" :"c2fd97dd-907f-4c2e-ae68-d80f2b8caf3c"}, "snpName": "resultU", "snpContent": "#define R16\r\nopen FsRoot\r\n\r\nresultU {\r\n    let! m1 = Info     \"Info    1\"\r\n    let! m2 = Warning  \"Warning 1\"\r\n    let! m3 = ErrorMsg \"ErrorMsg1\"\r\n    if    1 = 1 then printfn \"1=1\"\r\n    let! m4 = Message  \"Hello\"\r\n    let! m5 = NoMsg\r\n    let! m7 = Info     \"Info    2\"\r\n    let! v = ResultU.getM()\r\n    printfn \"----> %A\" v\r\n    let! m8 = Warning  \"Warning 2\"\r\n    let! m9 = ErrorMsg \"ErrorMsg2\"\r\n    ()\r\n}\r\n|> ResultU.run |> print\r\n\r\nresultU {\r\n            do! Info     \"Info    1\" \r\n            do! Warning  \"Warning 1\" \r\n            do! ErrorMsg \"ErrorMsg1\" \r\n            let! v = ResultU.getM()\r\n            printfn \"----> %A\" v\r\n            do! Info     \"Info    2\" \r\n            do! ResultU.checkU       \r\n            do! Warning  \"Warning 2\" \r\n            do! ResultU.checkU       \r\n            do! ErrorMsg \"ErrorMsg2\" \r\n            do! ResultU.checkU       \r\n}          \r\n|> ResultU.run |> printfn \">>> %A\"\r\n\r\nupdate {\r\n            do! Info     \"Info    1\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n            do! Warning  \"Warning 1\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n            do! ErrorMsg \"ErrorMsg1\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n            let! v = ResultU.getM()\r\n            printfn \"----> %A\" v\r\n            do! Info     \"Info    2\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n            do! Warning  \"Warning 2\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n            do! ErrorMsg \"ErrorMsg2\" |> ResultU.rtnM |> UpdateM.map (Option.iter id)\r\n            do! ResultU.checkU                       |> UpdateM.map (Option.iter id)\r\n}          \r\n|> function UM f -> match f NoMsg with (v, m) -> (v, m) |> printfn \"===> %A\"\r\n\r\nopen ResultU.Operators\r\n\r\n(\r\n        (  Info     \"Info    1\" |> OkUWithMsg ()  ) |> ResultU.bind (fun m1 ->\r\n        (  Warning  \"Warning 1\" |> OkUWithMsg ()  ) |> ResultU.bind (fun m2 ->\r\n        (  ErrorMsg \"ErrorMsg1\" |> OkUWithMsg ()  ) |> ResultU.bind (fun m3 ->\r\n        (  Info     \"Info    2\" |> OkUWithMsg ()  ) |> ResultU.bind (fun m4 ->\r\n        (  Warning  \"Warning 2\" |> OkUWithMsg ()  ) |> ResultU.bind (fun m5 ->\r\n        (  ErrorMsg \"ErrorMsg2\" |> OkUWithMsg ()  ) \r\n        )))))\r\n)\r\n|> ResultU.run |> print\r\n\r\nupdate {\r\n    do!      UpdateM.set \"Hello\"\r\n    let! v = UpdateM.get ()\r\n    do       printfn \"%A\" v\r\n} |> UpdateM.setRun \"Hi\" |> print", "snpParentIdO": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpPredIds": [{"SnippetId" :"014e7d5e-9b89-406d-a193-b2a77d817215"}, {"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}, {"SnippetId" :"3f5aa563-e468-4d13-a027-8a5ff3a44106"}, {"SnippetId" :"ff513507-728e-411b-9964-a6844e194c25"}], "snpProperties": [], "snpGeneration": 230}, {"snpId": {"SnippetId" :"f5c6e00d-1589-46a4-bfc6-d3c3b58b689d"}, "snpName": "ContM", "snpContent": "#define TEST12\nopen FsRoot\n\ntype ContMX<'T, 'R> = ContM of (('T -> 'R) -> 'R)\n\nmodule ContMX =\n\n    let run  (ContM ab_b) a_b = ab_b a_b\n\n    let rtn  a                    = ContM(fun a_b -> a_b a )\n    let bind a_bcC   (ContM ac_c) = fun b_c -> \n                                        (fun a -> match a_bcC a with \n                                                  ContM bc_c -> bc_c b_c\n                                        ) |> ac_c\n                                    |> ContM\n    let map              a_b  acC = acC |> bind (a_b >> rtn)\n\ntype ContM<'T, 'R> = (('T -> 'R) -> 'R)\n\n/// Continuation Monads have a signature like this ab_b : ('a->'b)->'b\n/// where ab is the continuation function\nmodule ContM =\n\n    let rtn  a                        = (fun a_b -> a_b a                               ) : ContM<_,_>\n    let bind a_bc_c (ac_c:ContM<_,_>) = (fun b_c -> (fun a -> a_bc_c a <| b_c ) |> ac_c ) : ContM<_,_>\n    let map  a_b     ac_c             = ac_c |> bind (a_b >> rtn)                         : ContM<_,_>\n    let run  a_b    (ab_b:ContM<_,_>) = ab_b a_b\n\n    type ContinuationBuilder() = \n      member inline x.Return(v) = rtn v\n      member inline x.Bind(u, f) = bind f u\n      member inline x.Zero() = x.Return(())    \n      member inline x.Delay(f) = x.Bind(x.Zero(), f)\n      member inline x.Combine(c1, c2) = x.Bind(c1, fun () -> c2)\n      member inline x.ReturnFrom(m : ContM<_,_>) = m\n     // member inline x.Using(r,f) = UM(fun s -> use rr = r in let (UM g) = f rr in g s)\n      //member inline x.For(sq:seq<'V>, f:'V -> UpdateMonad<'S, 'P, unit>) = \n      //  let rec loop (en:System.Collections.Generic.IEnumerator<_>) = \n      //    if en.MoveNext() then x.Bind(f en.Current, fun _ -> loop en)\n      //    else x.Zero()\n      //  x.Using(sq.GetEnumerator(), loop)\n      //member inline x.While(t, f:unit -> UpdateMonad<'S, 'P, unit>) =\n      //  let rec loop () = if t() then x.Bind(f(), loop)\n      //                           else x.Zero()\n      //  loop()\n\n    let contM = ContinuationBuilder()        \n\n//// ex2 = do\n////   a <- return 1\n////   b <- Cont (\\fred -> fred 10)\n////   return $ a+b\n//\n//    let ex2 = contM {\n//        let  a =  1\n//        let! b = (fun fred -> fred 10)\n//        return a + b\n//    }\n//\n//    let test2 = ex2 |> run (tee <| print)\n//    printfn \"test2: %A\" test2\n////> ex3 = do\n////>   a <- return 1\n////>   b <- Cont (\\fred -> \"escape\")\n////>   return $ a+b\n////\n////> test3 = runCont ex3 show\n//\n//    let ex3 = contM {\n//        let  a =  1\n//        let! b = (fun fred -> \"escape\")\n//        return a + b\n//    }\n//\n//    let test3 = ex3 |> run string\n//    test3 |> printfn \"test3: %A\"\n//\n////> test5 = do\n////>   a <- return 1\n////>   b <- [10,20]\n////>   return $ a+b\n//\n//    let test5 = seq {\n//        let  a = 1\n//        for b in [10 ; 20] do\n//        yield a + b\n//    }\n//\n//    test5 |> Seq.toList |> printfn \"test5: %A\"\n//\n////> ex6 = do\n////>   a <- return 1\n////>   b <- Cont (\\fred -> fred 10 ++ fred 20)\n////>   return $ a+b\n////\n////> test6 = runCont ex6 (\\x -> [x])\n//\n//    let ex6 = contM {\n//        let  a =  1\n//        let! b = (fun fred -> fred  10 @ fred  20 )\n//        //let! c = (fun fred -> fred 400 @ fred 500 )\n//        return a + b //+ c\n//    }\n//\n//    let test6 = ex6 |> run (fun v -> [v])\n//    test6 |> printfn \"test6: %A\"\n//\n////> ex7 = do\n////>   a <- return 1\n////>   b <- Cont (\\fred -> concat [fred 10,fred 20])\n////>   return $ a+b\n////\n////> test7 = runCont ex7 (\\x -> [x])\n//\n//    let ex7 = contM {\n//        let  a =  1\n//        let! b = (fun fred -> List.concat [ fred  10 ; fred  20 ] )\n//        return a + b //+ c\n//    }\n//\n//    let test7 = ex7 |> run (fun v -> [v])\n//    test7 |> printfn \"test7: %A\"\n//\n////> ex8 = do\n////>   a <- return 1\n////>   b <- Cont (\\fred -> [10,20] >>= fred)\n////>   return $ a+b\n////\n////> test8 = runCont ex8 return\n//\n//    let ex8 = contM {\n//        let  a =  1\n//        let! b = (fun fred -> [ 10 ; 20 ] |> List.collect fred )\n//        return a + b //+ c\n//    }\n//\n//    let test8 = ex8 |> run (fun v -> [v])\n//    test8 |> printfn \"test8: %A\"\n//\n////> i x = Cont (\\fred -> x >>= fred)\n////> run m = runCont m return\n//\n//    let i    b x = fun fred -> x |> b fred\n//    let runM r m = run r m\n//\n////> test9 = run $ do\n////>   a <- i [1,2]\n////>   b <- i [10,20]\n////>   return $ a+b\n//\n//    let ex9 = contM {\n//        let! a = i List.collect [  1 ;  2 ; 3 ; 4 ]\n//        let! b = i List.collect [ 10 ; 20 ]\n//        return a + b\n//    }\n//\n//    let test9 = ex9 |> runM List.singleton\n//\n//    test9 |> printfn \"test9: %A\"\n//\n//    let a() = i List.collect [  1 ;  2 ; 3 ; 4 ]\n//    let b() = i List.collect [ 10 ; 20 ]\n//    let ex9b = a() |> bind (fun a ->\n//               b() |> bind (fun b ->\n//                    a + b\n//                    |> rtn \n//               ))\n//    ex9b |> run List.singleton |> printfn \"test9a: %A\"\n//    let ex9c = a() |> map string |> bind (fun a ->\n//               b() |> map string |> bind (fun b ->\n//                    a + b\n//                    |> rtn \n//               ))\n//    ex9c |> run List.singleton |> printfn \"test9a: %A\"\n//\n//    let at() = i Array.collect [|  \"1\" ;  \"2\" ; \"3\" ; \"4\" |]\n//    let bt() = i Array.collect [| \"10\" ; \"20\" |]\n//    let ex10 = at() |> map int |> bind (fun a ->\n//               bt() |> map int |> bind (fun b ->\n//                    a + b\n//                    |> rtn \n//               ))\n//    ex10 |> run Array.singleton |> printfn \"test10: %A\"    \n//\n//    type ListX<'a> = ListX of 'a with\n//        static member (>>=) (a, f) = List.collect f a\n//\n//    //let l    b x = fun fred -> x >>= fred\n//    let runl r m = run r m\n//\n//    let inline add aC bC = contM {\n//        let! a = aC\n//        let! b = bC\n//        return a + b\n//    }\n//\n//    let (>>=) a f = bind f a\n//    let (|>>) a f = map  f a    \n//\n//    add (a () |>> string) (b () |>> string) |> run List .singleton |> print\n//    add (at() |>> int   ) (bt() |>> int   ) |> run Array.singleton |> print\n//\n//    let aO() = i Option.bind <| Some 11\n//    let bO() = i Option.bind <| Some 20\n//    let cO() = i Option.bind <| None\n//\n//    add (aO()           ) (cO()           ) |> run Some |> print\n//    add (aO()           ) (bO()           ) |> run Some |> print\n//    add (aO() |>> string) (bO() |>> string) |> run Some |> print\n//\n//    let tbind f (a, b) = (a |> f |> fst, b |> f |> snd)\n//    let trtn  a        = (a, a)\n//\n//    let aT() = i tbind <| (11, 12)\n//    let bT() = i tbind <| (20, 30)\n//\n//    add (aT()           ) (bT()           ) |> run trtn |> print\n//    add (aT() |>> string) (bT() |>> string) |> run trtn |> print\n//\n//    aT() |> map ((*) 10) |> run trtn |> print\n//\n//    let mapT f m = i tbind m |> map f |> run trtn\n//\n//    (11, 12) |> mapT ((*) 10) |> mapT string |> print\n//\n//\n//module ``EXAMPLE fibo`` =\n//    let rec fibo_k n k =\n//        if n = 0 then\n//            k 1\n//        else if n = 1 then \n//            k 1\n//            else\n//                let k_new1 = (fun x1 -> \n//                    let k_new2 = (fun x2 -> k(x1 + x2))\n//                    fibo_k (n - 2) k_new2\n//                )\n//                fibo_k (n - 1) k_new1\n//\n//    fibo_k 9 string |> printfn \"fibo_k = %A\"\n//\n//module ``EXAMPLE fibo in FSharpPlus`` =\n//    open ContM\n//    let rec fibo_k n =\n//      contM {\n//        if n < 0 then return  Error true else\n//        if n = 0 then return  Ok 1       else \n//        if n = 1 then return  Ok 1       else\n//        let! x1 = fibo_k (n - 1)\n//        let! x2 = fibo_k (n - 2)\n//        return x1 |> Result.bind (fun x1 -> x2 |> Result.map ((+) x1))\n//      }\n//    (fibo_k 9) |> run print |> printfn \"fibo_k2 = %A\"\n\nmodule another =\n    open ContM\n\n    let add  aM bM = contM {\n        let! a = aM\n        let! b = bM\n        //let! c = (fun fred -> fred 400 @ fred 500 )\n        return a + b //+ c\n    }\n\n    let inline ofMonad bind v = (fun cont -> v |> bind cont )\n\n    let exe rtn (cmonF:ContM<_,_>-> ContM<_,_>) mon =\n            cmonF mon\n            |> run rtn\n\n    let add1 v = \n        ofMonad Option.bind (Some 2)\n        |> add v\n\n    let bindLO (f:'a->Option<List<'b>>) (a:Option<List<'a>>) : Option<List<'b>> =\n        a |> Option.map(fun l ->\n            l |> List.choose f |> fun xxx->xxx |> List.collect id\n        )\n\n    Some [ 10 ;  20]\n    |> ofMonad bindLO\n    |> exe     (List.singleton >> Some)  add1\n    |> printfn \"another: %A\"\n\n//    [ 10 ;  20]\n//    |> ofMonad List.collect\n//    |> exe     List.singleton add1\n//    |> printfn \"another: %A\"\n\n    Some 10\n    |> ofMonad Option.bind\n    |> exe     Some add1\n    |> printfn \"another: %A\"\n\n//    10\n//    |> ofMonad (<|)\n//    |> exe     id add1\n//    |> printfn \"another: %A\"\n\n    let inline option2result<'e> o = match o with Some v -> Ok v |_-> Error (Unchecked.defaultof<'e>)\n\n    let bindRLO f a =\n        a |> Option.map(fun l ->\n            l |> List.map (Result.bind (f >> Option.bind List.tryHead >> option2result<_> >> Result.bind id ) ) |> fun xxx->xxx\n        )\n\n    Some [ Ok 10 ;  Error true]\n    |> ofMonad  bindRLO\n    |> exe      (Ok >> List.singleton >> Some) add1\n    |> printfn \"another: %A\"\n\n//    async { return 10 }\n//    |> ofMonad (fun f a  -> async.Bind(a,f))\n//    |> exe      async.Return add1\n//    |> Async.RunSynchronously\n//    |> printfn \"another: %A\"\n\n//    async { return Some 10 }\n//    |> ofMonad  (fun  fRA  vRA -> async { \n//        let! vR       = vRA\n//        match   vR with\n//        | Some    v -> return! fRA v\n//        | None      -> return  None\n//    })\n//    |> exe (Some >> async.Return) add1\n//    |> Async.RunSynchronously\n//    |> printfn \"another: %A\"\n\n", "snpParentIdO": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpPredIds": [{"SnippetId" :"048b8598-8344-4dfa-8cbc-f79c496a1707"}], "snpProperties": [], "snpGeneration": 233}, {"snpId": {"SnippetId" :"25634c24-339e-43e9-95e2-3c9350104c9e"}, "snpName": "F#+", "snpContent": "let inline print v = printfn \"%A\" v\n\n#r @\"../packages/FSharpPlus/lib/net45/FSharpPlus.dll\"\n\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet fn : ResultT<Reader<int,Result<_,string>>> = \n    monad {\n       let! x1 = lift ask\n       if   x1 < 0 then return! ResultT (result (Error \"Negative value\")) \n       let! x2 = result 1\n       return x1 + x2\n    }\n\nlet x = fn |> ResultT.run |> Reader.run <| 10 |> print // Result<int,string> = Ok 11\nlet y = fn |> ResultT.run |> Reader.run <| -1 |> print // Result<int,string> = Error \"Negative value\"    \n\n", "snpParentIdO": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 230}, {"snpId": {"SnippetId" :"fe6f3d71-63e7-401c-9239-17b8aaf60076"}, "snpName": "FsTranslator", "snpContent": "#cd @\"..\\projects\\FsTranslator\\src\"\r\n#nowarn \"1178\"\r\n#nowarn \"1182\"\r\n#nowarn \"40\"\r\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\r\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\r\n#if INTERACTIVE\r\n//#I @\"../WebServer/bin\"\r\nmodule FSSGlobal   =\r\n#else\r\nnamespace FSSGlobal\r\n#endif\r\n\r\n// Code to be evaluated using FSI: `Evaluate F#`\r\n#if WEBSHARPER\r\n#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Core.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.FSharp.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\System.Reflection.Metadata.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\FSharp.Compiler.Service.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Pdb.dll\"\r\n#r @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Mdb.dll\"\r\n#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper\\lib\\net461\"\r\n#I @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\\WebSharper.UI\\lib\\net461\"\r\n  \r\n  open WebSharper\r\n  open WebSharper.JavaScript\r\n  open WebSharper.UI\r\n  open WebSharper.UI.Client\r\n  type on   = WebSharper.UI.Html.on\r\n  type attr = WebSharper.UI.Html.attr\r\n#endif\r\n#if WEBSHARPER\r\n  [<WebSharper.JavaScript>]\r\n#endif\r\n  module Useful =\r\n    let extract n (s:string) = s.Substring(0, min n s.Length)\r\n    \r\n#if WEBSHARPER\r\n    [< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\r\n#endif\r\n    let nowStamp() = \r\n        let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\r\n        t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\r\n    \r\n    module Async =\r\n        let map f va = \r\n            async { \r\n                let! a = va\r\n                return f a \r\n            } \r\n        let iter f va = \r\n            async { \r\n                let! a = va\r\n                do f a \r\n            } \r\n    \r\n        let retn x = async.Return x\r\n    \r\n        let apply fAsync xAsync = async {\r\n            let! fChild = Async.StartChild fAsync\r\n            let! xChild = Async.StartChild xAsync\r\n            let! f = fChild\r\n            let! x = xChild \r\n            return f x \r\n            }\r\n    \r\n        let bind f va = async.Bind(va, f)\r\n        let sleepThen f milliseconds =\r\n            async {\r\n                do! Async.Sleep milliseconds\r\n                do  f()\r\n            }\r\n    \r\n    module KeyVal =\r\n        //let inline getEnumerator dict = (^a : (member get_Enumerator : _) (dict, ()))\r\n        let inline tryGetValue key (dict) =\r\n            dict \r\n            :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \r\n            |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\r\n    \r\n    \r\n    module String =\r\n        let splitByChar (c: char) (s: string) = s.Split c\r\n        let trim                  (s: string) = s.Trim()\r\n        let append     (a: string)(b: string) =  a + b\r\n        \r\n        \r\n    open System\r\n#nowarn \"1178\"\r\n         \r\n    module Option =\r\n        let defaultValue v =\r\n            function\r\n            | Some x -> x\r\n            | None   -> v\r\n    \r\n        let defaultWith f =\r\n            function\r\n            | Some x -> x\r\n            | None   -> f()\r\n    \r\n        let call v = \r\n            function\r\n            | None   -> None\r\n            | Some f -> f v |> Some\r\n    \r\n        let iterF v = \r\n            function\r\n            | None   -> ()\r\n            | Some f -> f v\r\n    \r\n        let iterFO vO fO = \r\n            match vO, fO with\r\n            | Some v, Some f -> f v\r\n            | _     , _      -> ()\r\n    \r\n        let apply vO fO =\r\n            match vO, fO with\r\n            | Some v, Some f -> f v |> Some\r\n            | _     , _      -> None\r\n    \r\n        let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\r\n          \r\n    \r\n#nowarn \"25\"\r\n    type ErrMsg = \r\n        abstract member ErrMsg   : string\r\n        abstract member IsWarning: bool\r\n    \r\n#if WEBSHARPER\r\n    [<JavaScript>]\r\n#endif\r\n    type ExceptionThrown(exn:Exception) =\r\n        interface ErrMsg with\r\n            member this.ErrMsg   : string = sprintf \"%A\" exn\r\n            member this.IsWarning: bool   = false\r\n        override this.ToString() = (this :> ErrMsg).ErrMsg\r\n    \r\n#if WEBSHARPER\r\n    [<JavaScript>]\r\n#endif\r\n    type ErrOptionIsNone() =\r\n        interface ErrMsg with\r\n            member this.ErrMsg   : string = \"Option is None\"\r\n            member this.IsWarning: bool   = false\r\n        override this.ToString() = (this :> ErrMsg).ErrMsg\r\n    \r\n    type ErrSimple(msg, warning) =\r\n        interface ErrMsg with\r\n            member this.ErrMsg   : string = msg\r\n            member this.IsWarning: bool   = warning\r\n        override this.ToString() = (this :> ErrMsg).ErrMsg\r\n    \r\n    type Result< 'TSuccess> = Result  of 'TSuccess option * ErrMsg    []     \r\n    type ResultS<'TSuccess> = ResultS of 'TSuccess option * ErrSimple []\r\n    \r\n    module Result =\r\n        let inline succeed             x       = Result (Some x           , [|  |]             )\r\n        let inline succeedWithMsg      x  m    = Result (Some x           , [|m |]             )\r\n        let inline succeedWithMsgs     x  ms   = Result (Some x           ,   ms               )\r\n        let inline fail                   m    = Result (None             , [|m |]             )\r\n        let inline failWithMsgs           ms   = Result (None             ,   ms               )\r\n        let inline map       f (Result(o, ms)) = Result (o |> Option.map f,   ms               )\r\n        let inline mapErr    f (Result(o, ms)) = Result (o                ,   ms |> Array.map f)\r\n        let inline mapMsg    f (Result(o, ms)) =        (o                ,   ms |> Array.map f)\r\n        let inline mapMsgs   f (Result(o, ms)) =        (o                ,   ms |>           f)\r\n        let inline getOption   (Result(o, _ )) =         o                   \r\n        let inline getMsgs     (Result(_, ms)) =                             ms\r\n        let inline mergeMsgs              ms r = Result (r |> mapMsgs   (Array.append ms) )\r\n        let inline combine     (Result(o, ms)) (rb: unit -> Result<_>) = o |> Option.map (fun _ -> rb() |> mergeMsgs ms) |> Option.defaultValue (Result(None, ms))\r\n        let inline bind      f (Result(o, ms)) = \r\n            match o with\r\n            | Some x   -> match f x with Result(o2, ms2) -> Result(o2, Array.append ms ms2)\r\n            | None     -> Result(None, ms)\r\n        let inline apply (Result(fO, fMs))  (Result(o , ms)) = \r\n            match fO, o with\r\n            | Some f, Some x -> Result(f x |> Some, Array.append fMs ms)\r\n            | _              -> Result(None       , Array.append fMs ms)\r\n            \r\n        let inline failSimpleError   m = (m, false) |> ErrSimple |> fail \r\n        let inline failSimpleWarning m = (m, true ) |> ErrSimple |> fail \r\n    \r\n    \r\n        let (|Success|Failure|) =\r\n            function \r\n            | Result(Some x, ms) -> Success (x, ms) \r\n            | Result(None  , ms) -> Failure     ms  \r\n    \r\n    //    let successTee f result =                           // given an RopResult, call a unit function on the success branch\r\n    //        let fSuccess (x,msgs) =                         // and pass thru the result\r\n    //            f (x,msgs)\r\n    //            Success (x,msgs) \r\n    //        either fSuccess Failure result\r\n    //\r\n    //    let fFailure2 f errs = \r\n    //        f errs\r\n    //        Failure errs \r\n    //    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\r\n    //        either Success (fFailure2 f) result\r\n    //\r\n    //    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\r\n    //        match result with \r\n    //        | Success (x,msgs) -> \r\n    //            let msgs' = List.map f msgs\r\n    //            Success (x, msgs')\r\n    //        | Failure errors -> \r\n    //            let errors' = List.map f errors \r\n    //            Failure errors' \r\n    //\r\n    //    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\r\n    //        match result with                               /// In the failure case, determine the value to return by \r\n    //        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\r\n    //        | Failure errors -> f errors\r\n    //\r\n    //    let failIfNone message = function                   /// lift an option to a RopResult.\r\n    //        | Some x -> succeed x                           /// Return Success if Some\r\n    //        | None -> fail message                          /// or the given message if None\r\n    //\r\n    //    let failIfNoneR message = function                  /// given an RopResult option, return it\r\n    //        | Some rop -> rop                               /// or the given message if None\r\n    //        | None -> fail message \r\n    \r\n        let failException e = ExceptionThrown(e) :> ErrMsg\r\n    \r\n    ///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\r\n        let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\r\n    \r\n        type ropBuilder() =\r\n            member inline this.Return     (x)                       = succeed x\r\n            member inline this.ReturnFrom (x)                       = x\r\n            member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind (tryCall r) w\r\n            member inline this.Zero       ()                        = succeed ()\r\n            member inline this.Delay      (f)                       = f\r\n            member inline this.Combine    (a, b)                    = combine a b\r\n            member inline this.Run        (f)                       = f()\r\n            member this.While(guard, body) =\r\n                if not (guard()) \r\n                then this.Zero() \r\n                else this.Bind( body(), fun () -> \r\n                    this.While(guard, body))  \r\n            member this.TryWith(body, handler) =\r\n                try this.ReturnFrom(body())\r\n                with e -> handler e\r\n            member this.TryFinally(body, compensation) =\r\n                try this.ReturnFrom(body())\r\n                finally compensation()\r\n            member this.Using(disposable:#System.IDisposable, body) =\r\n                let body' = fun () -> body disposable\r\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\r\n            member this.For(sequence:seq<_>, body) =\r\n                this.Using(sequence.GetEnumerator(),fun enum -> \r\n                    this.While(enum.MoveNext, \r\n                        this.Delay(fun () -> body enum.Current)))              \r\n    \r\n        let result = ropBuilder()\r\n    //    let inline flow_ () = new ropBuilder ()\r\n    \r\n    //    let fromChoice context c =  context?????\r\n        let fromChoice c =\r\n            match c with | Choice1Of2 v -> succeed v\r\n                         | Choice2Of2 e -> fail    e\r\n    \r\n        let fromOption m =\r\n            function | None   -> fail    m\r\n                     | Some v -> succeed v\r\n    \r\n        let toOption   (Result(o, _ )) = o\r\n        let toOptionMs (Result(o, ms)) = o, ms\r\n    \r\n        let tryProtection() : Result<unit> = succeed ()\r\n    \r\n        let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \r\n        let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \r\n                \r\n        let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\r\n        let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\r\n    \r\n    //    let processMessages mtype (msgs: PossibleMessages list) =\r\n    //        msgs\r\n    //        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\r\n    //                               WebSharper.JavaScript.Console.Log o)\r\n    //\r\n    //    let notifyMessages R =\r\n    //        match R with | Success (_, m) -> processMessages \"N\" m\r\n    //                     | Failure     m  -> processMessages \"E\" m\r\n    //\r\n    //    let messagesDo f =\r\n    //        function | Success (_, ms) -> f false ms\r\n    //                 | Failure     ms  -> f true  ms\r\n    \r\n        let seqCheck s = \r\n            s \r\n            |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\r\n                             | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\r\n                             | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\r\n            )\r\n    \r\n        let msgs2String   (ms: ErrMsg []) = ms |> Array.map (fun m -> m.ErrMsg)\r\n        let getMessages   (ms: ErrMsg []) = ms |> msgs2String |> String.concat \"\\n\"\r\n        let countMessages (ms: ErrMsg []) =\r\n            if ms = [||] then \"\" else\r\n            let errors   = ms |> Array.filter(fun m -> m.IsWarning |> not)\r\n            let warnings = ms |> Array.filter(fun m -> m.IsWarning       )\r\n            match errors.Length, warnings.Length with\r\n            | 0, 0 -> sprintf \"%s\"\r\n            | 1, 0 -> sprintf \"%s\"\r\n            | 0, 1 -> sprintf \"%s\"\r\n            | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\r\n            | e, 0 -> sprintf \"%d errors\\n%s\" e\r\n            | 0, w -> sprintf \"%d warnings\\n%s\" w\r\n            | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\r\n            <| getMessages ms\r\n    \r\n        let result2String res =\r\n            match res with\r\n            | Result(vO, msgs) -> Array.append [| vO |> Option.defaultValue \"Failed: \" |] (msgs2String msgs)\r\n            |> String.concat \"\\n\"\r\n    \r\n        let fromResultS (ResultS(v, ms)) = Result (v, ms |> Array.map (fun m -> m :> ErrMsg                     ))\r\n        let toResultS   (Result( v, ms)) = ResultS(v, ms |> Array.map (fun m -> ErrSimple(m.ErrMsg, m.IsWarning)))\r\n    \r\n    open Result\r\n    \r\n    module ResultS =\r\n        let fromResult = Result.toResultS\r\n        let toResult   = Result.fromResultS\r\n    \r\n    type Wrap<'T> =\r\n    | WResult of Result<'T>\r\n    | WAsync  of Async<'T>\r\n    | WAsyncR of Async<Result<'T>>\r\n    | WSimple of 'T\r\n    | WOption of 'T option\r\n    \r\n    module Wrap =\r\n        let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\r\n    \r\n        let wb2arb ms = \r\n            function\r\n            | WAsync       ab  -> async { let!   b = ab\r\n                                          return succeedWithMsgs b               ms }\r\n            | WAsyncR     arb  -> async { let!   rb = arb                               \r\n                                          return rb |> mergeMsgs                 ms }\r\n            | WResult      rb  -> async { return rb |> mergeMsgs                 ms }\r\n            | WSimple       b                                                           \r\n            | WOption (Some b) -> async { return succeedWithMsgs b               ms }\r\n            | WOption None     -> async { return failWithMsgs      (Array.append ms [| errOptionIsNone |] )}\r\n    \r\n        let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \r\n            try f a \r\n            with e -> failException e |> fail |> WResult\r\n    \r\n        let bind (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\r\n            match wa with\r\n            | WSimple         a       \r\n            | WOption(Some    a)       \r\n            | WResult(Success(a, [||])) -> tryCall f a\r\n            | WOption None            -> None            |> WOption\r\n            | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \r\n            | WResult(Success(a, ms)) -> tryCall f a\r\n                                         |> function\r\n                                         | WSimple         b              \r\n                                         | WOption(Some    b       ) -> succeedWithMsgs b               ms                   |> WResult \r\n                                         | WOption None              -> failWithMsgs (Array.append ms [| errOptionIsNone |] )|> WResult\r\n                                         | WResult(Success(b, [||])) -> succeedWithMsgs b               ms                   |> WResult \r\n                                         | WResult(Success(b, m2  )) -> succeedWithMsgs b (Array.append ms m2)               |> WResult \r\n                                         | WResult(Failure    m2  )  -> failWithMsgs      (Array.append ms m2)               |> WResult \r\n                                         | WAsync  ab                -> async { let!  b = ab\r\n                                                                                return succeedWithMsgs b ms\r\n                                                                        } |> WAsyncR\r\n                                         | WAsyncR arb               -> async { let! rb = arb\r\n                                                                                return mergeMsgs ms rb\r\n                                                                        } |> WAsyncR\r\n            | WAsync         aa       -> async {\r\n                                             let! a  = aa\r\n                                             return! tryCall f a |> wb2arb [||]\r\n                                         } |> WAsyncR\r\n            | WAsyncR       ara       -> async {\r\n                                             let! ar  = ara\r\n                                             let  arb = match ar with\r\n                                                        | Success(a, ms) -> tryCall f a |> wb2arb ms\r\n                                                        | Failure    ms  -> async { return failWithMsgs ms }\r\n                                             return! arb\r\n                                         } |> WAsyncR\r\n        let Return = WSimple \r\n        let map  (f: 'a -> 'b  ) = bind (f >> Return)     \r\n        let inline getAsyncR (wb: Wrap<'T>) =\r\n            match wb with\r\n            | WAsync      va  -> async {\r\n                                   let! v = va\r\n                                   return      succeed                           v}\r\n            | WSimple     v   -> async.Return (succeed                           v)\r\n            | WOption     v   -> async.Return (Result.fromOption errOptionIsNone v)\r\n            | WResult     v   -> async.Return                                    v\r\n            | WAsyncR     vra -> vra\r\n            \r\n            \r\n        let inline getAsyncWithDefault f w = getAsyncR w |> Async.map (Result.withError f)\r\n        let inline getAsync              w = getAsyncWithDefault (fun ms -> raise (exn(getMessages ms))) w\r\n    \r\n        let toAsync            w = getAsync  w\r\n        let toAsyncResult      w = getAsyncR w\r\n        let toAsyncOption      w = getAsyncR w |> Async.map Result.toOption\r\n        let toAsyncOptionMs    w = getAsyncR w |> Async.map Result.toOptionMs\r\n        let toAsyncWithDefault w = getAsyncWithDefault w\r\n    \r\n    //    let call wb = wb |> getR Rop.notifyMessages\r\n        let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\r\n            w\r\n            |> getAsyncR\r\n            |> fun asy -> Async.StartWithContinuations\r\n                            (asy \r\n                           , Result.mapMsgs Result.getMessages  >> processVal\r\n                           , sprintf \"%O\" >> (fun m -> None, m) >> processVal\r\n                           , sprintf \"%O\" >> (fun m -> None, m) >> processVal)\r\n                           \r\n        let start (printMsg: string->unit) (w: Wrap<unit>) = \r\n            startV (function\r\n                    | Some (), msgs ->               msgs |> printMsg \r\n                    | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\r\n    \r\n        let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\r\n            let wb = tryCall f a\r\n            match wb with\r\n            | WSimple _\r\n            | WOption _               -> wb |> wb2arb [||]\r\n            | WResult (Result(_, ms)) -> wb |> wb2arb ms\r\n            | WAsync  ab              -> async { let!   b = ab\r\n                                                 return succeed b }\r\n            | WAsyncR arb             -> arb\r\n    \r\n        let addMsgs errOptionIsNone ms wb =\r\n            if ms = [||] then wb else\r\n            match wb with\r\n            | WSimple          v       \r\n            | WOption (Some    v)      -> WResult (succeedWithMsgs                        v ms)\r\n            | WOption (None     )      -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\r\n            | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\r\n            | WAsync           va      -> async {\r\n                                            let! v = va\r\n                                            return succeedWithMsgs v ms\r\n                                          } |> WAsyncR\r\n            | WAsyncR          vra     -> async {\r\n                                            let! vr = vra\r\n                                            return vr                    |> Result.mergeMsgs ms\r\n                                          } |> WAsyncR\r\n    \r\n        let combine errOptionIsNone wa (wb: unit -> Wrap<_>) =\r\n            match wa with\r\n            | WSimple             _\r\n            | WOption(       Some _)\r\n            | WResult(Result(Some _,[||]))-> wb()\r\n            | WResult(Result(Some _, ms ))-> wb() |> addMsgs errOptionIsNone ms\r\n            | WAsync           aa         -> async { let!   _a = aa\r\n                                                     let!   br = wb() |> toAsyncResult\r\n                                                     return br\r\n                                                    } |> WAsyncR\r\n            | WAsyncR          ara        -> async { let!  ar = ara\r\n                                                     match ar with\r\n                                                     | Failure    ms -> return Result.failWithMsgs ms\r\n                                                     | Success(_, ms)-> let! br = wb() |> toAsyncResult\r\n                                                                        return br |> Result.mergeMsgs ms\r\n                                                   } |> WAsyncR\r\n            | WOption(       None     )   -> WOption None\r\n            | WResult(Result(None, ms))   -> Result.failWithMsgs ms |> WResult\r\n            \r\n        let rec whileLoop pred body =\r\n            if pred() then body() |> bind (fun () -> whileLoop pred body)\r\n            else WSimple ()\r\n            //while pred() do\r\n            //    body() //|> ignore\r\n            //WSimple ()\r\n    \r\n    \r\n        type Builder() =\r\n    //        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \r\n            member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \r\n            member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \r\n            member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WResult |> bind restOfCExpr \r\n            member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WOption |> bind restOfCExpr \r\n            member inline this.Zero         ( ) = WSimple ()\r\n            member inline this.Return       (x) = WSimple x\r\n            member inline this.ReturnFrom   (w) = w\r\n    //        member inline this.ReturnFrom   (w) = WAsync  w\r\n    //        member inline this.ReturnFrom   (w) = WResult w\r\n    //        member inline this.ReturnFrom   (w) = WOption w        \r\n            member inline this.Delay        (f) = f\r\n            member this.Run(f) = f()\r\n            member        this.Combine   (a, b) = combine errOptionIsNone a b\r\n            member        this.While(guard, body) = whileLoop guard body\r\n            member this.TryWith(body, handler) =\r\n                async {\r\n                    let! r = body() |> toAsyncResult |> Async.Catch \r\n                    return\r\n                        match r with\r\n                        | Choice1Of2 v -> v\r\n                        | Choice2Of2 e -> handler e\r\n                } |> WAsyncR\r\n            member this.TryFinally(body, compensation) =\r\n                async {\r\n                    let! r1 = body() |> toAsyncResult |> Async.Catch \r\n                    let _r2 = compensation()     \r\n                    return\r\n                        match r1 with\r\n                        | Choice1Of2 v -> v\r\n                        | Choice2Of2 e -> raise e\r\n                } |> WAsyncR\r\n            member this.Using(disposable:#System.IDisposable, body) =\r\n                let body' = fun () -> body disposable\r\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\r\n            member this.For(sequence:seq<_>, body) =\r\n                this.Using(sequence.GetEnumerator(),fun enum -> \r\n                    this.While(enum.MoveNext, \r\n                        this.Delay(fun () -> body enum.Current)))            \r\n        let wrap    = Builder()\r\n        let wrapper = Builder()  // deprecated use wrap instead\r\n    \r\n        let getResult callback (wb: Wrap<'T>) =\r\n            match wb with\r\n            | WSimple      s  -> s               |> succeed                                              |> callback\r\n            | WOption(Some s) -> s               |> succeed                                              |> callback\r\n            | WOption None    -> errOptionIsNone |> fail                                                 |> callback\r\n            | WResult      rb -> rb                                                                      |> callback\r\n            | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v                 |> callback), \r\n                                                                   (fun exc -> failException exc |> fail |> callback), \r\n                                                                    fun can -> failException can |> fail |> callback)\r\n            | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \r\n                                                                   (fun exc -> failException exc |> fail |> callback), \r\n                                                                    fun can -> failException can |> fail |> callback)\r\n    \r\n    \r\n#if WEBSHARPER\r\n        [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \r\n#endif\r\n        let runSynchronouslyR (w: Wrap<_>) =\r\n            w\r\n            |> getAsyncR\r\n            |> Async.RunSynchronously\r\n        let runSynchronouslyO count (w: Wrap<_>) =\r\n            w\r\n            |> runSynchronouslyR\r\n            |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\r\n        let runSynchronouslyS count (w: Wrap<_>) =\r\n            w\r\n            |> runSynchronouslyO count\r\n            |> function\r\n               | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\r\n               | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\r\n               \r\n    type Wrap<'T> with\r\n        static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\r\n        static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\r\n#if WEBSHARPER\r\n        [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \r\n#endif\r\n        static member RunSynchronouslyR(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\r\n#if WEBSHARPER\r\n        [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \r\n#endif\r\n        static member RunSynchronously( w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsync  w, ?timeout            = timeout, ?cancellationToken= cancToken)\r\n    \r\n  module UsefulDotNet =\r\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n    open System.Text.RegularExpressions\r\n    \r\n    let (|Regex|_|) pattern input =\r\n        if input = null then None else\r\n        try \r\n            let m = Regex.Match(input, pattern)\r\n            if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\r\n            else None\r\n        with e -> None\r\n    \r\n    let (|Regexs|) pattern input =\r\n        if input = null then [| |] else\r\n        try \r\n            let ms = Regex.Matches(input, pattern)\r\n            [| for m in ms do yield m.Value |] \r\n        with e -> [| |]\r\n    \r\n    open Microsoft.FSharp.Compiler.SourceCodeServices\r\n    open Microsoft.FSharp.Compiler\r\n    open Useful\r\n    \r\n    type FSharpErrors =\r\n        | WarningFSharp                 of string\r\n        | ErrFSharp                     of string\r\n    with interface ErrMsg with\r\n            member this.ErrMsg    = sprintf \"%A\"this\r\n            member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\r\n    \r\n    let getIndentFile input =\r\n        match input with\r\n        | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\r\n        | _                                                 -> 0         , input\r\n       \r\n    let fSharpError2TranspilerError (error : FSharpErrorInfo) =\r\n        let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \r\n        sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \r\n           file \r\n           error.StartLineAlternate (error.StartColumn - indent) \r\n           error.EndLineAlternate   (error.EndColumn   - indent) \r\n           error.Subcategory error.ErrorNumber error.Message\r\n        |> (if   error.Severity = FSharpErrorSeverity.Error  \r\n            then ErrFSharp     \r\n            else WarningFSharp\r\n           )\r\n        :> ErrMsg\r\n        \r\n        \r\n  module FsTranslator =\r\n    \r\n    module Translator =\r\n        open Useful\r\n        open UsefulDotNet\r\n        open System\r\n        open System.IO\r\n        open System.Reflection\r\n        \r\n        module Re = WebSharper.Core.Resources\r\n        module P  = WebSharper.PathConventions\r\n        open WebSharper.Compiler\r\n        open WebSharper.Compiler.FrontEnd\r\n        open WebSharper.Core\r\n        open WebSharper.Core.Resources\r\n        open WebSharper.Compiler.CommandTools\r\n        open Microsoft.FSharp.Compiler.SourceCodeServices\r\n        open Microsoft.FSharp.Compiler\r\n        \r\n        type WebSharperError = AST.SourcePos option * CompilationError\r\n        type TranslatorError =\r\n            | MustProvideAssemblyOutputPath\r\n            | MustProvideProjectPath\r\n            | ErrWebSharper                 of string\r\n            | NothingToTranslateToJavaScript\r\n            | OutputAssemblyNotFound        of string\r\n        with interface ErrMsg with\r\n                member this.ErrMsg =\r\n                    if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\r\n                    sprintf \"%A\"this\r\n                member this.IsWarning = false\r\n        \r\n        let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\r\n            fun                              (posO, error)   ->\r\n                posO \r\n                |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\r\n                |> Option.defaultValue \"\"\r\n                |>  sprintf \"%s%s\" <| error.ToString()\r\n                |> ErrWebSharper\r\n                :> ErrMsg\r\n                \r\n        let PrintGlobalError err = eprintfn \"WebSharper error FS9001: %s\" (ErrorPrinting.NormalizeErrorString err)\r\n                \r\n        module M = WebSharper.Core.Metadata\r\n\r\n        let compile(logger, checker:FSharpChecker, prevMeta : System.Threading.Tasks.Task<option<M.Info>>, argv, config: WsConfig, assemblyName) = \r\n            stdout.WriteLine(\"About to compile, hit enter to continue\")\r\n            stdin.ReadLine() |> ignore\r\n            let path = config.ProjectFile\r\n            \r\n            let projectOptionsOpt =\r\n                try\r\n                    checker.GetProjectOptionsFromCommandLineArgs(path, argv) |> Some\r\n                with e ->\r\n                    None\r\n\r\n            match projectOptionsOpt with\r\n            | None -> None\r\n            | Some projectOptions ->\r\n\r\n            let checkProjectResults = \r\n                projectOptions\r\n                |> checker.ParseAndCheckProject \r\n                |> Async.RunSynchronously\r\n\r\n            TimedStage \"Checking project\"\r\n\r\n            try\r\n                prevMeta.Wait()\r\n                prevMeta.Result\r\n            with :? System.AggregateException as exn ->\r\n                exn.InnerExceptions\r\n                |> Seq.map (sprintf \"%O\")\r\n                |> String.concat \"\\r\\n\"\r\n                |> failwith\r\n            |> function\r\n            | None -> None\r\n            | Some refMeta ->\r\n\r\n            TimedStage \"Waiting on merged metadata\"\r\n\r\n            if checkProjectResults.Errors |> Array.exists (fun e -> e.Severity = FSharpErrorSeverity.Error) then\r\n                if assemblyName = \"WebSharper.Main\" || config.ProjectType = Some BundleOnly then\r\n                    printfn \"%A\" checkProjectResults.Errors\r\n                None\r\n            else\r\n            \r\n            let comp = \r\n                WebSharper.Compiler.FSharp.ProjectReader.transformAssembly\r\n                    (WebSharper.Compiler.Compilation(refMeta, true))\r\n                    assemblyName\r\n                    config\r\n                    checkProjectResults\r\n\r\n            WebSharper.Compiler.Translator.DotNetToJavaScript.CompileFull comp\r\n            \r\n            //if this.UseVerifier then\r\n            //    comp.VerifyRPCs()\r\n                \r\n            TimedStage \"WebSharper translation\"\r\n\r\n            Some comp\r\n            \r\n        let CompileToJsW: WsConfig -> Wrap<string> =\r\n            fun           config   -> Wrap.wrapper {\r\n                do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\r\n                do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\r\n                let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\r\n                let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\r\n                let  fsErrors            = errors |> Array.map fSharpError2TranspilerError \r\n                do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\r\n                do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\r\n                let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\r\n                do   System.IO.File.Delete config.AssemblyFile\r\n                let  paths               = [   for r in config.References -> \r\n                                                   Path.GetFullPath r\r\n                                               yield Path.GetFullPath config.AssemblyFile\r\n                                           ]        \r\n                let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\r\n                let  loader              = Loader.Create aR (printfn \"%s\")\r\n                let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\r\n                let wsRefsMeta =\r\n                    System.Threading.Tasks.Task.Run(fun () ->\r\n                        let mutable refError = false\r\n                        let wsRefs, metas = \r\n                            refs |> List.choose (fun r -> \r\n                                match TryReadFromAssembly FullMetadata r with\r\n                                | None -> None\r\n                                | Some (Ok m) -> Some (r, m)\r\n                                | Some (Error e) ->\r\n                                    refError <- true\r\n                                    PrintGlobalError e\r\n                                    None\r\n                            ) |> List.unzip\r\n                        if refError then None\r\n                        elif List.isEmpty metas then Some ([], [], WebSharper.Core.Metadata.Info.Empty) \r\n                        else\r\n                            try\r\n                                Some (\r\n                                    wsRefs, metas,\r\n                                    { \r\n                                        WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\r\n                                            Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\r\n                                    }\r\n                                )\r\n                            with e ->\r\n                                refError <- true\r\n                                PrintGlobalError (\"Error merging WebSharper metadata: \" + e.Message)\r\n                                None\r\n                    )\r\n                let refMeta = wsRefsMeta.ContinueWith(fun (t: System.Threading.Tasks.Task<_>) -> \r\n                                match t.Result with \r\n                                | Some (_, _, m) -> Some m \r\n                                | _ -> None )\r\n                let  referencedAsmNames     = paths\r\n                                              |> Seq.map (fun i -> \r\n                                                  let n = Path.GetFileNameWithoutExtension(i)\r\n                                                  n, i\r\n                                              ) |> Map.ofSeq\r\n                let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\r\n                let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\r\n                        //printfn \"assemblyResolveHandler %s\" e.Name\r\n                        let assemblyName    = AssemblyName(e.Name).Name\r\n                        match Map.tryFind assemblyName referencedAsmNames with\r\n                        | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\r\n                        | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\r\n                        | Some p                                   -> Assembly.LoadFrom(p)\r\n                        | _                                        -> null\r\n                    )\r\n                System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\r\n                let! comp        = compile(printfn \"%s\", fsharpChecker, refMeta, config.CompilerArgs, config, config.ProjectFile) \r\n                let  wsErrors    = comp.Errors |> Seq.map webSharperError2TranspilerError |> Seq.toArray\r\n                do! if wsErrors |> Seq.isEmpty then Result.succeed () else\r\n                    Result.failWithMsgs wsErrors\r\n                let  assem       = loader.LoadRaw assemblyBytes None\r\n                let  getRefMeta()= match wsRefsMeta.Result with | Some (_, _, m) -> m | _ -> WebSharper.Core.Metadata.Info.Empty\r\n                let jsO, currentMeta, sources = ModifyAssembly (Some comp) \r\n                                                  (getRefMeta()) \r\n                                                  (comp.ToCurrentMetadata(config.WarnOnly)) \r\n                                                  config.SourceMap config.AnalyzeClosures assem\r\n                let! js, jsMin   = jsO |> Result.fromOption NothingToTranslateToJavaScript\r\n                let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\r\n                use  stringW     = new System.IO.StringWriter()\r\n                use  writer      = new HtmlTextWriter(stringW)\r\n                let  pu          = P.PathUtility.VirtualPaths(\"/\")\r\n                let ctx : Resources.Context =\r\n                    {\r\n                        WebRoot                 = \"\"\r\n                        DebuggingEnabled        = true\r\n                        DefaultToHttp           = false\r\n                        GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\r\n    \r\n                        GetAssemblyRendering    = fun name ->\r\n                            //printfn \"GetAssemblyRendering %s\" name\r\n                            if name = thisProject || name = config.ProjectFile\r\n                            then WebSharper.Core.Resources.Rendering.Skip else\r\n                            name\r\n                            |> P.AssemblyId.Create\r\n                            |> pu.JavaScriptPath \r\n                            |> Re.RenderLink\r\n                        GetWebResourceRendering = fun ty resource ->\r\n                            //printfn \"GetWebResourceRendering %A\" ty\r\n                            let id = P.AssemblyId.Create(ty)\r\n                            let kind =\r\n                                if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\r\n                                    then P.ResourceKind.Script\r\n                                    else P.ResourceKind.Content\r\n                            P.EmbeddedResource.Create(kind, id, resource)\r\n                            |> pu.EmbeddedPath\r\n                            |> Re.RenderLink\r\n                        RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\r\n                        ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\r\n                        ScriptBaseUrl = None\r\n                    }            \r\n                comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\r\n                //js.RenderDependencies(ctx, writer)\r\n                let  includes = stringW.ToString()\r\n                let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\r\n                                |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\r\n                                |> String.concat \", \"\r\n                let! f        = Result.succeedWithMsgs js.[1..js.Length - 7] (comp.Warnings |> Seq.map (fun v -> (sprintf \"%A\" v, true) |> ErrSimple :> ErrMsg) |> Seq.toArray)\r\n                return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\r\n            }\r\n        \r\n        let compileMainW: string[] -> Wrap<string> =\r\n          fun             argv     ->\r\n            let resSplit (r:string) = \r\n                match r.Split(',') with \r\n                | [| res           |] -> (res, None         )\r\n                | [| res; fullName |] -> (res, Some fullName)\r\n                | _ -> argError (\"Unexpected value --resource:\" + r)\r\n            let wsArgs    = ref WsConfig.Empty\r\n            let refs      = ResizeArray()\r\n            let resources = ResizeArray()\r\n            let fscArgs   = ResizeArray()\r\n            let cArgv     =\r\n                [|\r\n                    let isRNext = ref false\r\n                    for a in argv do\r\n                        match a with\r\n                        | \"-r\" ->\r\n                            isRNext := true\r\n                        | _ ->\r\n                            if !isRNext then\r\n                                isRNext := false   \r\n                                yield \"-r:\" + a\r\n                            else\r\n                                yield a\r\n                |]\r\n            for a in cArgv do\r\n                let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\r\n                try\r\n                    match a with\r\n                    | \"--wig\"                          -> setProjectType WIG\r\n                    | \"--bundle\"                       -> setProjectType Bundle\r\n                    | \"--html\"                         -> setProjectType Html\r\n                    | \"--site\"                         -> setProjectType Website\r\n                    | StartsWith \"--ws:\" wsProjectType ->\r\n                        match wsProjectType.ToLower() with\r\n                        | \"site\" \r\n                        | \"web\" \r\n                        | \"website\" \r\n                        | \"export\"                     -> setProjectType Website\r\n                        | \"extension\"                  \r\n                        | \"interfacegenerator\"         -> setProjectType WIG\r\n                        | \"bundle\"                     -> setProjectType Bundle\r\n                        | \"html\"                       -> setProjectType Html\r\n                        | \"ignore\"                     -> ()\r\n                        | \"library\"                    -> ()\r\n                        | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\r\n                    | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\r\n                    | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\r\n                    | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\r\n                    | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \r\n                    | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \r\n                    | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \r\n                    | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\r\n                    | \"--debug\"                      \r\n                    | \"--debug+\"                     \r\n                    | \"--debug:full\"                 \r\n                    | \"-g\"                           \r\n                    | \"-g+\"                          \r\n                    | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\r\n                    | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\r\n                    | StartsWith \"-o:\"               o \r\n                    | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\r\n                    | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\r\n                    | StartsWith \"-r:\"               r             \r\n                    | StartsWith \"--reference:\"      r -> refs.Add      (Path.GetFullPath r)                ; fscArgs.Add a\r\n                    | StartsWith \"--resource:\"       r -> resources.Add (resSplit         r)                ; fscArgs.Add a\r\n                    | _                                ->                                                     fscArgs.Add a  \r\n                with e ->\r\n                    failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\r\n            fscArgs.Add \"--define:FSHARP41\"\r\n            wsArgs := \r\n                { !wsArgs with \r\n                    References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\r\n                    Resources    = resources.ToArray()\r\n                    CompilerArgs = fscArgs  .ToArray() \r\n                }\r\n            CompileToJsW !wsArgs\r\n    \r\n        let Process args =  \r\n            compileMainW args \r\n            |> Wrap.runSynchronouslyR\r\n            |> fun (Result(jsO, msgs)) -> \r\n                   jsO |> Option.iter (printfn \"%s\")\r\n                   if msgs |> Seq.isEmpty |> not then Result.getMessages msgs |> eprintfn \"%O\"\r\n                   match jsO with\r\n                   | Some js -> 0\r\n                   | None    -> 1\r\n                   \r\n        let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\r\n    \r\n        [< EntryPoint >]\r\n        let Main args =\r\n            Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\r\n            let mutable cycle = true\r\n            if args = [| \"++loop\" |] \r\n            then while cycle do\r\n                   let line = Console.ReadLine()\r\n                   if line = null ||  line = \"++end\" then cycle <- false else\r\n                   let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\r\n                   if Process argsL = 0 then \"success\" else \"fail\"\r\n                   |> printfn \"//%s\"\r\n                   eprintfn \"%s\" endToken\r\n                 0\r\n            else Process args \r\n#", "snpParentIdO": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"fb6a6513-3241-4387-aa2d-0d8ec71a2db9"}, "snpName": "compile FsTranslator", "snpContent": "#cd @\"..\\projects\\FsTranslator\\src\"\r\n#define COMPILEFSTranslator18\r\n#define FIX_GENERIC\r\nmodule RunFSharpStation =\r\n    open FsRoot\r\n    module ReaderM = ReaderMAsyncResultM\r\n    open ReaderM.Operators\r\n    \r\n    open System.IO\r\n    open RunProcess\r\n    open FsCompiler\r\n    open FsCode\r\n    open CommArgCollection\r\n    \r\n    let wsCompileSnippet snpName = \r\n        asyncResultM {\r\n            let! code            = FSharpStationClient.getCode snpName |> AsyncResult.freeMessage\r\n            let  defines0        = (FsCode.extractDefines <| FsCode code).Split([| \" \" ; \"-d:\" |], System.StringSplitOptions.RemoveEmptyEntries) \r\n            let  fs, assembs0, defines1, prepIs, nowarns, cdO = separatePrepros (String.splitByChar '\\n' code) |> separateDirectives\r\n            let  fsCore          = @\"..\\packages\\fsharp.core\\lib\\net45\\FSharp.Core.dll\"\r\n            let  assembs         = Array.append assembs0 [| fsCore |]\r\n            let  defines         = Array.append defines0 defines1\r\n            let  args            = [ intShowArgs   /= true\r\n                                     intCreateDir  /= true\r\n                                     fscGenFSharp2 /= \"noframework\"\r\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\r\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\r\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\r\n                                     fscReference  /= @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\r\n                                     fscReference  /= fsCore\r\n                                   ]\r\n            let  args1           = compileOptionsExeDebug snpName\r\n                                 + siteOptions()\r\n                                 + args\r\n            let  args2           = prepOptions args1 (assembs, defines, prepIs)\r\n            return! reader {\r\n                do!                processArgs fs assembs nowarns\r\n                do!                compileRm() \r\n            } |> ReaderM.run args2\r\n        } |> AsyncResultM.iterpS id\r\n\r\n    wsCompileSnippet \"FSI Zone/FsTranslator\"\r\n\r\n", "snpParentIdO": {"SnippetId" :"45229ca6-7613-467c-b747-938f9d0d1b45"}, "snpPredIds": [{"SnippetId" :"35f1037c-2785-4017-be73-538eae4d1228"}, {"SnippetId" :"a1a3625f-748c-4e87-aaa2-fbe07392235d"}, {"SnippetId" :"f17f2e46-aaa8-4974-9c42-f3c9db07faad"}], "snpProperties": [], "snpGeneration": 225}, {"snpId": {"SnippetId" :"bc1521b8-a408-454d-9857-de5d145cfd77"}, "snpName": "Old Stuff", "snpContent": "", "snpParentIdO": null, "snpPredIds": [], "snpProperties": [["IndentChildren", "0 |-| 4"]], "snpGeneration": 216}, {"snpId": {"SnippetId" :"bf864f3c-1370-42f2-ac8a-565a604892e8"}, "snpName": "FSSGlobal", "snpContent": "//#nowarn \"1182\"\n//#nowarn \"40\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n//#r @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\FSharp.Core.dll\"\n#if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSSGlobal   =\n#else\nnamespace FSSGlobal\n#endif\n", "snpParentIdO": {"SnippetId" :"bc1521b8-a408-454d-9857-de5d145cfd77"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 45}, {"snpId": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpName": "F# Code", "snpContent": "// Code to be evaluated using FSI: `Evaluate F#`", "snpParentIdO": {"SnippetId" :"bf864f3c-1370-42f2-ac8a-565a604892e8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, "snpName": "open WebSharper", "snpContent": "#if WEBSHARPER\n#I @\"..\\packages\\WebSharper\\lib\\net461\"\n#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\ntype on   = WebSharper.UI.Html.on\ntype attr = WebSharper.UI.Html.attr\n#else\n\nmodule WebSharper =\n    type RpcAttribute() =\n        let a = 1\n    type JavaScriptAttribute(translate:bool) =\n        let a = 1\n        new() = JavaScriptAttribute true\n    type InlineAttribute(code:string) =\n        let a = 1\n        new() = InlineAttribute \"\"\n    type DirectAttribute(code:string) =\n        let a = 1\n\nopen WebSharper\n\n#endif", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpName": "Useful", "snpContent": "[<JavaScript>]\nmodule Useful =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}, "snpName": "module String", "snpContent": "module String =\n    let splitByChar (c: char) (s: string) = s.Split c\n    let trim                  (s: string) = s.Trim()\n    let append     (a: string)(b: string) =  a + b\n    let skipFirstLine (txt:string) = txt.IndexOf '\\n' |> fun i -> if i < 0 then \"\" else txt.[i + 1..]\n    let unindent (s:string) =\n        let lines = s.Split '\\n'\n        let n     = lines \n                    |> Seq.tryFind (fun l -> l.Trim() <> \"\")\n                    |> Option.defaultValue \"\"\n                    |> Seq.tryFindIndex ((<>) ' ') \n                    |> Option.defaultValue 0\n        lines \n        |> Seq.map    (fun l -> if l.Length <= n then \"\" else l.Substring n)\n        |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n    let indent n (s:string) =\n        s.Split '\\n'\n        |> Seq.map ((+) (String.replicate n \" \"))\n    let unindentStr = unindent >> String.concat \"\\n\"\n    let indentStr i = indent i >> String.concat \"\\n\" \n    \ntype System.String with\n    member s.Substring2(from, n) = \n        if   n    <= 0        then \"\"\n        elif from <  0        then s.Substring2(0, n + from)\n        elif from >= s.Length then \"\"\n        else s.Substring(from, min n (s.Length - from))\n    member s.Left             n  = s.Substring2(0, n)\n    member s.Right            n  = s.Substring2(max 0 (s.Length - n), s.Length)\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}, "snpName": "extract, now, Async, Log, Hole", "snpContent": "let extract n (s:string) = s.Substring(0, min n s.Length)\n\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\nlet nowStamp() = \n    let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n    t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } \n    let iter f va = \n        async { \n            let! a = va\n            do f a \n        } \n\n    let retn x = async.Return x\n\n    let apply fAsync xAsync = async {\n        let! fChild = Async.StartChild fAsync\n        let! xChild = Async.StartChild xAsync\n        let! f = fChild\n        let! x = xChild \n        return f x \n        }\n\n    let bind f va = async.Bind(va, f)\n    let sleepThen f milliseconds =\n        async {\n            do! Async.Sleep milliseconds\n            do  f()\n        }\n\nmodule KeyVal =\n    //let inline getEnumerator dict = (^a : (member get_Enumerator : _) (dict, ()))\n    let inline tryGetValue key (dict) =\n        dict \n        :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n        |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n\nlet [<Inline>] inline tee f v = f v ; v\n\nlet [<Inline>] inline traceT t v = tee (printfn \"%s %s: %A\" (nowStamp()) t) v\nlet [<Inline>] inline trace   v = traceT \"trace\" v\nlet [<Inline>] inline traceI  v = trace          v |> ignore\n\nmodule Log =\n    let [<Inline>] inline In     n f   =      (traceT (sprintf \"%s in \" n)) >> f\n    let [<Inline>] inline Out    n f   = f >> (traceT (sprintf \"%s out\" n))\n    let [<Inline>] inline InA    n f p = async { return! In  n f p }\n    let [<Inline>] inline OutA   n f p = async { return! Out n f p }\n    let [<Inline>] inline InOut  n     = In  n >> Out  n\n    let [<Inline>] inline InOutA n f p = async {\n        let!   r = InA n f  p\n        do         Out n id r |> ignore\n        return r \n      }\n\n/// Adapted from here http://fssnip.net/7V5   Usage:\n/// let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n///         \n/// abs  1 |> printfn \"%A\" // 1\n/// abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\ntype Hole = Hole with\n    [< Inline ; CompilerMessage(\"Incomplete hole\", 130) >]\n    static member inline (?) (Hole, id) : 'T = \n        sprintf \"Incomplete hole '%s'\" id\n#if WEBSHARPER        \n        |> exn\n#else\n        |> System.NotImplementedException\n#endif\n        |> raise\n        \n//let abs n = if n >= 0 then n else Hole ? TODO_AbsForNegativeValue    \n//        \n//abs  1 |> printfn \"%A\" // 1\n//abs -1 |> printfn \"%A\" // System.NotImplementedException: Incomplete hole 'TODO_AbsForNegativeValue : System.Int32'\n// \n        ", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, "snpName": "swap", "snpContent": "let [<Inline>] inline swap f a b = f b a\nlet [<Inline>] inline __   f a b = f b a\n\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, "snpName": "Result, Wrap", "snpContent": "open System\n#nowarn \"1178\"\n     \nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\n    let defaultWith f =\n        function\n        | Some x -> x\n        | None   -> f()\n\n    let call v = \n        function\n        | None   -> None\n        | Some f -> f v |> Some\n\n    let iterF v = \n        function\n        | None   -> ()\n        | Some f -> f v\n\n    let iterFO vO fO = \n        match vO, fO with\n        | Some v, Some f -> f v\n        | _     , _      -> ()\n\n    let apply fO  vO =\n        match fO, vO with\n        | Some f, Some v -> f v |> Some\n        | _     , _      -> None\n\n    let join vOO =\n        match vOO with\n        | Some vO -> vO\n        | _       -> None\n\n    let modify modifier = Option.map (fun f -> modifier f) >> defaultValue id\n      \n\n//#nowarn \"25\"\ntype ErrMsg = \n    abstract member ErrMsg   : string\n    abstract member IsWarning: bool\n\ntype ExceptionThrown(exn:Exception) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" exn\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\ntype ErrOptionIsNone() =\n    interface ErrMsg with\n        member this.ErrMsg   : string = \"Option is None\"\n        member this.IsWarning: bool   = false\n    override this.ToString() = (this :> ErrMsg).ErrMsg\n\ntype ErrSimple(msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg\n        member this.IsWarning: bool   = warning\n    override this.ToString() = (this :> ErrMsg).ErrMsg\nlet errSimple msg = ErrSimple(msg, false)\n\ntype Result< 'TSuccess> = Result  of 'TSuccess option * ErrMsg    []     \ntype ResultS<'TSuccess> = ResultS of 'TSuccess option * ErrSimple []\n\nmodule Result =\n    let inline succeed             x       = Result (Some x           , [|  |]             )\n    let inline succeedWithMsg      x  m    = Result (Some x           , [|m |]             )\n    let inline succeedWithMsgs     x  ms   = Result (Some x           ,   ms               )\n    let inline fail                   m    = Result (None             , [|m |]             )\n    let inline failWithMsgs           ms   = Result (None             ,   ms               )\n    let inline failException          e    = ExceptionThrown(e) :> ErrMsg\n    /// map without try protection\n    let inline map0      f (Result(o, ms)) =       Result(o |> Option.map f, ms)\n    /// map with try protection in case of exceptions\n    let inline map       f (Result(o, ms)) = try   Result(o |> Option.map f, ms)\n                                             with  e -> failException e |> fail\n    let inline mapErr    f (Result(o, ms)) = Result (o                ,   ms |> Array.map f)\n    let inline mapMsg    f (Result(o, ms)) =        (o                ,   ms |> Array.map f)\n    let inline mapMsgs   f (Result(o, ms)) =        (o                ,   ms |>           f)\n    let inline getOption   (Result(o, _ )) =         o                   \n    let inline getMsgs     (Result(_, ms)) =                             ms\n    let inline mergeMsgs              ms r = Result (r |> mapMsgs   (Array.append ms) )\n    let inline combine     (Result(o, ms)) (rb: unit -> Result<_>) = o |> Option.map (fun _ -> rb() |> mergeMsgs ms) |> Option.defaultValue (Result(None, ms))\n    let inline join arr                    =\n        match arr with\n        | Result(None                , ms ) -> Result(None, ms                  ) \n        | Result(Some(Result(b, ms1)), ms2) -> Result(b   , Array.append ms2 ms1) \n    /// bind with no try protection\n    let inline bind0     f  ar             = map0 f ar |> join \n    /// bind with try protection in case of exceptions\n    let inline bind      f  ar             = map  f ar |> join\n    let inline applyMap mapF (Result(fO, fMs)) aR =\n        match fO with\n        | None   -> aR |> getMsgs |> Array.append fMs |> failWithMsgs\n        | Some f -> aR |> mapF f\n    /// apply with try protection in case of exceptions\n    let inline apply0    fr ar = applyMap map0 fr ar\n    /// apply with try protection in case of exceptions\n    let inline apply     fr ar = applyMap map  fr ar\n    let map2 f a1 a2 = apply <| apply (succeed f) a1 <| a2\n        \n    let inline failSimpleError   m = (m, false) |> ErrSimple |> fail \n    let inline failSimpleWarning m = (m, true ) |> ErrSimple |> fail \n    let inline isError (Result (v, _)) = v.IsNone\n    let inline isGood  (Result (v, _)) = v.IsSome\n\n    let (|Success|Failure|) =\n        function \n        | Result(Some x, ms) -> Success (x, ms) \n        | Result(None  , ms) -> Failure     ms  \n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n    let inline tryCall (f:'a -> Result<'b>) (v:'a) : Result<'b> = try f v with e -> failException e |> fail\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w:Result<'a>, r: 'a -> Result<'b>) = bind r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = succeed () |> bind f // to ensure Try protection\n        member this.While(guard, body) =\n            if not (guard()) \n            then this.Zero() \n            else this.Bind( body(), fun () -> \n                this.While(guard, body))  \n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    let result = ropBuilder()\n//    let inline flow_ () = new ropBuilder ()\n\n//    let fromChoice context c =  context?????\n    let fromResult c =\n        match c with | Result.Ok    v -> succeed  v\n                     | Result.Error e -> fail    (ErrSimple(e, false))\n\n    let fromChoice c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n    let fromOptionW m =\n        function | None   -> fail    (m())\n                 | Some v -> succeed v\n                 \n    type RResult<'V,'E> = Result<'V,'E>\n    let inline toResult fv fe r =\n        match r with | Result(Some v, ms) -> RResult<_,_>.Ok    (fv (v, ms))\n                     | Result(None  , ms) -> RResult<_,_>.Error (fe     ms )\n\n    let inline toResultStr r = toResult fst (Seq.map (fun e -> e.ToString()) >> String.concat \"\\n\") r \n\n    let toOption   (Result(o, _ )) = o\n    let toOptionMs (Result(o, ms)) = o, ms\n\n    let tryProtection() : Result<unit> = succeed ()\n\n    let failIfFalse m v : Result<unit>  = if v then succeed () else m |> fail \n    let failIfTrue  m v : Result<unit>  = if v then m |> fail  else succeed () \n            \n    let ifError   def (Result(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (Result(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n//    let seqCheck s = \n//        s \n//        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n//                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n//                         | false -> elems |> Seq.map   (function | Result (vO,_)-> vO.Value            ) |> succeed\n//        )\n\n    let msgs2String   (ms: ErrMsg []) = ms |> Array.map (fun m -> m.ErrMsg)\n    let getMessages   (ms: ErrMsg []) = ms |> msgs2String |> String.concat \"\\n\"\n    let countMessages (ms: ErrMsg []) =\n        if ms = [||] then \"\" else\n        let errors   = ms |> Array.filter(fun m -> m.IsWarning |> not)\n        let warnings = ms |> Array.filter(fun m -> m.IsWarning       )\n        match errors.Length, warnings.Length with\n        | 0, 0 -> sprintf \"%s\"\n        | 1, 0 -> sprintf \"%s\"\n        | 0, 1 -> sprintf \"%s\"\n        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n        | e, 0 -> sprintf \"%d errors\\n%s\" e\n        | 0, w -> sprintf \"%d warnings\\n%s\" w\n        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n        <| getMessages ms\n\n    let result2String res =\n        match res with\n        | Result(vO, msgs) -> Array.append [| vO |> Option.defaultValue \"Failed: \" |] (msgs2String msgs)\n        |> String.concat \"\\n\"\n\n    let fromResultS (ResultS(v, ms)) = Result (v, ms |> Array.map (fun m -> m :> ErrMsg                     ))\n    let toResultS   (Result( v, ms)) = ResultS(v, ms |> Array.map (fun m -> ErrSimple(m.ErrMsg, m.IsWarning)))\n\n    module Seq =\n        let cons h t = Seq.append t (Seq.singleton h) \n        /// Map a Result producing function over a sequence to get a new Result\n        /// using monadic style\n        /// ('a -> XResult<'b>) -> 'a list -> XResult<'b list>\n        let rec traverseM f sequ =\n            let (>>=) v f = bind f v\n            let retn      = succeed\n            let initState = retn (seq[])\n            let folder tail head = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            Seq.fold folder initState sequ  \n        /// Transform a \"Seq<Result>\" into a \"Result<Seq>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map a Result producing function over a sequence to get a new Result \n        /// using applicative style\n        /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n        let rec traverseA f sequ =\n            let (<*>)     = apply\n            let retn      = succeed\n            let initState = retn (Seq.empty)\n            let folder tail head = retn cons <*> f head <*> tail\n            Seq.fold folder initState sequ\n        /// Transform a \"Seq<Result>\" into a \"Result<Seq>\" \n        /// and collect the results using apply.\n        let inline sequenceA x = traverseA id x\n\nmodule ResultS =\n    let fromResult = Result.toResultS\n    let toResult   = Result.fromResultS\n\ntype Wrap<'T> =\n| WResult of Result<'T>\n| WAsync  of Async<'T>\n| WAsyncR of Async<Result<'T>>\n| WSome   of 'T\n| WNone\n\nmodule Wrap =\n    open Result\n    let errOptionIsNone = ErrOptionIsNone() :> ErrMsg\n\n    let wb2arb ms = \n        function\n        | WAsync       ab  -> async { let!   b = ab\n                                      return succeedWithMsgs b               ms }\n        | WAsyncR     arb  -> async { let!   rb = arb                               \n                                      return rb |> mergeMsgs                 ms }\n        | WResult      rb  -> async { return rb |> mergeMsgs                 ms }\n        | WSome         b  -> async { return succeedWithMsgs b               ms }\n        | WNone            -> async { return failWithMsgs      (Array.append ms [| errOptionIsNone |] )}\n\n    let tryCall (f: 'a -> Wrap<'b>) (a:'a) = \n        try f a \n        with e -> failException e |> fail |> WResult\n\n    /// bind with old implementation\n    let bind0' (f: 'a -> Wrap<'b>) (wa: Wrap<'a>) :Wrap<'b> =\n        match wa with\n        | WSome           a       \n        | WResult(Success(a, [||])) -> tryCall f a\n        | WNone                     -> WNone\n        | WResult(Failure    ms ) -> failWithMsgs ms |> WResult \n        | WResult(Success(a, ms)) -> tryCall f a\n                                     |> function\n                                     | WSome           b         -> succeedWithMsgs b               ms                   |> WResult \n                                     | WNone                     -> failWithMsgs (Array.append ms [| errOptionIsNone |] )|> WResult\n                                     | WResult(Success(b, [||])) -> succeedWithMsgs b               ms                   |> WResult \n                                     | WResult(Success(b, m2  )) -> succeedWithMsgs b (Array.append ms m2)               |> WResult \n                                     | WResult(Failure    m2  )  -> failWithMsgs      (Array.append ms m2)               |> WResult \n                                     | WAsync  ab                -> async { let!  b = ab\n                                                                            return succeedWithMsgs b ms\n                                                                    } |> WAsyncR\n                                     | WAsyncR arb               -> async { let! rb = arb\n                                                                            return mergeMsgs ms rb\n                                                                    } |> WAsyncR\n        | WAsync         aa       -> async {\n                                         let! a  = aa\n                                         return! tryCall f a |> wb2arb [||]\n                                     } |> WAsyncR\n        | WAsyncR       ara       -> async {\n                                         let! ar  = ara\n                                         let  arb = match ar with\n                                                    | Success(a, ms) -> tryCall f a |> wb2arb ms\n                                                    | Failure    ms  -> async { return failWithMsgs ms }\n                                         return! arb\n                                     } |> WAsyncR\n    let Return v = v |> WSome\n    /// map with no try protection\n    let map0 (f: 'a -> 'b) (aw: Wrap<'a>) = \n        match aw with\n        | WNone       -> WNone\n        | WSome   a   -> f a                                               |> WSome\n        | WResult ar  -> Result.map f ar                                   |> WResult\n        | WAsync  aa  -> async {\n                             let!   a  = aa\n                             return f a\n                         }                                                 |> WAsync\n        | WAsyncR ara -> async {\n                             let!   ar  = ara\n                             return Result.map  f ar\n                         }                                                 |> WAsyncR\n    /// map with try protection in case of exceptions\n    let map  (f: 'a -> 'b) (aw: Wrap<'a>) = \n        match aw with\n        | WNone       -> WNone\n        | WSome   a   -> try  f a                                          |> WSome\n                         with e -> failException e            |> fail      |> WResult\n        | WResult ar  -> Result.map f ar                                   |> WResult\n        | WAsync  aa  -> async {\n                             let!   a  = aa\n                             return try  f a                  |> succeed\n                                    with e -> failException e |> fail\n                         }                                                 |> WAsyncR\n        | WAsyncR ara -> async {\n                             let!   ar  = ara\n                             return Result.map  f ar\n                         }                                                 |> WAsyncR\n    let join aww =\n        match aww with\n        | WSome   aw                   -> aw\n        | WNone                        -> WNone\n        | WResult(Result(None   , ms)) -> WResult(Result(None, ms))\n        | WResult(Result(Some aw, ms)) -> aw\n        | WAsync  awa                  -> async {\n                                              let!  aw = awa\n                                              match aw with\n                                              | WNone       -> return            Result.fail errOptionIsNone\n                                              | WSome   a   -> return a       |> Result.succeed\n                                              | WResult ar  -> return ar\n                                              | WAsync  aa  -> let!   a  = aa\n                                                               return a       |> Result.succeed\n                                              | WAsyncR ara -> let!   ar = ara\n                                                               return ar\n                                          } |> WAsyncR\n        | WAsyncR awra                 -> async {\n                                              let!  awr = awra\n                                              match awr with\n                                              | Result(None   , ms) -> return Result.failWithMsgs ms\n                                              | Result(Some aw, ms) ->\n                                              match aw with\n                                              | WNone               -> return             Result.failWithMsgs    <| Array.append ms [| errOptionIsNone |]\n                                              | WSome   a           -> return a        |> Result.succeedWithMsgs <| ms\n                                              | WResult ar          -> return ar       |> Result.mergeMsgs ms\n                                              | WAsync  aa          -> let!   a  = aa \n                                                                       return a        |> Result.succeedWithMsgs <| ms\n                                              | WAsyncR ara         -> let!   ar = ara \n                                                                       return ar       |> Result.mergeMsgs ms\n                                          } |> WAsyncR\n    /// bind with no try protection \n    let bind0 (f: 'a -> Wrap<'b>) (aw: Wrap<'a>) :Wrap<'b> = aw |> map0 f |> join\n    /// bind with try protection in case of exceptions\n    let bind  (f: 'a -> Wrap<'b>) (aw: Wrap<'a>) :Wrap<'b> = aw |> map  f |> join\n    /// apply with no try protection\n    let apply0 (fw: Wrap<'a -> 'b>) (aw: Wrap<'a>) = fw |> bind0 (swap map0 aw)\n    /// apply with try protection in case of exceptions\n    let apply  (fw: Wrap<'a -> 'b>) (aw: Wrap<'a>) = fw |> bind  (swap map  aw)\n\n    let inline getAsyncR (wb: Wrap<'T>) =\n        match wb with\n        | WAsync      va  -> async {\n                               let! v = va\n                               return      succeed                           v}\n        | WSome       v   -> async.Return (succeed                           v)\n        | WNone           -> async.Return (Result.fail       errOptionIsNone  )\n        | WResult     v   -> async.Return                                    v\n        | WAsyncR     vra -> vra\n        \n    let inline getResultW  w = w |> getAsyncR |> WAsync\n    let inline getAsyncWithDefault f w = getAsyncR w |> Async.map (Result.withError f)\n    let inline getAsync              w = getAsyncWithDefault (fun ms -> raise (exn(getMessages ms))) w\n\n    let fromAsyncResultStr a = a |> Async.map Result.fromResult |> WAsyncR\n\n    let toAsync            w = getAsync  w\n    let toAsyncResult      w = getAsyncR w\n    let toAsyncResultStr   w = getAsyncR w |> Async.map Result.toResultStr\n    let toAsyncOption      w = getAsyncR w |> Async.map Result.toOption\n    let toAsyncOptionMs    w = getAsyncR w |> Async.map Result.toOptionMs\n    let toAsyncWithDefault w = getAsyncWithDefault w\n\n//    let call wb = wb |> getR Rop.notifyMessages\n    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n        w\n        |> getAsyncR\n        |> fun asy -> Async.StartWithContinuations\n                        (asy \n                       , Result.mapMsgs Result.getMessages  >> processVal\n                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal\n                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal)\n                       \n    let start (printMsg: string->unit) (w: Wrap<unit>) = \n        startV (function\n                | Some (), msgs ->               msgs |> printMsg \n                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n\n    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n        let wb = tryCall f a\n        match wb with\n        | WNone                   \n        | WSome   _               -> wb |> wb2arb [||]\n        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n        | WAsync  ab              -> async { let!   b = ab\n                                             return succeed b }\n        | WAsyncR arb             -> arb\n\n    let addMsgs errOptionIsNone ms wb =\n        if ms = [||] then wb else\n        match wb with\n        | WSome            v       -> WResult (succeedWithMsgs                        v ms)\n        | WNone                    -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n        | WAsync           va      -> async {\n                                        let! v = va\n                                        return succeedWithMsgs v ms\n                                      } |> WAsyncR\n        | WAsyncR          vra     -> async {\n                                        let! vr = vra\n                                        return vr                    |> Result.mergeMsgs ms\n                                      } |> WAsyncR\n\n    let combine errOptionIsNone wa (wb: unit -> Wrap<_>) =\n        match wa with\n        | WSome               _\n        | WResult(Result(Some _,[||]))-> wb()\n        | WResult(Result(Some _, ms ))-> wb() |> addMsgs errOptionIsNone ms\n        | WAsync           aa         -> async { let!   _a = aa\n                                                 let!   br = wb() |> toAsyncResult\n                                                 return br\n                                                } |> WAsyncR\n        | WAsyncR          ara        -> async { let!  ar = ara\n                                                 match ar with\n                                                 | Failure    ms -> return Result.failWithMsgs ms\n                                                 | Success(_, ms)-> let! br = wb() |> toAsyncResult\n                                                                    return br |> Result.mergeMsgs ms\n                                               } |> WAsyncR\n        | WNone                       -> WNone\n        | WResult(Result(None, ms))   -> Result.failWithMsgs ms |> WResult\n        \n    let rec whileLoop pred body =\n        if pred() then body() |> bind (fun () -> whileLoop pred body)\n        else WSome   ()\n        //while pred() do\n        //    body() //|> ignore\n        //WSome   ()\n\n    let tryWith    (handler: exn -> Wrap<'a>) (body: unit -> Wrap<'a>) = \n        async {\n            let! r = body() |> toAsyncResult |> Async.Catch \n            match r with\n            | Choice1Of2 v -> return  v\n            | Choice2Of2 e -> return! handler e |> toAsyncResult\n        } |> WAsyncR\n    let tryFinally compensation body = \n        async {\n            let! r1 = body() |> toAsyncResult |> Async.Catch \n            do        compensation()     \n            return\n                match r1 with\n                | Choice1Of2 v -> v\n                | Choice2Of2 e -> raise e\n        } |> WAsyncR\n\n\n    type Builder() =\n//        member        this.Bind (wrapped: Async<Result<'a>>, restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsyncR |> bind restOfCExpr //<< cannot differentiate from next \n        member        this.Bind (wrapped: Wrap<'a>         , restOfCExpr: 'a -> Wrap<'b>) = wrapped            |> bind restOfCExpr \n        member        this.Bind (wrapped: Async<'a>        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> WAsync  |> bind restOfCExpr  \n        member        this.Bind (wrapped: Result<'a>       , restOfCExpr: 'a -> Wrap<'b>) = match wrapped with \n                                                                                            | Result(Some v, [||]) -> WSome v\n                                                                                            | Result(None  , [||]) -> WNone\n                                                                                            | _                    -> WResult wrapped\n                                                                                            |> bind restOfCExpr \n        member        this.Bind (wrapped: 'a option        , restOfCExpr: 'a -> Wrap<'b>) = wrapped |> Option.map WSome   |> Option.defaultValue WNone |> bind restOfCExpr \n        member inline this.Zero         ( ) = WSome   ()\n        member inline this.Return       (x) = WSome   x\n        member inline this.ReturnFrom   (w) = w\n//        member inline this.ReturnFrom   (w) = WAsync  w\n//        member inline this.ReturnFrom   (w) = WResult w\n//        member inline this.ReturnFrom   (w) = WOption w        \n        member inline this.Delay        (f) = f\n        member this.Run(f) = f()\n        member        this.Combine   (a, b) = combine errOptionIsNone a b\n        member        this.While(guard, body) = whileLoop guard body\n        member this.TryWith   (body, handler     ) = tryWith    handler      body\n        member this.TryFinally(body, compensation) = tryFinally compensation body\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))            \n    let wrap    = Builder()\n    let wrapper = Builder()  // deprecated use wrap instead\n\n    let getResult callback (wb: Wrap<'T>) =\n        match wb with\n        | WSome        s  -> s               |> succeed                                              |> callback\n        | WNone           -> errOptionIsNone |> fail                                                 |> callback\n        | WResult      rb -> rb                                                                      |> callback\n        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v                 |> callback), \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n                                                               (fun exc -> failException exc |> fail |> callback), \n                                                                fun can -> failException can |> fail |> callback)\n\n    module Seq =\n        let cons h t = Seq.append t (Seq.singleton h) \n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XResult<'b>) -> 'a list -> XResult<'b list>\n        let rec traverseM f sequ =\n            let (>>=) v f = bind f v\n            let retn      = Return\n            let initState = retn (seq[])\n            let folder tail head = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            Seq.fold folder initState sequ  \n        /// Transform a \"list<XResult>\" into a \"XResult<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map a Result producing function over a list to get a new Result \n        /// using applicative style\n        /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n        let rec traverseA f sequ =\n            let (<*>)     = apply\n            let retn      = Return\n            let initState = retn (Seq.empty)\n            let folder tail head = retn cons <*> f head <*> tail\n            Seq.fold folder initState sequ\n        /// Transform a \"list<Result>\" into a \"Result<list>\" \n        /// and collect the results using apply.\n        let inline sequenceA x = traverseA id x\n\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n    let runSynchronouslyR (w: Wrap<_>) =\n        w\n        |> getAsyncR\n        |> Async.RunSynchronously\n    let runSynchronouslyO count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyR\n        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n    let runSynchronouslyS count (w: Wrap<_>) =\n        w\n        |> runSynchronouslyO count\n        |> function\n           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n           \ntype Wrap<'T> with\n    static member Start           (w:Wrap<_   >,           ?cancToken) = Async.Start           (Wrap.getAsync  w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:Wrap<'T  >, ?options, ?cancToken) = Async.StartAsTask     (Wrap.getAsyncR w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n    static member RunSynchronouslyR(w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsyncR w, ?timeout            = timeout, ?cancellationToken= cancToken)\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n    static member RunSynchronously( w:Wrap<'T  >, ?timeout, ?cancToken) = Async.RunSynchronously(Wrap.getAsync  w, ?timeout            = timeout, ?cancellationToken= cancToken)\n\nlet cons head tail = head :: tail\n\nmodule List =\n    /// Map an AsyncResult producing function over a list to get a new AsyncResult\n    /// using monadic style\n    /// ('a -> Wrap<'b>) -> 'a list -> Wrap<'b list>\n    let rec traverseWrapM f list =\n        let (>>=) x f = Wrap.bind f x\n        let initState = Wrap.Return []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> Wrap.Return (cons h t) ))\n        List.foldBack folder list initState \n    /// Transform a \"list<Wrap>\" into a \"Wrap<list>\"\n    /// and collect the results using bind.\n    let sequenceWrapM x = traverseWrapM id x\n    \n    /// Map an AsyncResult producing function over a list to get a new AsyncResult\n    /// using monadic style\n    /// ('a -> Wrap<'b>) -> 'a list -> Wrap<'b list>\n    let rec traverseWrapA f list =\n        let (<*>)     = Wrap.apply\n        let retn      = Wrap.WSome  \n        let initState = retn []\n        let folder head tail = retn cons <*> f head <*> tail\n        List.foldBack folder list initState \n    /// Transform a \"list<Wrap>\" into a \"Wrap<list>\"\n    /// and collect the results using bind.\n    let sequenceWrapA x = traverseWrapA id x\n    \n    /// Map a Result producing function over a list to get a new Result \n    /// using applicative style\n    /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n    let rec traverseResultA f list =\n        let (<*>)            = Result.apply\n        let retn             = Result.succeed\n        let initState        = retn []\n        let folder head tail = retn cons <*> (f head) <*> tail\n        List.foldBack folder list initState\n    /// Transform a \"list<Result>\" into a \"Result<list>\" \n    /// and collect the results using apply.\n    let sequenceResultA x = traverseResultA id x\n    \n[< AutoOpen >]    \nmodule ResultWrap =\n    let result = Result.result\n    let wrap   = Wrap  .wrap\n\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [{"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"aa485846-7b78-4ca8-ae22-84ba0c42d962"}, "snpName": "Mailbox", "snpContent": "[<System.Runtime.CompilerServices.Extension ; JavaScript false>]\ntype MailboxProcessorExt =\n    [<System.Runtime.CompilerServices.Extension>]\n    static member PostAndReply     (agent:MailboxProcessor<_>, msg) = agent.PostAndReply     (fun reply -> reply, msg)\n    [<System.Runtime.CompilerServices.Extension>]\n    static member PostAndAsyncReply(agent:MailboxProcessor<_>, msg) = agent.PostAndAsyncReply(fun reply -> reply, msg)\n    \n\n\nmodule Mailbox =\n\n    /// A simple Mailbox processor to serially process Async tasks\n    /// use:\n    ///      let logThisMsgA = Mailbox.iterA (fun msg -> \n    ///                            async { printfn \"Log: %s\" msg } )\n    ///      logThisMsgA.Post \"message Async\"\n    ///      \n    let iterA f =\n        MailboxProcessor.Start(fun inbox ->\n            async {\n                while true do\n                    try       let!   msg = inbox.Receive()\n                              do!  f msg\n                    with e -> printfn \"%A\" e\n            }\n        )\n        \n    /// A simple Mailbox processor to serially process tasks\n    /// use:\n    ///      let logThisMsg = Mailbox.iter (printfn \"Log: %s\")\n    ///      logThisMsg.Post \"message\"\n    ///      \n    let iter f = iterA (fun msg -> async { f msg } )\n    \n    /// A simple Mailbox processor to serially and synchronously process tasks\n    /// use:\n    ///      let toUpperCaseA = Mailbox.callA (fun (msg:string) -> \n    ///                                async { return msg.ToUpper() } )\n    ///\n    ///      toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") \n    ///      |> printfn \"%s\"\n    ///\n    ///      toUpperCaseA.PostAndReply \"message\"\n    ///      |> printfn \"%s\"\n    ///\n    ///      async {\n    ///          let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> \n    ///                                                        reply, \"message\")\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///\n    ///      async {\n    ///          let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously    \n    ///      \n    let callA f = iterA (fun ((replyChannel: AsyncReplyChannel<_>), msg) -> async {\n        let! r = f msg\n        replyChannel.Reply r\n    })\n    \n    /// A simple Mailbox processor to serially and synchronously process tasks\n    /// use:\n    ///      let toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\n    ///      \n    ///      toUpperCase.PostAndReply(fun reply -> reply, \"message\") \n    ///      |> printfn \"%s\"\n    ///      \n    ///      toUpperCase.PostAndReply \"message\"\n    ///      |> printfn \"%s\"\n    ///      \n    ///      async {\n    ///          let! res = toUpperCase.PostAndAsyncReply(fun reply -> \n    ///                                                       reply, \"message\")\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///      \n    ///      async {\n    ///          let! res = toUpperCase.PostAndAsyncReply \"message\"\n    ///          printfn \"Async: %s\" res\n    ///      } |> Async.RunSynchronously\n    ///      \n    let call f = callA (fun (msg:string) -> async { return f msg } )\n    \n    /// A Mailbox processor that maintains a state\n    let foldA f initState =\n        MailboxProcessor.Start(fun inbox ->\n            let rec loop state : Async<unit> = async {\n                try       let! msg      = inbox.Receive()\n                          let! newState = f state msg\n                          return! loop newState\n                with e -> printfn \"%A\" e\n                          return! loop state\n            }\n            loop initState\n        )\n\n    /// A Mailbox processor that maintains a state\n    let fold f initState = foldA (fun state msg -> async { return f state msg } ) initState\n\n    type FoldNShare<'S, 'X>(f: 'S -> 'X -> Async<'S>, initState:'S) =\n        let mutable share = initState\n        let agent =\n          MailboxProcessor.Start(fun inbox ->\n            let rec loop state : Async<unit> = async {\n                try       let! msg      = inbox.Receive()\n                          let! newState = f state msg\n                          share <- newState\n                          return! loop newState\n                with e -> printfn \"%A\" e\n                          return! loop state\n            }\n            loop initState\n        )\n        member this.Post  = agent.Post\n        /// Copy of current state. This is a mutable value\n        member this.State = share\n        member this.Agent = agent\n\n    /// A Mailbox processor that maintains a state and shares its current value\n    let foldNShare f initState = FoldNShare(f, initState)\n\n// object expressions work only on types not objects\n//\n//    /// A simple Mailbox processor to serially process tasks\n//    /// with a Flush option\n//    let iterFlushable f =\n//        let ff msg = match msg with \n//                     | Some m -> f m \n//                     | None   -> async { () }\n//        let mailbox = iter ff\n//        { new mailbox with member this.Flush() = mailbox.Post None }  \n//\n//    let foldFlushable f initState =\n//        let ff msg = match msg with \n//                     | Some m -> f m \n//                     | None   -> async { () }\n//        let mailbox = fold ff initState\n//        { new mailbox with member this.Flush() = mailbox.Post None }\n//        \n\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [{"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}, "snpName": "Dict, LDict, IDict", "snpContent": "(* issues with websharper Type not found in JavaScript compilation: System.Collections.Generic.IDictionary`2\nmodule IDict =\n#if WEBSHARPER\n    [< Inline >]\n#endif\n    let inline tryGetValue key (dict:System.Collections.Generic.IDictionary<_, _>) =\n        let mutable res = Unchecked.defaultof<_>\n        if dict.TryGetValue(key, &res)\n        then Some res \n        else None\n    let add          key v (dict:System.Collections.Generic.IDictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n*)\nmodule Dict =\n    let [<Inline>] inline tryGetValue key (dict:System.Collections.Generic. Dictionary<_, _>) =\n        let mutable res = Unchecked.defaultof<_>\n        if dict.TryGetValue(key, &res)\n        then Some res \n        else None\n    let add          key v (dict:System.Collections.Generic. Dictionary<_, _>) = if dict.ContainsKey key then      dict.[key] <- v else dict.Add(key, v)\n\nmodule LDict =\n    let [<Inline>] inline containsKey  key  dict = (^a : (member ContainsKey : _ -> bool) (dict, key))\n    //let inline item         key  dict = (^a : (member get_Item    : _ -> _   ) (dict, key))\n    let [<Inline>] inline tryGetValue fitem key  dict =\n        if containsKey key dict then Some (fitem key)\n        else None\n\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"af2b60c6-a99f-433d-b938-f59fefe66c01"}, "snpName": "parseInt", "snpContent": "let tryParseWith tryParseFunc = tryParseFunc >> function\n        | true, v    -> Some v\n        | false, _   -> None\n\nlet parseDate   = tryParseWith System.DateTime.TryParse\nlet parseInt    = tryParseWith System.Int32   .TryParse\nlet parseSingle = tryParseWith System.Single  .TryParse\nlet parseDouble = tryParseWith System.Double  .TryParse\n// etc.\n\n// active patterns for try-parsing strings\nlet (|Date  |_|) = parseDate\nlet (|Int   |_|) = parseInt\nlet (|Single|_|) = parseSingle\nlet (|Double|_|) = parseDouble", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, "snpName": "REGEX", "snpContent": "#if WEBSHARPER\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match JavaScript.String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})\"\"\"\n\nmodule REGEX =\n    let getStartWord (line:string) ch =\n        match line.Substring(0, ch) with\n        | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n        | _                                      -> \"\"          \n    \n    let getEndWord (line:string) ch =\n        match line.Substring(ch) with\n        | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n        | _                                      -> \"\"          \n\n\n\n#endif\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}, "snpName": "dprintfn, oprintfn", "snpContent": "let dprintfn       fmt = fmt |> Printf.ksprintf ignore //(fun s -> printfn \"%s\"  s)\nlet printoutfn out fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\" |> out)\n//let printoutf  out fmt = Printf.kprintf                        out  fmt\nlet print    v = printfn \"%A\" v\nlet mapPrint v = print        v; v\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"}, "snpName": "memoize", "snpContent": "let [<Inline>] memoize f = \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x -> \n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n             \ntype ResetableMemoize(f) =             \n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    member this.ClearCache() = cache.Clear()\n    [<Inline>] \n    member this.Call x =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = cache.TryGetValue(x, &res)\n        if ok then res \n        else let res = f x\n             cache.[x] <- res\n             res\n    ", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}, "snpName": "separateDirectives", "snpContent": "type PreproDirective =\n| PrepoR      of string\n| PrepoDefine of string\n| PrepoLoad   of string\n| PrepoLine   of string //* int\n| PrepoNoWarn of string\n| PrepoI      of string\n| PrepoIf     of string\n| PrepoElse   \n| PrepoEndIf\n| PrepoLight  of bool\n| PrepoOther  of string\n| NoPrepo\n\nlet separatePrepros removePrepoLine (code:string[]) =\n    let  quoted (line:string) = line.Trim().Split([| \"\\\"\"       |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryLast |> Option.defaultValue line\n    let  define (line:string) = line.Trim().Split([| \"#define \" |], System.StringSplitOptions.RemoveEmptyEntries) |> Seq.tryHead |> Option.defaultValue \"\"\n    let  comment = ((+)\"//\") \n    let  preL    = if removePrepoLine then comment else id \n    let  prepro (line:string) = match true with \n                                | true when line.StartsWith(\"#define\") -> (comment line, line |> define |> PrepoDefine)\n                                | true when line.StartsWith(\"#r\"     ) -> (comment line, line |> quoted |> PrepoR     )\n                                | true when line.StartsWith(\"#load\"  ) -> (comment line, line |> quoted |> PrepoLoad  )\n                                | true when line.StartsWith(\"#nowarn\") -> (comment line, line |> quoted |> PrepoNoWarn)\n                                | true when line.StartsWith(\"# \"     ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#line\"  ) -> (preL    line, line |> quoted |> PrepoLine  )\n                                | true when line.StartsWith(\"#I\"     ) -> (comment line, line |> quoted |> PrepoI     )\n                                | true when line.StartsWith(\"#if\"    ) -> (        line, line           |> PrepoIf    )\n                                | true when line.StartsWith(\"#else\"  ) -> (        line,                   PrepoElse  )\n                                | true when line.StartsWith(\"#endif\" ) -> (        line,                   PrepoEndIf )\n                                | true when line.StartsWith(\"#light\" ) -> (        line, false          |> PrepoLight )\n                                | true when line.StartsWith(\"#\"      ) -> (comment line, line           |> PrepoOther )\n                                | _                                    -> (        line,                   NoPrepo    ) \n    code |> Array.map prepro\n    \nlet separateDirectives (fsNass:(string * PreproDirective) seq) =\n    let  assembs  = fsNass |> Seq.choose (snd >> (function | PrepoR assemb -> Some assemb | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  defines  = fsNass |> Seq.choose (snd >> (function | PrepoDefine d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  prepoIs  = fsNass |> Seq.choose (snd >> (function | PrepoI      d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  nowarns  = fsNass |> Seq.choose (snd >> (function | PrepoNoWarn d -> Some d      | _ -> None)) |> Seq.distinct |> Seq.toArray\n    let  code     = fsNass |> Seq.map     fst                                                                           |> Seq.toArray\n    code, assembs, defines, prepoIs, nowarns\n\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b37f91be-7579-4fea-8263-bd10ec60f7e4"}, "snpName": "Save File", "snpContent": "open System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\nlet inline saveFile (file:string) (content: string) =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        backupFile file\n        File.WriteAllText(file, content)\n    } \n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c7e56d1e-aea8-483a-a99a-23b7e056de0d"}, "snpName": "", "snpContent": "let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"16f618b6-0483-44dc-9c54-550f4f5b725d"}, "snpName": "type ActionBar", "snpContent": "open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5d4bba38-c34d-40be-a19a-383bdb85c663"}, "snpName": "Tree", "snpContent": "\nmodule Tree =\n\n    type Node<'I> =\n        abstract member Id              : 'I\n        abstract member isExpanded      : bool\n        abstract member canHaveChildren : bool\n        abstract member children        : Node<'I> seq\n        abstract member path            : 'I list\n        abstract member parent          : Node<'I> seq -> Node<'I> option\n        abstract member newChildren     : Node<'I> seq -> Node<'I>\n\n    let [<Inline>] inline toNode    (o: obj) = o :?> Node<_>\n    let [<Inline>] inline toSeqNode  os      = os |> Seq.map toNode\n\n    let rec listNodes level (nodes: Node<'I> seq) = seq {\n        for node in nodes do\n            yield node, level\n            if node.isExpanded then\n                yield! listNodes (level + 1) node.children\n    }\n\n    let removeNode (node:Node<_>) nodes =\n        let path = node.path\n        let rec chRemove (n:Node<_>) =\n            if                 n.Id = node.Id then None\n            elif List.contains n.Id path      then Some (n.newChildren (Seq.choose chRemove n.children) )\n            else                                   Some n\n        nodes |> Seq.choose chRemove\n\n    let removeNodes p nodes =\n        let rec folder (children, noparent) (n:Node<_>) =\n            let ch, np = n.children |> Seq.fold folder ([], noparent)\n            if p n then (                                  children, ch @ np)\n            else        (n.newChildren (ch |> List.rev) :: children,      np)\n        let res, noparent = nodes |> Seq.fold folder ([], [])\n        noparent @ res |> List.rev\n\n    let addNodeToSeq after p node (nodes:Node<'I> seq)  =\n        seq [ for n in nodes do\n                if p n then\n                    if after then yield n    ; yield node\n                    else          yield node ; yield n\n                else              yield n\n        ]\n        \n    let addToParent after p (node:Node<'I>) (parent :Node<'I>) (nodes:Node<'I> seq)  = nodes |> addNodeToSeq after p node |> parent.newChildren\n\n    let addSibling  after   (node:Node<'I>) (sibling:Node<'I>) (nodes:Node<'I> seq) =\n        let theSibling (n:Node<'I>) = n.Id = sibling.Id\n        match sibling.path with\n        | [   ]          -> addNodeToSeq after theSibling node nodes \n        | parent :: path -> \n        let rec mapAdd (n:Node<'I>) =\n            if   n.Id = parent           then n.children |> addToParent after theSibling node n\n            elif List.contains n.Id path then n.newChildren (Seq.map mapAdd n.children) \n            else                              n\n        nodes |> Seq.map mapAdd\n\n    let tryFind p (nodes:Node<'I> seq) =\n        let rec folder res (node:Node<'I>) =\n            match  res with\n            | Some _ -> res\n            | None   -> if p node then Some node else node.children |> Seq.fold folder None\n        nodes\n        |> Seq.fold folder None\n    let tryFindId (id:'I) (nodes:Node<'I> seq) = tryFind (fun n -> n.Id = id) nodes\n\n    let moveToSibling after (node:Node<'I>) (sibling:Node<'I>) (nodes:Node<'I> seq) =\n        nodes\n        |> removeNode node\n        |> addSibling after node sibling\n\n    let moveToSibling2 after (nodeId:'I) (siblingId:'I) (nodes:Node<'I> seq) =\n        nodes\n        |> tryFindId nodeId\n        |> Option.bind(fun node ->\n            nodes\n            |> tryFindId siblingId\n            |> Option.map(fun sibling -> moveToSibling after node sibling nodes)\n        )\n        |> Option.defaultValue nodes\n\n    let addChild append (node:Node<'I>) (parentN:Node<'I>) (nodes:Node<'I> seq) =\n        let path = parentN.path\n        let rec mapAppend (n:Node<'I>) =\n            if   n.Id = parentN.Id          then \n                if append                then n.children |> Seq.append <| [ node ] |> n.newChildren\n                else                          n.children |> Seq.append    [ node ] |> n.newChildren\n            elif List.contains n.Id path then n.children |> Seq.map mapAppend      |> n.newChildren\n            else                              n\n        nodes |> Seq.map mapAppend\n\n    let indentNode (node:Node<'I>) (nodes:Node<'I> seq) =\n        node.parent nodes\n        |> Option.map (fun parent -> parent.children )\n        |> Option.defaultValue nodes\n        |> Seq.takeWhile (fun            n -> node.Id <> n.Id)\n        |> Seq.fold      (fun newParentO n -> if n.canHaveChildren then Some n else newParentO) None\n        |> Option.map(fun newParent ->\n            nodes\n            |> removeNode node \n            |> addChild true node newParent\n        )\n        |> Option.defaultValue nodes\n\n    let outdentNode (node:Node<'I>) (nodes:Node<'I> seq) =\n        node.parent nodes\n        |> Option.map(fun parent -> moveToSibling true node parent nodes )\n        |> Option.defaultValue nodes\n", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ece85c79-829d-4bec-a607-a1cd01f9dafa"}, "snpName": "asyncStartCancelling", "snpContent": "let asyncStartCancelling() =    \n    let mutable tokenSource : System.Threading.CancellationTokenSource option = None\n    fun a ->\n        tokenSource |> Option.iter (fun oldTokenSource -> oldTokenSource.Cancel() )\n        let newTokenSource = new System.Threading.CancellationTokenSource() \n        Async.Start(a, newTokenSource.Token)\n        tokenSource <- Some newTokenSource\n\n        ", "snpParentIdO": {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpName": "UsefulDotNet", "snpContent": "module UsefulDotNet =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7646acbc-2c28-4159-98b1-2365d19fc97c"}, "snpName": "Regex, Regexs", "snpContent": "#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    if input = null then None else\n    try \n        let m = Regex.Match(input, pattern)\n        if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n        else None\n    with e -> None\n\nlet (|Regexs|) pattern input =\n    if input = null then [| |] else\n    try \n        let ms = Regex.Matches(input, pattern)\n        [| for m in ms do yield m.Value |] \n    with e -> [| |]\n", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9becc68c-9cc2-4f29-82df-e510d10226db"}, "snpName": "fSharpError2TranspilerError", "snpContent": "open Microsoft.FSharp.Compiler.SourceCodeServices\nopen Microsoft.FSharp.Compiler\nopen Useful\n\ntype FSharpErrors =\n    | WarningFSharp                 of string\n    | ErrFSharp                     of string\nwith interface ErrMsg with\n        member this.ErrMsg    = sprintf \"%A\"this\n        member this.IsWarning = match this with | WarningFSharp _ -> true | _ -> false\n\nlet getIndentFile input =\n    match input with\n    | Regex \"^\\\\((\\\\d+)\\\\)\\\\s(.*)$\" [_ ; indent ; file] -> int indent, file\n    | _                                                 -> 0         , input\n   \nlet fSharpError2TranspilerError (error : FSharpErrorInfo) =\n    let indent, file = System.IO.Path.GetFileNameWithoutExtension error.FileName |> getIndentFile  \n    sprintf \"%s (%d,%d) - (%d,%d) %s %d: %s\" \n       file \n       error.StartLineAlternate (error.StartColumn - indent) \n       error.EndLineAlternate   (error.EndColumn   - indent) \n       error.Subcategory error.ErrorNumber error.Message\n    |> (if   error.Severity = FSharpErrorSeverity.Error  \n        then ErrFSharp     \n        else WarningFSharp\n       )\n    :> ErrMsg\n    \n    ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"7646acbc-2c28-4159-98b1-2365d19fc97c"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"f930dc48-39e8-453c-8c77-18a2cd73637a"}, "snpName": "ResourceAgent", "snpContent": "open Useful\n\ntype ResourceAgent<'T, 'C when 'C : equality>(maxUseCount:int, ctor: 'C option ->'T, ?cleanup, ?isAlive, ?configuration: 'C) =\n    let mutable configuration = configuration\n    let mutable resource      = ctor configuration\n    let mutable useCount      = 0\n    let respawn() =\n        cleanup |> Option.iter (fun clean -> clean resource) \n        resource <- ctor configuration\n        useCount <- 0\n    let agent    = \n        MailboxProcessor.Start(fun inbox ->\n            async {\n               while true do\n                 try\n                     let! increment, config, work = inbox.Receive()\n                     isAlive |> Option.iter (fun alive -> if not (alive resource) then respawn())\n                     if config <> configuration then\n                        configuration <- config\n                        respawn()\n                     do!  work resource\n                     if increment then useCount <- useCount + 1\n                                       if useCount >= maxUseCount && maxUseCount > 0 then respawn()\n                 with _ -> respawn() \n            }\n        )\n    do agent.Error.AddHandler <| Handler (fun _ _ -> respawn())\n    member this.Process (work:'T -> Wrap<'a>, ?config, ?incrUse) =\n        agent.PostAndAsyncReply\n            (fun reply ->\n                 (defaultArg incrUse true, config, fun resource ->\n                          async {\n                               let! res = work resource |> Wrap.getAsyncR\n                               reply.Reply res\n                          } \n                 )\n            )\n    member this.Configuration  = configuration\n    member this.MaxUseCount    = maxUseCount\n    member this.UseCount       = useCount\n    interface System.IDisposable with\n        member this.Dispose () =\n            try cleanup |> Option.iter (fun clean -> clean resource) with _ -> ()\n", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, "snpName": "TempFileName", "snpContent": "type TempFileName(fn) =\n    new () = new TempFileName(System.IO.Path.GetTempFileName())\n    member this.Name = fn\n    interface System.IDisposable with\n        member this.Dispose() = if System.IO.File.Exists fn then System.IO.File.Delete fn\n        \n        ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, "snpName": "RunProcess", "snpContent": "open System.Diagnostics\nopen System.Text\nopen Useful\n\nmodule RunProcess =\n\n    let startProcess p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    let startProcessDir p ops dir =\n        let procStart   = ProcessStartInfo(p, ops, WorkingDirectory = dir)\n        let proc        = new Process()\n        proc.StartInfo <- procStart\n        proc.Start() \n    \n    type ShellExError =\n        | ShellExitCode              of int\n        | ShellOutput                of string\n        | ShellErrors                of string\n        | ShellFailWithMessage       of string\n        | ShellFinishedWithNoMessage \n        | ShellDidNotStart \n        | ShellCrashed               of string\n    with interface ErrMsg with\n            member this.ErrMsg    = \n                match this with \n                | ShellFailWithMessage msg   -> msg  \n                | ShellFinishedWithNoMessage -> \"warning - No output\"\n                | ShellOutput          msg   -> msg\n                | ShellCrashed         msg   -> \"Crashed \" + msg\n                | msg                        -> sprintf \"%A\" msg\n            member this.IsWarning =\n                match this with \n                | ShellFinishedWithNoMessage\n                | ShellOutput _              -> true\n                | _                          -> false \n    \n    \n    type ShellEx(startInfo: ProcessStartInfo, ?outHndl, ?errHndl, ?priorityClass) =\n        let proc                              = new Process()\n        let bufferOutput                      = new StringBuilder()\n        let bufferError                       = new StringBuilder()\n        let append  (sb: StringBuilder) txt   = sb.Append(txt + \"\\n\") |> ignore\n        let consume (sb: StringBuilder)       = \n            let v = sb.ToString()\n            sb.Clear() |> ignore\n            v\n        let dataHandler handler               = DataReceivedEventHandler(fun sender args -> try handler args.Data with _ -> ())\n        let outputHandler                     = append bufferOutput |> dataHandler\n        let errorHandler                      = append bufferError  |> dataHandler\n        do  startInfo.RedirectStandardInput  <- true\n            startInfo.RedirectStandardOutput <- true\n            startInfo.RedirectStandardError  <- true\n            startInfo.UseShellExecute        <- false\n            proc.StartInfo                   <- startInfo\n            proc.EnableRaisingEvents         <- true\n            outputHandler                    |>             proc.OutputDataReceived.AddHandler\n            errorHandler                     |>             proc.ErrorDataReceived .AddHandler\n            Option.map dataHandler outHndl   |> Option.iter proc.OutputDataReceived.AddHandler\n            Option.map dataHandler errHndl   |> Option.iter proc.ErrorDataReceived .AddHandler\n    //        proc.Exited            .AddHandler(System.EventHandler     (fun sender args -> try proc.Close()                                    with _ -> () ))\n        new (program, args, ?priorityClass) =             \n            let startInfo                     = new ProcessStartInfo()\n            do  startInfo.FileName           <- program\n                startInfo.Arguments          <- args\n            new ShellEx(startInfo, ?priorityClass = priorityClass)\n        member this.Start() = \n            let r = proc.Start() \n            priorityClass |> Option.iter (fun p -> proc.PriorityClass <- p)\n            proc.BeginOutputReadLine()\n            proc.BeginErrorReadLine ()\n            r\n        member this.stdOutErr2Result out errs exit =\n            if exit <> 0\n            then Result.failWithMsgs\n                    [| if out  <> \"\"              then yield ErrSimple (\"stdout: \" + out           , true ) :> ErrMsg\n                       if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg\n                       if errs  = \"\" || exit <> 1 then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                    |]\n            else Result.succeedWithMsgs out \n                    [| if errs <> \"\"              then yield ErrSimple (errs                       , false) :> ErrMsg |]\n        member this.WaitToFinish() =\n            proc.WaitForExit()\n            let    output  = (consume bufferOutput).Trim()\n            let    error   = (consume bufferError ).Trim()\n            (output, error, if proc.HasExited then proc.ExitCode else -99999)\n        member this.StartAndWait() =\n            let _started = this.Start()\n            this.WaitToFinish()\n        member this.WaitForInputIdle() =\n            proc.WaitForInputIdle()\n        member this.StartAndWaitR() =\n            let r = this.StartAndWait()\n            (this :> System.IDisposable).Dispose()\n            r |||> this.stdOutErr2Result\n        member this.RunToFinish() =\n            this.StartAndWaitR()\n            |> Result.result2String\n        member this.RunOutputToFileR file =\n            proc.OutputDataReceived.RemoveHandler outputHandler\n            use stream  = new System.IO.FileStream(file, System.IO.FileMode.Create)\n            let _started = proc.Start() \n            proc.BeginErrorReadLine ()\n            proc.StandardOutput.BaseStream.CopyTo stream\n            this.WaitToFinish()\n            |||> this.stdOutErr2Result\n        member this.RunOutputToFile file =\n            this.RunOutputToFileR file\n            |> Result.result2String\n        member this.Send(txt: string)   = proc.StandardInput.WriteLine txt\n        member this.Output  ()          = consume bufferOutput\n        member this.Error   ()          = consume bufferError\n        member this.Response(out:string, err:string)  = \n            match out.Trim(), err.Trim() with\n    //        | \"\"  , \"\"  -> None\n            | good, \"\"  -> Some( Result.succeed        good                             )\n            | \"\"  , bad -> Some( Result.fail                <| ShellFailWithMessage bad )\n            | good, bad -> Some( Result.succeedWithMsg good <| ShellFailWithMessage bad )\n        member this.Response()          = this.Response(this.Output(), this.Error())\n        member this.SendAndWait(send, wait, ?onError) =\n            let waitOnError   = defaultArg onError false\n            let eventWait = \n                if waitOnError then proc.ErrorDataReceived else proc.OutputDataReceived\n                |> Event.choose (fun evArgs -> try evArgs.Data |> (fun v -> if v.Contains wait then Some <| Result.succeed v else None) with _ -> None)\n            let eventAll = Event.merge eventWait  (Event.map (fun _ -> Result.fail <| ShellCrashed startInfo.FileName) proc.Exited)\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                async { \n                    do!    Async.Sleep 20 \n                    this.Send send        } |> Async.Start\n                let!   waitedR = Async.AwaitEvent eventAll\n                let!   waited  = waitedR\n                do!    Async.Sleep 200\n                let!   res =\n                       if waitOnError then \n                           this.Response(this.Output(), this.Error() |> fun msg -> msg.Split([| waited |], System.StringSplitOptions.None) |> Array.head)\n                       else this.Response()\n                       |> Option.defaultWith (fun () -> Result.succeedWithMsg \"\" ShellFinishedWithNoMessage)\n                return res\n            }\n        member this.HasExited = try proc.HasExited with _ -> true\n        member this.Abort()   = try proc.Kill   () with _ -> ()\n        interface System.IDisposable with\n            member this.Dispose () =\n                try proc.Kill   () with _ -> ()\n                try proc.Close  () with _ -> ()\n                try proc.Dispose() with _ -> ()\n    \n    \n    let runAndWaitR p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.StartAndWaitR() \n    \n    let runToFinish p ops =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart, printfn \"%s\", eprintfn \"%s\")\n        shell.RunToFinish() \n    \n    let runOutputToFile p ops file =\n        let procStart   = ProcessStartInfo(p, ops)\n        let shell       = new ShellEx(procStart)\n        shell.RunOutputToFile file \n    \n    ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ab5ab0ca-eb45-4851-affe-4690bb75d055"}, "snpName": "copyIfMust", "snpContent": "open System.IO\n\nlet copyIfNotExistsToFile from dest =\n    let fit = FileInfo dest\n    if not fit.Exists then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToFile from dest =\n    let fit = FileInfo dest\n    let must = \n        match fit.Exists with \n        | false -> true\n        | true  ->\n            let fif = FileInfo dest\n            fif.Length <> fit.Length || fif.LastWriteTime <> fit.LastWriteTime\n    if must then\n        File.Copy(from, dest, true )\n\nlet copyIfMustToDir from destDir =\n    let dest = Path.Combine(destDir, Path.GetFileName(from))\n    copyIfMustToFile from dest\n    ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"15cf771f-22b1-4796-8e34-6c16f35d6506"}, "snpName": "Path.Combine", "snpContent": "let inline (+/+) a b = System.IO.Path.Combine(a, b)", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ef053bdf-997b-49c8-a401-1611a568bd8a"}, "snpName": "CompOptions", "snpContent": "module CompOptionsModule = // needs to be in a module so (?) operator does not collide with websharper\n    \n    type CompOptionClass = \n         | OpFSharp\n         | OpWebSharper\n         | OpInternal\n\n    type CompOption = \n        {\n            name   : string\n            unique : bool\n            opClass: CompOptionClass  \n            prefix : string\n        }\n    with\n        static member (/=) (op: CompOption, v: CompOptionValue) = op,           v\n        static member (/=) (op: CompOption, v                 ) = op, OpVText   v\n        static member (/=) (op: CompOption, v                 ) = op, OpVTextOF v\n    \n    and CompOptionValue =\n        | OpVText   of                 string\n        | OpVTextOF of (CompOptions -> string)\n    with \n        member this.Value ops = \n            match this with\n            | OpVText   v  -> v\n            | OpVTextOF fo -> fo ops\n    \n    and CompOptions = CompOptions of (CompOption * CompOptionValue) []\n    with\n        member this.Pairs             =  this |> function CompOptions ops ->  ops\n        member this.Exists   f        =  this.Pairs |> Array.exists f \n        member this.Find     name     =  this.Pairs |> Array.tryFind (fun (opT, opV) -> name = opT.name) |> Option.defaultWith (fun () -> raise (exn (\"option \" + name + \" not found.\")) )\n        member this.FindV    name     = (this.Find name |> snd).Value this\n        member this.Contains co       =  this.Exists (fun (opT, opV) -> co   = opT                           )\n        member this.Contains v        =  this.Exists (fun (opT, opV) -> v    = opT.prefix + (opV.Value this) )\n        member this.Get      f        =  this.Pairs |> Array.filter f |> Array.map (fun (opT, opV) ->        opT.prefix + (opV.Value this) )\n        static member FSharpOptions   = fun ({opClass=cls}, _) -> cls = OpFSharp\n        static member WSharperOptions = fun ({opClass=cls}, _) -> cls = OpFSharp || cls = OpWebSharper\n        static member (?) (ops: CompOptions, name: string) = ops.FindV name\n        static member (+) (os1: CompOptions, a2: (CompOption * CompOptionValue) seq) = \n            match os1 with \n            | CompOptions a1 -> \n                a1\n                |> Array.filter (fun (opT, _) -> (not opT.unique) || (a2 |> Seq.exists (fst >> (=) opT) |> not) )\n                |> Seq.append <| a2\n                |> Seq.toArray\n                |> CompOptions\n        static member (+) (ops: CompOptions, o:   CompOption * CompOptionValue      ) = ops + [| o |]\n        static member (+) (os1: CompOptions, os2: CompOptions                       ) = match os2 with | CompOptions a2 -> os1 + a2\n    \n    let (?) (ops:CompOptions) name = ops.FindV name\n    \n    let opSnippet     = { name = \"Snippet\"     ; unique = true  ; opClass = OpInternal   ; prefix = \"++snippet:\"   }\n    let opDirectory   = { name = \"Directory\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++directory:\" }\n    let opName        = { name = \"Name\"        ; unique = true  ; opClass = OpInternal   ; prefix = \"++name:\"      }\n    let opExtension   = { name = \"Extension\"   ; unique = true  ; opClass = OpInternal   ; prefix = \"++extension:\" }\n    let opFileName    = { name = \"Filename\"    ; unique = true  ; opClass = OpInternal   ; prefix = \"++filename:\"  }\n    let opOutputFile  = { name = \"OutputFile\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++fileout:\"   }\n    let opConfig      = { name = \"Config\"      ; unique = true  ; opClass = OpInternal   ; prefix = \"++config:\"    }\n    let opGenInternal = { name = \"GenInternal\" ; unique = false ; opClass = OpInternal   ; prefix = \"++\"           }\n    let opWebSharper  = { name = \"WebSharper\"  ; unique = true  ; opClass = OpInternal   ; prefix = \"++websharper:\"}\n        \n    let opIOption     = { name = \"IOption\"     ; unique = false ; opClass = OpFSharp     ; prefix = \"-I:\"          }\n    let opReference   = { name = \"Reference\"   ; unique = false ; opClass = OpFSharp     ; prefix = \"-r:\"          }\n    let opSource      = { name = \"Source\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"\"             }\n    let opTarget      = { name = \"Target\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"--target:\"    }\n    let opPlatform    = { name = \"Platform\"    ; unique = true  ; opClass = OpFSharp     ; prefix = \"--platform:\"  }\n    let opOutput      = { name = \"Output\"      ; unique = true  ; opClass = OpFSharp     ; prefix = \"-o:\"          }\n    let opDebug       = { name = \"Debug\"       ; unique = true  ; opClass = OpFSharp     ; prefix = \"--debug:\"     }\n    let opDefine      = { name = \"Define\"      ; unique = false ; opClass = OpFSharp     ; prefix = \"--define:\"    }\n    let opGenFSharp1  = { name = \"GenFSharp1\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"-\"            }\n    let opGenFSharp2  = { name = \"GenFSharp2\"  ; unique = false ; opClass = OpFSharp     ; prefix = \"--\"           }\n    \n    let opWebSite     = { name = \"Website\"     ; unique = true  ; opClass = OpWebSharper ; prefix = \"--wsoutput:\"  }\n    let opWsProject   = { name = \"WsProject\"   ; unique = true  ; opClass = OpWebSharper ; prefix = \"--project:\"   }\n    let opGenWSharper = { name = \"GenWSharper\" ; unique = false ; opClass = OpWebSharper ; prefix = \"--\"           }\n    \n    let dllOptions     = CompOptions [| opTarget      /= \"library\"                                                                     |]  \n    let exeOptions     = CompOptions [| opTarget      /= \"exe\"     ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    let winExeOptions  = CompOptions [| opTarget      /= \"winexe\"  ; opGenInternal /= \"copyassemblies\" ; opGenInternal /= \"copyconfig\" |]\n    \n    let genericOptions = \n      CompOptions\n        [|\n           opSnippet     /= \"Test\"\n           opName        /= fun os -> (os?Snippet : string).Split('/') |> Array.last\n           opDirectory   /= fun os -> \"Compiled\" +/+ os?Name\n           opExtension   /= fun os -> match os?Target with | \"library\" -> \"dll\" | _ -> \"exe\"\n           opFileName    /= fun os -> os?Directory +/+ os?Name + \".fs\"\n           opSource      /= fun os -> os?Filename\n           opOutput      /= fun os -> System.IO.Path.ChangeExtension(os?Source, os?Extension)\n           opOutputFile  /= fun os -> System.IO.Path.GetFileName(os?Output)\n           opConfig      /= fun os -> os?Output + \".config\"\n           opWebSharper  /= fun os -> if (os:CompOptions).Exists (fun (opT, opV) -> opT.opClass = OpWebSharper) then \"1\" else \"0\"\n        |]\n        \n    let siteOptions =\n      CompOptions\n        [|\n           opGenWSharper /= \"ws:Site\"\n           opWebSite     /= fun os -> os?Directory +/+ \"website\"\n           opWsProject   /= fun os -> os?Name\n           opGenWSharper /= \"jsmap+\"\n        |] \n     \n    let wsProjectOptions =\n      CompOptions\n        [|\n           opWsProject   /= fun os -> os?Name\n        |] \n     \n    let debugOptions = \n      CompOptions\n        [|\n           opGenFSharp1  /= \"g\"\n           opDebug       /= \"full\"\n           opDefine      /= \"DEBUG\"\n           opDefine      /= \"TRACE\"\n           opGenFSharp2  /= \"optimize-\"\n           opGenFSharp2  /= \"tailcalls-\"\n        |]\n    \n    let otherOptions =\n      CompOptions\n        [|\n           //@\"--noframework\"\n           opGenFSharp2  /= \"warn:3\"\n           opGenFSharp2  /= \"warnaserror:76\"\n           opGenFSharp2  /= \"vserrors\"\n           opGenFSharp2  /= \"utf8output\"\n           opGenFSharp2  /= \"fullpaths\"\n           opGenFSharp2  /= \"flaterrors\"\n           opGenFSharp2  /= \"subsystemversion:6.00\"\n           opGenFSharp2  /= \"highentropyva+\"\n           opGenInternal /= \"removelinedirectives\"\n        |]\n    \n    let compileOptionsDll (snp:string) = \n        genericOptions\n        + dllOptions\n        + otherOptions\n        + opSnippet     /= snp\n        \n    let compileOptionsDllDebug (snp:string) = compileOptionsDll snp + debugOptions        \n    let compileOptionsExeDebug    snp = compileOptionsDllDebug snp + exeOptions   \n    let compileOptionsWinExeDebug snp = compileOptionsDllDebug snp + winExeOptions\n        \n    let prepOptions (options:CompOptions) (code : string [], assembs : string [], defines : string [], prepoIs : string [], nowarns : string []) =\n        let  code2 =\n           [\n              yield! nowarns |> Seq.distinct |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n              yield! code \n           ] |> String.concat \"\\n\"\n        let  fileName = options?Filename\n        do   System.IO.File.WriteAllText(fileName, code2)\n        let  options2 = \n             options  + [|\n                           yield! prepoIs |> Array.map ((/=) opIOption  ) \n                           yield! assembs |> Array.map ((/=) opReference)\n                           yield! defines |> Array.map ((/=) opDefine   )\n                           if options.Contains \"++staticlinkall\" then \n                               yield! assembs |> Array.map (System.IO.Path.GetFileNameWithoutExtension >> ((+) \"staticlink:\") >> ((/=) opGenFSharp2 ))         \n                        |]\n        if options.Contains \"++copyassemblies\" then \n            assembs |> Array.iter (fun f -> System.IO.Path.GetDirectoryName(fileName) |> copyIfMustToDir f)      \n        if options2.Contains \"++showoptions\"    then printfn \"%s\" (options2.Get (fun _ -> true) |> String.concat \"\\n\")               \n        options2\n    \n", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"15cf771f-22b1-4796-8e34-6c16f35d6506"}, {"SnippetId" :"ab5ab0ca-eb45-4851-affe-4690bb75d055"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"82ab58ca-79e8-47f9-8917-f444d3320751"}, "snpName": "RemotingDll", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n\n#define WEBSHARPER\n//#define FSS_SERVER\n\nopen System\nopen System.Net\nopen System.Text\nopen System.IO\nopen WebSharper\n//open WebSharper.Remoting\n//open WebSharper.JavaScript\n\n//#if FSS_SERVER\nlet sendRequestRpcEP     = \"RemotingDll:FSSGlobal.UsefulDotNet.sendRequest:-426626804\"\nlet awaitRequestForRpcEP = \"RemotingDll:FSSGlobal.UsefulDotNet.awaitRequestFor:-439983525\"\nlet replyToRpcEP         = \"RemotingDll:FSSGlobal.UsefulDotNet.replyTo:-1092841374\"\n//#else\n//let sendRequestRpcEP     = \"Remote:CIPHERPrototype.Messaging.sendRequest:1096816393\"\n//let awaitRequestForRpcEP = \"Remote:CIPHERPrototype.Messaging.awaitRequestFor:278590570\"\n//let replyToRpcEP         = \"Remote:CIPHERPrototype.Messaging.replyTo:-1092841374\"\n//#endif\n\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule Messaging =\n    let mutable Debug = true\n    \n    type AddressId = AddressId of string\n    \n    type Request = {\n        toId              : AddressId\n        fromId            : AddressId\n        content           : string\n        mutable messageId : Guid option\n    }\n    \n    type MBMessage =\n    | Listener of AddressId * (Request->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Request  of Request   * (string ->unit) * (exn->unit) * (OperationCanceledException->unit)\n    | Reply    of Guid      *  string\n    \n    type POMessage =\n    | POIdentification\n    | POEcho   of string\n    | POListeners\n    | POPendingRequests\n    | POPendingReplys\n    \n    type POResponse =\n    | POString  of string\n    | POStrings of string[]\n\nopen Messaging\n\nlet extract n (s:string) = s.Substring(0, min n s.Length)\nlet now() = System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\ntype PostOffice() =\n    let mutable listeners = [| |]\n    let mutable requests  = [| |]\n    let mutable sent      = [| |]\n    let agent = MailboxProcessor.Start(fun mail ->\n        async {\n            while true do\n                let! mbMsg = mail.Receive()\n                match mbMsg with\n                | Listener                  (listener, lfs, lfe, lfc)  ->\n                    if Messaging.Debug then printfn \"%s Listener:   %A\"       (now()) listener\n                    requests\n                    |> Seq.indexed\n                    |> Seq.tryPick (fun (i, (request , rfs, rfe, rfc)) -> \n                        if request.toId <> listener then None else\n                        requests <- Array.append requests .[0..i-1]  requests .[i+1..requests .Length - 1]\n                        if Messaging.Debug then printfn \"removed %d\" requests.Length\n                        Some(lfs, request, rfs))\n                    |> (fun v -> (if v.IsNone then \n                                    listeners <- \n                                        listeners \n                                        |> Array.filter(fun (lnr, lfs, exn, cen) -> \n                                            if lnr = listener then\n                                                //exn <| DivideByZeroException ()\n                                                //exn <| TimeoutException ()\n                                                lfs <| {\n                                                            toId      = AddressId \"\"\n                                                            fromId    = AddressId \"\"\n                                                            content   = \"{\\\"$\\\":0}\"\n                                                            messageId = None\n                                                        }\n                                                false\n                                            else true) \n                                        |> Array.append [| listener, lfs, lfe, lfc |]); v)\n                | Request                     (request , rfs, rfe, rfc)  ->\n                    if Messaging.Debug then printfn \"%s Request: %A %A %A\" (now()) request.toId request.fromId (extract 80 request.content)\n                    listeners\n                    |> Seq.indexed\n                    |> Seq.tryPick (fun (i, (listener, lfs, lfe, lfc)) -> \n                        if request.toId <> listener then None else \n                        listeners <- Array.append listeners.[0..i-1] listeners.[i+1..listeners.Length - 1]\n                        Some(lfs, request, rfs))\n                    |> (fun v -> if v.IsNone then requests  <- requests  |> Array.append <| [| request , rfs, rfe, rfc |]\n                                                  if Messaging.Debug then printfn \"appended %d\" requests.Length\n                                 v)\n                | Reply                       (reply   , response)  ->\n                    if Messaging.Debug then printfn \"%s Reply:   %s\"       (now()) (extract 100 response)\n                    sent\n                    |> Seq.indexed\n                    |> Seq.pick (fun (i, (request , rfs)) -> \n                        if request.messageId.Value <> reply then None else\n                        sent      <- Array.append sent     .[0..i-1] sent     .[i+1..sent     .Length - 1]\n                        rfs response\n                        Some ())\n                    None\n                |> Option.iter (fun (lfs, request, rfs) -> \n                    request.messageId <- Some <| Guid.NewGuid()\n                    sent <- sent |> Array.append [| request, rfs |]\n                    lfs request\n                )\n        }\n    )\n    with\n        member this.AwaitRequest    listener  fs fe fc = agent.Post <| Listener (listener, fs, fe, fc)\n        member this.SendRequest     request   fs fe fc = agent.Post <| Request  (request , fs, fe, fc) ; if Messaging.Debug then printfn \"SendRequest sent\"\n        member this.ReplyTo         request   response = agent.Post <| Reply    (request , response  )\n        member this.Listeners       ()                 = listeners |> Array.map (function | AddressId id, _, _, _ -> id)\n        member this.Requests        ()                 = requests  |> Array.map (sprintf \"%A\")\n        member this.Sent            ()                 = sent      |> Array.map (sprintf \"%A\")\n\nlet postOffice = PostOffice()\n\n[< Rpc >]\nlet awaitRequestFor (listener:AddressId) =\n    let startAsync (fs, fe, fc) = postOffice.AwaitRequest listener fs fe fc \n    Async.FromContinuations startAsync // ISSUE: fe & fc are never called even when there are exceptions\n\n[< Rpc >]\nlet replyTo    (reply:Guid) response =\n    async {\n        postOffice.ReplyTo reply response\n    }\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\n[< Rpc >]\nlet sendRequest  toId fromId content =\n    if toId = AddressId \"WebServer:PostOffice\" then\n        async {\n            let msg = Json.Deserialize<POMessage> content\n            return\n                match msg with\n                | POIdentification  -> POString     \"WebServer:PostOffice\"\n                | POEcho        txt -> POString     txt\n                | POListeners       -> POStrings <| postOffice.Listeners()\n                | POPendingRequests -> POStrings <| postOffice.Requests ()\n                | POPendingReplys   -> POStrings <| postOffice.Sent     ()\n                |> Json.Serialize \n        }\n    else\n    let startAsync (fs, fe, fc) = postOffice.SendRequest   \n                                    { toId      = toId   \n                                      fromId    = fromId \n                                      content   = content \n                                      messageId = None }\n                                    fs fe fc\n    async {\n        try \n            let! res = Async.FromContinuations startAsync // ISSUE: fe & fc are never called even when there are exceptions like timeout (this crashes FSharpStation!)\n            return res\n        with e -> \n            printfn \"%A\" e\n            return \"ERROR: exception\"\n    }\n\nlet RpcCall (url:string) method (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        req.Headers.Add(\"x-websharper-rpc\", method            )\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        //printfn \"RpcCallResponse %s\" (extract 100 msg)\n        let json   = JsonValue.Parse (if msg.[0] = '\"' then \"{\\\"$DATA\\\":\" + msg + \"}\" else msg)\n        return       json.[\"$DATA\"]\n    }\n\nlet serializeAddressId aId =\n    match aId with\n    | AddressId v -> sprintf \"\"\"{\"$\":0,\"$0\":\"%s\"}\"\"\" v\n\nlet sendRequestRpc (toId: AddressId) (fromId: AddressId) (content: string): Async<string> =\n    async {\n        let! msg =\n            [| serializeAddressId toId ; serializeAddressId fromId ; Json.Serialize content |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint sendRequestRpcEP\n        return msg.AsString()\n    }\n\nlet awaitRequestForRpc (listener:AddressId) =\n    async {\n        let! msg =\n            [| serializeAddressId listener |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint awaitRequestForRpcEP\n        let  v = msg.[\"$V\"]\n        let req    =\n            {\n                toId      = AddressId <| v?toId  .[\"$V\"].[\"$0\"].AsString()\n                fromId    = AddressId <| v?fromId.[\"$V\"].[\"$0\"].AsString()\n                content   = v?content                          .AsString()\n                messageId = Some <| v?messageId  .[\"$V\"].[\"$0\"].AsGuid  ()\n            }\n        return req\n    }\n\nlet replyToRpc (reply:Guid) response =\n    async {\n        let! msg =\n            [| sprintf \"\\\"%s\\\"\" <| reply.ToString() ; Json.Serialize response |]\n            |> String.concat \", \"\n            |> sprintf \"[%s]\"\n            |> RpcCall WebSharper.Remoting.EndPoint replyToRpcEP\n        return ()\n    }\n", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bc75b72d-7942-4ac8-a71f-fc290321b875"}, "snpName": "Ping", "snpContent": "open Useful\nopen System.Net.NetworkInformation\n\nlet ping (ip:string) =\n    let reply = (new Ping()).Send ip\n    reply.Status, reply.Address, reply.RoundtripTime\n    \nlet pingAsync (ip:string) =\n    async {\n        let pinger = new Ping()\n        try\n            let! reply = pinger.SendPingAsync(ip, 9000, \"Hello!\"B) |> Async.AwaitTask \n            return reply.Status.ToString(), reply.Address, reply.RoundtripTime, System.Text.Encoding.ASCII.GetString reply.Buffer\n        with e -> \n            return e.GetBaseException().GetBaseException().Message, System.Net.IPAddress(0L), 0L, \"\"\n    }\n\nlet pingOneAsync name ip =\n    async {\n        let! status, address, roundtripTime, buffer = pingAsync ip\n        return status, (name, ip), (address, roundtripTime, buffer)\n    }\n\nlet pingSeveral list = \n    list\n    |> Seq.sort\n    |> Seq.map (fun (n, ip) -> pingOneAsync n ip)\n    |> Seq.map (Async.map \n                   (function \n                    | \"Success\", (name, ip), (address, time, buffer) -> printfn \"Success %-15s %-15s %-25s %4d %s \"     name ip (address.ToString()) time buffer\n                    | msg      , (name, ip), (address, time, buffer) -> printfn \"%-15s %-15s %-15s %-25s \"  msg name ip (address.ToString())                 \n             ))\n    |> Async.Parallel \n    |> Async.RunSynchronously\n\n", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bff6817d-fe67-4777-9a13-50393e8900c4"}, "snpName": "ADB Android Debugger", "snpContent": "let removeBlankLines (s:string) = \n    s.Split '\\n'\n    |> Seq.filter ((<>) \"\")\n    |> String.concat \"\\n\"\n\nmodule Adb =\n//    let mutable path          = @\"C:\\Program Files (x86)\\Android\\android-sdk\\platform-tools\\adb.exe\"\n    let mutable path          = @\"D:\\Abe\\Downloads\\Android\\adb.exe\"    \n    let call command          = RunProcess.runToFinish     path command  |> removeBlankLines\n    let execOut      file cmd = RunProcess.runOutputToFile path <| sprintf \"exec-out %s\" cmd <| file\n    let connectIpPort ip port = call   <| sprintf \"connect %s:%d\" ip  port        \n    let connectIp     ip      = connectIpPort                         ip  5555        \n    let connectUSB         () = call    \"usb\"\n    let devices            () = call  \"devices\"\n    let pull      rfile lfile = call  <| sprintf \"pull \\\"%s\\\" \\\"%s\\\"\" rfile lfile\n    let shell             cmd = call  <| sprintf \"shell %s\"           cmd\n    let shellSU           cmd = shell <| sprintf \"su -c %s\"           cmd\n    let keyevent          key = shell <| sprintf \"input keyevent %d\"  key\n    let runApp            app = shell <| sprintf \"monkey -p %s 1\"     app            \n    let checkApp          app = shell <| sprintf \"ps | grep %s\"       app            \n    let ls                dir = shell <| sprintf \"ls -la %s\"          dir\n    let version            () = call    \"version\"\n    let reboot             () = call    \"reboot\"\n    let rebootByCmd        () = shellSU \"am start -a android.intent.action.REBOOT\"\n    let killServer         () = call    \"kill-server\"\n    let connectWifi        ip = printfn \"Connecting ADB via Wifi: \"; connectIp ip\n    let connectUSBMsg      () = printfn \"Connecting ADB via USB: \" ; connectUSB()\n    let runCheckApp     app   =\n        runApp          app |> ignore\n        let ps        = app |> checkApp\n        if  ps.Contains app \n        then \"IS RUNNING!!\"\n        else \"is not running at the moment.\"\n        |> printfn \"%s %s\" app\n    \n    let captureScreen local file =\n        shell <| \"screencap -p \" + local |> ignore\n        pull  local  file                |> ignore\n        //adb.Call <| sprintf \"exec-out screencap -p > \\\"%s\\\"\" file\n    \n    let captureScreen2 file = execOut file \"screencap -p\" \n    \n    let activateWifi () =\n        killServer  ()                                                           |> ignore\n        connectUSB  ()                                                           |> ignore\n        shellSU     \"setprop service.adb.tcp.port 5555 ; stop adbd ; start adbd\" |> ignore\n        killServer  ()                                                           |> ignore\n    \n    ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"555306ec-f8cc-455f-b01f-9d86fbb2682d"}, "snpName": "SSH.NET", "snpContent": "#r \"../packages/SSH.NET/lib/net40/Renci.SshNet.dll\"\nopen Useful\nopen Renci.SshNet\n\nlet getClient    ip (port:int) user (pwd    : string        ) = new SshClient(ip, port, user, pwd    )\nlet getClientRsa ip (port:int) user (keyfile: PrivateKeyFile) = new SshClient(ip, port, user, keyfile)\n\nlet doCmdW (client:SshClient) f cmd =\n    Wrap.wrapper {\n        do! Result.tryProtection()\n        if not client.IsConnected then\n            client.Connect()\n        use cmnd  = client.CreateCommand cmd\n        let! res   = Async.FromBeginEnd(cmnd.BeginExecute, cmnd.EndExecute)\n        let! res =\n            match res, cmnd.Error with\n            | \"\"  , \"\"   -> Result.succeed \"\"\n            | \"\"  , err  -> Result.fail               <| ErrSimple(err, false)\n            | res , \"\"   -> Result.succeed        res\n            | res , err  -> Result.succeedWithMsg res <| ErrSimple(err, false)\n        return f res\n    }\n    \nlet doCmdF client f =\n    doCmdW client f\n    >> Wrap.runSynchronouslyS false\n    >> printfn \"%s\"    \n    \nlet doCmd client = doCmdF client id\n    ", "snpParentIdO": {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpName": "FsStationShared", "snpContent": "#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule FsStationShared =\n", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"eb54ba64-3d11-4347-97c8-aeae9e3e3121"}, "snpName": "MessagingClient", "snpContent": "//#define FSS_SERVER\n\n//#if FSS_SERVER\nopen FSSGlobal.UsefulDotNet\nopen FSSGlobal.UsefulDotNet.Messaging\n#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n//#else\n\n//#r \"remote.dll\"\n//open CIPHERPrototype.Messaging\n//#endif\nopen WebSharper\nopen Useful\n//open UsefulFewJS\n//open UsefulFewJS.Messaging\n\n#if WEBSHARPER\n[< Inline \"true\" >]\n#endif          \nlet inJavaScript = false\n\nlet selectF fj fn =\n    match inJavaScript with\n    | true  -> fj\n    | false -> fn\n    \n#if WEBSHARPER\nlet AsyncStart asy     = Async.StartWithContinuations(asy, id, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))    \n[< Inline \"\" >]\nlet awaitRequestForRpc = awaitRequestForRpc\n[< Inline \"\" >]\nlet sendRequestRpc     = sendRequestRpc\n[< Inline \"\" >]\nlet replyToRpc         = replyToRpc\n#else\nlet AsyncStart asy     = Async.Start asy\n#endif          \n\nlet AddressId        = AddressId\nlet addressIdTxt     = function | AddressId txt -> txt\n\n#if FSS_SERVER\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestFor\nlet sendRequestF     = selectF sendRequest         sendRequest\nlet replyToF         = selectF replyTo                 replyTo\n#else\nlet awaitRequestForF = selectF awaitRequestFor awaitRequestForRpc\nlet sendRequestF     = selectF sendRequest         sendRequestRpc\nlet replyToF         = selectF replyTo                 replyToRpc\n#endif\nlet AsyncStartF      = selectF AsyncStart             Async.Start\n\n[< Inline \"WebSharper.Remoting.EndPoint()\" >]\nlet getEndPoint() = \"##FSHARPSTATION_ENDPOINT##\"\n\ntype MessagingClientx(clientId, ?timeout, ?endPoint:string) =\n    //do printfn \"%s %s\" WebSharper.Remoting.EndPoint clientId\n    let mutable active = true\n    let wsEndPoint     = endPoint    |> Option.defaultValue (getEndPoint())\n    let tout           = timeout     |> Option.defaultValue 100_000\n    let fromId         = AddressId clientId\n    do WebSharper.Remoting.EndPoint <- wsEndPoint \n    let awaitMessage respond =\n        async {\n            while active do\n                printfn \"%s awaitRequest %s %s\" (nowStamp()) clientId wsEndPoint\n                let! msgA  = Async.StartChild(awaitRequestForF fromId, tout)\n                try\n                    let! msg   = msgA\n                    let! resp  = respond (addressIdTxt msg.fromId) msg.content\n                    do!          replyToF msg.messageId.Value resp\n                with \n                | :? System.TimeoutException -> ()\n                | e                          -> printfn \"%A\" e\n        } \n        |> AsyncStartF\n    let sendMessage  toId msg = sendRequestF toId fromId msg\n    let poMsg checkResponse msg =\n        async {\n            let! resp = sendMessage (AddressId \"WebServer:PostOffice\") (Json.Serialize<POMessage> msg)\n            return checkResponse (Json.Deserialize<POResponse> resp)\n        }\n    let poString resp =\n                match resp with\n                | POString  v  -> v\n                | POStrings vs -> sprintf \"%A\" vs\n    let poStrings resp =\n                match resp with\n                | POString  v  -> [| sprintf \"unexpected response: %s\" v |]\n                | POStrings vs -> vs     \n    [<Inline>] \n    let respondMessageG respond fromId txt =\n        async {\n            printfn \"respondMessageG txt: %s\" txt\n            let  msg = Json.Deserialize txt \n            printfn \"respondMessageG msg: %A\" msg\n            let! res = respond fromId msg\n            return Json.Serialize res\n        }                \n    [<Inline>] \n    let sendMessageG toId msg =\n        async {\n            let! resp = sendMessage toId (Json.Serialize msg)\n            let  acr  = resp |> Json.Deserialize\n            return acr\n        }\n  with \n    member this.AwaitMessage  respond  = awaitMessage (fun senderId request -> async { return respond senderId request })\n    member this.AwaitMessage  respondA = awaitMessage respondA\n    member this.SendMessage  toId msg  = sendMessage  toId msg\n    [<Inline>] \n    member this.AwaitMessageG respondA = awaitMessage (respondMessageG respondA)\n    [<Inline>] \n    member this.SendMessageG toId msg  = sendMessageG toId msg\n    member this.POMessage        msg   = poMsg id          msg\n    member this.POListeners      ()    = poMsg poStrings   POListeners\n    member this.EndPoint               = wsEndPoint\n    member this.ClientId               = clientId\n    member this.Deactivate       ()    = active <- false\n    static member EndPoint_            = getEndPoint()\n    interface System.IDisposable with\n           member this.Dispose () = active <- false\n\ntype GenSeverity =\n    | GenError\n    | GenWarning\n    | GenInfor\n\ntype GenResponse =\n    | StringResponse   of string\n    | OpStringResponse of string option\n    | ResultResponse   of string option * (string * GenSeverity)[]\n\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2deb54e7-009e-4297-b2bc-1c86d04203a4"}, "snpName": "CodeSnippet", "snpContent": "open Useful\n\nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\ntype CodeSnippetId = CodeSnippetId of System.Guid   \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n     member this.Text  = match this with CodeSnippetId guid -> guid.ToString()\n\n[< NoComparison >]\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n    level        : int\n    levelCode    : int\n    properties   : System.Collections.Generic.Dictionary<string, string>\n} with\n    member this.Name = snippetName this.name this.content\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> this.id.Text + \" \" + c + \".fsx\")\n//    member this.ContentIndented addLinePrepos =\n//        let indent        = this.levelCode * 2\n//        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n//        let addLinePs     = if not addLinePrepos  then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |] \n//        this.content.Split('\\n') \n//        |> addLinePs\n//        |> separatePrepros (not addLinePrepos)\n//        |> indentF\n//      , indent\n\n// tail recursion does not optimize\nlet rec preds fetcher outs (ins : CodeSnippetId list) : CodeSnippetId list =\n    match ins with\n    | []         -> outs\n    | hd :: rest -> List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                    |> preds fetcher (if outs |> Seq.contains hd then outs else hd::outs)\n\nlet predsL fetcher (ins : CodeSnippetId list) : CodeSnippetId list =\n    let mutable ins  = ins \n    let mutable outs = []\n    while not ins.IsEmpty do\n        match ins with\n        | []         -> ()\n        | hd :: rest -> if outs |> Seq.contains hd then\n                            ins  <- rest\n                        else\n                            ins  <- List.collect id [ rest ; hd |> fetcher |> Option.toList |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            outs <- hd::outs\n    outs\n\ntype CodeSnippet with\n    member this.UniquePredecessors (fetcher: CodeSnippetId -> CodeSnippet option) = predsL fetcher [ this.id ]        \n    static member TryFindByKey  snps key = snps |> Seq.tryFind (fun snp        -> snp.id = key)\n    member this.SeparateCode addLinePrepos =\n        let noLinePre     = not addLinePrepos || this.properties.ContainsKey \"NoLinePre\"\n        let indent        = this.levelCode * 2\n        let indentF, prfx = if indent = 0         then (id, \"\") else (Array.map    (fun (l, pr) -> String.replicate indent \" \" + l, pr), sprintf\"(%d)\" indent)\n        let addLinePs     = if noLinePre          then  id      else  Array.append [| sprintf \"# 1 @\\\"%s%s\\\"\" prfx this.NameSanitized |]\n        let code, assembs, defines, prepIs, nowarns  =\n            this.content.Split('\\n') \n            |> addLinePs\n            |> separatePrepros (not addLinePrepos)\n            |> indentF\n            |> separateDirectives\n        [| this.NameSanitized, code.Length, indent |] , code, assembs, defines, prepIs, nowarns\n    static member AddSeps (lines1:(string*int*int)[], code1:string[], assembs1:string[], defines1:string[], prepIs1:string[], nowarns1:string[])\n                          (lines2:(string*int*int)[], code2:string[], assembs2:string[], defines2:string[], prepIs2:string[], nowarns2:string[]) =\n        Array.append lines1   lines2\n      , Array.append code1    code2\n      , Seq  .append assembs1 assembs2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append defines1 defines2 |> Seq.distinct |> Seq.toArray\n      , Seq  .append prepIs1  prepIs2  |> Seq.distinct |> Seq.toArray\n      , Seq  .append nowarns1 nowarns2 |> Seq.distinct |> Seq.toArray\n    static member ReducedCode  addLinePrepos (snippets: CodeSnippet seq) =\n        snippets\n        |> Seq.map(fun snp -> snp.SeparateCode addLinePrepos)\n        |> fun snps -> if snps |> Seq.isEmpty then seq [ [||],  [||],  [||],  [||],  [||],  [||] ] else snps\n        |> Seq.reduce CodeSnippet.AddSeps\n        |> fun (lines, code, assembs, defines, prepIs, nowarns) ->\n           (lines, code |> String.concat \"\\n\" |> Array.singleton, assembs, defines, prepIs, nowarns)\n    static member FinishCode addLinePrepos (lines:(string*int*int)[],code:string[], assembs:string[], defines:string[], prepIs:string[], nowarns:string[]) =\n        let config = defines |> Seq.sort |> Seq.map ((+)\"-d:\") |> String.concat \" \"\n        let part1  =\n          [ if config <> \"\" then yield \"////\" + config\n            yield! prepIs  |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n            yield! assembs |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n            yield! nowarns |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n          ]\n        Seq.append part1 code |> String.concat \"\\n\"\n      , lines \n        |> Seq.mapFold (fun firstLine (name, len, ind) -> (name, (ind, firstLine, firstLine + len)), firstLine + len) part1.Length\n        |> fst\n        |> Seq.toArray\n    static member CodeAndStarts   addLinePrepos (snippets:CodeSnippet seq) =\n        CodeSnippet.ReducedCode   addLinePrepos snippets\n        |> CodeSnippet.FinishCode addLinePrepos\n    static member CodeFsx         addLinePrepos snps = CodeSnippet.CodeAndStarts addLinePrepos snps |> fst\n//    static member CodeMerged  addLinePrepos (snippets: CodeSnippet seq) =\n//        let bySnippet = \n//            snippets\n//            |> Seq.map(fun snp -> \n//                let code, indent = snp.ContentIndented addLinePrepos\n//                snp, indent, code\n//            )\n//        (bySnippet, bySnippet |> Seq.collect (function _, _, code -> code))\n//    static member CodeParts addLinePrepos snippets =\n//        let bySnippet, merged                        = CodeSnippet.CodeMerged addLinePrepos snippets\n//        let code, assembs, defines, prepIs, nowarns  = separateDirectives merged\n//        let config = defines |> Seq.distinct |> Seq.sort |> Seq.map ((+)\"-d:\")             |> String.concat \" \"\n//        [   if config <> \"\" then yield \"////\" + config\n//            yield! prepIs  |> Seq.distinct             |> Seq.map (sprintf \"#I @\\\"%s\\\"\"    )\n//            yield! assembs |> Seq.distinct             |> Seq.map (sprintf \"#r @\\\"%s\\\"\"    )\n//            if addLinePrepos && (nowarns |> Seq.isEmpty |> not) then yield \"# 1 \\\"required for nowarns to work\\\"\"\n//            yield! nowarns |> Seq.distinct             |> Seq.map (sprintf \"#nowarn \\\"%s\\\"\")\n//        ], code, bySnippet\n//    static member CodeFsx0 addLinePrepos (cur, snippets) =\n//        let part1, part2, bySnippet = CodeSnippet.CodeParts addLinePrepos (Array.append snippets [| cur |])\n//        [ yield! part1 ; yield! part2 ] |> String.concat \"\\n\"\n\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}, {"SnippetId" :"b59aa3c7-13d9-4f78-98ea-307182bf4bd4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f6ebdffc-049c-4493-8de8-e32072419479"}, "snpName": "FSMessage,FSResponse", "snpContent": "type FSMessage =\n    | GetIdentification\n    | GenericMessage        of string\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetPredsById   of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippetPreds       of string []\n    | GetSnippet            of string []\n    | GetSnippetJSCode      of string []\n    | GetWholeFile\n    | RunSnippetUrlJSById   of CodeSnippetId * string\n    | RunSnippetUrlJS       of string []     * string\n    | RunActionCall         of name: string * action: string * parms: string[]\n\ntype FSSeverity =\n    | FSError\n    | FSWarning\n    | FSInfor\n\ntype FSResponse =\n    | IdResponse        of string\n    | StringResponse    of string option\n    | SnippetResponse   of CodeSnippet option\n    | SnippetsResponse  of CodeSnippet []\n    | StringResponseR   of string option * (string * FSSeverity)[]\n\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"2deb54e7-009e-4297-b2bc-1c86d04203a4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}, "snpName": "FsStationClient", "snpContent": "\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | msg                        -> false\n\ntype FsStationClient(clientId, ?fsStationId:string, ?timeout, ?endPoint) =\n    let fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let msgClient  = new MessagingClient(clientId, ?timeout= timeout, ?endPoint= endPoint)\n    let toId       = AddressId fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toList)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse   response =\n        match response with\n        | StringResponse (Some code)        -> Result.succeed code\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =    \n        match response with    \n        | SnippetsResponse snps             -> Result.succeed snps\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse  response =    \n        match response with    \n        | SnippetResponse  snp              -> Result.succeed snp\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        let msgser =  msg |> Json.Serialize\n        let respA  =  msgClient.SendMessage toId msgser\n        Wrap.wrapper {\n            let!   response = respA\n            let!   resp     = checkResponse (Json.Deserialize<FSResponse> response)\n            return resp\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg toId2  msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg toId   msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg toId  (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg toId  (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg toId  (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg toId  (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg toId  (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg toId   GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg toId  (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg toId  (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.RunActionCall   (name, act, parms     ) = sendMsg toId  (RunActionCall       (name, act, parms      ))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"eb54ba64-3d11-4347-97c8-aeae9e3e3121"}, {"SnippetId" :"f6ebdffc-049c-4493-8de8-e32072419479"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b5ce4e03-57ad-4ec2-a8f2-445831815f01"}, "snpName": "FsStationClient Save Extension", "snpContent": "//open CIPHERPrototype.Messaging\nopen Useful\nopen System.IO\n\nlet backupFile file = \n    try File.Delete(      file + \".bak\") ; printfn \"Deleted %s.bak\" file with _ -> ()\n    try File.Copy  (file, file + \".bak\") with _ -> ()\n\ntype FsStationClient with\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file, printMsg) =\n        Wrap.wrapper {\n            printMsg <| sprintf \"%s\" msgBefore\n            let! content = contentW\n            let fullName = Path.Combine(path, file)\n            backupFile fullName\n            File.WriteAllText(fullName, content)\n            printMsg <| sprintf \"Saved %s.\" fullName\n        } |> Wrap.runSynchronouslyS false |> printMsg\n    member this.Save(contentW:Wrap<string>, msgBefore, path, file) = this.Save(contentW, msgBefore, path, file, printfn \"%s\")\n    member this.SaveSnippetJS  path snippet = this.Save(this.RequestJSCode snippet, sprintf \"Compiling %s to JavaScript\" snippet, path, (snippet.Split '/' |> Seq.last) + \".js\" )\n    member this.SaveSnippetFsx path snippet = this.Save(this.RequestCode   snippet, sprintf \"Saving %s to F#\"            snippet, path, (snippet.Split '/' |> Seq.last) + \".fsx\")\n    member this.SaveWholeFile  path name    = this.Save(this.RequestWholeFile()   , sprintf \"Saving to %s.fsjson\"        name   , path, name + \".fsjson\"                        )\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}, {"SnippetId" :"b37f91be-7579-4fea-8263-bd10ec60f7e4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}, "snpName": "FsStationClient Compile Extension", "snpContent": "#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FsStationClient with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [ yield! msgs |> Array.map fSharpError2TranspilerError\n                                if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              ]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new RunProcess.ShellEx(@\"WsFsc.exe\", ops)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"15cf771f-22b1-4796-8e34-6c16f35d6506"}, {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}, {"SnippetId" :"9becc68c-9cc2-4f29-82df-e510d10226db"}, {"SnippetId" :"ab5ab0ca-eb45-4851-affe-4690bb75d055"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"ef053bdf-997b-49c8-a401-1611a568bd8a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"47912c89-9605-41df-9425-7facea3d6b50"}, "snpName": "WebSite", "snpContent": "#define WEBSHARPER\nopen WebSharper.Sitelets\nopen WebSharper.UI.Next.Server\n\ntype EndPoint = EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page( Html.html [ Html.body [ Html.h1 [ Html.text \"Hello Dolly\" ] ]])\n\nlet site = Application.MultiPage content\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2071bfaf-8f65-47a7-98e6-7ec138e9f905"}, "snpName": "SelfHostedServer", "snpContent": "#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n\n    [<EntryPoint>]\n    let Main args =\n        let rootDirectory, url =\n            match args with\n            | [| rootDirectory; url |] -> rootDirectory, url\n            | [| url                |] -> \"..\"         , url\n            | [|                    |] -> \"..\"         , \"http://localhost:9001/\"\n            | _ -> eprintfn \"Usage: WebServer ROOT_DIRECTORY URL\"; exit 1\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                                   , Sitelet             = Some site\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                |> ignore\n                let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n                let maxA = ref 0\n                let maxB = ref 0\n                listener.SetRequestProcessingLimits(1000, 1000)\n                listener.GetRequestProcessingLimits(maxA, maxB)\n                printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n                )\n        stdout.WriteLine(\"Serving {0}\", url)\n        stdin.ReadLine() |> ignore\n        0\n", "snpParentIdO": {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, "snpPredIds": [{"SnippetId" :"47912c89-9605-41df-9425-7facea3d6b50"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpName": "WSMessagingBroker", "snpContent": "#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule WSMessagingBroker =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}, "snpName": "WebSocket Messages", "snpContent": "#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper\nopen Useful\n\nlet MessageBrokerId  = \"<MessageBroker>\"\n\ntype Address = Address of address:string\nwith member this.txt = match this with Address txt -> txt\n\nlet MessageBrokerAddress = Address MessageBrokerId\n\n/// Requests made to Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerRequest = \n    | BRGetConnections  /// request for list of connections\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerReply = \n    | BRConnections  of string[]\n  //  | BRPleaseClose  \n\n[< NamedUnionCases \"type\" >]\ntype MessageType = \n    | MsgInformation             // does not expect a reply, payload may or may not be structured\n    | MsgRequest                 // expects a reply, structured payload\n    | MsgReply                   // structured payload.\n    | MsgFromBroker              // Payload is BrokerMessage. Only Broker should use this\n    | MsgRequestForId            // expects reply as Information with id\n    | MsgRequestForEcho          // expects reply as Information with same payload\n\n/// Replies from Message Broker\n[< NamedUnionCases \"type\" >]\ntype BrokerMessage = \n    | BMOk\n    | BMOnlyBrokerShouldUse\n    | BMDestinationNotFound of Address  \n    | BMWebSocketError      of string\n    | BMReceiverCantReply\n    | BMUnexpectedMsgType   of MessageType\n\n[< NamedUnionCases \"type\" >]\ntype Replier = \n    | NoReply\n    | Broker\n    | Receiver\n\n[< NamedUnionCases \"type\" >]\ntype MessageGeneric = {\n    from          : Address\n    destination   : Address\n    msgType       : MessageType\n    subtype       : string      // free short string that provides information to deserialize payload\n    id            : System.Guid\n    payload       : string\n    replier       : Replier\n}\n\n[< Inline >]\nlet inline processPayload f (payload:string) : string =\n    if payload = \"\" then Unchecked.defaultof<_> else Json.Deserialize payload\n    |> f\n    |> Json.Serialize\n            \n[<  Inline >]\nlet newMsgSerialized dst payload = {\n    from          = Address \"\"\n    destination   = dst\n    msgType       = MsgRequest\n    subtype       = \"\"\n    id            = System.Guid.NewGuid()\n    payload       = payload\n    replier       = NoReply\n}\n\n[< Inline >]\nlet inline payload        pl  msg = { msg with payload       = Json.Serialize pl }\nlet inline from           frm msg = { msg with from          = frm               }\nlet inline destination    dst msg = { msg with destination   = dst               }\nlet inline msgType        typ msg = { msg with msgType       = typ               }\nlet inline subtype        sub msg = { msg with subtype       = sub               }\nlet inline replier        rpl msg = { msg with replier       = rpl               }\nlet inline msgId          id  msg = { msg with id            = id                }\n\n[<  Inline >]\nlet inline newMsg dst payload = Json.Serialize payload |> newMsgSerialized dst\n\n[<  Inline >]\nlet inline msgPayload msg = Json.Deserialize msg.payload\n\nlet mapPayload f msg = { msg with payload = f msg.payload }\n\nlet inline makeReply msg =\n    msg\n    |> msgType MsgReply\n    |> replier NoReply\n\n[<  Inline >]\nlet inline respond pyld msg =\n    msg\n    |> makeReply\n    |> payload  pyld\n\ntype IServer =\n    abstract member Post  : MessageGeneric -> unit\n    abstract member Close : unit           -> unit\n\ntype CMessage<'C2S> = WebSharper.Owin.WebSocket.Client.Message<'C2S>\n", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e137b990-172b-4879-bc74-8650123b7a5d"}, "snpName": "StatefulAgent", "snpContent": "\ntype SMessage<'S2C> = WebSharper.Owin.WebSocket.Server.Message<'S2C>\n\n#if WEBSHARPER\n[< JavaScript false >]\n#endif\nmodule Broker =\n    open WebSharper\n    open WebSharper.Owin.WebSocket.Server\n    open Useful\n    open System.Collections.Generic\n    \n    type SomeState = {\n        info       : string\n    }\n    \n    type IClient =\n        abstract member Post : MessageGeneric -> unit\n        abstract member Ip   : unit           -> string\n        abstract member Id   : unit           -> string\n        abstract member Close: unit           -> unit\n\n    type BrokerAgent(_epWebSocket: WebSharper.Owin.WebSocket.Endpoint<MessageGeneric,MessageGeneric>) =\n#if FSS_SERVER                          \n        static let mutable fssWebSocketO : BrokerAgent option = None\n#endif\n        do printfn \"WebSocket server start\"\n        let connectionsFunc state action = async {\n            return \n                match action with\n                | Choice1Of2 (clientAddress, (uniqueId, client)) -> state |> Map.add clientAddress (uniqueId, client)\n                | Choice2Of2                  uniqueId           -> state |> Map.filter (fun _ (uid, _) -> uid <> uniqueId)\n          }\n        let connectionsAgent = Mailbox.foldNShare connectionsFunc Map.empty\n        let processBrokerRequest req = \n            match req with\n            | BRGetConnections -> connectionsAgent.State |> Map.toSeq |> Seq.map (fun (Address cl, _) -> cl) |> Seq.toArray |> BRConnections \n            \n        let respondFromBroker pyld msg =\n            msg\n            |> respond     pyld\n            |> msgType     MsgFromBroker\n            |> subtype     \"FromBroker\"\n\n        let post reply msg =\n            match connectionsAgent.State |> Map.tryFind msg.destination with\n            | None                      -> msg |> respondFromBroker (BMDestinationNotFound msg.destination) |> reply\n            | Some(_, clientTo:IClient) -> msg |> clientTo.Post\n            \n        let clientConnect (client: IClient) = async {\n            let clientId = client.Id()\n            printfn \"clientConnect: %A\" clientId\n            let uniqueId = System.Guid.NewGuid()\n            printfn \"New Connection from %s\" clientId                           \n            let clientAddress = Address clientId\n            connectionsAgent.State\n            |> Seq.filter(fun kp -> kp.Key = clientAddress)\n            |> Seq.iter  (fun (kp:KeyValuePair<_, _ * IClient>) -> \n                printfn \"Closing old connection from %s\" clientId\n                kp.Value \n                |> fun (_, conn) -> conn.Close()\n            )\n            connectionsAgent.Post (Choice1Of2(clientAddress, (uniqueId, client))) // add connection\n            \n            let reply msg = msg |> from MessageBrokerAddress |> destination clientAddress |> client.Post\n            let checkReply msg = if msg.replier = Broker then\n                                        msg |> respondFromBroker BMOk |> reply\n            let forward msg = msg |> from clientAddress |> post reply\n                              checkReply msg\n            let respondMsg (msg:MessageGeneric) =\n                checkReply msg\n                printfn \"%A\" msg\n                match msg.msgType with\n                | MsgInformation    -> printfn \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n                | MsgReply          -> printfn              \"Reply %s: %s\" msg.from.txt  msg.payload\n                | MsgRequest        -> msg |> respond (msgPayload msg  |> processBrokerRequest)  |> reply\n                | MsgRequestForId   -> msg |> respond  MessageBrokerId |> msgType MsgInformation |> reply\n                | MsgRequestForEcho -> msg |> mapPayload id            |> msgType MsgInformation |> reply\n                | MsgFromBroker     -> ()\n            let clientIp = client.Ip()\n            return Unchecked.defaultof<_>, fun state wsmsg -> async {\n                printfn \"Received message %A from %s - %s\" state clientIp clientId\n                match wsmsg with\n                | Message msg ->\n                    if   msg.msgType     = MsgFromBroker        then msg |> respondFromBroker BMOnlyBrokerShouldUse |> reply\n                    elif msg.destination = MessageBrokerAddress then respondMsg msg\n                    else                                             forward    msg     \n                    return state\n                | Error exn -> \n                    printfn \"Error in WebSocket server connected to %s - %s: %s\" clientIp clientId (exn.ToString())\n                    newMsg clientAddress (BMWebSocketError exn.Message) |> msgId System.Guid.Empty |> msgType MsgFromBroker |> msgType MsgFromBroker |> reply\n                    return state\n                | Close ->\n                    printfn \"Closed connection to %s - %s\" clientIp clientId\n                    connectionsAgent.Post (Choice2Of2 uniqueId) // remove connection\n                    return state\n            }\n        }\n        member this.Post msg = post (fun m -> dprintfn \"%s\" m.payload) msg\n        member this.Start (client : WebSocketClient<MessageGeneric,MessageGeneric>) =\n            clientConnect { new IClient with\n                                member this.Post v  = client.Post v\n                                member this.Ip()    = client.Connection.Context.Request.RemoteIpAddress\n                                member this.Id()    = client.Connection.Context.Request.Query \n                                                      |> KeyVal.tryGetValue  \"ClientId\" \n                                                      |> Option.bind         Array.tryHead \n                                                      |> Option.defaultValue \"\"\n                                member this.Close() = client.Connection.Close(System.Net.WebSockets.WebSocketCloseStatus.NormalClosure, null) |> Async.AwaitTask |> Async.Start\n                          }\n#if FSS_SERVER\n        static member FssWebSocketO                = fssWebSocketO\n        static member FssWebSocketO with set value = fssWebSocketO <- value\n        member this.ConnectLocal clientId receiver = \n            clientConnect { new IClient with\n                                member this.Post v  = receiver v \n                                member this.Ip()    = \"(server)\"\n                                member this.Id()    = clientId\n                                member this.Close() = () // probably shouldn't be called at all\n                          }\n\n    let ConnectStatefulFSS uri clientId (f:IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) =\n        async {\n            match BrokerAgent.FssWebSocketO with \n            | None -> raise (exn \"FssWebSocketO is not set\")\n            | Some serverP ->\n            let  mutable clientBoxO : MailboxProcessor<CMessage<MessageGeneric>> option = None\n            let  receiver msg                = clientBoxO |> Option.iter (fun cbox -> cbox.Post (CMessage.Message msg))\n            let! brokerInitState, brokerFunc = serverP.ConnectLocal clientId receiver\n            let  brokerBox                   = Mailbox.foldA brokerFunc brokerInitState\n            let! clientInitState, clientFunc = f { new IServer with\n                                                       member this.Post msg = brokerBox.Post (Owin.WebSocket.Server.Message msg)\n                                                       member this.Close()  = ()\n                                                 }\n            let  clientBox    = Mailbox.foldA clientFunc clientInitState\n            clientBoxO <- Some clientBox\n            clientBox.Post CMessage.Open\n        }\n#endif        \n        \n        ", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}, {"SnippetId" :"aa485846-7b78-4ca8-ae22-84ba0c42d962"}, {"SnippetId" :"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"47bcdd6d-e61b-4884-bd1a-c30702c9508c"}, "snpName": "MessagingBroker", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net45\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\nopen WebSharper.UI.Server\n    \n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9050\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    //printfn \"Starting, hit <Enter>...\" ; stdin.ReadLine() |> ignore\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some (WebSharper.Application.MultiPage(fun _ _ -> Content.Page []))\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = 500000)\n            |> ignore\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"e137b990-172b-4879-bc74-8650123b7a5d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9c253bae-ab8b-4c99-b7e5-38fc50756bec"}, "snpName": "ClientWebSocket .Net", "snpContent": "//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Main.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Collections.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.InterfaceGenerator.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.JQuery.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.JavaScript.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Web.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Sitelets.dll\"\n//#r @\"..\\packages\\WebSharper\\lib\\net40\\WebSharper.Control.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n\nopen System\nopen System.Threading\nopen System.Net.WebSockets\nopen WebSharper\nopen Useful\n\n#if WEBSHARPER\n[< JavaScript false >]\n#endif\nmodule Client =\n    let startStateFull receive initAndfolder =\n        async {\n            let! initState, folder = initAndfolder\n            let agentBox = Mailbox.foldA folder initState\n            let finish a = agentBox.Post CMessage.Close ; printfn \"%A\" a\n            let error  a = agentBox.Post CMessage.Error ; finish a\n            Async.StartWithContinuations(receive agentBox, finish, error, error)\n        }\n\n    type WebSocketServer<'S2C, 'C2S>(uri:string) =\n        let conn = new ClientWebSocket()\n        let chunkSize = 8192\n        let send (txt:string)  =\n            async {\n                let buffer = System.Text.Encoding.UTF8.GetBytes txt\n                let chunks = buffer.Length / chunkSize\n                for i = 0 to chunks do\n                    let last = i = chunks\n                    let size = if last then buffer.Length % chunkSize else chunkSize\n                    do! conn.SendAsync(new ArraySegment<byte>(buffer, i * chunkSize, size), WebSocketMessageType.Binary, last, CancellationToken.None) |> Async.AwaitTask\n            }\n        let receive (receiverBox:MailboxProcessor<CMessage<'S2C>>) =\n            let buffer : byte[] = Array.create chunkSize 0uy\n            let builder         = System.Text.StringBuilder()\n            let keepgo          = ref true\n            async {\n                receiverBox.Post CMessage.Open\n                while conn.State = WebSocketState.Open && !keepgo do\n                    let! result = conn.ReceiveAsync(ArraySegment buffer, CancellationToken.None) |> Async.AwaitTask\n                    match result.MessageType with\n                    | WebSocketMessageType.Close -> keepgo := false\n                    | WebSocketMessageType.Text ->\n                        let txt = System.Text.Encoding.UTF8.GetString buffer.[0..result.Count - 1]\n                        builder.Append txt |> ignore\n                        if result.EndOfMessage then\n                            let txt = builder.ToString()\n                            builder.Clear() |> ignore\n                            Json.Deserialize txt |> CMessage.Message |> receiverBox.Post\n                    | _ -> ()\n                return \"WebSocketServer receive Closed.\"\n            }\n        let brokerBox = Mailbox.iterA (Json.Serialize >> send)\n        let connect f =\n            async {\n                dprintfn \"Connecting %s\" uri\n                do! conn.ConnectAsync(new Uri(uri), CancellationToken.None) |> Async.AwaitTask\n                dprintfn \"Connected %A\" WebSocketState.Open\n                do! startStateFull receive f\n            }\n        member this.WebSocket        = conn\n        member this.Post (msg: 'C2S) = brokerBox.Post msg\n        member this.Connect          = connect\n\n    let ConnectStateful<'S2C, 'C2S> uri agent =\n        async {\n            let  server          = WebSocketServer uri\n            do!  server.Connect (agent server)\n            return server\n        }\n\n    let ConnectStatefulFS uri clientId (f:IServer -> _) =\n        let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n        let func (serverP:WebSocketServer<MessageGeneric, MessageGeneric>) =\n            f { new IServer with\n                  member this.Post  v = serverP.Post v\n                  member this.Close() = serverP.WebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None) \n                                        |> Async.AwaitTask |> Async.RunSynchronously            \n               }\n        ConnectStateful uri2 func\n        |> Async.map ignore\n        ", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"aa485846-7b78-4ca8-ae22-84ba0c42d962"}, {"SnippetId" :"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}, "snpName": "WSMessagingClient", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen System\nopen Useful\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\n//#define FSS_SERVER\n//#define WEBSHARPER\n\ntype  Server = WebSocketServer<MessageGeneric,MessageGeneric>\n\ntype ClientTypeFSharp    = FSharp\n#if WEBSHARPER\ntype ClientTypeFSStation = FSStation\ntype ClientTypeJScript   = JScript\n\n[< Inline >]\nlet ConnectStatefulJS uri clientId (f:IServer -> Async<'state * ('state -> CMessage<MessageGeneric> -> Async<'state>)>) =\n    let uri2 = sprintf \"ws://%s?ClientId=%s\" uri clientId\n    let func (serverP:WebSocketServer<MessageGeneric,MessageGeneric>) =\n        f { new IServer with\n              member this.Post  v = serverP.Post v\n              member this.Close() = serverP.Connection.Close 1000 // Normal Closure\n           }\n    let  endPoint = Endpoint.CreateRemote(uri2, JsonEncoding.Readable)\n    ConnectStateful endPoint func\n    |> Async.map ignore\n#endif\n\ntype ErrBroker(bm : BrokerMessage) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = sprintf \"%A\" bm\n        member this.IsWarning: bool   = false\n\nmodule ReplyHandler =\n    type WaitForReplyMsg =\n        | Add    of Guid * ((MessageGeneric -> unit) * (exn -> unit) * (OperationCanceledException -> unit))\n        | Reply  of Guid *   MessageGeneric\n        | Excpn  of Guid *   exn\n        | Cancel of Guid *   OperationCanceledException\n        \n    type Handler (defProc) =\n        let waitingAgent =    \n            Mailbox.fold (fun waitingForReply action ->\n                let exec key f def  = Map.tryFind key     waitingForReply |> Option.map f |> Option.defaultWith def\n                                      Map.remove  key     waitingForReply\n                match action with\n                | Add   (key, fns) -> Map.add     key fns waitingForReply\n                | Reply (key, msg) -> exec        key (fun (f,_,_) -> f msg) (fun () -> defProc msg)\n                | Excpn (key, exn) -> exec        key (fun (_,f,_) -> f exn)  ignore\n                | Cancel(key, cnl) -> exec        key (fun (_,_,f) -> f cnl)  ignore\n            ) Map.empty\n        member __.Add    key fns = Add   (key, fns) |> waitingAgent.Post\n        member __.Reply  key msg = Reply (key, msg) |> waitingAgent.Post\n        member __.Raise  key exn = Excpn (key, exn) |> waitingAgent.Post\n        member __.Cancel key cnl = Cancel(key, cnl) |> waitingAgent.Post\n\n[< Inline \"window.location.href\" >]\nlet getEndPoint() = \n#if FSS_SERVER\n    \"No Endpoint required, should use WSMessagingClient with FSStation parameter not FSharp\"\n#else\n    \"##FSHARPSTATION_ENDPOINT##\"\n#endif\n\nlet extractEndPoint() = \n    let ep : string = getEndPoint()\n    let ep2 = ep.Substring(ep.IndexOf \"//\" + 2)\n    ep2.Split('/').[0]\n\ntype WSMessagingClient(connectStateful: string -> string -> (IServer -> Async<int * (int -> CMessage<MessageGeneric> -> Async<int>)>) -> Async<unit>\n        , clientId:string, ?timeout:int, ?endPoint:string) =    \n    let wsEndPoint    = defaultArg endPoint (extractEndPoint() + \"/ws\")\n    let clientAddress = Address clientId\n    let wsTimeout     = defaultArg timeout 60000\n\n    let mutable out = printfn \"%s\"\n    //let printoutfn out     = 0 // just to catch printoutfn out that should not be around \n    let mutable serverO : IServer option = None\n    let mutable payloadProcessorO : (string -> Wrap<string>) option = None\n    let waiting = ReplyHandler.Handler (fun msg -> printoutfn out \"Reply from '%s': %s\" msg.from.txt msg.payload)\n\n    let reply msg = serverO |> Option.iter (fun server -> msg |> from clientAddress |> destination msg.from |> server.Post)\n    let close ()  = serverO |> Option.iter (fun server -> server.Close() ; serverO <- None                                )\n\n    let processReply      msg = waiting.Reply msg.id msg\n    let mapPayloadWrap (fW: _ -> Wrap<_> ) msg =\n        Wrap.wrap {\n            let! r = fW msg.payload\n            return msg |> mapPayload (fun _ -> r)\n        }\n    let processMessage msg =\n        dprintfn \"%A\" msg\n        match msg.msgType with\n        | MsgFromBroker     \n        | MsgReply          -> processReply msg\n        | MsgInformation    -> printoutfn out \"Information from '%s': %s\" msg.from.txt (msgPayload msg)\n        | MsgRequest        -> match payloadProcessorO with \n                               | None           -> if msg.replier = Receiver then () // requires a reply but cannot give one, ask broker to handle it\n                               | Some processor ->\n                               msg |> mapPayloadWrap processor |> Wrap.map  (makeReply >> reply) |> Wrap<unit>.Start\n        | MsgRequestForEcho -> msg |> mapPayload     id        |> msgType MsgInformation |> reply\n        | MsgRequestForId   -> msg |> respond        clientId  |> msgType MsgInformation |> reply\n    \n    let connectToWebSocketServer() =\n        dprintfn \"in connectToWebSocketServer\"\n        async {\n            do! connectStateful wsEndPoint clientId <| fun (server: IServer) -> async {\n                return 0, fun state wsmsg -> async {\n                    try match wsmsg with\n                        | CMessage.Message msg -> processMessage msg\n                        | CMessage.Open        -> printoutfn out \"WebSocket %s connection open.\"   clientId ; serverO <- Some server\n                        | CMessage.Close       -> printoutfn out \"WebSocket %s connection closed.\" clientId ; close()\n                        | CMessage.Error       -> printoutfn out \"WebSocket %s connection error!\"  clientId\n                    with e -> printfn \"msg: %A \\nexn:%A\" wsmsg e \n                    return state\n                }\n            }\n            dprintfn \"connectToWebSocketServer with server\"\n            \n        }\n\n    let checkServer = Mailbox.callA ( fun () -> async {\n        dprintfn \"getServer\"\n        if serverO.IsNone then\n            dprintfn \"getServer Connecting\"\n            do! connectToWebSocketServer()\n            do! Async.Sleep 200\n        return serverO |> Result.fromOption (ErrSimple(\"could not connect to Server\", false))\n    })        \n\n    let getServer() : Wrap<IServer> =\n        Wrap.wrap {\n            let! serverA = checkServer.PostAndAsyncReply(fun reply -> reply, ())\n            let! server  = serverA\n            return server\n        }\n        \n    let postR (server: IServer) rpl msg = \n        let m = msg |> from clientAddress |> replier rpl \n        try       server.Post m\n        with e -> serverO <- None\n                  raise e\n\n    let sendAndForget msg =\n        Wrap.wrap {\n            let! server = getServer()\n            msg |> postR server NoReply\n        }\n        \n    let sendAndReply rpl msg =\n        Wrap.wrap {\n            let! server  = getServer()\n            let  replyA  = Async.FromContinuations(fun fns -> \n                waiting.Add msg.id fns\n                msg |> postR server rpl\n                if wsTimeout > 0 then\n                    async {\n                        do! Async.Sleep wsTimeout\n                        waiting.Raise msg.id (TimeoutException(sprintf \"Did not receive reply in %d seconds for Message: %A\" (wsTimeout / 1000) msg) :> exn)\n                    } |> Async.Start\n            )\n            let! reply   = replyA\n            return reply\n        }\n        \n    let sendAndVerify msg =\n        Wrap.wrap {\n            let! reply   = sendAndReply Broker msg \n            do!  match reply.msgType with\n                 | MsgFromBroker  -> let  bm = msgPayload reply\n                                     if   bm = BMOk \n                                     then Result.succeed () \n                                     else Result.fail (ErrBroker bm)\n                 | _              ->      Result.fail (ErrBroker (BMUnexpectedMsgType reply.msgType))\n        }\n    \n    let sendGetReply msg =\n        Wrap.wrap {\n            let! reply   = sendAndReply Receiver msg \n            let! result =\n                match reply.msgType with\n                | MsgReply      -> Result.succeed reply.payload\n                | MsgFromBroker -> let bm = msgPayload reply\n                                   Result.fail (ErrBroker bm)\n                | _             -> Result.fail (ErrBroker (BMUnexpectedMsgType reply.msgType))\n            return result\n        }\n\n    let getListeners() =\n        Wrap.wrap {\n            let  msg    = newMsg MessageBrokerAddress BRGetConnections\n            let! reply  = sendGetReply msg\n            match Json.Deserialize<BrokerReply> reply with\n            | BRConnections listeners -> return listeners\n            //| _ -> ()\n        } \n        \n    let sendMsg msg =\n        Wrap.wrap {\n            if msg.replier = NoReply\n            then do!     sendAndForget msg\n                 return  \"\"\n            else return! sendGetReply  msg\n        }\n    member this.MBListeners            = getListeners()\n    member this.EndPoint               = wsEndPoint\n    member this.ClientId               = clientId\n    member this.SendMsg           msg  = sendMsg msg\n    [<  Inline >]\n    member this.SendAndForget dst pyld = newMsg dst pyld |> sendAndForget\n    [<  Inline >]\n    member this.SendAndVerify dst pyld = newMsg dst pyld |> sendAndVerify\n    [<  Inline >]\n    member this.SendGetReply  dst pyld = newMsg dst pyld |> sendGetReply  |> Wrap.map Json.Deserialize\n    member this.Out with set fout      = out <- fout\n    [<  Inline >]\n    member this.ProcessIncoming   pro  = payloadProcessorO <- Some (Json.Deserialize >> pro >> (Wrap.map Json.Serialize))\n                                         newMsg MessageBrokerAddress \"Registering Processor\" \n                                         |> msgType MsgInformation\n                                         |> sendAndForget |> Wrap<unit>.Start\n    interface IDisposable with\n        member this.Dispose() = close()\n\n#if FSS_SERVER   \n    [< JavaScript false >]\n    new (clientId:string, FSStation, ?timeout, ?endPoint) = new WSMessagingClient(Broker.ConnectStatefulFSS, clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n#if WEBSHARPER\n    [< JavaScript false >]\n    new (clientId:string, FSharp   , ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(       ConnectStatefulJS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#else    \n    new (clientId:string,            ?timeout, ?endPoint) = new WSMessagingClient(Client.ConnectStatefulFS , clientId, ?timeout = timeout, ?endPoint = endPoint)\n#endif\n\n", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"9c253bae-ab8b-4c99-b7e5-38fc50756bec"}, {"SnippetId" :"b95ef4c5-ca1b-443a-acad-ca8158403d8b"}, {"SnippetId" :"e137b990-172b-4879-bc74-8650123b7a5d"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, "snpName": "FStationMessaging", "snpContent": "open FsStationShared\n\ntype FsStationClientErr =\n    | FSMessage             of string * FSSeverity\n    | ``Snippet Not Found`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = \n            match this with \n            | FSMessage (msg, sev    )   -> sprintf \"%A %s\" sev msg\n            | msg                        -> sprintf \"%A\"        msg\n        member this.IsWarning =     \n            match this with \n            | FSMessage (_  , FSError)   -> true\n            | _msg                       -> false\n\ntype FStationMessaging(msgClient:WSMessagingClient, _clientId, ?fsStationId:string) =\n    let mutable fsIds      = fsStationId |> Option.defaultValue \"##FSHARPSTATION_ID##\"\n    let         toId()     = Address fsIds\n    let stringResponseR response =\n        match response with\n        | StringResponseR (Some code, msgs) -> Result.succeedWithMsgs code (msgs |> Seq.map (fun v -> FSMessage v :> ErrMsg) |> Seq.toArray)\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let stringResponse   response =\n        match response with\n        | StringResponse (Some code)        -> Result.succeed code\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetsResponse response =    \n        match response with    \n        | SnippetsResponse snps             -> Result.succeed snps\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    let snippetResponse  response =    \n        match response with    \n        | SnippetResponse  snp              -> Result.succeed snp\n        | _                                 -> Result.fail    (``Snippet Not Found`` <| response.ToString()) \n    [< Inline >]\n    let sendMsg toId (msg: FSMessage) (checkResponse: FSResponse -> Result<'a>) =\n        Wrap.wrap {\n            let!   res   = msgClient.SendGetReply toId msg\n            let!   check = checkResponse res\n            return check\n        } \n  with \n    member this.SendMessage     (toId2,  msg:FSMessage) = sendMsg  toId2    msg    Result.succeed   \n    member this.SendMessage     (        msg:FSMessage) = sendMsg (toId())  msg    Result.succeed   \n    member this.RequestSnippet  (    snpPath:string   ) = sendMsg (toId()) (GetSnippet          (snpPath.Split '/'     ))    snippetResponse  \n    member this.RequestCode     (    snpPath:string   ) = sendMsg (toId()) (GetSnippetCode      (snpPath.Split '/'     ))    stringResponse   \n    member this.RequestJSCode   (    snpPath:string   ) = sendMsg (toId()) (GetSnippetJSCode    (snpPath.Split '/'     ))    stringResponseR  \n    member this.RequestPreds    (    snpPath:string   ) = sendMsg (toId()) (GetSnippetPreds     (snpPath.Split '/'     ))    snippetsResponse \n    member this.RequestPredsById(      snpId          ) = sendMsg (toId()) (GetSnippetPredsById  snpId                  )    snippetsResponse \n    member this.RequestWholeFile(                     ) = sendMsg (toId())  GetWholeFile                                     stringResponse   \n    member this.GenericMessage  (        txt:string   ) = sendMsg (toId()) (GenericMessage       txt                    )    stringResponse   \n    member this.RunSnippet      (url,snpPath:string   ) = sendMsg (toId()) (RunSnippetUrlJS     (snpPath.Split '/', url))    stringResponseR\n    member this.RunActionCall   (name, act, parms     ) = sendMsg (toId()) (RunActionCall       (name, act, parms      ))    stringResponseR\n    member this.FSStationId                             = fsIds\n    member this.FSStationId with set id                 = fsIds <- id\n    member this.MessagingClient                         = msgClient    \n    static member FSStationId_                          = \"##FSHARPSTATION_ID##\"\n#if FSS_SERVER   \n    [< JavaScript false >]\n    new (clientId, FSStation, ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId, FSStation, ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n#endif\n    [< JavaScript false >]\n#if WEBSHARPER\n    new (clientId, FSharp   , ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId, FSharp   , ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n#endif    \n    new (clientId,            ?fsStationId:string, ?timeout, ?endPoint) = FStationMessaging(new WSMessagingClient(clientId,            ?timeout= timeout, ?endPoint= endPoint), clientId, ?fsStationId = fsStationId)\n\n\n", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}, {"SnippetId" :"f6ebdffc-049c-4493-8de8-e32072419479"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}, "snpName": "FSCompilerDll", "snpContent": "#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype CodeSnippet with\n    static member PrepareCompileOptions (options1: CompOptions) (snps: CodeSnippet seq) =\n        let  addLinePrepos =  options1.Contains \"++removelinedirectives\" |> not\n        let  lines, code, assembs, defines, prepoIs, nowarns = CodeSnippet.ReducedCode addLinePrepos snps\n        let  options2      = prepOptions options1 (code, assembs, defines, prepoIs, nowarns)\n        options2\n\ntype FStationMessaging with\n    member this.PrepareCompileOptions(options1) = \n        Wrap.wrapper {\n            let  snpPath   = options1?Snippet\n            let!   preds   = this.RequestPreds snpPath\n            let    options = CodeSnippet.PrepareCompileOptions options1 preds\n            return options\n        }\n    member this.CompileFSharpW(options:CompOptions) = \n        Wrap.wrapper {\n            let! msgs, exit = options.Get CompOptions.FSharpOptions \n                              |> Array.append [| \"IGNORED_Fsc.exe\" |] \n                              |> FSharpChecker.Create().Compile\n            let  errs       = [| yield! msgs |> Array.map fSharpError2TranspilerError\n                                 if exit <> 0 && (exit <> 1 || msgs.Length = 0) then yield ErrSimple (sprintf \"ExitCode: %d\" exit, false) :> ErrMsg\n                              |]\n            let! res        = if   exit <> 0\n                              then Result.failWithMsgs                errs\n                              else Result.succeedWithMsgs \"Compiled!\" errs\n            return res\n        }\n    member this.CompileWebSharperW(options:CompOptions) : Wrap<string> =\n        Wrap.wrapper {\n            if options.Contains opWebSite then\n                let  site     = options?Website\n                if options.Contains \"++createdirectory\"     then Directory.CreateDirectory(site) |> ignore\n            let! res          = options.Get CompOptions.WSharperOptions\n                                 |> Seq.map (sprintf \"%A\")\n                                 |> String.concat \"  \"\n                                 |> fun ops -> (new RunProcess.ShellEx(@\"WsFsc.exe\", ops, priorityClass = System.Diagnostics.ProcessPriorityClass.RealTime)).StartAndWaitR()\n            return if res = \"\" then \"Compiled!\" else res\n        }\n    member this.CompileSnippetW options  = \n        Wrap.wrapper {\n            let  snpPath      = options?Snippet\n            let  config       = options?Config\n            let  directory    = options?Directory\n            do   Directory.CreateDirectory(directory) |> ignore\n            let! options2     = this.PrepareCompileOptions options\n            let  compiler     = if options2.Contains \"++websharper:1\" then this.CompileWebSharperW else this.CompileFSharpW\n            let! res          = compiler options2\n            if options2.Contains \"++copyassemblies\" then copyIfMustToDir        \"FSharp.Core.dll\"          directory\n            if options2.Contains \"++copyconfig\"     then copyIfNotExistsToFile  \"FSharpStation.exe.config\" config\n            return res\n        }\n        \n", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"9becc68c-9cc2-4f29-82df-e510d10226db"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"ef053bdf-997b-49c8-a401-1611a568bd8a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a044767b-4c0d-4527-9bad-c4633469f216"}, "snpName": "compile & run Messaging Broker", "snpContent": "open System.IO\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options      = compileOptionsExeDebug \"FSSGlobal/F# Code/WSMessagingBroker/MessagingBroker\"\n                        + (opGenInternal /= \"showoptions\")\n    let! res          = FStationMessaging(\"compile & run Messaging Broker\", FSharp).CompileSnippetW options\n    do   printfn        \"Starting MessagingBroker.exe\"\n    do   startProcess   options?Output \"\" |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b6577554-e62e-41ed-983e-d4dd12e3512f"}, "snpName": "FSAutoCompleteIntermediary", "snpContent": "module FSAutoCompleteIntermediary =\n", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"319e0842-b83e-4036-9f57-602ca4a30ac5"}, "snpName": "FSAutocompleteCall", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Useful\nopen Useful.Result\nopen Newtonsoft.Json\n\nopen Utils\n\n#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule CommTypes =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n    \n    type ACMessage =\n    | ACMIdentification\n    | ACMEcho             of string\n    | ACMToolTip          of string * int * int\n    | ACMToolTip2         of string * int * int *  string\n    | ACMSignature        of string * int * int\n    | ACMSignature2       of string * int * int *  string\n    | ACMFindDeclaration  of string * int * int\n    | ACMFindDeclaration2 of string * int * int *  string\n    | ACMComplete         of string * int * int *  string\n    | ACMComplete2        of string * int * int *  string *  string\n    | ACMParse            of string * string    * (string * (int * int * int)) []\n    | ACMMustParse        of string * string\n\nopen CommTypes\n\ntype ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\ntype DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\ntype CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\ntype PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\ntype ProjectRequest       = { FileName  : string                                                                                                               }\ntype LintRequest          = { FileName  : string                                                                                                               }\ntype HelptextRequest      = { Symbol    : string                                                                                                               }\ntype WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n\ntype FARequest =\n    | FarParse         of ParseRequest         \n    | FarDeclarations  of DeclarationsRequest  \n    | FarCompletion    of CompletionRequest    \n    | FarPosition      of PositionRequest      \n    | FarProject       of ProjectRequest       \n    | FarLint          of LintRequest          \n    | FarHelptext      of HelptextRequest      \n    | FarWorkspacePeek of WorkspacePeekRequest    \nwith\n  member this.Json =\n    match this with \n    | FarParse         data -> JsonConvert.SerializeObject data \n    | FarDeclarations  data -> JsonConvert.SerializeObject data \n    | FarCompletion    data -> JsonConvert.SerializeObject data \n    | FarPosition      data -> JsonConvert.SerializeObject data \n    | FarProject       data -> JsonConvert.SerializeObject data \n    | FarLint          data -> JsonConvert.SerializeObject data \n    | FarHelptext      data -> JsonConvert.SerializeObject data \n    | FarWorkspacePeek data -> JsonConvert.SerializeObject data    \n\nlet fromJson<'a> json = JsonConvert.DeserializeObject(json, typeof<'a>) :?> 'a\nlet jsonData2Obj item = item?Data.ToString() |> fromJson\n\nlet HttpRequestCall (url:string) (data:string) =\n    async {\n        //printfn \"RpcCall %s\" (extract 100 data)\n        let req = WebRequest.Create(url) :?> HttpWebRequest \n        req.Timeout         <- 300_000\n        req.ProtocolVersion <- HttpVersion.Version10\n        req.Method          <- \"POST\"\n        req.ContentType     <- \"application/json\"\n        let postBytes = Encoding.ASCII.GetBytes(data)\n        //printfn \"<---\\n%s\\n\" data\n        req.ContentLength <- int64 postBytes.Length\n        let reqStream = req.GetRequestStream() \n        reqStream.Write(postBytes, 0, postBytes.Length);\n        reqStream.Close()\n        \n        // Obtain response and download the resulting page \n        // (The sample contains the first & last name from POST data)\n        use resp   = req.GetResponse() \n        use stream = resp.GetResponseStream() \n        use reader = new StreamReader(stream)\n        let msg    = reader.ReadToEnd()\n        printfn \"\\n----> \\n%s\\n\" (extract 100 msg)\n        let jsonV  = JsonValue.Parse msg\n        return       jsonV\n    }\n\nlet KindError msg = KError { Code = 0 ; Message = msg }\n\nlet json2Kind (v:JsonValue) = \n    let item =JsonValue.Parse <| v.AsString()\n    match item?Kind.AsString() with\n    | \"info\"             -> jsonData2Obj item |> KInfo\n    | \"error\"            -> jsonData2Obj item |> KError\n    | \"errors\"           -> jsonData2Obj item |> KErrors\n    | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n    | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n    | \"completion\"       -> jsonData2Obj item |> KCompletion\n    | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n    | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n    | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n    | _                  -> KindError <| v.ToString()\n\nlet UrlAddress = \"http://localhost:9001/\"\n\nlet FSAutocompleteCall cmd f (req: FARequest) =\n    Wrap.wrapper {\n        let  data         = req.Json\n        let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n        let  several      = jsonV.AsArray() |> Array.map json2Kind\n        let  good, others = several |> Array.partition f\n        let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toArray\n        let! result       = Result (Seq.tryHead good, msgs) \n        return result\n    } \n\nlet parseCode file code =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"parse\" (function | KErrors _ -> true | _ -> false) <|\n                             FarParse\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   IsAsync    = true   \n                                   Lines      = code           \n                                   Version    = 0\n                                 }\n        return result\n    } \n\nlet toolTip file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"tooltip\" (function | KToolTip _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet signature file lin col filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"signatureData\" (function | KSignatureData _ -> true | _ -> false) <|\n                             FarPosition\n                                 { FileName   = System.IO.Path.GetFullPath file\n                                   Line       = lin         \n                                   Column     = col\n                                   Filter     = filter\n                                 }\n        return result\n    } \n\nlet completion file lin col lineText filter =\n    Wrap.wrapper {\n        let!  result = FSAutocompleteCall \"completion\" (function | KCompletion _ -> true | _ -> false) <|\n                             FarCompletion\n                                 { FileName        = System.IO.Path.GetFullPath file\n                                   Line            = lin         \n                                   Column          = col\n                                   Filter          = filter\n                                   SourceLine      = lineText \n                                   IncludeKeywords = false                                     \n                                 }\n        return result\n    } \n\ntype FsAutoCompleteErr =\n    | ``Code has not been parsed, use Parse F#``\n    | ``This snippet has not been previosuly parsed, use Parse F#``\n    | ``Cached typecheck results not yet available``\n    | ``Error FileCheckerOptions`` of string\nwith interface ErrMsg with\n        member this.ErrMsg    = match this with | msg -> sprintf \"%A\" msg\n        member this.IsWarning = false    \n        \n/// this converts from Result to Rop.Result\nlet fromResult' f = \n    function \n    | Failure s  -> Result.fail <| f s\n    | Success v  -> Result.succeed v\n\ntype Responder2() =\n    //let commands = Commands()\n    let starts : Map<string, Map<string, int * int * int>> ref = ref Map.empty\n    \n    let getDelta fname snpIdO =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file = System.IO.Path.GetFullPath fname\n            match snpIdO with\n            | Some _snpI -> let! fileMap          = (!starts) |> Map.tryFind file         |> Result.fromOption ``Code has not been parsed, use Parse F#``\n                            let! ind, first, _las = fileMap   |> Map.tryFind snpIdO.Value |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n                            return file, first, ind\n            | None       -> return file, 0    , 0 \n        }\n    let getDeltaBack fname line =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  file             = System.IO.Path.GetFullPath fname\n            let! fileMap          = (!starts) |> Map.tryFind file |> Result.fromOption ``Code has not been parsed, use Parse F#``\n            let! snp, first, ind  = fileMap \n                                    |> Seq.map     (fun kv -> kv.Key, kv.Value) \n                                    |> Seq.tryPick (fun (snp, (ind, first, last)) -> if line >= first && line < last then Some (snp, first, ind) else None) \n                                    |> Result.fromOption ``This snippet has not been previosuly parsed, use Parse F#``\n            return snp, first, ind                        \n        }\n    let mustParse fname snpId =\n        getDelta  fname (Some snpId)\n        |> Wrap.map              (fun _ -> false)\n        |> Wrap.RunSynchronouslyR \n        |> Result.withError      (fun _ -> true )\n\n    let findDeclaration file lin col filter =\n        Wrap.wrapper {\n            //File.WriteAllText(file, \" \")\n            let!  result = FSAutocompleteCall \"finddeclaration\" (function | KFindDecl _ -> true | _ -> false) <|\n                                 FarPosition\n                                     { FileName   = System.IO.Path.GetFullPath file\n                                       Line       = lin         \n                                       Column     = col\n                                       Filter     = filter\n                                     }\n            //File.Delete file                         \n            match result with\n            | KFindDecl decl -> let! snp, dln, dcol = getDeltaBack decl.File decl.Line\n                                let resultAdj = \n                                 {  File    = snp\n                                    Line    = decl.Line   - dln\n                                    Column  = decl.Column - dcol\n                                 } |> KFindDecl\n                                return resultAdj\n            | _              -> return result\n        } \n\n    let getPosition (getKind: string -> int -> int -> string -> Wrap<Kind>) fname ln col (snpIdO:string option) =\n        Wrap.wrapper {\n            let! _fil, dln, dcol = getDelta fname snpIdO\n            let! res             = getKind fname (ln + dln) (col + dcol) \"\"\n            return res\n        } \n        |> Wrap.RunSynchronouslyR\n        |> Result.withError (Result.getMessages >> KindError)\n\n    let getCompletion fname ln col lineText (snpIdO:string option) =\n        Wrap.wrapper {\n            let! _fil, dln, dcol = getDelta fname snpIdO\n            let! res             = completion fname (ln + dln) (col + dcol) ((String.replicate dcol \" \") + lineText) \"Contains\"\n            return res\n        } \n        |> Wrap.RunSynchronouslyR\n        |> Result.withError (Result.getMessages >> KindError)\n        \n    member this.Respond (msg:ACMessage) =\n        match msg with\n        | ACMIdentification              -> KInfo \"FSAutoCompleteIntermedirary\"\n        | ACMEcho   txt                  -> KInfo txt \n        | ACMMustParse(fname, snpId    ) -> mustParse fname snpId |> sprintf \"%b\" |> KInfo\n        | ACMParse    (fname, code, sts) ->\n            async {\n                let  file = System.IO.Path.GetFullPath (fname)\n                do   starts := !starts |> Map.add file (Map sts)\n                //printfn \"\\n%A\\n\" sts\n                let! errors = parseCode file (code.Split '\\n') |> Wrap.getAsync\n                let  fixedErrors =\n                    match errors with\n                    | KErrors ers -> \n                          KErrors { ers with \n                                      Errors = ers.Errors \n                                        |> Array.map (fun err ->\n                                          sts \n                                          |> Array.tryFind (fun (_snpN, (_in, first, last)) -> err.StartLine >= first && err.StartLine <= last)\n                                          |> Option.map    (fun (snpNm, (ind, first, _las)) ->\n                                              { err with FileName    = snpNm\n                                                         StartLine   = err.StartLine   - first\n                                                         EndLine     = err.EndLine     - first\n                                                         StartColumn = err.StartColumn - ind\n                                                         EndColumn   = err.EndColumn   - ind   }) \n                                          |> Option.defaultValue err)\n                                  } \n                    | _ -> errors\n                return fixedErrors \n            }\n            |> Async.RunSynchronously\n        | ACMToolTip         (fname, ln, col)             -> getPosition   toolTip         fname ln col None\n        | ACMToolTip2        (fname, ln, col,      snpId) -> getPosition   toolTip         fname ln col (Some snpId)\n        | ACMSignature       (fname, ln, col)             -> getPosition   signature       fname ln col None\n        | ACMSignature2      (fname, ln, col,      snpId) -> getPosition   signature       fname ln col (Some snpId)\n        | ACMFindDeclaration (fname, ln, col)             -> getPosition   findDeclaration fname ln col None\n        | ACMFindDeclaration2(fname, ln, col,      snpId) -> getPosition   findDeclaration fname ln col (Some snpId)\n        | ACMComplete        (fname, ln, col, txt)        -> getCompletion                 fname ln col txt None\n        | ACMComplete2       (fname, ln, col, txt, snpId) -> getCompletion                 fname ln col txt (Some snpId)\n\n", "snpParentIdO": {"SnippetId" :"b6577554-e62e-41ed-983e-d4dd12e3512f"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"466e6783-0751-48d5-b79b-165aaa7d2173"}, "snpName": "FSAutoCompleteIntermediaryClient", "snpContent": "#define FSAUTOCOMPLETE\n\nopen Useful\n//open FsStationShared\nopen WSMessagingBroker\nopen WebSharper\nopen WebSharper.Remoting\n\n#if FSS_SERVER\n\nlet responder = Responder2()\n\nlet fssClient = new WSMessagingBroker.FStationMessaging(\"FSAutoComplete\", FSStation)\nasync {\n    do! Async.Sleep 1000\n    fssClient.MessagingClient.ProcessIncoming (responder.Respond >> WSome)\n} |> Async.Start\n\n[< Rpc >]\nlet sendMessageRpc msg = async { return responder.Respond msg }\n\n[< JavaScript >]\nlet sendMessage  (msg:ACMessage) : Async<Kind> = \n    async {\n        let!   res = sendMessageRpc (msg |> box |> unbox)\n        return res                       |> box |> unbox\n    }\n#endif\n\n#if WEBSHARPER\n[< JavaScript >]\n#endif\ntype FSAutoCompleteIntermediaryClient(clientId, ?endPoint:string) =\n     #if FSS_SERVER\n     #else\n     let msgClient = new WSMessagingClient(clientId, ?endPoint = endPoint)\n     let toId      = Address \"FSAutoComplete\"\n     let sendMessage (msg:ACMessage) : Async<Kind> = msgClient.SendGetReply toId msg |> Wrap.getAsyncWithDefault (Result.getMessages >> KInfo)\n     #endif\n     let Async_map f aa = \n         async { \n             let! a = aa\n             return f a\n         }\n     let rec comp2Strings comp =\n         match comp with \n         | KCompletion cs -> cs |> Array.map (fun cs -> cs.Name, cs.ReplacementText, cs.Glyph, cs.GlyphChar)\n         | KHelpText   _  -> [||]\n         | KMultiple   ks -> ks |> Array.collect comp2Strings \n         | m              -> [| sprintf \"%A\" m, \"\", \"ErrorMsg\", \"E\" |] \n     let tip2String tip =\n         match tip with \n         | KToolTip ts -> ts |> Seq.collect id |> Seq.collect (fun t -> [ t.Signature ; t.Comment ] ) |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let errors2String errs =\n         match errs with \n         | KErrors  es -> \n             es.Errors \n             |> Seq.map (fun er -> sprintf \"ErrFSharp \\\"F# %s.fsx (%d,%d) - (%d,%d) %s:%s\\\"\" \n                                      er.FileName er.StartLine er.StartColumn er.EndLine er.EndColumn er.Subcategory er.Message) \n             |> String.concat \"\\n\"\n         | m           -> sprintf \"%A\" m \n     let info2Bool inf =\n         match inf with\n         | KInfo \"true\" -> true\n         | _            -> false\n        \n   with\n     member this.MustParse(fname,                 sId) = sendMessage (ACMMustParse       (fname,                  sId)) |> Async_map info2Bool\n     member this.Parse    (fname, txt , sts          ) = sendMessage (ACMParse           (fname, txt , sts           )) |> Async_map errors2String\n     member this.Parse    (fname, txt                ) = sendMessage (ACMParse           (fname, txt , [||]          )) |> Async_map errors2String\n     member this.ToolTip  (fname, line, col          ) = sendMessage (ACMToolTip         (fname, line, col           )) |> Async_map tip2String\n     member this.ToolTip  (fname, line, col,      sId) = sendMessage (ACMToolTip2        (fname, line, col ,      sId)) |> Async_map tip2String\n     member this.Complete (fname, txt, line, col     ) = sendMessage (ACMComplete        (fname, line, col , txt     )) |> Async_map comp2Strings\n     member this.Complete (fname, txt, line, col, sId) = sendMessage (ACMComplete2       (fname, line, col , txt, sId)) |> Async_map comp2Strings\n     member this.FindDecl (fname, line, col          ) = sendMessage (ACMFindDeclaration (fname, line, col           )) |> Async_map id\n     member this.FindDecl (fname, line, col,      sId) = sendMessage (ACMFindDeclaration2(fname, line, col ,      sId)) |> Async_map id\n     #if FSS_SERVER\n     #else\n     member this.MessagingClient                       = msgClient    \n     member this.ToId                                  = toId\n     #endif\n", "snpParentIdO": {"SnippetId" :"b6577554-e62e-41ed-983e-d4dd12e3512f"}, "snpPredIds": [{"SnippetId" :"319e0842-b83e-4036-9f57-602ca4a30ac5"}, {"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"}, "snpName": "FsEvaluator", "snpContent": "/// FSI interfase\n\nmodule FsEvaluator =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"}, "snpName": "evalFsiExe", "snpContent": "open Useful\n\nmodule Evaluator =\n    open System.Diagnostics\n    open UsefulDotNet\n    open RunProcess\n    \n    let endToken = \"xXxY\" + \"yYyhH\"\n    let mutable silent    = false\n    type FsiExe(config, ?outHndl, ?errHndl) =\n        let fsiexe                    = if config |> Seq.contains \"-d:FSI32BIT\" then \"fsi.exe\" else \"fsianycpu.exe\"\n        let startInfo                 = ProcessStartInfo(fsiexe, config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo, ?outHndl = outHndl, ?errHndl = errHndl)  // --noninteractive\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Eval txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                shell.Send txt \n                shell.Send \";;\"\n                let! res = shell.SendAndWait(\"printfn \\\"\" + endToken + \"\\\";;\", endToken)\n                //shell.WaitForInputIdle() |> ignore\n                //let! resR = shell.Response()\n                //let! res  = resR\n                return res\n            }\n        member this.IsAlive = not shell.HasExited\n        member this.Abort() = shell.Abort()\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()\n\n#if FSS_SERVER\n    printfn \"FSS_SERVER\"\n    let fssClient = FSAutoCompleteIntermediary.fssClient //WSMessagingBroker.FStationMessaging(\"<FsEvaluator>\", WSMessagingBroker.FSStation)\n    let queueOutput =\n        let output      = new System.Text.StringBuilder()\n        let append  txt = output.Append((if output.Length = 0 then \"\" else \"\\n\") + txt) |> ignore\n        let consume ()  = let v = output.ToString()\n                          output.Clear() |> ignore\n                          v\n        Mailbox.iter (fun msg -> \n            match msg with\n            | Some txt -> append txt\n            | None     -> let txt2send =  consume()\n                          if  txt2send <> \"\" then\n                              fssClient.RunActionCall(\"OutText\", \"actOutText\", [| \"+\" ; txt2send |])\n                              |> Wrap.RunSynchronously \n                              |> ignore\n          )\n    let queueText txt = \n        txt |> Some |> queueOutput.Post\n        async { do! Async.Sleep 100\n                queueOutput.Post None } |> Async.Start\n    let outHndl (txt:string) = if not silent then txt.Replace(endToken, \"Done!\")   |> queueText\n    let errHndl (txt:string) = if not silent then if txt <> \"\" then \"ERR : \" + txt |> queueText\n    let setFsid id ep = if id <> fssClient.FSStationId && id <> \"\" then fssClient.FSStationId <- id ; printfn \"setFSid = %s\" id\n#else\n    let outHndl       = ignore\n    let errHndl       = ignore\n    let setFsid _i _e = ()\n#endif\n\n    let fsiExe = lazy new ResourceAgent<_, string> (70\n                                                  , (fun config ->\n                                                          printfn \"FsiExe %s\" (defaultArg config \"\")\n                                                          new FsiExe([ \"--nologo\"\n                                                                       \"--quiet\"\n                                                                       defaultArg config \"\"\n                                                                     ], outHndl, errHndl))\n                                                  , (fun fsi -> (fsi :> System.IDisposable).Dispose()), (fun fsi -> fsi.IsAlive), \"\")\n\n    #if WEBSHARPER\n    [< JavaScript >]\n    #endif\n    let extractConfig (code:string) = if code.StartsWith \"////-d:\" then code.[4..code.IndexOf '\\n' - 1] else \"\"\n\n    let evalFsiExe (code:string) incrUseCount =\n        wrap {\n            let  config = extractConfig code\n            let! resR   = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  return! fsi.Eval code \n                }\n            , config, incrUseCount)\n            let! res    = resR\n            return res\n        }\n        \n    let evalSilent (config:string option) fs = \n        wrap {\n            silent <- true\n            let! resR   = fsiExe.Value.Process(fun fsi -> \n                Wrap.wrapper {\n                  return! fsi.Eval fs\n                }\n            , config \n              |> Option.orElse fsiExe.Value.Configuration\n              |> Option.defaultValue \"\"\n            , false)\n            let! res    = resR\n            silent <- false\n            return res\n        }\n        |> Wrap.runSynchronouslyS false \n        |> fun s -> s.Split('\\n').[0]     \n        \n    let installPresence configO = evalSilent configO \"\"\"\nmodule CodePresence =\n    let mutable present : Map<string, string>  = Map.empty\n    let presenceOf    k   = present |> Map.tryFind k |> Option.defaultValue \"--\" |> printfn \"%s\"\n    let addPresenceOf k v = present <- present |> Map.add k v ; printfn \"ok\"\n\"\"\"\n\n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let addPresence (name:string) (v:string) = \n        async {\n            let code = sprintf \"CodePresence.addPresenceOf %A %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\")) v\n            evalSilent None code\n            |> function\n               | \"ok\" -> ()\n               | _    -> installPresence None      |> ignore\n                         evalSilent      None code |> ignore\n        }\n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let getPresence config (name:string)   = \n        async {\n            let code = sprintf \"CodePresence.presenceOf    %A\" (name.Replace(\"\\\"\", \"\\\\\\\"\"))\n            return\n                evalSilent (Some config) code\n                |> function\n                   | v when v = endToken -> installPresence (Some config) |> ignore\n                                            None\n                   | \"--\"                -> None\n                   | v                   -> Some v\n        }\n        \n    #if WEBSHARPER\n    [< Rpc >]\n    #endif\n    let abortFsiExe () = \n        fsiExe.Value.Process(fun fsi -> Wrap.wrap { fsi.Abort() }) \n        |> WAsyncR \n        |> Wrap.toAsync\n\n    type EVMessage =\n    | EVMEvaluate of string\n    | EVMAbort\n    \n    type EVResponse =\n    | EVROk\n    | EVRResult   of ResultS<string>\n\n    let respond msg = \n        Wrap.wrap {\n            match msg with\n            | EVMEvaluate fs -> let!   r =  evalFsiExe fs true |> Wrap.toAsyncResult\n                                return r |> Result.toResultS   |> EVRResult\n            | EVMAbort       -> do! abortFsiExe()\n                                return EVROk\n        }\n\n", "snpParentIdO": {"SnippetId" :"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"}, "snpPredIds": [{"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"f930dc48-39e8-453c-8c77-18a2cd73637a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, "snpName": "evaluateAR", "snpContent": "#define WEBSHARPER\nopen WebSharper\n\n[< Rpc >]\nlet evaluateAS (fsid:string) (ep:string) incrUseCount source =\n    async {\n        Evaluator.setFsid fsid ep\n        let!    res  = Evaluator.evalFsiExe source incrUseCount |> Wrap.getAsyncR \n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet evaluateAR fsid ep incrUseCount source =\n    async {\n        let!   vO, msgs = evaluateAS fsid ep incrUseCount source \n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toArray)\n    }\n\n[< JavaScript >]\nlet evaluateW fsid ep incrUseCount source = evaluateAR fsid ep incrUseCount source |> WAsyncR\n\n[< JavaScript >]\nlet abortFsiExe () = Evaluator.abortFsiExe() |> Async.Start \n\n#if FSS_SERVER\n\nlet fssClient = new WSMessagingBroker.FStationMessaging(\"FSEvaluator\", WSMessagingBroker.FSStation)\n\nasync {\n    do! Async.Sleep 1000\n    fssClient.MessagingClient.ProcessIncoming Evaluator.respond\n} |> Async.Start\n\n#else\n\n#if FSS_SERVER\n#else\ntype WSMessagingBroker.WSMessagingClient with\n#if WEBSHARPER\n[< JavaScript >]\n#endif\n     member this.EvaluateFS fs = \n         Wrap.wrap {\n             let! repS = Evaluator.EVMEvaluate fs |> this.SendGetReply (WSMessagingBroker.Address \"FSEvaluator\")\n             let! rep  = match repS with\n                         | Evaluator.EVROk       -> Result.fail (ErrSimple (\"Unexpected EVROk reply received\", false))\n                         | Evaluator.EVRResult r -> Result.fromResultS r\n             return rep\n         }\n#endif\n#endif\n", "snpParentIdO": {"SnippetId" :"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}, {"SnippetId" :"f930dc48-39e8-453c-8c77-18a2cd73637a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6568955e-6aa8-4f8f-b93f-b7e97622c677"}, "snpName": "FsTranslator", "snpContent": "module FsTranslator =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cfe0b3ef-9176-4f30-853c-27177faef6b0"}, "snpName": "FsTranslator", "snpContent": "#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\WebSharper.Compiler.FSharp.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\System.Reflection.Metadata.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\FSharp.Compiler.Service.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\FSharp.Core.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Pdb.dll\"\n#r @\"..\\packages\\WebSharper.FSharp\\tools\\net461\\Mono.Cecil.Mdb.dll\"\n//#r @\"System.Reflection.Metadata.dll\"\n\nmodule Translator =\n    open Useful\n    open UsefulDotNet\n    open System\n    open System.IO\n    open System.Reflection\n    \n    module Re = WebSharper.Core.Resources\n    module P  = WebSharper.PathConventions\n    open WebSharper.Compiler\n    open WebSharper.Compiler.FrontEnd\n    open WebSharper.Core\n    open WebSharper.Core.Resources\n    open WebSharper.Compiler.CommandTools\n    open Microsoft.FSharp.Compiler.SourceCodeServices\n    open Microsoft.FSharp.Compiler\n    \n    type WebSharperError = AST.SourcePos option * CompilationError\n    type TranslatorError =\n        | MustProvideAssemblyOutputPath\n        | MustProvideProjectPath\n        | ErrWebSharper                 of string\n        | NothingToTranslateToJavaScript\n        | OutputAssemblyNotFound        of string\n    with interface ErrMsg with\n            member this.ErrMsg =\n                if this = NothingToTranslateToJavaScript then \"WebSharper found nothing that required translation to JavaScript. Possibly a [< JavaScript >] attribute is missing.\" else\n                sprintf \"%A\"this\n            member this.IsWarning = false\n    \n    let webSharperError2TranspilerError: WebSharperError -> ErrMsg =\n        fun                              (posO, error)   ->\n            posO \n            |> Option.map (fun pos -> sprintf \"%s %A - %A \" pos.FileName pos.Start pos.End )\n            |> Option.defaultValue \"\"\n            |>  sprintf \"%s%s\" <| error.ToString()\n            |> ErrWebSharper\n            :> ErrMsg\n            \n    let PrintGlobalError err = eprintfn \"WebSharper error FS9001: %s\" (ErrorPrinting.NormalizeErrorString err)\n\n    let CompileToJsW: WsConfig -> Wrap<string> =\n        fun           config   -> Wrap.wrapper {\n            do!  config.ProjectFile  = null       |> Result.failIfTrue  MustProvideProjectPath\n            do!  config.AssemblyFile = null       |> Result.failIfTrue  MustProvideAssemblyOutputPath\n            let  fsharpChecker       = FSharpChecker.Create(keepAssemblyContents = true)\n            let! errors, exitCode    = fsharpChecker.Compile(config.CompilerArgs)\n            let  fsErrors            = errors |> Array.map fSharpError2TranspilerError \n            do!  (if exitCode = 0 then Result.succeedWithMsgs () else Result.failWithMsgs) <| fsErrors\n            do!  File.Exists config.AssemblyFile  |> Result.failIfFalse (OutputAssemblyNotFound config.AssemblyFile)\n            let  assemblyBytes       = File.ReadAllBytes config.AssemblyFile\n            do   System.IO.File.Delete config.AssemblyFile\n            let  paths               = [   for r in config.References -> \n                                               Path.GetFullPath r\n                                           yield Path.GetFullPath config.AssemblyFile\n                                       ]        \n            let  aR                  = AssemblyResolver.Create().SearchPaths(paths)\n            let  loader              = Loader.Create aR (printfn \"%s\")\n            let  refs                = [ for r in config.References -> loader.LoadFile(r, false) ]\n            let wsRefsMeta =\n                System.Threading.Tasks.Task.Run(fun () ->\n                    let mutable refError = false\n                    let wsRefs, metas = \n                        refs |> List.choose (fun r -> \n                            match TryReadFromAssembly FullMetadata r with\n                            | None -> None\n                            | Some (Ok m) -> Some (r, m)\n                            | Some (Error e) ->\n                                refError <- true\n                                PrintGlobalError e\n                                None\n                        ) |> List.unzip\n                    if refError then None\n                    elif List.isEmpty metas then Some ([], [], WebSharper.Core.Metadata.Info.Empty) \n                    else\n                        try\n                            Some (\n                                wsRefs, metas,\n                                { \n                                    WebSharper.Core.Metadata.Info.UnionWithoutDependencies metas with\n                                        Dependencies = WebSharper.Core.DependencyGraph.Graph.NewWithDependencyAssemblies(metas |> Seq.map (fun m -> m.Dependencies)).GetData()\n                                }\n                            )\n                        with e ->\n                            refError <- true\n                            PrintGlobalError (\"Error merging WebSharper metadata: \" + e.Message)\n                            None\n                )\n            let refMeta = wsRefsMeta.ContinueWith(fun (t: System.Threading.Tasks.Task<_>) -> \n                            match t.Result with \n                            | Some (_, _, m) -> Some m \n                            | _ -> None )\n            let  referencedAsmNames     = paths\n                                          |> Seq.map (fun i -> \n                                              let n = Path.GetFileNameWithoutExtension(i)\n                                              n, i\n                                          ) |> Map.ofSeq\n            let  thisName               = Path.GetFileNameWithoutExtension config.AssemblyFile\n            let  assemblyResolveHandler = ResolveEventHandler(fun _ e ->\n                    //printfn \"assemblyResolveHandler %s\" e.Name\n                    let assemblyName    = AssemblyName(e.Name).Name\n                    match Map.tryFind assemblyName referencedAsmNames with\n                    | Some p when assemblyName = \"FSharp.Core\" -> typeof<option<_>>.Assembly\n                    | Some p when assemblyName = thisName      -> Assembly.Load assemblyBytes\n                    | Some p                                   -> Assembly.LoadFrom(p)\n                    | _                                        -> null\n                )\n            System.AppDomain.CurrentDomain.add_AssemblyResolve(assemblyResolveHandler)\n            let! comp        = WebSharper.Compiler.FSharp.WebSharperFSharpCompiler(printfn \"%s\", fsharpChecker)\n                                        .Compile(refMeta, config.CompilerArgs, config, config.ProjectFile) \n            let  wsErrors    = comp.Errors |> Seq.map webSharperError2TranspilerError |> Seq.toArray\n            do! if wsErrors |> Seq.isEmpty then Result.succeed () else\n                Result.failWithMsgs wsErrors\n            let  assem       = loader.LoadRaw assemblyBytes None\n            let  getRefMeta()= match wsRefsMeta.Result with | Some (_, _, m) -> m | _ -> WebSharper.Core.Metadata.Info.Empty\n            let jsO, currentMeta, sources = ModifyAssembly (Some comp) \n                                              (getRefMeta()) \n                                              (comp.ToCurrentMetadata(config.WarnOnly)) \n                                              config.SourceMap config.AnalyzeClosures assem\n            let! js, jsMin   = jsO |> Result.fromOption NothingToTranslateToJavaScript\n            let  thisProject = Path.GetFileNameWithoutExtension config.ProjectFile\n            use  stringW     = new System.IO.StringWriter()\n            use  writer      = new HtmlTextWriter(stringW)\n            let  pu          = P.PathUtility.VirtualPaths(\"/\")\n            let ctx : Resources.Context =\n                {\n                    WebRoot                 = \"\"\n                    DebuggingEnabled        = true\n                    DefaultToHttp           = false\n                    GetSetting              = fun (name: string) -> None //printfn \"GetSetting %s\" name ; None\n\n                    GetAssemblyRendering    = fun name ->\n                        //printfn \"GetAssemblyRendering %s\" name\n                        if name = thisProject || name = config.ProjectFile\n                        then WebSharper.Core.Resources.Rendering.Skip else\n                        name\n                        |> P.AssemblyId.Create\n                        |> pu.JavaScriptPath \n                        |> Re.RenderLink\n                    GetWebResourceRendering = fun ty resource ->\n                        //printfn \"GetWebResourceRendering %A\" ty\n                        let id = P.AssemblyId.Create(ty)\n                        let kind =\n                            if resource.EndsWith(\".js\") || resource.EndsWith(\".ts\")\n                                then P.ResourceKind.Script\n                                else P.ResourceKind.Content\n                        P.EmbeddedResource.Create(kind, id, resource)\n                        |> pu.EmbeddedPath\n                        |> Re.RenderLink\n                    RenderingCache          = System.Collections.Concurrent.ConcurrentDictionary()\n                    ResourceDependencyCache = System.Collections.Concurrent.ConcurrentDictionary()\n                    ScriptBaseUrl = None\n                }            \n            comp.Graph.Nodes |> comp.Graph.GetDependencies |> comp.Graph.GetResources |> Seq.iter(fun r -> r.Render ctx (fun _ -> writer) )\n            //js.RenderDependencies(ctx, writer)\n            let  includes = stringW.ToString()\n            let  incs     = includes.Split([| \"src=\"; \"href=\" ; \"<\" ; \">\" |], System.StringSplitOptions.RemoveEmptyEntries)\n                            |> Seq.choose(fun v -> if v.[0] = '\"' then v.Split([| '\"' |], System.StringSplitOptions.RemoveEmptyEntries).[0] |> sprintf \"%A\" |> Some else None)\n                            |> String.concat \", \"\n            let! f        = Result.succeedWithMsgs js.[1..js.Length - 7] (comp.Warnings |> Seq.map (fun v -> (sprintf \"%A\" v, true) |> ErrSimple :> ErrMsg) |> Seq.toArray)\n            return          sprintf \"CIPHERSpaceLoadFiles([%s], %s);\" incs f\n        }\n    \n    let compileMainW: string[] -> Wrap<string> =\n      fun             argv     ->\n        let resSplit (r:string) = \n            match r.Split(',') with \n            | [| res           |] -> (res, None         )\n            | [| res; fullName |] -> (res, Some fullName)\n            | _ -> argError (\"Unexpected value --resource:\" + r)\n        let wsArgs    = ref WsConfig.Empty\n        let refs      = ResizeArray()\n        let resources = ResizeArray()\n        let fscArgs   = ResizeArray()\n        let cArgv     =\n            [|\n                let isRNext = ref false\n                for a in argv do\n                    match a with\n                    | \"-r\" ->\n                        isRNext := true\n                    | _ ->\n                        if !isRNext then\n                            isRNext := false   \n                            yield \"-r:\" + a\n                        else\n                            yield a\n            |]\n        for a in cArgv do\n            let setProjectType t = wsArgs := { !wsArgs with ProjectType = Some t }\n            try\n                match a with\n                | \"--wig\"                          -> setProjectType WIG\n                | \"--bundle\"                       -> setProjectType Bundle\n                | \"--html\"                         -> setProjectType Html\n                | \"--site\"                         -> setProjectType Website\n                | StartsWith \"--ws:\" wsProjectType ->\n                    match wsProjectType.ToLower() with\n                    | \"site\" \n                    | \"web\" \n                    | \"website\" \n                    | \"export\"                     -> setProjectType Website\n                    | \"extension\"                  \n                    | \"interfacegenerator\"         -> setProjectType WIG\n                    | \"bundle\"                     -> setProjectType Bundle\n                    | \"html\"                       -> setProjectType Html\n                    | \"ignore\"                     -> ()\n                    | \"library\"                    -> ()\n                    | _                            -> invalidArg \"type\" (\"Invalid project type: \" + wsProjectType)\n                | StartsWith \"--project:\"        p -> wsArgs := { !wsArgs with ProjectFile   = p      } //Path.Combine(Directory.GetCurrentDirectory(), p) }\n                | StartsWith \"--wsoutput:\"       o -> wsArgs := { !wsArgs with OutputDir     = Some o }\n                | StartsWith \"--keyfile:\"        k -> wsArgs := { !wsArgs with KeyFile       = Some k }\n                | \"--jsmap\"                        -> wsArgs := { !wsArgs with SourceMap     = true   } \n                | \"--dts\"                          -> wsArgs := { !wsArgs with TypeScript    = true   } \n                | \"--wswarnonly\"                   -> wsArgs := { !wsArgs with WarnOnly      = true   } \n                | \"--printjs\"                      -> wsArgs := { !wsArgs with PrintJS       = true   }\n                | \"--debug\"                      \n                | \"--debug+\"                     \n                | \"--debug:full\"                 \n                | \"-g\"                           \n                | \"-g+\"                          \n                | \"-g:full\"                        -> wsArgs := { !wsArgs with IsDebug       = true   } ; fscArgs.Add a\n                | \"--vserrors\"                     -> wsArgs := { !wsArgs with VSStyleErrors = true   } ; fscArgs.Add a\n                | StartsWith \"-o:\"               o \n                | StartsWith \"--out:\"            o -> wsArgs := { !wsArgs with AssemblyFile = o       } ; fscArgs.Add a\n                | StartsWith \"--doc:\"            d -> wsArgs := { !wsArgs with Documentation = Some d } ; fscArgs.Add a\n                | StartsWith \"-r:\"               r             \n                | StartsWith \"--reference:\"      r -> refs.Add      r                                   ; fscArgs.Add a\n                | StartsWith \"--resource:\"       r -> resources.Add (resSplit r)                        ; fscArgs.Add a\n                | _                                ->                                                     fscArgs.Add a  \n            with e ->\n                failwithf \"Parsing argument failed: '%s' - %s\" a e.Message\n        fscArgs.Add \"--define:FSHARP41\"\n        wsArgs := \n            { !wsArgs with \n                References   = refs |> Seq.map (fun s -> s.ToLower()) |> Seq.distinct |> Array.ofSeq\n                Resources    = resources.ToArray()\n                CompilerArgs = fscArgs  .ToArray() \n            }\n        CompileToJsW !wsArgs\n\n    let Process args =  \n        compileMainW args \n        |> Wrap.runSynchronouslyR\n        |> fun (Result(jsO, msgs)) -> \n               jsO |> Option.iter (printfn \"%s\")\n               if msgs |> Seq.isEmpty |> not then Result.getMessages msgs |> eprintfn \"%O\"\n               match jsO with\n               | Some js -> 0\n               | None    -> 1\n               \n    let endToken = sprintf \"//---------------%s-----------------\" \"EOF\"\n\n    [< EntryPoint >]\n    let Main args =\n        Console.SetIn(new StreamReader(Console.OpenStandardInput 30000))\n        let mutable cycle = true\n        if args = [| \"++loop\" |] \n        then while cycle do\n               let line = Console.ReadLine()\n               if line = null ||  line = \"++end\" then cycle <- false else\n               let argsL = match line with Regexs \"(\\\".*?\\\"|\\S+)\" ms -> ms |> Array.map (function | Regex \"(\\\"(.*)\\\")\" [_ ; m] | m -> m)\n               if Process argsL = 0 then \"success\" else \"fail\"\n               |> printfn \"//%s\"\n               eprintfn \"%s\" endToken\n             0\n        else Process args \n", "snpParentIdO": {"SnippetId" :"6568955e-6aa8-4f8f-b93f-b7e97622c677"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"7646acbc-2c28-4159-98b1-2365d19fc97c"}, {"SnippetId" :"9becc68c-9cc2-4f29-82df-e510d10226db"}, {"SnippetId" :"b7c2d8cd-7246-4ad1-af46-ffbb7acde6e0"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}, "snpName": "TranslatorCaller", "snpContent": "module TranslatorCaller =\n    open Useful\n    open UsefulDotNet\n    open UsefulDotNet.RunProcess\n    open CompOptionsModule\n    open System\n    open System.IO\n    open System.Diagnostics\n    \n    type TranslatorExe(config) =\n        let startInfo                 = ProcessStartInfo(@\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\projects\\FsTranslator\\bin\\FsTranslator.exe\", config |> String.concat \" \")             \n        let shell                     = new ShellEx(startInfo)  // --noninteractive\n        let endToken                  = sprintf \"//---------------%s-----------------\" \"EOF\"\n        do  startInfo.CreateNoWindow <- false\n            shell.Start() |> ignore\n        member this.Translate txt =\n            Wrap.wrapper {\n                do! Result.tryProtection()\n                let! res1 = shell.SendAndWait(txt, endToken, true)\n                let! res2 = if res1.EndsWith \"//success\" then Result.succeed res1 else Result.fail (ErrSimple (\"Translator Failed\", false))\n                return res2\n            }\n        member this.IsAlive = not shell.HasExited\n        interface System.IDisposable with\n            member this.Dispose () = \n                (shell :> System.IDisposable).Dispose()    \n\n    let translator = lazy new ResourceAgent<_, string> (20, (fun config -> new TranslatorExe([\"++loop\"; defaultArg config \"\"] )), (fun exe -> (exe :> System.IDisposable).Dispose()), (fun exe -> exe.IsAlive), \"\")\n    \n    let extractConfig (code:string[]) = if code.[0].StartsWith \"////-d:\" then code.[0].[4..] else \"\"\n\n    let getJSW (minified:bool) (options0 : (CompOption * CompOptionValue) seq) (fsCode:string) =\n        Wrap.wrapper {\n            do!  Result.tryProtection()\n            let  code           = fsCode.Split '\\n'\n            let  defines0       = (extractConfig code).Split([| \" \" ; \"-d:\" |], StringSplitOptions.RemoveEmptyEntries) \n            let  fs, assembs, defines1, prepIs, nowarns = separatePrepros false code |> separateDirectives\n            let  defines        = Array.append defines0 defines1\n            let  codeBase       = Path.GetFullPath \"bin\"\n            let  name           = \"Temp_\" + Path.GetFileNameWithoutExtension(Path.GetRandomFileName())\n            let  options1       = compileOptionsDll name\n                                  + opDirectory   /= Path.GetDirectoryName(codeBase)\n                                  + opWsProject   /= name\n                                 // + opIOption   /= @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\"\n            let  options2       = prepOptions options1 (fs, assembs, defines, prepIs, nowarns)\n            use  toErase        = new TempFileName(options2?Source)\n            let  ops            = options2.Get CompOptions.WSharperOptions\n                                  |> Seq.append [ \"IGNORED\" ]\n                                  |> Seq.map (sprintf \"%A\")\n                                  |> String.concat \" \"\n            printfn \"%s\" ops \n            let! jsR            = translator.Value.Process (fun tra -> tra.Translate ops)\n            let! js             = jsR\n            return js\n        }\n\n    \"\"\"\n////-d:WEBSHARPER\n#I @\"..\\packages\\WebSharper\\lib\\net461\"\n#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n/// Root namespace for all code\n#if INTERACTIVE\nmodule FsRoot   =\n#else\nnamespace FsRoot\n#endif\n\n    #if WEBSHARPER\n    //#define NOFRAMEWORK --noframework\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\"\n    //#I @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\Facades\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\mscorlib.dll\"\n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n    \n    //#I @\"..\\packages\\WebSharper\\lib\\net461\"\n    //#I @\"..\\packages\\WebSharper.UI\\lib\\net461\"\n    \n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Collections.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.InterfaceGenerator.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Main.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JQuery.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.JavaScript.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Web.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Sitelets.dll\"\n    //#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Control.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\HtmlAgilityPack.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Runtime.dll\"\n    //#r @\"..\\packages\\WebSharper.UI\\lib\\net461\\WebSharper.UI.Templating.Common.dll\"\n    \n    open WebSharper\n    open WebSharper.JavaScript\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    type on   = WebSharper.UI.Html.on\n    type attr = WebSharper.UI.Html.attr\n    #else\n    /// dummy WebSharper definition in order to avoid having to use #if WEBSHARPER all the time\n    module WebSharper =\n        type RpcAttribute() =\n            let a = 1\n        type JavaScriptAttribute(translate:bool) =\n            let a = 1\n            new() = JavaScriptAttribute true\n        type InlineAttribute(code:string) =\n            let a = 1\n            new() = InlineAttribute \"\"\n        type DirectAttribute(code:string) =\n            let a = 1\n    \n    open WebSharper\n    \n    #endif\n    \n        //#define WEBSHARPER\n        \n        [< JavaScript >]\n        module TestingJS =\n        \n            module Button =\n                open WebSharper.UI\n                open WebSharper.UI.Html\n                \n                [< SPAEntryPoint >]\n                let main() =\n                    div    [] [\n                        text \"When you press the button \"\n                        button [ on.click (fun _ _ -> JS.Alert \"Hello!\") ] [ text \"Press Me!\" ]\n                        text \" It should respond 'Hello!'\"\n                    ]\n                    |> Doc.Run JS.Document.Body    \"\"\"\n    |> getJSW false [] \n    |> Wrap.runSynchronouslyO false\n    |> printfn \"%A\"\n", "snpParentIdO": {"SnippetId" :"6568955e-6aa8-4f8f-b93f-b7e97622c677"}, "snpPredIds": [{"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"ace1fc12-3dfb-4db8-80c9-5bde1e7d0597"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"ef053bdf-997b-49c8-a401-1611a568bd8a"}, {"SnippetId" :"f930dc48-39e8-453c-8c77-18a2cd73637a"}], "snpProperties": [], "snpGeneration": 216}, {"snpId": {"SnippetId" :"f587e7a5-825a-4c95-ac79-a53f43ed52c8"}, "snpName": "Test FsTranslator.exe", "snpContent": "open Useful\nopen UsefulDotNet\nopen CompOptionsModule\n\nWrap.wrapper {\n    let    snippet = \"FSSGlobal/F# STATION TUTORIALS/1 - Hello World\" //\"FSSGlobal/WebSharper Code/WebSharper Snippets1/Test mouse\" //\"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    //let    snippet = \"FSSGlobal/F# Code/Snippets/Failed to load argument type\"\n    let!   code    = WSMessagingBroker.FStationMessaging(\"Test FsTranslator.exe\").RequestCode snippet\n    let!   js      = TranslatorCaller.getJSW false [ (* opGenInternal /= \"showoptions\" *) ] code\n    return js\n} \n|> Wrap.runSynchronouslyS false\n|> printfn \"%A\"\n", "snpParentIdO": {"SnippetId" :"6568955e-6aa8-4f8f-b93f-b7e97622c677"}, "snpPredIds": [{"SnippetId" :"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}, {"SnippetId" :"ef053bdf-997b-49c8-a401-1611a568bd8a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"95a237c8-a9ff-40d1-bd72-bd298b20af8c"}, "snpName": "translateAR", "snpContent": "open Useful\nopen WebSharper\n\n[< Rpc >]\nlet translateAS source minified = \n    async {\n        let!    res  = TranslatorCaller.getJSW minified [] source |> Wrap.getAsyncR\n        return  res |> Result.mapMsgs (Seq.map (fun (e:ErrMsg) -> e.ErrMsg, e.IsWarning) >> Seq.toArray)\n    }\n    \n[< JavaScript >]\nlet translateAR source minified = \n    async {\n        let!   vO, msgs = translateAS source minified\n        return  Result (vO,  msgs |> Seq.map (fun (msg, wrn) -> ErrSimple(msg, wrn) :> ErrMsg) |> Seq.toArray)\n    }\n    ", "snpParentIdO": {"SnippetId" :"6568955e-6aa8-4f8f-b93f-b7e97622c677"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, "snpName": "Blog", "snpContent": "module Blog =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8ee6b535-3615-4066-8917-9125cf8a1f20"}, "snpName": "FreeMonad", "snpContent": "(**\nFree Monad - Interpreter pattern in F#\n================================\n\nAn analysis of the Free Monad - Interpreter pattern in F# from a definition\ncreated by erdeszt and based on: http://programmers.stackexchange.com/a/242803/145941\n\nThe DSL\n-------\n\nFirst we define a DSL for our actions. Each action points to the next action using the `'next` generic type, \nevery action has a `'next` that in turn could be a DSL, thus chaining them.\n*)\ntype DSL<'next> =\n    | Set of key: string * value: string *  'next\n    | Get of key: string *       (string -> 'next)\n(** \n* `Get` returns a string which is passed to a function. `id` function can be used to finish the chain.\n* `Set` doesn't return anything, so the `'next` portion is the next DSL element in the chain, or a constant like `()` to finish.\n\nNote that used this way `'next` can be anything. It does not have to be a DSL value, so there is no real implication of a chain of DSLs.\n\nThis is what 3 actions in the DSL may look like.\n*)\nlet ex1 = Set (\"name\", \"John\"\n             , Get (\"name\"\n                  , fun name -> Set (\"greeting\", sprintf \"Hello %s\" name, () )\n                   )\n              )\n(**\n`val ex1 : DSL<DSL<DSL<unit>>> =\n  Set (\"name\",\"John\",Get (\"name\",<fun:ex1@23-4>))`\n\nNotice how the resulting type `DSL<DSL<DSL<unit>>>` is nested and not generic. \nThis means a strongly type function cannot process all posible values.\n\nThe Free Monad\n--------------\n\nHere comes the Free Monad `ChainDSL` to the rescue.\n*)\n\ntype ChainDSL<'a> =\n    | Do     of DSL<ChainDSL<'a>>\n    | Return of 'a\n\n(**\nThe `Do` option creates a chain of `ChainDSL`s that ends with the `Return` option.\nThis chain ends up having a type equal to the last `DSL` in the chain.\nThis is almost like creating a `List` of `DSL`s (`List<DSL<'a>> or DSL<'a> list`), \n<del>except that each `DSL` in the chain can be of a different type</del>\nexcept that each element of the DSL chains to the next and some elements are chained using functions.\n\nLets look at the same value above with `ChainDSL`:\n*)\n\nlet exF1 = Do (Set (\"name\", \"John\"\n                  , Do (Get (\"name\"\n                           , fun name -> Do (Set (\"greeting\", sprintf \"Hello %s\" name, Return () )) \n                            )\n                       )\n                   )\n              )\n(**\n`val exF1 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:exF1@49-3>))))`\n\nCompare the resulting type with the prior case: `ChainDSL<unit>` vs `DSL<DSL<DSL<unit>>>`.\nNo matter how deep the chain is, the value will always be of type `ChainDSL<unit>` or `ChainDSL<string>`.\n\n\nBut creating the chain is much more complex than before.\nTo solve that, lets create two helper functions: get and set.\n*)\nlet get key       = Do (Get (key, fun value -> Return value))\nlet set key value = Do (Set (key,     value,   Return ()   ))    \n(**\n`val get : key:string -> ChainDSL<string>`\n\n`val set : key:string -> value:string -> ChainDSL<unit>`\n\nNotice `get` returns a `ChainDSL<string>` and `set` returns a `ChainDSL<unit>`.\nThey both return a `ChainDSL` chain with a single `DSL` action.\n\nWith these functions we can create Get & Set operations like this:\n*)\nlet setName     name = set \"name\"     name\nlet getName          = get \"name\"\nlet setGreeting name = set \"greeting\" (sprintf \"Hello %s\" name)\n(**\nbut they are not chained together like before.\n\nBinding it together\n-------------------\n\nTo chain them we will need to define a bind function for the ChainDSL.\nWe start with a map function for DSL, thus making DSL a functor:\n*)\nlet mapDSL: ('a -> 'b) -> DSL<'a> -> DSL<'b> = \n    fun     f             action  ->\n        match action with\n        | Get (key,        fNext) -> Get (key,        fNext >> f)\n        | Set (key, value,  next) -> Set (key, value,  next |> f)\n\n(**\nAll `mapDSL` does is apply the function `f` to the `'next` part of the `DSL`.\nIn other words go to the next node in the chain.\n\nNext we define the bind function for ChainDSL, finally making it a monad:\n*)\nlet bindChain: ('a -> ChainDSL<'b>) -> ChainDSL<'a> -> ChainDSL<'b> =\n    fun        fChain                  chainTo      ->\n        let rec appendTo chain =\n            match chain with\n            | Return a   -> fChain a\n            | Do     dsl -> Do (mapDSL appendTo dsl)\n        appendTo chainTo\n(** \n`bindChain` is similar and acts like the List.append function, it concatenates two chains of `ChainDSL`s. \nThe difference is that the chain to be appended `fChain` is passed within a function.\n`bindChain` navigates recursively down `chainTo` and replaces the last element with the result of `fChain`:\n\n* On the `Do` side `bindChain` calls `mapDSL` to apply the function to the next `ChainDSL` node.\n* On the `Return` side it replaces the `Return a` for a call to the chain to be appended `fChain`.\n\nIn a sense `ChainDSL` is actually the opposite of a `List<DSL<'a>>`. In a List new elements are\ninserted at the head, here they are attached at the tail end.\n\nNow we can bind setName, getName & setResult from above like this: *)\n\nlet exF2 = setName \"John\" \n           |> bindChain (fun _    -> getName         )\n           |> bindChain (fun name -> setGreeting name)\n\n(** \n`val exF2 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nwhich is the same as this: *)\n\nlet exF3 = set \"name\" \"John\" \n           |> bindChain (fun _ -> get \"name\"                           )\n           |> bindChain (fun v -> set \"greeting\" (sprintf \"Hello %s\" v))\n(** \n`val exF3 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nand this: *)\nlet (>>=) v f = bindChain f v\n\nlet exF4 = set \"name\" \"John\" \n           >>= fun _    -> get \"name\" \n           >>= fun name -> set \"greeting\" (sprintf \"Hello %s\" name)\n(**\n`val exF4 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nUsing Computational Expressions\n-------------------------------\n\nNow lets try it with Computational Expressions.\nFirst we define a builder class.\n*)\n\ntype ChainDSLBuilder () =\n    member this.Return      v = Return v\n    member this.ReturnFrom mv = mv\n    member this.Zero       () = Return ()\n    member this.Bind   (v, f) = v >>= f\n\nlet chainDSL = ChainDSLBuilder ()\n\n(**\nAnd now we use the computational expression like this.\n*)\n\nlet exF5 = chainDSL {\n    do!         set \"name\"     \"John\"\n    let! name = get \"name\"\n    do!         set \"greeting\" (sprintf \"Hello %s\" name)\n}\n(**\n`val exF5 : ChainDSL<unit> =\n  Do (Set (\"name\",\"John\",Do (Get (\"name\",<fun:mapDSL@87-2>))))`\n\nThe Interpreters\n------------------\n  \nNow we are going to create an interpreter to execute the AST created.\n\nThis first version is very simple it does not store or retrieve any values, just prints out the commands.\n*)\n(*** define-output:interpreter1 ***)    \nlet rec interpreter1: ChainDSL<'a> -> 'a =\n    fun               chain        ->\n        match chain with\n        | Return v -> printfn \"return %A\" v\n                      v\n        | Do   dsl -> \n            match dsl with\n            | Get(key,        nextF) -> printfn \"Get %s\" key\n                                        nextF (sprintf \"<get.%s>\" key) \n            | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                        next                           \n            |> interpreter1\n\ninterpreter1 exF5\n(*** include-output:interpreter1 ***)\n(**\nThis next version actually stores and retrieves the values in a `Map` object, and when finished prints its content. \n*)\n(*** define-output:interpreter2 ***)    \nlet interpreter2 chain = \n    let rec interpreter2r: Map<string, string> -> ChainDSL<'a> -> 'a =\n        fun                dataStore              chain        ->\n            match chain with\n            | Return v -> printfn \"return %A\\n%A\" v dataStore\n                          v\n            | Do   dsl -> \n                match dsl with\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n\n    interpreter2r (Map.ofList []) chain\n\ninterpreter2 exF5\n(*** include-output:interpreter2 ***)\n\n(**\nA slightly longer example:\n*)\n\n(*** define-output:interpreter2b ***)    \n\nchainDSL {\n    do!           set \"first-name\" \"John\"\n    do!           set \"last-name\"  \"Smith\"\n    let! first  = get \"first-name\"\n    let! last   = get \"last-name\"\n    do!           set \"full-name\" (first + \" \"  + last)\n    let! full   = get \"full-name\"\n    return        sprintf \"Hello %s\" full\n}\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2b ***)\n(** Return value:*)\n(*** include-it:interpreter2b ***)\n(**\nTrying to replicate this last example without the computational expression \nrequires explicitly nesting some of the calls.\n\nIt would look like this:\n\n*)\n(*** define-output:interpreter2c ***)    \n\nset \"first-name\" \"John\" \n>>= fun _     -> set \"last-name\"  \"Smith\"            \n>>= fun _     -> get \"first-name\"                    \n>>= fun first -> get \"last-name\" \n                 >>= fun last -> set \"full-name\" (first + \" \"  + last)\n>>= fun _     -> get \"full-name\"\n>>= fun full  -> Return (sprintf \"Hello %s\" full)\n|> interpreter2\n(** Output:*)\n(*** include-output:interpreter2c ***)\n(** Return value:*)\n(*** include-it:interpreter2c ***)\n\n(**\nTwo in one\n----------\n\nSo, do we really need two types, the Free Monad and the DSL?\n\nI do not think it is necessary, the free monad helps in binding the elements of the DSL. \nThe same can be achieved just by adding the `Return` option to the DSL.\n\nHere is the same implementation with just the DSL type:\n*)\n\nmodule DSL2 =\n    type DSL<'a> =\n        | Set of key: string * value: string *  DSL<'a>\n        | Get of key: string *       (string -> DSL<'a>)\n        | Return of 'a\n    \n    let set key value = Set (key, value,          Return ())\n    let get key       = Get (key,        fun v -> Return v )\n    \n    let bind: ('a -> DSL<'b>) -> DSL<'a> -> DSL<'b> =\n        fun   fChain             chainTo ->\n           let rec appendTo chain =\n               match chain with\n               | Set (k, v,  next) -> Set (k, v,  next |> appendTo)\n               | Get (k,    fNext) -> Get (k,    fNext >> appendTo)\n               | Return  v         -> fChain v\n           appendTo chainTo\n\n    let (>>=) v f = bind f v\n\n    let interpreter2 dsl =\n        let rec interpreter2r: Map<string, string> -> DSL<'a> -> 'a =\n            fun                dataStore              dslR    ->\n                match dslR with\n                | Return v               -> printfn \"return %A\\n%A\" v dataStore\n                                            v\n                | Get(key,        nextF) -> dataStore \n                                            |> Map.find key \n                                            |> (fun v -> printfn \"Get %s -> '%s'\" key v ; v )\n                                            |> nextF\n                                            |> interpreter2r dataStore\n                | Set(key, value, next ) -> printfn \"Set %s '%s'\" key value\n                                            next\n                                            |> interpreter2r (dataStore |> Map.add key value)\n        interpreter2r (Map.ofList []) dsl\n\n(**\nThere you have it the DSL definition, helper functions, the bind function and the interpreter.\nHere is the last example again.\n*)\n(*** define-output:dsl2 ***)    \n\n    set \"first-name\" \"John\" \n    >>= fun _     -> set \"last-name\"  \"Smith\"            \n    >>= fun _     -> get \"first-name\"                    \n    >>= fun first -> get \"last-name\" \n                     >>= fun last -> set \"full-name\" (first + \" \"  + last)\n    >>= fun _     -> get \"full-name\"\n    >>= fun full  -> Return (sprintf \"Hello %s\" full)\n    |> interpreter2\n(** Output:*)\n(*** include-output:dsl2 ***)\n(** Return value:*)\n(*** include-it:dsl2 ***)    \n(*** hide ***)\ninterpreter2 exF1\ninterpreter2 exF2\ninterpreter2 exF3\ninterpreter2 exF4\ninterpreter2 exF5\n", "snpParentIdO": {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1ed5f12f-c8ae-42fb-bfb6-f27d6c2faf8c"}, "snpName": "NoFreeMonad", "snpContent": "(**\n# No Free Monad for old men\n\n### ** *Update!* **\nClarifications from Seemann et al. showed me\nthat Free Monads are used not just for keeping code pure but also as the equivalent of an interface in OOP.\nFor that reason I added a mechanism for dependency injection.\n\n### What is better than Free Monad? Async Monad!\nI have been reading with great interest a series of posts by Mark Seemann \nabout dependency injection (and 'rejection') using F#.\nHis very pedagogical style together with the fact that he, like\nme, has gone from OOP to FP made it especially relevant and eye-opening for me.\nIn those posts, he uses the Free Monad as a functional alternative for dependency injection.\nThey are a must read:\n\n- [From dependency injection to dependency rejection](http://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/)\n- [Pure interactions](http://blog.ploeh.dk/2017/07/10/pure-interactions/)\n\nSeemann's posts work with very didactic examples of a restaurant reservation study case. I wanted to write my own take on the same study case basically\ncopying his code and rewriting it in my own style and doing some variations to help me understand it better.\n\nI myself had analyzed the Free Monad before in another [post](/FreeMonad.html). That post, very much like this one,\nwas intended mainly for my own consumption. In it, I concluded that two types: the DSL Functor and the Free Monad\ncould be fused into one, thus reducing boilerplate. I wanted to try the same approach with Seamann's \ncase study where he combines two Free Monads (by stacking them and/or adding them as suggested by a commenter)\nto see if my conclusion still held true.\n\n### A funny thing happened.\nI could not finish. As is logical, my mock HTTP Client functions return `Async<>` and\nso I wrote my interpreter with type `ReservationsApi<'a> -> Async<'a>`.\n*)\n(*** hide  ***)\nopen System\ntype ReservationR = ReservationR\ntype SlotR = { Date : DateTime; SeatsLeft : int }\n\ntype ReservationsApi<'a> =\n| GetSlots        of DateTime     * (SlotR list -> ReservationsApi<'a>)\n| PostReservation of ReservationR *               ReservationsApi<'a>\n| ReturnRA        of                                             'a\n\nlet getSlotsHttp        d = async { return [] }\nlet postReservationHttp r = async { () }\n    \n(***)\n// interpreterReservationsApi: ReservationsApi<'a> -> Async<'a>\nlet rec interpreterReservationsApi resApi = \n    match resApi with\n    | ReturnRA         x         -> async { return x }\n    | GetSlots        (d, fNext) -> async { let!     slots = getSlotsHttp d \n                                            return!  fNext slots |> interpreterReservationsApi }\n    | PostReservation (r,  next) -> async { do!       postReservationHttp r\n                                            return!   next       |> interpreterReservationsApi }\n(**\nThe interpreter was going from a Monad to another Monad. Hmmm!\nThat led me to the realization that the interpreter written that way was a pure function because \nall the functions it was calling were also pure. Those functions return `Async<>` values, which makes them pure too.\nThat made me question the whole exercise. In order to make the code pure, all I needed to do\nwas wrap the impure functions with `Async<>`. What could be easier?\n\nNo DSL, no Free Monad, no builder types, no interpreters were needed. `Async.RunSynchronously` was the interpreter.\n\nSo I rewrote the exercise using Asyncs instead:\n\n## 1.- [Command-line wizard](http://blog.ploeh.dk/2017/07/17/a-pure-command-line-wizard/):\n\nTaken from [here](http://blog.ploeh.dk/2017/07/17/a-pure-command-line-wizard/).\n\nThe console api functions are defined in a module with a dummy definition, but they are mutable:\n*)\n\nmodule CliInjection =\n    let mutable private       readLine  : unit   -> string = fun () -> \"\"\n    let mutable private       writeLine : string -> unit   = ignore\n    let inject(read, write) = readLine  <- read\n                              writeLine <- write\n\n    let WriteLine s         = async {        writeLine s  }\n    let ReadLine            = async { return readLine  () }\n\n(**\nThe `inject` function provides the mechanism for injecting the implementation.\nThe public functions `WriteLine` `ReadLine` use the `Async<>` monad to make them pure.\n\nSome derived Console API functions\n*)\nlet rec promptFor test prompt reject = async {\n    do!         CliInjection.WriteLine prompt\n    let!   v =  CliInjection.ReadLine\n    match  v |> test with\n    | Some r -> return  r\n    | None   -> do!     CliInjection.WriteLine             reject\n                return! promptFor test prompt reject\n}\n\ntype Net.Mail.MailAddress with\n    static member TryParse s = try Net.Mail.MailAddress s |> Some with e -> None\n\nlet promptForString = promptFor (fun (s:string) ->  s.Trim()   |> function \"\"      -> None   | r -> Some r)\nlet promptForEMail  = promptFor (Net.Mail.MailAddress.TryParse                                            )\nlet promptForNumber = promptFor (Int32               .TryParse >> function true, r -> Some r | _ -> None  )\nlet promptForDate   = promptFor (DateTime            .TryParse >> function true, r -> Some r | _ -> None  )\n\n(**\nThe reservation record:\n*)\ntype Reservation = {\n    Date     : DateTime\n    Name     : string\n    Email    : string\n    Quantity : int \n}\n(**\nA wizard to read the reservation:\n*)\nlet readReservationRequest = async {\n    let! count = promptForNumber \"Please enter number of diners:\"   \"Not a valid integer.\"\n    let! date  = promptForDate   \"Please enter your desired date:\"  \"Not a valid date.\"\n    let! name  = promptForString \"Please enter your name:\"          \"Not a valid name.\"\n    let! email = promptForEMail  \"Please enter your email address:\" \"Not a valid email.\"\n    return { Date = date; Name = name; Email = email.Address; Quantity = count } \n  }\n(**\nTo execute the monad we inject the desired implementation and call Async.RunSynchronously\n*)\n\nlet getReservation cli =\n    CliInjection.inject cli\n    readReservationRequest\n    |> Async.RunSynchronously\n    |> printfn \"%A\"\n\n(**\nNow lets define a MockConsole for testing:\n*)\n\nmodule MockConsole =\n    let readLines (txt:string) = \n        let current = txt.Split '\\n' |> Array.map (fun s -> s.Trim()) |> Array.filter ((<>)\"\") |> ref\n        fun () ->\n            let head = Array.head !current\n            current := (!current).[1..]\n            printfn \"%s\" head\n            head\n    let input1 = \"\n        x\n        5\n        x\n        11/11/11\n        Abe\n        x\n        amieres@b.c\n    \"\n    let input2 = \"\n        15\n        12/31/1911\n        Schroedinger's cat\n        Schroedinger@dead.alive\n    \"\n    let toInject1() = (readLines input1, printfn \"%s\"   )\n    let toInject2() = (readLines input2, printfn \":: %s\")\n\n(**\nWe run it passing the functions to be injected:\n*)\n(*** define-output:cliInject1 ***)    \ngetReservation <| MockConsole.toInject1()\n(*** include-output:cliInject1 ***)    \n(**\nAnother run with different functions. Notice the difference in the WriteLine\noutput between the 2 outputs:\n*)\n(*** define-output:cliInject2 ***)    \ngetReservation <| MockConsole.toInject2()\n(*** include-output:cliInject2 ***)    \n(**\n\nTo call it with the actual Console implementation:\n\n    let getReservationConsole() = getReservation <| (Console.ReadLine, Console.WriteLine)\n\n## 2.- [HTTP API client module](http://blog.ploeh.dk/2017/07/31/combining-free-monads-in-f/)\n\nTaken from [here](http://blog.ploeh.dk/2017/07/31/combining-free-monads-in-f/).\n\nThe Slot type:\n*)\ntype Slot = { Date : DateTime; SeatsLeft : int }\n(**\nLets define the api injection module this way, following the same recipe as above.\nThe only difference is that we already expect the functions to return `Async<>`:\n*)\nmodule ResApiInjection =\n    let mutable private     getSlots       : DateTime    -> Async<Slot list> = fun _ -> async { return [] }\n    let mutable private     postReservation: Reservation -> Async<unit>      = fun _ -> async { ()        }\n    let inject(get, post) = getSlots        <- get\n                            postReservation <- post\n    \n    let GetSlots        date = getSlots        date\n    let PostReservation res  = postReservation res \n    \n(**\nA reservation wizard that queries the HTTP server and makes the reservation.\n*)\nlet tryReserve          = async {\n    let! count          = promptForNumber \"Please enter number of diners:\"   \"Not a valid integer.\"\n    let! date           = promptForDate   \"Please enter your desired date:\"  \"Not a valid date.\"\n    let! slots          = ResApiInjection.GetSlots date\n    let  availableSeats = slots |> List.sumBy (fun slot -> slot.SeatsLeft)\n    if availableSeats   < count\n    then do! sprintf \"****************    \nOnly %i remaining seats.\n****************\" availableSeats  |> CliInjection.WriteLine\n    else let! name      = promptForString \"Please enter your name:\"          \"Not a valid name.\"\n         let! email     = promptForEMail  \"Please enter your email address:\" \"Not a valid email.\"\n         do! { Date     = date; Name = name; Email = email.Address; Quantity = count } \n                                  |> ResApiInjection.PostReservation\n         do! sprintf \"****************\n%s party of %d, reserved for %A.\n****************\" name count date |> CliInjection.WriteLine\n    }\n\n(**\nTo run it we pass both the Console api and the reservations api:\n*)\n\nlet reserve cli resApi = \n    CliInjection   .inject cli\n    ResApiInjection.inject resApi\n    tryReserve \n    |> Async.RunSynchronously\n\n(**\nHere is an implementation for the Reservations api that returns a random number of available seats:\n*)\n\nmodule RandomResApi =\n    let random = lazy (System.Random DateTime.Now.Millisecond)\n    \n    let getSlotsHttp         date             = async { \n        do! Async.Sleep 1000\n        return [ { Date = date ; SeatsLeft = random.Force().Next(20) } ] \n      }\n    let postReservationHttp (res:Reservation) = async { \n        do! Async.Sleep 1500\n      }\n    let toInject() = (getSlotsHttp, postReservationHttp)\n(** We call `reserve` passing both apis *)\n(*** define-output:reserve1 ***)    \nreserve <| MockConsole.toInject2() <| RandomResApi.toInject()\n(*** include-output:reserve1 ***)\n(** As its name indicates the output is random.\n\n\nFor testing we can have another version with a fixed number of available seats:\n*)\nmodule MockReservationAPI =\n    let mutable available = 18\n\n    let getSlotsHttp         date             = async { \n        do! Async.Sleep 1000\n        return [ { Date = date ; SeatsLeft = available } ] \n      }\n    let postReservationHttp (res:Reservation) = async { \n        do! Async.Sleep 1500\n        available <- available - res.Quantity \n      }\n    let toInject() = (getSlotsHttp, postReservationHttp)\n\n(*** define-output:reserve2 ***)    \nreserve <| MockConsole.toInject2() <| MockReservationAPI.toInject()\n(*** include-output:reserve2 ***)    \n(** \nSince originally there were 18 seats, reservation for 5 more will fail:\n*)\n(*** define-output:reserve3 ***)    \nreserve <| MockConsole.toInject1() <| MockReservationAPI.toInject()\n(*** include-output:reserve3 ***)    \n(**\n\nUsing async we accomplish the same objective and avoid a lot of boilerplate.\nTrue, this does not follow the DSL-interpreter pattern typical of the Free Monad\nand there may be other uses that are possible with the Free Monad,\nbut this solution allows dependency injection,\nseparation of pure and impure code, separation of concerns and composition, \nall in a very clean and powerful way.\n\nUsing the `async` Computational Expression has the added advantage of\nalready having strong implementations for:\n\n- `try-finally`\n- `try-with`\n- `use` and `use!`\n- `while`\n- `for` \n\n... and other computational expressions features that are not easy to implement and/or new ones that may be added in the future.\n\n*)\n\n", "snpParentIdO": {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"63d38e99-7fb8-45da-9229-14f64b4e7121"}, "snpName": "FreeMonadRestaurant", "snpContent": "(**\n# Composing Free Monads\n\nA second analysis of the Free Monad - Interpreter pattern in F# based on \nMark Seemann's series of articles: \n\n- [From dependency injection to dependency rejection](http://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/)\n- [Pure interactions](http://blog.ploeh.dk/2017/07/10/pure-interactions/)\n\nThe main purpose of writing this post is to enhance my own understanding on these issues.\nI'm going to copy Seemann's definition with minor changes using my own style of coding.\nIn those articles Seemann poses a restaurant reservation case divided in two parts.\nTo understand this article I recommend you read them first. Seemann methodically and very pedagogically\nexplains step by step every detail of his solution.\n\n## Part 1 - The CLI DSL\n\nA CLI or command line interface wizard for taking the details of a reservation.\nWe use a Free Monad to 'inject' the implementation of the console read and write operations.\nThat way we can have versions for testing or for other type of user interaction like speech recognition.\n\nThese are the instructions for reading and writing to the console:\n\n    type ConsoleOperation<'a> =\n    | ReadLine  of (string -> 'a)\n    | WriteLine of  string  * 'a\n\nA map function will make it a Functor: \n\n    //  mapCLI : ('a -> 'b) -> ConsoleOperation<'a> -> ConsoleOperation<'b>\n    let mapCLI f inst =\n        match inst with\n        | ReadLine      fNext  -> ReadLine  (  fNext >> f)\n        | WriteLine (x,  next) -> WriteLine (x, next |> f)\n\nThe Free Monad can be defined this way:\n\n    type ConsoleProgram<'a> =\n    | Free of ConsoleOperation<ConsoleProgram<'a>>\n    | Pure of 'a\n    \n    //      bind : ('a -> ConsoleProgram<'b>) -> ConsoleProgram<'a> -> ConsoleProgram<'b>\n    let rec bind fChain inst = \n        match inst with\n        | Free instruction -> instruction |> mapCLI (bind fChain) |> Free\n        | Pure x           ->                             fChain x\n\n### The Functor and the Monad\n\nIn a previous article I argued that creating two types to create a Monad was not necessary. The purpose of the \nFree Monad is to chain (or bind) the elements of the DSL and to provide an end point to the chain\n(the `Pure` element above, although I will use `Return` in the next code). \n\nIn Haskell the Free monad can be applied automatically thanks to the higher kinded types. \nIn F# we use 'recipes' instead which means we must add all the boiler plate code everytime.\nIn that case it is simpler to just merge the two types into one this way:\n*)\nopen System\ntype ConsoleProgram<'a> =\n| ReadLine  of (string -> ConsoleProgram<'a>)\n| WriteLine of  string  * ConsoleProgram<'a>\n| ReturnCP  of                           'a\n(**\nI use the suffix Program even though it is only a\ncouple of instructions (read and write) and some parameters. But when we bind several\nof these together with other code it can truly become a program.\n\nNow we are going to create a couple of helper functions.\n*)\nlet writeLine (s:string) = WriteLine(s, ReturnCP())\nlet readLine             = ReadLine     ReturnCP\n(**\nThe `writeLine` function has type `string -> ConsoleProgram<unit>` \nand `readLine` is not even a function, although it 'feels' like one. It is a value of type `ConsoleProgram<string>`\n\nTo complete the Monad we need a bind function:\n*)\n// bindConsole : ('a -> ConsoleProgram<'b>) -> ConsoleProgram<'a> -> ConsoleProgram<'b>\nlet bindConsole fChain   chainTo =\n    let rec appendTo chain   =\n        match chain with\n        | ReadLine      fNext  -> ReadLine  (  fNext >> appendTo)\n        | WriteLine (s,  next) -> WriteLine (s, next |> appendTo)\n        | ReturnCP   v         -> fChain v\n    appendTo chainTo        \n(** \nThe `bindConsole` function chains together several `ConsoleProgram` elements.\nSo instead of a Functor and a Monad like in the original articles we just have one Monad.\n\nIn order to use Computational Expressions (a great feature of F#) we define\na builder type and value:\n*)\ntype ConsoleProgramBuilder () =\n    member this.Bind       (x, f) = bindConsole f x\n    member this.ReturnFrom  x     =           x\n    member this.Return      x     = ReturnCP  x\n    member this.Zero       ()     = ReturnCP ()\n\nlet console = ConsoleProgramBuilder ()\n(**\nComputational Expressions let us use Monads as if it were imperative code.\nEvery time we use a `let!` (called let bang), `do!`, and `return!` the compiler automatically\ninserts a call to bind.\n\nThe following function uses `readLine` and `writeLine` to ask for an input from the user \nand then validates it with the `test` function. If validation fails it repeats the question again.\n*)\nlet rec promptFor test prompt reject = console {\n    do!         writeLine prompt\n    let!   v =  readLine\n    match  v |> test with\n    | Some r -> return  r\n    | None   -> do!     writeLine             reject\n                return! promptFor test prompt reject\n}\n(**\nNow we can create other derived functions:\n*)\ntype Net.Mail.MailAddress with\n    static member TryParse s = try Net.Mail.MailAddress s |> Some with e -> None\n\nlet promptForString = promptFor (fun (s:string) ->  s.Trim()   |> function \"\"      -> None   | r -> Some r)\nlet promptForEMail  = promptFor (Net.Mail.MailAddress.TryParse                                            )\nlet promptForNumber = promptFor (Int32               .TryParse >> function true, r -> Some r | _ -> None  )\nlet promptForDate   = promptFor (DateTime            .TryParse >> function true, r -> Some r | _ -> None  )\n(** \nLets use this CLI functions to collect the information for a reservation:\n*)\ntype Reservation = {\n    Date     : DateTime\n    Name     : string\n    Email    : string\n    Quantity : int \n}\n\nlet readReservationRequest = console {\n    let! count = promptForNumber \"Please enter number of diners:\"   \"Not a valid integer.\"\n    let! date  = promptForDate   \"Please enter your desired date:\"  \"Not a valid date.\"\n    let! name  = promptForString \"Please enter your name:\"          \"Not a valid name.\"\n    let! email = promptForEMail  \"Please enter your email address:\" \"Not a valid email.\"\n    return { Date = date; Name = name; Email = email.Address; Quantity = count } \n  }\n(**\nThe object `readReservationRequest` is of type `ConsoleProgram<Reservation>`.\nIt is not a function, it is a wrapper object that defines the steps needed to read\na Reservation from the console.\n\n### The CLI Interpreter(s)\n\nIf you look at the code above you can clearly understand what the intention\nof the code is: to read and write to the console. You can understand it from the names\nof the functions and the prompts but at no point has there\nbeen any calls to actual read/write Console commands.\n\nFor that, we need an interpreter that can process the ConsoleProgram returning the result.\nThe intepreter recursively traverses the Monad executing the chain of instructions:\n*)\n// consoleInterpreter : ConsoleProgram<'a> -> 'a\nlet consoleInterpreter readLine writeLine program = \n    let rec interpreter = \n        function\n        | ReturnCP   x         -> x\n        | ReadLine      fNext  -> readLine () |> fNext |> interpreter\n        | WriteLine (s,  next) -> writeLine s ;   next |> interpreter\n    interpreter program\n(**\nWe curry our generic interpreter with the actual Console functions\n*)\nmodule Console =\n    let interpreter v = consoleInterpreter \n                            Console.ReadLine \n                            Console.WriteLine\n                            v\n(**\nNow we can run the program\n*)\nlet main _ =\n    readReservationRequest\n    |> Console.interpreter\n    |> printfn \"%A\"\n(**\nA second version of the interpreter may be used for testing:\n*)\nmodule MockConsole =\n    let input = \"\n        x\n        5\n        x\n        11/11/11\n        Abe\n        x\n        amieres@b.c\n    \"\n    let mutable current = input.Split '\\n' |> Array.map (fun s -> s.Trim()) |> Array.filter ((<>)\"\")\n    let interpreter v = consoleInterpreter \n                            (fun () -> let head = Array.head current\n                                       current <- current.[1..]\n                                       printfn \"%s\" head\n                                       head)\n                            (printfn \"%s\")\n                            v\n\n(**\nAnd run this way:\n*)\nreadReservationRequest\n|> MockConsole.interpreter\n|> printfn \"%A\"\n(** \nOutput:\n\n    Please enter number of diners:\n    x\n    Not a valid integer.\n    Please enter number of diners:\n    5\n    Please enter your desired date:\n    x\n    Not a valid date.\n    Please enter your desired date:\n    11/11/11\n    Please enter your name:\n    Abe\n    Please enter your email address:\n    x\n    Not a valid email.\n    Please enter your email address:\n    amieres@b.c\n    {Date = 11/11/2011 12:00:00 AM;\n     Name = \"Abe\";\n     Email = \"amieres@b.c\";\n     Quantity = 5;}\n\n\n\n## Part 2 - The Reservation HTTP Client\n\nFor the second part we are going to interact with a mock HTTP Service that provides\nan API to query availablity and to perform the reservation. For that we define another DSL and Free Monad.\n*)\ntype Slot = { Date : DateTime; SeatsLeft : int }\n\ntype ReservationsApi<'a> =\n| GetSlots        of DateTime    * (Slot list -> ReservationsApi<'a>)\n| PostReservation of Reservation *               ReservationsApi<'a>\n| ReturnRA        of                                             'a\n(**\nThe bind function:\n*)\nlet bindReservationsApi fChain   chainTo =\n    let rec appendTo chain   =\n        match chain with\n        | GetSlots        (d, fNext) -> GetSlots        (d, fNext >> appendTo)\n        | PostReservation (s,  next) -> PostReservation (s,  next |> appendTo)\n        | ReturnRA         v         -> fChain v\n    appendTo chainTo\n(**\nHelper functions:\n*)\nlet getSlots        date = GetSlots        (date, ReturnRA  )\nlet postReservation res  = PostReservation (res , ReturnRA())\n(**\nThe Computation Expression builder:\n*)\ntype ReservationsApiBuilder () =\n    member this.Bind       (x, f) = bindReservationsApi f x\n    member this.ReturnFrom  x     =           x\n    member this.Return      x     = ReturnRA  x\n    member this.Zero       ()     = ReturnRA ()\n\nlet reservationsApi = ReservationsApiBuilder ()\n\n(**\nHere we have a function that given a reservation record interacts with the API and returns a boolean confirming or denying the reservation.\n*)\n\nlet confirmReservation (res:Reservation) = reservationsApi {\n    let! slots          = getSlots res.Date\n    let  availableSeats = slots |> List.sumBy (fun slot -> slot.SeatsLeft)\n    if availableSeats < res.Quantity\n         then return false\n    else do! res |> postReservation \n         return true\n}\n\n(** \nLet us call the function with a reservation record.\n*)\n\nlet reservationConfirmed =\n    {     Date     = DateTime.Now\n          Name     = \"Schroedinger\"\n          Email    = \"Schroedinger@dead.alive\"\n          Quantity = 11\n    } |> confirmReservation\n\n(**\nThe type of `reservationConfirmed` is `ReservationsApi<bool>` which means\nthat even though we have all the data and the program correctly set up,\nwe do not yet know if the reservation is good or not. \nThe reservation is like the Schroedinger cat, it is neither dead nor alive (or is both simultaneously).\n\nTo find out which is it, we have to run it through the interpreter which we have not defined yet.\nFirst we define a generic interpreter that receives the functions `getSlots` and `postReservation`:\n*)\nlet rec interpreterReservationsApi getSlots postReservation resApi =\n    let rec interpreter = \n        function\n        | ReturnRA         x         -> x\n        | GetSlots        (d, fNext) -> getSlots d        |> fNext |> interpreter\n        | PostReservation (r,  next) -> postReservation r ;   next |> interpreter\n    interpreter resApi\n\n(**\nIn the module `MockReservationAPI` we are going to create the functions `getSlotsHttp` and `postReservationHttp`\nthat simulate going to a web server and performing the operations.\nSince Http operations are typically asynchronous we are going to make them return async.\nAlso this version determines availability at random.\n*)\nmodule RandomReservationAPI =\n    let random = lazy (System.Random DateTime.Now.Millisecond)\n\n    let getSlotsHttp         date             = async { do! Async.Sleep 1000\n                                                        return [ { Date = date ; SeatsLeft = random.Force().Next(20) } ] }\n    let postReservationHttp (res:Reservation) = async { do! Async.Sleep 1500                                             }\n(**\nWe curry our generic interpreter with the functions above:\n*)\n    let interpreter = interpreterReservationsApi \n                        (getSlotsHttp        >> Async.RunSynchronously) \n                        (postReservationHttp >> Async.RunSynchronously)\n(**\nWe can run it through the interpreter like this.\n*)\nreservationConfirmed\n|> RandomReservationAPI.interpreter\n|> printfn \"%A\"\n(**\nThe output is sometimes `true` and sometimes `false` depending on the pseudo-random number generator above.\n\nA second version could have an initial fixed number of available spots. Like this:\n*)\n\nmodule MockReservationAPI =\n    let mutable available = 30\n\n    let getSlotsHttp         date             = async { do! Async.Sleep 1000\n                                                        return [ { Date = date ; SeatsLeft = available } ] }\n    let postReservationHttp (res:Reservation) = async { do! Async.Sleep 1500\n                                                        available <- available - res.Quantity }\n    let interpreter = interpreterReservationsApi \n                        (getSlotsHttp        >> Async.RunSynchronously) \n                        (postReservationHttp >> Async.RunSynchronously)\n(**\nWe run it several times through the interpreter like this.\n*)\n[1..4]\n|> Seq.iter (fun _ ->\n    reservationConfirmed\n    |> MockReservationAPI.interpreter\n    |> printfn \"%A\"\n)\n(**\nOutput:\n\n    true\n    true\n    false\n    false\n\n# Combining the two Free Monads\n\nWe have two DSL Monads that seem to work well individually, but how do we use them together?\nI see several options:\n\n- Stacking the monads and creating a Computational Expression Builder. This is the approach used in the original article.\n- Creating a third Free Monad that combines the other two. <del>I am going to try this one.</del>. Tried it, turns out is not possible.\n  Long story short the free monad cannot have 2 generic types ('DSL and 'next) \n  because every element of the chain needs to have the same type which impedes conversion of types.\n  Since the elements of one DSL monad cannot tie directly with the other DSL they need to have same resulting type.\n    type CombinedOperation<'a, 'b> =\n    | CliOperation   of ConsoleProgram< 'a> * ('a -> 'b)\n    | ReservationApi of ReservationsApi<'a> * ('a -> 'b)\n- Adding the DSL Functors and using a Free Monad. This is a suggestion by [George Pollard](http://blog.ploeh.dk/2017/07/24/combining-free-monads-in-haskell/) in a comment to the Haskell article.\n  I am going to try this one.\n\nIf we want to be able to compose the DSLs we need to have them separate from the Free Monad.\nThat is an argument for having the Free Monad separate from the DSL.\n*)\n\nmodule Composite =\n\n    type ConsoleProgram<'next> =\n    | ReadLine  of (string -> 'next)\n    | WriteLine of  string  * 'next\n    \n    let mapConsoleProgram f = \n        function\n        | ReadLine     fNext  -> ReadLine (  fNext >> f)\n        | WriteLine (s, next) -> WriteLine(s, next |> f)\n    \n    let writeLine (s:string) = WriteLine(s, ()) \n    let readLine             = ReadLine     id\n    \n    type ConsoleMonad<'a> =\n    | ConsoleP  of ConsoleProgram<ConsoleMonad<'a>>\n    | ReturnCP  of                             'a\n    \n    let bindConsole fChain   chainTo =\n        let rec appendTo chain   =\n            match chain with\n            | ConsoleP v -> ConsoleP  (mapConsoleProgram appendTo v)\n            | ReturnCP v -> fChain v\n        appendTo chainTo        \n\n    let liftCP x = ConsoleP (mapConsoleProgram ReturnCP x)\n\n    type ConsoleProgramBuilder () =\n        member this.Bind       (x, f) = bindConsole f         x\n        member this.Bind       (x, f) = bindConsole f (liftCP x)\n        member this.ReturnFrom  x     =           x\n        member this.Return      x     = ReturnCP  x\n        member this.Zero       ()     = ReturnCP ()\n    \n    let console = ConsoleProgramBuilder ()\n    let rec promptFor test prompt reject = console {\n        do!         writeLine prompt\n        let!   v =  readLine\n        match  v |> test with\n        | Some r -> return  r\n        | None   -> do!     writeLine             reject\n                    return! promptFor test prompt reject\n    }\n    (**\n    Now we can create other derived functions:\n    *)\n    \n    let promptForString = promptFor (fun (s:string) ->  s.Trim()   |> function \"\"      -> None   | r -> Some r)\n    let promptForEMail  = promptFor (Net.Mail.MailAddress.TryParse                                            )\n    let promptForNumber = promptFor (Int32               .TryParse >> function true, r -> Some r | _ -> None  )\n    let promptForDate   = promptFor (DateTime            .TryParse >> function true, r -> Some r | _ -> None  )\n\n(***)\n    \n    type ReservationsApi<'next> =\n    | GetSlots        of DateTime    * (Slot list -> 'next)\n    | PostReservation of Reservation *               'next\n    \n    let mapReservationsApi f = \n        function\n        | GetSlots        (d, fNext) -> GetSlots       (d, fNext >> f)\n        | PostReservation (s,  next) -> PostReservation(s,  next |> f)\n    \n    let getSlots        date = GetSlots        (date, id)\n    let postReservation res  = PostReservation (res , ())\n    \n    type CompositeMonad<'result> =\n    | ConsoleProgram  of ConsoleProgram< CompositeMonad<'result>>\n    | ReservationsApi of ReservationsApi<CompositeMonad<'result>>\n    | ReturnC         of                                'result\n    \n    let bindCompositeDSL fChain   chainTo =\n        let rec appendTo chain   =\n            match chain with\n            | ConsoleProgram  v -> ConsoleProgram (mapConsoleProgram  appendTo v)\n            | ReservationsApi v -> ReservationsApi(mapReservationsApi appendTo v)\n            | ReturnC         v ->                                      fChain v\n        appendTo chainTo\n\n    let     liftCPtoCD cp = ConsoleProgram  (mapConsoleProgram  ReturnC cp)\n    let     liftRAtoCD ra = ReservationsApi (mapReservationsApi ReturnC ra)\n    let rec liftCMtoCD =\n        function\n        | ConsoleP v -> mapConsoleProgram liftCMtoCD v |> ConsoleProgram\n        | ReturnCP v -> ReturnC v\n    \n    type CombinedProgramBuilder () =\n        member this.Bind       (x, f) = bindCompositeDSL f         x\n        member this.Bind       (x, f) = bindCompositeDSL f (liftCPtoCD x)\n        member this.Bind       (x, f) = bindCompositeDSL f (liftCMtoCD x)\n        member this.Bind       (x, f) = bindCompositeDSL f (liftRAtoCD x)\n        member this.ReturnFrom  x     =           x\n        member this.Return      x     = ReturnC   x\n        member this.Zero       ()     = ReturnC  ()\n    \n    let composite = CombinedProgramBuilder ()\n    \n    let tryReserve          = composite {\n        let! count          = promptForNumber \"Please enter number of diners:\"   \"Not a valid integer.\" \n        let! date           = promptForDate   \"Please enter your desired date:\"  \"Not a valid date.\"\n        let! slots          = getSlots date\n        let  availableSeats = slots  |> List.sumBy (fun slot -> slot.SeatsLeft)\n        if   availableSeats < count\n        then do! sprintf \"Only %i remaining seats.\" availableSeats                         |> writeLine\n        else let! name      = promptForString \"Please enter your name:\"          \"Not a valid name.\"\n             let! email     = promptForEMail  \"Please enter your email address:\" \"Not a valid email.\"\n             do! { Date     = date; Name = name; Email = email.Address; Quantity = count } |> postReservation\n             do! sprintf \"%s party of %d, reserved for %A.\" name count date                |> writeLine\n    }\n\n(*\n    module MockComposite =\n        let interpreter = \n    \n    [1..4]\n    |> Seq.iter (fun _ ->\n        tryReserve\n        |> MockComposite.interpreter\n        |> printfn \"%A\"\n    )\n    *)", "snpParentIdO": {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"206bb511-43c5-4c21-aeff-5f391edd21b0"}, "snpName": "Update Entries", "snpContent": "//#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages\\FSharp.Formatting\\lib\\net40\"\n//#r \"FSharp.CodeFormat.dll\"\n//#r \"FSharp.Literate.dll\"\n//\n//open FSharp.Literate\n//\n//Literate.ProcessScriptFile( @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\NoFreeMonad.fsx\"\n//                          , @\"D:\\Abe\\CIPHERWorkspace\\Repos\\amieres.github.io\\NoFreeMonad.html\")\n\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen System.IO\n\nlet fsStation = FStationMessaging(\"Compile Modules\")\n\nlet snippetPath = \"FSSGlobal/F# Code/Blog/\"\nlet scriptPath  = @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\"\nlet htmlPath    = @\"D:\\Abe\\CIPHERWorkspace\\Repos\\amieres.github.io\"\n\nlet copyTextW name = \n    Wrap.wrap {\n        let  snippetName = snippetPath + name\n        let! snippetO    = fsStation.RequestSnippet snippetName\n        let  script      = Path.Combine(scriptPath, name + \".fsx\" )\n        printfn \"Updating file %s ...\" script\n        File.WriteAllText(script, snippetO.Value.content)\n        printfn \"Updated!\"\n        printfn \"Waiting 12 seconds to give opportunity to background worker.\"\n        do!  Async.Sleep 12000\n        printfn \"Copying file %s.html ...\" name        \n        let  output      = Path.Combine(Path.Combine(scriptPath,\"output\")\n                                                            , name + \".html\") \n        let  html        = Path.Combine(  htmlPath          , name + \".html\")\n        try File.Delete   html with _ -> ()\n        File.Copy(output, html)\n    }\n\nlet saveSnippet name = \n    copyTextW name\n    |> Wrap.RunSynchronously\n\nlet startWorker() =\n    RunProcess.startProcessDir \"build.cmd\" \"run\" scriptPath\n", "snpParentIdO": {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, "snpPredIds": [{"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpName": "Snippets", "snpContent": "module Snippets =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e620b2e0-e518-4992-86f3-bc9623015345"}, "snpName": "", "snpContent": "let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"}, "snpName": "UNLOAD FSI", "snpContent": "#define UNLOAD_FSI\n\n#if WEBSHARPER\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.JavaScript.dll\"\nopen WebSharper\n[< JavaScript >]\n#endif\nlet a = 9 + 8\n\n7 * 3\n|> printfn \"%A\"\n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"560bbd44-ad59-4b88-81d7-c27a14b0ad2e"}, "snpName": "FSharp.Compiler.Service.Tests.Common", "snpContent": "open System.IO\nopen System.Collections.Generic\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n#if FX_RESHAPED_REFLECTION\nopen ReflectionAdapters\n#endif\n\n#if DOTNETCORE\nlet readRefs (folder : string) (projectFile: string) =\n    let runProcess (workingDir: string) (exePath: string) (args: string) =\n        let psi = System.Diagnostics.ProcessStartInfo()\n        psi.FileName <- exePath\n        psi.WorkingDirectory <- workingDir\n        psi.RedirectStandardOutput <- false\n        psi.RedirectStandardError <- false\n        psi.Arguments <- args\n        psi.CreateNoWindow <- true\n        psi.UseShellExecute <- false\n\n        use p = new System.Diagnostics.Process()\n        p.StartInfo <- psi\n        p.Start() |> ignore\n        p.WaitForExit()\n\n        let exitCode = p.ExitCode\n        exitCode, ()\n\n    let runCmd exePath args = runProcess folder exePath (args |> String.concat \" \")\n    let msbuildExec = Dotnet.ProjInfo.Inspect.dotnetMsbuild runCmd\n    let result = Dotnet.ProjInfo.Inspect.getProjectInfo ignore msbuildExec Dotnet.ProjInfo.Inspect.getFscArgs [] projectFile\n    match result with\n    | Ok(Dotnet.ProjInfo.Inspect.GetResult.FscArgs x) ->\n        x\n        |> List.filter (fun s -> s.StartsWith(\"-r:\"))\n        |> List.map (fun s -> s.Replace(\"-r:\", \"\"))\n    | _ -> []\n#endif\n\n\n// Create one global interactive checker instance\nlet checker = FSharpChecker.Create()\n\ntype TempFile(ext, contents) = \n    let tmpFile =  Path.ChangeExtension(System.IO.Path.GetTempFileName() , ext)\n    do File.WriteAllText(tmpFile, contents)\n    interface System.IDisposable with \n        member x.Dispose() = try File.Delete tmpFile with _ -> ()\n    member x.Name = tmpFile\n\n#nowarn \"57\"\n\nlet getBackgroundParseResultsForScriptText (input) = \n    use file =  new TempFile(\"fsx\", input)\n    let checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file.Name, input) |> Async.RunSynchronously\n    checker.GetBackgroundParseResultsForFileInProject(file.Name, checkOptions)  |> Async.RunSynchronously\n\n\nlet getBackgroundCheckResultsForScriptText (input) = \n    use file =  new TempFile(\"fsx\", input)\n    let checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file.Name, input) |> Async.RunSynchronously\n    checker.GetBackgroundCheckResultsForFileInProject(file.Name, checkOptions) |> Async.RunSynchronously\n\n\nlet sysLib nm = \n#if !FX_ATLEAST_PORTABLE\n    if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows \n        let programFilesx86Folder = System.Environment.GetEnvironmentVariable(\"PROGRAMFILES(X86)\")\n        programFilesx86Folder + @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\\" + nm + \".dll\"\n    else\n#endif\n#if FX_NO_RUNTIMEENVIRONMENT\n        let sysDir = System.AppContext.BaseDirectory\n#else\n        let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n#endif\n        let (++) a b = System.IO.Path.Combine(a,b)\n        sysDir ++ nm + \".dll\" \n\n[<AutoOpen>]\nmodule Helpers = \n    open System\n    type DummyType = A | B\n    let PathRelativeToTestAssembly p = Path.Combine(Path.GetDirectoryName(Uri(typeof<Microsoft.FSharp.Compiler.SourceCodeServices.FSharpChecker>.Assembly.CodeBase).LocalPath), p)\n\nlet fsCoreDefaultReference() = \n    PathRelativeToTestAssembly \"FSharp.Core.dll\"\n\n(*\n#if !FX_ATLEAST_PORTABLE\n     if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows \n        let programFilesx86Folder = System.Environment.GetEnvironmentVariable(\"PROGRAMFILES(X86)\")\n        programFilesx86Folder + @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.4.0.0\\FSharp.Core.dll\"  \n     else \n#endif\n        sysLib \"FSharp.Core\"\n*)\n\nlet mkStandardProjectReferences () = \n#if DOTNETCORE\n            let file = \"Sample_NETCoreSDK_FSharp_Library_netstandard1.6.fsproj\"\n            let projDir = Path.Combine(__SOURCE_DIRECTORY__, \"../projects/Sample_NETCoreSDK_FSharp_Library_netstandard1.6\")\n            readRefs projDir file\n#else\n            [ yield sysLib \"mscorlib\"\n              yield sysLib \"System\"\n              yield sysLib \"System.Core\"\n              yield fsCoreDefaultReference() ]\n#endif              \n\nlet mkProjectCommandLineArgs (dllName, fileNames) = \n  let args = \n    [|  yield \"--simpleresolution\" \n        yield \"--noframework\" \n        yield \"--debug:full\" \n        yield \"--define:DEBUG\" \n#if NETCOREAPP1_0\n        yield \"--targetprofile:netcore\" \n#endif\n        yield \"--optimize-\" \n        yield \"--out:\" + dllName\n        yield \"--doc:test.xml\" \n        yield \"--warn:3\" \n        yield \"--fullpaths\" \n        yield \"--flaterrors\" \n        yield \"--target:library\" \n        for x in fileNames do \n            yield x\n        let references = mkStandardProjectReferences ()\n        for r in references do\n            yield \"-r:\" + r\n     |]\n  printfn \"dllName = %A, args = %A\" dllName args\n  args\n\n#if DOTNETCORE\nlet mkProjectCommandLineArgsForScript (dllName, fileNames) = \n    [|  yield \"--simpleresolution\" \n        yield \"--noframework\" \n        yield \"--debug:full\" \n        yield \"--define:DEBUG\" \n#if NETCOREAPP1_0\n        yield \"--targetprofile:netcore\" \n#endif\n        yield \"--optimize-\" \n        yield \"--out:\" + dllName\n        yield \"--doc:test.xml\" \n        yield \"--warn:3\" \n        yield \"--fullpaths\" \n        yield \"--flaterrors\" \n        yield \"--target:library\" \n        for x in fileNames do \n            yield x\n        let references = mkStandardProjectReferences ()\n        for r in references do\n            yield \"-r:\" + r\n     |]\n#endif\n\nlet parseAndCheckScript (file, input) = \n\n#if DOTNETCORE\n    let dllName = Path.ChangeExtension(file, \".dll\")\n    let projName = Path.ChangeExtension(file, \".fsproj\")\n    let args = mkProjectCommandLineArgsForScript (dllName, [file])\n    printfn \"file = %A, args = %A\" file args\n    let projectOptions = checker.GetProjectOptionsFromCommandLineArgs (projName, args)\n\n#else    \n    let projectOptions, _diagnostics = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n    printfn \"projectOptions = %A\" projectOptions\n#endif\n\n    let parseResult, typedRes = checker.ParseAndCheckFileInProject(file, 0, input, projectOptions) |> Async.RunSynchronously\n    \n    // if parseResult.Errors.Length > 0 then\n    //     printfn \"---> Parse Input = %A\" input\n    //     printfn \"---> Parse Error = %A\" parseResult.Errors\n\n    match typedRes with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseResult, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet parseSourceCode (name: string, code: string) =\n    let location = Path.Combine(Path.GetTempPath(),\"test\"+string(hash (name, code)))\n    try Directory.CreateDirectory(location) |> ignore with _ -> ()\n\n    let projPath = Path.Combine(location, name + \".fsproj\")\n    let filePath = Path.Combine(location, name + \".fs\")\n    let dllPath = Path.Combine(location, name + \".dll\")\n    let args = mkProjectCommandLineArgs(dllPath, [filePath])\n    let options, errors = checker.GetParsingOptionsFromCommandLineArgs(List.ofArray args)\n    let parseResults = checker.ParseFile(filePath, code, options) |> Async.RunSynchronously\n    parseResults.ParseTree\n\n/// Extract range info \nlet tups (m:Range.range) = (m.StartLine, m.StartColumn), (m.EndLine, m.EndColumn)\n\n/// Extract range info  and convert to zero-based line  - please don't use this one any more\nlet tupsZ (m:Range.range) = (m.StartLine-1, m.StartColumn), (m.EndLine-1, m.EndColumn)\n\nlet attribsOfSymbolUse (s:FSharpSymbolUse) = \n    [ if s.IsFromDefinition then yield \"defn\" \n      if s.IsFromType then yield \"type\"\n      if s.IsFromAttribute then yield \"attribute\"\n      if s.IsFromDispatchSlotImplementation then yield \"override\"\n      if s.IsFromPattern then yield \"pattern\" \n      if s.IsFromComputationExpression then yield \"compexpr\" ] \n\nlet attribsOfSymbol (s:FSharpSymbol) = \n    [ match s with \n        | :? FSharpField as v -> \n            yield \"field\"\n            if v.IsCompilerGenerated then yield \"compgen\"\n            if v.IsDefaultValue then yield \"default\"\n            if v.IsMutable then yield \"mutable\"\n            if v.IsVolatile then yield \"volatile\"\n            if v.IsStatic then yield \"static\"\n            if v.IsLiteral then yield sprintf \"%A\" v.LiteralValue.Value\n\n\n        | :? FSharpEntity as v -> \n            v.TryFullName |> ignore // check there is no failure here\n            if v.IsNamespace then yield \"namespace\"\n            if v.IsFSharpModule then yield \"module\"\n            if v.IsByRef then yield \"byref\"\n            if v.IsClass then yield \"class\"\n            if v.IsDelegate then yield \"delegate\"\n            if v.IsEnum then yield \"enum\"\n            if v.IsFSharpAbbreviation then yield \"abbrev\"\n            if v.IsFSharpExceptionDeclaration then yield \"exn\"\n            if v.IsFSharpRecord then yield \"record\"\n            if v.IsFSharpUnion then yield \"union\"\n            if v.IsInterface then yield \"interface\"\n            if v.IsMeasure then yield \"measure\"\n#if EXTENSIONTYPING\n            if v.IsProvided then yield \"provided\"\n            if v.IsStaticInstantiation then yield \"staticinst\"\n            if v.IsProvidedAndErased then yield \"erased\"\n            if v.IsProvidedAndGenerated then yield \"generated\"\n#endif\n            if v.IsUnresolved then yield \"unresolved\"\n            if v.IsValueType then yield \"valuetype\"\n\n        | :? FSharpMemberOrFunctionOrValue as v -> \n            if v.IsActivePattern then yield \"apat\"\n            if v.IsDispatchSlot then yield \"slot\"\n            if v.IsModuleValueOrMember && not v.IsMember then yield \"val\"\n            if v.IsMember then yield \"member\"\n            if v.IsProperty then yield \"prop\"\n            if v.IsExtensionMember then yield \"extmem\"\n            if v.IsPropertyGetterMethod then yield \"getter\"\n            if v.IsPropertySetterMethod then yield \"setter\"\n            if v.IsEvent then yield \"event\"\n            if v.EventForFSharpProperty.IsSome then yield \"clievent\"\n            if v.IsEventAddMethod then yield \"add\"\n            if v.IsEventRemoveMethod then yield \"remove\"\n            if v.IsTypeFunction then yield \"typefun\"\n            if v.IsCompilerGenerated then yield \"compgen\"\n            if v.IsImplicitConstructor then yield \"ctor\"\n            if v.IsMutable then yield \"mutable\" \n            if v.IsOverrideOrExplicitInterfaceImplementation then yield \"overridemem\"\n            if v.IsInstanceMember && not v.IsInstanceMemberInCompiledCode && not v.IsExtensionMember then yield \"funky\"\n            if v.IsExplicitInterfaceImplementation then yield \"intfmem\"\n//            if v.IsConstructorThisValue then yield \"ctorthis\"\n//            if v.IsMemberThisValue then yield \"this\"\n//            if v.LiteralValue.IsSome then yield \"literal\"\n        | _ -> () ]\n\nlet rec allSymbolsInEntities compGen (entities: IList<FSharpEntity>) = \n    [ for e in entities do \n          yield (e :> FSharpSymbol) \n          for gp in e.GenericParameters do \n            if compGen || not gp.IsCompilerGenerated then \n             yield (gp :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             if compGen || not x.IsCompilerGenerated then \n               yield (x :> FSharpSymbol)\n             for gp in x.GenericParameters do \n              if compGen || not gp.IsCompilerGenerated then \n               yield (gp :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n             for f in x.UnionCaseFields do\n                 if compGen || not f.IsCompilerGenerated then \n                     yield (f :> FSharpSymbol)\n          for x in e.FSharpFields do\n             if compGen || not x.IsCompilerGenerated then \n                 yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities compGen e.NestedEntities ]\n\n\nlet coreLibAssemblyName =\n#if DOTNETCORE\n    \"System.Runtime\"\n#else\n    \"mscorlib\"\n#endif\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"38e6c579-4305-4929-9666-44b3890c7a6a"}, "snpName": "FsUnit NUnit", "snpContent": "\n// To run the tests in this file:\n//\n// Technique 1: Compile VisualFSharp.Unittests.dll and run it as a set of unit tests\n//\n// Technique 2:\n//\n//   Enable some tests in the #if EXE section at the end of the file, \n//   then compile this file as an EXE that has InternalsVisibleTo access into the\n//   appropriate DLLs.  This can be the quickest way to get turnaround on updating the tests\n//   and capturing large amounts of structured output.\n(*\n    cd Debug\\net40\\bin\n    .\\fsc.exe --define:EXE -r:.\\Microsoft.Build.Utilities.Core.dll -o VisualFSharp.Unittests.exe -g --optimize- -r .\\FSharp.LanguageService.Compiler.dll -r nunit.framework.dll ..\\..\\..\\tests\\service\\FsUnit.fs ..\\..\\..\\tests\\service\\Common.fs /delaysign /keyfile:..\\..\\..\\src\\fsharp\\msft.pubkey ..\\..\\..\\tests\\service\\EditorTests.fs \n    .\\VisualFSharp.Unittests.exe \n*)\n// Technique 3: \n// \n//    Use F# Interactive.  This only works for FSHarp.Compiler.Service.dll which has a public API\n\n#if INTERACTIVE\n#r @\"D:\\Abe\\CIPHERWorkspace\\visualfsharp\\fcs\\FSharp.Compiler.Service\\obj\\Debug\\FSharp.Compiler.Service.dll\" \n#r \"../packages/NUnit/lib/net45/nunit.framework.dll\"\n#r \"../packages/FsUnit/lib/net45/FsUnit.NUnit.dll\"\n#load \"FsUnit.fs\"\n#load \"Common.fs\"\n#else\nmodule Tests.Service.Editor\n#endif\n\nopen NUnit.Framework\nopen FsUnitTyped\nopen System\nopen System.IO\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\nlet stringMethods = \n#if DOTNETCORE\n    [\"Chars\"; \"CompareTo\"; \"Contains\"; \"CopyTo\"; \"EndsWith\"; \"Equals\";\n    \"GetHashCode\"; \"GetType\"; \"IndexOf\";\n    \"IndexOfAny\"; \"Insert\"; \"LastIndexOf\"; \"LastIndexOfAny\";\n    \"Length\"; \"PadLeft\"; \"PadRight\"; \"Remove\"; \"Replace\"; \"Split\";\n    \"StartsWith\"; \"Substring\"; \"ToCharArray\"; \"ToLower\"; \"ToLowerInvariant\";\n    \"ToString\"; \"ToUpper\"; \"ToUpperInvariant\"; \"Trim\"; \"TrimEnd\"; \"TrimStart\"]\n#else\n    [\"Chars\"; \"Clone\"; \"CompareTo\"; \"Contains\"; \"CopyTo\"; \"EndsWith\"; \"Equals\";\n    \"GetEnumerator\"; \"GetHashCode\"; \"GetType\"; \"GetTypeCode\"; \"IndexOf\";\n    \"IndexOfAny\"; \"Insert\"; \"IsNormalized\"; \"LastIndexOf\"; \"LastIndexOfAny\";\n    \"Length\"; \"Normalize\"; \"PadLeft\"; \"PadRight\"; \"Remove\"; \"Replace\"; \"Split\";\n    \"StartsWith\"; \"Substring\"; \"ToCharArray\"; \"ToLower\"; \"ToLowerInvariant\";\n    \"ToString\"; \"ToUpper\"; \"ToUpperInvariant\"; \"Trim\"; \"TrimEnd\"; \"TrimStart\"]\n#endif\n\nlet input = \n  \"\"\"\n  open System\n  \n  let foo() = \n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then \n      printfn \"%s\" msg.\n  \"\"\"\n\n[<Test>]\nlet ``Intro test`` () = \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n    let identToken = FSharpTokenTag.IDENT\n//    let projectOptions = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n\n    // We only expect one reported error. However,\n    // on Unix, using filenames like /home/user/Test.fsx gives a second copy of all parse errors due to the\n    // way the load closure for scripts is generated. So this returns two identical errors\n    (match typeCheckResults.Errors.Length with 1 | 2 -> true | _ -> false)  |> shouldEqual true\n\n    // So we check that the messages are the same\n    for msg in typeCheckResults.Errors do \n        printfn \"Good! got an error, hopefully with the right text: %A\" msg\n        msg.Message.Contains(\"Missing qualification after '.'\") |> shouldEqual true\n\n    // Get tool tip at the specified location\n    let tip = typeCheckResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], identToken) |> Async.RunSynchronously\n    // (sprintf \"%A\" tip).Replace(\"\\n\",\"\") |> shouldEqual \"\"\"FSharpToolTipText [Single (\"val foo : unit -> unitFull name: Test.foo\",None)]\"\"\"\n    // Get declarations (autocomplete) for a location\n    let decls =  typeCheckResults.GetDeclarationListInfo(Some parseResult, 7, 23, inputLines.[6], [], \"msg\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    CollectionAssert.AreEquivalent(stringMethods,[ for item in decls.Items -> item.Name ])\n    // Get overloads of the String.Concat method\n    let methods = typeCheckResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n\n    methods.MethodName  |> shouldEqual \"Concat\"\n\n    // Print concatenated parameter lists\n    [ for mi in methods.Methods do\n        yield methods.MethodName , [ for p in mi.Parameters do yield p.Display ] ]\n        |> shouldEqual\n              [(\"Concat\", [\"[<ParamArray>] args: obj []\"]);\n               (\"Concat\", [\"[<ParamArray>] values: string []\"]);\n               (\"Concat\", [\"values: Collections.Generic.IEnumerable<'T>\"]);\n               (\"Concat\", [\"values: Collections.Generic.IEnumerable<string>\"]);\n               (\"Concat\", [\"arg0: obj\"]); (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"]);\n               (\"Concat\", [\"str0: string\"; \"str1: string\"]);\n               (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"; \"arg2: obj\"]);\n               (\"Concat\", [\"str0: string\"; \"str1: string\"; \"str2: string\"]);\n#if !DOTNETCORE\n               (\"Concat\", [\"arg0: obj\"; \"arg1: obj\"; \"arg2: obj\"; \"arg3: obj\"]);\n#endif               \n               (\"Concat\", [\"str0: string\"; \"str1: string\"; \"str2: string\"; \"str3: string\"])]\n\n\n#if !INTERACTIVE && !DOTNETCORE // InternalsVisibleTo on IncrementalBuild.LocallyInjectCancellationFault not working for some reason?\n[<Test>]\nlet ``Basic cancellation test`` () = \n   try \n    printfn \"locally injecting a cancellation condition in incremental building\"\n    use _holder = IncrementalBuild.LocallyInjectCancellationFault()\n    \n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    async { \n        checker.ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients()\n        let! checkOptions, _diagnostics = checker.GetProjectOptionsFromScript(file, input) \n        let! parseResult, typedRes = checker.ParseAndCheckFileInProject(file, 0, input, checkOptions) \n        return parseResult, typedRes\n    } |> Async.RunSynchronously\n      |> ignore\n    Assert.Fail(\"expected a cancellation\")\n   with :? OperationCanceledException -> ()\n#endif\n\n[<Test>]\nlet ``GetMethodsAsSymbols should return all overloads of a method as FSharpSymbolUse`` () =\n\n    let extractCurriedParams (symbol:FSharpSymbolUse) =\n        match symbol.Symbol with\n        | :? FSharpMemberOrFunctionOrValue as mvf ->\n            [for pg in mvf.CurriedParameterGroups do \n                for (p:FSharpParameter) in pg do \n                    yield p.DisplayName, p.Type.Format (symbol.DisplayContext)]\n        | _ -> []\n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input)\n    let methodsSymbols = typeCheckResults.GetMethodsAsSymbols(5, 27, inputLines.[4], [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n    match methodsSymbols with\n    | Some methods ->\n        [ for ms in methods do\n            yield ms.Symbol.DisplayName, extractCurriedParams ms ]\n        |> List.sortBy (fun (_name, parameters) -> parameters.Length, (parameters |> List.map snd ))\n        |> shouldEqual\n            [(\"Concat\", [(\"values\", \"Collections.Generic.IEnumerable<'T>\")]);\n             (\"Concat\", [(\"values\", \"Collections.Generic.IEnumerable<string>\")]);\n             (\"Concat\", [(\"arg0\", \"obj\")]);\n             (\"Concat\", [(\"args\", \"obj []\")]);\n             (\"Concat\", [(\"values\", \"string []\")]);\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\")]);\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\")]);\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\"); (\"arg2\", \"obj\")]);\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\"); (\"str2\", \"string\")]);\n#if !DOTNETCORE\n             (\"Concat\", [(\"arg0\", \"obj\"); (\"arg1\", \"obj\"); (\"arg2\", \"obj\"); (\"arg3\", \"obj\")]);\n#endif\n             (\"Concat\", [(\"str0\", \"string\"); (\"str1\", \"string\"); (\"str2\", \"string\"); (\"str3\", \"string\")])]\n    | None -> failwith \"No symbols returned\"\n\n\nlet input2 = \n        \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) = \n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then \n        printfn \"x = %d, y = %d\" x y \n        printfn \"%s\" msg\n\ntype C() = \n    member x.P = 1\n        \"\"\"\n\n[<Test>]\nlet ``Symbols basic test`` () = \n\n    let file = \"/home/user/Test.fsx\"\n    let untyped2, typeCheckResults2 = parseAndCheckScript(file, input2)\n\n    let partialAssemblySignature = typeCheckResults2.PartialAssemblySignature\n    \n    partialAssemblySignature.Entities.Count |> shouldEqual 1  // one entity\n\n[<Test>]\nlet ``Symbols many tests`` () = \n\n    let file = \"/home/user/Test.fsx\"\n    let untyped2, typeCheckResults2 = parseAndCheckScript(file, input2)\n\n    let partialAssemblySignature = typeCheckResults2.PartialAssemblySignature\n    \n    partialAssemblySignature.Entities.Count |> shouldEqual 1  // one entity\n    let moduleEntity = partialAssemblySignature.Entities.[0]\n\n    moduleEntity.DisplayName |> shouldEqual \"Test\"\n\n    let classEntity = moduleEntity.NestedEntities.[0]\n\n    let fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n    fnVal.Accessibility.IsPublic |> shouldEqual true\n    fnVal.Attributes.Count |> shouldEqual 1\n    fnVal.CurriedParameterGroups.Count |> shouldEqual 1\n    fnVal.CurriedParameterGroups.[0].Count |> shouldEqual 2\n    fnVal.CurriedParameterGroups.[0].[0].Name.IsSome |> shouldEqual true\n    fnVal.CurriedParameterGroups.[0].[1].Name.IsSome |> shouldEqual true\n    fnVal.CurriedParameterGroups.[0].[0].Name.Value |> shouldEqual \"x\"\n    fnVal.CurriedParameterGroups.[0].[1].Name.Value |> shouldEqual \"y\"\n    fnVal.DeclarationLocation.StartLine |> shouldEqual 3\n    fnVal.DisplayName |> shouldEqual \"foo\"\n    fnVal.EnclosingEntity.Value.DisplayName |> shouldEqual \"Test\"\n    fnVal.EnclosingEntity.Value.DeclarationLocation.StartLine |> shouldEqual 1\n    fnVal.GenericParameters.Count |> shouldEqual 0\n    fnVal.InlineAnnotation |> shouldEqual FSharpInlineAnnotation.OptionalInline\n    fnVal.IsActivePattern |> shouldEqual false\n    fnVal.IsCompilerGenerated |> shouldEqual false\n    fnVal.IsDispatchSlot |> shouldEqual false\n    fnVal.IsExtensionMember |> shouldEqual false\n    fnVal.IsPropertyGetterMethod |> shouldEqual false\n    fnVal.IsImplicitConstructor |> shouldEqual false\n    fnVal.IsInstanceMember |> shouldEqual false\n    fnVal.IsMember |> shouldEqual false\n    fnVal.IsModuleValueOrMember |> shouldEqual true\n    fnVal.IsMutable |> shouldEqual false\n    fnVal.IsPropertySetterMethod |> shouldEqual false\n    fnVal.IsTypeFunction |> shouldEqual false\n\n    fnVal.FullType.IsFunctionType |> shouldEqual true // int * int -> unit\n    fnVal.FullType.GenericArguments.[0].IsTupleType |> shouldEqual true // int * int \n    let argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\n    argTy1.TypeDefinition.DisplayName |> shouldEqual \"int\" // int\n\n    argTy1.HasTypeDefinition |> shouldEqual true\n    argTy1.TypeDefinition.IsFSharpAbbreviation |> shouldEqual true // \"int\"\n\n    let argTy1b = argTy1.TypeDefinition.AbbreviatedType\n    argTy1b.TypeDefinition.Namespace |> shouldEqual (Some \"Microsoft.FSharp.Core\")\n    argTy1b.TypeDefinition.CompiledName |> shouldEqual \"int32\" \n\n    let argTy1c = argTy1b.TypeDefinition.AbbreviatedType\n    argTy1c.TypeDefinition.Namespace |> shouldEqual (Some \"System\")\n    argTy1c.TypeDefinition.CompiledName |> shouldEqual \"Int32\" \n\n    let typeCheckContext = typeCheckResults2.ProjectContext\n    \n    typeCheckContext.GetReferencedAssemblies() |> List.exists (fun s -> s.FileName.Value.Contains(coreLibAssemblyName)) |> shouldEqual true\n    \n\nlet input3 = \n  \"\"\"\nlet date = System.DateTime.Now.ToString().PadRight(25)\n  \"\"\"\n\n[<Test>]\nlet ``Expression typing test`` () = \n\n    printfn \"------ Expression typing test -----------------\"\n    // Split the input & define file name\n    let inputLines = input3.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input3) \n    let identToken = FSharpTokenTag.IDENT\n\n    for msg in typeCheckResults.Errors do \n        printfn \"***Expression typing test: Unexpected  error: %A\" msg.Message\n\n    typeCheckResults.Errors.Length |> shouldEqual 0\n\n    // Get declarations (autocomplete) for a location\n    //\n    // Getting the declarations at columns 42 to 43 with [], \"\" for the names and residue \n    // gives the results for the string type. \n    // \n    for col in 42..43 do \n        let decls =  typeCheckResults.GetDeclarationListInfo(Some parseResult, 2, col, inputLines.[1], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n        let autoCompleteSet = set [ for item in decls.Items -> item.Name ]\n        autoCompleteSet |> shouldEqual (set stringMethods)\n\n// The underlying problem is that the parser error recovery doesn't include _any_ information for\n// the incomplete member:\n//    member x.Test = \n\n[<Test; Ignore(\"Currently failing, see #139\")>]\nlet ``Find function from member 1`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 21, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    let item = decls.Items |> Array.tryFind (fun d -> d.Name = \"abc\")\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Find function from member 2`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = a\"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 22, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    let item = decls.Items |> Array.tryFind (fun d -> d.Name = \"abc\")\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n \n[<Test>]\nlet ``Find function from var`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    let test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListInfo(Some parseResult, 4, 15, inputLines.[3], [], \"\", (fun _ -> []), fun _ -> false)|> Async.RunSynchronously\n    decls.Items |> Seq.exists (fun d -> d.Name = \"abc\") |> shouldEqual true\n\n[<Test; Ignore(\"Currently failing, see #139\")>]\nlet ``Symbol based find function from member 1`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 21, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Symbol based find function from member 2`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    member x.Test = a\"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 22, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Symbol based find function from var`` () = \n    let input = \n      \"\"\"\ntype Test() = \n    let abc a b c = a + b + c\n    let test = \"\"\" \n\n    // Split the input & define file name\n    let inputLines = input.Split('\\n')\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults =  parseAndCheckScript(file, input) \n\n    let decls = typeCheckResults.GetDeclarationListSymbols(Some parseResult, 4, 15, inputLines.[3], [], \"\", fun _ -> false)|> Async.RunSynchronously\n    //decls |> List.map (fun d -> d.Head.Symbol.DisplayName) |> printfn \"---> decls = %A\"\n    decls |> Seq.exists (fun d -> d.Head.Symbol.DisplayName = \"abc\") |> shouldEqual true\n\n[<Test>]\nlet ``Printf specifiers for regular and verbatim strings`` () = \n    let input = \n      \"\"\"let os = System.Text.StringBuilder()\nlet _ = Microsoft.FSharp.Core.Printf.printf \"%A\" 0\nlet _ = Printf.printf \"%A\" 0\nlet _ = Printf.kprintf (fun _ -> ()) \"%A\" 1\nlet _ = Printf.bprintf os \"%A\" 1\nlet _ = sprintf \"%*d\" 1\nlet _ = sprintf \"%7.1f\" 1.0\nlet _ = sprintf \"%-8.1e+567\" 1.0\nlet _ = sprintf @\"%-5s\" \"value\"\nlet _ = printfn @\"%-A\" -10\nlet _ = printf @\"\n            %-O\" -10\nlet _ = sprintf \"\n\n            %-O\" -10\nlet _ = List.map (sprintf @\"%A\n                           \")\nlet _ = (10, 12) ||> sprintf \"%A\n                              %O\"\nlet _ = sprintf \"\\n%-8.1e+567\" 1.0\nlet _ = sprintf @\"%O\\n%-5s\" \"1\" \"2\" \nlet _ = sprintf \"%%\"\nlet _ = sprintf \" %*%\" 2\nlet _ = sprintf \"  %.*%\" 2\nlet _ = sprintf \"   %*.1%\" 2\nlet _ = sprintf \"    %*s\" 10 \"hello\"\nlet _ = sprintf \"     %*.*%\" 2 3\nlet _ = sprintf \"      %*.*f\" 2 3 4.5\nlet _ = sprintf \"       %.*f\" 3 4.5\nlet _ = sprintf \"        %*.1f\" 3 4.5\nlet _ = sprintf \"         %6.*f\" 3 4.5\nlet _ = sprintf \"          %6.*%\" 3\nlet _ =  printf \"           %a\" (fun _ _ -> ()) 2\nlet _ =  printf \"            %*a\" 3 (fun _ _ -> ()) 2\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range,numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual\n         [|(2, 45, 2, 47, 1); (3, 23, 3, 25, 1); (4, 38, 4, 40, 1); (5, 27, 5, 29\n, 1);\n          (6, 17, 6, 20, 2); (7, 17, 7, 22, 1); (8, 17, 8, 23, 1); (9, 18, 9, 22, 1);\n          (10, 18, 10, 21, 1); (12, 12, 12, 15, 1); (15, 12, 15, 15, 1);\n          (16, 28, 16, 30, 1); (18, 30, 18, 32, 1); (19, 30, 19, 32, 1);\n          (20, 19, 20, 25, 1); (21, 18, 21, 20, 1); (21, 22, 21, 26, 1);\n          (22, 17, 22, 19, 0); (23, 18, 23, 21, 1); (24, 19, 24, 23, 1);\n          (25, 20, 25, 25, 1); (26, 21, 26, 24, 2); (27, 22, 27, 27, 2);\n          (28, 23, 28, 28, 3); (29, 24, 29, 28, 2); (30, 25, 30, 30, 2);\n          (31, 26, 31, 31, 2); (32, 27, 32, 32, 1); (33, 28, 33, 30, 2);\n          (34, 29, 34, 32, 3)|]\n\n[<Test>]\nlet ``Printf specifiers for triple-quote strings`` () = \n    let input = \n      \"\nlet _ = sprintf \\\"\\\"\\\"%-A\\\"\\\"\\\" -10\nlet _ = printfn \\\"\\\"\\\"\n            %-A\n                \\\"\\\"\\\" -10\nlet _ = List.iter(printfn \\\"\\\"\\\"%-A\n                             %i\\\\n%O\n                             \\\"\\\"\\\" 1 2)\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range,numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [|(2, 19, 2, 22, 1);\n                     (4, 12, 4, 15, 1);\n                     (6, 29, 6, 32, 1);\n                     (7, 29, 7, 31, 1); \n                     (7, 33, 7, 35,1 )|]\n \n[<Test>]\nlet ``Printf specifiers for user-defined functions`` () = \n    let input = \n      \"\"\"\nlet debug msg = Printf.kprintf System.Diagnostics.Debug.WriteLine msg\nlet _ = debug \"Message: %i - %O\" 1 \"Ok\"\nlet _ = debug \"[LanguageService] Type checking fails for '%s' with content=%A and %A.\\nResulting exception: %A\" \"1\" \"2\" \"3\" \"4\"\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n\n    typeCheckResults.Errors |> shouldEqual [||]\n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range, numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [|(3, 24, 3, 26, 1); \n                     (3, 29, 3, 31, 1);\n                     (4, 58, 4, 60, 1); \n                     (4, 75, 4, 77, 1); \n                     (4, 82, 4, 84, 1); \n                     (4, 108, 4, 110, 1)|]\n\n[<Test>]\nlet ``should not report format specifiers for illformed format strings`` () = \n    let input = \n      \"\"\"\nlet _ = sprintf \"%.7f %7.1A %7.f %--8.1f\"\nlet _ = sprintf \"ABCDE\"\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetFormatSpecifierLocationsAndArity() \n    |> Array.map (fun (range, numArgs) -> range.StartLine, range.StartColumn, range.EndLine, range.EndColumn, numArgs)\n    |> shouldEqual [||]\n\n[<Test>]\nlet ``Single case discreminated union type definition`` () = \n    let input = \n      \"\"\"\ntype DU = Case1\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        r.StartLine, r.StartColumn, r.EndLine, r.EndColumn)\n    |> shouldEqual [|(2, 10, 2, 15); (2, 5, 2, 7); (1, 0, 1, 0)|]\n\n[<Test>]\nlet ``Synthetic symbols should not be reported`` () = \n    let input = \n      \"\"\"\nlet arr = [|1|]\nlet number1, number2 = 1, 2\nlet _ = arr.[0..number1]\nlet _ = arr.[..number2]\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"val arr\", (2, 4, 2, 7)); \n          (\"val number2\", (3, 13, 3, 20));\n          (\"val number1\", (3, 4, 3, 11)); \n          (\"val arr\", (4, 8, 4, 11));\n          (\"OperatorIntrinsics\", (4, 11, 4, 12)); \n          (\"Operators\", (4, 11, 4, 12));\n          (\"Core\", (4, 11, 4, 12)); \n          (\"FSharp\", (4, 11, 4, 12));\n          (\"Microsoft\", (4, 11, 4, 12)); \n          (\"val number1\", (4, 16, 4, 23));\n          (\"val arr\", (5, 8, 5, 11)); \n          (\"OperatorIntrinsics\", (5, 11, 5, 12));\n          (\"Operators\", (5, 11, 5, 12)); \n          (\"Core\", (5, 11, 5, 12));\n          (\"FSharp\", (5, 11, 5, 12)); \n          (\"Microsoft\", (5, 11, 5, 12));\n          (\"val number2\", (5, 15, 5, 22)); \n          (\"Test\", (1, 0, 1, 0))|]\n\n\n[<Test>]\nlet ``Enums should have fields`` () =\n    let input = \"\"\"\ntype EnumTest = One = 1 | Two = 2 | Three = 3\nlet test = EnumTest.One\nlet test2 = System.StringComparison.CurrentCulture\nlet test3 = System.Text.RegularExpressions.RegexOptions.Compiled\n\"\"\"\n    let file = \"/home/user/Test.fsx\"\n    let parseResult, typeCheckResults = parseAndCheckScript(file, input) \n    let allSymbols = typeCheckResults.GetAllUsesOfAllSymbolsInFile() |> Async.RunSynchronously\n    let enums =\n        allSymbols\n        |> Array.choose(fun s -> match s.Symbol with :? FSharpEntity as e when e.IsEnum -> Some e | _ -> None)\n        |> Array.distinct\n        |> Array.map(fun e -> (e.DisplayName, e.FSharpFields\n                                              |> Seq.map(fun f -> f.Name, f.LiteralValue )\n                                              |> Seq.toList))\n\n    enums |> shouldEqual\n        [| \"EnumTest\", [ (\"value__\", None)\n                         (\"One\", Some (box 1))\n                         (\"Two\", Some (box 2))\n                         (\"Three\", Some (box 3))\n                       ]\n           \"StringComparison\", [ (\"value__\", None)\n                                 (\"CurrentCulture\", Some (box 0))\n                                 (\"CurrentCultureIgnoreCase\", Some (box 1))\n                                 (\"InvariantCulture\", Some (box 2))\n                                 (\"InvariantCultureIgnoreCase\", Some (box 3))\n                                 (\"Ordinal\", Some (box 4))\n                                 (\"OrdinalIgnoreCase\", Some (box 5))\n                               ]\n           \"RegexOptions\", [ (\"value__\", None)\n                             (\"None\", Some (box 0))\n                             (\"IgnoreCase\", Some (box 1))\n                             (\"Multiline\", Some (box 2))\n                             (\"ExplicitCapture\", Some (box 4))\n                             (\"Compiled\", Some (box 8))\n                             (\"Singleline\", Some (box 16))\n                             (\"IgnorePatternWhitespace\", Some (box 32))\n                             (\"RightToLeft\", Some (box 64))\n                             (\"ECMAScript\", Some (box 256))\n                             (\"CultureInvariant\", Some (box 512))\n                           ]\n        |]\n\n[<Test>]\nlet ``IL enum fields should be reported`` () = \n    let input = \n      \"\"\"\nopen System\n\nlet _ =\n    match ConsoleKey.Tab with\n    | ConsoleKey.OemClear -> ConsoleKey.A\n    | _ -> ConsoleKey.B\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"ConsoleKey\", (5, 10, 5, 20))\n          (\"field Tab\", (5, 10, 5, 24))\n          (\"ConsoleKey\", (6, 6, 6, 16))\n          (\"field OemClear\", (6, 6, 6, 25))\n          (\"ConsoleKey\", (6, 29, 6, 39))\n          (\"field A\", (6, 29, 6, 41))\n          (\"ConsoleKey\", (7, 11, 7, 21))\n          (\"field B\", (7, 11, 7, 23))\n          (\"Test\", (1, 0, 1, 0))|]\n\n[<Test>]\nlet ``Literal values should be reported`` () = \n    let input = \n      \"\"\"\nmodule Module1 =\n    let [<Literal>] ModuleValue = 1\n\n    let _ =\n        match ModuleValue + 1 with\n        | ModuleValue -> ModuleValue + 2\n        | _ -> 0\n\ntype Class1() =\n    let [<Literal>] ClassValue = 1\n    static let [<Literal>] StaticClassValue = 2\n    \n    let _ = ClassValue\n    let _ = StaticClassValue\n\n    let _ =\n        match ClassValue + StaticClassValue with\n        | ClassValue -> ClassValue + 1\n        | StaticClassValue -> StaticClassValue + 2\n        | _ -> 3\n\"\"\"\n\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    typeCheckResults.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n    |> Array.map (fun su -> \n        let r = su.RangeAlternate \n        su.Symbol.ToString(), (r.StartLine, r.StartColumn, r.EndLine, r.EndColumn))\n    |> shouldEqual \n        [|(\"LiteralAttribute\", (3, 10, 3, 17))\n          (\"LiteralAttribute\", (3, 10, 3, 17))\n          (\"member .ctor\", (3, 10, 3, 17))\n          (\"val ModuleValue\", (3, 20, 3, 31))\n          (\"val op_Addition\", (6, 26, 6, 27))\n          (\"val ModuleValue\", (6, 14, 6, 25))\n          (\"val ModuleValue\", (7, 10, 7, 21))\n          (\"val op_Addition\", (7, 37, 7, 38))\n          (\"val ModuleValue\", (7, 25, 7, 36))\n          (\"Module1\", (2, 7, 2, 14))\n          (\"Class1\", (10, 5, 10, 11))\n          (\"member .ctor\", (10, 5, 10, 11))\n          (\"LiteralAttribute\", (11, 10, 11, 17))\n          (\"LiteralAttribute\", (11, 10, 11, 17))\n          (\"member .ctor\", (11, 10, 11, 17))\n          (\"val ClassValue\", (11, 20, 11, 30))\n          (\"LiteralAttribute\", (12, 17, 12, 24))\n          (\"LiteralAttribute\", (12, 17, 12, 24))\n          (\"member .ctor\", (12, 17, 12, 24))\n          (\"val StaticClassValue\", (12, 27, 12, 43))\n          (\"val ClassValue\", (14, 12, 14, 22))\n          (\"val StaticClassValue\", (15, 12, 15, 28))\n          (\"val op_Addition\", (18, 25, 18, 26))\n          (\"val ClassValue\", (18, 14, 18, 24))\n          (\"val StaticClassValue\", (18, 27, 18, 43))\n          (\"val ClassValue\", (19, 10, 19, 20))\n          (\"val op_Addition\", (19, 35, 19, 36))\n          (\"val ClassValue\", (19, 24, 19, 34))\n          (\"val StaticClassValue\", (20, 10, 20, 26))\n          (\"val op_Addition\", (20, 47, 20, 48))\n          (\"val StaticClassValue\", (20, 30, 20, 46))\n          (\"member .cctor\", (10, 5, 10, 11))\n          (\"Test\", (1, 0, 1, 0))|]\n          \n[<Test>]\nlet ``GetDeclarationLocation should not require a physical file`` () = \n    let input = \"let abc = 1\\nlet xyz = abc\"\n    let file = \"/home/user/Test.fsx\"\n    let _, typeCheckResults = parseAndCheckScript(file, input) \n    let location = typeCheckResults.GetDeclarationLocation(2, 13, \"let xyz = abc\", [\"abc\"]) |> Async.RunSynchronously\n    match location with\n    | FSharpFindDeclResult.DeclFound r -> Some (r.StartLine, r.EndLine, r.StartColumn, r.EndColumn, \"Found in the right place.\") \n    | _                                -> Some (0          , 0        , 0            , 0          , \"Not Found. Missing file.\" )\n    |> shouldEqual                       (Some (1          , 1        , 4            , 7          , \"Found in the right place.\"))\n``GetDeclarationLocation should not require a physical file`` ()          \n\n//-------------------------------------------------------------------------------\n\n\n#if TEST_TP_PROJECTS\nmodule internal TPProject = \n    open System.IO\n\n    let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")\n    let base2 = Path.GetTempFileName()\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\nopen Samples.FSharp.RegexTypeProvider\n[<Literal>]\nlet REGEX = \"ABC\"\nlet _ = RegexTypedStatic.IsMatch  // TEST: intellisense when typing \"<\"\nlet _ = RegexTypedStatic.IsMatch<REGEX>( ) // TEST: param info on \"(\"\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( ) // TEST: param info on \"(\"\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( (*$*) ) // TEST: meth info on ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >( null (*$*) ) // TEST: param info on \",\" at $\nlet _ = RegexTypedStatic.IsMatch< > // TEST: intellisense when typing \"<\"\nlet _ = RegexTypedStatic.IsMatch< (*$*) > // TEST: param info when typing ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" (*$*) > // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" (*$*) >(  ) // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\", (*$ *) >(  ) // TEST: param info on Ctrl-alt-space at $\nlet _ = RegexTypedStatic.IsMatch<\"ABC\" >(  (*$*) ) // TEST: no assert on Ctrl-space at $\n    \"\"\"\n\n    File.WriteAllText(fileName1, fileSource1)\n    let fileLines1 = File.ReadAllLines(fileName1)\n    let fileNames = [fileName1]\n    let args = Array.append (mkProjectCommandLineArgs (dllName, fileNames)) [| \"-r:\" + PathRelativeToTestAssembly(@\"UnitTests\\MockTypeProviders\\DummyProviderForLanguageServiceTesting.dll\") |]\n    let options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)\n    let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"\n\n[<Test>]\nlet ``Test TPProject all symbols`` () = \n\n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let allSymbolUses = wholeProjectResults.GetAllUsesOfAllSymbols() |> Async.RunSynchronously\n    let allSymbolUsesInfo =  [ for s in allSymbolUses -> s.Symbol.DisplayName, tups s.RangeAlternate, attribsOfSymbol s.Symbol ]\n    //printfn \"allSymbolUsesInfo = \\n----\\n%A\\n----\" allSymbolUsesInfo\n\n    allSymbolUsesInfo |> shouldEqual\n        [(\"LiteralAttribute\", ((4, 2), (4, 9)), [\"class\"]);\n         (\"LiteralAttribute\", ((4, 2), (4, 9)), [\"class\"]);\n         (\"LiteralAttribute\", ((4, 2), (4, 9)), [\"member\"]);\n         (\"REGEX\", ((5, 4), (5, 9)), [\"val\"]);\n         (\"RegexTypedStatic\", ((6, 8), (6, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((6, 8), (6, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((7, 8), (7, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"REGEX\", ((7, 33), (7, 38)), [\"val\"]);\n         (\"IsMatch\", ((7, 8), (7, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((8, 8), (8, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((8, 8), (8, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((9, 8), (9, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((9, 8), (9, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((10, 8), (10, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((10, 8), (10, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((11, 8), (11, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((11, 8), (11, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((12, 8), (12, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((12, 8), (12, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((13, 8), (13, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((13, 8), (13, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((14, 8), (14, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((14, 8), (14, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((15, 8), (15, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((15, 8), (15, 32)), [\"member\"]);\n         (\"RegexTypedStatic\", ((16, 8), (16, 24)), [\"class\"; \"provided\"; \"erased\"]);\n         (\"IsMatch\", ((16, 8), (16, 32)), [\"member\"]);\n         (\"M\", ((2, 7), (2, 8)), [\"module\"])]\n\n\n[<Test>]\nlet ``Test TPProject errors`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let errorMessages = [ for msg in typeCheckResults.Errors -> msg.StartLineAlternate, msg.StartColumn, msg.EndLineAlternate, msg.EndColumn, msg.Message.Replace(\"\\r\",\"\").Replace(\"\\n\",\"\") ]\n    //printfn \"errorMessages = \\n----\\n%A\\n----\" errorMessages\n\n    errorMessages |> shouldEqual\n        [(15, 47, 15, 48, \"Expected type argument or static argument\");\n         (6, 8, 6, 32, \"This provided method requires static parameters\");\n         (7, 39, 7, 42, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (8, 40, 8, 43, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (9, 40, 9, 49, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (11, 8, 11, 35, \"The static parameter 'pattern1' of the provided type or method 'IsMatch' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. 'IsMatch<pattern1=...>'.\");\n         (12, 8, 12, 41, \"The static parameter 'pattern1' of the provided type or method 'IsMatch' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. 'IsMatch<pattern1=...>'.\");\n         (14, 46, 14, 50, \"This expression was expected to have type    'string'    but here has type    'unit'    \");\n         (15, 33, 15, 38, \"No static parameter exists with name ''\");\n         (16, 40, 16, 50, \"This expression was expected to have type    'string'    but here has type    'unit'    \")]\n``Test TPProject errors`` ()\nlet internal extractToolTipText (FSharpToolTipText(els)) = \n    [ for e in els do \n        match e with\n        | FSharpToolTipElement.Group txts -> for item in txts do yield item.MainDescription\n        | FSharpToolTipElement.CompositionError err -> yield err\n        | FSharpToolTipElement.None -> yield \"NONE!\" ] \n\n[<Test>]\nlet ``Test TPProject quick info`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let toolTips  =\n      [ for lineNum in 0 .. TPProject.fileLines1.Length - 1 do \n         let lineText = TPProject.fileLines1.[lineNum]\n         if lineText.Contains(\".IsMatch\") then \n            let colAtEndOfNames = lineText.IndexOf(\".IsMatch\") + \".IsMatch\".Length\n            let res = typeCheckResults.GetToolTipTextAlternate(lineNum, colAtEndOfNames, lineText, [\"RegexTypedStatic\";\"IsMatch\"], FSharpTokenTag.IDENT) |> Async.RunSynchronously \n            yield lineNum, extractToolTipText  res ]\n    //printfn \"toolTips = \\n----\\n%A\\n----\" toolTips\n\n    toolTips |> shouldEqual\n        [(5, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (6, [\"RegexTypedStatic.IsMatch() : int\"]);\n         // NOTE: This tool tip is sub-optimal, it would be better to show RegexTypedStatic.IsMatch<\"ABC\">\n         //       This is a little tricky to implement\n         (7, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (8, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (9, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (10, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (11, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (12, [\"RegexTypedStatic.IsMatch() : int\"]);\n         (13, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (14, [\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"]);\n         (15, [\"RegexTypedStatic.IsMatch() : int\"])]\n\n\n[<Test>]\nlet ``Test TPProject param info`` () = \n    let wholeProjectResults = checker.ParseAndCheckProject(TPProject.options) |> Async.RunSynchronously\n    let parseResult, typeCheckAnswer = checker.ParseAndCheckFileInProject(TPProject.fileName1, 0, TPProject.fileSource1, TPProject.options) |> Async.RunSynchronously\n    let typeCheckResults = \n        match typeCheckAnswer with\n        | FSharpCheckFileAnswer.Succeeded(res) -> res\n        | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n    let paramInfos =\n      [ for lineNum in 0 .. TPProject.fileLines1.Length - 1 do \n         let lineText = TPProject.fileLines1.[lineNum]\n         if lineText.Contains(\".IsMatch\") then \n            let colAtEndOfNames = lineText.IndexOf(\".IsMatch\")  + \".IsMatch\".Length\n            let meths = typeCheckResults.GetMethodsAlternate(lineNum, colAtEndOfNames, lineText, Some [\"RegexTypedStatic\";\"IsMatch\"]) |> Async.RunSynchronously \n            let elems = \n                [ for meth in meths.Methods do \n                   yield extractToolTipText  meth.Description, meth.HasParameters, [ for p in meth.Parameters -> p.ParameterName ], [ for p in meth.StaticParameters -> p.ParameterName ] ]\n            yield lineNum, elems]\n    //printfn \"paramInfos = \\n----\\n%A\\n----\" paramInfos \n\n    // This tests that properly statically-instantiated methods have the right method lists and parameter info\n    paramInfos |> shouldEqual\n        [(5, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (6, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         // NOTE: this method description is sub-optimal, it would be better to show RegexTypedStatic.IsMatch<\"ABC\">\n         (7,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (8,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (9,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (10,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true, [\"input\"], [\"pattern1\"])]);\n         (11, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (12, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])]);\n         (13,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (14,[([\"RegexTypedStatic.IsMatch,pattern1=\\\"ABC\\\"(input: string) : bool\"], true,[\"input\"], [\"pattern1\"])]);\n         (15, [([\"RegexTypedStatic.IsMatch() : int\"], true, [], [\"pattern1\"])])]\n\n#endif // TEST_TP_PROJECTS\n\n#if EXE\n\n``Intro test`` () \n//``Test TPProject all symbols`` () \n//``Test TPProject errors`` () \n//``Test TPProject quick info`` () \n//``Test TPProject param info`` () \n``Basic cancellation test`` ()\n``Intro test`` () \n#endif", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [{"SnippetId" :"560bbd44-ad59-4b88-81d7-c27a14b0ad2e"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"128c1c1d-e96f-41e7-bf89-9466b8dff4ee"}, "snpName": "GetDeclarationListInfo", "snpContent": "   ParsedFileResultsOpt             : FSharpParseFileResults option\n * line                             : int\n * colAtEndOfPartialName            : int\n * lineText                         : string\n * qualifyingNames                  : string list\n * partialName                      : string\n * getAllSymbols                    : (unit -> AssemblySymbol list)\n * hasTextChangedSinceLastTypecheck : (obj * range -> bool) option\n * userOpName                       : string option\n\nGetDeclarationListInfo(\n  Some parseResult\n, 7\n, 23\n, inputLines.[6]\n, []\n, \"msg\"\n, (fun _ -> [])\n, fun _ -> false)\n\nFSharpCheckFileResults.GetDeclarationListInfo :\n  ParsedFileResultsOpt:FSharpParseFileResults option\n* line:int\n* lineText:string\n* partialName:PartialLongName\n* getAllSymbols:(unit -> AssemblySymbol list)\n* ?hasTextChangedSinceLastTypecheck:(obj * Range.range -> bool)\n* ?userOpName:string -> Async<FSharpDeclarationListInfo>\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5df15cf1-361e-4d57-a565-683ab0b72082"}, "snpName": "Substring, Regex", "snpContent": "let extract n (s:string) = s.Substring(0, min n s.Length)\nlet s = \"1234567890123456789012345678901234567890\"\nprintfn \"%s\" <| extract 100 s\n\nopen System\nprintfn \"%s\" <| System.DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nopen UsefulDotNet\n//Example:\nlet phone = \"(555) 555-5555\"\nmatch phone with\n| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n| _ -> printfn \"Not a phone number\"\n\nlet code = \"let a = \\\"123\\\" |> St\"\nmatch code with\n| Regex @\"([a-zA-Z_]\\w+)$\" [ txt ] -> printfn \"%s\" txt\n| _                                -> printfn \"<No match>\"\n\nlet line = \" hello how \\\"are you\\\" good \\\"and you\\\"\"\nmatch line with \n| Regexs \"(\\\".*?\\\"|\\S+)\" ms -> \n    ms \n    |> Seq.iter\n        (function | Regex \"(\\\"(.*?)\\\")\" [_ ; m] | m -> printfn \"%A\" m)\n//| Regex \"(\\\"([^\\\"]*)\\\"|\\S*)*\" r -> printfn \"%A\" r\n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [{"SnippetId" :"7646acbc-2c28-4159-98b1-2365d19fc97c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3d704638-8ba4-4bc8-b810-29e023a222fc"}, "snpName": "Stack Overflow", "snpContent": "let rec recursive i = 1 + recursive i\nrecursive 1", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bd716e89-0546-4d6b-8964-26473ddcd121"}, "snpName": "Calculate primes", "snpContent": "open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\n#if INTERACTIVE\nlet main =\n#else\n[< EntryPoint ; STAThread >]\nlet main args =\n#endif\n    Application.EnableVisualStyles()\n    let form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    panel1.DockPadding.All <- 10\n    let spacing = 5\n    let button1 = new Button(Text = \"Start\")\n    let button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\n    let button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\n    let updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                         Value = 20m,\n                                                         Minimum = 0m,\n                                                         Maximum = 1000000m)\n    let label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                            Width = 300, Height = 2 * button1.Height)\n    let progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                      Width = 300)\n    panel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\n    form.Controls.Add(panel1)\n    button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n    button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n    button3.Click.Add(fun args -> Async.CancelDefaultToken())\n    form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n#if INTERACTIVE\n    form.ShowDialog() |> ignore\n#else\n    form |> Application.Run\n#endif\n    0\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dc44bbe1-876a-4910-a39a-5d74bc2304ee"}, "snpName": "Form test and Messaging", "snpContent": "open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\n\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value   = 20m     ,\n                                                     Minimum = 0m      ,\n                                                     Maximum = 1000000m)\n\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1    \n   button2    \n   button3    \n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start\n\n//open CIPHERPrototype.Messaging\nopen Useful\nopen FsStationShared\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.Web.dll\"\n#nowarn \"1125\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\nlet fsClient = FsStationClient(\"ButtonTest\")\n\nbutton1.Click.Add (fun args ->                                                      \n    Wrap.wrapper {\n        let! response = fsClient.GenericMessage \"Hello\"\n        label1.Text <- response\n    } |> Wrap.Start\n)\n\n//let requestCode (snpName:string) = \n//    async {\n//        let! response = sendRequestRpc toId fromId (snpName.Split '/' |> GetSnippetCode |> Json.Serialize)\n//        let resp =\n//            match response |> Json.Deserialize<FSResponse> with\n//            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n//            | StringResponse (Some code)    -> code\n//            | IdResponse     (AddressId id) -> id.ToString()\n//            | _                             -> sprintf \"<Incomplete response: %s>\" response\n//        return resp\n//    }    \n//\n//open Rop\n//Wrap.wrapper {\n//    let! code   = requestCode \"module FSharpStationMD   =/Evaluate F# Code/module Snippets =/Calculate primes\"\n//    let! result = processCode (compileCode \"TESTCODE\") code\n//    result |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> printfn \"%s\"\n//} |> Wrap.getAsyncR |> Async.Start\n\nlet respondMessage fromId (msg:string) : string =\n    label1.Text <- msg\n    match msg |> Json.Deserialize<FSMessage> with\n    | GenericMessage        txt  -> label1.Text <- txt\n                                    StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fromId \n    | _                          -> StringResponse <| (Some <| \"Message received: \" + msg)\n    |> Json.Serialize\n\nfsClient.MessagingClient.AwaitMessage respondMessage\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [{"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"46450fbf-b073-4a66-ab42-587be0afc45f"}, "snpName": "JSON Serializer", "snpContent": "#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Collections.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Main.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.JavaScript.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Web.dll\"\n#r @\"..\\packages\\Zafir.UI.Next\\lib\\net40\\WebSharper.UI.Next.dll\"\n#r @\"..\\packages\\Zafir\\lib\\net40\\WebSharper.Sitelets.dll\"\n\n//open CIPHERPrototype.Messaging\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Remoting\n\n\ntype FSMessage =\n    | GetSnippetContentById of string //CodeSnippetId\n    | GetSnippetCodeById    of string //CodeSnippetId\n    | GetSnippetById        of string //CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of string //CodeSnippet option\n    | StringResponse    of string option\n//    | IdResponse        of CIPHERPrototype.Messaging.AddressId\n\nGenericMessage \"Hello\" \n|> Json.ServerSideProvider.GetEncoder().Encode\n|> Json.ServerSideProvider.Pack\n|> printfn \"%A\"\n\ntype Response = {\n    ``$TYPES`` : string[]\n    ``$DATA``  : string\n}\n\n\"\"\"{\"$TYPES\":[],\"$DATA\":\"{\\\"$\\\":1,\\\"Item\\\":\\\"Message received: Hello\\\"}\"}\"\"\"\n|> Json.Deserialize<Response>\n|> (fun r -> r.``$DATA``)\n|> Json.Deserialize<FSResponse>\n|> printfn \"%A\"\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"}, "snpName": "", "snpContent": "System.IO.File.Delete(@\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\EPFileX\\CodeEditor.fsx.bak\")", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"}, "snpName": "", "snpContent": "let rand = System.Random()\nlet randomNumbers = seq { while true do yield rand.Next(100) }\nlet firstTenRandomNumbers =\n randomNumbers\n |> Seq.truncate 10\n |> Seq.toList\n \nprintfn \"%+A\" firstTenRandomNumbers  \n//printfn \"%t\" (fun w -> w.WriteLine 6)  \n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f850ce38-14e5-47a4-81ed-df02d7979f8e"}, "snpName": "Failed to load argument type", "snpContent": "#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\n\n[< JavaScript >]\ntype AddressId = AddressId of string\n\n[< Rpc >]\nlet sendRequest  (toId:AddressId) =\n        async {\n            return \"HELLO\"\n        }\n\n[< JavaScript >]\nlet tried() =\n    let f = AddressId \"XXX\"\n    let v = sendRequest f\n    (f, v)\n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dfc80990-ada5-4f24-8192-85bfe3b115a5"}, "snpName": "Rules Alea", "snpContent": "let accounts =\n  [|\n    \"30\", \"Net Income After M. I. & Taxes \"\n    \"35\", \"Income (Loss) before Taxes \"\n    \"36\", \"Income (Loss) before taxes and M.I. \"\n    \"37\", \"Income from Continuing Operations \"\n    \"38\", \"Operating Income/(Loss) \"\n    \"39\", \"Actual Gross Income \"\n    \"300\", \"Total Net Revenue \"\n    \"301\", \"Orders Available to Ship \"\n    \"310\", \"Total Projected Sales Orders \"\n    \"320\", \"Plus:Orders In Backlog \"\n    \"350\", \"Less:Proj. Ending Backlog \"\n    \"360\", \"Non Interco Revenue \"\n    \"370\", \"Interco Revenue \"\n    \"400\", \"Cost of Goods Sold-Actual \"\n    \"401\", \"Memo Only:Inventory Receipts \"\n    \"402\", \"Memo Only:Interco inventory \"\n    \"410\", \"Cost of Goods Sold \"\n    \"430\", \"Standard COGS-Non Interco \"\n    \"440\", \"Standard COGS-Interco \"\n    \"500\", \"Total Mfg./Distr. Variances \"\n    \"510\", \"Purchase Price/Freight/Reclass \"\n    \"520\", \"Material Usage \"\n    \"530\", \"Inventory Adjustment \"\n    \"540\", \"Labor Performance/Rate \"\n    \"580\", \"Overhead Variance \"\n    \"5800\", \"Overhead Spending \"\n    \"5810\", \"Bonus Accrual for Overhead \"\n    \"5820\", \"Less:Overhead Absorption \"\n    \"40\", \"Actual Gross Margin %   \"\n    \"41\", \"Plan Gross Margin %  \"\n    \"60\", \"Total Expenses \"\n    \"610\", \"Engineering \"\n    \"620\", \"Sales \"\n    \"630\", \"General & Administrative \"\n    \"640\", \"ESOP/401K Contributions \"\n    \"650\", \"Bonus Accrual \"\n    \"660\", \"Warranty Expense-Total \"\n    \"700\", \"Total Non-Operating Income/(Expense) \"\n    \"710\", \"Other Income \"\n    \"720\", \"JV Profit Allocation \"\n    \"730\", \"Other (Expense) \"\n    \"740\", \"Management Fees \"\n    \"750\", \"Interest (Expense)/Income \"\n    \"810\", \"Inventory Disposal Program \"\n    \"910\", \"Minority Interest \"\n    \"920\", \"Federal State Other Income Tax \"\n    \"31\", \"P.A.T. % \"\n    \"32\", \"PLAN INCOME AFTER TAXES & M.I. \"\n    \"33\", \"$ VARIANCE TO PLAN \"\n    \"Cash Flow Statement\", \"Cash Flow Statement \"\n    \"C1\", \"Projected Ending Loan Balance \"\n    \"C10\", \"Beginning Loan Balance \"\n    \"C20\", \"NET PROJECTED CASH + (-) \"\n    \"C201\", \"Other Items- \"\n    \"C202\", \"Other Income \"\n    \"C203\", \"JV Profit Allocation \"\n    \"C204\", \"Other Expense \"\n    \"C205\", \"Management Fees \"\n    \"C206\", \"Capital Additions & Investments \"\n    \"C207\", \"Interest (Expense)/Income \"\n    \"C208\", \"Note principal payments \"\n    \"C209\", \"Other State & Fed Taxes \"\n    \"C210\", \"Tax Distributions to Holdings \"\n    \"C211\", \"Tax Dist. to Other Shareholders \"\n    \"C212\", \"Non-Tax Distributions to Holdings \"\n    \"C213\", \"Non-Tax Dist. to Other Shareholders \"\n    \"C30\", \"Net Cash Flow from Operations \"\n    \"C31\", \"= Gross Cash Inflow(Outflow) \"\n    \"C310\", \"= Net Collections \"\n    \"C311\", \"Gross Collections \"\n    \"C312\", \"Less Core Credits \"\n    \"C321\", \"Payments \"\n    \"C322\", \"Materials \"\n    \"C323\", \"Less Warranty Recovery \"\n    \"C324\", \"Freight Payments \"\n    \"C325\", \"Direct Labor \"\n    \"C326\", \"Overhead Spending \"\n    \"C33\", \"Total Expenses \"\n    \"C331\", \"Engineering \"\n    \"C332\", \"Sales \"\n    \"C333\", \"General & Administrative \"\n    \"C334\", \"ESOP/401K Contributions \"\n    \"C335\", \"Bonus Payments \"\n    \"C336\", \"Gross Warranty Payments \"\n    \"C39\", \"Add back: Depreciation \"\n    \"C2\", \"PLAN Loan Balance \"\n    \"C3\", \"$ VARIANCE TO PLAN (under) \"\n    \"Return On Assets\", \"Return On Assets \"\n    \"R10\", \"Opinion ROA (annualized) \"\n    \"R11\", \"Year End ROA Plan \"\n    \"R5\", \"Year End Net Income Plan \"\n    \"R100\", \"Net Income Calculations \"\n    \"R3\", \"YTD Comparison to Plan \"\n    \"R1\", \"Total Net Income (opinion & YTD) \"\n    \"R110\", \"Last Month Projected Net Income YTD \"\n    \"R120\", \"This Month Opinion Net Income \"\n    \"R2\", \"Net Income YTD Plan \"\n    \"R4\", \"Annualized Projected - Actual, Opinion & Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Earnings\", \"Earnings \"\n    \"E1\", \"EBITDA Dollar Calculations \"\n    \"E2\", \"EBITDA YTD Opinion to Plan (worse) \"\n    \"E20\", \"Annualized Projected  \"\n    \"E21\", \"Total EBITDA Dollars (opinion & YTD) \"\n    \"E22\", \"Projected Last Month EBITDA YTD \"\n    \"E23\", \"This Month Opinion EBITDA Dollars \"\n    \"E231\", \"This Month-- Profit Before Tax and M.I. \"\n    \"E232\", \"This Month-- Interest \"\n    \"E233\", \"This Month-- Depreciation/Amortization \"\n    \"E24\", \"EBITDA Plan Remaining Year \"\n    \"E25\", \"Annual EBITDA Dollars -- FROM PLAN \"\n    \"E3\", \"EBITDA Month Opinion to Plan (worse) \"\n    \"E30\", \"Plan EBITDA Dollars This Month \"\n    \"E31\", \"This Month Opinion EBITDA Dollars \"\n    \"E40\", \"Opinion EBITDA/Assets (annualized) \"\n    \"E41\", \"Annual EBITDA/Month Assets Plan \"\n    \"E42\", \"Annual EBITDA/Annual Assets Plan \"\n    \"R8\", \"Assets Month to Plan (better) \"\n    \"R6\", \"Total This Month Ending Assets Opinion \"\n    \"R600\", \"Total Assets Calculation \"\n    \"R610\", \"Projected Last Month Ending Assets \"\n    \"R620\", \"Total Net Change in Assets \"\n    \"R630\", \"Total Net Change Inventory \"\n    \"R631\", \"Net Change in Inventory \"\n    \"R632\", \"Total Into Inventory \"\n    \"R633\", \"Material Receipts \"\n    \"R634\", \"Material Usage Variance \"\n    \"R635\", \"Labor \"\n    \"R636\", \"Labor Variance \"\n    \"R637\", \"Overhead Absorbed \"\n    \"R638\", \"Material Recovery from Warranty \"\n    \"R639\", \"COGS Out \"\n    \"R640\", \"Total Net Change Fixed Assets \"\n    \"R641\", \"Net Change in Fixed Assets \"\n    \"R642\", \"Capital and Investments \"\n    \"R643\", \"Depreciation \"\n    \"R650\", \"Total Net Change in A/R \"\n    \"R651\", \"Net Change in Accts Rec \"\n    \"R652\", \"Shipments \"\n    \"R653\", \"Gross Collections \"\n    \"R7\", \"Plan This Month Ending Assets \"\n    \"R9\", \"Year Ending Asset Plan \"\n    \"Shipments\", \" \"\n    \"S1\", \"Current Shipments \"\n  |]\n  \nlet rules = \n  [| \n    \"[Version:'Projection'] =IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))));\", \"##[Projection] FROM [FP,W5,W4,W3,W2,W1] RULE: IF([Version:'Final Projection']<>0, [Version:'Final Projection'],IF([Version:'Week 5']<>0, [Version:'Week 5'],IF([Version:'Week 4']<>0, [Version:'Week 4'], IF([Version:'Week 3']<>0, [Version:'Week 3'],IF([Version:'Week 2']<>0, [Version:'Week 2'],IF([Version:'Week 1']<>0, [Version:'Week 1'],0))))))\"\n    \"[Version:'Actual\\Projection']=B:IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection']);\", \"##[Actual\\Projection] FROM ['Actual'], ['Projection'] RULE: IF(NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),1,4))*100+NUMBR(SUBST(GETATTR('Version', 'Projection', 1, 'START'),6,2))> NUMBR(!YEAR)*100+NUMBR(SUBST(!PERIOD, 2, 2)),['Actual'], ['Projection'])\"\n    \"[Currency:'USD'] =B:[Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'));\", \"##[Currency] FROM LC RULE: [Currency:'LC'] * DB('XRates',!YEAR, !PERIOD, !VERSION, GETATTR('ACCOUNT', !Account, 1, 'XRate'),GETATTR('UNIT', !Unit, 1, 'Currency'))\"\n    \"[Period:'YTD']=[Period:'YTD_12'];\", \"##[YTD] FROM [YTD_12] RULE: [Period:'YTD_12']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'310'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Total Projected Sales Orders] FROM [Interco Revenue] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']=-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370'];\", \"##ELIM [Interco Revenue]                     FROM [Interco Revenue]  RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'401']=[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\", \"##ELIM Memo [Only:Inventory Receipts] FROM [Interco Revenue] RULE: [Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'370']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'440'] =B:-1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Interco] FROM [Standard COGS-Interco] RULE: -1*[Level:'Net Reported', Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Level:'Automatic Elim 1', Unit:'Interco Elims', Account:'430'] =B:-1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440'];\", \"##ELIM [Standard COGS-Non Interco] FROM [Interco Revenue] AND [Standard COGS-Interco] RULE: -1*[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'370']+[Level:'Net Reported',Unit:'Consolidated wo Elims', Account:'440']\"\n    \"[Account:'910', Version:'Plan']=#NA;\", \"##[Minority Interest] RULE: #NA\"\n    \"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\", \"##[Minority Interest] FROM [Income (Loss) before taxes and M.I.] RULE: -1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %')\"\n    \"[Account:'40'] =[Account:'39']/[Account:'300'];\", \"##[Actual Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39']/[Account:'300']\"\n    \"[Account:'41'] =[Account:'39',Version:'Plan']/[Account:'300',Version:'Plan'];\", \"##[Plan Gross Margin %] FROM [Actual Gross Income] / [Total Net Revenue] RULE: [Account:'39',Version:'Plan']/[Account:'300',Version:'Plan']\"\n    \"[Account:'31'] =[Account:'30']/[Account:'360'];\", \"##[P.A.T. %] FROM [Net Income After M. I. & Taxes] / [Income (Loss) before taxes and M.I.] RULE: [Account:'30']/[Account:'360']\"\n    \"[Account:'32'] =[Account:'30',Version:'Plan'];\", \"##[PLAN INCOME AFTER TAXES & M.I.] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30',Version:'Plan']\"\n    \"[Account:'33'] =B:[Account:'30']-[Account:'32'];\", \"##[$ VARIANCE TO PLAN] FROM [Net Income After M. I. & Taxes] - [PLAN INCOME AFTER TAXES & M.I.] RULE: [Account:'30']-[Account:'32']\"\n    \"###[Account:'C326']=B:-1*([Account:'5800']-[Account:'5810'])\", \"##[Overhead Spending] FROM [Overhead Spending] - [Bonus Accrual for Overhead] RULE: -1*([Account:'5800']-[Account:'5810'])\"\n    \"[Account:'C331']=-1*([Account:'610']);\", \"##[Engineering] FROM [Engineering] RULE: -1*([Account:'610'])\"\n    \"[Account:'C332']=-1*([Account:'620']);\", \"##[Sales] FROM [Sales] RULE: -1*([Account:'620'])\"\n    \"[Account:'C333']=-1*([Account:'630']);\", \"##[General & Administrative] FROM [General & Administrative] RULE: -1*([Account:'630'])\"\n    \"[Account:'C334']=-1*[Account:'640'];\", \"##[ESOP/401K Contributions] FROM [ESOP/401K Contributions] RULE: -1*([Account:'640'])\"\n    \"[Account:'C205']=B:[Account:'740'];\", \"##[Management Fees] FROM [Management Fees] RULE: [Account:'740']\"\n    \"[Account:'C207']=[Account:'750'];\", \"##[Interest (Expense)/Income] FROM [Interest (Expense)/Income] RULE: [Account:'750']\"\n    \"[Account:'C3'] =[Account:'C1']-[Account:'C2'];\", \"##[$ VARIANCE TO PLAN (under)] FROM [Projected Ending Loan Balance] - [PLAN Loan Balance] RULE: [Account:'C1']-[Account:'C2']\"\n    \"[Account:'C2']=B:IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2']);\", \"##[PLAN Loan Balance] FROM [PLAN Loan Balance] RULE: IF(!VERSION@='Plan',STET,[Version:'Plan', Account:'C2'])\"\n    \"[Account:'R110']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE));\", \"##BC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), !VERSION, !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE))\"\n    \"[Account:'R110']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET);\", \"##CC [Last Month Projected Net Income YTD] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Account:'36'], STET)\"\n    \"[Account:'R120'] =[Account:'30'];\", \"##[This Month Opinion Net Income] FROM [Net Income After M. I. & Taxes] RULE: [Account:'30']\"\n    \"[Account:'R2']=B:DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##BC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'R2']=C:IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET);\", \"##CC [Net Income YTD Plan] FROM [Income (Loss) before taxes and M.I.] RULE: IF(DE.CHILDRENCOUNT('Period', !PERIOD)>0, [Version:'Plan', Account:'36'], STET)\"\n    \"[Account:'R610']=B:IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE));\", \"##[Projected Last Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: IF(!PERIOD@='M01',0,DB('StaffNumbers',!YEAR, DE.SIBLING('Period',!PERIOD,-1), 'Projection', !CURRENCY, !LEVEL, !UNIT, 'R6', !MEASURE))\"\n    \"[Account:'R7']=[Version:'Plan',Account:'R6'];\", \"##[Plan This Month Ending Assets] FROM [Total This Month Ending Assets Opinion] RULE: [Version:'Plan',Account:'R6']\"\n    \"[Account:'R9']=[Period:'Year', Version:'Plan', Account:'R6'];\", \"##[Year Ending Asset Plan] FROM [Total This Month Ending Assets Opinion] RULE: [Period:'Year', Version:'Plan', Account:'R6']\"\n    \"###[Account:'R3'] =[Account:'R1']-[Account:'R2']\", \"##[YTD Comparison to Plan] FROM [Total Net Income (opinion & YTD)] - [Net Income YTD Plan] RULE: [Account:'R1']-[Account:'R2']\"\n    \"[Account:R633] =[Account:401];\", \"##[Material Receipts] FROM [Memo Only:Inventory Receipts] RULE: [Account:401]\"\n    \"[Account:R634] =-1*[Account:520];\", \"##[Material Usage Variance] FROM [Material Usage] RULE: -1*[Account:520]\"\n    \"[Account:R635] =-1*[Account:C325];\", \"##[Labor] FROM [Direct Labor] RULE: -1*[Account:C325]\"\n    \"[Account:R637] =-1*[Account:5820];\", \"##[Overhead Absorbed] FROM [Less:Overhead Absorption] RULE: -1*[Account:5820]\"\n    \"[Account:R636] =-1*[Account:540];\", \"##[Labor Variance] FROM [Labor Performance/Rate] RULE: -1*[Account:540]\"\n    \"[Account:R638] =[Account:C323];\", \"##[Material Recovery from Warranty] FROM [Less Warranty Recovery] RULE: [Account:C323]\"\n    \"[Account:R639] =-1*[Account:'410'];\", \"##[COGS Out] FROM [Cost of Goods Sold] RULE: -1*[Account:'410']\"\n    \"[Account:R642] =-1*[Account:C206];\", \"##[Capital and Investments] FROM [Capital Additions & Investments] RULE: -1*[Account:C206]\"\n    \"[Account:R643] =-1*[Account:C39];\", \"##[Depreciation] FROM [Add back: Depreciation] RULE: -1*[Account:C39]\"\n    \"[Account:R652] =[Account:300];\", \"##[Shipments] FROM [Total Net Revenue] RULE: [Account:300]\"\n    \"[Account:R653] =[Account:C311];\", \"##[Gross Collections] FROM [Gross Collections] RULE: [Account:C311]\"\n    \"[Account:'R10']=[Account:'R4']/[Account:'R6'];\", \"##[Opinion ROA (annualized)] FROM [Annualized Projected - Actual, Opinion & Plan] / [Total This Month Ending Assets Opinion] RULE: [Account:'R4']/[Account:'R6']\"\n    \"[Account:'R11']=[Account:'R5']/[Account:'R9'];\", \"##[Year End ROA Plan] FROM [Year End Net Income Plan] / [Year Ending Asset Plan] RULE: [Account:'R5']/[Account:'R9']\"\n    \"[Account:'E22']=DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Projected Last Month EBITDA YTD] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',DE.SIBLING('Period',!PERIOD,-1),2), 'Projection', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E24']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[EBITDA Plan Remaining Year] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)-DB('StaffNumbers',!YEAR, DE.PARENTNAME('Period',!PERIOD,2), 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E25']=DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE);\", \"##[Annual EBITDA Dollars -- FROM PLAN] FROM [Income (Loss) before taxes and M.I.] RULE: DB('StaffNumbers',!YEAR, 'Year', 'Plan', !CURRENCY, !LEVEL, !UNIT, '36', !MEASURE)\"\n    \"[Account:'E30']=[Version:'Plan',Account:'36'];\", \"##[Plan EBITDA Dollars This Month] FROM [Income (Loss) before taxes and M.I.] RULE: [Version:'Plan',Account:'36']\"\n    \"[Account:'E31']=[Account:'E23'];\", \"##[This Month Opinion EBITDA Dollars] FROM [This Month Opinion EBITDA Dollars] RULE: [Account:'E23']\"\n    \"[Account:'E231']=[Account:'36'];\", \"##[This Month-- Profit Before Tax and M.I.] FROM [Income (Loss) before taxes and M.I.] RULE: [Account:'36']\"\n    \"[Account:'E233']=[Account:'C39'];\", \"##[This Month-- Depreciation/Amortization] FROM [Add back: Depreciation] RULE: [Account:'C39']\"\n    \"[Account:'E232']=-1*[Account:'750'];\", \"##[This Month-- Interest] FROM [Interest (Expense)/Income] RULE: -1*[Account:'750']\"\n    \"[Account:'E40']=[Account:'E20']/[Account:'R6'];\", \"##[Opinion EBITDA/Assets (annualized)] FROM [Annualized Projected ] / [Total This Month Ending Assets Opinion] RULE: [Account:'E20']/[Account:'R6']\"\n    \"[Account:'E41']=[Account:'E25']/[Account:'R7'];\", \"##[Annual EBITDA/Month Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Plan This Month Ending Assets] RULE: [Account:'E25']/[Account:'R7']\"\n    \"[Account:'E42']=[Account:'E25']/[Account:'R9'];\", \"##[Annual EBITDA/Annual Assets Plan] FROM [Annual EBITDA Dollars -- FROM PLAN] / [Year Ending Asset Plan] RULE: [Account:'E25']/[Account:'R9']\"\n  |]  \n  \n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\nopen System.Text.RegularExpressions\n\nlet AccountP = @\"(\\[((.+?),)*\\s*Account\\s*:\\s*'?(.+?)'?(,(.+?))*\\])\"\nlet input    = @\"[Level:'Adjustments', Account:'910']=B:-1*([Account:'36',Level:'Net Reported'])*DB('UNITSET',!YEAR, !PERIOD, !UNIT, 'Minority %');\"\n\nlet splitRule r =\n    Regex.Match(r, @\"(.+?)=(.+)\")\n    |> (fun m -> m.Groups.[1].Value, m.Groups.[2].Value)\n\nlet replace input =\n    Regex.Matches(input, AccountP)\n    |> Seq.cast<Match>\n    |> Seq.map (fun m -> \n        let whole = m.Groups.[0]\n        let acct  = m.Groups.[4]\n        let pres  = m.Groups.[3].Captures |> Seq.cast<Capture>\n        let sufs  = m.Groups.[6].Captures |> Seq.cast<Capture>\n        accounts \n        |> Seq.tryFind (fst >> ((=) acct.Value)) \n        |> Option.map snd \n        |> Option.defaultValue (\"Not Found: \" + acct.Value) \n        |> (fun s -> \n            let txt  = \n                [ yield s.Trim()\n                  for pre in pres do yield pre.Value\n                  for suf in sufs do yield suf.Value \n                ] \n                |> String.concat \"~\" \n                |> sprintf \"{%s}\" \n            txt, whole.Index, whole.Length)\n       )\n    |> Seq.fold (fun (txt:string, i, out) (v, s, l) -> (txt.[s + l - i ..], s + l, out + txt.[0 .. s - i - 1] + v) ) (input, 0, \"\")\n    |> fun (res, _, out) -> out + res\n    \nrules\n|> Seq.iter (\n    fun (r, c) ->\n        let a, b = splitRule r\n        printfn \"%s\\t%s\\t%s\" (replace a) (replace b) c\n \n)", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3def8b16-6c90-40f4-a78e-b2b293df699a"}, "snpName": "FSharpPlus", "snpContent": "#r \"..\\packages\\FSharpPlus\\lib\\net45\\FSharpPlus.dll\"\n\nopen FSharpPlus\n\nlet doF f v = f v; v\n\nlet getType (obj:obj) = if obj = null then null else obj.GetType()\n\nlet print v = printfn \"val it : %O = %A\" (getType v) v\n    \n//let pythags = \nmonad {\n    let! z = [| 1..50    |]\n    let! x = [| 1..z - 1 |]\n    let! y = [| x..z - 1 |]\n    do!  guard (x*x + y*y = z*z)\n    return (x, y, z)\n}    \n|> print\n\n//let pythags' = \nmonad.plus {\n      let! z = [1..50   ]\n      let! x = [1..z - 1]\n      let! y = [x..z - 1]\n      do!  guard (x*x + y*y = z*z)\n      return (x, y, z)\n}    \n|> print\n\n//let allCombinations = \n//sequence [['a'; 'b'; 'c']; ['1'; '2']]\n//|> print\n\n//let asyncValue = \n(let  a = (printfn \"I'm not async\"; 2)\n async {\n    printfn \"started\"\n    let  b =              (printfn \"I'm kind of async\";  3)\n    let! c = async.Return (printfn \"I'm async too\"    ; 10)\n    return a + b + c\n })\n|> doF print    \n|> Async.RunSynchronously\n|> printfn \"%d\" \n\n//let lazyValue = \n(let  a = (printfn \"I'm not lazy\"; 2)\n monad {\n    printfn \"started\"\n    let  b =      (printfn \"I'm kind of lazy\" ;  2)\n    let! c = lazy (printfn \"I'm lazy too\"     ; 10)\n    return a + b + c\n })\n|> doF print    \n|> fun f -> f.Value\n|> print\n    \n//let maybeWithSideFx = \nmonad.fx.strict {  \n//monad.fx {  // without strict we get infinite loop\n        let! a = Some 3\n        let b = ref 0\n        while !b < 10 do \n          let! n = Some ()\n          incr b\n        if a = 3 then printfn \"got 3\"\n        else printfn \"got something else (will never print this)\"\n        return a \n}\n|> print    \n// val maybeWithSideFx : int option = Some 3\n\nlet lst = [None; None; Some 2; Some 4; Some 10; None]\n\n//let maybeManyTimes = \nmonad.plus.strict {\n//monad.plus { // without strict we get Stack Overflow\n        let defaultValue = 42\n        let mutable i = 0\n        return! None\n        while i < 5 do\n            printfn \"looping %i\" i\n            i <- i + 1\n            return! lst.[i]\n        printfn \"halfway\"\n        return! None\n        printfn \"near the end\"\n        return defaultValue \n}\n|> print\n// val maybeManyTimes : int option = Some 2\nprintfn \"--------------------------------------------------------------\"\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\"2\"; \"3\"; \"4\"; \"5\"|]\n|> print\n\nmap ((+) 9) (Some 3)\n// val it : int option = Some 12\n|> print\n\n//map string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList<string> = {Head = \"2\"; Tail = [\"3\"; \"4\"; \"5\"];}\n//|> print\n\n[\"hello\";\" \";\"world\"] >>= (fun x -> Seq.toList x)\n|> print\n// val x : char list = ['h'; 'e'; 'l'; 'l'; 'o'; ' '; 'w'; 'o'; 'r'; 'l'; 'd']\n\n\nlet tryParseInt : string -> int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nSome \"20\" >>= tryParseInt >>= tryDivide 100\n|> print\n// val y : int option = Some 5\n\nlet parseAndDivide100By = tryParseInt >=> tryDivide 100\n\nparseAndDivide100By \"20\"   // Some 5\n|> print\nparseAndDivide100By \"zero\" // None\n|> print\nparseAndDivide100By \"0\"    // None\n|> print\n\nlet parseElement n = List.tryItem n >=> tryParseInt\nparseElement 2 [\"0\"; \"1\";\"2\"]\n|> print\n\nlet tryParseInt' x : Choice<int, string> = \n    match tryParse x with \n    | Some x -> Choice1Of2 x\n    | None   -> Choice2Of2 (\"Failed to parse \" + x)\n        \n\nlet tryDivide' x n = \n    if n = 0 then Choice2Of2 \"Can't divide by zero\"\n    else Choice1Of2 (x / n)\n    \nlet parseAndDivide100By' = tryParseInt' >=> tryDivide' 100\n\nparseAndDivide100By' \"20\"   // Some 5\n|> print\nparseAndDivide100By' \"zero\" // None\n|> print\nparseAndDivide100By' \"0\"    // None\n|> print\n\nSome (+) <*> Some 2 <*> Some 10     // val sumAllOptions : int option = Some 12\n|> print\n\n[(+)] <*> [10; 100] <*> [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n|> print\n\nopen FSharpPlus.Lens\n\n\n(\"hello\",\"world\")^. _2           // val it : string = \"world\"\n|> print\n\nsetl _2 42 (\"hello\",\"world\", 8)  // val it : string * int = (\"hello\", 42)\n|> print\n\n(\"hello\",(\"world\",\"!!!\"))^.(_2 << _1)\n// val it : string = \"world\"\n|> print\n\nsetl (_2 << _1) 42 (\"hello\",(\"world\",\"!!!\"))             \n// val it : string * (int * string) = (\"hello\", (42, \"!!!\"))\n|> print\n\n\"hello\"^.to' length\n// val it : int = 5\n|> print\n\n(\"hello\",(\"world\",\"!!!\"))^. (_2 << _2 << to' length)\n// val it : int = 3\n|> print\n\n_1 .-> \"hello\" <| ((),\"world\")\n// val it : string * string = (\"hello\", \"world\")\n|> print\n\n((), \"world\") |> _1 .-> \"hello\"\n|> print // val it : string * string = (\"hello\", \"world\")\n\nview _2 (10,20)\n|> print // val it : int = 20\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"89c87a53-75dd-4f6b-aa52-c1de4d1d4ff0"}, "snpName": "Expr GADT's", "snpContent": "module Case0 =\n    type Expr =\n        | I of int\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n                \n    let rec eval (e: Expr) : int =   \n        match e with\n        | I   n      -> n\n        | Add (a, b) -> eval a + eval b\n        | Mul (a, b) -> eval a * eval b\n\n    let ( + ) a b = Add(a, b)\n    let ( * ) a b = Mul(a, b)\n\n    printfn \"Case0\"\n    (I 5 + I 1) * I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case1 =\n    type Expr =\n        | I of int\n        | B of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr        \n        \n    let rec eval (e: Expr) : int =   \n        match e with\n        | I   n      -> n\n        | B   b      -> if b then 1 else 0\n        | Add (a, b) -> eval a + eval b\n        | Mul (a, b) -> eval a * eval b\n        | Eq  (a, b) -> eval a = eval b |> B |> eval\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case1\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n        \nmodule Case2 =\n    type Expr =\n        | I of int\n        | B of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n        \n    let rec eval (e: Expr) : Choice<int, bool> option =   \n        match e with\n        | I    n                                       -> n               |> Choice1Of2 |> Some\n        | B    b                                       -> b               |> Choice2Of2 |> Some\n        | Add (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Mul (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Eq  (a, b)                                   -> eval a = eval b |> Choice2Of2 |> Some\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case2\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n    B true + I 5\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case3a =\n    type Expr =\n        | I   of int\n        | B   of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n    type ExprT<'T> = ExprT of Expr\n        \n    let Add (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Add(a, b) |> ExprT\n    let Mul (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Mul(a, b) |> ExprT\n    let Eq  (ExprT a: ExprT<_  >, ExprT b: ExprT<_  >) : ExprT<bool> = Eq (a, b) |> ExprT\n    let I n                                            : ExprT<int > = I n       |> ExprT\n    let B b                                            : ExprT<bool> = B b       |> ExprT\n\n    let rec eval (e: ExprT<'T>) : Choice<int, bool> option =   \n        match e with\n        | ExprT(I    n    )                            -> n                               |> Choice1Of2 |> Some\n        | ExprT(B    b    )                            -> b                               |> Choice2Of2 |> Some\n        | ExprT(Add (a, b)) ->             \n            match eval (ExprT a), eval (ExprT b) with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b                           |> Choice1Of2 |> Some\n            | _                                        ->                                                  None\n        | ExprT(Mul (a, b)) ->             \n            match eval (ExprT a), eval (ExprT b) with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b                           |> Choice1Of2 |> Some\n            | _                                        ->                                                  None\n        | ExprT(Eq  (a, b))                            -> eval (ExprT a) = eval (ExprT b) |> Choice2Of2 |> Some\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case3a\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| eval e\n\nmodule Case3b =\n    type Expr =\n        | I   of int\n        | B   of bool\n        | Add of Expr * Expr\n        | Mul of Expr * Expr\n        | Eq  of Expr * Expr\n    type ExprT<'T> = ExprT of Expr\n        \n    let Add (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Add(a, b) |> ExprT\n    let Mul (ExprT a: ExprT<int>, ExprT b: ExprT<int>) : ExprT<int > = Mul(a, b) |> ExprT\n    let Eq  (ExprT a: ExprT<_  >, ExprT b: ExprT<_  >) : ExprT<bool> = Eq (a, b) |> ExprT\n    let I n                                            : ExprT<int > = I n       |> ExprT\n    let B b                                            : ExprT<bool> = B b       |> ExprT\n    \n    type Eval() =     \n        static let rec eval e = \n            match e with\n            | ExprT(I    n    )                            -> n                               |> Choice1Of2 |> Some\n            | ExprT(B    b    )                            -> b                               |> Choice2Of2 |> Some\n            | ExprT(Add (a, b)) ->             \n                match eval (ExprT a), eval (ExprT b) with            \n                | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b                           |> Choice1Of2 |> Some\n                | _                                        ->                                                  None\n            | ExprT(Mul (a, b)) ->             \n                match eval (ExprT a), eval (ExprT b) with            \n                | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b                           |> Choice1Of2 |> Some\n                | _                                        ->                                                  None\n            | ExprT(Eq  (a, b))                            -> eval (ExprT a) = eval (ExprT b) |> Choice2Of2 |> Some\n        static let fail t = failwith <| sprintf \"Result is not of type <%s>\" t\n    with\n      static member Eval (e:ExprT<int >) =\n        match eval e with\n        | Some (Choice1Of2 a) -> a\n        | _                   -> fail \"int\"\n      static member Eval (e:ExprT<bool>) =\n        match eval e with\n        | Some (Choice2Of2 a) -> a\n        | _                   -> fail \"bool\"\n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = Eq (a, b)\n\n    printfn \"Case3b\"\n    I 5 + I 1 == I 7\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n\nmodule Case3c =\n    type I      = I   of int\n    and  B      = B   of bool\n    and  Add    = Add of Expr<int > * Expr<int >\n    and  Mul    = Mul of Expr<int > * Expr<int >\n    and  EqI    = EqI of Expr<int > * Expr<int >\n    and  EqB    = EqB of Expr<bool> * Expr<bool>\n    and  Expr<'T> =\n        | TI   of I   \n        | TB   of B   \n        | TAdd of Add \n        | TMul of Mul \n        | TEqI of EqI  \n        | TEqB of EqB \n        \n    let Add (a: Expr<int>, b: Expr<int>) : Expr<int > = Add(a, b) |> TAdd\n    let Mul (a: Expr<int>, b: Expr<int>) : Expr<int > = Mul(a, b) |> TMul\n    let EqI (a: Expr<_  >, b: Expr<_  >) : Expr<bool> = EqI(a, b) |> TEqI\n    let EqB (a: Expr<_  >, b: Expr<_  >) : Expr<bool> = EqB(a, b) |> TEqB\n    let I n                              : Expr<int > = I   n     |> TI\n    let B b                              : Expr<bool> = B   b     |> TB\n\n    type Eval() =     \n        static let fail t = failwith <| sprintf \"Result is not of type <%s>\" t\n    with\n      static member Eval (I   n                              ) : int  = n \n      static member Eval (B   b                              ) : bool = b\n      static member Eval (Add(a : Expr<int >, b : Expr<int >)) : int  = Eval.Eval a + Eval.Eval b\n      static member Eval (Mul(a : Expr<int >, b : Expr<int >)) : int  = Eval.Eval a * Eval.Eval b\n      static member Eval (EqI(a : Expr<int >, b : Expr<int >)) : bool = Eval.Eval a = Eval.Eval b\n      static member Eval (EqB(a : Expr<bool>, b : Expr<bool>)) : bool = Eval.Eval a = Eval.Eval b\n      static member Eval (    e : Expr<int >                 ) : int  = \n          match e with\n          | TI   e -> Eval.Eval e   \n          | TAdd e -> Eval.Eval e\n          | TMul e -> Eval.Eval e\n          | _      -> fail \"int\"\n      static member Eval (    e : Expr<bool>                 ) : bool = \n          match e with\n          | TB   e -> Eval.Eval e\n          | TEqI e -> Eval.Eval e\n          | TEqB e -> Eval.Eval e\n          | _      -> fail \"bool\"   \n\n    let ( +  ) a b = Add(a, b)\n    let ( *  ) a b = Mul(a, b)\n    let ( == ) a b = EqI(a, b)\n    let ( =@ ) a b = EqB(a, b)\n\n    printfn \"Case3c\"\n    (I 5 + I 1) == I 7\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n    (I 5 == I 1) =@ B false\n    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n//    B true + I 5\n//    |> fun e -> printfn \"%A = %A\" e <| Eval.Eval e\n\n(*module Case4 =   \n    type Expr<'T> = \n        | I   of int\n        | B   of bool\n        | Add of Expr<'T> * Expr<'T>\n        | Mul of Expr<'T> * Expr<'T>\n        | Eq  of Expr<'T> * Expr<'T>                              // using the phantom type 'T fails for Eq\n        \n    let Add (a: Expr<int>, b: Expr<int>) : Expr<int > = Add(a, b)\n    let Mul (a: Expr<int>, b: Expr<int>) : Expr<int > = Mul(a, b)\n    let Eq  (a: Expr<'a >, b: Expr<'a >) : Expr<bool> = Eq (a, b) // because of this\n    let I n                              : Expr<int > = I n   \n    let B b                              : Expr<bool> = B b   \n\n    let rec eval (e: Expr<'T>) : Choice<int, bool> option =   \n        match e with\n        | I    n                                       -> n               |> Choice1Of2 |> Some\n        | B    b                                       -> b               |> Choice2Of2 |> Some\n        | Add (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a + b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Mul (a, b) ->             \n            match eval a, eval b with            \n            | Some (Choice1Of2 a), Some (Choice1Of2 b) -> a * b           |> Choice1Of2 |> Some\n            | _                                        ->                                  None\n        | Eq  (a, b)                                   -> eval a = eval b |> Choice2Of2 |> Some\n\n    printfn \"Case4\"\n    Eq(Add(I 5, I 1), I 7)\n    |> fun e -> printfn \"%A = %A\" e <| eval e\n\n //   Add(B true, I 5)\n //   |> fun e -> printfn \"%A = %A\" e <| eval e\n\n*)\n\nprintfn \"Case SafeList\"\n\ntype EmptyList    = EmptyList\ntype NonEmptyList = NonEmptyList\ntype BaseList<'T> =\n    | Nil\n    | Cons of 'T * BaseList<'T>\ntype SafeList<'T, 'E> = SafeList of BaseList<'T>\n\nlet Nil                 : SafeList<_, EmptyList   > = SafeList    Nil\nlet Cons(e, SafeList l) : SafeList<_, NonEmptyList> = SafeList <| Cons(e, l)\n\nlet SafeHead(a: SafeList<_, NonEmptyList>) = match a with | SafeList (Cons (e, l)) -> e | _ -> failwith \"not possible\"\n\nCons(\"Hello\", Nil)\n|> fun e -> printfn \"SafeHead of %A = %A\" e <| SafeHead e \n\n//Nil\n//|> fun e -> printfn \"SafeHead of %A = %A\" e <| SafeHead e \n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b1a33b33-1d1d-4c5f-be94-988886b74c31"}, "snpName": "Fable inline Errors", "snpContent": "let counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()\n      }\n      \n    member        this.Method  (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.Method  ()       = { this with a = this.a * 10 }\n    member inline this.MethodI ()       = { this with a = this.a * 10 }\n\nType.New(5).Method(false).Method(true).Method()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c8d8aeb9-a872-45dc-b240-b7846e076d1a"}, "snpName": "", "snpContent": "System.IO.Path.GetRandomFileName()\n|> printfn \"%s\"", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"caa2898b-b46a-4e93-99ba-63cc8e5726d0"}, "snpName": "Check All F# Code 1", "snpContent": "#define JUSTCHECKING", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [{"SnippetId" :"08e9600a-804b-4aba-a262-85f22e0cc8de"}, {"SnippetId" :"16f618b6-0483-44dc-9c54-550f4f5b725d"}, {"SnippetId" :"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"}, {"SnippetId" :"210f90c1-81fc-43bd-b838-6a5dc2a8e46b"}, {"SnippetId" :"3d704638-8ba4-4bc8-b810-29e023a222fc"}, {"SnippetId" :"3def8b16-6c90-40f4-a78e-b2b293df699a"}, {"SnippetId" :"46450fbf-b073-4a66-ab42-587be0afc45f"}, {"SnippetId" :"56e5bc09-e528-49cc-9d42-6359b32a0cc9"}, {"SnippetId" :"5df15cf1-361e-4d57-a565-683ab0b72082"}, {"SnippetId" :"89c87a53-75dd-4f6b-aa52-c1de4d1d4ff0"}, {"SnippetId" :"8ee6b535-3615-4066-8917-9125cf8a1f20"}, {"SnippetId" :"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"}, {"SnippetId" :"b1a33b33-1d1d-4c5f-be94-988886b74c31"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}, {"SnippetId" :"b4a9f681-f5c2-443b-8f6e-146a6d6cd093"}, {"SnippetId" :"b5ce4e03-57ad-4ec2-a8f2-445831815f01"}, {"SnippetId" :"bd716e89-0546-4d6b-8964-26473ddcd121"}, {"SnippetId" :"c7e56d1e-aea8-483a-a99a-23b7e056de0d"}, {"SnippetId" :"c8d8aeb9-a872-45dc-b240-b7846e076d1a"}, {"SnippetId" :"dc44bbe1-876a-4910-a39a-5d74bc2304ee"}, {"SnippetId" :"dfc80990-ada5-4f24-8192-85bfe3b115a5"}, {"SnippetId" :"f850ce38-14e5-47a4-81ed-df02d7979f8e"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d54a55c5-1462-4983-a966-4feb4cfccb2a"}, "snpName": "Test FSharp.Compiler.Service", "snpContent": "let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \n#if HELLO\nlet checker = FSharpChecker.Create()\n#endif\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#define FSHARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#if FHSARP40\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n#else\n#r @\"FSharp.Compiler.Service.dll\"\n#endif\n\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\nlet checker = FSharpChecker.Create()\n\nlet file       = @\"Compiled\\Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 2\nlet lineStr    = inputLines.[line - 1]\nasync {\n    #if FSHARP40 \n    let! projOptions0    = checker.GetProjectOptionsFromScript(file, input)\n    #else\n    let! projOptions02, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"ERRORS: %A\" errors\n    #endif\n    let  projOptions     = { projOptions0 with OtherOptions = Array.append projOptions0.OtherOptions [| \"-d:HELLO\" |]}\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, \"////-d:HELLO\\nlet a = 1\", projOptions)\n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    printfn \":%s\" lineStr\n    printfn \"PROJECT: %A\" projOptions\n    //parseResults.PrintDump()\n    let res = checker.TryGetRecentCheckResultsForFile(file, projOptions)\n    printfn \"RES: %A\" res\n    match res with\n    | None  -> ()\n    | Some  (_, res,_) ->\n        let! tip2 = res.GetToolTipTextAlternate(2, 5, \"let a = 1\", [\"a\"], FSharpTokenTag.IDENT) \n        printfn \"TIP2: %A\" tip2\n} |> Async.RunSynchronously", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"11e21cf6-f497-4f73-a287-a2d5ff5b0445"}, "snpName": "Check All F# Code 2", "snpContent": "// separate check for FSAutoComplete because it uses a different version of Compiler.Services.dll than Compile\n#define JUSTCHECKING", "snpParentIdO": {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, "snpPredIds": [{"SnippetId" :"971e9b81-6e5d-4f11-a604-f87504d7c950"}, {"SnippetId" :"d54a55c5-1462-4983-a966-4feb4cfccb2a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpName": "Snippets2", "snpContent": "module Snippets2 =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8a27056f-c4c9-41a3-bfbb-7869240575ab"}, "snpName": "FSLab (not working)", "snpContent": "#nowarn \"211\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages\\FsLab\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.1.2.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.RPlugin/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Deedle.RPlugin.1.2.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Charting/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Charting.0.90.14/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Data/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/FSharp.Data.2.3.0/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Foogle.Charts/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Foogle.Charts.0.0.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.3.11.1/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.FSharp/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/MathNet.Numerics.FSharp.3.11.1/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/DynamicInterop/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/DynamicInterop.0.7.4/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.1.6.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.FSharp/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/R.NET.Community.FSharp.1.6.5/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/RProvider/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/RProvider.1.1.20/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.Plotly/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.Plotly.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.Deedle/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/XPlot.GoogleCharts.Deedle.1.3.1/lib/net45\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Google.DataTable.Net.Wrapper/lib\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Google.DataTable.Net.Wrapper.3.1.2.0/lib\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Newtonsoft.Json/lib/net40\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\CipherSpace\\FSLab\\packages/Newtonsoft.Json.8.0.3/lib/net40\"\n#r \"Deedle.dll\"\n#r \"Deedle.RProvider.Plugin.dll\"\n#r \"System.Windows.Forms.DataVisualization.dll\"\n#r \"FSharp.Charting.dll\"\n#r \"FSharp.Data.dll\"\n#r \"Foogle.Charts.dll\"\n#r \"MathNet.Numerics.dll\"\n#r \"MathNet.Numerics.FSharp.dll\"\n#r \"DynamicInterop.dll\"\n#r \"RDotNet.dll\"\n#r \"RDotNet.NativeLibrary.dll\"\n#r \"RDotNet.FSharp.dll\"\n#r \"RProvider.Runtime.dll\"\n#r \"RProvider.dll\"\n#r \"XPlot.Plotly.dll\"\n#r \"XPlot.GoogleCharts.dll\"\n#r \"XPlot.GoogleCharts.Deedle.dll\"\n#r \"Google.DataTable.Net.Wrapper.dll\"\n#r \"Newtonsoft.Json.dll\"\n//namespace FsLab\n\n#if NO_FSI_ADDPRINTER\n#else\nmodule FsiAutoShow =\n  open FSharp.Charting\n  open RProvider\n\n  fsi.AddPrinter(fun (printer:Deedle.Internal.IFsiFormattable) ->\n    \"\\n\" + (printer.Format()))\n  fsi.AddPrinter(fun (ch:FSharp.Charting.ChartTypes.GenericChart) ->\n    ch.ShowChart() |> ignore; \"(Chart)\")\n  fsi.AddPrinter(fun (synexpr:RDotNet.SymbolicExpression) ->\n    synexpr.Print())\n\n  open System.IO\n  open Foogle\n  open Foogle.SimpleHttp\n\n  let server = ref None\n  let tempDir = Path.GetTempFileName()\n  let pid = System.Diagnostics.Process.GetCurrentProcess().Id\n  let counter = ref 1\n\n  do File.Delete(tempDir)\n  do Directory.CreateDirectory(tempDir) |> ignore\n\n  let displayHtml html = \n    match server.Value with\n    | None -> server := Some (HttpServer.Start(\"http://localhost:8084/\", tempDir))\n    | _ -> ()\n    let file = sprintf \"show_%d_%d.html\" pid counter.Value\n    File.WriteAllText(Path.Combine(tempDir, file), html)\n    System.Diagnostics.Process.Start(\"http://localhost:8084/\" + file) |> ignore\n    incr counter\n      \n  fsi.AddPrinter(fun (chart:FoogleChart) ->\n    chart\n    |> Foogle.Formatting.Google.CreateGoogleChart\n    |> Foogle.Formatting.Google.GoogleChartHtml\n    |> displayHtml \n    \"(Foogle Chart)\" )\n\n  fsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n    let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n    ch.Html |> displayHtml\n    \"(Google Chart)\")\n\n  fsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n    \"\"\"<!DOCTYPE html>\n    <html>\n    <head>\n        <title>Plotly Chart</title>\n        <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n    </head>\n    <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml\n    \"(Plotly Chart)\" )\n#endif\n\n//namespace FSharp.Charting\nopen FSharp.Charting\nopen Deedle\n\n[<AutoOpen>]\nmodule FsLabExtensions =\n  type FSharp.Charting.Chart with\n    static member Line(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Line(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Column(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Column(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Pie(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Pie(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Area(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Area(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n    static member Bar(data:Series<'K, 'V>, ?Name, ?Title, ?Labels, ?Color, ?XTitle, ?YTitle) =\n      Chart.Bar(Series.observations data, ?Name=Name, ?Title=Title, ?Labels=Labels, ?Color=Color, ?XTitle=XTitle, ?YTitle=YTitle)\n\n//namespace Foogle\nopen Deedle\n\n[<AutoOpen>]\nmodule FoogleExtensions =\n\n  type Foogle.Chart with\n    static member PieChart(frame:Frame<_, _>, column, ?Label, ?PieHole) =\n      Foogle.Chart.PieChart\n        ( frame.GetColumn<float>(column) |> Series.observations,\n          ?Label=Label, ?PieHole=PieHole)\n    static member GeoChart(frame:Frame<_, _>, column, ?Label, ?Region, ?DisplayMode) =\n      Foogle.Chart.GeoChart\n        ( frame.GetColumn<float>(column) |> Series.observations,\n          ?Label=Label, ?Region=Region, ?DisplayMode=DisplayMode)\n\n//namespace MathNet.Numerics.LinearAlgebra\nopen MathNet.Numerics.LinearAlgebra\nopen Deedle\n\nmodule Matrix =\n  let inline toFrame matrix = matrix |> Matrix.toArray2 |> Frame.ofArray2D\nmodule DenseMatrix =\n  let inline ofFrame frame = frame |> Frame.toArray2D |> DenseMatrix.ofArray2\nmodule SparseMatrix =\n  let inline ofFrame frame = frame |> Frame.toArray2D |> SparseMatrix.ofArray2\nmodule Vector =\n  let inline toSeries vector = vector |> Vector.toSeq |> Series.ofValues\nmodule DenseVector =\n  let inline ofSeries series = series |> Series.values |> Seq.map (float) |> DenseVector.ofSeq\nmodule SparseVector =\n  let inline ofSeries series = series |> Series.values |> Seq.map (float) |> SparseVector.ofSeq\n\n\n//namespace Deedle\nopen Deedle\nopen MathNet.Numerics.LinearAlgebra\n\nmodule Frame =\n  let inline ofMatrix matrix = matrix |> Matrix.toArray2 |> Frame.ofArray2D\n  let inline toMatrix frame = frame |> Frame.toArray2D |> DenseMatrix.ofArray2\n\n  let ofCsvRows (data:FSharp.Data.Runtime.CsvFile<'T>) =\n    match data.Headers with\n    | None -> Frame.ofRecords data.Rows\n    | Some names -> Frame.ofRecords data.Rows |> Frame.indexColsWith names\n\nmodule Series =\n  let inline ofVector vector = vector |> Vector.toSeq |> Series.ofValues\n  let inline toVector series = series |> Series.values |> Seq.map (float) |> DenseVector.ofSeq\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2cb87fcf-2fb6-487b-a9ee-aa46802f7d64"}, "snpName": "WorldBankProvider", "snpContent": "#r \"../packages/FSharp.Data/lib/net40/FSharp.Data.dll\"\n#r \"../packages/XPlot.Plotly/lib/net45/XPlot.Plotly.dll\"\n\nopen FSharp.Data\nopen XPlot.Plotly\n \nlet wb = WorldBankData.GetDataContext()\n\nlet cs = wb.Countries\n\n//wb.Countries.``European Union``.Indicators.``Women who believe a husband is justified in beating his wife when she argues with him (%)``.Years\ncs\n|> Seq.choose(fun c -> \n    c.Indicators.``Women who believe a husband is justified in beating his wife when she argues with him (%)``.Values \n    |> Seq.tryLast\n    |> Option.map (fun v -> c, v)\n   )\n|> Seq.sortByDescending snd\n|> Seq.map (sprintf \"%A\")\n|> String.concat \"\\n\"\n|> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5e163957-a783-4e82-9bb8-5d116d8c653e"}, "snpName": "", "snpContent": "type Person = { name: string; age: int }\ntype DB = { people: Person list }\n//let db' : DB = database(\"People\")\n\nlet printout v =\n    v\n    |> String.concat \"\\n\"\n    |> printfn \"%s\"\n\nmodule naive =\n\n    let db' =\n        { people = \n            [\n               { name = \"Alex\"; age = 40 }\n               { name = \"Bert\"; age = 30 }\n               { name = \"Cora\"; age = 35 }\n               { name = \"Drew\"; age = 60 }\n               { name = \"Edna\"; age = 25 }\n               { name = \"Fred\"; age = 70 }\n            ]}\n    \n    let youths': Person list =\n        [\n            for u in db'.people do\n              for v in db'.people do\n                if u.name = \"Alex\" && v.age < u.age then\n                  yield {name= v.name;  age = v.age}  \n        ]                \n    \n    youths'\n    |> Seq.map (fun p -> sprintf \"%s %d\" p.name p.age )\n    |> printout\n    \nmodule quotations =\n    open Microsoft.FSharp.Quotations\n\n    let db =\n        <@\n            { people = \n                [\n                   { name = \"Alex\"; age = 40 }\n                   { name = \"Bert\"; age = 30 }\n                   { name = \"Cora\"; age = 35 }\n                   { name = \"Drew\"; age = 60 }\n                   { name = \"Edna\"; age = 25 }\n                   { name = \"Fred\"; age = 70 }\n                ]} \n        @>\n    \n    let youths: Expr<Person list> =\n       <@ [\n            for u in (%db).people do\n              for v in (%db).people do\n                if u.name = \"Alex\" && v.age < u.age then\n                  yield {name= v.name;  age = v.age} \n        ] @>               \n\n    let run (query: Expr<_ list>) =\n        // does something\n        [ sprintf \"%A\" query ]\n\n    run youths\n    |> printout\n    \n    let range = \n        <@ fun(a,b) ->\n          [\n            for w in (%db).people do\n                if a <= w.age && w.age < b then\n                    yield w.name\n          ]\n        @>\n        \n    run <@ (%range)(30, 40) @>\n    |> printout\n    \n    let satisfies = \n        <@ fun p ->\n          [\n            for w in (%db).people do\n                if p w.age then\n                    yield w.name\n          ]\n        @>\n        \n    run <@ (%satisfies)(fun x -> 30 <= x && x < 40) @>\n    |> printout\n    \n    let inline lift x : Expr<_> = <@ x @>\n    \n    type Predicate =\n        | Above of int\n        | Below of int\n        | And of Predicate * Predicate\n        \n    let rec P(t: Predicate) : Expr<int -> bool> =\n        match t with \n        | Above a   -> <@ fun x -> (%lift a)  <= x          @>\n        | Below a   -> <@ fun x -> x          <  (%lift a)  @>\n        | And(u, v) -> <@ fun x -> ((%P u) x) && ((%P v) x) @>\n        \n    run <@ (%satisfies) (%P(And(Above 30, Below 40))) @>\n    |> printout\n    \n    let rec P'(t: Predicate)(x:Expr<int>) : Expr<bool> =\n        match t with \n        | Above a   -> <@ (%lift a) <= (%x)      @>\n        | Below a   -> <@ (%x)      <  (%lift a) @>\n        | And(u, v) -> <@ (%P' u x) && (%P' v x) @>\n        \n    run <@ (%satisfies) (%P(And(Above 30, Below 40))) @>\n    |> printout\n    \n                ", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9ef41d54-1c84-4aa6-915d-864ce05c289f"}, "snpName": "Testing op precedence associativity", "snpContent": "type N = N of string * N list\nwith member this.Add c = match this with N(n, l) -> N(n, l @ [c])\n\nlet rec toStrL lvl (N(n, l)) =\n    (sprintf \"%s%s\" \n        <| String.replicate lvl \"  \" \n        <| n) :: [ yield! l |> Seq.map (toStrL (lvl + 1)) ]\n    |> String.concat \"\\n\"\n\nlet toStr n = toStrL 0 n\n\nlet inline N n l = N(n, l)\nlet inline a ch  = N \"a\" ch\nlet inline b ch  = N \"b\" ch\nlet inline c ch  = N \"c\" ch\nlet inline d ch  = N \"d\" ch\nlet inline e ch  = N \"e\" ch\nlet inline f ch  = N \"f\" ch\nlet inline g ch  = N \"g\" ch\n\nmodule Try1 =\n\n    //let inline ( -- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( |- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( == ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( ** ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    let inline ( -+ ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( -= ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( *+ ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( *= ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( *- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    let inline ( -  ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    let inline ( +  ) (f:N list -> N) (r:N list -> N) : (N list -> N) = fun l -> f [ r l ]\n    let inline ( +- ) (f:N list -> N) (chn) : (N list -> N) = fun l -> f (chn :: l)\n    \n    //let inline ( -- ) (f:N list -> N) (n:int) = \n    \n    let def =\n        a\n        + b\n          + c \n            - d []\n        +-e []\n        - f []\n    \n    \n    def []\n    |> toStr\n    |> printfn \"try 1 : \\n%s\"\n    \n\nmodule Try2 =\n    let inline ( -  ) (ps:N list) (chn) : N list = \n        match ps with \n        | h :: tail -> h.Add chn :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:N list) (r:N list -> N) : (N list) = r [] ::ps\n    \n    let root (r:N list -> N)                     = [ r [] ]\n    let inline ( *  ) (r:N list -> N) : (N list) = [ r [] ]\n    let out (ps:N list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.Add h :: tail\n\n    let inline ( -<<- ) (ps:N list) (_) : N list = out ps\n    let inline ( ---- ) (ps:N list) (_) : N list = out ps\n\n    let x = 0\n\n    let rec finish (ps:N list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finish <| out ps        \n\n    let def =\n        root a\n        + b\n          + c \n            - d []\n          ----x\n        ----x\n        - e []\n        - f []                 \n\n    finish def\n    |> Option.map toStr\n    |> Option.iter ( printfn \"try 2 : \\n%s\")\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"63b982fe-0a84-47b1-bc43-db48033de3f3"}, "snpName": "Quotations Transformation", "snpContent": "open Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.DerivedPatterns\nopen Microsoft.FSharp.Quotations.ExprShape\n\nlet rec evilTransform quotation =\n    let minus l r = <@@ %%l - %%r @@>\n    match quotation with\n    | SpecificCall <@ (+) @> (expoO, types, [ l ; r ] ) -> minus (evilTransform l) (evilTransform r)\n    | ShapeVar                                v         -> Expr.Var v\n    | ShapeLambda                            (v, expr ) -> Expr.Lambda (v,evilTransform expr)\n    | ShapeCombination                       (o, exprs) -> RebuildShapeCombination (o, List.map evilTransform exprs)\n\n\n#r \"../packages/FSharp.Quotations.Evaluator/lib/net40/FSharp.Quotations.Evaluator.dll\"\nopen FSharp.Quotations.Evaluator\n\n\nlet mult a b = a * b\n\nlet a = 2\nlet b = 3\nlet before = <@ 1 + (mult a 3) + 5 @>.Substitute (function | v -> printfn \"Var %A\" v; Some <@@ b @@> )\n\nbefore |> printfn \"before: %A\"\n\nlet call p = \n    let x = evilTransform p \n    x.EvaluateUntyped() \n\nlet doIt = <@ call before @>\n\nprintfn \"before %A\" <| before.EvaluateUntyped()\nprintfn \"doIt   %A\" <| doIt  .EvaluateUntyped()\n\ndoIt.ToLinqExpressionUntyped().Reduce().ToString()\n|> printfn \"%A\"", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"68320a0c-b1b1-4812-bac1-f4ef8a6fe0d3"}, "snpName": "Test EvalFsiExe", "snpContent": "open Useful\nopen FsEvaluator.Evaluator\n\nevalFsiExe\n  \"\"\"\nprintfn \"Hello\"\n\"\"\"\n  false\n|> Wrap.runSynchronouslyS false\n|> printfn \"%s\"\n\n\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [{"SnippetId" :"82c8fbfd-6b85-4b5c-8bd0-81bcd8de1e58"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"df325114-ae81-4bd5-bdeb-617e77b19352"}, "snpName": "Alea Dimension", "snpContent": "open Useful\n\nlet path = @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Hotel Demo\\Modelo\"\n\nlet processDimension dim =\n    \n    let input  = System.IO.File.ReadAllLines (sprintf @\"%s\\%s.Dim\" path dim)\n\n    let columns =\n        input\n        |> Seq.filter ((<>) \"\")\n        |> Seq.map (fun s -> s.Split '\\t')\n        |> Seq.filter (Array.length >> (__ (>=) 2))\n        |> Seq.map (fun l -> l.[0].Trim(), l.[1].Trim())\n    \n    let elements =\n        columns\n        |> Seq.map snd\n        |> Seq.distinct\n    \n    let pairs =\n        columns\n        |> Seq.mapFold (fun p (l,r) -> if l = \"\" then (Some (p,r), p) else (None, r)) \"\"\n        |> fst\n        |> Seq.choose id\n    \n    let withParents =\n        pairs\n        |> Seq.map snd\n        |> Seq.distinct\n    \n    let parents =\n        elements\n        |> Seq.filter (fun e -> withParents |> Seq.exists ((=) e) |> not)\n    \n    let addChildrens x =\n        x \n        |> Seq.collect (fun e ->\n            pairs \n            |> Seq.filter (fst >> ((=) (e |> Array.last)))\n            |> Seq.map (fun (_, ch) ->  e |> Array.append <| [| ch |])\n            |> fun r -> if r |> Seq.isEmpty then e |> Array.append <| [| \"\" |] |> Seq.singleton else r\n        )\n        \n    let rec addChildrensRec x =\n        let r = addChildrens x\n        if Seq.length r = Seq.length x then x else addChildrensRec r\n    \n    parents\n    |> Seq.map Array.singleton\n    |> addChildrensRec\n    |> Seq.map (String.concat \"\\t\")\n    |> fun txt -> System.IO.File.WriteAllLines(sprintf @\"%s\\output\\%s.Flat\" path dim, txt)\n\nprocessDimension \"BEVERAGE\"\nprocessDimension \"BSOURCE\"\nprocessDimension \"DATATYPE\"\nprocessDimension \"DAYMONTH\"\nprocessDimension \"DAYWEEK\"\nprocessDimension \"DCOMP\"\nprocessDimension \"DMEAS_MA\"\nprocessDimension \"DTIME\"\nprocessDimension \"DUITEMS1\"\nprocessDimension \"HOLIDAY\"\nprocessDimension \"MEAL\"\nprocessDimension \"OUTLET\"\nprocessDimension \"PERIOD\"\nprocessDimension \"PERIODM\"\nprocessDimension \"POSITION\"\nprocessDimension \"ROOM\"\nprocessDimension \"SEASON\"\nprocessDimension \"TCALC\"\nprocessDimension \"TCALC2\"\nprocessDimension \"TDAY\"\nprocessDimension \"TLAUNDRY\"\nprocessDimension \"TPHONE\"\n\nSystem.IO.Directory.GetFiles path\n|> Seq.filter (fun f -> f.EndsWith \".Dim\")\n|> Seq.map  (fun f -> f.[path.Length + 1 .. f.Length - 5])\n|> Seq.iter (printfn \"processDimension %A\")\n\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [{"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"079efcaa-4544-4ac8-ad7c-0c2b76dbc93d"}, "snpName": "toRomanNumerals", "snpContent": "let getAllIs n = \"I\" |> String.replicate n\n\nlet rep_IIIII_V  (r:string) = r.Replace(\"IIIII\", \"V\")\nlet rep_VV_X     (r:string) = r.Replace(\"VV\"   , \"X\")\nlet rep_XXXXX_L  (r:string) = r.Replace(\"XXXXX\", \"L\")\nlet rep_LL_C     (r:string) = r.Replace(\"LL\"   , \"C\")\n\nlet rep_LXXXX_XC (r:string) = r.Replace(\"LXXXX\", \"XC\")\nlet rep_XXXX_XL  (r:string) = r.Replace(\"XXXX\" , \"XL\")\nlet rep_VIIII_IX (r:string) = r.Replace(\"VIIII\", \"IX\")\nlet rep_IIII_IV  (r:string) = r.Replace(\"IIII\" , \"IV\")\n\nlet toRomanNumerals n =\n    n\n    |> getAllIs\n    |> rep_IIIII_V    \n    |> rep_VV_X\n    |> rep_XXXXX_L\n    |> rep_LL_C\n    |> rep_LXXXX_XC\n    |> rep_XXXX_XL\n    |> rep_VIIII_IX\n    |> rep_IIII_IV\n\nlet replace (old:string) newv (s:string) = s.Replace(old, newv)\nlet printlist l = l |> Seq.iter (printfn \"%A\")\n\nlet numerals = [\n    \"I\",    1\n    \"V\",    5\n    \"X\",   10\n    \"L\",   50\n    \"C\",  100\n    \"D\",  500\n    \"M\", 1000\n]\n\nlet firstPass =\n    numerals\n    |> List.pairwise\n    |> List.map (fun ((ll, lv),(hl, hv)) -> replace (String.replicate (hv / lv) ll) hl)\n\nprintlist numerals\n\nlet secondPass =\n    numerals\n    |> List.pairwise\n    |> List.pairwise\n    |> List.map (fun ((a,b),(c,d)) -> a,b,d)\n    |> List.filter (fun ((_,v),_,_) -> (string v).[0] = '1')\n    |> List.map(fun ((ll,lv),(ml,mv),(hl,hv)) ->\n        replace (ml + String.replicate 4 ll) (ll + hl)\n        >> replace (String.replicate 4 ll) (ll + ml)\n    )\n\nlet toRomanNumerals2 n =\n    let allIs = getAllIs n\n    firstPass @ secondPass\n    |> List.fold (fun s f -> f s) allIs\n\nfor i = 1 to 2000 do\n    toRomanNumerals2 i\n    |> printfn \"%d = %s\" i\n    |> ignore\n\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9407b622-c7ae-4f43-872b-fc65d331df13"}, "snpName": "FizzBuzz", "snpContent": "type CarbonatedNumbers =\n     | Carbonated   of string\n     | Uncarbonated of int\n     \nlet carbonate div name n =\n    if n % div = 0\n    then Carbonated   name\n    else Uncarbonated n\n\nlet print = printfn \"%A\"    \n\n10 |> carbonate 3 \"Fizz\" |> print\n12 |> carbonate 3 \"Fizz\" |> print\n15 |> carbonate 5 \"Buzz\" |> print\n\nlet result n = Uncarbonated n\nlet bind f cn =\n    match cn with\n    | Carbonated _   -> cn\n    | Uncarbonated n -> f n\n    \nlet FizzBuzz n =\n    n\n    |>       carbonate 15 \"FizzBuzz\"\n    |> bind (carbonate  3 \"Fizz\")\n    |> bind (carbonate  5 \"Buzz\")\n\nlet toText cn =\n    match cn with\n    | Carbonated   v -> v\n    | Uncarbonated n -> string n\n\nfor i = 1 to 50 do\n    printfn \"%d => %s\" i (FizzBuzz i |> toText)", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"36960fad-ce00-4882-866b-9c02402603b6"}, "snpName": "Linq", "snpContent": "\nopen System.Linq\nopen System.Linq.Expressions\n\nlet words = \"the quick brown fox jumps over the lazy dog\".Split ' '\n\nwords\n    .Select(  fun w -> w.ToUpper())\n    .GroupBy( fun w -> w.Length)\n    .Select(  fun g -> g.Key, g)\n    .OrderBy( fun t -> fst t)\n|> Seq.iter (printfn \"%A\")\n\nquery {\n    for w in words do\n    groupValBy (w.ToUpper()) w.Length into g\n    sortBy g.Key\n    select (g.Key, g)\n}\n|> Seq.iter   (printfn \"%A\")\n\nwords\n|> Seq.map    (fun w -> w.ToUpper())\n|> Seq.groupBy(fun w -> w.Length   )\n|> Seq.sortBy  fst\n|> Seq.iter   (printfn \"%A\")\n\nwords\n    .GroupBy((fun w -> w.Length), fun w -> w.ToUpper())\n    .Select(  fun g -> g.Key, g)\n    .OrderBy( fun t -> fst t)\n|> Seq.iter (printfn \"%A\")\n\nquery {\n    for w in words do\n    groupValBy (w.ToUpper()) w.Length into g\n    sortBy g.Key\n    select (g.Key, g)\n}\n|> Seq.iter   (printfn \"%A\")\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1609359e-513a-4184-b5dc-d5049574891f"}, "snpName": "JsonSD request", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\n#r @\"..\\packages\\NewtonSoft.JSon\\lib\\net45\\NewtonSoft.JSon.dll\"\n\nopen System.Net\nopen System.Text\nopen System.IO\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\nopen Newtonsoft.Json\n\nmodule JsonSD =\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    let value = {\n        FileName  = \"hello.fsx\"\n        IsAsync   = true\n        Lines     = [| \"line1\" ; \"line2\" ; \"line3\" |]\n        Version   = 8\n    }\n    let json = JsonConvert.SerializeObject value\n    let des  = JsonConvert.DeserializeObject json \n    \n    let HttpRequestCall (url:string) (data:string) =\n        async {\n            //printfn \"RpcCall %s\" (extract 100 data)\n            let req = WebRequest.Create(url) :?> HttpWebRequest \n            req.Timeout         <- 300_000\n            req.ProtocolVersion <- HttpVersion.Version10\n            req.Method          <- \"POST\"\n            req.ContentType     <- \"application/json\"\n            let postBytes = Encoding.ASCII.GetBytes(data)\n            //printfn \"<---\\n%s\\n\" data\n            req.ContentLength <- int64 postBytes.Length\n            let reqStream = req.GetRequestStream() \n            reqStream.Write(postBytes, 0, postBytes.Length);\n            reqStream.Close()\n            \n            // Obtain response and download the resulting page \n            // (The sample contains the first & last name from POST data)\n            use resp   = req.GetResponse() \n            use stream = resp.GetResponseStream() \n            use reader = new StreamReader(stream)\n            let msg    = reader.ReadToEnd()\n            let jsonV  = JsonValue.Parse msg\n            return       jsonV\n        }\n        \n    printfn \"%A\" value\n    printfn \"%s\" json                 \n    printfn \"%A\" des \n    printfn \"calling ...\"\n    \n    async { \n        let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\"  json \n        //let! r = HttpRequestCall \"http://localhost:9001/parse\" json \n        printfn \"result = %A\" r\n    } |> Async.Start\n\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"eff9765f-ca6a-4921-a687-f10c8831409b"}, "snpName": "words", "snpContent": "let words0 = \"able\nabove\nacross\nadd\nagainst\nago\nalmost\namong\nanimal\nanswer\nbecame\nbecome\nbegan\nbehind\nbeing\nbetter\nblack\nbest\nbody\nbook\nboy\nbrought\ncall\ncannot\ncar\ncertain\nchange\nchildren\ncity\nclose\ncold\ncountry\ncourse\ncut\ndidn't\ndog\ndone\ndoor\ndraw\nduring\nearly\nearth\neat\nenough\never\nexample\neye\nface\nfamily\nfar\nfather\nfeel\nfeet\nfire\nfish\nfive\nfood\nform\nfour\nfront\ngave\ngiven\ngot\ngreen\nground\ngroup\ngrow\nhalf\nhand\nhard\nheard\nhigh\nhimself\nhowever\nI'll\nI'm\nidea\nimportant\ninside\nJohn\nkeep\nkind\nknew\nknown\nland\nlater\nlearn\nlet\nletter\nlife\nlight\nlive\nliving\nmaking\nmean\nmeans\nmoney\nmorning\nmother\nmove\nMrs.\nnear\nnight\nnothing\nonce\nopen\norder\npage\npaper\nparts\nperhaps\npicture\nplay\npoint\nready\nred\nremember\nrest\nroom\nrun\nschool\nsea\nsecond\nseen\nsentence\nseveral\nshort\nshown\nsince\nsix\nslide\nsometime\nsoon\nspace\nStates\nstory\nsun\nsure\ntable\nthough\ntoday\ntold\ntook\ntop\ntoward\ntree\ntry\nturn\nUnited\nuntil\nupon\nusing\nusually\nwhite\nwhole\nwind\nwithout\nyes\nyet\nyoung\nabout\nafter\nagain\nair\nall\nalong\nalso\nan\nand\nanother\nany\nare\naround\nas\nat\naway\nback\nbe\nbecause\nbeen\nbefore\nbelow\nbetween\nboth\nbut\nby\ncame\ncan\ncome\ncould\nday\ndid\ndifferent\ndo\ndoes\ndon't\ndown\neach\nend\neven\nevery\nfew\nfind\nfirst\nfor\nfound\nfrom\nget\ngive\ngo\ngood\ngreat\nhad\nhas\nhave\nhe\nhelp\nher\nhere\nhim\nhis\nhome\nhouse\nhow\nI\nif\nin\ninto\nis\nit\nits\njust\nknow\nlarge\nlast\nleft\nlike\nline\nlittle\nlong\nlook\nmade\nmake\nman\nmany\nmay\nme\nmen\nmight\nmore\nmost\nMr.\nmust\nmy\nname\nnever\nnew\nnext\nno\nnot\nnow\nnumber\nof\noff\nold\non\none\nonly\nor\nother\nour\nout\nover\nown\npart\npeople\nplace\nput\nread\nright\nsaid\nsame\nsaw\nsay\nsee\nshe\nshould\nshow\nsmall\nso\nsome\nsomething\nsound\nstill\nsuch\ntake\ntell\nthan\nthat\nthe\nthem\nthen\nthere\nthese\nthey\nthing\nthink\nthis\nthose\nthought\nthree\nthrough\ntime\nto\ntogether\ntoo\ntwo\nunder\nup\nus\nuse\nvery\nwant\nwater\nway\nwe\nwell\nwent\nwere\nwhat\nwhen\nwhere\nwhich\nwhile\nwho\nwhy\nwill\nwith\nword\nwork\nworld\nwould\nwrite\nyear\nyou\nyour\nwas\nalready\nalthough\nam\nAmerica\nanything\narea\nball\nbeautiful\nbeginning\nBill\nbirds\nblue\nboat\nbottom\nbox\nbring\nbuild\nbuilding\nbuilt\ncan't\ncare\ncarefully\ncarried\ncarry\ncenter\ncheck\nclass\ncoming\ncommon\ncomplete\ndark\ndeep\ndistance\ndoing\ndry\neasy\neither\nelse\neveryone\neverything\nfact\nfall\nfast\nfelt\nfield\nfinally\nfine\nfloor\nfollow\nfoot\nfriend\nfull\ngame\ngetting\ngirl\nglass\ngoes\ngold\ngone\nhappened\nhaving\nheart\nheavy\nheld\nhold\nhorse\nhot\nhour\nhundred\nice\nIndian\ninstead\nitself\njob\nkept\nlanguage\nlay\nleast\nleave\nlet's\nlist\nlonger\nlow\nmain\nmap\nmatter\nmind\nMiss\nmoon\nmountain\nmoving\nmusic\nneeded\nnotice\noutside\npast\npattern\nperson\npiece\nplant\npoor\npossible\npower\nprobably\nproblem\nquestion\nquickly\nquite\nrain\nran\nreal\nriver\nroad\nrock\nround\nsat\nscientist\nshall\nship\nsimple\nsize\nsky\nslowly\nsnow\nsomeone\nspecial\nstand\nstart\nstate\nstay\nstood\nstop\nstopped\nstrong\nsuddenly\nsummer\nsurface\nsystem\ntaken\ntalk\ntall\nten\nthat's\nthemselves\nthird\ntiny\ntown\ntried\nvoice\nwalk\nwarm\nwatch\nweather\nwhether\nwide\nwild\nwinter\nwithin\nwriting\nwritten\"\n\nlet words = words0.Split '\\n' |> Array.map (fun s -> s.Trim())", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a5ef35a4-0915-4a27-8c0d-dec5bbb581b7"}, "snpName": "DrillThru data", "snpContent": "open System.IO\nopen System\nopen System.Text\nopen Useful\n\ntype System.Random with\n    /// Generates an infinite sequence of random numbers within the given range.\n    member this.GetValues(minValue, maxValue) = Seq.initInfinite (fun _ -> this.Next      (minValue, maxValue))\n    member this.GetValues(minValue, maxValue) = Seq.initInfinite (fun _ -> this.NextDouble() * (maxValue - minValue) + minValue)\n\nlet separateNumber (fs: string[]) = fs.[0..fs.Length - 2], double fs.[fs.Length - 1]\n\nlet random = System.Random()\n\nlet capitalize (s:string) = s.[0..0].ToUpper() + s.[1..]\n\nlet getRandomPhrase() = \n    let n  = random.Next(3, 6)\n    random.GetValues(0, words.Length - 1) |> Seq.take n |> Seq.map (swap Array.item words) |> Seq.map (fun w -> if random.Next(0,5) < 2 then capitalize w else w) |> String.concat \" \"\n\nlet costPeriodCol   = 0 \nlet costScenarioCol = 1\nlet costUnitCol     = 4\nlet costAcctCol     = 6\nlet balancingAcct   = \"ACC999999\"\n\nlet generateRecords (fs: string[], v:double) =\n    let n  = random.Next(1, 10)\n    let r  = v / double n * 1.5\n    let vs = random.GetValues(-r, r) |> Seq.take (n - 1) |> Seq.cache\n    let vf = v - Seq.sum vs\n    let pe = fs.[costPeriodCol]\n    let ds = random.GetValues(1, 28) |> Seq.take  n |> Seq.map (fun d -> sprintf \"%2s-%02d-%4s\" (pe.Substring(0, 2)) d (pe.Substring(3, 4)))\n    let dv = Seq.zip ds (Seq.append vs [vf])\n    dv \n    |> Seq.map (fun (d, v) -> \n        let jn = sprintf \"%s-%2s%2s%2d\" <| fs.[costUnitCol] <| pe.Substring(5, 2) <| pe.Substring(0, 2) <| random.Next(21, 49)\n        Array.collect id [| [| jn ; d ;  |] ; fs ; [| getRandomPhrase() |] |], v)\n\nlet processFile fn =\n\n    let input = \n        File.ReadAllLines(fn)\n        |> Seq.map     (fun s  -> s.Split '\\t'                   )\n        |> Seq.filter  (fun fs -> fs.[costScenarioCol] = \"Actual\")\n        |> Seq.map     separateNumber\n    //    |> Seq.take 1\n    \n    \n    let generated = input |> Seq.collect generateRecords |> Seq.cache\n    \n    let totalJournals =\n        generated\n        |> Seq.groupBy (fun (fs, v ) -> fs.[0])\n        |> Seq.map     (fun (jn, rs) -> \n            let v     = rs |> Seq.map snd |> Seq.sum\n            let d     = rs |> Seq.map fst |> Seq.map (Array.item 1) |> Seq.max\n            let fs, _ = rs |> Seq.head\n            fs.[1              ] <- d\n            fs.[costAcctCol + 2] <- balancingAcct\n            fs, -v\n        )\n    \n    let getRecord (fs: string [], v:double) =\n        seq [\n            yield! fs\n            yield  sprintf \"%f\" v\n        ] |> String.concat \"\\t\"\n    \n    let showRecords rs = \n        rs \n        |> Seq.truncate 20 \n        |> Seq.map  getRecord\n        |> Seq.iter (printfn \"%s\")\n    \n    let showTotal   rs = rs |> Seq.map snd |> Seq.sum |> printfn \"Total   %f\"\n    \n    //input         |> showRecords\n    //input         |> showTotal\n    generated     |> showRecords\n    //generated     |> showTotal\n    totalJournals |> showRecords\n    //totalJournals |> showTotal\n    \n    File.WriteAllLines( Path.GetFileNameWithoutExtension(fn) + \" gen.txt\"\n        , Seq.append generated totalJournals |> Seq.map getRecord)\n    \n       \nprocessFile @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Goodman\\COST.DATA.TXT\"", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [{"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"eff9765f-ca6a-4921-a687-f10c8831409b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"65ef495c-a73c-4ac4-84dc-1ecbfecd0b81"}, "snpName": "FsCheck", "snpContent": "#r \"..\\packages\\FsCheck\\lib\\net452\\FsCheck.dll\"\n\nopen FsCheck\nCheck.Verbose\n\nlet revRevIsOrig (xs:list<int>) = List.rev(List.rev xs) = xs\nCheck.Quick revRevIsOrig\n\nlet revIsOrig (xs:list<int>) = List.rev xs = xs\nCheck.Quick revIsOrig\n\nlet revRevIsOrigFloat (xs:list<float>) = List.rev(List.rev xs) = xs\nCheck.Quick revRevIsOrigFloat", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"923e0786-e6f6-43c4-8a0f-3a0a3047f582"}, "snpName": "ArrayToFlatArray", "snpContent": "let rec ArrayToFlatArray (array : System.Array) = \n    if array.Length = 0 then failwith \"Empty array\"\n    let array0 = array  |> Seq.cast |> Seq.toArray\n    let arrays = array0 |> Array.choose (box >> function\n                                          | :? System.Array as xs -> Some xs\n                                          | _                     -> None\n                                        ) \n    let lengths = Array.map (Seq.cast >> Seq.length) arrays |> Array.distinct\n    if   arrays .Length  = 0            then array0, [|int64 array.Length|]\n    elif arrays .Length <> array.Length then failwith \"Invalid array\"\n    elif lengths.Length  > 1            then failwith \"Irregular array\"\n    else\n        let a             = Array.map ArrayToFlatArray arrays\n        let subarrs, lens = Array.unzip a\n        let subarrs'      = Array.concat subarrs\n        let lens'         = Array.head lens\n        let len_subarrs   = int64 array.Length\n        let lens_out      = Array.append [|len_subarrs|] lens'\n        subarrs', lens_out\n\n[| [| \"1\" ; \"2\" ; \"3\" ; \"4\" |] ; [| \"5\" ; \"6\" ; \"7\" ; \"8\" |] |]\n|> fun a -> [| a ; a |]\n|> Array.singleton\n|> Array.singleton\n|> Array.singleton\n|> Array.singleton\n|> ArrayToFlatArray\n//|> fun (a, b) -> a |> Array.map unbox<int>, b\n|> fun arr -> printfn \"%A\"  arr\n              printfn \"%s\" (arr.GetType().FullName)\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d8b411c5-8416-4600-a49a-e9eeb9eed600"}, "snpName": "Partial Active Patterns", "snpContent": "let err = 1.e-10\n\nlet isNearlyIntegral (x:float) = abs (x - round(x)) < err\n\nlet (|Square|_|) (x : int) =\n  let s = sqrt (float x)\n  if isNearlyIntegral s\n  then Some (int <| round s)\n  else None\n\nlet (|Cube|_|) (x : int) =\n  let c = (float x) ** ( 1.0 / 3.0)\n  if isNearlyIntegral c \n  then Some (int <| round c)\n  else None\n\nlet examineNumber x =\n   match x with\n   | Cube   c -> printfn \"%d is the cube of %d\"   x c\n   | _        -> ()\n   match x with\n   | Square s -> printfn \"%d is the square of %d\" x s\n   | _        -> ()\n\nlet print r = printfn \"%8d = %4d^2 = %4d^3 = %4d^6\" (r * r * r * r * r * r) (r * r * r) (r * r) r\n\nlet findSquareCubes x =\n   match x with\n   | Square(Cube r) -> print r\n   | _        -> ()\n\n[ 1 .. 10000000 ] |> List.iter (fun elem -> findSquareCubes elem)\n\n[1..20] |> List.iter print\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c256790c-956c-49f4-b0fe-93c6a42c3870"}, "snpName": "Single Active Pattern", "snpContent": "let (|Default|) onNone value =\n    match value with\n    | None -> onNone\n    | Some e -> e\n\nlet greet  (Default \"random citizen\" name) = printfn \"Hello, %s!\" name\nlet square (Default 10               n   ) = printfn \"%d^2 = %d\"  n (n * n)\n\ngreet  None\ngreet (Some \"George\")\n\nsquare  None\nsquare (Some 3)", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c2f48f7c-7c7e-49e9-9716-ce7c3f566431"}, "snpName": "Multiple Active Pattern", "snpContent": "let (|Pattern1|Pattern2|) v = if v < 10 then Pattern1(v/2, fun x -> x * x) else Pattern2(printfn \"the value is %d\")\n\nlet useit n =\n    match n with\n    | Pattern1(h, f) -> printfn \"f(%d) = %d\" h (f h)\n    | Pattern2    f  -> f n\n    \n    \nuseit 6\nuseit 13\n\nprintfn \"%A\" <| (|Pattern1|Pattern2|) 6\nprintfn \"%A\" <| (|Pattern1|Pattern2|) 13\n", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a6726d24-73aa-4795-af69-3b9663cd6992"}, "snpName": "Golden Rule", "snpContent": "open System\n\nmodule imperative =\n    let funcion (x:float) :float =\n        (0.5 - (x*(System.Math.E))**(((-1.0)*x)**(2.0)))\n    \n    let mutable a:float = 0.0\n    let mutable b:float = 2.0\n    let mutable x1:float = a\n    let mutable x2:float = b\n    let mutable iter = 0\n    let R:float = (((-1.0)+((5.0)**(0.5)))/(2.0))\n    let mutable Break:bool = true\n    let mutable f1:float = 0.0\n    let mutable f2:float = 0.0\n    while (Break=true) do\n        if ((System.Math.Round(a,6)) = (System.Math.Round(b,6))) then\n            Break <- false\n        f1 <- funcion (x1)\n        f2 <- funcion (x2)\n        if (f1>f2) then\n            a <- a\n            b <- x2\n        elif (f1<f2) then\n            a <- x1\n            b <- b\n        else\n            Break <- false\n        x1 <- a + (1.0 - R)*(b-a)\n        x2 <- a + R*(b-a)\n        iter <- iter + 1\n        printfn \"iteraciones: %i\"  iter\n        printfn \"valor en x: %f\" x1\n        printfn \"valor en f(x): %f\" f1\n\n\nlet round   (f:float) = Math.Round(f, 6)\nlet funcion  x        =  0.5 - (x * Math.E) ** (-x ** 2.0)\nlet R                 = (5.0 ** 0.5 - 1.0) / 2.0\n\nlet goldenAlgorithm limits =\n    let rec golden iter (a, b) =\n        if round a = round b then (iter, a, funcion a) else\n        if funcion a > funcion b \n            then   a                       , (a + R * (b - a))\n            else  (a + (1.0 - R) * (b - a)),  b\n        |> golden (iter + 1)\n    golden 1 limits\n    \ngoldenAlgorithm (0.0, 2.0)\n|||> printfn \"iteraciones: %i\\nvalor en x:  %f\\nvalor en f(x):  %f\" \n\n\n// output:\n// iteraciones: 32\n// valor en x:  0.223130\n// valor en f(x):  -0.475414", "snpParentIdO": {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpName": "AdventOfCode", "snpContent": "#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule AdventOfCode =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"62be52fd-08c3-4afa-8178-39b7b338d67e"}, "snpName": "Day 1", "snpContent": "let input = \"8231753674683997878179259195565332579493378483264978184143341284379682788518559178822225126625428318115396632681141871952894291898364781898929292614792884883249356728741993224889167928232261325123447569829932951268292953928766755779761837993812528527484487298117739869189415599461746944992651752768158611996715467871381527675219481185217357632445748912726487669881876129192932995282777848496561259839781188719233951619188388532698519298142112853776942545211859134185231768952888462471642851588368445761489225786919778983848113833773768236969923939838755997989537648222217996381757542964844337285428654375499359997792679256881378967852376848812795761118139288152799921176874256377615952758268844139579622754965461884862647423491918913628848748756595463191585555385849335742224855473769411212376446591654846168189278959857681336724221434846946124915271196433144335482787432683848594487648477532498952572515118864475621828118274911298396748213136426357769991314661642612786847135485969889237193822718111269561741563479116832364485724716242176288642371849569664594194674763319687735723517614962575592111286177553435651952853878775431234327919595595658641534765455489561934548474291254387229751472883423413196845162752716925199866591883313638846474321161569892518574346226751366315311145777448781862222126923449311838564685882695889397531413937666673233451216968414288135984394249684886554812761191289485457945866524228415191549168557957633386991931186773843869999284468773866221976873998168818944399661463963658784821796272987155278195355579386768156718813624559264574836134419725187881514665834441359644955768658663278765363789664721736533517774292478192143934318399418188298753351815388561359528533778996296279366394386455544446922653976725113889842749182361253582433319351193862788433113852782596161148992233558144692913791714859516653421917841295749163469751479835492713392861519993791967927773114713888458982796514977717987598165486967786989991998142488631168697963816156374216224386193941566358543266646516247854435356941566492841213424915682394928959116411457967897614457497279472661229548612777155998358618945222326558176486944695689777438164612198225816646583996426313832539918\"\n\nlet numbers = input.ToCharArray() |> Array.map (fun c -> System.Int32.Parse <| c.ToString())\nlet l       = numbers |> Seq.length\n    \nnumbers\n|> Seq.mapi   (fun i n -> n, numbers.[(i + 1) % l])\n|> Seq.filter (fun (a,b) -> a = b)\n|> Seq.map     fst\n|> Seq.reduce (+)\n|> printfn \"Puzzle 1.1 = %A\"\n\n\nnumbers\n|> Seq.mapi   (fun i n -> n, numbers.[(i + l / 2) % l])\n|> Seq.filter (fun (a,b) -> a = b)\n|> Seq.map     fst\n|> Seq.reduce (+)\n|> printfn \"Puzzle 1.2 = %A\"", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1e403dfe-1572-4cbc-85f5-c92b1b743e83"}, "snpName": "Day 2", "snpContent": "let input = \"\"\"104\t240\t147\t246\t123\t175\t372\t71\t116\t230\t260\t118\t202\t270\t277\t292\n740\t755\t135\t205\t429\t822\t844\t90\t828\t115\t440\t805\t526\t91\t519\t373\n1630\t991\t1471\t1294\t52\t1566\t50\t1508\t1367\t1489\t55\t547\t342\t512\t323\t51\n1356\t178\t1705\t119\t1609\t1409\t245\t292\t1434\t694\t405\t1692\t247\t193\t1482\t1407\n2235\t3321\t3647\t212\t1402\t3711\t3641\t1287\t2725\t692\t1235\t3100\t123\t144\t104\t101\n1306\t1224\t1238\t186\t751\t734\t1204\t1275\t366\t149\t1114\t166\t1118\t239\t153\t943\n132\t1547\t1564\t512\t2643\t2376\t2324\t2159\t1658\t107\t1604\t145\t2407\t131\t2073\t1878\n1845\t91\t1662\t108\t92\t1706\t1815\t1797\t1728\t1150\t1576\t83\t97\t547\t1267\t261\n78\t558\t419\t435\t565\t107\t638\t173\t93\t580\t338\t52\t633\t256\t377\t73\n1143\t3516\t4205\t3523\t148\t401\t3996\t3588\t300\t1117\t2915\t1649\t135\t134\t182\t267\n156\t2760\t1816\t2442\t2985\t990\t2598\t1273\t167\t821\t138\t141\t2761\t2399\t1330\t1276\n3746\t3979\t2989\t161\t4554\t156\t3359\t173\t3319\t192\t3707\t264\t762\t2672\t4423\t2924\n3098\t4309\t4971\t5439\t131\t171\t5544\t595\t154\t571\t4399\t4294\t160\t6201\t4329\t5244\n728\t249\t1728\t305\t2407\t239\t691\t2241\t2545\t1543\t55\t2303\t1020\t753\t193\t1638\n260\t352\t190\t877\t118\t77\t1065\t1105\t1085\t1032\t71\t87\t851\t56\t1161\t667\n1763\t464\t182\t1932\t1209\t640\t545\t931\t1979\t197\t1774\t174\t2074\t1800\t939\t161\"\"\"\n\nlet numbers = \n    input.Split '\\n'\n    |> Array.map (fun r -> \n        r.Split '\\t'\n        |> Array.map System.Int32.Parse\n    )\n\nnumbers\n|> Array.map (fun r -> Array.max r - Array.min r)\n|> Array.reduce (+)\n|> printfn \"Puzzle 2.1 = %A\"\n\nlet allPairs s1 s2 =\n    s1 |> Seq.collect (fun e1 -> s2 |> Seq.map (fun e2 -> e1, e2) ) \n\nlet divPair ns =\n    allPairs ns ns\n    |> Seq.filter (fun (a,b) -> a <> b && a % b = 0)\n    |> Seq.head\n    ||> (/)\n\nnumbers\n|> Array.map divPair\n|> Array.reduce (+)\n|> printfn \"Puzzle 2.1 = %A\"\n", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1e372ba4-5147-47e8-b4a1-4f23d94f01e5"}, "snpName": "Day 3", "snpContent": "let input = 277678\n\nlet     squareOf         n = n * n\nlet     sideOfSquare     i = (i - 1) * 2 + 1\nlet     sizeOfSquare     i =    sideOfSquare i |> squareOf\nlet rec findSquareForR v i = if sizeOfSquare i >= v then i else findSquareForR v (i + 1)\nlet     findSquareFor  v   =                                    findSquareForR v      1\n\nlet solution n =\n    let square   = findSquareFor  n\n    let side     = sideOfSquare square - 1\n    let index    = n - sizeOfSquare (square - 1)\n    let position = index % side\n    let steps    = System.Math.Abs(position - (side / 2))\n    steps + (square - 1)\n\nlet verify1() =\n    [12, 3 ; 23, 2; 1024, 31; input, 0]\n    |> List.map (fun (n, s) -> n, s, solution n)\n    |> List.iter (fun (a,b,c) -> printfn \"Puzzle 3.1 = for %d: %d = %A\" a b c)\n\nsolution input\n|> printfn \"Puzzle 3.1 = %A\"\n\ntype Step = Normal | Ledge | Turn | Turn0 | Corner\n\nlet get nmbs i = if i >= List.length nmbs then 0 else  List.item i nmbs\n\nlet step (nmbs, i) ts =\n    let p = get nmbs 0 + get nmbs i\n    match ts with\n    | Normal -> p + get nmbs (i + 1) + get nmbs (i - 1) :: nmbs, i\n    | Turn   -> p + get nmbs      1  + get nmbs (i - 1) :: nmbs, i \n    | Turn0  -> p + get nmbs      1                     :: nmbs, i + 1\n    | Corner -> p + get nmbs (i + 1)                    :: nmbs, i + 1\n    | Ledge  -> p                                       :: nmbs, i + 1\n\nlet getVals steps =\n    let nmbs, i =\n        steps\n        |> Seq.fold step ([1 ; 1], 1)\n    nmbs\n\nlet createSide n = [\n    yield  Ledge\n    yield  Turn\n    for i in 5..n do yield Normal\n    yield Corner\n]\n\nlet createSquare n = [\n    yield! createSide (n - 1)\n    yield! createSide  n\n    yield! createSide  n\n    yield! createSide (n + 1)\n]\n\nlet verify2() =\n    \n    let stepsNExpected = [\n        Ledge   ,   2\n        Turn0   ,   4\n        Ledge   ,   5\n        Turn0   ,  10\n        Ledge   ,  11\n        Turn    ,  23\n        Corner  ,  25\n        Ledge   ,  26\n        Turn    ,  54\n        Corner  ,  57\n        Ledge   ,  59\n        Turn    , 122\n        Normal  , 133\n        Corner  , 142\n        Ledge   , 147\n        Turn    , 304\n        Normal  , 330\n        Corner  , 351\n        Ledge   , 362\n        Turn    , 747\n        Normal  , 806\n    ]\n    \n    let steps, expected = List.unzip stepsNExpected\n    \n    getVals steps\n    |> List.zip ([Normal, 1 ; Normal, 1 ] @ stepsNExpected)\n    |> List.iter (printfn \"%A\")\n    \n    //let steps2 = steps |> List.take 4 |> \n\nlet stepsFor n = \n    seq {\n        yield  Ledge\n        yield  Turn0\n        yield  Ledge\n        yield  Turn0\n        yield! createSide   3\n        for i in 5 .. 2 .. n do\n            yield! createSquare i\n    }\n   \nstepsFor 9   \n|> getVals \n|> Seq.filter ((<) input)\n|> Seq.last\n|> printfn \"Puzzle 3.2 = %A\"\n\n\n//verify2()", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"27802317-f924-45b5-8997-da8cbfb68812"}, "snpName": "Day 4", "snpContent": "let input = \"\"\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\nxmuf znkhaes pggrlp zia znkhaes znkhaes\nnti rxr bogebb zdwrin\nsryookh unrudn zrkz jxhrdo gctlyz\nbssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\nflawt cpott xth ucwgg xce jcubx wvl qsysa nlg\nqovcqn zxcz vojsno nqoqvc hnf gqewlkd uevax vuna fxjkbll vfge\nqrzf phwuf ligf xgen vkig elptd njdm gvqiu epfzsvk urbltg dqg\nsfpku viwihi fje umdkwvi ejzhzj qrbl sfpku sad nawnow ksnku\nnzhj mfudick ueaa jnhz kpy pzk\neuiin xvl elaoelu wbdd xlv jtm nohtq gfdbgdg gdfggdb edtym\nxfmkn wyww woe hwysuh gjw dtk utryasc dela eluk vmmun\nnmag qfwe cwslmgd nlhf hpf\nifs sszo iod isf jna\npjptwg wreera leyb hmlbpf qcrbma ylgue\nrwlpo jhla rprxvgs quguh pyybwgl qqvcb\nrxtcpdy wmpci mpcwi vwvdzdn nfpnj rcsxinl itatg ycy hrctg ron wveju\nzmkfn wip pyiz pyiz tnyg dvftf elks ezhotbj wip\nsgmtfdd xdl sch sch yaxzh wphgksh knzrixp yaxzh etm czqbaa jldta\ngnbr rnpd upe eeb sbq sbq oxc rwvugoj\ncshk thcc emfxx emfxx pbtcf jpim vltkqar czy iudkac jhpcc nqs\nuzbvx fkiuyk izxdiu yutntvn dixuzi hkyfnud oyz ynutntv\newl mfns idy fphu yqccb pte unukirt unukirt fdx\nlzn tin fgena qbql qycbdw gbtn lctlysx adhjfq blu aiv\nites ites pbxzunl vljzh lqgerta pbxzunl\nvmk wjfzvhn pqkidze qfwh\ntqprmc exypl caf kwikh mdyyljc pbo hhxxo skna\nsqxgejb ejc fvup hpesvs luz fcxqwhr ypxof fxlcp pxyk xiczjri\nvjg qcw fsyqaoj mxf jha feclqqr vzdqnk verw mvmvm pvdqtcd xsfu\nfwwn ktvdh aecfv acfve yjozxwo cnujw bcgde lphnk knlph bqwlqju\nuwwapm dlln uwwapm uwwapm\nhuupab ewetcte huupab ewetcte\nwjs zipivpd klwafr ipcczg wbv uujstsw hykn\nmgojdyh hlm xruta lbmaxit pabqrnp vkyigd ptpzr glin gfau pbo\ntbwx baqxq vtz jwex tvz tzv\nefopwx wfknzb ogaxln tqzrh jne zugd zpxikma\nrdjsa arjds hqdldw fjrtl midt qjv jfrlt\ndggqohj bidaaty iah lgmug wwmlbc lggmu laonaoq erkqrb tqolnns iygv qnonlst\nmsc glwn xjfnij itt pka irrafjd euazydj silo\nzsyut znsht ldky zsyut dzcdft znsht\niit cyteu pib fgvrs iux ffctql pib zuzp zsbb ieoi\nxxtwlu kqfxjhq isj xqjhfkq dohrs haovzc cgfwfrt munqon vuyexz nouqnm\neptpqgi uiflvd acj livzq ejtt bniud cjdh jkrcken lspfy tpxri zibj\nzxme dpo fumup gly bkdcwxn lsly eglhe\nuoshw ijoyiql rcskaa vjbqv roiinzi fppqdu\nxuw vdbxie oypcx khxq xebjt oypcx uitqep vdbxie hoz\nlrjv tdksk uebo wktebvx nlapmp udhhxh uliqbm cklyyf jlzw xrmdlvx\nfosspck fosspck fosspck qyidyur hxnxmb dkpj\nrmrvlms susvos idw hzy idw tjgxbc lhgqxr tjgxbc uuq\netjmbdr hwqe lnfwzni lnfwzni good eisci etjmbdr\nyqde bmlcc yuel vpyplss vyvhho kslgiu lllhc jtkijdj uclz hfbqsf\ntlohlvv tlohlvv bdqahw tlohlvv qavcqrn penia saafy\nlvtzyt qffe eaikhv eaikhv wbnl mdkg mdkg utfrm\nluowwk magp luowwk oyao oyao hsb yms\ngnxply vsdqum nprf jik axdp ariqjpc hjqcc\nizbo nkqkb xpqg pgxq qpxg gpm jxbkvu resj\nhsgyxar hvsl ner zzmcn lcpdvqn ern\nrfjlhu xkyh hafs cvvk drg vjsk mymc iab ycmlubx kpwemiw\nwlci qhhpr vhpr oyrili cnynh sivdso ldjya wilc ioiyrl\ncdfwd mbtk sienxui jsmxzo yxbeyl bybtc covxaq yuxn ktbvztl ktbvztl rcekjhk\nptenhqv tzdt phetqvn mfkdz\nhmezeak pqvqld amsih jxqacc uferfyh nfqjsz rtuqdzz pohcx qia cpxho hgpqs\niygny dluc uxqz nlujm xkdtlm xbdgepg jwn ohl wpfll\nlnqf pcxy cpit enp zpj lqfn oowgw yoxdff ohvcfcf fuvz qkpmb\noydu jlscilm pzxen nmtdngu tslcupx ntdgmun uztpx nlhh jqn llsv\neuyx epn gyvg cwtoe ruyap yaurp uryap obbl ovo\npgo irm ksrxe qotuygd afwh qfhzfsr wafh dqjbwce dzfo hew skrxe\ndpvel dpvel ipljjxs vrrsob iakey uheuu swxu qmnmn mpjkb jqrwfmv jozj\nsempz plzxqe qvyg sempz fejux\ncqgqvg zhqir rqzih vyu fmb mfb\nuejl kjh ayz dzimg yzafvg dem vlogg\nhtfkd htfkd hwykmm htfkd\noxvgq wtai rkyyxya ldkecdv\nlvlrsu rsullv pptnrwi slvulr vxrk dpzti\ngde ixwoz nnsx nhc nzi\ndsadkj qtgya wco psyondq jayad crc lswwm purrad pof\nnocibgs hxqdejv nlqxdpu dvzd\njfaws aiwnjm tqjpgs fuiobz gwnemv hjevs xkbbgiq sakgv zmwpkuq grjllw\nxrr jwhtchs boaqkg wjhdr xrr\nvyapct tgw juzgwkz odddvof juzgwkz\nunuu kubdd dxr drwg\nqpefzz iemo fwa vhdcxx\nhseqy copss gytzub lxi mrxtwc hxqqdfx ijt kcy tafjs jit\nuevse rrq zmwyjfe xljx lhgnyzt rngvwqd\ngfvpyhq xpdhind eocgpiz ebs pcmsgjy swni iwns thspnh yvbzxz fgb\nhxr ehw ekfd ncxcs gxjmd oqszdjp fgu gwuoafw zumenf qltbw whzuxov\nwfc pawqo pim jxgt dtiwzil hdptivc slkazm htafjih hzheez rkk amy\nmgoatiy pkec ddvwyni zuya aqrcjes ubkaeus nuhhad upe qfem bpcc\nrmyeg qfq bia lzk fusqfb ltvgry vggr xaxi avwdkbg zhlzt\nzkjoeee dyi sxdwfqa irqljmw gek dgdb mrakr ddaznn zlh ajzzacf juv\nkmqcy pohbej hujdgao rsxfkn vlu\nscnpa hvl cybql lvh lbcyq msw deqqb yjpsndq\nndhjooo dpf ziey jtjlc eesag ldhgoif\ntysbae wkpst kjz stpkw sil yetsba\nghvlfq flhvgq tgkjie gqlvfh\noimn vlmsljl ocala vokhrs odyv msn dzly wcky\ncfjwmh rpsdor bttnkg jxenm mwdk mer jgsusdz cslf\nialvxk bvc qjfikr caw puhmmfl xpmsx\ntyoey egcf dijg vywd enued uxkshz nav bdrn hjugffi iobqwiy\neykhxck shpfjhk vlqg alkenz kuj okxs oeth mqbr nfvqvkv xfvyi mboo\nzbw curcajm mel jxqcw mpdscxq rhadty zrddeh wmedc wkcwt yvwm\niee hzeofmh pqlkkb azlam fpj hzeofmh ripi\nsawaqek oyoiwtb npq pisadk nnd bzgo wiqme lxnvn\nobqx ffiegn obxq for xobq\nzwway wwazy aqxg gaxq\nebssilw nuscati mofyc sogyacc yujmdwu ehxsx qcaf udvoo nlcfaz eov\nvnbe wtzzjn bczyxt crmvas zujy kukq zujy kukq\ngvltk kgltv kglvt zflikic\nhby pium gut fjqn sksoqyq kcliapa\ntbonrr prf vga jqgw ulze ukfig\nzafixw hia omgwoi noeiox fqbket iviidgp bebune kwcuotp slvy wcx\nfjq cyecn fhxvj byv kojvj iaqd aaxva rkogp\nvqbbt sjmr mxu mxu rlfj yqhtzv cuar yde yrs sjmr\niyxiyp auepgw dtpbyvu thuoai fpsfkpn bemgbsk lni ozy jogp xldyvvx fpsfkpn\njtha ibn ahbkh xzxkei tql mycvmyh ioyw\nmpsc pvdiuu wqixxlo cqwmlrw cttoz lad\nsrl xxlnofu dqf snxd zjlp htxzd\nfkv berlbyh kyna wkme qjzgh thpw frup\nirhreaj udkpbza qmgp ormlipa lbyuc\nempizc apcb ossmtj awk ttsgi bfoymzd ftx jkicph qqjv tywp fwzfe\nzaqkd ysn zaluvs rljdk ast fjp amjqr uabrya ufswzjg vcldkxt hzsmrbl\nqvy tqgnwj akibr tfjevhv vav\nmhe sxg hacoa emh kasf hid jklfy ijk dih\nqvwbenk akdctm jztmsx aqvpodu vmknns nck letcrk poba\nlhve kkvff iiixid vtsun uvgte mmlxk pgd\ngktphd aaoqwz lrvsuw ofcyvmi suvwrl dpqiol wjgj uqigjx\ntbp xoc lmz dyzlvp bjleh pxj xjp xbil\ngpzgvj tctszm tctszm pnp upqtmm rribg tctszm sllsbr\nhpm qvjnd lyqg bybpwn etz pwfigbg uqgrvpg cvniubo\ntpowus bdncyxg gmm ebfg zwoue izgkwtx gmtfeg xvudp xgmjp atrvn aqgl\nwlrxvo wvonohi owxlvr owhnvoi\nknyo aiixyi sjtqb kukhgv qkj qiuefb syhfc aoana okmot tdsmnoj eyzqjn\nszhto szhto szhto fxpsavu dtcz hnwqdvk iza\npoykme rboczge tuyiw sxr\nlpgbp bpmf aiqy exzqt gxdoow yjp fxwdmt eoklc jnps zbnbiwr ppvl\nhuecy jjhyz pwcea ffofmj tts\nahbmkw brz xdenmw mwexnd ncdxgf gcxnfd\nyhfnra vqljz bkyxzt vhtsyde ysaxt qbw\ngqhiej rofhmp soeebdp rcuiblb rcuiblb rrnh nses\npxrwe suil iihzf lhcgmfm mqasxh ttpp kqitdyf cuabaa\ncxl cwsp qyseogj dimvv igsoxu ncrexla ubrvpp oum usluv\nrkmo jqqcdjb mobqcta pbcmoi afjlh mork\nnmohoeq fezpxh fezpxh yec\nyxlncrt ivi dajo tjpim tjpim\nhzhy rcjs uhyvwz tdpxlqw itoiyf\nded apfmhe stfk ugyujv drwks zagqnw mbbzmvc aoupemq\niezre wivdwif xzytxe xwytd vpnol pljx aot phln ztncw\nozblu asda tkxh xqe pvijnl qwwh uvp bdhtgjt uynwtav cdz uqmvp\neukgtsy kdfb bdfk tnv dfkb ewdemb\nrsf cxnk cid qsa zwk oetnggn\nfpq oim zetbmlk fpq oim xgv cbaj cjrqm\nphgldt fhmkc efkztj qidri vsv bvjf lfwfgm wfuoln toamg wfuoln idrs\niuc rrdnk rrdnk asqhnz qxkigmo eeoim mmdtgif akk\nrfvsyy kopfhmd tnv ibo demeqm gxrxw hwk ukorln bep\nialo eogif sxlj xfegx nanch egoif eymwt\nkttrpjq gbnyiat kptg oarewx vkmt gbnyiat szyokf\ntjll xviodi tjll efc rliugl wfbbpq wsqvdli jur tjll bguqyu\nuecm yzjhn vqf labnc xyaksj\nhjtef zzq ellr wtrodcg drwqo ernt uzx sqiokam\nizmh ddutl bdzft jvfthh\necr xqrp qlxstu kgprd gqvtwni mkughf bulabe bvoxkx\njwsna vjwq swkycg cpp dvmyal xotxviy qkiva ffa eakwp fww yirri\nufnl lpuxw rjki nggh ajdkpvo oeuaemy bjisma vsjzc\nctxu aavlw rap fzxtcp msufn fzxtcp sdlaom vgvdvpc\nrftw cyf twyxi orifavd\nogiht ertz wcw jnqdup phvp lbw\ntplpyq jeh aobamqe bvaim qptac gssi mkjbaj\nnmklyg iitx iczojzr vjspqb uooky uooky hjk\nggnekbb bnebggk sepzjd fvqfgr\nwnfwrn yaiogv mbusuy cpbcgs thjea\natndjc dbjgdz guedeay rasa kfhame pusuu dbjgdz\nxivzyml xivzyml eqsykxo bshvz xivzyml\nnfe ayx gscy ylyp oqyl isatnpx poaelm zsrw dpd eyrdjpq yllk\nfeqktz mlm jhi yxigeu xzqa qwv yquxw emken jgqsp rojfcu\nruvfcud poubal xswer hfhpyp guf pzgzoq pzgzoq jwgxafi guf kqzzlu apg\nrxwcsdc rxwcsdc ywu rxwcsdc\ndmgsey xrtx wldwyxz avi\nyxnqv ewlx fvif ozfcbxb zqapa yudqksk wlxe mjpvgz\nozoa ozoa hwkbp ozoa\nqcv drtqn uqv kcsavgn ybzs tkw\nnjmloq wapa srm srm ifurca\nezm ccj rub yuaww xhee liikjee kcabgic sbgqx vrpyo pzmesdp ksvv\nhycyne raaksm nylsc lcpgn akasrm vxwoaum\nzhugs pqquitv bae lyozb fhij pcdcc bae rygsgm pqquitv pizz\noxx bzk grpis qiqljwh svkn\nqcq qqc fzgn sqg\nlclad motw ukz zghp\nglr okzfs zgv ygsvv sauuog glr amxr vvmwmu khy eyh\nukpxpy rgnqyaw ncm coeblf\nqdbr ortzo spvnrnq uomtj vffbeva\nmiwar bidfxp eibo qyee\nyldec ghwj mxlemvi imac klkvmg fekxhp kevlzfr fcgnoq fncgqo\nhlm vlol qdic rltij nlzxfys rzpoh\nkrpwspb yrosr hioqla dbpgzgu dvkvvc vvdckv lcjzb qbsbr acbi rtnk\niqtvk jcldzuv smly whmnte mdwlse mkxw mfnkv mkxw kes owkfh\niwcjmkt rnb bjcdjl furhzuu exs\nkjwu iuaj ixkujoa jzeau whpn\ntvj zrdy fwsbagh zrdy czuzum lxotprx wbohaai\ncrsyzod jouf osxntw iwzzie bodu scze gjxn vgxvqo gjxn mmthykb\ndabjfb vjqz cvr gsymwoe qzpusj twvwhw gyvlqd kdrdkzm bdljp cvr\nvmswdz lgjsvxz yjkgqkg tzmjkfp uzbmwxe kuqa dzomt hep jjlibs oxvpvq cix\niqgd btwdjd ncdrovj ltxqc orwhdlo orwhdlo\nnxro uxj ovgha elvzl xmlzssr wonimvb urecfx dbfn kope\ntbes cgyh fypswue fgxjqtd dxdrfm pzhnaeu kugspa\neouzw qrpokyb fyhpb bcvfvze brdwey gpaa fpqutw pbqkroy axtc egamku gxk\nxdrovpt peeww wkcin suir gvrbix\nhgsjks juvod jtii iijt\nyaw hzifa wpagkd tgvmc iru yyeuy mgcvt fhiza\nlsk lks kls edypaxo\ntjz qjs mgoyd gomyd ztjbex nprwk vvw rtjsq quvf vuziqtb oygdm\nkftodz xua lyxt zfadf fgdwt zfadf xua ehwykd wniahd mqoarg\nqgiapb xptk iscyf zfspn qvrpva egufqte zfspn hksw xwxrs dkdruku vegfs\nwqifs wfsevg iwnjjpi oajju tkvhpl lemuw\nrzbmhso pbvb lfgpq fzjwxxh pqlgf rbhsomz\nufi aiyd gxozgx hygjp dtma uughdc ojumcf yuadt\ncaami tqzkvor tqzkvor tqzkvor\nvhtnvyx myxdywi mwpwq hjxadd qkcj vvytxnh dmbea\njvjtcjg mbiwyad cup xkrfk puz uxpmutf rjxyxyn mfchc\nocrak zprfbgu pjjzl zoehfkm xqn qki uxq tcv emknqjp wvmkas\nnxg myr myr vnfzpoy\ngwu ezt kbmeouj sxue cxax gcquz ieegnal xecusia vxf\nxermi xermi qporwc mzemns ticltnz ddpsstr ddpsstr slgbn\nxnujwtw bvzv xjwntuw unxwtjw\ntipo akp fkmcls wglmjq fnrtsv\nfan dfbya qrp lcvxqqu ldpm gucmeky mrzy fixaph rygneb ocm pjh\novtrqs ujmbnal geihpe mijhy eewuic toaxbp ipy tvb evlmrtd lbujmna\nlsmbwwd hvurk ihbuek hvoyq erzomhn gue lpq dihon dgzvst\nfuoshq hfrzeu zfrhue ufqohs\nicgwnbi gmhogxu gmguohx toixb hfwj haxlav hbe jdpxeyi xtgfi\nvfakk ioil hddqu sdztx hduqd bmiuyr vmas\nmcvjjhf sfgt sfgt lambvp dnqc pfecquk\nxgr omy bmoadg afbna mar nicpazd iveku zdioyo\nrpipon dwg wgd pironp\nfkyx wjefuy mfesst ztlf gnnceb rsbvuk ckilt kliqnm iuifcvu\nlmgzx oknwr wmttry luipa vcttj nuqdmy\niota efrxkk daqzm certtoi nnvqrwz qrqgza tllwp efrxkk\nalde wqmdjy erh txrtqm zuljg hspbnrd pvsnebh bkue pvsnebh txrtqm txtthn\nhgggm rswwfpj uctzrv bylqeen dpbnw ostsjwn jtjiyuh ofxu mmmqlg ayhza opbgdrv\nqmhkh orbeokv agosach lhujcju jzpp wmxtcy jcxglu iuwmzrv xwkgz sxlzld\ndzcdm lwal xpujjm xpujjm lpfojz lqqcon qmqrg\ngmwugq ceslt rxcogaq jwkraq\njoxr brdy yixlou brdy lnr lnr\nwbut pxlsclt igigapq zeacg jxiezn hvws wwz ujpbl fdjtfjw opod kea\ntsodswf pufo zqrt zvcpu\nnyy mrqmg zkt tslzsf zkt\nhxywv lbmogd hhv npyzgjy whfvv mlfqjr ggjz owijo zmesslo gtvizw\nxzz dvpzxbd wxwlp cye rcqpgrr gynzo nhy gzpk fpfmb\nnhaakbv iazpdc yadqbe kmqm dffq lidnh cegjosw kgd hwivd wijj\ncwmdyf huoy awihev qav cwmdyf rdwck hahj pesfyk uoju zrirjdu\nqabl vwcwbb phnd xnp huuzwxl rukbp kod sfu ngcvgrt buncnfw\nregyd gjzfwf hpuv zmm vphu gwffjz\nrdf emo crsoeo bksetj aqfzm pphny\nopbmboi iakvj ymjwm vxoq qvox yafk zkch adlusz\nqhm jul zasv xhu qnhjwzx\nmjmyvd mezfuls upbdpzw awc qxta bzrx tjpjmj dxfyewc zorm\nbko kfokm htcpoqc liuvj xhmpcu ccqphot dthvo pfj dtxpmu xoocm cmxoo\nkxv eenns qhpfsvo gqoyv jzjho aoscl fetug agxmfea aygpt\njavmegf jlmt epdwy egfs hwv uszcqvn foixpz iukh dbuhqgs zgb\nzrex zrex xtx ydan maomp hqdhh mfvan broh wvwhqbu\nphatsot joipm pmniq arqzmbe vurl bgy iwbwk oyhngcv vnzbzgm bgy\nxprufgn vhca nrs abuh zwsxmhk mqrj tyslsij ojkdzom wepxg koodzv ypvyy\nvop nnpz mcod mlli ntyhz laqztb kauqkla gmrfte pcuhaci\nvrenj lypors prknc djbdkzv amofdx\nlgig lojnrw obusoc fkwe ggnv pydcraq bvdivl vev mrojjs rxa\nqeg tap jocwlsm vqxa lmjscow\ngptlrgq vdasm erdc oparmw\nrgbsa nacqhvm pczf anupcp upudwgp\njbnobi ifhzrd ihrkkf osw wos lrnwv\naiuntpl fcxpmz fplacs fplacs tipm gfotkx\nfsbnd qoc ozmbi rqv fmbxh tuso kfoxvjn ocja zzs jwplx\nmuaklvq ghozoxh nwxbh mgoou ufptl ouhh reyuf jougckd dgprag\ngwbnqwv dtrd mkzxinl erxl zmfa skuu crxmp wwao wwvdpk nxbn lglzy\nqeejk wvnypc yfzyfcr eeqkj\nnmcp fmkgfyi grfthau azw\nkkallxz rjke ukbt ixkhfb bktu jkre\npxj mnwe djrjde gpsc enqz pdbydx cktfs jjeddr\nmgplj yyunujc vis odee ccesa yyg yjcnuyu doo utse\nflyy juvxomm vcdcyva lfyy ozxnuzw bmgns\nkmsypi zpbyiv rrycnb qos sslwyeo jgbyv njltzt fuwk nwfb ozcf xqnf\nsdcvgmy sdcvgmy hzv uyq sdcvgmy\nfyox vmgxahj ywaxbmm ugy ruwc mys yrjwr ozsxb vaq\ngjpyc sgdn kgm fbvq cziui nzy bwu ezjkkus jrag\nkxcr tgjxss xkcr bembjv rbbiw bwbri\ndcz rrhvdc zbonfzy ubjt\nrvq yjnzswt vatkopb xlj dwxig dqlt qts iva\nlylclc jptz rbidu lbt byxk\nlwre vwriwh afixsi vwriwh\nkmvbflr nfptw fbglxh pyas dxmn hemf segaz zrs\ndvbey zmj xfoi bma udtxhb\nyryng geiwgz bbrvjp ala\nolzicp olzicp qhhslry olzicp\nexf xdmwh xdwhm nhjsssn rmlkdb excguia fex\nxkwgeso htys sjdk jizciy gjjl phgqdjh wzdb izew zcrumu llxfp\nfrkohf oifsm aisebkt ijsfkot ukk\nkoqf xvoior tpe erfpnp npnx\nsneysk nsxki wpmhd mdor akrpvgz moicncj sbsj owfhj exw\noqqbvk xztx gtxlms icmo\nlfy ltq dlzqlvi ovbrsa gzm nhcjq umbtgm nhcjq\niuopdzq cqaeuu xuzngq kxlx laml slvvr frtml tvioiez vyoomw xickbqh\nckahov mepeku gtaf gtaf\ntlto cnnz kzsbkjo kzsbkjo\nkqf comkf dvrkyl jdsqi rnwvb vxvd pok\nhncq xcx yuykfs egrruvw yqh smcou\ntywyq xeq cix yywqt jhzptci hybcoe\nzsw zsgot wnu sumd azmuos qawjaz rpf zkxgwdu iom igh\nvmxmelt gll ysbbt yboqoyz ykdglk cnypf otn owsz ipn epfeka bkmy\nwxjpce etzyavi whb sxzft bfu dgwnbgc nfw sxcteis qqpk\nkofv dgoyme vlza oxhbo lrqt uic tvfqiyy iaqm afnk\nnsmpg wkibdcz dxbw tlxzm zgwe nqwjji eacbhn blk\nshlgws eencr rtufah kjyvqw transt ecsq otbf\nobs xsjceex ffqj sob djpq jcda zlskve\nrfqtle klarp mtzrx rasr eisqovk rpt vymibt zwrif ilsnd\nldu ffd ldu tizfexr fwpmyan\nflxso tzec pzn flxso kzdouon tkvkj\ntvd arh qywql uev btvnpm\nwtwx kzafvk ybyzmhv mdbrphy vamlvr gbxhod tyulba krcqj ikotmla qfhpa\nbnfin ebngj agfdfzu rhjtj aaqzh fsyp nilar uwurjnu hhmso hhmso\nuanmesj vshh syosjdt xkormf syosjdt ifvytwl qnw vshh jkg\nepyzcn pgdxgye lecnx nebg jzdhvge hfy imiyft\nzonbcnv vuvg sxtuty zdhmiow lmud cuegzg\nbxgft mxhzrh unqd pqpsnce khykn qlb oujdxpq pxrd jzxjuxr tij\nqss mqirowz ijjswjm jjer utwn kuedqxx bxshuok qkfag dmfwcr\njgln zdohd xitfbge xbokj xxeuv wqhvhjo erg cua fhc mhwy\neuo ousht ipxt tpzq vnbmlo wvbjpb yjg bwpjbv nzvsea aerhsqv\naxhmi bcf zdx vplso xhmai qsk psolv\nydnpmyo pfba zmo nat ykwxvm ydnpmyo rtd uuvqqr hcfccbd rtd\nytp guw ydmyf rww oucmpf gemhpj labc\nedpbefn awgg qzpe aat cupig\nmmi ghdaoh ibx fbyj gge vmmssen nplt mmqcra omcvm uwa fxypxfc\nkjaw mtijne cfmsigd zwcjjd ajxjlqr tbp bnilc\nfse ele vcsyiv bfe udny vznrao mgrjfgw\nhadl nikvvpf gmdg bkmgt ugj\nxkis qmr cgz nresp gms zrii coxkke vfsqiil\nwmicbf bkk wcwklfg vpcbeg kfmjab vabc dax tnao tnao fvvzeyq fqm\nbct tvj tra soo stqao kqua ikupoy wulcu nauxkkb pvqxy bfu\nwpz txdduxq gaehfki kxo lvjzpxu iqon swr eyihl nbbec\nfuphnbj bdtz huwu zdtb ilgzpa uyaut vpy viff tuuya\ncvusbh bgy apsao qsupha\njtzlbd ljfvh wkjrw xsah sef jygb pqym zbcwok zdmug qpym\nhbibuax iorqc dqjrs daeb iorqc qiw sagyt rkc sagyt khbr\nshz mgn pqrdbm jvace gfhnq ann zosq wdwzmuf kswsg dzt brlavyo\nqiw cdvwds dckpruy pybjra lfvgfn cwj bajtud pojehb rzrzvwe\ntxfyk zkgeeu zkgeeu zkgeeu wskcv nccoz\neettnxq gbgr uiqonyz wqtgs ozfjbn gbgr\nsvd thmmr rbbtxn sxkq isxlnhf tamdlbe bqrgvu nmpvlkc spko\nqmn rspbjme ikjddkq kdb ugpegi egipgu\nufffijo revqpep zfw kwd pnya blqo rnntzx anpy\npiaeyf vbeye uuqd vbeye\nhamd hap ekk lgla twto\nisniinr crz sjpmfxn uskwj\nlzeofk tavbq ijcglqy lvy jliqcyg lwlip\nuhyyyw itlrf tdc iabeocv jzwnjh vqxll nefze pyrxmx eispxnm hzlksce\nucuh mlam bhyej rgzkew ctbo iswqnvg\nytmb toppqgp ytmb gqgpr gqgpr vps ebv\neavn atkqltv bjvojs kaskr vqltakt uiktr xglc eyb rkkas fhnf eaorqm\njmfipc ujggeh hdxpfa xtab ydkibi ycxn ujggeh icheh vpznael oprbf\nxazqxg khlemu awh uwz vhnixk vdcty hkk\ngcl kayi hfozask grpseyn zviy tzoum qywnr wqkhq\nctrrcpw wqfbylp wqfbylp wqfbylp\ngtk lqohf hqeaku mdj zrfkmxn bcqgf msing\nluhpel kexokpx vojap ldaexs bbbtz\noimnqb esg zyjmbfh dfyhcf khpo zjtgm yelztbs ugj zjtgm mxro xyfxpk\ndgtsu vvk wwfugbx aai zlxab beyxcg bpx chc bnxui\nirrwbo orwibr lqt qtl tqknh\nihjsg ihjsg powwy pycyqo ihjsg\nxdcu outh fnqrc eihkss bdylm sjunib eihkss\njpnw ycimse rffu ismyce uhxl feai\nyyodnh dvwshkx vulh pvxj ydhyno hyodny\nvuuweg pfguvyu orhei orhei wrm amkr xecja lmnveth\nwriwe xgtnvj tdmxf gadtqh bezjvz lifu\neuft tchbm xmtlwji tchbm\ncfi zudn zludl pwiu axe psed\ndbtfwf ajxcudj uaxdjcj dxuajjc zouyy\nfmycmej bqhe jyfecmm kkrv kcdvjoy\ngrtb uzs rkxzt hivhic brtg hwyc lsl iivhch qbcp\nymn xfpka hqm sldz dblvsoe\nqrcapma hntgmy difrkpk difrkpk xlsph\nflvqh akcw boxrz ywhq boxrz esnxzv boxrz\nzrvh jskaw mfs fkj\nabveb qxfnlfq abveb kbwiyvd abveb\npgarl nbfrenx rnxgx bdlkix liltdm dzcokeg fubupcg iwp xfayp obfaz nevfw\nnuhvaci blyv fcsp adlanka sjy syj ysxl\navwakn dkoya yzuszuk lqrr oqfyd dmgbhd lqrr\npxa mcvtoug nlweso yffqc dtuagcd ovvrkz ggfhw wnlseo bpqbn ohxzs rxzo\ndjkcl kbgyfir ogquot uoqotg jtmyd ohudvle xrnbt yvsln wykqt hntc xlrhqrb\nykt tkxfmd exas kty\nzebstke msbbndq itmli ubexmht vekvd xbmb iajbj wac sta\nptdg oftwo goiulah tfmsrqs jffxvnv ozaluj qlhqjy wyffa\nxeq ezmlpw xgno xorvfo yzq vwif wsi\nhdove hqbzhu pjrxlj uafuh rizlb advmkca\njzk ddoisdh tfjh yuvikps ixpkf hnu\nkixa djx uksr ogxty dxj clda ukrs\nxgiy diwbvn vphdbg qnelyz tqptqig lenyzq ecsswj\nalx awj fpasmmg zukuh qaanvb too nvskuk too gnria\nsuo suo brw nazq suo dqv\ntan uxiz oqa xyezcd lsaicjr bosiak rmmh\nbidpomf dimcj qekero wbrc lewt kmgmlao\nbciacj eye lxfpef cbdshd dhdsbc qwnhil iuokc\nzduefht lrgfjn nclksm wpjpjr hkeqd oprsjcw\nchhdr bram swdfjr yikqra xkzsloc otptp agec hhdrc uofljf toppt wpbyrwo\nbwlpb nishr knnrysj bvr ftnb iedskch weo\nczo hsfp wblh cru kzalun intt\njvob rppz rkwv hgyhrqg\nsgo hued jnygge izf ztan kjgpcn fagff jsi ijcxzoi tgqjjp tgqjjp\nltjq zidjy rfmy yevuaa nlhfyg xytdtle wsqvzzx wfflboo nawhv golhf xhsti\nbmtzlml xcbsquq vnfsux voep lkss ioim\nntfffh gcncwu mmymn wkwlswa gcncwu iaeyumz\nkcgdm rbaau cwsoya pznnnn xzz zbbdlhw zxuelq xzz pjeq\nxrmnuct kwvykx khxr ioua xnmtrcu xrnctum ujq imnt ecee\nxjsgx fby fby fby ggtpgdm jqvuj qshewki tkml ymsazcq\nsdbyhwg kewtrte novhdcp wbuaoh dtytgtx zez whygbds hpg\ntjvaqo yrycda yrycda ldbp yrycda\nkloi tmsocmx dza sqtxc wgevs zlevs vtm\nftnx drvdm ryjfdgw nerynh cwfjpa mddvr\nwsqjyn svg ncw aesn hvuq vybajti aesn bql atxhp ipu\neye romgxj gumuke jwi jrf dtt kcj wmg waw\nptltud oymklv fgnmbc ete apanovb vpt vyospi\nclkguhu rbxs lxtnmy ferdx qbmrpg pvojnj zbcffbp\nitngp dvtlq fzxp cxrf gbxxqp aafls pfe bpxgxq\nnmikrui ddsq srfilr gnuvghu mwnacz nlbdm zcjm uylgev umzu mftz nmikrui\nbow jmnxyen bow hvz\nlksibxk lefzh lksibxk nkxsi nkxsi pldvhk\nosjlzns pihvr zpeu zxjgjb xplykfk xplykfk\nhajmfss cardd kaddjw uicfde taue\nrgwdjra sgifh ggt mpzx usghkos oob fvzx ghnyxr sblcif\ndtu gnihpry kjdpiny xvax itmluk fxvgaap bei xuq wzcy rhb hailtgo\nwwob ueldq ueldq glxc umimwv onu dxhmhis ebottoa lnysfiu\nzfbyi eyq etaj idpbkf\nqshcfjb ozzqigv raztm ymcv sgivwoc kightf dcaglk udah fdm\njmxr jrcnck enffwfl jycc jmxr cylnigo enffwfl\nbkslhv tykqw tykqw mbeqrbt tykqw\nvogf nhqltpt nhqltpt vogf kpc\nryayz ddktu rfhkmx xok xninjcm ijcrw fxu\ncmezfj zaamjrs whlcuoo mug lcaqhkb ymkdci qexa onhgk pgy\nhcrcok qri fki wbiog ptj pmgtdt\nxsl mpfxwbz bmzxpwf hrysu bmfxwzp xfja\ngybzho ktokndy rzkbr jcnp ahicq weccg pgrodkt che vaglyn omhmpo\nvdv bngjox srs faymg xrmf enseu aygfm gvsd\nnuzi xodkbag eevovl bfjuv nuzi xmejqn\nkcswegw bpa dgil insf insf\nstg tklrut poi knurfpf\npcs dgirfie yep lvkfk ype hntt athvad clfybsq ofjhegj epy qwawns\nwjtpgd wjtpgd vxnapp mwyfsm vxnapp rvcswcs jksa\nckzslrg wdzeimw cqhp nfgk zgukvd yyt tra erkx wdzeimw\nhsww avl vkmzej hsww\nmum oczj jfew rag zjoc wjfe yqynjqt cbkcsgo mri\nvjhfqdi vjhfqdi npfa pzdmy utlyw bwvbfm nqdv iiap ygpky bwvbfm eocya\newkqi ckb yviuro mqz vtrdam yzkqzv ppbj lhmj blkafo juxvwke lvewc\nljrewgx sutnb hfsavbu jofr ltml mjzkzz nmjii sutnb eonegt\ncxzv nepyrb wmejdo vwqi aeqys\nsbx fmne obzdz rdnfb gmb sbx ykcae hbzom ncwju rhpiao obzdz\nlsgfun cbmfjwk fya ktzxbwt\nica bpsk bwjwkp obloxdx uwoqdo bnnhjuc tlsx qtaacp bdooxxl jamy ade\npsus wmtkg ikvfx fkvesj upqlhfs ueje nyt abxvo\nadlbl hzskbrp ooht nps\nwtcgnvy nvqtvx tvgnycw ntvcygw kkxcp zyjmpbh\nxfxww xsddqe ewvmgw qxqwy wpabtz ppe zuiw zubcc onaqii\nkkaeec xhcakul wrrvi dtlqfy ahqdilw bnt gwimw espaivx nam yfv\nlxz jtc nkwgz nbgsao olsck emtltf xidwcvm lcjxq\neav dzh hnbp hnbp yeg\negaq yvat kavsige csar zsi sptai\npofijc ibdnoe caoazp azlnjk dqp chik lowll iby gpvjv ohm\nors lexk zcneaj rmesx jman uqkb kvkq zfufmn\nqgsyzxd hlm juerg ortfzw hxjzg\nfxwy lcoc fyxw pzhynp yfn zdzrz\ndatmws ckwghgr gbtyf lqrpfgl mbgpd dyjilr fgybt hxpg\nmxw facxdnu wxm urltwtf qfo wtpwrj\nesa srypq jauwv dpm wdgqq hrke icvudq bdmubb ellhfjh ttpjjd gxmg\ngvwvqwj cbzzuvj eckube adqinpa djutlue wcpw vrt ucqwu ekruwsn\nfhj fst zmtb yhwk dxlbozs fcb vjvuxin dxlbozs rixdvu\negfoep cvq icd prwj icyg\naojaa ezmcuf udreyi bja cyrtpl wjl\ngjeka bsbufp tbqqq vbmnqg sfqtgac odhq xzsxt\nyse gujdr ugjdr sye\ntax hntqw phf eixjwfh qkylnu nkyuql ugsuj\nwyh egum zizhfc jrq htbyug lop dsu\nexh vfdoosj ajrna jbiaz lqsgvks xklqgjv abtmdud\njuqc ormfa sab tucsfln detqfo feg kifsion juqc ovhra\nhvcrh oddhme omzmu vmy she xulvfa fecmgi\nayo gspge nkmy yblsj lrsre nkmy pwocjz gdexqqx ovovm\nacy sqcz ijl htt yjsi rly vea bck\nbniafe yore xnh rkcfd hxfuzw xlr nkzmmcs ekwggiu kgoboi wfuzxh hwfxuz\nweq crkeq cccphe dtozviy kzkkdr yku cephcc ctq zbau dewpi\nvfla rzpl bnmx uvggon foivrb fval\nziaove lawkpdn ddwl sxj krroj rqmffxv babb\nbdw dsifr kuueet hugddwt piz dwb sjixveg kmsoknq\nczl feyxf soyvbj tnmpjn kklwi akx nqepntc\nnrmhc tkkn jrxgc jrxgc tkkn\nufzn mrhiapi qrme kjlf qrme xpp qrme loyzizz xqm coli\nqvaoye mysv ydfxr iixrw\ndql tqarux fxqfn haoinu lyati xml\nkyve obatly dgfjt fjz sqrz xlbst lgwlt zovih aepy otrpl oifid\nymawam afgye lcnpkmv feilfws vonseh rxrdco\ntqij kuawg dmova slds imdtb sjsafo ffkzzl pxxenva wuakg efbgx\nyrwoaos vpw ijjpua jnbxl sev yvgdxzr mpqa vpe lboh sev\nkrwdtd uglxtcz mljcgdk lqj fgpfle nuui cqk exr nuu oyn\ndwd nwt idhclm vgkh rpubq wybhapp\nhskhgpy gzvz jztbr jwv vcx vdjmnjr jrsp\nikml ceuhcng biu zoo gra bnnforx abzan hwsmd lmki tsl yvogo\nkqfc younaz azvgfz gesajr tmwxvyb vmcdu dclwh rfjwhic slfym\npbrhjml rsacryg jga qvgks neh fcq qmi mwb juezk mjteeg alkb\npcj ujstl fkrqm eeczrle hbkcvm upbo mrb qrspjt\njbq rrk xjl rgokbnx hor ogg szxqu hysy vqj piorq wtrtrdk\nbnq ntvhcrf vrm puer kde xaxkja sfxgjf\npgcicus hqeqkkx xqekqhk qqkxhke\npuquxi hmeaehh oxe tasipw qzyg hyvy wcmpwe\nhvs fxq wvfy zjepsl dvrfxnc xnvg\nxle crcuc qkhnv crcuc oedez bjw pmwq\nxzzpiy cjwss jwscs apb bpa\nydjhhf yeltadb lwi cjdcb ovaox xrdm vkxub\nzax xza admbc lvpzfeh auxn rwasj\nkebx eild nrskdr meja jxczomh gcne\"\"\"\n\ninput.Split '\\n'\n|> Seq.map    (fun p -> p.TrimStart().Split ' ')\n|> Seq.map    (Seq.countBy id)\n|> Seq.filter (Seq.exists (snd >> ((<) 1 )) >> not)\n|> Seq.length\n|> printfn \"Puzzle 4.1 = %A\"\n\ninput.Split '\\n'\n|> Seq.map    (fun p -> p.TrimStart().Split ' ')\n|> Seq.map    (Seq.map (fun w -> w.ToCharArray() |> Array.sort |> System.String.Concat))\n|> Seq.map    (Seq.countBy id)\n|> Seq.filter (Seq.exists (snd >> ((<) 1 )) >> not)\n|> Seq.length\n|> printfn \"Puzzle 4.2 = %A\"\n\n", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"}, "snpName": "Day 5 start", "snpContent": "let steps = \n [|", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9650c84b-d384-4bbf-b43c-0e997fb616e8"}, "snpName": "Day 5 input", "snpContent": "2\n1\n2\n-2\n0\n0\n-5\n0\n-3\n-5\n-8\n-2\n-1\n-2\n-1\n-9\n-10\n1\n-11\n-5\n-9\n-7\n-13\n-19\n-22\n1\n0\n-3\n2\n-9\n-4\n-5\n-15\n-13\n-30\n-21\n-4\n0\n-34\n0\n-31\n0\n-29\n-42\n-1\n2\n-24\n-16\n-16\n-12\n-22\n-37\n-16\n-34\n-46\n-12\n-53\n-12\n-23\n-44\n-1\n-29\n-9\n-52\n-17\n-30\n-60\n-5\n-29\n-26\n-48\n-55\n-10\n0\n-50\n-1\n-8\n2\n-37\n-74\n-63\n-39\n-7\n-81\n-33\n-62\n-59\n-20\n-58\n-54\n-23\n-19\n-80\n-39\n0\n0\n-92\n-75\n-24\n0\n-73\n-36\n-14\n1\n-102\n-97\n-30\n-105\n-99\n-84\n-46\n-67\n-88\n-86\n-94\n-53\n-88\n0\n-100\n-86\n-11\n-93\n-99\n-21\n-2\n-108\n-6\n0\n-113\n-116\n-127\n-42\n-131\n-124\n-24\n-56\n-63\n-130\n-118\n-52\n-139\n-43\n-90\n-123\n-7\n-93\n-117\n-34\n-59\n-140\n-103\n-52\n-115\n-83\n-42\n-92\n-48\n-82\n-104\n-38\n-2\n-28\n-150\n-39\n-30\n-71\n-146\n-55\n-114\n-141\n-158\n-55\n-21\n-121\n-142\n-137\n-119\n-99\n-113\n-99\n-33\n-99\n-20\n-129\n-83\n-64\n-179\n-182\n-43\n-86\n-50\n-135\n-186\n-68\n-100\n-181\n-22\n-106\n-178\n-157\n-46\n-41\n-80\n-166\n-77\n-81\n-144\n-132\n-81\n-11\n-38\n-57\n-69\n-13\n-79\n-146\n-1\n-165\n-52\n-134\n-86\n-160\n-97\n-220\n-92\n-200\n-145\n-175\n-138\n-205\n-127\n-165\n-155\n-211\n-134\n-31\n-118\n-190\n-40\n-182\n-96\n-134\n-93\n-84\n-76\n-34\n-33\n-203\n-16\n-245\n-167\n-102\n-5\n-44\n-239\n-127\n-255\n-116\n-61\n-140\n-238\n-69\n-254\n-203\n-178\n-229\n-250\n-120\n-109\n-153\n-108\n-137\n-247\n2\n-151\n-270\n-164\n-62\n-186\n-272\n-190\n-180\n-70\n-179\n-38\n-208\n-215\n-151\n-156\n-62\n-57\n-275\n-182\n-169\n-264\n-70\n-279\n-55\n-287\n-57\n-3\n-67\n-155\n-213\n-17\n2\n-200\n-291\n-179\n-175\n-73\n-257\n-47\n-118\n-206\n-93\n-293\n-199\n-102\n-118\n-188\n-66\n-288\n-21\n-204\n-80\n-237\n-175\n-297\n-235\n-168\n-262\n2\n-162\n-95\n1\n-286\n-318\n-9\n-213\n-159\n-127\n-175\n-266\n-240\n-268\n-245\n-196\n-281\n-86\n-202\n-127\n-144\n-157\n-333\n-122\n-230\n-182\n-38\n-296\n-12\n-224\n-123\n-40\n-6\n-324\n-135\n-289\n-85\n-179\n-37\n-58\n-125\n-228\n-124\n-250\n-73\n-35\n-286\n-267\n-257\n-348\n-83\n-3\n-98\n-99\n-273\n-118\n-310\n-23\n-299\n-96\n-51\n-273\n-79\n-112\n-355\n-48\n-219\n-10\n-103\n-18\n-201\n-108\n-34\n-362\n-165\n-359\n-347\n-157\n-148\n-20\n-344\n-66\n-337\n-387\n-62\n-125\n-4\n-355\n-322\n-263\n-381\n-108\n-25\n-262\n-425\n-100\n-54\n-315\n-221\n-268\n-211\n-321\n-89\n-124\n-297\n-22\n-162\n-117\n-430\n-152\n-373\n-256\n-37\n-61\n-59\n-436\n-377\n-346\n-245\n-167\n-451\n-392\n-382\n-248\n-254\n-382\n-249\n-267\n-216\n-205\n-310\n-326\n-144\n-107\n-65\n-382\n-79\n-401\n-370\n-221\n-283\n-269\n-64\n-207\n-262\n-181\n-146\n-52\n-169\n-147\n-225\n-179\n-215\n-116\n-115\n-37\n-227\n-250\n-228\n-132\n-414\n-425\n-230\n-224\n-319\n-42\n-353\n-285\n-38\n-145\n-263\n-25\n-142\n-296\n-267\n-43\n-315\n-352\n-105\n-275\n-354\n-66\n-414\n-464\n-215\n-107\n-267\n-394\n-10\n-27\n-315\n-286\n-113\n-454\n-400\n-468\n-245\n-18\n-427\n-479\n-281\n-43\n-29\n-15\n-371\n-127\n-371\n-251\n-343\n-267\n-355\n-271\n-68\n-454\n-532\n-264\n-513\n-170\n-484\n-85\n-329\n-389\n-317\n-382\n-535\n-169\n-395\n-53\n-429\n-394\n-465\n-250\n-419\n-434\n-84\n-130\n-229\n-496\n-336\n-388\n-412\n-123\n-502\n-205\n-367\n-224\n-40\n-551\n-99\n-394\n-321\n-515\n-260\n-410\n-518\n-22\n-23\n-259\n-397\n-306\n-199\n-157\n-49\n-298\n-176\n-564\n-271\n-6\n-297\n-514\n-432\n-455\n-192\n-95\n-447\n-237\n-571\n-543\n-229\n-405\n-282\n-235\n-380\n-25\n-603\n-335\n-94\n-533\n-463\n-396\n-421\n-393\n-588\n-376\n-152\n-328\n-460\n-90\n-315\n-533\n-207\n-590\n-100\n-588\n-574\n-259\n-183\n-522\n-424\n-272\n-341\n-443\n-217\n-143\n-26\n-196\n-632\n-520\n-606\n-277\n-176\n-547\n-564\n-444\n-228\n-223\n-115\n-200\n-616\n-576\n-398\n-157\n-78\n-586\n-12\n-650\n-239\n-152\n-20\n-366\n-100\n-478\n-666\n-247\n-105\n-230\n-218\n-48\n-238\n0\n-387\n-660\n-542\n-189\n-339\n-577\n-527\n-273\n-565\n-230\n-578\n-147\n-106\n-373\n-513\n-8\n-465\n-66\n-408\n-351\n-357\n-119\n-251\n-626\n-81\n-575\n-542\n-193\n-219\n-189\n-635\n-77\n-517\n-608\n-309\n-716\n-712\n-287\n-67\n-312\n-334\n-584\n-687\n-488\n-612\n-42\n-180\n-726\n-235\n-606\n-538\n-470\n-477\n-504\n-278\n-24\n-435\n-610\n-540\n-646\n-503\n-151\n-350\n-43\n-699\n-459\n-516\n-424\n-343\n-297\n-460\n-592\n-30\n-614\n-125\n-425\n-180\n-73\n-550\n-361\n-390\n-380\n-518\n-418\n-305\n-326\n-84\n-675\n-320\n-557\n-486\n-457\n-414\n-69\n-228\n-683\n-610\n-188\n-608\n-480\n-225\n-186\n-374\n-256\n-672\n-145\n-323\n-453\n-252\n-214\n-600\n-49\n-652\n-593\n-93\n-42\n-101\n-600\n-422\n-146\n-191\n-474\n-725\n-568\n-572\n-498\n-506\n-702\n-120\n-210\n-340\n-482\n-210\n-666\n-520\n-647\n-219\n-435\n-455\n-814\n-304\n-610\n-224\n-95\n-425\n-456\n-761\n-339\n-256\n-793\n-49\n-317\n-274\n-374\n-620\n-730\n-130\n-128\n-420\n-315\n-47\n-92\n-467\n-269\n-563\n-495\n-501\n-32\n-755\n-774\n-154\n1\n-685\n-657\n-38\n-727\n-428\n-293\n-68\n-203\n-850\n-775\n-545\n-740\n-683\n-728\n-502\n-520\n-44\n-53\n-826\n-555\n-539\n-291\n-435\n-673\n-865\n-114\n-467\n-679\n-598\n-611\n-566\n-606\n-320\n-124\n-430\n-240\n-85\n-549\n-847\n-481\n-444\n-792\n-695\n-405\n-427\n-292\n-533\n-91\n-5\n-546\n-181\n-156\n-488\n-29\n-17\n-572\n-510\n-663\n-321\n-177\n-516\n-85\n-829\n-109\n-236\n-876\n-141\n-427\n-180\n-576\n-45\n-178\n-6\n-236\n-381\n-638\n-144\n-391\n-739\n-43\n-898\n-896\n-395\n-280\n-712\n-127\n-823\n-130\n-783\n-324\n-29\n-136\n-941\n-816\n-712\n-120\n-639\n-209\n-522\n-618\n-205\n-557\n-153\n-451\n-280\n-214\n-683\n-134\n-329\n-403\n-156\n-645\n-194\n-811\n-377\n-161\n-620\n-920\n-225\n-632\n-543\n-658\n-864\n-137\n-928\n-616\n-728\n-145\n-182\n-879\n-595\n-598\n-409\n-934\n-23\n-58\n-301\n-427\n-599\n-562\n-373\n-656\n-360\n-783\n-68\n-228\n-712\n-912\n-260\n-490\n-588\n-481\n-610\n-615\n-180\n-914\n-960\n-462\n-522\n-782\n-617\n-687\n-477\n-934\n-54\n-201\n-279\n-101\n-27\n-759\n-407\n-187\n-202\n-715\n-488\n-206\n-802\n-737\n-18\n-364\n-325\n-155\n-573\n-536\n-769\n-747\n-669\n-856\n-521\n-24\n-921\n-394\n-726\n-251\n-5\n-533\n-923\n-752\n-28\n-775\n-100\n-801\n-22\n-723\n-383\n-952\n-355\n-1058\n-975\n-975\n-706\n-843\n-75\n-124\n-150\n-98\n-1019\n-195\n-342\n-915", "snpParentIdO": {"SnippetId" :"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d0577089-2f95-4c4f-ab4d-8940a394ea5b"}, "snpName": "Day 5 code", "snpContent": "|]\n\nlet testInput = [| 0 ; 3 ; 0 ; 1 ; -3 |]\n\nlet getInstr (steps: int []) pp =\n    let instr   = steps.[pp]\n    steps.[pp] <- instr + 1\n    instr\n\nlet solve get (stepsI: int []) =\n    let steps           = Array.copy stepsI \n    let mutable pp      = 0\n    let mutable counter = 0\n    \n    while pp < steps.Length do\n        let instr = get steps pp\n        pp       <- pp + instr\n        counter  <- counter + 1\n    counter, steps\n    \nsolve getInstr testInput\n|> printfn \"Puzzle 5.1 = %A\"\n\nsolve getInstr steps\n|> fst\n|> printfn \"Puzzle 5.1 = %A\"\n\nlet getInstr2 (steps: int []) pp =\n    let instr   = steps.[pp]\n    steps.[pp] <- instr + if instr >= 3 then -1 else +1\n    instr\n\nsolve getInstr2 testInput\n|> printfn \"Puzzle 5.2 = %A\"\n\nsolve getInstr2 steps\n|> fst\n|> printfn \"Puzzle 5.2 = %A\"", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [{"SnippetId" :"61c4050b-83dd-4a8e-aafd-f64fc2ae4954"}, {"SnippetId" :"9650c84b-d384-4bbf-b43c-0e997fb616e8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7791cff0-6654-4b0e-b75c-a4bb7ddca919"}, "snpName": "Day 6", "snpContent": "let input = \n    \"10\t3\t15\t10\t5\t15\t5\t15\t9\t2\t5\t8\t5\t2\t3\t6\".Split '\\t'\n    |> Array.map System.Int32.Parse\n    \nlet test = [| 0; 2; 7; 0 |]\n\nlet step (input: int []) =\n    let copy = Array.copy input\n    input \n    |> Array.mapi  (fun  i  v  -> i,  v)\n    |> Array.maxBy (fun (i, v) -> v, -i)\n    |> fun (p, m) ->\n          copy.[p] <- 0\n          for i in 1..m do\n              copy.[(p + i) % copy.Length] <- copy.[(p + i) % copy.Length] + 1\n    copy\n\nopen Useful\n\n#define WEBSHARPER\n\nlet rec solutionR input history = \n    let next = step input\n    let pos  = List.tryFindIndex ((=)next) (input::history) \n    pos\n    |> Option.map(fun n -> history.Length + 1, n + 1)\n    |> Option.defaultWith (fun () -> solutionR next (input::history))\n\nlet solutionNR inputP = // Javascript cannot handle tail recursion\n    let mutable input   = input\n    let mutable history = []\n    let mutable result  = None\n    while result = None do\n        let next = step input\n        let pos  = List.tryFindIndex ((=)next) (input::history)\n        result  <- pos |> Option.map(fun n -> history.Length + 1, n + 1)\n        input   <- next\n        history <- input::history\n    result.Value\n\nsolutionNR input  \n|> printfn \"Puzzle 6 = %A\"\n\n\n", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9ab13c25-ea79-454d-83e3-2287448e8e8b"}, "snpName": "Day 7", "snpContent": "let input = \"\"\"\nllyhqfe (21)\nvpbdpfm (74) -> ndegtj, wnwxs\ndosteiu (262) -> vliyv, rfxmk, nulxd, tckql\nleqnli (222) -> wuttw, nckca\ncgztcyz (59) -> zbtmpkc, lleaucw, zxvjkqv, tqjyoj\ndqfti (67)\nvsjhe (34) -> zpbbgqh, menyi, ksasli, uahdbi, ccfiz, kdwmlx\nntzuhe (98)\nmpjrzt (53)\ndnzll (23)\nensyb (18) -> usvzfi, uxxtnll, phrkfo, vntjo\nairqzst (39)\nhfzvg (26)\nwpojcme (79)\nxggisxm (37)\njkqcelt (35)\napjsu (299) -> rgylin, yrmfcs\nodoni (18)\ngzatvf (27)\nazkpaf (81)\ndnyaj (76)\nchfcnsc (70)\nwjdkcjo (29) -> jdntuc, htaxf, edpqtnn\nbejkc (194) -> lqjnh, xkfwmh\nlfapaod (97)\neidqfh (24)\nhaeyms (23) -> akxrge, qgqrmeu, nsnhdll, ydyvay\nialdd (67)\notqufza (116) -> dvasofv, mxdxz\njbopt (91)\nmkxsdn (46)\nvkcim (63)\nypokgio (14)\nwiihwvv (55) -> mivrqpc, hdqgdm, muulq, tveyfha\nrvdldy (47)\nxzsfek (87)\nshkfwm (26) -> yjpzyzx, vdnvw, nsbyncu, wpafb\njdryrup (43)\nzqxhle (53)\nxaaqdv (21) -> kxkwc, mpwnd\nlfmlqs (79)\nmcctaf (37)\nqewiy (18)\nlfzvi (240) -> gxmqlu, sfteyu\nzbtmpkc (94)\njaathmh (33)\nsjwxyqb (55)\nwxvsp (187) -> umiohmp, zeauj\nopghigg (97) -> dletgs, bcgqdc\nkabjov (239) -> eulcspz, nxttce\njivdw (14)\nnckca (6)\nnfeok (203) -> apqan, ywtywz, inoyp\nejyegf (71)\nccmfbok (82) -> jbopt, cteuws, rrsxb, atfjks\nqizkjh (350) -> mxsacj, liiwwfa\ntdfirdf (62)\njwboky (54)\nksnnnc (638) -> iuuzow, eiyvtz, dlxcy, ltfbsgc\nmhbiyxk (15396) -> ehpfjr, zqgeod, hiccoc\nbzenp (37)\nuymhfo (37) -> wiihwvv, jgpsybl, zpxuxph\nvewathl (261) -> bzbxoa, ntzbt, jsizfuj, ikrlxqw\nbvqhn (82)\njqtxjrm (1199) -> aqkclfk, eipaxu, hzvctd, zpohg\nkfuwkh (52)\naamghal (79)\njqywsxa (74)\nehpfjr (42) -> sdxwhvp, itdxbrj, cgztcyz, awylric\ngxmyk (166)\nbeknji (29)\nahvdop (50)\nfpuhllh (8)\ncadtows (49)\nshbrz (874) -> hcywj, pkgyjn, hwxxvlb\ntebvlpn (106) -> kfuwkh, nkuhc\njexcm (33)\ngwplv (33)\nnsckvp (49)\nghaxmrh (10881) -> hhosv, ximzx, ztphu\ngkwamq (54)\nvonve (204) -> scxkq, ubsbx\nhmlil (63)\nrpmzw (97)\nfzkqz (75) -> xxyjm, yjqgw, ejyegf\ndfwamci (36)\nbzbxoa (42)\nqlmbqwi (58)\nivygtzl (1708) -> vjfsl, xfvhi, sbhfnav\nvliyv (20)\nmecsrr (81)\nuskdpcu (388) -> nktkgz, xcuud\nvwktc (60)\nfkpjukc (42)\nnsnhdll (70)\ndpgggti (8)\nnxmxgax (70)\nvwntogi (64)\njshekxk (42)\nncxhv (184) -> ddxiiha, hcvuc, tebvlpn, kkjen, wjkalv\nurpzfa (58)\nocrgjl (2738) -> qogmb, qxirdyg, aovhss\ngtxvgr (58)\npsqgnhx (20)\nvkoor (69)\nmzpeoz (50)\nsbebrkf (12)\nzupsoqc (20)\neiyvtz (65) -> modakko, mlydcn\njdvuj (8)\nbytizsx (61)\ndhamym (17)\nzldebh (76)\nesmltj (21)\ntihzzf (701) -> wyeoaxt, hrkhlaq, vyccl, jezmn, nmmrik\nrmriv (27)\nbyiqom (88)\nmnkamc (1717) -> idhjov, pyurvrc, ahpitb\nfvtofr (44) -> jexcm, jokgw, slmnzei\nppkpq (41)\nkxkwc (57)\nepnvhbn (21)\ntusmlk (295) -> ialdd, kipiwwk\nlwqscns (14) -> zgyryw, oiooued\nzbmsz (35)\nczmmh (44)\nfmwid (1567) -> dhbxpw, xkzrkzh, wxvsp, zqyrggw\nsviwi (15)\nnodqkan (89)\nqddbmn (72)\nkiphte (353) -> kfiggar, rncuf\njyajecr (14)\nclqwflm (17)\nkkjen (36) -> rftaqhw, hxtejel\niokwnq (25)\nyelgho (38) -> uiagqs, dzrflyr, tdfirdf\nrgocso (41)\nmdsywgy (70)\nknhvwhl (298)\nzpxuxph (399)\ndhbxpw (19) -> itfnye, yghucrl, ekvkidl\nrxeqfsj (24)\nsjzapjt (85) -> opndzmu, ilexb, tqddro\nnbybi (7) -> vwntogi, mhvzqc\nbnkbyp (73) -> hagkc, arfsqdz, wbzmjq, eisjz\njezmn (40) -> nsmlghl, lakhmm\niwlxpz (18)\nvjfsl (87) -> gccvp, wkble, ilshxl, jqywsxa\nztphu (983) -> picliob, wcblyq, ollvgn\neuwfw (12)\nrccvm (363) -> mutyu, kqltwau\nhifms (54)\nbyldgs (79)\nforycux (37)\nxwwjzx (39)\nqvqzuic (6)\nuylrp (7179) -> apqwz, nsqaxp, yffumkx\njblzpyq (45)\npeexz (96)\nldcaht (98)\nwwggl (157) -> ssxpawm, brjzpkm, woionr\nyyhkwha (179) -> yiehfd, jkqcelt, fuvikt\nrjtdc (44)\nwnwxs (83)\nmsigvaq (96)\nojrggba (69)\npvctv (3341) -> gkwamq, sattu\nctrdahm (24)\nxfvhi (283) -> zkphtd, qmncedz, lsdkm, iokwnq\ngkrtbv (30)\naovhss (185) -> wevhizp, lmnews\ntfpbait (45)\nmkeen (102) -> jttgtsg, phkcge, zxyrq, telnuq\nefbrhl (31)\nwjkalv (54) -> eloku, xwwjzx, etyja, vghvcv\nndois (317) -> csuoxe, jwboky\nvfpwu (712) -> tusmlk, vewathl, jxfbflh, lcefyg, bnkbyp\nzdkgm (13) -> xpkyf, eaqhut\nrhpxizt (449) -> lcnqmai, cpjkn, ccfbpoc\ndmhfz (66) -> ojrui, bkuazfi, yedrd\nbpbwn (97)\ncdglv (1515) -> pbimnll, rcyjnsi, sfnsx, hfdoqqt\nkfcaozk (27)\nlqjnh (38)\nqhjui (47)\nntzbt (42)\natfjks (91)\nkfiggar (24)\nqeoyu (42) -> liukun, tdvorom, knhvwhl, ombds\ntlnuq (76)\nzpedug (76)\narrok (230) -> ypokgio, qonkb\nwvvmksv (21)\nscxkq (33)\niuuzow (117) -> unlwjj, ayfcyul\nbkuazfi (55)\nhrkhlaq (66) -> mwavu, jbtqs\nnbtsze (80)\ndarmn (96)\nkaugsh (378) -> fhzkakn, epdzg, ogsxfk, rzoojpm, dabvuui\nelhxdco (220) -> wmmrhf, tcxkqku\nmgnux (46)\nyzhwurz (136) -> pksyw, osrkwa\nmuulq (86)\nayfcyul (43)\nuryery (39)\nxipivez (33)\nubsbx (33)\ntcxkqku (21)\ndhqjni (17)\nnokkziw (73)\nyzjiby (79) -> numbey, jqtxjrm, ybkdekt, ciwpis, smkqg\nybjghed (91)\naxleb (81)\njfoztzy (37)\nrjoszhu (92)\nvimazqc (93)\nsvhcnju (24)\nmwssex (55)\nwfmmajk (177) -> kfcaozk, pmfbr\nhxjopp (228) -> nsckvp, cadtows\nbieswf (51)\ndabvuui (38) -> nxmxgax, xmtosc, chfcnsc\napqan (38)\nlivac (240)\nkcotwhf (1006) -> jbztwms, pfpmube, bgeec, hhawhzk\nmxdxz (44)\nhhosv (40) -> klnemf, vrzsj, bacazl, gzepcax, onqop, afkeosv, zvlafea\neytppcy (309) -> ltifq, ehxjsgn\nkyzjusc (37)\ngmsmnlz (36)\nmncyztp (1990) -> fsmzfjp, kndrzyc, svvirl\nbnkfzle (261) -> bvqhn, edihrrv\njakfuqo (317) -> sxfxnp, tdrdp\nuxqiqg (95) -> xwyggz, oxtvu, zwtaqj, cxvse\ntftwygl (29)\nytaus (47)\nuxxtnll (81)\nyghucrl (66)\ntnxoqxw (93)\nemkyoy (354) -> rddeecm, dugvnav\nhmorsv (64)\njwidjq (217) -> qfyor, bpsyylv\nkeily (231) -> ueywo, xlpqnhm\numiohmp (15)\nkiuayw (24)\nenuzo (63)\nnoejr (83)\ntveyfha (86)\nohmvcr (98)\nxfzxw (67)\nmodakko (69)\ncwemvgf (85) -> iebsger, mtoqh, ciabx, puzwwgx\nwmmrhf (21)\nvxghl (48) -> umgqr, cbvwcv\ncnvghq (33) -> byiqom, ehljn\niemkgdl (79)\ngpucfv (270) -> bscob, leyohju\nmlydcn (69)\ngsgexgb (90) -> cwemvgf, cukbzsw, iaiqz, gveadp, rccvm\niybrmf (27)\nfrruz (7530) -> pkrxt, ifwkgxo, abpry, dydso, fjjuj, sgfbfq\nxxvlxs (37)\nuqttm (33)\neryxwj (90) -> vxtwg, bmtjkw\nbsdxw (29)\nffxkad (91)\nciwpis (1215) -> elhxdco, ccmod, etuteik, jaxkva\nzzxzeuo (62)\nqycoh (66)\nsuprw (34) -> vpbdpfm, kacamw, dwdczlx, mrqaryt, rjnzfa\nefpvvp (7686) -> mncyztp, tleviy, uuftjqx, vsjhe, mmutg, wzvjkiu\nbpsyylv (17)\nthmnm (80)\nrvpbx (256) -> zwxlf, ojrggba\nndegtj (83)\nksasli (331) -> cyxtnfe, xrtkqi\nvyfbsgv (81) -> rwxfhk, kihifp, ndois, kupmpp, eytppcy, bnkfzle, fycnyn\nkjyufi (37)\nykxkv (299) -> ijzgy, dsbxavd\nwnfcsap (32)\nicoti (69)\nakowch (67)\nxlpqnhm (59)\nyzrfzv (73)\njmmbca (91)\nmfacoz (23)\nbcgqdc (77)\nohbfa (79)\nnumbey (1861) -> lwqscns, arlrk, klqvgm\nkfgyus (42)\ndlfay (16) -> zksnaz, miocbjk\ndwdczlx (162) -> cmdcov, pbhsevc\nliiwwfa (22)\nikrlxqw (42)\nfwbang (99684) -> lvxnl, aspplbw, uylrp, yzjiby\nryzfgj (44) -> lrbozkj, mpjrzt\nzrjtxfa (9314) -> iixjr, vfpwu, ivygtzl, vgwfukr\nmkxatmb (91)\nzxmsme (66) -> lgjbhwy, jugycbw, dnzll\nhxtejel (87)\nrsblo (385)\nrqbgxlt (24)\nrbbhhe (91)\nkcbag (36)\nfdorzyx (49)\nlcnqmai (12)\ndvpmg (1474) -> uagszs, otqufza, mjmpkq\nlakhmm (99)\nzxyrq (18)\nfthgkl (55) -> ekuibos, zmtszz, peexz\nonqop (60) -> bnryi, kjyufi, kyzjusc, elukq\ntismupk (86)\nhhrqbn (75)\ncycky (75)\nxksjes (103)\nufhjnc (106) -> rbbhhe, ybjghed\naqkclfk (88) -> nodqkan, tahov\nfuehgn (175) -> dnliq, dhqjni, ruszodn, cjagg\nafkeosv (181) -> qfwtxzq, aowuj, trkvrk\nbrdkwc (45)\nyedrd (55)\nwyeoaxt (104) -> inlzx, akowch\nowfrl (1516) -> rsblo, hfytix, ggwwhvf, ykxkv\ngosjs (24)\nmxsacj (22)\nosrkwa (32)\ndrffb (15)\nzsucroj (76)\nermgcbt (78)\njpjehc (37)\nvdnvw (58)\nholcy (66) -> frruz, hbzxaji, mhbiyxk, zrjtxfa, efpvvp, acmrndk, trrkrqa\ngjbijgl (64)\nlphqgek (21) -> qdpnoic, qvjiwvb, qxoly\nuhsdpj (72) -> rslnx, bmaoav\nakxrge (70)\nyerckb (255) -> dpgggti, ssysjwe\neipaxu (150) -> qlmbqwi, fsuglk\npbhsevc (39)\npfmordc (36)\nrdjfp (1393) -> dmhfz, wfmmajk, utoogeb\ntpbbd (91)\ndexwo (223) -> fqjdoe, ovpyq\nhwinqpr (27)\nmqgmc (150) -> vkoor, hvdwvo\nqrhweil (99)\nkrdsv (24)\ndydso (1002) -> evbilqr, glbaxl, yzhwurz, usubx, uxxyr, gremk\nwowirye (47)\neaqhut (70)\nilshxl (74)\nyqsfolo (11) -> vrdrc, utqxez\nqniem (85) -> qdnuduv, zsseyik, xxardqs, xafip, uhsdpj, xxehapc, pmwosk\nojbyg (21)\nvkwcj (96)\nrtvpznv (257) -> emxviup, dfwamci, pfmordc, ikcjmxi\nabpry (1005) -> uxqiqg, adxplm, xlbjv\nnhtetdw (29)\nzstbuv (60)\nzmtszz (96)\nnfccf (26) -> zpqpd, skbxo, hzkvyoj, fhivbs\nkrkeek (52)\nowgbqb (30)\ntekug (77)\njaxkva (138) -> zzxzeuo, npxeql\nhqqxg (43)\nungfmbw (61)\nedpqtnn (96)\nydyvay (70)\nniopwq (42)\njgpsybl (317) -> ppkpq, fezoee\noyypq (142) -> iwxgwc, qyovvxb\ninlzx (67)\nedihrrv (82)\nqsloy (44)\nyffumkx (9) -> jakfuqo, ouxsgm, keily, pshyy\nfhivbs (92)\nfkprhv (31)\nrhgyz (38)\neiyxgk (76)\npzemz (76)\nlcefyg (353) -> twvjddq, rhgyz\nvrpyfgm (88)\nhfytix (81) -> cjctf, fckcu, ztcqm, pzemz\nvoiqnou (147) -> czmmh, rjtdc\nozwdh (96)\nekhsrgq (25)\nxmtosc (70)\nyfrewb (77)\nqfyor (17)\nijuod (93) -> ldcaht, ruuhrmf, dfbabey, bbdfr\npknpuej (91) -> livac, vxghl, qcccxc, mxprsl\ngwvsbo (76)\nfqjdoe (39)\ngqahoa (57)\nvykav (89) -> dfhtf, yopex, ypzxdhs\npicliob (97) -> bzenp, jfoztzy\nfhzkakn (107) -> wowirye, aseilg, jmutqq\numgqr (96)\nqmlguo (96)\ngosak (27)\nnvatz (63)\nzsgnve (39)\nfyvjfxi (58)\noxtvu (76)\nhoewyjx (47)\nqykdedu (63)\ntocrk (88) -> nzyls, qlgljuh\nssnoqt (24)\nmhvzqc (64)\narfsqdz (89)\nvrzsj (127) -> tetfdv, ornacig, yrdbx\ntszune (40)\njcuhfsd (80) -> sordz, zmfhyr\ndqaov (96)\njeafpic (32)\ntdvorom (246) -> hfzvg, dapey\ndldcoc (149) -> gwvsbo, eadjn\nngxtfx (91)\noiooued (60)\nnmhmw (979) -> krdsv, kiuayw, rovftl\nyqmbbyr (24)\nzvlafea (140) -> wtjoxu, dxszgsr\nuiagqs (62)\nlhpjahj (86)\nuagszs (36) -> cflribm, dsukkg\numqlwls (202)\npazby (45)\nmqayze (55)\nnzeqmqi (12216) -> nmhmw, pknpuej, rfkvap\nhfdoqqt (128) -> sevcqp, bieswf\nejmfnnu (43)\nhupmm (76)\nwnahs (18)\noomve (87)\nhdfsofm (75)\nqonkb (14)\ncnlny (278)\nogsxfk (140) -> iybrmf, xixiloi, hwinqpr, jdmrbxc\nnafdo (23)\njsizfuj (42)\nmwavu (86)\nciabx (96)\nljwcd (16) -> nokkziw, cjgpfb, yzrfzv\netyja (39)\nhcrzxz (78)\nxwyyfr (256) -> jyajecr, jivdw\nlrbozkj (53)\noibnbf (15)\nbbdfr (98)\nzwzgp (14)\nsvvirl (62)\ntlkrx (23)\nkndrzyc (62)\neuenhl (53)\nipvrlll (86)\nggwwhvf (160) -> hhrqbn, zvazn, hdfsofm\nsofrg (281)\njyovf (29)\nagobkww (69)\ngzepcax (50) -> wpojcme, pprspr\ncxvse (76)\nrftaqhw (87)\nyzbmyaw (86)\njjbmtij (54)\nwhuozum (35) -> suftfkn, gtxvgr, igxdio\njxfbflh (229) -> xkyocjn, ahvdop, ewlsf, jejwwxj\nwoionr (15)\npkgyjn (76) -> urpzfa, fyvjfxi\npwydnik (63)\nchhli (46)\ngdvcou (189) -> jdglmn, mgnux\ncbvwcv (96)\ngtiqar (29)\ntxcwm (29)\nfvojv (116) -> rycpngd, hifms\ndzxjy (96)\nniznnko (44)\njmutqq (47)\nsevcqp (51)\npmfbr (27)\nshoxg (7)\nltfbsgc (109) -> rvdldy, qhjui\nltifq (58)\njxzyg (37)\njttgtsg (18)\nzwtaqj (76)\nmwussz (143) -> etotvx, lbmvl, xlavrvm, rmriv\nzwlok (143) -> zvtgd, shoxg\nhcywj (102) -> brdkwc, tfpbait\nkbuslbp (81)\nsmunvi (172) -> zqxhle, euenhl\nqlgljuh (26)\ngwcqtcr (73)\nkacamw (170) -> bexrple, wetutqh\ndvkbqm (20)\neaerpmi (1342) -> rjoszhu, migwxez, izydgv\nealilsq (50)\neisjz (89)\nrihil (12)\nysabu (24)\nombds (178) -> wlrihpy, vwktc\nsueftvh (81)\nmrqaryt (80) -> thmnm, kligtj\nxkyocjn (50)\nprywl (43)\nfonky (47)\nbhddwe (64)\nmtoqh (96)\npksyw (32)\njndnfa (45)\nguqul (222) -> oonfc, irpjsbf\nnkuhc (52)\napqwz (934) -> gjvcdp, fnuzrye, zwlok\nojrui (55)\ntckql (20)\numsilqj (32)\nxswwe (212) -> ffxkad, ngxtfx\nhwtztim (187) -> idaqt, jshekxk\nnuzxo (83)\nitfnye (66)\nqcedbm (2484) -> bkipqaq, xmcqygt, fvtofr, zjksxbk\njutbah (55)\nscntyh (5)\nliukun (70) -> oftcgd, eiyxgk, sqbfin\nvqxwlkh (8119) -> kcotwhf, ksnnnc, shbrz, jtxdihn, yixpr\nywqtog (136) -> epelgzz, lpvwee\noftcgd (76)\nrdzvcb (184) -> clqwflm, dhamym, qkmkjm\ntqjyoj (94)\npprdw (42) -> tpbbd, mkxatmb\nbgmypwk (22)\nhznriv (96)\ntleviy (973) -> rtvpznv, gbpxwcx, kiphte\ncsuoxe (54)\npqqcnkr (39)\nhcqrrju (100) -> xfzxw, zwyhf\namccpoz (254) -> zsaen, jfkvg\nwbzmjq (89)\nxpkyf (70)\nhnofc (85)\ndsukkg (84)\nqfifp (6)\nqmncedz (25)\ndyrik (37)\niaiqz (445) -> sgjywom, alwbi\nxpjzc (86) -> qrhweil, vsgqkho\nagagr (81)\nfpkktd (25)\nmjmpkq (44) -> nbtsze, hwlgay\nkwhtsv (26)\nawljibm (5)\nhssykro (81)\nvyccl (80) -> aamghal, tkwmbxl\nnelgvnr (2052) -> jwidjq, mwussz, nkuwwiy, opghigg\nzbhioc (20)\nzqgeod (1323) -> sbnod, rtxzoap, zdkgm\nrgqjtw (243)\nvaxouij (343)\njsrpud (57)\nwetutqh (35)\nlsdkm (25)\nsdttg (27)\narlrk (40) -> xlsmzu, hoewyjx\nybkdekt (1234) -> vaxouij, fthgkl, kabjov\nsebno (279) -> qfifp, ghxvqb, qvqzuic, wfazzy\nkeidsd (73) -> hqqxg, ejmfnnu, prywl\nuevcnw (39)\nzvazn (75)\nxdjola (63)\nmiocbjk (75)\nghxvqb (6)\nywtywz (38)\nvtpoo (89) -> vskibye, nelgvnr, qcedbm, owfrl, vyfbsgv\njlfukd (57) -> tnxoqxw, vimazqc\nvkxyhk (41)\ndlxcy (203)\nkosbvn (19)\nwfazzy (6)\nuufonho (46)\nkdwmlx (357)\nlokmiua (2132) -> hdrab, eftrvo, hbnnhyi, avnxndg, tihzzf, nbvtfz, qniem\ndugvnav (46)\nxxardqs (216) -> llyhqfe, ojbyg\nwkble (74)\nlpvwee (67)\npkrxt (1524) -> drwpdaj, ojcinc, hqetmky\nzjksxbk (143)\niebsger (96)\nofwijoe (60)\nqyovvxb (41)\nigxdio (58)\nxkzrkzh (148) -> nafdo, tlkrx, gclbhxw\nruszodn (17)\ndnliq (17)\nqcccxc (114) -> ibiuha, byykf\nbscob (28)\nmivrqpc (86)\nyiehfd (35)\nhbnnhyi (1055) -> ptnjpp, hqcxvkr, aqlvute, yqsfolo\njpexkf (86)\nhagkc (89)\nhlscl (214) -> jblzpyq, jndnfa, twvfw, pazby\nirrca (56)\nsgjywom (12)\nepdzg (248)\nyixpr (1141) -> pjlhta, xksjes, icfxlu\nyjtsmy (85)\ninwmb (53046) -> ghaxmrh, vqxwlkh, nzeqmqi, lokmiua, znypga, vtpoo\netuteik (262)\nwbtqez (87)\nlmnews (26)\nzoovdc (75)\nsmkqg (44) -> vyzukfk, nfeok, apjsu, vbjlbhq, wjdkcjo, ztstgc, olvxzb\ntelnuq (18)\njdmrbxc (27)\nrrsxb (91)\ntetfdv (27)\ncpjkn (12)\ngveadp (429) -> zbhioc, psqgnhx\nzxvjkqv (94)\nmmvszx (12)\nxkfwmh (38)\nvyzukfk (255) -> efbrhl, tqdfypr\ngbpxwcx (77) -> azkpaf, axleb, ngwafk, sueftvh\nblcnplx (32)\ntrkvrk (9)\nnxttce (52)\nrzoojpm (234) -> kbguoiu, yvjjec\nidhjov (49) -> mcctaf, jpjehc\nctnucjw (105) -> ohmvcr, ntzuhe\ntdrdp (16)\nqkmkjm (17)\nbacazl (82) -> enuzo, hmlil\nlgjbhwy (23)\netotvx (27)\npfkbcg (228) -> xkvtxav, oibnbf\nfjlqp (30)\nnsbyncu (58)\nxnackkp (33)\nsxfxnp (16)\nhhawhzk (89) -> dserbhu, ckfagrp\ndsbxavd (43)\nmtbszl (12)\nbkipqaq (71) -> ctrdahm, sptjz, svhcnju\nsndkiv (73)\nidaqt (42)\nsxcfr (98) -> ungfmbw, ynjccf, bytizsx\ngtutcoq (154) -> zqmizps, vxdcv, nmshjlp\nefxxl (69)\nnpxeql (62)\nljelubc (437) -> gwxgtm, umfqiru\nhzbtbe (46)\nbjvncf (49)\nhwxxvlb (48) -> qddbmn, vomiow\nsfteyu (19)\nsbhfnav (255) -> jeafpic, ywecj, wnfcsap, cvgzkp\nbmaoav (93)\nfnuzrye (125) -> vlqcuq, jdvuj, mykvbt, fpuhllh\nvsgqkho (99)\nvkbgz (63)\nrcyjnsi (206) -> rihil, usfvqn\nhdqgdm (86)\nunaqbx (23)\numyrtu (33)\nsordz (47)\nbyykf (63)\nqggexrc (33)\nrovftl (24)\nqdnuduv (120) -> icoti, efxxl\nqogmb (81) -> rnyqcj, hcrzxz\ndfbabey (98)\nvdmkp (38)\nkacpu (90) -> hrbfs, vdmkp\njcegjy (92) -> xoaxcg, mecsrr\nxrtkqi (13)\ncosllh (38) -> hzfwp, gjbijgl\njfkvg (15)\nifwkgxo (1752) -> pbrcoyl, ryzfgj, luswq\ngrcsr (64)\ndzrflyr (62)\nhjtwqe (748) -> mkeen, zowbv, lphqgek, jcuhfsd, qymfgaf\nyjqgw (71)\nidiorl (24)\nusvzfi (81)\nacmrndk (13437) -> cdglv, gsgexgb, fmwid\nvijilqr (271)\ndxszgsr (34)\nehljn (88)\nyutfxcu (72) -> wobno, mwmfw\nngwafk (81)\neijlg (51) -> dzxjy, msigvaq\npkchh (24)\nizydgv (56) -> odoni, wnahs\nwobno (93)\nidfxtqr (96)\nhqetmky (127) -> gwplv, umyrtu, uqttm\nfvjrau (166) -> qsloy, niznnko\nehxjsgn (58)\nhqcxvkr (37) -> oeyrk, ipvrlll\nvaztjkc (75)\nynnfzdz (54)\nvrdrc (99)\nhdrtnjm (273) -> drffb, sviwi\nywecj (32)\niixjr (99) -> hlscl, xswwe, gtutcoq, qizkjh, nfccf, rvpbx, extmwcb\nfuvikt (35)\nkipiwwk (67)\nlakzkpk (84) -> rpmzw, lfapaod\nextmwcb (142) -> vkcim, ihramd, kwkdq, hjwjw\npmwosk (118) -> leefit, mdsywgy\nruuhrmf (98)\ntqdfypr (31)\nitdxbrj (366) -> fjebkm, mfacoz, unaqbx\nkfgmuj (54) -> ljelubc, jlewu, rhpxizt, pjujpa, ijuod, xauyij, bbrdet\njtxdihn (45) -> sofrg, vgdtk, sxcfr, rmivzpg, gdvcou\nyzulmo (33)\nuuamcdc (1954) -> qycoh, jhbov\nochjr (68) -> xhujxe, fonky, olyohzo\nnbvtfz (807) -> hwtztim, yerckb, nyszg, vijilqr\nimtvzmm (40)\ntshcqcu (33)\novsgve (83)\nueywo (59)\ngxmqlu (19)\ntahov (89)\nelukq (37)\nzadsb (87)\nbgeec (53) -> tftwygl, txcwm\nyjpzyzx (58)\nxlbjv (288) -> jxzyg, dyrik, cdanu\nzsaen (15)\nqywtwbt (124) -> esmltj, qsppfv\ndwbirs (5)\noonfc (16)\npyurvrc (49) -> xwidhe, xxvlxs\nzksnaz (75)\nxhujxe (47)\nwctphrv (19)\notadcxu (2028) -> bsdxw, beknji\nhzkvyoj (92)\nzeauj (15)\nzayxe (2822) -> ochjr, cnvghq, whuozum\naqlvute (27) -> absogx, jmmbca\nilexb (72)\nvrdtrmn (69)\ndfhtf (79)\nsbnod (153)\nlwyirb (77)\nhwlgay (80)\nsfnapsi (55)\ncflribm (84)\ncjgpfb (73)\nmenyi (185) -> lhpjahj, yzbmyaw\nubkmjag (78)\nfycnyn (313) -> lwuvg, irrca\nrzixiwv (10)\nqtvcuqk (85)\nalwbi (12)\nsqbfin (76)\nhcvuc (78) -> yzulmo, xnackkp, qggexrc, wjdhaf\nccmod (13) -> ovsgve, noejr, nuzxo\nrslnx (93)\nopndzmu (72)\nmxprsl (84) -> uivazm, ennkek, krkeek\nzowbv (28) -> sndkiv, gwcqtcr\npjujpa (433) -> rgyaijv, kwhtsv\nrnyqcj (78)\nzwxlf (69)\nccfiz (231) -> pwydnik, vkbgz\nzqyrggw (61) -> qqbgbeo, ubkmjag\npuzwwgx (96)\nxwidhe (37)\nasmikyo (24)\nhdrab (1083) -> umqlwls, tuldcdj, keidsd, wwggl\nximzx (146) -> ywqtog, bejkc, vonve, wmdgia, ggeae\nhzfwp (64)\nwmdgia (14) -> bhddwe, zrzgp, hmorsv, grcsr\npfpmube (73) -> wctphrv, kosbvn\neadjn (76)\ntxplq (24)\nqsppfv (21)\nqxoly (51)\nsardhwu (77) -> iemkgdl, byldgs\nvlqcuq (8)\neloku (39)\nypzxdhs (79)\nfsmzfjp (62)\nzqmizps (80)\nqqpnt (1108) -> hxjopp, gpucfv, vykav\naowuj (9)\nxlsmzu (47)\njokgw (33)\nepelgzz (67)\ncjctf (76)\nqgqrmeu (70)\neulcspz (52)\nsattu (54)\nvgdtk (101) -> ggffqux, jlinuge, hvinb\nbrjzpkm (15)\nyvlwtb (114) -> wbtqez, zadsb\nssysjwe (8)\nptnjpp (135) -> forycux, xggisxm\nadxplm (295) -> nfxyjl, lksgoz\nqvjiwvb (51)\nlleaucw (94)\nabsogx (91)\nzflsryn (239) -> fkprhv, blloue\ninoyp (38)\nluswq (102) -> yhlyk, mmvszx, euwfw, sbebrkf\nrncuf (24)\njdntuc (96)\ngremk (86) -> gqahoa, jsrpud\nmutyu (53)\nyhlyk (12)\newlsf (50)\nxixiloi (27)\nwoiwqf (5)\nfckcu (76)\nddxiiha (16) -> bpbwn, uuxhyt\nnmmrik (73) -> jutbah, sjwxyqb, mqayze\nssxpawm (15)\nrksykyt (77) -> ohbfa, lfmlqs\nzwyhf (67)\njhbov (66)\ntqddro (72)\naafpxpx (30)\nzsseyik (248) -> awljibm, woiwqf\nvxdcv (80)\novpyq (39)\nznypga (14031) -> emkyoy, uskdpcu, ccmfbok\ngwxgtm (24)\nztstgc (125) -> jqwbc, darmn\nusubx (100) -> mzpeoz, ealilsq\nklqvgm (56) -> zsgnve, pqqcnkr\nuuxhyt (97)\nyjxneui (76)\nawylric (393) -> wvvmksv, epnvhbn\nwtjoxu (34)\nztcqm (76)\nwjdhaf (33)\nhrase (25)\nllcpsj (178) -> mwssex, sfnapsi\nhrbfs (38)\nvomiow (72)\nuumrue (29)\nxxyjm (71)\nyrdbx (27)\ndserbhu (11)\ntrrkrqa (48) -> awytebt, ocrgjl, zayxe, pvctv, sdovaq, kfgmuj\nxoaxcg (81)\nsdxwhvp (192) -> agagr, hssykro, kbuslbp\nbeqez (142) -> mtbszl, dytsvc\nkihifp (117) -> tekug, lsxwznl, lwyirb, yfrewb\nfwlyuh (70) -> zbmsz, btldlkh\ncvgzkp (32)\nmigwxez (72) -> rzixiwv, bwekmvc\njqwbc (96)\nihramd (63)\nbwekmvc (10)\noeyrk (86)\nccfbpoc (12)\nbexrple (35)\nrtxzoap (153)\nbvwnlaw (88)\npbimnll (136) -> pkbitw, ytaus\nzciuy (63)\nzvtgd (7)\nuuftjqx (1414) -> guqul, jcegjy, fvjrau\nqymfgaf (66) -> gzatvf, sdttg, gosak, pcacjm\nesbnpk (43)\nekuibos (96)\nazyccec (67)\nvghvcv (39)\nicfxlu (31) -> asmikyo, gosjs, fafrerl\ncmdcov (39)\nrjnzfa (192) -> eidqfh, yqmbbyr\nqxirdyg (121) -> mwhopi, jyovf, nhtetdw, tmvjt\nwlrihpy (60)\nnyszg (95) -> bvwnlaw, vrpyfgm\nhiccoc (1118) -> osbsdhc, dlfay, fsomlm, cosllh\nixiqnn (138) -> vthnh, cycky\nuahdbi (313) -> bgmypwk, rzxyny\nahpitb (25) -> yyoptv, qihhif\nzrzgp (64)\nxxehapc (120) -> vrdtrmn, agobkww\nkwkdq (63)\nprhgge (49)\nornacig (27)\nwuttw (6)\nsjbalvv (186) -> uufonho, chhli\nxauyij (427) -> uumrue, gtiqar\nthahonu (208) -> eacnma, fpkktd\nvgwfukr (1921) -> hcqrrju, ckqwb, leqnli, xavfse\npshyy (97) -> qykdedu, zciuy, nvatz, xdjola\ntkwmbxl (79)\nphkcge (18)\nszrnpdw (27)\nfafrerl (24)\naryqw (118) -> ysabu, pkchh\ntwvfw (45)\nyopex (79)\nsptjz (24)\nmwmfw (93)\nsuftfkn (58)\nfjjuj (1782) -> fwlyuh, tocrk, eryxwj\njbztwms (111)\nollvgn (15) -> ermgcbt, kjikhxm\npcacjm (27)\nnldrlb (55)\nyyoptv (49)\nqfwtxzq (9)\nxavfse (42) -> hznriv, vkwcj\npbrcoyl (40) -> nldrlb, wnhseb\ndytsvc (12)\nwpafb (58)\naspplbw (4922) -> eaerpmi, hjtwqe, fikvmjg, kaugsh\nmpwnd (57)\nxmcqygt (65) -> uryery, tlkive\nwevkksz (49)\nikcjmxi (36)\nojcinc (106) -> fjlqp, owgbqb, aafpxpx, gkrtbv\njbtqs (86)\nlksgoz (52)\ntntqpl (202) -> jdryrup, esbnpk\nzpbbgqh (53) -> zpedug, hupmm, yjxneui, zldebh\nrgylin (9)\njdglmn (46)\npkbitw (47)\nrfxmk (20)\nmykvbt (8)\ntwvjddq (38)\nslmnzei (33)\nzpqpd (92)\nlvxnl (3990) -> qeoyu, uymhfo, suprw, ncxhv, drrbwlp, kzwamsk\nfikvmjg (70) -> arrok, thahonu, pfkbcg, yutfxcu, shkfwm, clsve\nekvkidl (66)\niwxgwc (41)\ncbwsr (55)\nkqltwau (53)\njlewu (320) -> zphlpeu, kcxfwz, cbwsr\nbnryi (37)\ndletgs (77)\njlinuge (60)\nennkek (52)\nrzxyny (22)\nuivazm (52)\nhgoesez (214) -> umsilqj, blcnplx\nxkvtxav (15)\nclsve (138) -> ofwijoe, zstbuv\nleefit (70)\nymwqj (301)\nklnemf (76) -> xipivez, tshcqcu, jaathmh, vpzylgj\nqdpnoic (51)\nfsuglk (58)\ndvasofv (44)\ncjagg (17)\nkcxfwz (55)\nkjikhxm (78)\nnulxd (20)\nzgyryw (60)\nnktkgz (29)\npprspr (79)\nwzvjkiu (2006) -> yjtsmy, gjpjta\nusfvqn (12)\nutoogeb (183) -> idiorl, txplq\ngclbhxw (23)\nfsomlm (74) -> hzbtbe, mkxsdn\npxjgtg (219) -> uevcnw, airqzst\nnfxyjl (52)\nhtaxf (96)\nouxsgm (241) -> ynnfzdz, jjbmtij\ncdanu (37)\nzpohg (230) -> qewiy, iwlxpz\nnmshjlp (80)\nuxxyr (26) -> oomve, xzsfek\nwcblyq (171)\nqqbgbeo (78)\nibiuha (63)\nippnuw (342)\njusoe (27)\neftrvo (919) -> rgqjtw, fuehgn, eijlg, jlfukd\nrgyaijv (26)\nfezoee (41)\nzmfhyr (47)\nmxltn (14)\nrfkvap (655) -> zxmsme, nbybi, xaaqdv\numfqiru (24)\nsyeyppr (20)\ntuldcdj (152) -> ekhsrgq, hrase\nskbxo (92)\nlwuvg (56)\nhzvctd (256) -> dwbirs, scntyh\ncteuws (91)\ngjpjta (85)\nijzgy (43)\nrddeecm (46)\nhvinb (60)\ngsrui (49)\nvxtwg (25)\nvthnh (75)\nolyohzo (47)\nbtldlkh (35)\nlbmvl (27)\ngjvcdp (23) -> azyccec, dqfti\nspnzn (70) -> ixiqnn, llcpsj, ufhjnc, fzkqz, mqgmc, tntqpl, yvlwtb\nfjebkm (23)\nkupmpp (41) -> qmlguo, dqaov, ozwdh, idfxtqr\nawytebt (2553) -> oyypq, pprdw, fvojv, yelgho\nrycpngd (54)\nvpzylgj (33)\nosbsdhc (166)\nbdplsy (20)\nwnhseb (55)\nemxviup (36)\nazqje (72) -> holcy, fwbang, inwmb\nblloue (31)\ngccvp (74)\nsfnsx (83) -> prhgge, bjvncf, wevkksz\nnylej (42)\nzkphtd (25)\ndrwpdaj (58) -> nylej, fkpjukc, niopwq, kfgyus\nolvxzb (89) -> tlnuq, zsucroj, dnyaj\npjlhta (63) -> zupsoqc, dvkbqm\nxafip (176) -> rgocso, vkxyhk\nqihhif (49)\nggffqux (60)\nbbrdet (445) -> bdplsy, syeyppr\nvbjlbhq (219) -> gsrui, fdorzyx\nmwhopi (29)\neacnma (25)\ndrrbwlp (59) -> ljwcd, voiqnou, rdzvcb, sardhwu, rksykyt\ndapey (26)\nrmivzpg (227) -> szrnpdw, jusoe\nckfagrp (11)\nnkuwwiy (79) -> jpexkf, tismupk\njejwwxj (50)\ncukbzsw (441) -> mxltn, zwzgp\neobbt (229) -> rxeqfsj, rqbgxlt, ssnoqt\nggeae (270)\nxdfnmvr (147) -> vaztjkc, zoovdc\nfmcwdv (85)\nyvjjec (7)\nkzwamsk (325) -> sebno, haeyms, hdrtnjm\nhvdwvo (69)\nbmtjkw (25)\nrwxfhk (353) -> gmsmnlz, kcbag\nynjccf (61)\nzxozp (42) -> hnofc, fmcwdv, qtvcuqk\nxcuud (29)\nxwyggz (76)\nglbaxl (120) -> imtvzmm, tszune\nunlwjj (43)\nhjwjw (63)\njugycbw (23)\ncyxtnfe (13)\nphrkfo (81)\nmmutg (1040) -> yyhkwha, xwyyfr, xpjzc, amccpoz\nvntjo (81)\ntlkive (39)\nkbguoiu (7)\nnsqaxp (575) -> kacpu, gxmyk, aryqw, qywtwbt, beqez\ntmvjt (29)\nvskibye (1388) -> sjbalvv, hgoesez, lfzvi, lakzkpk, smunvi, cnlny\nsgfbfq (95) -> eobbt, ymwqj, sjzapjt, dldcoc, dexwo, ctnucjw, zflsryn\naseilg (47)\nhbzxaji (6140) -> otadcxu, dvpmg, qqpnt, mnkamc, spnzn, uuamcdc, rdjfp\nxlavrvm (27)\nwevhizp (26)\nyrmfcs (9)\nnsmlghl (99)\nsdovaq (2558) -> zxozp, pxjgtg, xdfnmvr\nirpjsbf (16)\nevbilqr (200)\navnxndg (865) -> ippnuw, ensyb, dosteiu\nutqxez (99)\nleyohju (28)\nnzyls (26)\nlsxwznl (77)\nzphlpeu (55)\nckqwb (234)\nkligtj (80)\"\"\"\n\nlet test = \"\"\"\npbga (66)\nxhth (57)\nebii (61)\nhavc (66)\nktlj (57)\nfwft (72) -> ktlj, cntj, xhth\nqoyq (66)\npadx (45) -> pbga, havc, qoyq\ntknk (41) -> ugml, padx, fwft\njptl (61)\nugml (68) -> gyxo, ebii, jptl\ngyxo (61)\ncntj (57) \"\"\"\n\nlet parseInput (input:string) =\n    input.Split '\\n'\n    |> Array.map (fun s -> s.Trim())\n    |> Array.filter ((<>) \"\")\n    |> Array.choose (fun s  -> \n        let ss = s.Split([| \"->\" |], System.StringSplitOptions.RemoveEmptyEntries)\n        let children = if ss.Length = 1 then [||] else ss.[1].Split(',') |> Array.map (fun s -> s.Trim())\n        match ss.[0].Trim().Split ' '  with\n        | [| nm; wg |] -> Some (nm, (wg.[1..wg.Length-2] |> System.Int32.Parse, children))\n        | _ -> None\n     )\n    \nlet findRoots (nodes:(string * (int * string [])) []) =\n    nodes\n    |> Seq.filter (fun (nm, _) -> Seq.exists (fun (_,(_, ch)) -> Seq.contains nm ch) nodes |> not)\n\nlet nodes = parseInput input\nlet root  = findRoots nodes |> Seq.head\n\nroot\n|> fst\n|> printfn \"Puzzle 7.1 = %A\"\n\nlet getNodeData =\n    let nodesM =\n        nodes\n        |> Map.ofSeq\n    fun nm -> Map.find nm nodesM\n\nlet rec getWeight nm =\n    let wg, ch = getNodeData nm\n    nm\n   ,wg + if ch.Length = 0 \n         then 0 \n         else ch\n              |> Array.map (getWeight >> snd)\n              |> Array.reduce (+)\n\nlet rec findOutBalance nm =\n    let ch     = getNodeData nm |> snd\n    let chws   = ch   |> Array.map     getWeight\n    let ws     = chws |> Array.countBy snd\n    let oddws  = ws   |> Array.filter (snd >> ((=) 1) ) \n    if  ws.Length    < 2 then None else\n    if  ws.Length    > 2 then failwith \"Oops more than 2 different weights\"\n    if  oddws.Length > 1 then failwith \"Oops more than 1 odd out\"\n    oddws\n    |> Seq.tryHead\n    |> Option.map (fun (v, _) -> \n        let oddnm, totw = Array.find (snd >> ((=) v)) chws\n        findOutBalance oddnm\n        |> Option.defaultWith (fun () ->\n            let normalw = ws |> Array.filter (snd >> ((<>) 1) ) |> Array.head |> fst\n            let weight  = getNodeData oddnm |> fst\n            oddnm, weight + normalw - totw\n        )\n    )\n\nnodes\nroot \n|> fst\n|> findOutBalance\n|> printfn \"Puzzle 7.2 = %A\"\n\n#define WEBSHARPER\n", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"68e7f307-62ef-4ccc-b8ae-c93d3edd1455"}, "snpName": "Day 8", "snpContent": "let input = \"\nutc dec -736 if p > -7\ntn inc -876 if qlm == 4\nuz dec 294 if l < 10\na inc -904 if me >= -7\ntn inc 622 if ppl <= 6\nfr dec 17 if ufk > -10\nhkt inc -511 if mdk == 0\nt inc -290 if xxh <= -1\nl dec 727 if ufk < 7\ntn inc -576 if l == -727\nz inc 464 if dea >= -2\nufk inc 755 if utc >= 735\nutc dec -720 if qlm <= 5\na dec -277 if ufk <= 755\nxxh dec -640 if u == 0\nhkt inc 875 if m != -6\nny inc -351 if p >= -4\nl inc 674 if dea > -7\nufk dec -826 if p == 0\nmdk inc 377 if utc == 1456\nppl dec 793 if q <= 4\nz dec 114 if mdk > 368\nny dec -412 if ny >= -353\nutc dec 176 if a != -620\nutc dec -610 if p <= 1\nl inc -541 if xxh <= 635\nl inc 102 if ny < 66\nqlm dec 700 if l >= 43\ndea dec -202 if tn <= 38\na inc 785 if a <= -629\nny inc 414 if fr <= -21\nl inc 250 if hw <= -10\nl inc -516 if l > 41\nutc dec 358 if mdk > 373\np dec -38 if z == 350\nuz dec -71 if a == -627\nt inc -713 if fr > -13\nl inc 242 if tn <= 53\ndea dec 600 if hw <= 8\nhw dec -92 if fr != -19\nhkt dec 67 if l <= -232\nqlm dec 523 if hw == 92\nutc dec -608 if q != -8\nm dec 314 if me < 9\nxxh inc -937 if xxh >= 638\nqlm dec 494 if m <= -313\nfr dec -590 if m <= -306\nutc inc -539 if tn == 46\nhkt dec 831 if p >= 43\ndea inc 510 if a > -627\np inc 319 if m > -305\nm inc 736 if xxh >= -302\nppl inc -712 if mdk == 377\nny inc 21 if p <= 41\nhw inc -569 if hw != 92\nppl inc 150 if dea < -595\nxxh dec -953 if z != 356\nppl inc 578 if qlm <= -1714\nuz dec -733 if p >= 35\nxxh inc 100 if xxh >= 660\nhw dec -491 if ppl < -767\nt dec -64 if z < 347\nme dec 802 if dea > -601\nhkt inc 431 if hkt > 359\nutc inc -600 if q != 0\nu inc -223 if tn < 48\ntn inc 443 if uz <= 513\nl inc -349 if ny == 82\nutc inc -499 if xxh <= 661\na inc 600 if hw >= 578\nz dec -636 if utc > 1099\ntn inc 75 if z == 986\nhkt dec 364 if mdk < 377\nufk inc 249 if fr == 573\nl inc -429 if uz > 507\nhw dec -621 if ppl == -778\nl inc -620 if z != 980\nl inc 319 if tn == 564\nq dec -478 if ny <= 82\nutc dec -169 if uz < 519\nfr inc 124 if dea >= -607\nm dec -674 if p != 28\nm dec 744 if p != 44\nl dec -620 if hw <= 582\nutc dec -950 if p >= 37\nuz dec -122 if xxh < 660\nl inc -563 if z < 996\nhkt inc -514 if m <= 361\nl dec 525 if mdk == 377\nxxh inc -666 if u != -228\na inc 934 if a <= -23\na inc 817 if xxh >= -11\nme inc 450 if tn < 563\nhw inc 475 if xxh < -1\nfr dec 493 if xxh < -8\nuz inc -985 if qlm > -1724\nppl inc 856 if qlm >= -1720\nhw inc -368 if me > -804\nny dec -219 if p != 38\nu inc 1000 if ny > 79\nq dec 551 if hkt == 281\nuz dec 317 if dea >= -600\nuz inc -916 if qlm <= -1726\nhkt dec 915 if mdk != 380\nmdk inc 484 if l == -2392\nxxh inc 326 if dea > -607\nu dec -803 if me > -811\nq dec 689 if tn != 565\nhw dec 908 if p == 38\nz inc -173 if ppl > 72\nz dec 371 if tn < 565\np inc 185 if u > 1571\na inc 490 if mdk != 864\ntn dec -27 if u == 1580\nqlm inc 77 if m > 345\np dec 364 if ufk <= 1836\ndea dec 308 if me == -802\na inc -345 if hw == -218\nny inc 603 if p <= -138\nfr inc -4 if utc > 2217\nme inc 118 if hkt <= -626\nhw inc -590 if z < 443\nme dec 279 if q <= -756\nme inc -50 if dea == -908\nppl inc 708 if u <= 1586\nt inc -429 if mdk >= 854\nm dec -372 if uz > -676\nfr dec -840 if ppl == 787\nqlm dec -442 if tn != 584\nu dec 227 if l == -2402\nm inc 279 if z <= 446\nxxh inc -951 if t > -421\nt dec 530 if xxh != 317\nfr inc -621 if mdk <= 869\na dec 480 if fr < 424\nq inc 988 if l == -2384\nu inc 313 if q < -757\nhw dec 237 if hkt == -634\nmdk dec 945 if t > -969\nme inc 631 if ny >= 679\nny dec -740 if uz == -670\nt inc -310 if utc > 2213\np dec -453 if utc >= 2218\nmdk inc -266 if hw == -1045\na inc -887 if qlm == -1198\nppl dec 521 if t >= -1270\ndea dec -685 if xxh != 310\nl inc -472 if m < 1013\nufk inc -920 if l <= -2860\nu dec -503 if me <= -373\nufk inc 547 if m > 998\nl inc -287 if p <= 309\nqlm dec -173 if q <= -755\nu dec -928 if z > 437\nhw inc 43 if hkt < -626\nutc inc -694 if me == -382\nfr dec -938 if tn > 584\nq inc 9 if mdk == -350\ndea inc 119 if m < 1012\nny dec 210 if ufk <= 1465\nxxh inc 352 if q > -758\ndea inc 483 if hkt >= -639\ntn inc -652 if t >= -1266\nufk inc 674 if ny >= 1207\nppl dec 311 if z >= 442\nqlm inc 655 if m < 1005\nz dec 580 if uz < -661\nutc inc -977 if ppl <= -36\nxxh inc -25 if l == -2864\nme dec 252 if uz > -674\nmdk dec -98 if z <= -129\np inc -276 if utc < 541\nhw dec 796 if xxh <= 649\nq inc -726 if z != -137\nfr dec 433 if ufk <= 2140\nhw inc -701 if z < -131\nhw dec 587 if mdk <= -244\nny dec -734 if mdk <= -249\nqlm dec -311 if utc != 546\nufk dec -405 if q > -1481\np dec 97 if t != -1275\nt dec 597 if qlm >= -49\nufk dec 389 if uz < -660\nl inc 765 if a < 504\nfr dec -948 if tn >= 586\nqlm dec 79 if m > 997\nny inc 764 if p < 225\na dec 419 if m != 1003\nq dec -860 if q != -1475\nfr inc 426 if hw > -3080\nufk inc 0 if ppl != -36\nutc inc 939 if p >= 206\nm inc 830 if xxh < 650\nm inc -511 if hw > -3091\nu inc -720 if qlm > -134\ndea inc -147 if a <= 503\nu inc -322 if tn != 591\nny dec 900 if ny != 2713\nny inc -737 if me == -634\nfr inc -494 if l != -2097\nmdk inc -363 if ny != 1976\nl inc 991 if hkt > -636\nl dec 179 if dea != 232\nq dec -264 if ny != 1977\nl dec -976 if uz > -667\ntn inc 791 if hkt > -637\nppl dec 225 if utc < 1495\nuz dec -527 if m > 1317\na inc -644 if me < -624\nuz inc 160 if q >= -361\nu inc 577 if xxh > 650\nq inc 124 if xxh < 653\nl inc 268 if dea > 222\nhw inc 795 if uz < 10\nuz dec 934 if uz < 26\ntn inc 966 if ufk == 2150\nme dec -71 if p <= 222\nme inc 186 if ppl > -270\nm dec -377 if xxh <= 649\nny dec 275 if mdk > -248\nqlm dec -574 if fr != 1371\nutc dec 78 if xxh > 638\nl inc 494 if u > 3315\ntn dec -595 if qlm > 435\ntn dec 113 if a <= -140\nfr inc -610 if ufk < 2148\nuz inc -791 if u != 3334\nuz inc 356 if t < -1276\nl dec -463 if utc < 1414\ntn inc -266 if a < -137\np inc 747 if utc >= 1402\nz inc -671 if hkt == -634\ntn inc -441 if u != 3324\nfr inc 172 if hkt > -638\ntn dec -558 if qlm < 439\na dec -234 if tn <= 2155\nt inc -325 if l >= 126\nt dec -685 if l > 110\nufk inc -912 if z < -805\nufk dec 0 if fr < 941\nfr dec 276 if a == -142\nxxh inc -972 if p < 967\nufk inc 188 if mdk >= -245\nme inc -255 if t > -583\nqlm inc 451 if uz > -1710\nfr inc -921 if z >= -814\nq inc 272 if uz < -1705\nu dec 216 if p <= 956\na inc 30 if z > -812\ntn dec -202 if dea == 232\nm inc 792 if ny != 1976\nuz dec -867 if z == -809\nppl inc -765 if qlm != 894\nhkt inc 301 if xxh < -322\np dec -839 if dea == 232\nutc dec -920 if m > 1694\na inc -206 if mdk == -252\nny dec -545 if ppl <= -1029\nme dec -860 if q >= 39\nufk inc 644 if tn <= 2359\nhw dec 959 if t == -584\nqlm dec 667 if xxh != -321\nufk inc 598 if a > -323\nppl dec -514 if hw <= -4039\nuz dec 708 if p == 1801\nhw inc -902 if hkt != -333\nqlm dec 249 if tn != 2366\nmdk inc -570 if z > -812\nfr inc -47 if tn > 2350\nme inc -62 if hw != -4037\nqlm dec 796 if dea > 239\nq dec -201 if ppl == -521\nz inc 265 if ufk != 2481\nhw dec 597 if q >= 239\nny dec 417 if uz > -1540\nhkt dec -866 if m <= 1704\nm inc 103 if m == 1699\nufk inc -733 if qlm <= -28\nmdk dec -416 if z > -546\nufk dec 477 if z < -543\nl dec 224 if m < 1799\nq inc 646 if u < 3327\nhkt dec -501 if qlm != -29\nppl inc 321 if p > 1797\na dec 678 if ufk == 1268\nu inc -878 if fr > -302\nt dec 523 if uz != -1552\nmdk dec -490 if fr != -304\np dec -603 if ufk >= 1264\ntn inc -234 if qlm > -33\nmdk dec -51 if q <= 881\na inc 672 if me < 244\nz dec 473 if m != 1797\nmdk dec -727 if utc == 2331\nppl inc -59 if me == 235\na dec -937 if uz <= -1547\nuz dec -352 if m >= 1798\nfr inc 693 if utc < 2333\nt inc 493 if hkt != 526\nhw inc 86 if hkt >= 533\nt dec 49 if ny != 2512\nutc inc 273 if me != 235\nxxh inc -871 if dea == 232\nz dec -707 if dea != 234\nmdk dec 362 if ny > 2528\ntn inc -825 if t <= -658\nuz dec 655 if xxh < -1195\ndea dec 231 if me < 242\nmdk dec -260 if xxh != -1200\nppl dec -842 if mdk != 321\nl inc -957 if qlm == -23\nm dec 393 if ny > 2515\nufk inc -648 if me < 243\ndea inc -251 if fr < 399\na inc 772 if mdk < 323\nhkt inc 997 if fr > 383\nl dec 13 if dea == -240\nhkt dec -935 if tn >= 1291\nuz dec 992 if u < 3324\nhw dec -970 if t <= -655\nm inc 132 if mdk == 321\nhw inc 908 if hkt > 2464\nme inc -975 if l != 119\nny dec -76 if dea >= -251\nppl dec -844 if u >= 3322\nqlm dec 286 if ny >= 2597\nxxh dec 903 if uz != -1843\nu dec 992 if hkt <= 2471\ntn dec -663 if me > -735\nny dec -598 if ppl >= 583\nm inc 84 if mdk != 318\nufk inc -260 if t <= -668\nu dec -443 if fr >= 388\nl dec -116 if hw <= -2670\nm inc 816 if dea < -240\nt inc 319 if mdk != 317\nme inc -681 if z < -301\nm inc 451 if uz != -1845\nt inc 472 if mdk <= 330\nqlm inc -125 if z == -310\nufk inc -419 if p > 2401\nl dec -7 if xxh <= -2096\nm dec 325 if fr < 380\nmdk inc -391 if hkt <= 2465\nxxh inc 491 if z != -315\np inc -832 if utc > 2324\nt dec 304 if a > 2056\nxxh dec 107 if dea < -243\nl inc 220 if hw < -2681\np dec -316 if p > 1565\nmdk inc 333 if utc == 2332\nppl dec 961 if a >= 2055\nfr inc 230 if z <= -310\nhkt dec -715 if fr >= 615\nl inc -466 if p <= 1888\nqlm inc 185 if xxh >= -1725\nu inc -710 if t == -168\nz inc 15 if ppl < -371\nutc inc 422 if hw < -2683\nfr dec 688 if t > -181\nmdk dec 606 if a < 2064\nme dec 323 if z <= -289\nppl dec 150 if uz > -1844\nt inc 617 if q > 879\nhw inc -212 if qlm != -255\na inc 338 if m <= 2901\nutc dec 545 if l < -228\ntn dec 407 if z > -303\nmdk dec 784 if ppl >= -378\nq inc -352 if z == -295\nuz inc -644 if ppl <= -372\nfr dec 209 if dea < -242\ntn dec -605 if p >= 1879\nhkt dec 77 if mdk != -1470\nhw dec -280 if hw < -2676\nufk dec 375 if qlm >= -248\np inc -958 if xxh <= -1710\na inc 653 if z != -295\nutc inc 493 if qlm == -255\nxxh dec -649 if q > 530\nz inc -993 if me != -1749\nt inc 119 if mdk <= -1451\nufk dec 883 if utc <= 2825\nm inc -545 if qlm == -255\ntn inc 626 if dea != -253\ntn dec -111 if p > 923\ntn inc -719 if u <= 2780\nu inc 976 if u != 2767\nz inc -495 if ppl != -368\nz dec 481 if dea != -246\nppl dec 539 if ppl >= -381\nuz dec 213 if uz >= -2504\na inc -9 if tn < 1509\nny dec 719 if u < 3757\nuz inc 718 if hkt <= 3103\nny dec 378 if u >= 3748\nme dec 163 if xxh >= -1076\nt dec -569 if hkt > 3105\nfr inc -280 if a <= 2407\nl dec -908 if q != 527\na inc -13 if me < -1912\ndea dec 584 if mdk <= -1464\nhw inc -988 if l >= 692\ntn dec 847 if mdk < -1451\nhw inc 568 if utc > 2822\nt dec 133 if tn < 659\nz inc 271 if q <= 539\nmdk inc -33 if q <= 545\nl inc 185 if dea >= -259\nxxh inc 36 if xxh != -1064\na dec 70 if xxh >= -1042\nz inc 956 if p > 931\nutc inc -778 if dea != -244\ndea inc -868 if z > -1985\nt dec -872 if u >= 3750\nppl dec 420 if u < 3747\ndea inc 372 if xxh >= -1043\nhkt dec 32 if u != 3759\nt inc 23 if uz == -1985\nny dec 106 if ufk == -683\ndea dec -794 if t == 1441\nhkt dec -233 if t < 1435\nq dec -186 if ufk == -683\nu dec 328 if a >= 2331\nxxh inc -179 if z <= -1991\nutc inc -614 if qlm > -254\nfr dec 136 if m != 2349\nuz inc -942 if uz >= -2000\nme inc 391 if m >= 2340\nl dec -448 if utc > 2054\nme dec -64 if fr > -696\nutc dec -621 if qlm > -256\nz dec -622 if dea == 132\na dec -228 if ny == 1992\nqlm inc 957 if a <= 2563\nt dec 178 if hkt == 3304\nme dec -583 if uz >= -2940\nxxh dec 22 if ny >= 1988\nufk dec 294 if fr <= -690\nl dec 666 if a != 2559\ntn dec 135 if qlm >= 704\nhkt inc 524 if q == 722\nuz inc 448 if dea > 118\nq inc 299 if hkt >= 3832\nu dec 502 if p <= 931\nqlm dec -530 if l > 863\nm dec -677 if m > 2344\nuz inc -254 if qlm < 1236\np inc 164 if tn != 663\nny inc -208 if me >= -874\nhw inc 688 if ny >= 1775\nq dec -90 if ny < 1787\nqlm inc 602 if l <= 874\nxxh inc 442 if uz == -2739\nmdk inc 235 if xxh == -793\na dec -225 if u > 2911\nm dec -706 if hkt <= 3831\na dec 229 if ufk <= -977\nppl dec 256 if xxh == -788\nt inc 1000 if p < 1087\nhw inc -970 if a <= 2564\nhw dec 398 if ny >= 1779\nppl inc 984 if ufk != -968\nutc inc -979 if ufk != -967\nhw dec -383 if utc > 1678\np dec 283 if xxh == -793\nhw inc -434 if ny <= 1786\nu dec -226 if l == 868\nl dec 943 if tn > 675\nxxh inc -64 if p >= 807\nppl inc 577 if fr == -694\ndea inc 629 if ppl > 636\nu dec 113 if ufk != -984\na inc 482 if dea < 760\ndea dec -232 if xxh == -857\nny inc -952 if ufk < -967\nhkt inc 159 if p < 811\nz inc 530 if mdk == -1258\nm dec -745 if dea <= 988\nm inc -554 if mdk >= -1258\nfr inc -798 if xxh >= -864\nq dec -139 if utc > 1690\nm dec 962 if p < 808\na inc -409 if u <= 2809\nu dec -30 if ppl > 643\nuz dec 502 if u < 2834\nl dec -653 if qlm == 1834\nqlm inc 732 if me <= -869\ntn dec 200 if fr >= -1495\nny inc -26 if a <= 2632\nhkt inc -601 if ppl < 656\nt inc -277 if l <= 1521\na inc -86 if xxh < -847\nhkt dec -42 if qlm >= 2566\ndea dec 218 if p >= 807\nufk dec 870 if q > 815\nz inc 141 if z == -1463\nl dec 873 if mdk > -1263\nu dec 897 if ppl <= 653\ndea inc -239 if p < 809\nxxh inc 525 if uz >= -2746\ndea inc 827 if mdk > -1266\ndea dec -988 if ppl != 636\nny dec 330 if m < 3923\nq inc -413 if hw > -2554\nhw inc 983 if mdk < -1250\nmdk dec 932 if hw >= -1573\nfr inc -984 if u >= 1934\nxxh dec -344 if qlm > 2566\np dec 189 if tn != 464\nhw inc -986 if ny < 473\nm dec 233 if z > -1323\nmdk inc -803 if a >= 2542\nu dec -858 if dea > 2570\nme dec 215 if dea >= 2590\nq inc 945 if dea >= 2589\nz inc 55 if ny >= 471\nxxh dec -63 if a <= 2544\nfr dec -864 if ufk != -969\nme dec -330 if me <= -861\nufk inc -96 if dea <= 2586\nfr inc 348 if uz >= -2739\nqlm inc -249 if q <= 805\nqlm dec -752 if uz < -2736\nhkt dec -389 if q < 818\ndea inc -169 if ppl == 646\nxxh inc -689 if z <= -1268\ntn inc 911 if m <= 3697\nppl inc -390 if a != 2551\na inc 87 if ufk != -1074\nz inc 413 if ppl == 262\np inc 476 if mdk < -2052\np dec -570 if z != -1257\nuz inc 266 if hkt <= 3654\nppl inc -29 if ny <= 474\nny inc -154 if ppl <= 264\nufk inc -614 if uz < -2741\ndea dec -627 if xxh == -269\nme inc 553 if p < 1670\nq inc -413 if a > 2636\nq dec 754 if utc == 1688\np dec 857 if m == 3688\ndea dec 883 if ufk >= -1074\nuz inc -485 if l == 647\ndea dec -979 if me <= 15\nhkt dec 738 if l > 642\nxxh inc 298 if tn < 1372\nuz dec 235 if l != 651\nm dec -170 if tn > 1379\nhkt inc 902 if a > 2619\nhkt inc 354 if hw < -1573\nqlm dec 512 if uz != -3462\nu inc -676 if t != 984\na inc 635 if z == -1267\nppl inc -756 if q <= 60\nt inc 662 if mdk == -2061\nqlm dec -900 if p > 807\nz dec 877 if hkt == 4176\na dec -841 if uz > -3466\ndea inc 141 if u != 2115\nq inc 917 if dea != 3270\nppl inc -582 if tn >= 1375\ndea dec -309 if xxh < -271\nutc inc -353 if hw <= -1578\nmdk dec 643 if q != 979\nhw inc -595 if fr != -1254\nxxh inc 736 if ny != 325\nhkt inc -692 if z == -2144\np dec 500 if hw < -2170\nuz dec -168 if ppl >= -1083\nu dec 419 if hw > -2181\nfr inc -653 if u != 1704\nm inc -677 if qlm < 3716\nqlm dec -341 if u >= 1704\nme dec -926 if utc >= 1329\nqlm dec -462 if hw != -2174\nfr dec 604 if hw != -2173\np dec -826 if uz >= -3291\nhkt inc -855 if ny <= 315\nutc dec -647 if dea > 3269\nxxh inc 483 if z < -2143\nl dec 93 if utc >= 1979\ndea inc -680 if fr != -1264\nme inc -293 if ufk != -1063\nuz dec 279 if t == 1636\nxxh inc -145 if u <= 1705\nq inc 269 if a > 4097\nufk dec 734 if l >= 552\nz dec -270 if utc > 1977\ntn inc -154 if t <= 1645\nmdk inc 455 if uz < -3283\ndea inc 350 if utc < 1992\nhw dec -300 if ppl <= -1085\nufk inc 337 if u >= 1699\nppl inc -634 if l != 558\nt dec -583 if xxh == 805\nt dec 384 if dea >= 3620\np dec -873 if m == 3011\nufk inc -710 if uz < -3287\nhw inc -808 if hkt <= 3490\nhw dec -464 if u > 1702\nm dec -102 if mdk > -2256\nfr dec 579 if t > 1829\ndea dec -839 if qlm < 4519\nufk dec -741 if l <= 545\nme inc -520 if z <= -1865\nmdk dec 824 if hkt < 3493\nqlm inc -703 if q <= 1243\nt dec 284 if qlm < 4517\nfr dec -527 if ufk == -2183\nme dec -995 if xxh == 805\nutc inc 498 if hw < -2525\nhw dec -350 if ufk <= -2174\ndea inc 143 if mdk == -3073\nutc dec 812 if l < 552\nufk dec 679 if hkt <= 3490\na inc -464 if ny < 317\nufk inc 116 if hkt > 3483\nhw inc 77 if mdk < -3063\nhkt dec 851 if ny < 329\nuz dec -37 if uz != -3287\nhkt dec 45 if xxh == 805\nuz dec -682 if fr <= -1850\ndea inc 695 if hkt > 2582\np dec 857 if hkt <= 2592\nfr inc 114 if dea < 5309\nq dec -714 if p < 1158\nutc dec 896 if ufk != -2752\nuz dec -937 if ufk < -2741\np inc -807 if tn <= 1232\nufk inc 788 if fr >= -1730\nufk dec 519 if l > 558\nufk dec 142 if tn < 1227\nppl dec -561 if ufk > -2103\ndea dec 463 if fr >= -1728\nm inc 139 if tn != 1218\nfr dec -606 if q >= 1951\nqlm inc 934 if fr >= -1122\na dec -910 if xxh < 815\nhw dec -564 if a <= 5015\nu dec -648 if hw > -1532\nhkt dec 601 if hkt <= 2588\nq dec -480 if hkt < 1997\nuz dec 596 if hkt >= 1983\np dec -971 if u > 2347\nz dec 790 if m == 3252\nfr inc 281 if hw <= -1517\nuz dec 636 if hw == -1516\nl dec -582 if ny > 315\nny inc 202 if dea < 5306\nmdk inc -251 if ppl > -1147\nme dec 826 if p == 1317\nqlm dec -11 if p == 1317\nz inc -166 if a >= 5011\nny inc 455 if l >= 1127\nutc dec -156 if qlm < 4525\nq dec -147 if l <= 1129\nufk inc 36 if ny < 978\nppl dec -871 if uz < -2907\nfr inc 776 if t >= 1548\nqlm inc -510 if u != 2352\nz inc 373 if dea >= 5294\nuz dec -975 if fr <= -59\nfr dec -670 if z < -2459\nutc dec 322 if q != 2428\nl dec 3 if ppl != -282\nuz dec 728 if ny > 971\nny dec -396 if p > 1308\na inc -502 if mdk <= -3067\nny dec -492 if uz <= -2666\nppl inc -720 if t >= 1554\nuz inc -323 if hw != -1533\nppl inc 805 if m >= 3252\np inc 310 if qlm != 4520\nm dec 743 if dea >= 5299\nppl inc 847 if t <= 1546\np dec 89 if u != 2352\na inc 472 if z < -2455\nme dec 301 if utc > 914\nppl inc 740 if q < 2434\nufk inc -633 if l > 1138\nppl inc -51 if hw > -1529\nu dec -714 if fr >= -56\nz dec 510 if me >= 0\nl inc 664 if mdk != -3073\nqlm dec -742 if l < 1142\nny dec -473 if tn == 1225\nfr inc -805 if ufk > -2093\nxxh dec -151 if fr > -74\nhw inc -734 if hw <= -1528\np dec 976 if uz >= -2990\nmdk inc 523 if m == 2509\nu dec -176 if utc < 923\nme inc 766 if hkt != 1987\nppl dec -392 if mdk != -2557\nl inc -756 if u > 2527\nfr inc -990 if xxh > 955\nl inc 901 if ufk > -2100\nxxh dec -856 if ppl >= 137\nhkt dec -989 if t == 1561\np dec 846 if p > 339\nhkt inc -429 if dea != 5302\nu dec 534 if hw <= -1517\nuz dec 178 if xxh > 1803\nz dec 655 if m <= 2516\nxxh inc -340 if ny < 2334\nu inc -545 if dea != 5295\np inc -996 if uz > -3172\ndea dec -140 if hkt != 1984\nq inc -764 if a <= 4985\nz inc 263 if uz == -3167\nl dec -929 if a <= 4985\np inc -214 if uz >= -3170\nuz inc 393 if hw >= -1533\ntn inc -624 if me == -5\nme inc -474 if ufk != -2106\nppl dec 475 if l <= 2214\nqlm inc 417 if u != 1449\np inc -490 if qlm > 5257\na inc 526 if u <= 1452\nny inc -347 if u <= 1454\np dec 397 if uz < -2765\nt dec 548 if u <= 1448\nufk dec 514 if ufk > -2102\nl dec 744 if uz != -2782\nfr dec 810 if ppl == -333\nppl dec -338 if qlm > 5258\nqlm dec 272 if q > 1665\nm dec 521 if ufk >= -2614\nuz dec 558 if me < -477\np inc -632 if m >= 1987\ndea inc -237 if fr != -1864\nmdk dec 3 if utc > 917\nl inc -406 if dea >= 5213\ndea inc -268 if z == -2849\nutc inc 675 if q > 1664\nme dec -905 if p < -3230\nufk inc -799 if u != 1439\nxxh inc 718 if hkt != 1987\ntn inc 156 if qlm >= 4984\np inc -680 if fr == -1866\nppl inc 423 if hkt >= 1980\np inc -759 if ufk != -3405\nme inc 496 if qlm <= 4995\nm dec 111 if mdk != -2545\nu dec 351 if z < -2843\nuz dec -405 if xxh != 1804\nny dec -634 if utc == 1592\nqlm inc 294 if l == 1463\nxxh inc -994 if a <= 5511\na inc 460 if uz == -2927\nt inc -313 if u != 1093\nl inc 254 if hkt > 1978\ndea dec -290 if ppl <= 429\nny inc 190 if z <= -2844\nppl inc -865 if dea == 5220\nz dec 372 if utc <= 1595\nl dec -563 if u < 1104\nz inc -283 if xxh < 821\nq inc 967 if utc == 1595\nq dec -621 if ppl > 433\nl dec -221 if tn > 757\nl dec -935 if a >= 5962\nl inc -62 if l != 3225\nhkt dec -654 if t > 1240\ndea inc 87 if p == -4673\nl dec -166 if u <= 1098\ndea dec 183 if hw != -1529\nq dec 70 if p == -4667\na dec -673 if ny < 2188\nq dec 295 if mdk != -2563\nm dec -26 if a == 6644\nqlm inc 378 if xxh != 816\na dec 174 if l <= 3320\nfr inc 117 if dea >= 5131\nhkt dec -732 if hkt >= 2634\nufk inc -838 if mdk != -2547\nny inc -964 if a >= 6461\nhw dec -264 if a == 6470\nz dec -834 if ufk >= -4251\nl inc -658 if m > 1897\nxxh inc 400 if fr >= -1753\nhw dec 380 if hw <= -1265\nt inc -608 if utc < 1597\nppl dec 352 if a > 6467\nl dec -355 if utc > 1591\nl dec 846 if dea <= 5128\nppl dec 756 if fr < -1746\nutc dec 259 if p == -4673\ntn dec 160 if hw < -1257\nt inc -625 if t != 640\nxxh dec 804 if dea > 5130\nny dec 227 if z <= -2665\nppl dec 306 if uz != -2922\nq dec -671 if hw < -1262\ntn dec 149 if ufk == -4248\np dec -583 if mdk == -2553\nhw inc 312 if uz <= -2919\nhkt inc 111 if tn >= 456\nq dec -23 if uz > -2918\nhw inc -291 if l > 3008\nme inc -744 if utc > 1327\nuz dec 188 if utc >= 1336\nhw dec -575 if z < -2663\nppl dec 977 if ny != 988\nl dec -84 if dea < 5135\np inc 905 if uz == -3115\nm inc 636 if m == 1903\nhkt dec 95 if p < -3178\nu inc 249 if utc > 1331\nuz dec -196 if qlm == 5662\nhkt inc -621 if fr > -1750\nz inc -859 if l < 3093\nl inc -789 if ppl > -1957\nme inc 916 if tn >= 457\nuz dec -115 if xxh != 406\nz dec -353 if z <= -2669\nhw inc -965 if ppl != -1960\nt inc 333 if qlm == 5662\nt dec 860 if z == -2310\np dec -841 if l > 3104\nqlm inc 225 if t == 341\nutc inc -937 if p <= -3185\nqlm inc -191 if xxh < 424\nm dec 607 if q != 2354\nuz inc 807 if p >= -3178\nfr dec -431 if uz == -2804\nppl dec -312 if t <= 341\na dec -764 if mdk >= -2557\nutc dec 505 if a >= 7228\nufk dec -148 if tn != 449\nutc dec -371 if utc != -100\ndea dec -11 if utc < 272\nufk inc 329 if utc != 261\nutc dec -484 if z <= -2312\nm dec 784 if ppl == -1651\nxxh dec 669 if m <= 1147\nxxh inc -798 if me == 178\np dec -832 if ppl == -1651\nufk inc 266 if fr > -1318\na inc -993 if fr >= -1319\nxxh inc 25 if ppl != -1652\nu inc -353 if hw == -1631\np inc -338 if q >= 2340\np dec 517 if utc >= 741\nppl dec -221 if dea > 5137\nhw dec 949 if mdk < -2544\ntn inc 201 if ufk != -3781\nmdk inc 855 if t > 334\nm dec 604 if q <= 2353\nme inc 268 if tn <= 644\ntn inc -372 if m > 540\nl dec 275 if qlm >= 5687\nmdk dec -13 if p == -3199\nz dec -725 if tn > 286\ndea inc -843 if dea == 5142\nhw inc -603 if a >= 6234\nppl inc 850 if tn <= 279\nl inc -601 if uz == -2804\nm inc 10 if z >= -2319\nfr inc -412 if xxh != -351\nme dec 726 if tn >= 277\nny dec -719 if me < -544\nhw dec 413 if q > 2349\na dec -229 if hkt == 2651\nt inc 620 if t != 347\nuz inc -216 if t <= 963\nfr inc 614 if me != -549\nxxh inc 536 if z < -2309\nq inc 974 if me < -548\nq inc -131 if ny == 1711\ntn dec 110 if tn > 274\nl inc 47 if p == -3208\nxxh inc -872 if dea >= 4295\ntn inc -667 if tn <= 169\nq dec 562 if mdk >= -1700\na inc -16 if xxh != -685\nhw dec 649 if xxh == -695\nufk inc 239 if l != 2268\nt dec 935 if ppl <= -576\nm dec 1000 if fr > -1120\nhkt inc -167 if xxh == -695\nny inc 926 if uz > -3027\nm inc -729 if xxh > -693\nm inc -677 if a > 6221\np dec -412 if qlm >= 5691\nm dec -678 if ufk < -3526\nppl inc 206 if z < -2308\nm inc -961 if m != -445\nt inc -989 if mdk > -1701\nppl dec 43 if q <= 1654\nxxh inc -619 if ny == 2637\nppl dec 168 if xxh < -1312\nt inc 191 if xxh > -1320\nme inc 387 if hw >= -3826\np inc 517 if q <= 1648\nq dec 577 if ppl > -589\nu dec -841 if fr <= -1115\ndea dec -791 if p <= -2793\nhkt inc 216 if tn != -500\nuz dec -333 if hkt >= 2490\ndea inc 46 if a > 6217\nmdk inc -168 if fr > -1117\nt inc -606 if fr > -1122\nme inc 662 if hkt != 2491\nuz dec 384 if p > -2806\nuz inc -848 if xxh < -1308\nny inc 617 if tn < -497\nfr dec -359 if utc != 750\nm dec -911 if ufk <= -3530\nppl dec -190 if mdk != -1858\nu dec -400 if t > -1388\nme inc -381 if u == 2235\nhw inc -548 if m == 466\nqlm inc -940 if mdk <= -1860\ndea dec 180 if z <= -2316\nhw inc 17 if tn != -504\nfr dec -769 if me > -277\nppl inc -630 if hkt == 2482\nhw inc 825 if xxh == -1314\nutc dec -38 if hw < -3529\nq dec 851 if uz <= -3918\nme dec -417 if me > -274\nq inc 505 if ny < 3248\nny dec 299 if fr > 9\nutc dec 996 if z == -2317\nz inc 157 if ppl == -395\nmdk inc -11 if mdk == -1866\nt dec -222 if ny <= 2964\nq dec 1000 if u <= 2244\ntn dec -704 if ppl >= -399\nl inc 666 if utc > -212\nq inc 890 if dea >= 4951\ntn inc 255 if xxh > -1324\nme dec -317 if p == -2796\nutc dec 651 if m >= 460\ndea dec -945 if q > 110\nny inc -755 if z > -2169\na inc 1 if utc < -858\nuz dec 840 if utc >= -861\nl dec 131 if ufk != -3542\nhkt inc -442 if u > 2236\nmdk dec -156 if hw == -3531\nufk dec 380 if uz != -4756\nxxh dec 198 if p == -2796\nfr inc -946 if z != -2165\nq dec -736 if dea < 5898\nqlm inc -284 if fr == -934\nz dec 895 if t < -1152\nme dec -370 if l != 2806\na dec -949 if dea >= 5906\nl inc -913 if uz <= -4758\nuz inc 15 if t > -1158\nm inc 535 if xxh > -1516\nme inc -896 if u > 2228\nm inc -821 if fr == -934\nme dec 754 if m <= 189\nxxh inc 685 if p >= -2802\nutc inc 149 if uz == -4744\nufk dec -486 if hw <= -3535\ntn dec 617 if u != 2228\nfr inc -971 if ny < 2191\nl dec 933 if z < -3053\nq dec 269 if qlm > 4467\nme inc 449 if l < 968\nutc inc -359 if l <= 965\ntn inc -465 if p <= -2798\nxxh dec -811 if t <= -1149\nfr dec -106 if m <= 182\nuz inc 603 if p < -2794\nuz inc 310 if z <= -3064\nny inc -764 if hw >= -3538\nmdk dec -843 if ufk < -3416\na inc 49 if tn != -158\ndea inc 129 if ufk >= -3433\nny dec 515 if ny < 1438\nq inc -603 if ufk < -3419\ntn dec 470 if hkt < 2496\nm inc -669 if utc <= -1067\ndea inc 401 if ny >= 912\np inc 129 if tn >= -631\np dec -708 if hw != -3540\ndea inc 932 if mdk == -1024\ntn dec -244 if ufk == -3426\nny dec 632 if utc >= -1075\nny dec -958 if z > -3063\nme dec -67 if hkt == 2490\nfr inc 431 if mdk > -1038\nny dec -435 if z < -3052\nny inc 997 if ny != 1686\ndea inc 397 if hw < -3537\nhw dec 232 if xxh == -16\nq inc 826 if p > -1960\nq inc -807 if z < -3045\nuz dec -645 if a < 6227\nme inc -725 if qlm < 4477\nxxh dec -440 if z == -3055\nmdk inc 647 if m <= -489\nt dec -497 if dea != 6827\nhkt dec -874 if hkt == 2490\"\n\nlet test = \"\nb inc 5 if a > 1\na inc 1 if b < 5\nc dec -10 if a >= 1\nc inc -20 if c == 10\"\n\nopen Useful\n\ntype RegisterId  = RegisterId of string\n\ntype ConditionOp =\n| EQ\n| LT\n| LE\n| GT\n| GE\n| NE\n\ntype InstructionType =\n| Inc\n| Dec\n\ntype Instruction = {\n    instType : InstructionType\n    register : RegisterId\n    value    : int\n    condReg  : RegisterId\n    condOp   : ConditionOp\n    condVal  : int\n}\n\n\nlet (|Inst|_|) s =\n    match s with\n    | \"inc\" -> Some Inc\n    | \"dec\" -> Some Dec\n    | _     -> None\n\nlet (|CondOp|_|) s =\n    match s with\n    | \"==\"  -> Some EQ\n    | \"<\"   -> Some LT\n    | \"<=\"  -> Some LE\n    | \">\"   -> Some GT\n    | \">=\"  -> Some GE\n    | \"!=\"  -> Some NE\n    | _     -> None\n\nlet getInstructions (input:string) = \n    input.Split '\\n'\n    |> Array.filter ((<>) \"\")\n    |> Array.map    (fun s -> \n        match s.Trim().Split ' ' with\n        | [| r ; Inst inst ; Int v ; \"if\" ; cr ; CondOp op ; Int cv |] -> \n            {\n                 instType = inst\n                 register = RegisterId r\n                 value    = v\n                 condReg  = RegisterId cr\n                 condOp   = op\n                 condVal  = cv\n            }\n        | _ -> failwith (sprintf \"Bad instruction: %s\" s)\n    )\n\nlet processInstruction (regs, max) (inst:Instruction) =\n    let getValue reg   = Map.tryFind reg   regs |> Option.defaultValue 0\n    let setValue reg v = Map.add     reg v regs\n    let evaluateCondition reg cop v =\n        let r = getValue reg\n        match cop with\n        | EQ -> r =  v\n        | LT -> r <  v\n        | LE -> r <= v\n        | GT -> r >  v\n        | GE -> r >= v\n        | NE -> r <> v\n    if evaluateCondition inst.condReg inst.condOp inst.condVal then\n        let nv = getValue inst.register + if inst.instType = Dec then - inst.value else inst.value\n        (setValue inst.register nv, if nv > max then nv else max)        \n    else (regs, max)\n\ngetInstructions input\n|> Seq.fold processInstruction (Map.empty, 0)\n|> fun (regs, max) -> Map.toSeq regs |> Seq.maxBy snd, max\n|> printfn \"Puzzle 8 = %A\"    \n\n#define WEBSHARPER\n", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [{"SnippetId" :"af2b60c6-a99f-433d-b938-f59fefe66c01"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0b3e1211-86f8-475f-a78b-32ddf232cbfe"}, "snpName": "Day 9", "snpContent": "let test = \"\"\"\n<>, empty garbage.\n<random characters>, garbage containing random characters.\n<<<<>, because the extra < are ignored.\n<{!>}>, because the first > is canceled.\n<!!>, because the second ! is canceled, allowing the > to terminate the garbage.\n<!!!>>, because the second ! and the first > are canceled.\n<{o\"i!a,<{i<a>, which ends at the first >.\nHere are some examples of whole streams and the number of groups they contain:\n\n{}, 1 group.\n{{{}}}, 3 groups.\n{{},{}}, also 3 groups.\n{{{},{},{{}}}}, 6 groups.\n{<{},{},{{}}>}, 1 group (which itself contains garbage).\n{<a>,<a>,<a>,<a>}, 1 group.\n{{<a>},{<a>},{<a>},{<a>}}, 5 groups.\n{{<!>},{<!>},{<!>},{<a>}}, 2 groups (since all but the last > are canceled).\nYour goal is to find the total score for all groups in your input. Each group is assigned a score which is one more than the score of the group that immediately contains it. (The outermost group gets a score of 1.)\n\n{}, score of 1.\n{{{}}}, score of 1 + 2 + 3 = 6.\n{{},{}}, score of 1 + 2 + 2 = 5.\n{{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16.\n{<a>,<a>,<a>,<a>}, score of 1.\n{{<ab>},{<ab>},{<ab>},{<ab>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<!!>},{<!!>},{<!!>},{<!!>}}, score of 1 + 2 + 2 + 2 + 2 = 9.\n{{<a!>},{<a!>},{<a!>},{<ab>}}, score of 1 + 2 = 3.\"\"\" // \"\n\ntest\n|> printfn \"Puzzle 9.1 = %A\"", "snpParentIdO": {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpName": "Garage & other things", "snpContent": "#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Garage =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}, "snpName": "Ping computers", "snpContent": "type Computer = {\n    name    : string\n    ip      : string option\n    sshPort : int    option\n    mac     : string option\n    user    : string option\n}\nwith static member New nm = \n      {\n        name    = nm\n        ip      = None\n        sshPort = None\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = None\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip, mac) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = None\n        mac     = Some mac\n        user    = None\n      }\n     static member New (nm, ip, port) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = None\n        user    = None\n      }\n     static member New (nm, ip, port, mac) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = Some mac\n        user    = None\n      }\n     static member New (nm, ip, port, mac, user) = \n      {\n        name    = nm\n        ip      = Some ip\n        sshPort = Some port\n        mac     = Some mac\n        user    = Some user\n      }\n\nlet computersData =\n    [\n        Computer.New(\"ABEASUS\"       , \"ABEASUS\"      , \"60:57:18:8E:F1:02\") // \"9C:EB:E8:1B:29:35\" wired\n        Computer.New(\"NeoRouter\"     , \"192.168.195.1\")\n        Computer.New(\"Router1\"       , \"192.168.5.1\"  , \"9c:d3:6d:b7:cb:e6\") // WNR1000v3\n        Computer.New(\"Router2\"       , \"192.168.5.3\"  , \"E0:91:F5:DE:F4:EC\") // WNDR3400v1\n        Computer.New(\"Router2\"       , \"192.168.5.40\" , \"E0:91:F5:DE:F4:ED\") // WNDR3400v1 Internet Port\n        Computer.New(\"OOMA\"          , \"192.168.5.2\"  )\n        Computer.New(\"EXSi\"          , \"192.168.5.5\"  )\n        Computer.New(\"Modem\"         , \"192.168.100.1\")\n        Computer.New(\"ABEHOME\"       , \"192.168.5.4\"  )\n        Computer.New(\"ABEHOME\"       , \"ABEHOME\"      )\n        Computer.New(\"AbeRaspi\"      , \"192.168.5.41\"  , 2200, \"80:1F:02:D3:77:3D\", \"pi\")\n        Computer.New(\"AbeRaspiNr\"    , \"192.168.195.42\", 2200, \"b8:27:eb:1a:ad:21\", \"pi\")\n        Computer.New(\"OldHTC\"        , \"192.168.5.39\"  , 2222, \"D8:B3:77:56:42:3E\", \"Abe\")\n        Computer.New(\"AbeWCam\"       , \"192.168.5.127\" )\n        Computer.New(\"JJJGarage\"     , \"192.168.15.242\")\n        Computer.New(\"FILESERVER1\"   , \"FILESERVER1\"   )\n        Computer.New(\"AbeRainMachine\", \"192.168.5.240\" )\n        Computer.New(\"Thermo-Abajo\"  , \"192.168.5.252\" , \"44a7cf5e3548\")\n        Computer.New(\"Thermo-Arriba\" , \"192.168.5.253\" , \"5cdad4fdb7d1\")\n        Computer.New(\"Google DNS\"    , \"8.8.8.8\"       )\n    ]\n\nlet computers         = computersData |> List.map   (fun c -> c.name, c.ip |> Option.defaultValue c.name)\nlet computer        n = computersData |> Seq.tryFind(fun c -> c.name = n                                )\nlet computerIp      n = computer n    |> Option.map (fun c -> c.ip         |> Option.defaultValue c.name)\nlet computerSshPort n = computer n    |> Option.bind(fun c -> c.sshPort                                 )\nlet computerMac     n = computer n    |> Option.bind(fun c -> c.mac                                     )\n\nlet getIpPortUser   c = c.ip.Value, c.sshPort.Value, c.user.Value\n\n#if WEBSHARPER\n#else\nlet OldHtcComputer                       = computer \"OldHTC\"   |> Option.get\nlet AbeRaspi                             = computer \"AbeRaspi\" |> Option.get\nlet OldHtcIp  , OldHtcPort  , OldHtcUser = getIpPortUser OldHtcComputer\nlet AbeRaspiIp, AbeRaspiPort, AbeUser    = getIpPortUser AbeRaspi\n#endif\n\nopen UsefulDotNet\n\n#if WEBSHARPER\n[<WebSharper.JavaScript false >]\n#endif\nlet pingOne c = computers |> List.filter (fst >> ((=) c)) |> pingSeveral \n\n#if WEBSHARPER\n[<WebSharper.JavaScript false >]\n#endif\nlet All    () = computers |> pingSeveral", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"bc75b72d-7942-4ac8-a71f-fc290321b875"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"77ddaeb8-a657-4246-8f17-65e10712930f"}, "snpName": "Thermostat Message", "snpContent": "\ntype ThermostatMessage = THMData of name:string * values:(string * string) []\n\n", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e8cbf634-01c4-4231-ab2a-6eec6905ac0c"}, "snpName": "Adb Run OpenGarage3", "snpContent": "open Useful\nopen UsefulDotNet\nopen Adb\n\nlet Adb_Run_OpenGarage3_Present = true\n\nlet shell    c = Adb.shell    c |> ignore\nlet shellSU  c = Adb.shellSU  c |> ignore\nlet keyevent k = Adb.keyevent k |> ignore\n\ntype PhoneCapabilities = {\n    connect       : unit                      -> unit\n    screenCapture : string                    -> unit\n    unlockScreen  : unit                      -> unit\n    click         : (int * int)               -> unit\n    dragDrop      : (int * int) * (int * int) -> unit\n}\n\nlet mutable currentPhoneN = None\n\nlet messaging = new WSMessagingBroker.FStationMessaging(\"screenCapture\")\n\nlet refreshCapture() = messaging.RunActionCall(\"Refresh\", \"actRunFableFs\", [| |])\n\nlet AbeFi = {\n    connect       = fun () -> currentPhoneN <- Some 2; Adb.connectUSB() |> ignore\n    screenCapture = fun file ->\n        Wrap.wrapper {\n            printfn \"%s\" <| Adb.captureScreen2 file\n            return! refreshCapture()\n        } |> Wrap.runSynchronouslyS false |> ignore\n    unlockScreen  = fun ()     -> keyevent 82 ; keyevent 66\n    click         = fun (x, y) -> shell <| sprintf \"input tap %d %d\" x y\n    dragDrop      = fun _ -> printfn \"not implemented dragDrop\"\n}\n\nlet file = @\".\\website\\screen.png\"\n    \nlet clickHtc (x, y) = \n    [\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 1 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 50 \"\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 0 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n    ] |> String.concat \" ; \"\n    |> shell\n\nlet dragDropHtc ((x1, y1), (x2,y2)) = \n    ((x1, y1), (x2,y2)) |> printfn \"sending swipe at %A\"\n    [\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x1 * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y1\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 1 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n        \"sendevent /dev/input/event2 3 48 58 \"\n        \"sendevent /dev/input/event2 3 50 58 \"\n        \"sendevent /dev/input/event2 3 58 58 \"\n        sprintf \"sendevent /dev/input/event2 3 53 %d \" (x2 * 2)\n        sprintf \"sendevent /dev/input/event2 3 54 %d \"  y2\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 50 \"\n        \"sendevent /dev/input/event2 0 2 0   \"\n        \"sendevent /dev/input/event2 1 330 0 \"\n        \"sendevent /dev/input/event2 0 0 0   \"\n        \"usleep 500 \"\n    ] |> String.concat \" ; \"\n    |> shell\n\nlet OldHtc = {\n    connect       = fun () -> currentPhoneN <- Some 1; Adb.connectWifi   OldHtcIp |> ignore\n    screenCapture = fun file ->\n        Wrap.wrapper {\n            Adb.captureScreen \"/data/local/screen.png\" file\n            return! refreshCapture()\n        } |> Wrap.runSynchronouslyS false |> ignore\n    unlockScreen  = fun () -> shell   \"/data/local/unlock.sh\"\n    click         = clickHtc\n    dragDrop      = dragDropHtc\n}\n\nlet Cyanogen = {\n    connect       = fun () -> currentPhoneN <- Some 3; Adb.connectUSB() |> ignore\n    screenCapture = Adb.captureScreen \"/data/local/screen.png\"\n    unlockScreen  = fun () -> shell   \"/data/local/unlock.sh\"\n    click         = clickHtc\n    dragDrop      = dragDropHtc\n}\n\nlet mapPhone f =\n    let map fm =\n        match currentPhoneN with \n        //| Some 1 -> Some OldHtc\n        | Some 2 -> Some AbeFi\n        | Some 3 -> Some Cyanogen\n        | _      -> Some OldHtc\n        |> Option.map fm\n        |> Option.defaultWith (fun () -> eprintfn \"Connect to phone first\")\n    if devices().Split('\\n').Length < 2 then\n        map (fun ph -> ph.connect())\n    map f\n    \nlet shellPh c = \n    if devices().Split('\\n').Length < 2 then\n        mapPhone (fun ph -> ph.connect())\n    shell c\n\nlet click p =\n    async {\n        mapPhone (fun ph -> printfn \"sending click %A\" p ; ph.click p)\n        do! Async.Sleep 1000\n        mapPhone (fun ph -> ph.screenCapture file)\n    } |> Async.RunSynchronously\n\nlet dragDrop p =\n    async {\n        mapPhone (fun ph -> printfn \"sending swipe %A\" p ; ph.dragDrop p)\n        do! Async.Sleep 1000\n        mapPhone (fun ph -> ph.screenCapture file)\n    } |> Async.RunSynchronously\n\n\nopen Useful\nopen UsefulDotNet\n\nlet client passphrase = \n    new Renci.SshNet.PrivateKeyFile(@\"D:\\Abelardo\\Documents\\MobaXterm\\home\\.ssh\\id_rsa\", passphrase)\n    |> getClientRsa OldHtcIp OldHtcPort OldHtcUser\n\nlet mutable OldHtcPassword = None\n\nlet doCmdSsh cmd = \n    if OldHtcPassword = None then printfn \"Passphrase not set\" else\n    doCmd (client OldHtcPassword.Value) cmd\n\n//let activateWifiSSH() = doCmdSsh \"ls -la\\n\"\n//let activateWifiSSH() = doCmdSSH \"su -c /home/local/airAdb.sh\"\nlet activateWifiSSH() = doCmdSsh \"su -c 'setprop service.adb.tcp.port 5555 ; stop adbd ; start adbd'\"\n\n// usage: input [text|keyevent]\n//   input text <string>\n//   input keyevent <event_code>\n// \n// 0 -->  \"KEYCODE_UNKNOWN\" \n// 1 -->  \"KEYCODE_MENU\" \n// 2 -->  \"KEYCODE_SOFT_RIGHT\" \n// 3 -->  \"KEYCODE_HOME\" \n// 4 -->  \"KEYCODE_BACK\" \n// 5 -->  \"KEYCODE_CALL\" \n// 6 -->  \"KEYCODE_ENDCALL\" \n// 7 -->  \"KEYCODE_0\" \n// 8 -->  \"KEYCODE_1\" \n// 9 -->  \"KEYCODE_2\" \n// 10 -->  \"KEYCODE_3\" \n// 11 -->  \"KEYCODE_4\" \n// 12 -->  \"KEYCODE_5\" \n// 13 -->  \"KEYCODE_6\" \n// 14 -->  \"KEYCODE_7\" \n// 15 -->  \"KEYCODE_8\" \n// 16 -->  \"KEYCODE_9\" \n// 17 -->  \"KEYCODE_STAR\" \n// 18 -->  \"KEYCODE_POUND\" \n// 19 -->  \"KEYCODE_DPAD_UP\" \n// 20 -->  \"KEYCODE_DPAD_DOWN\" \n// 21 -->  \"KEYCODE_DPAD_LEFT\" \n// 22 -->  \"KEYCODE_DPAD_RIGHT\" \n// 23 -->  \"KEYCODE_DPAD_CENTER\" \n// 24 -->  \"KEYCODE_VOLUME_UP\" \n// 25 -->  \"KEYCODE_VOLUME_DOWN\" \n// 26 -->  \"KEYCODE_POWER\" \n// 27 -->  \"KEYCODE_CAMERA\" \n// 28 -->  \"KEYCODE_CLEAR\" \n// 29 -->  \"KEYCODE_A\" \n// 30 -->  \"KEYCODE_B\" \n// 31 -->  \"KEYCODE_C\" \n// 32 -->  \"KEYCODE_D\" \n// 33 -->  \"KEYCODE_E\" \n// 34 -->  \"KEYCODE_F\" \n// 35 -->  \"KEYCODE_G\" \n// 36 -->  \"KEYCODE_H\" \n// 37 -->  \"KEYCODE_I\" \n// 38 -->  \"KEYCODE_J\" \n// 39 -->  \"KEYCODE_K\" \n// 40 -->  \"KEYCODE_L\" \n// 41 -->  \"KEYCODE_M\" \n// 42 -->  \"KEYCODE_N\" \n// 43 -->  \"KEYCODE_O\" \n// 44 -->  \"KEYCODE_P\" \n// 45 -->  \"KEYCODE_Q\" \n// 46 -->  \"KEYCODE_R\" \n// 47 -->  \"KEYCODE_S\" \n// 48 -->  \"KEYCODE_T\" \n// 49 -->  \"KEYCODE_U\" \n// 50 -->  \"KEYCODE_V\" \n// 51 -->  \"KEYCODE_W\" \n// 52 -->  \"KEYCODE_X\" \n// 53 -->  \"KEYCODE_Y\" \n// 54 -->  \"KEYCODE_Z\" \n// 55 -->  \"KEYCODE_COMMA\" \n// 56 -->  \"KEYCODE_PERIOD\" \n// 57 -->  \"KEYCODE_ALT_LEFT\" \n// 58 -->  \"KEYCODE_ALT_RIGHT\" \n// 59 -->  \"KEYCODE_SHIFT_LEFT\" \n// 60 -->  \"KEYCODE_SHIFT_RIGHT\" \n// 61 -->  \"KEYCODE_TAB\" \n// 62 -->  \"KEYCODE_SPACE\" \n// 63 -->  \"KEYCODE_SYM\" \n// 64 -->  \"KEYCODE_EXPLORER\" \n// 65 -->  \"KEYCODE_ENVELOPE\" \n// 66 -->  \"KEYCODE_ENTER\" \n// 67 -->  \"KEYCODE_DEL\" \n// 68 -->  \"KEYCODE_GRAVE\" \n// 69 -->  \"KEYCODE_MINUS\" \n// 70 -->  \"KEYCODE_EQUALS\" \n// 71 -->  \"KEYCODE_LEFT_BRACKET\" \n// 72 -->  \"KEYCODE_RIGHT_BRACKET\" \n// 73 -->  \"KEYCODE_BACKSLASH\" \n// 74 -->  \"KEYCODE_SEMICOLON\" \n// 75 -->  \"KEYCODE_APOSTROPHE\" \n// 76 -->  \"KEYCODE_SLASH\" \n// 77 -->  \"KEYCODE_AT\" \n// 78 -->  \"KEYCODE_NUM\" \n// 79 -->  \"KEYCODE_HEADSETHOOK\" \n// 80 -->  \"KEYCODE_FOCUS\" \n// 81 -->  \"KEYCODE_PLUS\" \n// 82 -->  \"KEYCODE_MENU\" \n// 83 -->  \"KEYCODE_NOTIFICATION\" \n// 84 -->  \"KEYCODE_SEARCH\" \n// 85 -->  \"TAG_LAST_KEYCODE\"\n// \n// \n// Image capture mode: adb shell \"am start -a android.media.action.IMAGE_CAPTURE\"\n// Video capture mode: adb shell \"am start -a android.media.action.VIDEO_CAPTURE\"\n// To focus: adb shell \"input keyevent KEYCODE_FOCUS\"\n// To take a photo or start/stop recording: adb shell \"input keyevent KEYCODE_CAMERA\"\n// ", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"555306ec-f8cc-455f-b01f-9d86fbb2682d"}, {"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}, {"SnippetId" :"bff6817d-fe67-4777-9a13-50393e8900c4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f4439890-9c51-46b1-94a8-72e35aaf98d1"}, "snpName": "AbeRaspi", "snpContent": "open Useful\nopen UsefulDotNet\n\nlet client pwd = getClient AbeRaspiIp AbeRaspiPort AbeUser pwd\n\nlet mutable AbeRaspiPassword = None\n\nlet doCmdF f cmd = \n    if AbeRaspiPassword = None then printfn \"Password not set\" else\n    doCmdF (client AbeRaspiPassword.Value) f cmd\n    \nlet doCmd cmd = doCmdF id cmd\n\n", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"555306ec-f8cc-455f-b01f-9d86fbb2682d"}, {"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"27bcf9a6-29e7-4f07-81a0-61704feaa012"}, "snpName": "Thermostats", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n//#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.DesignTime.dll\"\nopen System.Net\nopen System.IO\nopen FSharp.Data.HttpRequestHeaders\nopen FSharp.Data.JsonExtensions\nopen FSharp.Data\nopen Useful\nopen WSMessagingBroker\n\nlet ThermoAbajoIp  = computer \"Thermo-Abajo\"  |> Option.get |> fun c -> c.ip.Value\nlet ThermoArribaIp = computer \"Thermo-Arriba\" |> Option.get |> fun c -> c.ip.Value\n\ntype Tstat = JsonProvider<\"\"\"{\"temp\":74.00,\"tmode\":1,\"fmode\":0,\"override\":1,\"hold\":1,\"t_heat\":73.00,\"tstate\":0,\"fstate\":0,\"time\":{\"day\":1,\"hour\":14,\"minute\":13},\"t_type_post\":0}\"\"\">\n\nlet messaging = new WSMessagingClient(\"Thermostats\")\nprintfn \"%A\" messaging.EndPoint\n\nlet thermostats =\n    [ \"Arriba\", ThermoArribaIp\n      \"Abajo\" , ThermoAbajoIp\n    ]\n\nlet makeUri ip cmd = sprintf \"http://%s/%s\" ip cmd\n\nlet rec json2props cmd (json: JsonValue) =\n    json.Properties\n    |> Array.collect (fun (p, v) ->\n        let cmd2 = cmd + \"/\" + p\n        if v.Properties.Length > 0 \n        then json2props cmd2 v\n        else [| cmd2, v.ToString() |]\n     )\n     \nlet forThermostat tname = \n    thermostats\n    |> Seq.filter (fun (n, _) -> n = tname || tname = \"*\")\n\nlet queryThermoStat cmd tname =\n    forThermostat tname\n    |> Seq.map    (fun (n,ip) -> \n         makeUri ip cmd\n         |> Tstat.AsyncLoad \n         |> Async.map (fun m -> \n             json2props cmd m.JsonValue\n             |> fun data -> THMData(n, data)\n             |> mapPrint\n             |> messaging.SendAndForget (Address \"ThermostatsSite\") \n             |> Wrap.RunSynchronously \n         )\n       )\n    |> Async.Parallel\n    |> Async.RunSynchronously\n    |> ignore\n\nlet postThermostat cmd body tname =\n    forThermostat tname\n    |> Seq.iter (fun (n, ip) ->\n        Http.RequestString( makeUri ip cmd\n                          , headers = [ ContentType HttpContentTypes.Json ]\n                          , body    = TextRequest body\n                          )\n        |> printfn \"%s\"\n        queryThermoStat cmd n       \n    )\n    \nlet postTstat parm value tname =\n    sprintf \"{%A:%s}\" parm value\n    |> postThermostat \"tstat\"      <| tname\n\nlet setCurrentTime () =\n    System.DateTime.Now\n    |> (fun now -> sprintf \"{ %A: %d, %A: %d }\" \"hour\" now.Hour \"minute\" now.Minute)\n    |> postThermostat \"tstat/time\" <| \"*\"\n\nlet setTmode mode = postTstat \"tmode\" mode \"*\"\nlet setFmode mode = postTstat \"fmode\" mode \"*\"\n    \n    ", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"77ddaeb8-a657-4246-8f17-65e10712930f"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}, {"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c60a636a-5e8a-49ec-85f9-8f934c8f9b25"}, "snpName": "Create Symbolic Links", "snpContent": "open UsefulDotNet\n\n//let runAs       cmd         = runProcess3 \"runas.exe\" \"/user:amieres@hotmail.com cmd.exe\"\nlet runCommand  cmd         = RunProcess.runToFinish \"cmd.exe\" <| sprintf \"/C %s\"           cmd\nlet cmd_del     file        = runCommand                       <| sprintf \"del       %A\"    file\nlet cmd_rmdir   dir         = runCommand                       <| sprintf \"rmdir     %A\"    dir\nlet cmd_mklink  link target = runCommand                       <| sprintf \"mklink /D %A %A\" link target\n\n//cmd_del \"C:\\Program Files\\hello.txt\" |> printfn \"%A\"\n\nopen System.IO\n\n//File.Delete \"C:\\Program Files\\hello.txt\"\nlet createDirLinkInD d = \n    try File.Delete      d with _ -> ()\n    try Directory.Delete d with _ -> ()\n    cmd_mklink d (\"D\" + d.[1..])\n    |> printfn \"%A\"\n\ncreateDirLinkInD \"C:\\Program Files\\dotnet\"\ncreateDirLinkInD \"C:\\Program Files\\Git\"\ncreateDirLinkInD \"C:\\Program Files\\Microsoft SQL Server\"\ncreateDirLinkInD \"C:\\Program Files\\Microsoft SDKs\"\ncreateDirLinkInD \"C:\\Program Files\\Java\"\ncreateDirLinkInD \"C:\\Program Files\\RStudio\"\ncreateDirLinkInD \"C:\\Program Files\\R\"\ncreateDirLinkInD \"C:\\Program Files\\Oracle\"\ncreateDirLinkInD \"C:\\Program Files (x86)\\Android\"\n\ncmd_mklink \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\packages\" \"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\packages\"\ncmd_mklink \"D:\\Abe\\OLAPDBs\\RuizModel\"                                   \"\\\\FILESERVER1\\CIPHERShared\\Clientes\\Ruiz\\RuizModel\"\n", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0a1bc147-ca13-4f2c-9c8b-533b42001d8f"}, "snpName": "paket dependencies", "snpContent": "framework: net461\n\nsource https://www.nuget.org/api/v2\n\nnuget FSharp.Compiler.Tools 4.1.23\nnuget FSharp.Compiler.Service 17.0.1\n\nnuget CryptSharpOfficial \nnuget FSharp.Configuration\nnuget FSharp.Core\nnuget FSharp.Data\nnuget FSharp.Data.SqlClient\nnuget HtmlAgilityPack\nnuget Microsoft.Owin\nnuget Microsoft.Owin.Diagnostics\nnuget Microsoft.Owin.FileSystems\nnuget Microsoft.Owin.Host.HttpListener\nnuget Microsoft.Owin.Hosting\nnuget Microsoft.Owin.StaticFiles\nnuget Mono.Cecil 0.10.0\nnuget Owin\nnuget Owin.Compression 1.0.18\nnuget System.ValueTuple\n//nuget System.IO.Compression 4.3.0-preview1-24530-04\nnuget System.IO.Compression\nnuget WebSharper          \nnuget WebSharper.Compiler \nnuget WebSharper.Data     \nnuget WebSharper.FSharp\nnuget WebSharper.Owin\nnuget WebSharper.Owin.WebSocket\nnuget WebSharper.UI\nnuget WebSharper.Formlets    \nnuget WebSharper.Html\nnuget Newtonsoft.Json\nnuget XPlot.Plotly\nnuget SSH.NET\n\nnuget FSharpPlus 1.0.0-CI00136\n\nnuget FSharp.Quotations.Evaluator\n\nnuget Fable.Core\nnuget Fable.Import.Browser\n\nnuget NUnit 2.6.4\nnuget Unquote\n\nnuget CommonServiceLocator \n\nnuget AWSSDK.Core\nnuget AWSSDK.Lambda\n\nnuget FSharp.ComProvider 1.0.0-pre1\n\nnuget FsCheck\n\nnuget FSharp.Formatting\n\ngroup ruleeditor\n    framework: net461\n", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"833fc159-d686-4e6f-a25a-203a96adc537"}, "snpName": "paket", "snpContent": "#define PAKET\nopen UsefulDotNet\n\nlet paket cmd = RunProcess.runToFinish @\"..\\.paket\\paket.exe\" cmd\n\nopen System\nopen System.IO\n\nSystem.Net.ServicePointManager.SecurityProtocol <- System.Net.SecurityProtocolType.Tls12 // Github uses TLS 1.2\nlet downloadPaket() =\n//    if not (File.Exists \"paket.exe\") then\n        async {\n            let url    = \"http://fsprojects.github.io/Paket/stable\"\n            use wc     = new Net.WebClient()\n            wc.DownloadProgressChanged.Add(fun a -> printfn \"Progress downloading paket.exe: %d\" a.ProgressPercentage)\n            let tmp    = Path.GetTempFileName()\n            let stable = wc.DownloadString(url)\n            do! wc.AsyncDownloadFile(stable |> Uri, tmp)\n            File.Move(tmp, Path.GetFileName stable)\n        } |> Async.RunSynchronously\n        printfn \"Finished downloading paket.exe!\"\n        \nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen System.IO\n\nlet fsStation      = FStationMessaging(\"Compile Modules\")\n\nlet snippetName    = \"FSSGlobal/F# Code/Garage & other things/paket dependencies\"\nlet fsStationPath  = @\"..\"\n\nlet writeDependenciesW = \n    Wrap.wrap {\n        let! snippetO     = fsStation.RequestSnippet snippetName\n        let  dependencies = Path.Combine(fsStationPath, \"paket.dependencies\" )\n        printfn \"Updating file %s ...\" dependencies\n        File.WriteAllText(dependencies, snippetO.Value.content)\n        printfn \"Updated!\"\n    }\n\nlet updateFile() = writeDependenciesW |> Wrap.RunSynchronously\n        ", "snpParentIdO": {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, "snpPredIds": [{"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"b30f4582-64bd-49e5-aca2-29897fef74c5"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8d568171-bb31-4bee-a9a6-46514fe8f64e"}, "snpName": "AleaAPI", "snpContent": "module AleaAPI =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"916982d0-1d30-4cc7-8794-0f8a3b3e9a5d"}, "snpName": "Alea Interfase", "snpContent": "//#I @\"D:\\Program Files (x86)\\Infor\\BI\\OLAP\\bin\"\n//#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\n#define FSI32BIT\n\n#r \"../packages/FSharp.ComProvider/lib/net40/FSharp.ComProvider.dll\"\n\nopen Useful\n\nmodule Alea =\n\n    type MdsAut = TypeLib.``Alea Automation Server (Inproc)``.``1.0``\n    let private g  = new MdsAut.GeneralClass        ()\n    let private s  = new MdsAut.ServersClass        ()\n    let private d  = new MdsAut.DimensionsClass     ()\n    let private c  = new MdsAut.TablesClass         ()\n    let private at = new MdsAut.AttributeTablesClass()\n    let private e  = new MdsAut.ElementsClass       ()\n    let private l  = new MdsAut.DataCellsClass      ()\n\n    let res = g.MdsInit 0\n    \n    let aleaErr ef n = g.MdsError n |> unbox<string> |> sprintf \"Alea %d: %s\" n |> ef\n    type AleaResult<'T> = Result<'T, string>\n\n    let callR<'T> ef (v: obj) =\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then AleaResult<'T>.Error (aleaErr ef errN)\n        else v |> unbox<'T> |> AleaResult<'T>.Ok\n        |> Async.retn\n        \n    let callR2<'T> ef f p = \n        let v    = f p\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then AleaResult<'T>.Error (aleaErr ef errN)\n        else v |> unbox<'T> |> AleaResult<'T>.Ok\n        |> Async.retn\n\n    type [<JavaScript>] Server    = Server    of string\n    type [<JavaScript>] Dimension = Dimension of string\n    type [<JavaScript>] Cube      = Cube      of string\n    type [<JavaScript>] Element   = Element   of string\n    type [<JavaScript>] Field     = {\n        fldName        : string\n        fldTable       : int16\n        fldDescription : string\n        fldType        : int16\n        fldLength      : int16\n        fldDecimals    : int16\n    }\n    type Handle    = Handle    of int\n    \n    module Server =\n        let [< JavaScript >] address (Server n) = n\n        let ef       fn server = (sprintf \"Server.%s %A: %s\" fn server)\n        let [< Rpc >] connectRl    server = s.ServerConnectEx (address server, \"Admin\", \"\") |> callR<bool> (ef \"connectR\"    server)\n        let [< Rpc >] disconnectRl server = s.ServerDisconnect(address server             ) |> callR<bool> (ef \"disconnectR\" server)\n        let [<JavaScript>] connectR       = Log.InOutA \"connectRl\"    connectRl\n        let [<JavaScript>] disconnectR    = Log.InOutA \"disconnectRl\" disconnectRl\n\n    module Element = \n        let [<JavaScript>] name (Element n)  = n\n        let dname (Dimension n) = n\n        let ef          fn server dim elem   = (sprintf \"Element.%s %A %A %A: %s\" fn server dim elem)\n        let withR<'T>   fn server dim elem f = f <| Server.address server <| dname dim <| name elem |> callR<'T> (ef fn server dim elem)\n        let [< Rpc >] childrenCountR server dim elem   = withR<int   > \"childrenCountR\" server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenCount(servAd, dimN, elemN) \n        let [< Rpc >] childrenNameR  server dim elem i = withR<string> \"childrenNameR\"  server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenName (servAd, dimN, elemN, i)\n        let [< Rpc >] childrenR      server dim elem   = wrap {\n                                                             let! n     = childrenCountR server dim elem |> Wrap.fromAsyncResultStr\n                                                             let! elems = seq [1..n] |> Wrap.Seq.traverseM (childrenNameR server dim elem >> Async.map Result.fromResult >> WAsyncR)\n                                                             return elems |> Seq.map Element\n                                                         } |> Wrap.toAsyncResultStr\n    module Handle =\n        let int   (Handle n) = n\n        let int16 (Handle n) = int16 n\n        \n    module Dimension = \n        let [<JavaScript>] name    (Dimension n)                         = n\n        let ef                    fn server dim                          = (sprintf \"Dimension.%s %A %A: %s\" fn server dim)\n        let withR<'T>             fn server dim f                        = f <| Server.address server <| name dim |> callR<'T> (ef fn server dim)\n        let withL<'T>             fn server dim f                        = Log.InOutA fn (fun dim -> withR<'T> fn server dim f)    <| dim\n        let [< Rpc >] import         server dim          df ef del desc  = withL<bool  > \"import\"         server dim   <| fun servAd dimN -> d.DimensionImport        (servAd, dimN, df, ef, (del:string), (desc:string))\n        let [< Rpc >] editBeginR     server dim          clear desc      = withL<bool  > \"editBeginR\"     server dim   <| fun servAd dimN -> d.DimensionEditBegin     (servAd, dimN, clear, desc |> Option.defaultValue dimN)\n        let [< Rpc >] addElementR    server dim eType elem parent weight = withR<bool  > \"addElementR\"    server dim   <| fun servAd dimN -> d.DimensionEditAddElement(servAd, dimN, eType, elem, parent, weight, \"\")\n        let [< Rpc >] editCommitR    server dim commit                   = withL<bool  > \"editCommitR\"    server dim   <| fun servAd dimN -> d.DimensionEditCommit    (servAd, dimN, commit) \n        let [< Rpc >] elementsCountR server dim                          = withR<int   > \"elementsCountR\" server dim   <| fun servAd dimN -> e.ElementsCount          (servAd, dimN) \n        let [< Rpc >] elementsNameR  server dim i                        = withR<string> \"elementsNameR\"  server dim   <| fun servAd dimN -> e.ElementsName           (servAd, dimN, i) \n        let [< Rpc >] topElements    server dim                          = let arr = ref [||]\n                                                                           withR<bool> \"ElementTopLevelGetArray\" server dim <| fun servAd dimN -> e.ElementTopLevelGetArray(servAd, dimN, arr)\n                                                                           |> Async.map (Result.fromResult >> Result.map (fun _ -> !arr |> Seq.map Element) >> Result.toResultStr)\n     \n        let [< Rpc >] elementsR server dim = wrap {\n                                                 let! n     = elementsCountR server dim |> Wrap.fromAsyncResultStr\n                                                 let! names = seq [1..n] |> Wrap.Seq.traverseM (elementsNameR server dim >> Async.map Result.fromResult >> WAsyncR)\n                                                 let  elems = names |> Seq.map Element\n                                                 return elems\n                                             } |> Wrap.toAsyncResultStr\n        let [< Rpc >] inputsR   server dim = elementsR server dim |> Wrap.fromAsyncResultStr\n                                             |> Wrap.bind (Wrap.Seq.traverseM (fun elem -> Element.childrenCountR server dim elem |> Async.map Result.fromResult |> WAsyncR |> Wrap.map (fun cnt -> if cnt <> 0 then Some elem else None)) )\n                                             |> Wrap.map  (Seq.choose id)\n                                             |> Wrap.toAsyncResultStr\n        let [< Rpc >] attTableDeleteR      server dim nT                  = withL<bool> \"attTableDeleteR\"      server dim <| fun servAd dimN -> at.ATableDelete     (servAd, dimN, nT |> int)\n        let [< Rpc >] attTableCreateBeginR server dim nT                  = withL<int > \"attTableCreateBeginR\" server dim <|(fun servAd dimN -> at.ATableCreateBegin(servAd, dimN, nT - 1s  )) |> Async.map (Result.fromResult >> Result.map Handle >> Result.toResultStr)\n        let [< Rpc >] fieldAddR            handle fld                     =                                                                     at.ATableFieldAdd(    Handle.int16 handle, fld.fldName, fld.fldDescription, fld.fldType, fld.fldLength, fld.fldDecimals) |> callR<bool> (sprintf \"Dimension.fieldAddR     %s %s\" fld.fldName) \n        let [< Rpc >] createCommitR        handle                         = Log.Out     \"createCommitR\"                   <|(fun handleN     -> at.ATableCreateCommit(Handle.int16 handleN                                                                            )) <| handle |> callR<bool> (sprintf \"Dimension.createCommitR %s\")\n                                                                                                                          \n\n    module Field =\n        let [< JavaScript >] newField fldName fldTable fldDescription fldType fldLength fldDecimals   = {\n            fldName        = fldName       \n            fldTable       = fldTable      \n            fldDescription = fldDescription\n            fldType        = fldType       \n            fldLength      = fldLength     \n            fldDecimals    = fldDecimals   \n        }\n        let [<JavaScript>] name                  fld        = fld.fldName\n        let number                               fld        = fld.fldTable\n        let withR<'T>              fn server dim fld ef   f = f <| Server.address server <| Dimension.name dim <| number fld <| name fld |> callR<'T> (ef fn server dim fld)\n        let ef                     fn server dim fld        = sprintf \"Field.%s %A %A %A: %s\"     fn server dim fld\n        let ef2               elem fn server dim fld err    = sprintf \"%s Element: '%s'\"      (ef fn server dim fld err) elem\n        let [< Rpc >] getInfoDescR    server dim fld        = withR<string> \"getInfoDescR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 2)\n        let [< Rpc >] getInfoAtypR    server dim fld        = withR<int16 > \"getInfoAtypR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 3)\n        let [< Rpc >] getInfoLengthR  server dim fld        = withR<int16 > \"getInfoLengthR\"  server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 4)\n        let [< Rpc >] getInfoDecimalR server dim fld        = withR<int16 > \"getInfoDecimalR\" server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 5)\n        let [< Rpc >] putValueR       server dim fld v elem = withR<bool  > \"putValueR\"       server dim fld (ef2 elem) <| fun servAd dimN nS field -> at.ATableFieldPutValue(v, servAd, dimN, nS |> int, elem, field   )\n\n    module Cube =\n        let [<JavaScript>] name  (Cube n)          = n\n        let ef            fn server cube           = (sprintf \"Cube.%s %A %A: %s\" fn server cube)\n        let withR<'T>     fn server cube f         = callR2<'T> (ef fn server cube) (f <| Server.address server) <| name cube\n        let withL<'T>     fn server cube f         = Log.InOutA fn (fun cube -> withR<'T> fn server cube f)    <| cube\n        let [< Rpc >] create server cube ds        = withL<bool  > \"create\"           server cube <| fun servAd cubeN -> \n                                                        let dims = ds |> Array.map Dimension.name\n                                                        let dim n = Array.tryItem n dims |> Option.defaultValue null\n                                                        c.TablesAdd(servAd, cubeN, cubeN, dims.[0], dims.[1]\n                                                                  , dim  2, dim  3, dim  4, dim  5\n                                                                  , dim  6, dim  7, dim  8, dim  9\n                                                                  , dim 10, dim 11, dim 12, dim 13\n                                                                  , dim 14, dim 15, dim 16, dim 17\n                                                                  , dim 18, dim 19)\n        let [< Rpc >] delete           server cube           = withL<bool  > \"delete\"           server cube <| fun servAd cubeN -> c.TableKill(servAd, cubeN)\n        let [< Rpc >] putRulesForcedR  server cube xml       = withL<bool  > \"putRulesForced\"   server cube <| fun servAd cubeN -> c.TablePutRulesForced(servAd, cubeN, xml)\n        let [< Rpc >] setMeasure       server cube dim       = withR<bool  > \"setMeasure\"       server cube <| fun servAd cubeN -> c.TableSetMeasureDimension(servAd, cubeN, Dimension.name dim)\n        let [< Rpc >] dimensionsCountR server cube           = withR<int   > \"dimensionsCountR\" server cube <| fun servAd cubeN -> c.TableDimensionsCount(servAd, cubeN)\n        let [< Rpc >] exists           server cube           = dimensionsCountR                 server cube |> Async.map (Result.fromResult >> Result.map ((>) 0) >> Result.ifError false)\n        let [< Rpc >] dimensionsNameR  server cube i         = withR<string> \"dimensionsNameR\"  server cube <| fun servAd cubeN -> c.TableDimensionsName (servAd, cubeN, i)\n        let [< Rpc >] putValueExR      server cube (v:obj) elems = withR<bool  > \"putValueExR\"      server cube <| fun servAd cubeN -> l.DataPutValueEx (servAd, cubeN, v, elems)\n        let [< Rpc >] dimensionsR      server cube           = wrap {\n                                                                  let! n    = dimensionsCountR server cube |> Wrap.fromAsyncResultStr\n                                                                  let! dims = seq [1..n]\n                                                                              |> Wrap.Seq.traverseM(dimensionsNameR server cube >> Wrap.fromAsyncResultStr)\n                                                                  return dims |> Seq.map Dimension |> Seq.toArray\n                                                               } |> Wrap.toAsyncResultStr\n        let [< Rpc >] bulkTransferBeginR  lType              = l.BulkTransferBegin(lType)             |> callR<bool> (sprintf \"Cube.bulkTransferBeginR: %s\")\n        let [< Rpc >] bulkTransferCommitR lType stop log     = l.BulkTransferCommit(lType, stop, log) |> callR<bool> (sprintf \"Cube.bulkTransferCommitR: %s\")\n", "snpParentIdO": {"SnippetId" :"8d568171-bb31-4bee-a9a6-46514fe8f64e"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5416e265-2418-4907-8810-4dc99bafe392"}, "snpName": "MonadicAlea", "snpContent": "[< JavaScript >]\nmodule AleaN =\n    open Alea\n    \n    type   ServerN<'T>           = ServerN of (Server -> Wrap<'T>)\n    module ServerN =        \n        let address              = ServerN   (Server.address     >> Wrap.Return            )\n        let connectR             = ServerN   (Server.connectR    >> Wrap.fromAsyncResultStr)\n        let disconnectR          = ServerN   (Server.disconnectR >> Wrap.fromAsyncResultStr)\n        \n        let inline rtn  a                                   = ServerN(fun _ -> Wrap.Return a )\n        let inline rtnR a                                   = ServerN(fun _ ->             a )\n        let inline getResult                    (ServerN a) = ServerN(fun s -> a s |> Wrap.getResultW )\n        let inline bind  (f: 'a -> ServerN<'b>) (ServerN a) = ServerN(fun s -> a s |> Wrap.bind (f >> function ServerN b -> b s) )\n        let inline map    f m                               = bind (f >> rtn) m\n        let inline bindR  f                     (ServerN a) = ServerN(fun s -> a s |> Wrap.bind f)\n        let inline combine a b                              = a |> bind b\n        let inline delayRun f                               = ServerN(fun s -> match f() with ServerN g -> g s)\n        let tryWith    hndl fm = match fm() with ServerN a -> ServerN(fun s -> (fun () -> a s) |> Wrap.tryWith    (hndl >> function ServerN h -> h s) )\n        let tryFinally comp fm = match fm() with ServerN a -> ServerN(fun s -> (fun () -> a s) |> Wrap.tryFinally  comp )\n        let mutable private servers = Set []\n        let        run server                  (ServerN m)  = wrap {\n            if servers |> Set.contains server |> not then\n                let! r_  = Server.connectR    server |> Wrap.fromAsyncResultStr\n                servers <- servers |> Set.add server\n            let! res = m                  server\n            return res\n        }\n        let         disconnectServer server =  wrap {\n            if servers |> Set.contains server then\n                 servers <- servers |> Set.remove server\n                 let! res = Server.disconnectR server |> Wrap.fromAsyncResultStr\n                 return res\n            else return false\n        }\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n        \n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = delayRun f\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.Using(disposable:#System.IDisposable, body) = let dispose () = if disposable :> obj <> null then disposable.Dispose()\n                                                                      tryFinally dispose      (fun ()-> body disposable)\n            member this.TryFinally(body, compensation)              = tryFinally compensation           body\n            member this.TryWith   (body, handler     )              = tryWith    handler                body\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n                        \n                        \n    type   ElementN<'T>          = ElementN   of (Server -> Dimension -> Element-> Wrap<'T>)\n    module ElementN =         \n        let name                 = ElementN   (fun s d e -> Element.name               e   |> Wrap.Return )\n        let childrenCountR       = ElementN   (fun s d e -> Element.childrenCountR s d e   |> Wrap.fromAsyncResultStr)\n        let childrenNameR     i  = ElementN   (fun s d e -> Element.childrenNameR  s d e i |> Wrap.fromAsyncResultStr)\n        let childrenR            = ElementN   (fun s d e -> Element.childrenR      s d e   |> Wrap.fromAsyncResultStr)\n                                              \n    type   HandleN<   'T>                                   = HandleN    of (Handle -> Wrap<'T>)\n    module HandleN                                          =\n        let inline rtn a                                    = HandleN(fun _ -> Wrap.Return    a)\n        let inline rtnR a                                   = HandleN(fun _ ->                a)\n        let inline bind  (f: 'a -> HandleN<'b>) (HandleN a) = HandleN(fun h -> a h |> Wrap.bind (f >> function HandleN b -> b h) )\n        let inline map f m                                  = bind (f >> rtn) m\n        let inline combine a b                              = a |> bind b\n        let inline delayRun f                               = HandleN(fun s -> match f() with HandleN g -> g s)\n        let tryWith    hndl fm = match fm() with HandleN a -> HandleN(fun s -> (fun () -> a s) |> Wrap.tryWith    (hndl >> function HandleN h -> h s) )\n        let tryFinally comp fm = match fm() with HandleN a -> HandleN(fun s -> (fun () -> a s) |> Wrap.tryFinally  comp )\n        let inline run closer handle (HandleN m)            = m handle |> Wrap.bind (fun _ -> closer handle)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = delayRun f\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.Using(disposable:#System.IDisposable, body) = let dispose () = if disposable :> obj <> null then disposable.Dispose()\n                                                                      tryFinally dispose      (fun ()-> body disposable)\n            member this.TryFinally(body, compensation)              = tryFinally compensation           body\n            member this.TryWith   (body, handler     )              = tryWith    handler                body\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n        \n    type   DimensionN<'T>                           = DimensionN of (Server -> Dimension -> Wrap<'T>)\n    module DimensionN                               = \n        let serverDim                               = DimensionN (fun s d ->                               (s,d)                         |> Wrap.Return )\n        let name                                    = DimensionN (fun s d -> Dimension.name                   d                          |> Wrap.Return )\n        let import                  fi ef del desc  = DimensionN (fun s d -> Dimension.import               s d          fi ef del desc  |> Wrap.fromAsyncResultStr)\n        let editBeginR              clear desc      = DimensionN (fun s d -> Dimension.editBeginR           s d          clear desc      |> Wrap.fromAsyncResultStr)\n        let addElementR    eType elem parent weight = DimensionN (fun s d -> Dimension.addElementR          s d eType elem parent weight |> Wrap.fromAsyncResultStr)\n        let editCommitR    commit                   = DimensionN (fun s d -> Dimension.editCommitR          s d commit                   |> Wrap.fromAsyncResultStr)\n        let elementsCountR                          = DimensionN (fun s d -> Dimension.elementsCountR       s d                          |> Wrap.fromAsyncResultStr)\n        let elementsNameR  i                        = DimensionN (fun s d -> Dimension.elementsNameR        s d i                        |> Wrap.fromAsyncResultStr)\n        let topElements                             = DimensionN (fun s d -> Dimension.topElements          s d                          |> Wrap.fromAsyncResultStr)\n        let elementsR                               = DimensionN (fun s d -> Dimension.elementsR            s d                          |> Wrap.fromAsyncResultStr)\n        let inputsR                                 = DimensionN (fun s d -> Dimension.inputsR              s d                          |> Wrap.fromAsyncResultStr)\n        let attTableDeleteR          nT             = DimensionN (fun s d -> Dimension.attTableDeleteR      s d nT                       |> Wrap.fromAsyncResultStr)\n        let attTableCreateBeginR     nT             = DimensionN (fun s d -> Dimension.attTableCreateBeginR s d nT                       |> Wrap.fromAsyncResultStr)\n        let createCommitR                           =                        Dimension.createCommitR                                     >> Wrap.fromAsyncResultStr\n        let getInfoDescR                 fld        = DimensionN (fun s d -> Field.getInfoDescR             s d fld                      |> Wrap.fromAsyncResultStr)\n        let getInfoAtypR                 fld        = DimensionN (fun s d -> Field.getInfoAtypR             s d fld                      |> Wrap.fromAsyncResultStr)\n        let getInfoLengthR               fld        = DimensionN (fun s d -> Field.getInfoLengthR           s d fld                      |> Wrap.fromAsyncResultStr)\n        let getInfoDecimalR              fld        = DimensionN (fun s d -> Field.getInfoDecimalR          s d fld                      |> Wrap.fromAsyncResultStr)\n        let putValueR                    fld v elem = DimensionN (fun s d -> Field.putValueR                s d fld v elem               |> Wrap.fromAsyncResultStr)\n\n        let rtn  a                                             = DimensionN(fun _ _ ->          Wrap.Return a)\n        let rtnR a                                             = DimensionN(fun _ _ ->                      a)\n        let getResult                           (DimensionN a) = DimensionN(fun s d -> a s d |> Wrap.getResultW)\n        let bind (f: 'a -> DimensionN<'b>)      (DimensionN a) = DimensionN(fun s d -> a s d |> Wrap.bind (f >> function DimensionN b -> b s d) )\n        let map f m                                            = bind (f >> rtn) m\n        let bindR  f                            (DimensionN a) = DimensionN(fun s d -> a s d |> Wrap.bind f)\n        let combine a b                                        = a |> bind b\n        let inline delayRun f                                  = DimensionN(fun s d -> match f() with DimensionN g -> g s d)\n        let tryWith    hndl fm = match fm() with DimensionN a -> DimensionN(fun s d -> (fun () -> a s d) |> Wrap.tryWith    (hndl >> function DimensionN h -> h s d) )\n        let tryFinally comp fm = match fm() with DimensionN a -> DimensionN(fun s d -> (fun () -> a s d) |> Wrap.tryFinally  comp )\n        let run server dim                 (DimensionN m) = m server dim\n        let runS dim m                                    = ServerN (fun s -> run s dim m)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = delayRun f\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.Using(disposable:#System.IDisposable, body) = let dispose () = if disposable :> obj <> null then disposable.Dispose()\n                                                                      tryFinally dispose      (fun ()-> body disposable)\n            member this.TryFinally(body, compensation)              = tryFinally compensation           body\n            member this.TryWith   (body, handler     )              = tryWith    handler                body\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   FieldN<'T>                           = FieldN of (Server -> Dimension -> Field -> Wrap<'T>)\n    module FieldN                               = \n        let fieldAddR              = FieldN  (fun s d fld-> HandleN (fun h -> Dimension.fieldAddR h fld |> Wrap.fromAsyncResultStr) |> Wrap.Return )\n        let getInfoDescR           = FieldN  (fun s d fld-> Field.getInfoDescR             s d fld        |> Wrap.fromAsyncResultStr)\n        let getInfoAtypR           = FieldN  (fun s d fld-> Field.getInfoAtypR             s d fld        |> Wrap.fromAsyncResultStr)\n        let getInfoLengthR         = FieldN  (fun s d fld-> Field.getInfoLengthR           s d fld        |> Wrap.fromAsyncResultStr)\n        let getInfoDecimalR        = FieldN  (fun s d fld-> Field.getInfoDecimalR          s d fld        |> Wrap.fromAsyncResultStr)\n        let putValueR       v elem = FieldN  (fun s d fld-> Field.putValueR                s d fld v elem |> Wrap.fromAsyncResultStr)\n\n        let rtn  a                                         = FieldN(fun _ _ _ ->              Wrap.Return a)\n        let rtnR a                                         = FieldN(fun _ _ _ ->                          a)\n        let getResult                           (FieldN a) = FieldN(fun s d fl -> a s d fl |> Wrap.getResultW )\n        let bind          (f: 'a -> FieldN<'b>) (FieldN a) = FieldN(fun s d fl -> a s d fl |> Wrap.bind (f >> function FieldN b -> b s d fl) )\n        let map f m                                        = bind (f >> rtn) m\n        let bindR  f                            (FieldN a) = FieldN(fun s d fl -> a s d fl |> Wrap.bind f)\n        let combine a b                                    = a |> bind b\n        let inline delayRun f                              = FieldN(fun s d fl -> match f() with FieldN g -> g s d fl)\n        let tryWith    hndl fm = match fm() with FieldN a -> FieldN(fun s d fl -> (fun () -> a s d fl) |> Wrap.tryWith    (hndl >> function FieldN h -> h s d fl) )\n        let tryFinally comp fm = match fm() with FieldN a -> FieldN(fun s d fl -> (fun () -> a s d fl) |> Wrap.tryFinally  comp )\n        let run server dim fld                  (FieldN m) = m server dim fld\n        let runD fld m                                     = DimensionN (fun s dim -> run s dim fld m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = delayRun f\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.Using(disposable:#System.IDisposable, body) = let dispose () = if disposable :> obj <> null then disposable.Dispose()\n                                                                      tryFinally dispose      (fun ()-> body disposable)\n            member this.TryFinally(body, compensation)              = tryFinally compensation           body\n            member this.TryWith   (body, handler     )              = tryWith    handler                body\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   CubeN<'T>                 = CubeN of (Server -> Cube -> Wrap<'T>)\n    module CubeN                     = \n        let name                     = CubeN(fun s c -> Cube.name               c         |> Wrap.Return )  \n        let exists                   = CubeN(fun s c -> Cube.exists           s c         |> Wrap.Return )  \n        let create           ds      = CubeN(fun s c -> Cube.create           s c ds      |> Wrap.fromAsyncResultStr)  \n        let delete                   = CubeN(fun s c -> Cube.delete           s c         |> Wrap.fromAsyncResultStr)  \n        let putRulesForcedR  xml     = CubeN(fun s c -> Cube.putRulesForcedR  s c xml     |> Wrap.fromAsyncResultStr)  \n        let setMeasure       dim     = CubeN(fun s c -> Cube.setMeasure       s c dim     |> Wrap.fromAsyncResultStr)  \n        let dimensionsCountR         = CubeN(fun s c -> Cube.dimensionsCountR s c         |> Wrap.fromAsyncResultStr)  \n        let dimensionsNameR  i       = CubeN(fun s c -> Cube.dimensionsNameR  s c i       |> Wrap.fromAsyncResultStr)  \n        let putValueExR      v elems = CubeN(fun s c -> Cube.putValueExR      s c v elems |> Wrap.fromAsyncResultStr)  \n        let dimensionsR              = CubeN(fun s c -> Cube.dimensionsR      s c         |> Wrap.fromAsyncResultStr)  \n\n        let inline rtn  a                                 = CubeN(fun _ _ ->          Wrap.Return a)\n        let inline rtnR a                                 = CubeN(fun _ _ ->                      a)\n        let inline getResult                    (CubeN a) = CubeN(fun s d -> a s d |> Wrap.getResultW )\n        let inline bind    (f: 'a -> CubeN<'b>) (CubeN a) = CubeN(fun s d -> a s d |> Wrap.bind (f >> function CubeN b -> b s d) )\n        let inline map f m                                = bind (f >> rtn) m\n        let inline bindR  f                     (CubeN a) = CubeN(fun s d -> a s d |> Wrap.bind  f)\n        let inline combine a b                            = a |> bind b\n        let inline delayRun f                             = CubeN(fun s d -> match f() with CubeN g -> g s d)\n        let tryWith    hndl fm = match fm() with CubeN a -> CubeN(fun s d -> (fun () -> a s d) |> Wrap.tryWith    (hndl >> function CubeN h -> h s d) )\n        let tryFinally comp fm = match fm() with CubeN a -> CubeN(fun s d -> (fun () -> a s d) |> Wrap.tryFinally  comp )\n        let inline run server cube              (CubeN m) = m server cube\n        let inline runS cube m                            = ServerN (fun s -> run s cube m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = delayRun f\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.Using(disposable:#System.IDisposable, body) = let dispose () = if disposable :> obj <> null then disposable.Dispose()\n                                                                      tryFinally dispose      (fun ()-> body disposable)\n            member this.TryFinally(body, compensation)              = tryFinally compensation           body\n            member this.TryWith   (body, handler     )              = tryWith    handler                body\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n\n    let dimensionN = DimensionN.Builder()\n    let cubeN      = CubeN     .Builder()\n    let serverN    = ServerN   .Builder()\n    let fieldN     = FieldN    .Builder()\n    let handleN    = HandleN   .Builder()\n\n", "snpParentIdO": {"SnippetId" :"8d568171-bb31-4bee-a9a6-46514fe8f64e"}, "snpPredIds": [{"SnippetId" :"916982d0-1d30-4cc7-8794-0f8a3b3e9a5d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpName": "CalculationModel", "snpContent": "module CalculationModel =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, "snpName": "CalculationModel", "snpContent": "open System\nopen Useful\n\n[< JavaScript >]\nmodule CalculationModel =\n    open Useful\n    \n    type DimType =\n        | DtDataType\n        | DtTime\n        | DtVersion\n        | DtTCalc\n        | DtCalc\n        | DtMeasure\n        | DtOther\n    \n    type CubeType =\n        | CtOther\n        | CtCalc\n        | CtFreeze\n    \n    type AttType =\n        | AtString\n        | AtNumber\n    \n    type ElmType =\n        | EtString\n        | EtNumber\n    \n    type ModId = ModId of Guid with member x.Id = match x with ModId id -> id\n    type AttId = AttId of Guid with member x.Id = match x with AttId id -> id\n    type ElmId = ElmId of Guid with member x.Id = match x with ElmId id -> id\n    type CubId = CubId of Guid with member x.Id = match x with CubId id -> id\n    type DimId = DimId of Guid with member x.Id = match x with DimId id -> id\n    type CalId = CalId of Guid with member x.Id = match x with CalId id -> id\n    type TotId = TotId of Guid with member x.Id = match x with TotId id -> id\n    type ForId = ForId of Guid with member x.Id = match x with ForId id -> id\n    type RulId = RulId of Guid with member x.Id = match x with RulId id -> id\n    \n    type Attribute = {\n        attId          : AttId\n        attName        : string\n        attType        : AttType\n        attTableNum    : int\n    }\n    \n    type Element = {\n        elmId          : ElmId\n        elmDim         : DimId\n        elmType        : ElmType\n        elmName        : string\n        elmDescription : string\n        elmAttributes  : Map<AttId, string> \n        elmParents     : ElmId     []\n    } \n    \n    type Dimension = {\n        dimId               : DimId\n        dimName             : string\n        dimPrefix           : string\n        dimOrder            : string\n        dimExclude          : bool\n        dimFreeze           : bool\n        dimType             : DimType\n        defaultElm          : ElmId     option\n        mutable dimElements : Element   []\n        dimAttributes       : Attribute []\n        isCalcDim           : bool\n    }\n    \n    type UnaryOp = \n        | UoMinus\n        | UoPlus\n        \n    type Operator = \n        | OpAdd      \n        | OpSubtract \n        | OpMultiply \n        | OpDivide   \n        | OpEQ    \n        | OpNE\n        | OpGT       \n        | OpGE       \n        | OpLT       \n        | OpLE       \n        | OpAnd      \n        | OpOr           \n    \n    type Function = Function of string\n    \n    type ElmReference =\n        | ElemFixed   of DimId * ElmId\n        | ElemDynamic of DimId * ExpressionText\n            \n    and  ExpressionText =\n        | ExtNA\n        | ExtStet\n        | ExtSlice      of Slice\n        | ExtString     of string\n        | ExtDimElement of DimId\n        | ExtDimName    of DimId\n        | ExtFunction   of Function         * ExpressionAny []\n        | ExtIf         of ExpressionNumber * ExpressionText   * ExpressionText\n    \n    and  ExpressionNumber =\n        | ExnNA\n        | ExnStet\n        | ExnSlice      of Slice\n        | ExnNumber     of float\n        | ExnOperationN of Operator         * ExpressionNumber * ExpressionNumber\n        | ExnUnaryN     of UnaryOp          * ExpressionNumber\n        | ExnOperationT of Operator         * ExpressionText   * ExpressionText\n        | ExnOperationI of Operator         * ExpressionAny    * ExpressionAny\n        | ExnFunction   of Function         * ExpressionAny []\n        | ExnIf         of ExpressionNumber * ExpressionNumber * ExpressionNumber\n        | ExnIsNA       of ExpressionNumber\n        | ExnIsNAt      of ExpressionText\n        | ExnIsNAa      of ExpressionAny\n        \n    and ExpressionAny =    \n        | ExiNA\n        | ExiStet\n        | ExiSlice      of Slice\n        | ExNumeric     of ExpressionNumber\n        | ExText        of ExpressionText\n        | ExiIf         of ExpressionNumber * ExpressionAny * ExpressionAny\n        \n    and  Slice = {\n        sliDims     : Map<DimId, ElmReference>   \n        calculation : CalId option\n        cube        : CubId option\n    } \n    \n    type ForType = \n        | ForBase\n        | ForConsolidated\n        | ForAll\n    \n    type Formula = {\n        forId          : ForId\n        forDestDecl    : Map<DimId, string>\n        forDestination : ElmReference list\n        forDescription : string\n        forText        : string\n        forExpression  : ExpressionAny\n        forType        : ForType\n        forOrder       : string\n    }\n    \n    type Calculation = {\n        calId          : CalId\n        calName        : string\n        calDescription : string\n        calOrder       : string\n        format         : string\n        isText         : bool\n        isInput        : bool\n        isBalance      : bool\n        calDims        : Set<DimId>\n        calFormulas    : Formula []\n        cubIdO         : CubId   option\n        properties     : Map<string, string>\n    }\n    \n    type NodeId =\n        | Calc of CalId\n        | Tot  of TotId\n    \n    type Total = {\n        totId          : TotId\n        totName        : string\n        totOrder       : string\n        totFormat      : string\n        children       : (float * NodeId) []\n    }\n    \n    type RuleKey = \n        | RuleKey     of RulId\n        | CalcRuleKey of CalId\n        | FormulaKey  of ForId\n        | ForTextKey  of ForId\n        | ActualRuleKey \n        | InputRuleKey\n        | ConsolidatedRuleKey\n    \n    type Cube = {\n        cubId          : CubId\n        cubName        : string\n        cubRules       : Map<RuleKey, Rule option>\n        cubRuleXmls    : Map<RuleKey, string>\n        cubDims        : DimId []\n        measureDim     : DimId option\n        cubType        : CubeType\n    }\n    \n    and  Rule = {\n        rulId          : RulId\n        rulSourceId    : IComparable\n        rulDescription : string\n        rulDestination : ElmReference list\n        rulExpression  : ExpressionAny\n        rulType        : ForType\n        rulOrder       : string\n        rulXml         : string\n    }\n    \n    type RuleMsg =\n    | GetInitModelStats\n    | GetRulesForCube of CubId\n    \n    type ReplyMsg =\n    | ReplyInformation of string\n    | ReplyRules       of (RuleKey * string) []\n    \n    [<NoComparison ; NoEquality>]\n    type Model = {\n        modId           : ModId\n        server          : string\n        actualElem      : string\n        modDims         : Dimension   []\n        modCubes        : Cube        []\n        modCalculations : Calculation []\n    } \n    \n    let Xmodel = \n      {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"local\\Budget\"\n        actualElem      = \"Actual\"\n        modDims         = [||]\n        modCubes        = [||]\n        modCalculations = [||]\n      }\n        \n    let Map_adds kvs map = Seq.append (map |> Map.toSeq) kvs |> Map\n    let calcSlice calc : Slice = \n             {\n                 sliDims       = Map.empty\n                 calculation   = Some calc.calId\n                 cube          = None\n             }\n        \n    type HelperTypeN = HelperTypeN with\n        static member (&%>)  (HelperTypeN, a :     bool             ) : ExpressionNumber = ExnNumber <| if    a then 1.0 else 0.0\n        static member (&%>)  (HelperTypeN, a :     int              ) : ExpressionNumber = ExnNumber <| float a\n        static member (&%>)  (HelperTypeN, a :     float            ) : ExpressionNumber = ExnNumber          a\n        static member (&%>)  (HelperTypeN, a :     Slice            ) : ExpressionNumber = ExnSlice           a\n        static member (&%>)  (HelperTypeN, a :     Calculation      ) : ExpressionNumber = ExnSlice  <| calcSlice a\n        static member (&%>)  (HelperTypeN, a :     ExpressionNumber ) : ExpressionNumber =                    a\n        \n    let [< Inline >] inline toExpN v : ExpressionNumber = HelperTypeN &%>  v\n    \n    type HelperTypeT = HelperTypeT with\n        static member (&&>)  (HelperTypeT, a :     string           ) : ExpressionText   = ExtString          a \n        static member (&&>)  (HelperTypeT, a :     Dimension        ) : ExpressionText   = ExtDimName         a.dimId \n        static member (&&>)  (HelperTypeT, a :     Slice            ) : ExpressionText   = ExtSlice           a\n        static member (&&>)  (HelperTypeT, a :     Calculation      ) : ExpressionText   = ExtSlice  <| calcSlice a\n        static member (&&>)  (HelperTypeT, a :     ExpressionText   ) : ExpressionText   =                    a\n    \n    let [< Inline >] inline toExpT  v : ExpressionText = HelperTypeT &&>  v\n    \n    type HelperTypeA = HelperTypeA with\n        [< Inline >]\n        static member (&>>)  (HelperTypeA, a :     ExpressionNumber) : ExpressionAny = ExNumeric          a \n        [< Inline >]\n        static member (&>>)  (HelperTypeA, a :     ExpressionText  ) : ExpressionAny = ExText             a\n        [< Inline >]\n        static member (&>>)  (HelperTypeA, a :     Slice           ) : ExpressionAny = ExiSlice           a\n        [< Inline >]\n        static member (&>>)  (HelperTypeA, a :     Calculation     ) : ExpressionAny = ExiSlice <| calcSlice a\n        [< Inline >] \n        static member (&>>)  (HelperTypeA, a :     bool            ) : ExpressionAny = toExpN             a |> ExNumeric\n        [< Inline >] \n        static member (&>>)  (HelperTypeA, a :     int             ) : ExpressionAny = toExpN             a |> ExNumeric\n        [< Inline >] \n        static member (&>>)  (HelperTypeA, a :     float           ) : ExpressionAny = toExpN             a |> ExNumeric\n        [< Inline >] \n        static member (&>>)  (HelperTypeA, a :     string          ) : ExpressionAny = toExpT             a |> ExText\n        [< Inline >]\n        static member (&>>)  (HelperTypeA, a :     ExpressionAny   ) : ExpressionAny =                    a\n    \n    let [< Inline >] inline toExpA  v : ExpressionAny = HelperTypeA &>>  v\n\n    type Message =\n        | DimensionNotFound      of DimId\n        | DimensionHasNoElements of string\n        | ElementNotFound        of string * ElmId\n        | CubeNotFound           of CubId\n        | CubeHasNoMeasureDim    of string\n        | CalculationNotFound    of CalId\n        | CalculationHasNoCube   of string\n        interface ErrMsg with\n            member this.ErrMsg   : string = sprintf \"%A\" this\n            member this.IsWarning: bool   = false\n        override this.ToString() = (this :> ErrMsg).ErrMsg\n\n    let fromOptF f = Result.fromOptionW (fun () -> errSimple <| f())\n    let fromOptS s = Result.fromOption  (          errSimple <| s  )\n\n    module internal Model0 =\n        let getCubeO    cubId mdl = mdl.modCubes        |> Seq.tryFind (fun cub -> cub.cubId   =  cubId)\n        let getDimO       dId mdl = mdl.modDims         |> Seq.tryFind (fun d   ->   d.dimId   =    dId)\n        let getDimR       dId mdl = getDimO  dId mdl |> Result.fromOption (DimensionNotFound   dId)\n\n    module Element  =\n        let newElement name = \n          {\n            elmId          = ElmId <| Guid.NewGuid()\n            elmDim         = DimId <| Guid.NewGuid()\n            elmType        = EtString\n            elmName        = name\n            elmDescription = name\n            elmAttributes  = Map.empty\n            elmParents     = [||]\n          }\n\n    module ElmReference =\n        let dimId elr =\n            match elr with\n            | ElemFixed  (id, _)\n            | ElemDynamic(id, _) -> id\n\n    module Slice =\n        let newSlice ds = {\n                 sliDims       = ds |> Seq.map (fun dr -> ElmReference.dimId dr, dr) |> Map \n                 calculation   = None\n                 cube          = None\n        }\n        let forAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = None\n        }\n        let addRef      elr slc = { slc with sliDims = slc.sliDims |> Map.add (ElmReference.dimId elr) elr }\n        let containsDim did slc = slc.sliDims |> Map.containsKey did\n   \n    module Dimension =\n        let getElementO      eId dim = dim.dimElements |> Seq.tryFind (fun e -> e.elmId = eId)    \n        let getElementR      eId dim = getElementO eId dim |> Result.fromOption (ElementNotFound(dim.dimName, eId))\n        let newDimension id name isCalcDim =\n              {\n                dimId          = id \n                dimName        = name\n                dimPrefix      = \"\"\n                dimOrder       = \"\"\n                dimExclude     = false\n                dimFreeze      = false\n                dimType        = DtOther\n                defaultElm     = None\n                dimElements    = [|  |]\n                dimAttributes  = [|  |]      \n                isCalcDim      = isCalcDim\n              }\n        let newDimensionNonCalc id name  = newDimension id name false\n        let newDimensionCalc    id name  = newDimension id name true \n        let New                    name  = newDimension (DimId <| Guid.NewGuid()) name false\n        let [< Inline >] inline getElmReference it dim =\n            match toExpT it with \n            | ExtString s1 -> let s2 = s1.Replace(\"_\", \" \")\n                              let elm =\n                                 dim.dimElements                                 \n                                 |> Seq.tryFind (fun e -> e.elmName = s2)\n                                 |> Option.defaultWith (fun () -> \n                                     let newE = Element.newElement s2\n                                     dim.dimElements <- Array.append dim.dimElements [| newE |]\n                                     newE\n                                 )\n                              ElemFixed  (dim.dimId, elm.elmId) \n            | exp          -> ElemDynamic(dim.dimId, exp      )  \n//        member inline this.Item (it) = getElmReference it this\n        //member inline this.__     it     = this.Item it\n        //member inline this.M      it     = this.Item it\n        //member inline this.E      it     = this.Item it\n        //member inline this.I      it     = this.Item it\n        let prefix  pr   dim  = { dim with dimPrefix = pr   }\n        let dType   dt   dim  = { dim with dimType   = dt   }\n        let setName name dim  = { dim with dimName   = name }\n        let filter     dtypes : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\n        let sort             (ds:Dimension seq)                  = ds |> Seq.sortBy (fun d -> d.dimOrder)\n        let filterSort dtypes : (Dimension seq -> Dimension seq) = filter dtypes >> sort\n\n    type Dimension with\n        [< Inline >] \n        member inline this.Item (it) = Dimension.getElmReference it this\n\n\n    module Cube =\n        let slice cub : Slice  = \n             {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = Some cub.cubId\n             }\n        let containsDim dimId         cub = cub.cubDims |> Seq.contains dimId\n        let isCalcCube                cub = cub.cubType = CtCalc    \n        let newCubeId id name dims mDimO cType = \n                {\n                  cubId       = id\n                  cubName     = name\n                  cubDims     = dims\n                  cubRules    = Map.empty\n                  cubRuleXmls = Map.empty\n                  measureDim  = mDimO\n                  cubType     = cType\n                }\n        let newCube     name            = newCubeId <| CubId (Guid.NewGuid()) <| name\n        let newCubeCalc name dims mDimO = newCube name  dims mDimO CtCalc \n        let newCubeDims name dims mDimO = newCube name (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray) mDimO CtOther\n        let New()                       = newCube \"\" [||] None CtOther\n        let addRule     key rule  cub   = { cub with cubRules =                                              Map.add key rule         cub.cubRules }\n        let addRules        rules cub   = { cub with cubRules = rules |> Seq.fold (fun rulesN (key, rule) -> Map.add key rule rulesN) cub.cubRules }\n        //member inline this.Calc ()    = { this with cubType = CtCalc } \n        let forElr (es: ElmReference list) cub = { slice cub with sliDims = Map_adds (List.map (fun (e:ElmReference) -> ElmReference.dimId e, e) es) (slice cub).sliDims } \n        let dims            model cub   = model.modDims |> Array.filter(fun d -> cub.cubDims |> Array.exists ((=) d.dimId) )\n        let measureDimO     model cub   = cub.measureDim    |> Option.bind (swap Model0.getDimO model)\n        let measureDimR     model cub   = cub.measureDim         |> Result.fromOption (CubeHasNoMeasureDim cub.cubName) |> Result.bind (swap Model0.getDimR model)\n        let measureDimNameR model cub   = measureDimR model cub  |> Result.map (fun dim -> dim.dimName)\n        \n    module Calculation =\n        let slice calc = calcSlice calc\n        let calcType calc = if calc.isInput then \"INPUT\" else \"CALC\"    \n        let newInput id (name: string) dims  =\n             {\n                calId          = id\n                calName        = name.Replace(\"_\", \" \").Trim()\n                calDescription = \"\"\n                calOrder       = \"\"\n                format         = \"#,##0.00\"\n                isText         = false\n                isInput        = true\n                isBalance      = false\n                calDims        = dims |> Set \n                calFormulas    = [||]\n                cubIdO         = None\n                properties     = Map.empty\n             }\n        let newCalc id name dims      = { newInput id name dims     with isInput     = false  }\n        let New        ()             =   newInput (CalId <| Guid.NewGuid()) \"\"   []\n        let setName    name      calc = { calc                   with calName     = name   }\n        let setIsText  istext    calc = { calc                   with isText      = istext }\n        let setOrder   order     calc = { calc                   with calOrder    = order  }\n        let addFormula frml      calc = { calc                   with calFormulas = Array.append calc.calFormulas [| frml |] }\n        let forSlice (es: ElmReference list) calc = { slice calc with sliDims = Map_adds (List.map (fun e -> ElmReference.dimId e, e) es) (slice calc).sliDims } \n        let addFormulas fs calc = if Seq.isEmpty fs then calc else { calc with calFormulas = fs |> Seq.toArray |> Array.append calc.calFormulas } \n        let withCube (model: Model) calc f = calc.cube |> Option.bind (swap Model0.getCubeO model) |> Option.bind f\n        let [< Inline >] getElemRefO(model: Model) calc =\n            calc.cubIdO \n            |> Option.bind (swap Model0.getCubeO model)\n            |> Option.bind (fun cub ->  cub.measureDim) \n            |> Option.bind (swap Model0.getDimO  model)\n            |> Option.map  (Dimension.getElmReference calc.calName)\n        let cubeR           c = c.cubIdO        |> fromOptF (fun () -> sprintf \"Calculation '%s' has no cube\" c.calName)\n        let [< Inline >] getElemRefR   m c = getElemRefO m c |> fromOptF (fun () -> sprintf \"Calcuation '%s' has no ElemRef\" c.calName) \n        let sort             (cs:Calculation seq)                  = cs |> Seq.sortBy (fun c -> c.calOrder)\n\n    module Total =\n        let newTotal name  = {\n            totId          = TotId  <| System.Guid.NewGuid()\n            totName        = name\n            totOrder       = \"\"\n            totFormat      = \"\"\n            children       = [||]\n        }\n        let New() = newTotal \"\"\n        \n    module Model =\n        let mergeBy f a b = Array.append (Seq.toArray a) (Array.filter (fun e -> a |> Seq.map f |> Seq.contains (f e) |> not ) b)\n        let addCalcs     cs   mdl = { mdl with modCalculations = mergeBy (fun c -> c.calId) cs mdl.modCalculations }\n        let addDims      ds   mdl = { mdl with modDims         = mergeBy (fun c -> c.dimId) ds mdl.modDims         }\n        let addCubes     cs   mdl = { mdl with modCubes        = mergeBy (fun c -> c.cubId) cs mdl.modCubes        }\n        let addForms     fs   mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> fs |> Seq.filter (fst >> (=) cal.calId) |> Seq.map snd |> Calculation.addFormulas <| cal) }\n        let addCalc      calc mdl = { mdl with modCalculations = Array.append mdl.modCalculations [| calc |] }\n        let addDim       dim  mdl = { mdl with modDims         = Array.append mdl.modDims         [| dim  |] }\n        let addCube      cube mdl = { mdl with modCubes        = Array.append mdl.modCubes        [| cube |] }\n        let addForm  cid frm  mdl = { mdl with modCalculations = mdl.modCalculations |> Array.map (fun cal -> if cal.calId = cid then Calculation.addFormula frm cal else cal) }\n        let getDimO               = Model0.getDimO\n        let getDimR               = Model0.getDimR\n        let getCalcO      cId mdl = mdl.modCalculations |> Seq.tryFind (fun c   ->   c.calId   =    cId)\n        let getCubeO              = Model0.getCubeO\n        let getCalcR      cId mdl = getCalcO cId mdl |> Result.fromOption (CalculationNotFound cId)\n        let getCubeR      cId mdl = getCubeO cId mdl |> Result.fromOption (CubeNotFound        cId)\n        let pickCubeO      ct mdl = mdl.modCubes        |> Seq.tryPick (fun c   ->   if c.cubType = ct then Some c else None)\n        let pickDimO       dt mdl = mdl.modDims         |> Seq.tryPick (fun d   ->   if d.dimType = dt then Some d else None)\n        let pickCalcO      cn mdl = mdl.modCalculations |> Seq.tryPick (fun c   ->   if c.calName = cn then Some c else None)\n        let freezeCubeO       mdl = pickCubeO CtFreeze   mdl\n        let tCalcDimO         mdl = pickDimO  DtTCalc    mdl \n        let dataTypeDimO      mdl = pickDimO  DtDataType mdl\n        let timeDimO          mdl = pickDimO  DtTime     mdl\n        let versionDimO       mdl = pickDimO  DtVersion  mdl\n        let isActualCalcO     mdl = pickCalcO \"IsActual\" mdl \n        let getCalcCube dims  mdl = \n            mdl.modCubes \n            |> Seq.filter  Cube.isCalcCube\n            |> Seq.tryFind (fun cub -> \n                cub.cubDims \n                |> Seq.filter (fun d -> Some d <> cub.measureDim) \n                |> Set = dims )\n        let setCube cubeN model = { model with modCubes = model.modCubes |> Array.map (fun cub -> if cub.cubId = cubeN.cubId then cubeN else cub ) }\n        let withDimsO mdl cube f =\n            let (<*>)   = Option.apply\n            let dimMeaO = cube.measureDim |> Option.bind (swap getDimO mdl) \n            Some f <*> dimMeaO <*> dataTypeDimO mdl <*> versionDimO mdl <*> timeDimO mdl |> Option.join\n        let withDims mdl cube f = withDimsO mdl cube (fun a b c d -> f a b c d |> Some)\n        let dimCombinations model =\n            model.modCalculations\n            |>  Seq.map (fun c -> c.calDims)\n            |>  Seq.distinct \n        let cubePrefix    = \"Z\"\n        let measurePrefix = \"M\"\n        let orderedDims dimIds model =\n                model.modDims \n                |>  Seq.filter (fun d -> dimIds |> Seq.exists ((=) d.dimId) ) \n        let autoName dimIds model =\n            let nameBase =\n                model\n                |> orderedDims dimIds\n                |> Seq.map (fun d -> d.dimPrefix)\n                |>  String.concat \"\"\n            let similar =\n                model.modCubes\n                |> Seq.choose (fun c -> \n                    match cubePrefix + nameBase with\n                    | n when c.cubName          = n -> Some -1\n                    | n when c.cubName.StartsWith n -> c.cubName.[nameBase.Length + 1..] |> parseInt\n                    | _                             -> None\n                ) \n            nameBase\n          + if similar |> Seq.isEmpty then \"\" else similar |> Seq.max |> ((+) 1) |> sprintf \"%d\"\n    \n        let dimIds           model = model.modDims |> Array.map (fun d -> d.dimId)\n        let fixForDimensions model =\n            //this.modCubes        <- this.modCubes        |>> fun cub -> { cub with cubDims = cub.cubDims |> Array.filter (fun d -> Seq.exists ((=) d) this.DimIds) }\n            let calcs = model.modCalculations |> Array.map (fun cal -> { cal with calDims = cal.calDims |> Set.filter   (fun d -> Seq.exists ((=) d) (dimIds model)) } )\n            { model with modCalculations = calcs }\n        let newCalcCube dimIds model =\n            let name = autoName dimIds model\n            let mDim = Dimension.newDimensionCalc <| DimId (Guid.NewGuid()) <| measurePrefix + name\n            let orderedDimIds = \n                model\n                |> orderedDims dimIds\n                |> Seq.append <| [ mDim ]\n                |> Seq.map (fun d -> d.dimId)\n                |> Seq.toArray\n            let dims  = Array.append model.modDims  [| mDim                                                                 |]\n            let cubes = Array.append model.modCubes [| Cube.newCubeCalc (cubePrefix + name) orderedDimIds (Some mDim.dimId) |]\n            { model with modDims = dims ; modCubes = cubes }\n        let fixCalcsAndCubes model =\n            let calNoCube = model.modCalculations |> Array.filter (fun c -> c.cubIdO |> Option.bind (swap getCubeO model) |> Option.isNone)\n            if Seq.isEmpty calNoCube then model else\n                let modelN =\n                    calNoCube\n                    |> Seq.map      (fun c -> c.calDims)\n                    |> Seq.distinct\n                    |> Seq.filter   ((swap getCalcCube  model) >> Option.isNone)\n                    |> Seq.fold      (swap newCalcCube) model\n                let calcs =\n                    modelN.modCalculations\n                    |> Array.map (fun oldC ->\n                            calNoCube \n                            |> Seq.tryFind (fun newC -> newC.calId = oldC.calId)\n                            |> Option.map  (fun newC -> { newC with Calculation.cubIdO = (getCalcCube newC.calDims modelN) |> Option.map (fun cub -> cub.cubId) } )\n                            |> Option.defaultValue oldC\n                      )\n                { modelN with modCalculations = calcs }\n        let prepareModel model =\n            model\n            |> fixForDimensions \n            |> fixCalcsAndCubes\n        let addRules rules model =\n            rules\n            |> Seq.groupBy (fun (cubId, _, _) -> cubId)\n            |> Seq.fold (fun mdl (cubId, rules) ->\n                getCubeO cubId mdl\n                |> Option.map(fun cube ->\n                    rules \n                    |> Seq.map (fun (_, key, rule) -> key, rule)\n                    |> Cube.addRules <| cube\n                    |> swap setCube mdl\n                )\n                |> Option.defaultValue mdl\n            ) model\n            \n    \n    module Formula =\n        let [< Inline >] inline newFormula id dest exp  typ =\n              {\n                  forId          = id\n                  forDestDecl    = Map.empty\n                  forDestination = dest\n                  forDescription = \"\"\n                  forText        = \"\"\n                  forExpression  = toExpA exp\n                  forType        = typ\n                  forOrder       = \"\"\n              }\n        let [< Inline >] inline newBase    id expr      = newFormula id []   expr ForBase        \n        let [< Inline >] inline newBaseFor id expr dest = newFormula id dest expr ForBase        \n        let [< Inline >] inline newCons    id expr      = newFormula id []   expr ForConsolidated\n        let [< Inline >] inline newConsFor id expr dest = newFormula id dest expr ForConsolidated\n        let [< Inline >] inline newAll     id expr      = newFormula id []   expr ForAll         \n        let [< Inline >] inline newAllFor  id expr dest = newFormula id dest expr ForAll         \n        let [< Inline >] inline New        ()        =\n              {\n                  forId          = ForId <| Guid.NewGuid()\n                  forDestDecl    = Map.empty\n                  forDestination = []\n                  forDescription = \"\"\n                  forText        = \"\"\n                  forExpression  = ExiStet\n                  forType        = ForBase\n                  forOrder       = \"\"\n              }\n        let [< Inline >] inline forId      f         = f.forId\n        let                     conso      frm       = { frm with forType  = ForConsolidated }\n        let                     setText    txt  frm  = { frm with forText  = txt             }\n        let                     setOrder   ord  frm  = { frm with forOrder = ord             }\n        let getDimDest dim frm = \n            frm.forDestination \n            |> swap Seq.tryPick <| fun er -> if ElmReference.dimId er = dim.dimId then Some er else None\n        \n\n    module Rule =\n        let [< Inline >] inline newRule0     dest exp typ order =\n              {\n                  rulId          = RulId <| Guid.NewGuid()\n                  rulDestination = dest\n                  rulDescription = \"\"\n                  rulExpression  = exp\n                  rulType        = typ\n                  rulOrder       = order\n                  rulSourceId    = None\n                  rulXml         = \"\"\n              }\n        let [< Inline >] inline newRule     dest exp typ order = newRule0     dest (toExpA exp) typ order\n        let [< Inline >] inline newRuleDest dest exp typ = newRule (dest.sliDims |> Map.toList |> List.map snd) exp typ\n        let New() = newRule0 [] ExiStet ForBase \"\"\n        let conso rul = { rul with rulType = ForConsolidated }    \n    \n    module Attribute =\n        let New() = \n            {\n                attId            = AttId <| Guid.NewGuid()\n                attName          = \"\"\n                attTableNum      = 1\n                attType          = AtString\n            }\n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"af2b60c6-a99f-433d-b938-f59fefe66c01"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"90cfafb9-9397-4dda-940b-8e33c4412d1c"}, "snpName": "MonadicModel", "snpContent": "\ntype ModelM<'T> = ModelM of (CalculationModel.Model -> Result<'T>)\nmodule ModelM =\n    open CalculationModel\n    let model                     = ModelM Result.succeed\n    let getDimO               dId = ModelM(fun m -> Model.getDimO                 dId m |> fromOptF (fun () -> sprintf \"Dimension %A not found\"    dId) )\n    let getDimR               dId = ModelM(fun m -> Model.getDimR                 dId m ) \n    let getCalcO              cId = ModelM(fun m -> Model.getCalcO                cId m |> fromOptF (fun () -> sprintf \"Calculation %A not found\"  cId) )\n    let getCubeO              cId = ModelM(fun m -> Model.getCubeO                cId m |> fromOptF (fun () -> sprintf \"Cube %A not found\"         cId) )\n    let getCalcR              cId = ModelM(fun m -> Model.getCalcR                cId m ) \n    let getCubeR              cId = ModelM(fun m -> Model.getCubeR                cId m ) \n    let pickCubeO              ct = ModelM(fun m -> Model.pickCubeO                ct m |> fromOptF (fun () -> sprintf \"Cube type %A not found\"      ct ) )\n    let pickDimO               dt = ModelM(fun m -> Model.pickDimO                 dt m |> fromOptF (fun () -> sprintf \"Dimension type %A not found\" dt ) )\n    let pickCalcO              cn = ModelM(fun m -> Model.pickCalcO                cn m |> fromOptF (fun () -> sprintf \"Calculation '%s' not found\"  cn ) )\n    let freezeCubeO               = ModelM(fun m -> Model.freezeCubeO                 m |> fromOptS \"Model has no Freeze cube\"                  )\n    let tCalcDimO                 = ModelM(fun m -> Model.tCalcDimO                   m |> fromOptS \"Model has no TCalc dimension\"              )\n    let dataTypeDimO              = ModelM(fun m -> Model.dataTypeDimO                m |> fromOptS \"Model has no DataType dimension\"           )\n    let timeDimO                  = ModelM(fun m -> Model.timeDimO                    m |> fromOptS \"Model has no time    dimension\"            )\n    let versionDimO               = ModelM(fun m -> Model.versionDimO                 m |> fromOptS \"Model has no version dimension\"            )\n    let isActualCalcO             = ModelM(fun m -> Model.isActualCalcO               m |> fromOptS \"'isActual' calculation not found\"          )\n    let getCalcCube          dims = ModelM(fun m -> Model.getCalcCube            dims m |> Result.succeed)\n    let setCube             cubeN = ModelM(fun m -> Model.setCube               cubeN m |> Result.succeed) \n    let dimCombinations           = ModelM(fun m -> Model.dimCombinations             m |> Result.succeed) \n    let orderedDims        dimIds = ModelM(fun m -> Model.orderedDims          dimIds m |> Result.succeed) \n    let autoName           dimIds = ModelM(fun m -> Model.autoName             dimIds m |> Result.succeed) \n    let dimIds                    = ModelM(fun m -> Model.dimIds                      m |> Result.succeed) \n    let fixForDimensions          = ModelM(fun m -> Model.fixForDimensions            m |> Result.succeed) \n    let newCalcCube        dimIds = ModelM(fun m -> Model.newCalcCube          dimIds m |> Result.succeed) \n    let fixCalcsAndCubes          = ModelM(fun m -> Model.fixCalcsAndCubes            m |> Result.succeed) \n    let prepareModel              = ModelM(fun m -> Model.prepareModel                m |> Result.succeed) \n    let addRules            rules = ModelM(fun m -> Model.addRules              rules m |> Result.succeed) \n    let modId                     = ModelM(fun m -> m.modId                             |> Result.succeed) \n    let server                    = ModelM(fun m -> m.server                            |> Result.succeed) \n    let actualElem                = ModelM(fun m -> m.actualElem                        |> Result.succeed) \n    let modDims                   = ModelM(fun m -> m.modDims                           |> Result.succeed) \n    let modCubes                  = ModelM(fun m -> m.modCubes                          |> Result.succeed) \n    let modCalculations           = ModelM(fun m -> m.modCalculations                   |> Result.succeed) \n\n    let inline rtn  a                                  = ModelM(fun _ -> Result.succeed a)\n    let inline rtnR a                                  = ModelM(fun _ ->                a)\n    let inline getResult                   (ModelM a)  = ModelM(fun m -> a m |> Result.succeed )\n    let inline bind  (f: 'a -> ModelM<'b>) (ModelM a)  = ModelM(fun m -> a m |> Result.bind (f >> function ModelM b -> b m) )\n    let inline bindR (f: 'a -> ModelM<'b>)         a   = ModelM(fun m -> a   |> Result.bind (f >> function ModelM b -> b m) )\n    let inline delayRun f                              = ModelM(fun m ->                    match f() with ModelM b -> b m  )\n    let inline map f m                                 = bind (f >> rtn) m\n    let inline apply fX vX                             = fX |> bind  (swap map  vX)\n    let inline run model                   (ModelM m)  = m model\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn x\n        member inline this.ReturnFrom  x                        = x\n        member        this.Bind       (w , r )                  = bind  r w\n        member        this.Bind       (w , r )                  = bindR r w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = bind b a\n        member inline this.Run         f                        = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\ntype CubeM<'T> = CubeM of (CalculationModel.Model -> CalculationModel.Cube -> Result<'T>)\nmodule CubeM =\n    open CalculationModel\n    let slice                     = CubeM(fun m c -> Cube.slice                       c |> Result.succeed)\n    let containsDim     dimId     = CubeM(fun m c -> Cube.containsDim     dimId       c |> Result.succeed)\n    let isCalcCube                = CubeM(fun m c -> Cube.isCalcCube                  c |> Result.succeed)\n    let addRule         key rule  = CubeM(fun m c -> Cube.addRule         key rule    c |> Result.succeed)\n    let addRules            rules = CubeM(fun m c -> Cube.addRules            rules   c |> Result.succeed)\n    let forElr                 es = CubeM(fun m c -> Cube.forElr                 es   c |> Result.succeed)\n    let dims                      = CubeM(fun m c -> Cube.dims                      m c |> Result.succeed)\n    let measureDimO               = CubeM(fun m c -> Cube.measureDimO               m c |> Result.succeed)\n    let measureDimR               = CubeM(fun m c -> Cube.measureDimR               m c                  )\n    let measureDimNameR           = CubeM(fun m c -> Cube.measureDimNameR           m c                  )\n    let cubId                     = CubeM(fun m c -> c.cubId                            |> Result.succeed)\n    let cubName                   = CubeM(fun m c -> c.cubName                          |> Result.succeed)\n    let cubRules                  = CubeM(fun m c -> c.cubRules                         |> Result.succeed)\n    let cubDims                   = CubeM(fun m c -> c.cubDims                          |> Result.succeed)\n    let measureDim                = CubeM(fun m c -> c.measureDim                       |> fromOptF (fun () -> sprintf \"Cube %s has no measureDim\" c.cubName) )\n    let cubType                   = CubeM(fun m c -> c.cubType                          |> Result.succeed)\n\n    let inline rtn                                a  = CubeM(fun _ _ -> Result.succeed a  )\n    let inline rtnR                               a  = CubeM(fun _ _ ->                a  )\n    let inline rtnM                       (ModelM a) = CubeM(fun m _ ->                a m)\n    let inline getResult                  (CubeM  a) = CubeM(fun m c -> a m c |> Result.succeed)\n    let inline bind  (f: 'a -> CubeM<'b>) (CubeM  a) = CubeM(fun m c -> a m c |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline bindM (f: 'a -> CubeM<'b>) (ModelM a) = CubeM(fun m c -> a m   |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline bindR (f: 'a -> CubeM<'b>)         a  = CubeM(fun m c -> a     |> Result.bind (f >> function CubeM b -> b m c) )\n    let inline delayRun f                            = CubeM(fun m c ->                      match f() with CubeM b -> b m c  )\n    let inline map f m                               = bind (f >> rtn) m\n    let inline run model cube             (CubeM  m) = m model cube\n    let inline runM      cube             (CubeM  m) = ModelM(fun mdl -> m mdl cube)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = bind b a\n        member inline this.Run         f                        = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n        \ntype DimensionM<'T> = DimensionM of (CalculationModel.Model -> CalculationModel.Dimension -> Result<'T>)\nmodule DimensionM =\n    open CalculationModel\n    let        getElementO     eId  = DimensionM(fun m d -> Dimension.getElementO      eId d |> Result.succeed)\n    let        getElementR     eId  = DimensionM(fun m d -> Dimension.getElementR      eId d                  )\n    let inline getElmReference it   = DimensionM(fun m d -> Dimension.getElmReference   it d |> Result.succeed)\n    let        prefix          pr   = DimensionM(fun m d -> Dimension.prefix          pr   d |> Result.succeed)\n    let        dType           dt   = DimensionM(fun m d -> Dimension.dType           dt   d |> Result.succeed)\n    let        setName         name = DimensionM(fun m d -> Dimension.setName         name d |> Result.succeed)\n    let        dimId                = DimensionM(fun m d -> d.dimId                          |> Result.succeed)\n    let        dimName              = DimensionM(fun m d -> d.dimName                        |> Result.succeed)\n    let        dimPrefix            = DimensionM(fun m d -> d.dimPrefix                      |> Result.succeed)\n    let        dimType              = DimensionM(fun m d -> d.dimType                        |> Result.succeed)\n    let        defaultElm           = DimensionM(fun m d -> d.defaultElm                     |> Result.succeed)\n    let        dimElements          = DimensionM(fun m d -> d.dimElements                    |> Result.succeed)\n    let        dimAttributes        = DimensionM(fun m d -> d.dimAttributes                  |> Result.succeed)\n    let        isCalcDim            = DimensionM(fun m d -> d.isCalcDim                      |> Result.succeed)\n\n    let inline rtn  a                                          = DimensionM(fun _ _ -> Result.succeed a)\n    let inline rtnR a                                          = DimensionM(fun _ _ ->                a)\n    let inline getResult                       (DimensionM  a) = DimensionM(fun m c -> a m c |> Result.succeed)\n    let inline bind  (f: 'a -> DimensionM<'b>) (DimensionM  a) = DimensionM(fun m c -> a m c |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline bindM (f: 'a -> DimensionM<'b>) (ModelM      a) = DimensionM(fun m c -> a m   |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline bindR (f: 'a -> DimensionM<'b>)              a  = DimensionM(fun m c -> a     |> Result.bind (f >> function DimensionM b -> b m c) )\n    let inline delayRun f                                      = DimensionM(fun m c ->                      match f() with DimensionM b -> b m c  )\n    let inline map f m                                         = bind (f >> rtn) m\n    let inline run model dim                  (DimensionM  m) = m model dim\n    let inline runM      dim                  (DimensionM  m) = ModelM(fun mdl -> m mdl dim)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = bind b a\n        member inline this.Run         f                        = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member inline this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\ntype CalculationM<'T> = CalculationM of (CalculationModel.Model -> CalculationModel.Calculation -> Result<'T>)\nmodule CalculationM =\n    open CalculationModel\n    let slice             = CalculationM(fun m c -> Calculation.slice            c |> Result.succeed)\n    let calcType          = CalculationM(fun m c -> Calculation.calcType         c |> Result.succeed)\n    let setName    name   = CalculationM(fun m c -> Calculation.setName     name c |> Result.succeed)\n    let setOrder   order  = CalculationM(fun m c -> Calculation.setOrder   order c |> Result.succeed)\n    let addFormula frml   = CalculationM(fun m c -> Calculation.addFormula  frml c |> Result.succeed)\n    let forSlice    es    = CalculationM(fun m c -> Calculation.forSlice      es c |> Result.succeed)\n    let addFormulas fs    = CalculationM(fun m c -> Calculation.addFormulas   fs c |> Result.succeed)\n    let getElemRefR       = CalculationM(fun m c -> Calculation.getElemRefR    m c                  )\n    let calId             = CalculationM(fun m c -> c.calId                        |> Result.succeed)\n    let calName           = CalculationM(fun m c -> c.calName                      |> Result.succeed)\n    let calDescription    = CalculationM(fun m c -> c.calDescription               |> Result.succeed)\n    let calOrder          = CalculationM(fun m c -> c.calOrder                     |> Result.succeed)\n    let format            = CalculationM(fun m c -> c.format                       |> Result.succeed)\n    let isText            = CalculationM(fun m c -> c.isText                       |> Result.succeed)\n    let isInput           = CalculationM(fun m c -> c.isInput                      |> Result.succeed)\n    let isBalance         = CalculationM(fun m c -> c.isBalance                    |> Result.succeed)\n    let calDims           = CalculationM(fun m c -> c.calDims                      |> Result.succeed)\n    let calFormulas       = CalculationM(fun m c -> c.calFormulas                  |> Result.succeed)\n    let cube              = CalculationM(fun m c -> Calculation.cubeR            c                  )\n    let properties        = CalculationM(fun m c -> c.properties                   |> Result.succeed)\n\n    let inline rtn  a                                              = CalculationM(fun _ _ -> Result.succeed a)\n    let inline rtnR a                                              = CalculationM(fun _ _ ->                a)\n    let inline getResult                         (CalculationM  a) = CalculationM(fun m c -> a m c   |> Result.succeed )\n    let inline bind  (f: 'a -> CalculationM<'b>) (CalculationM  a) = CalculationM(fun m c -> a m c   |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindM (f: 'a -> CalculationM<'b>) (ModelM        a) = CalculationM(fun m c -> a m     |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindC (f: 'a -> CalculationM<'b>) (CubeM         a) = CalculationM(fun m c -> Calculation.cubeR c |> Result.bind (swap Model.getCubeR m) |> Result.bind (a m) |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline bindR (f: 'a -> CalculationM<'b>) (a: Result<_>   ) = CalculationM(fun m c -> a       |> Result.bind (f >> function CalculationM b -> b m c) )\n    let inline delayRun f                                          = CalculationM(fun m c ->                        match f() with CalculationM b -> b m c  )\n    let inline map f m                                             = bind (f >> rtn) m\n    let inline run  model calc                   (CalculationM  m) =                   m model calc\n    let inline runM       calc                   (CalculationM  m) = ModelM(fun mdl -> m mdl   calc)\n    let rec traverseM f list =\n        let (>>=) v f = bind f v\n        let retn      = rtn\n        let initState = retn []\n        let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n        List.foldBack folder list initState \n    let inline sequenceM x = traverseM id x\n\n    type Builder() =\n        member inline this.Return      x                        = rtn      x\n        member inline this.ReturnFrom  x                        =          x\n        member        this.Bind       (w , r )                  = bind  r  w\n        member        this.Bind       (w , r )                  = bindC r  w\n        member        this.Bind       (w , r )                  = bindM r  w\n        member        this.Bind       (w , r )                  = bindR r  w\n        member inline this.Zero       ()                        = rtn ()\n        member inline this.Delay       f                        = f\n        member inline this.Combine    (a, b)                    = bind b a\n        member inline this.Run         f                        = delayRun f\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else rtn   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try body()\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try body()\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\nlet calculationM  = CalculationM.Builder()\nlet dimensionM    = DimensionM.Builder()\nlet cubeM         = CubeM.Builder()\nlet modelM        = ModelM.Builder()\n\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"06aa50e4-05e5-4862-a528-57cdef08acfc"}, "snpName": "InitModel", "snpContent": "module InitModel =\n    open CalculationModel\n\n    let mutable initModel =\n      {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"LOCAL\\CipherSpace\"\n        actualElem      = \"Actual\"\n        modCubes        = [| |]\n        modDims         = [| |]\n        modCalculations = [| |]\n      }\n      \n    let mutable dims         = []\n    let mutable calcs        = []\n    let mutable forms        = []\n    let mutable cubes        = []\n    let mutable rules        = []\n\n    let setInitModel model   = initModel <- model\n                               dims      <- []\n                               calcs     <- []\n                               forms     <- []\n                               cubes     <- []\n                               rules     <- []\n    let addDim  dim          = dims      <-  dim              :: dims\n                               dim\n    let addCalc calc         = calcs     <-  calc             :: calcs\n                               calc\n    let addFrm  calc frm     = forms     <- (calc.calId, frm) :: forms\n    let addCube cube         = cubes     <-  cube             :: cubes\n                               cube\n    let addRule rule         = rules     <-  rule             :: rules\n    let getDimId d = d.dimId\n\n    let newDim  id name typ pre             = Dimension.newDimensionNonCalc id name |> Dimension.dType typ |> Dimension.prefix pre             |> addDim\n    let newCube id name typ dims mdim       = Cube.newCubeId id name (dims |> Seq.map getDimId |> Seq.toArray) (mdim |> Option.map getDimId) typ |> addCube\n    let newCalc id typ name ord istext cube = \n        { typ id name cube.cubDims with \n                                     calOrder  = ord\n                                     cubIdO    = Some cube.cubId\n                                     isText    = istext             } |> addCalc\n    let inline newForm id c t dest ord txt exp = Formula.newFormula id dest exp t |> Formula.setText txt |> Formula.setOrder ord               |> addFrm c\n    let inline newRule cube dest exp typ order =  (cube, Rule.newRule dest exp typ order) |> addRule\n\n    let addDims ()           = initModel |> Model.addDims  (List.rev dims ) |> setInitModel\n    let addCalcs()           = initModel |> Model.addCalcs (List.rev calcs) |> setInitModel\n    let addFrms ()           = initModel |> Model.addForms (List.rev forms) |> setInitModel\n    let addCubes()           = initModel |> Model.addCubes (List.rev cubes) |> setInitModel\n    let addRules()           = initModel |> Model.addRules (List.rev rules  |> List.map (fun (cube, rule) -> cube.cubId, RuleKey rule.rulId, Some rule)) |> setInitModel\n\n\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}, "snpName": "CalculationSyntax", "snpContent": "#nowarn \"86\"\nmodule CalculationSyntax = \n    open CalculationModel\n\n    //let And = (&&)\n\n    let inline ( +   ) x y = ExnOperationN (OpAdd     , toExpN    x      , toExpN    y)\n    let inline ( -   ) x y = ExnOperationN (OpSubtract, toExpN    x      , toExpN    y)\n    let inline ( *   ) x y = ExnOperationN (OpMultiply, toExpN    x      , toExpN    y)\n    let inline ( /   ) x y = ExnOperationN (OpDivide  , toExpN    x      , toExpN    y)\n    let inline ( =   ) x y = ExnOperationN (OpEQ      , toExpN    x      , toExpN    y)\n    let inline ( <>  ) x y = ExnOperationN (OpNE      , toExpN    x      , toExpN    y)\n    let inline ( >   ) x y = ExnOperationN (OpGT      , toExpN    x      , toExpN    y)\n    let inline ( >=  ) x y = ExnOperationN (OpGE      , toExpN    x      , toExpN    y)\n    let inline ( <   ) x y = ExnOperationN (OpLT      , toExpN    x      , toExpN    y)\n    let inline ( <=  ) x y = ExnOperationN (OpLE      , toExpN    x      , toExpN    y)\n    let inline ( &&  ) x y = ExnOperationN (OpAnd     , toExpN    x      , toExpN    y)\n    let inline ( ||  ) x y = ExnOperationN (OpOr      , toExpN    x      , toExpN    y)\n\n    let inline ( ~-  ) x   = ExnUnaryN     (UoMinus   , toExpN    x                   )\n    let inline ( ~+  ) x   = ExnUnaryN     (UoPlus    , toExpN    x                   )\n\n    let inline ( &=  ) x y = ExnOperationT (OpEQ      , toExpT    x      , toExpT    y)\n    let inline ( &<> ) x y = ExnOperationT (OpNE      , toExpT    x      , toExpT    y)\n     \n    let inline ( ?   ) (d:Dimension) e = d |> Dimension.getElmReference ( toExpT e )\n    let inline ( !   ) (d:Dimension)   = ExtDimElement d.dimId\n    \n    \n    let inline IF          (cond, thenR , elseR) = ExnIf       (toExpN cond, toExpN thenR , toExpN elseR)\n    \n    let inline IFt  (cond, thenR, elseR) = ExtIf   (toExpN cond, toExpT thenR, toExpT elseR)\n    let inline IFa  (cond, thenR, elseR) = ExiIf   (toExpN cond, toExpA thenR, toExpA elseR)\n\n\n    let inline toExpTA v = toExpT v |> toExpA\n    let inline toExpNA v = toExpN v |> toExpA\n    let exnFunc n ps = ExnFunction (Function n, ps |> Seq.toArray)\n    let extFunc n ps = ExtFunction (Function n, ps |> Seq.toArray)\n    \n    module DE =\n        let inline INDEX     (dim, elem                ) = exnFunc \"DE.INDEX\"      [ toExpTA dim; toExpTA elem                                 ]\n        let inline PARENTNAME(dim, elem  , nParent     ) = extFunc \"DE.PARENTNAME\" [ toExpTA dim; toExpTA elem  ; toExpNA nParent              ]\n        let inline ISCHILD   (dim, parent, child       ) = exnFunc \"DE.ISCHILD\"    [ toExpTA dim; toExpTA parent; toExpTA child                ]\n    let     inline SUBST     (txt, from  , len         ) = extFunc \"SUBST\"         [ toExpTA txt; toExpNA from  ; toExpNA len                  ]\n    let     inline INSRT     (t1 , t2    , p           ) = extFunc \"INSRT\"         [ toExpTA t1 ; toExpTA t2    ; toExpNA p                    ]\n    let     inline STR       (n  , len   , dec         ) = extFunc \"STR\"           [ toExpNA n  ; toExpNA len   ; toExpNA dec                  ]\n    let     inline GETATTR   (dim, elem  , nTable , fld) = extFunc \"GETATTR\"       [ toExpTA dim; toExpTA elem  ; toExpNA nTable ; toExpTA fld ]\n    let     inline NUMBR     (txt                      ) = exnFunc \"NUMBR\"         [ toExpTA txt                                               ]\n    let     inline MAX       (v1  , v2                 ) = exnFunc \"MAX\"           [ toExpNA v1 ; toExpNA v2                                   ]\n    let     inline MIN       (v1  , v2                 ) = exnFunc \"MIN\"           [ toExpNA v1 ; toExpNA v2                                   ]\n    let     inline INT       (v1                       ) = exnFunc \"INT\"           [ toExpNA v1                                                ]\n    let     inline MOD       (v1  , v2                 ) = exnFunc \"MOD\"           [ toExpNA v1 ; toExpNA v2                                   ]\n\n    let forAll = {\n                 sliDims       = Map.empty\n                 calculation   = None\n                 cube          = None\n    }\n    \n    //let inline toForm0 e = Formula.newFormula [] (toExpA e) ForBase\n    //let inline addFormula  (c:Calculation) f dest forT = c.Add({ f with forDestination = dest ; forType = forT })\n    //let inline addFormulaE (c:Calculation) e           = addFormula c (toForm0 e)\n    //let inline toRule0 e = Rule.New([], toExpA e, ForBase)\n    //let inline addRule     (c:Cube       ) r dest rulT = c.AddRule (RuleKey r.rulId) (Some { r with rulDestination = dest ; rulType = rulT })\n    //let inline addRuleE    (c:Cube       ) e           = addRule c (toRule0 e)\n    //\n   //\n    let Calc  = Calculation.newCalc\n    let Input = Calculation.newInput\n    let NA    = ExnNA\n    let inline ISNA  v = toExpN v |> ExnIsNA\n    let inline ISNAt v = toExpT v |> ExnIsNAt\n    let inline ISNAa v = toExpA v |> ExnIsNAa\n    let STET  = ExnStet\n    let STETt = ExtStet\n    \n    type Calculation with\n        member calc.For ls = Calculation.forSlice ls calc\n    type Cube with\n        member cube.For ls = Cube.forElr ls cube\n        ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"06aa50e4-05e5-4862-a528-57cdef08acfc"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3425a36b-08fa-4a1e-8284-3785e56f8b06"}, "snpName": "Formula & Calculation Rules", "snpContent": "//open Useful\n\nmodule CalcRules =\n    let (!=)  = (<>)\n    let (==)  = (=)\n    let (&&=) = (&&)\n    let (&)   = (+)\n    open CalculationModel\n    open CalculationSyntax\n    open Useful\n    \n    let noneToFalseC              = CubeM .getResult    >> CubeM .map  (Result.ifError      false                              )\n    let noneToFalseM              = ModelM.getResult    >> ModelM.map  (Result.ifError      false                              )\n    let versionRef     (s:string) = ModelM.versionDimO  |> ModelM.map  (fun versionDim  ->  versionDim?(s)                     )\n    let dataTypeRef    (s:string) = ModelM.dataTypeDimO |> ModelM.map  (fun dataTypeDim ->  dataTypeDim?(s)                    )\n    let getSlice       refM       = refM                |> CubeM.bindM (fun ref         ->  CubeM.forElr [ ref ]               )\n    let containsDTDim             = ModelM.dataTypeDimO |> CubeM.bindM (fun dataTypeDim ->  CubeM.containsDim dataTypeDim.dimId) |> noneToFalseC\n    let containsVersionDim        = ModelM.versionDimO  |> CubeM.bindM (fun versionDim  ->  CubeM.containsDim versionDim .dimId) |> noneToFalseC\n    let containsTimeDim           = ModelM.timeDimO     |> CubeM.bindM (fun timeDim     ->  CubeM.containsDim timeDim    .dimId) |> noneToFalseC\n    let versionDimSl   (s:string) = versionRef     s    |> getSlice\n    let calculatedValue           = dataTypeRef \"Calculated Value\"\n    let manualAdjustment          = dataTypeRef \"Manual Adjustment\"\n    let frozenValue               = dataTypeRef \"Frozen Value\"\n    let value                     = dataTypeRef \"Value\"\n    let formulaElem               = dataTypeRef \"Formula\"\n    let actualElemRef             = ModelM.actualElem |> ModelM.bind versionRef\n    let valueCalc                 = calculationM {\n        let! calName = CalculationM.calName\n        let! meaDim  = CubeM.measureDimR\n        let! value   = value\n        let! slice   = CubeM.forElr [ value ; meaDim?(calName) ]\n        return slice\n    }\n    let tCalcCalcName             = calculationM {\n        let! calName  = CalculationM.calName\n        let! tCalcDim = ModelM.tCalcDimO\n        return tCalcDim?(calName)\n    }\n    let actualElemSl                            = ModelM.actualElem |> CubeM .bindM versionDimSl\n    let exitWhen                              v = if v then Result.fail (errSimple \"false\") else Result.succeed()\n    let cubeActualRule                          = cubeM {\n        let! containsVersionDim = containsVersionDim\n        do!  exitWhen        (not containsVersionDim)\n        let! actualElem         = actualElemRef\n        return Rule.newRule [ actualElem  ]  ExtStet        ForBase \"B\"\n    }\n    let cubeFormulaRuleO  txt                   = cubeM {\n        let! containsDTDim   = containsDTDim\n        do!  exitWhen     (not containsDTDim)\n        let! formulaElem     = formulaElem\n        return Rule.newRule [ formulaElem ] (ExtString txt) ForBase \"G1\"\n    }\n    let cubeInputRuleO                          = cubeFormulaRuleO \"<Input>\"\n    let cubeConsolidationRuleO                  = cubeFormulaRuleO \"<Consolidation>\"\n    let getDimDest                    dimM  frm = dimM |> ModelM.bind (swap Formula.getDimDest frm >> fromOptS \"No getDimDest\" >> ModelM.rtnR)\n    let isFormulaText                       frm = getDimDest ModelM.dataTypeDimO frm |> ModelM.apply (ModelM.map (==) formulaElem  ) |> noneToFalseM \n    let isActual                            frm = getDimDest ModelM.versionDimO  frm |> ModelM.apply (ModelM.map (==) actualElemRef) |> noneToFalseM \n    let containsDimDest               dimM  frm = getDimDest dimM frm |> ModelM.map (fun _ -> true)                                  |> noneToFalseM\n    let dontUseCalculatedValue              frm = containsDimDest ModelM.dataTypeDimO frm\n    let shouldAddCalculatedValueF           frm = calculationM {\n        if frm.forType != ForBase then return false else\n        let! containsDTDim         = containsDTDim\n        if not containsDTDim      then return false else\n        let! dontUseCalculatedValue = dontUseCalculatedValue frm\n        if dontUseCalculatedValue then return false else\n        return true\n    }\n    let addValueRefs exp = modelM {\n        let! dtDim = ModelM.dataTypeDimO\n        let! value = value\n        let rec addValueRefs_elr exp =\n            match exp with\n            | ElemFixed   (did, elId) -> exp\n            | ElemDynamic (did, exT ) -> ElemDynamic(did, addValueRefs_ext exT)\n                \n        and  addValueRefs_ext exp =\n            match exp with\n            | ExtNA\n            | ExtStet\n            | ExtString      _  \n            | ExtDimElement  _  \n            | ExtDimName     _              -> exp\n            | ExtSlice       slc            -> ExtSlice (addValueRefs_slc slc)\n            | ExtFunction   (f, expAs)      -> ExtFunction(f, expAs |> Array.map addValueRefs_exa)\n            | ExtIf         (exC, exT, exe) -> ExtIf(addValueRefs_exn exC, addValueRefs_ext exT, addValueRefs_ext exe)\n        \n        and  addValueRefs_exn exp =\n            match exp with\n            | ExnNA\n            | ExnStet\n            | ExnNumber      _              -> exp\n            | ExnSlice       slc            -> ExnSlice (addValueRefs_slc slc)\n            | ExnOperationN (op , ex1, ex2) -> ExnOperationN (op , addValueRefs_exn ex1, addValueRefs_exn ex2)\n            | ExnUnaryN     (op , exN     ) -> ExnUnaryN     (op , addValueRefs_exn exN                      )\n            | ExnOperationT (op , ex1, ex2) -> ExnOperationT (op , addValueRefs_ext ex1, addValueRefs_ext ex2)\n            | ExnOperationI (op , ex1, ex2) -> ExnOperationI (op , addValueRefs_exa ex1, addValueRefs_exa ex2)\n            | ExnFunction   (f  , exas    ) -> ExnFunction   (f  , exas |> Array.map addValueRefs_exa        )\n            | ExnIf         (exN, exT, exE) -> ExnIf         (exN, addValueRefs_exn exT, addValueRefs_exn exE)\n            | ExnIsNA        exN            -> ExnIsNA       (addValueRefs_exn exN                           )\n            | ExnIsNAt       exT            -> ExnIsNAt      (addValueRefs_ext exT                           )\n            | ExnIsNAa       exa            -> ExnIsNAa      (addValueRefs_exa exa                           )\n            \n        and addValueRefs_exa exp =    \n            match exp with\n            | ExiNA\n            | ExiStet                  -> exp\n            | ExiSlice  slc            -> ExiSlice (addValueRefs_slc slc                                            )\n            | ExNumeric exN            -> ExNumeric(addValueRefs_exn exN                                            )\n            | ExText    exT            -> ExText   (addValueRefs_ext exT                                            )\n            | ExiIf    (exN, exT, exE) -> ExiIf    (addValueRefs_exn exN, addValueRefs_exa exT, addValueRefs_exa exE)\n            \n        and  addValueRefs_slc slc = \n            if slc |> Slice.containsDim dtDim.dimId then slc else\n            { slc with sliDims = slc.sliDims |> Map.add dtDim.dimId value }\n        let res = addValueRefs_exa exp\n        return res\n    } \n    \n    let formulaRule frm = calculationM {\n        let! calcRef             = CalculationM.getElemRefR\n        let! shouldAddCV         = shouldAddCalculatedValueF frm\n        let! calculatedValue     = calculatedValue\n        let  dest                = calcRef :: frm.forDestination |> if shouldAddCV then cons calculatedValue else id\n        let! isFormulaText       = isFormulaText frm\n        let! isActual            = isActual frm\n        let! calOrder            = CalculationM.calOrder\n        let  order               = (if isFormulaText then \"E\" elif isActual then \"A\" else \"M\") & calOrder & frm.forOrder\n        let! exp                 = frm.forExpression |> if shouldAddCV then addValueRefs else ModelM.rtn\n        return Rule.newRule dest exp frm.forType order \n    }\n    let formulaTextRule frm = calculationM {\n        let! containsDTDim   = containsDTDim\n        do!  exitWhen     (not containsDTDim)\n        let! containsDTDest  = containsDimDest ModelM.dataTypeDimO frm\n        do!  exitWhen          containsDTDest\n        let! formulaRef      = formulaElem\n        let! calcRef         = CalculationM.getElemRefR\n        let! calOrder        = CalculationM.calOrder\n        let  order           = \"F\" & calOrder & frm.forOrder\n        return Rule.newRule (formulaRef :: calcRef :: frm.forDestination) (ExtString <| frm.forText.Left 495) frm.forType order\n    }\n    let actualValueRule = calculationM {\n        let! isActualCalcR      = ModelM.isActualCalcO |> ModelM.getResult\n        if   Result.isError isActualCalcR then return id else\n        let! isActualCalc       = isActualCalcR\n        let! containsVersionDim = containsVersionDim\n        let! containsTimeDim    = containsTimeDim\n        let  useActual          = containsVersionDim &&= containsTimeDim\n        if   not useActual        then return id else\n        let! actualElemSl       = actualElemSl\n        return fun body -> IFa(isActualCalc = 1, actualElemSl, body)\n    }\n    let frozenBodyRule = calculationM {\n        let! freezeCubeR        = ModelM.freezeCubeO   |> ModelM.getResult\n        if Result.isError freezeCubeR then  return id else\n        let! freezeCube         = freezeCubeR\n        let! tCalcCalcName      = tCalcCalcName\n        let! frozenValue        = getSlice frozenValue     \n        return fun body -> IFa(Cube.forElr[tCalcCalcName] freezeCube = 1, frozenValue, body)\n    }\n    let calculationRule = calculationM {\n        let! containsDTDim      = containsDTDim\n        do!  exitWhen        (not containsDTDim)\n        let! isInput            = CalculationM.isInput\n        let! isText             = CalculationM.isText\n        let! calOrder           = CalculationM.calOrder\n        let! calName            = CalculationM.calName\n        let! calculatedValue    = getSlice calculatedValue \n        let! manualAdjustment   = getSlice manualAdjustment\n        let  body1              = if    isInput then ExiStet else \n                                     if isText  then IFa(ISNAt manualAdjustment, calculatedValue, manualAdjustment) \n                                                else calculatedValue + manualAdjustment |> ExNumeric\n        let! frozenBodyRule     = frozenBodyRule\n        let! actualValueRule    = actualValueRule\n        let  body2              = body1 |> frozenBodyRule |> actualValueRule\n        //do!  exitWhen  (body2 == ExiStet)\n        let! valueCalc          = valueCalc \n        return Rule.newRule (valueCalc.sliDims |> Map.toList |> List.map snd) body2 ForBase (\"N\" & calOrder)\n    }\n    let formulaRules frm = calculationM {\n        let! cubId        = CubeM.cubId\n        let! formRule     = formulaRule     frm |> CalculationM.getResult\n        let! formTextRule = formulaTextRule frm |> CalculationM.getResult\n        return [   cubId, (FormulaKey frm.forId), formRule     |> Result.toOption\n                   cubId, (ForTextKey frm.forId), formTextRule |> Result.toOption\n               ]\n     }\n    let calcRules = calculationM {\n        let! cubId        = CubeM.cubId\n        let! calId        = CalculationM.calId\n        let! calFormulas  = CalculationM.calFormulas\n        let! rule         = calculationRule |> CalculationM.getResult\n        let! ruless       = calFormulas     |> Seq.map formulaRules |> Seq.toList |> CalculationM.sequenceM\n        let  rules        = ruless          |> List.collect id\n        return (cubId, CalcRuleKey calId, rule |> Result.toOption) :: rules\n    }\n    let cubeRules = cubeM {\n        let! cubId        = CubeM.cubId\n        let! actualRule   = cubeActualRule          |> CubeM.getResult\n        let! inputRule    = cubeInputRuleO          |> CubeM.getResult\n        let! consolRule   = cubeConsolidationRuleO  |> CubeM.getResult\n        return [   cubId, ActualRuleKey      , actualRule |> Result.toOption\n                   cubId, InputRuleKey       , inputRule  |> Result.toOption\n                   cubId, ConsolidatedRuleKey, consolRule |> Result.toOption\n               ]\n    }\n    let modelRulesM = modelM {\n        let! model           = ModelM.model\n        let! modCubes        = ModelM.modCubes\n        let! modCalculations = ModelM.modCalculations\n        let  allCubeRules    = modCubes |> Seq.filter Cube.isCalcCube |> Seq.choose (fun cub -> CubeM.run        model cub cubeRules |> Result.toOption) |> Seq.collect id\n        let  allCalcRules    = modCalculations                        |> Seq.choose (fun cal -> CalculationM.run model cal calcRules |> Result.toOption) |> Seq.collect id\n        return Seq.append allCubeRules allCalcRules\n    }\n    let modelRules    model = ModelM.run model modelRulesM\n    let addModelRules model =\n        result {\n            let! rules  = modelRules model \n            let  model2 = Model.addRules rules model\n            return model2\n        } \n        |> fun res -> \n            Result.getMsgs res |> Seq.iter (printfn \"%A\")\n            res |> Result.ifError model\n    \n    let addCalcRules model cid =\n        result {\n            let! calc   = Model.getCalcR cid model\n            let! rules  = calcRules |> CalculationM.run model calc\n            let  model2 = Model.addRules rules model\n            return model2\n        } \n        |> fun res -> \n            Result.getMsgs res |> Seq.iter (printfn \"%A\")\n            res |> Result.ifError model\n        \n    \n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}, {"SnippetId" :"90cfafb9-9397-4dda-940b-8e33c4412d1c"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"}, "snpName": "RuleText", "snpContent": "module RuleText =\n    open CalculationModel\n    open Useful\n    \n    let uoRuleText op =\n            match op with\n            | UoPlus  -> \"+\"\n            | UoMinus -> \"-\"\n            \n    let opRuleText isText op =\n            match isText, op with\n            | _    , OpAdd      -> \"+\"\n            | _    , OpSubtract -> \"-\"\n            | _    , OpMultiply -> \"*\"\n            | _    , OpDivide   -> \"/\"\n            | _    , OpAnd      -> \"and\"\n            | _    , OpOr       -> \"or\"   \n            | false, OpEQ       -> \"=\"\n            | false, OpNE       -> \"<>\"\n            | false, OpGT       -> \">\"\n            | false, OpGE       -> \">=\"\n            | false, OpLT       -> \"<\"\n            | false, OpLE       -> \"<=\"\n            | true , OpEQ       -> \"@=\"\n            | true , OpNE       -> \"@<>\"\n            | true , OpGT       -> \"@>\"\n            | true , OpGE       -> \"@>=\"\n            | true , OpLT       -> \"@<\"\n            | true , OpLE       -> \"@<=\"\n    \n    let elemRuleText elem = sprintf \"'%s'\" elem.elmName       \n    let elementTextR dId eId = modelM {\n        let! dim  = ModelM.getDimR dId \n        let! elem = Dimension.getElementR eId dim\n        return elemRuleText elem\n    }\n//    module DimN    = AleaN.DimensionN\n//    module ServerN = AleaN.ServerN\n//    let firstTopElement           = dimensionM {\n//        let! dimName              = DimensionM.dimName\n//        let  dim                  = Alea.Dimension dimName\n//        let! servName             = ModelM.server\n//        let  server               = Alea.Server servName\n//        let! elems                = DimN.topElements |> DimN.runM dim |> ServerN.run server\n//        let! (Alea.Element first) = elems |> Seq.tryHead |> fromOptF (fun () -> sprintf \"Dimension %s Has No Elements\" dimName)\n//        return first\n//    }\n    let defaultElementTextR = dimensionM {\n        let! defaultElmId = DimensionM.defaultElm\n        match defaultElmId |> Option.map DimensionM.getElementR with\n        | Some elmD -> let! elm = elmD\n                       return elemRuleText elm \n        | None      -> let! name = DimensionM.dimName\n                       return sprintf \"Dimension %s Has No Elements\" name\n    }\n    let allFixedRefs (refs:Map<DimId,ElmReference>) =\n        refs \n        |> Seq.map (fun x -> x.Value)\n        |> Seq.exists (\n            function\n            | ElemFixed   _                \n            | ElemDynamic(_, ExtString(_)) -> false\n            | _                            -> true\n        )\n        |> not\n    \n    let fixedText dim txt = sprintf \"%s: %s\" dim.dimName txt\n    \n    let rec elrRuleTextR elr : CubeM<string> = cubeM {\n        match elr with\n        | ElemFixed   ( dId, eId) -> return! elementTextR dId eId |> CubeM.rtnM\n        | ElemDynamic (_dId, exT) -> return! extRuleTextR exT\n      }\n    and fixedTextR elr : CubeM<string> = cubeM {\n        let! dim = ModelM.getDimR (ElmReference.dimId elr)\n        let! txt = elrRuleTextR elr\n        return fixedText dim txt                                                            \n      }\n    and calcRuleTextRefR  : CalculationM<string> = calculationM {\n        let! meaDimName = CubeM.measureDimNameR\n        let! calName    = CalculationM.calName\n        return sprintf \"%s: '%s'\" meaDimName calName\n      }\n    and localSlcRuleTextR (refs:Map<DimId,ElmReference>) : CubeM<string> = cubeM {\n        return! refs\n                |> Seq.map  (fun x -> fixedTextR x.Value)\n                |> Seq.toList\n                |> CubeM.sequenceM\n                |> CubeM.map (String.concat \", \")\n                |> CubeM.map (sprintf \"[%s]\")\n      }\n    and dimParameterText thisDims dimId : CubeM<string> = cubeM {\n        let! dim = ModelM.getDimR dimId\n        if   Seq.exists ((=) dimId) thisDims\n        then return \"!\" + dim.dimName\n        else let!   res = defaultElementTextR |> DimensionM.runM dim\n             return res |> sprintf \"'%s'\"\n      }\n    and dbCallRuleText (refs:Map<DimId,ElmReference>) thatCubId : CubeM<string> = cubeM {\n        let! thisDims = CubeM.cubDims\n        let! thatCube = ModelM.getCubeR thatCubId\n        let! texts    = thatCube.cubDims\n                        |> Seq.map (fun d ->\n                            refs \n                            |> Map.tryFind d\n                            |> Option.map          elrRuleTextR\n                            |> Option.defaultWith (fun () -> dimParameterText thisDims d)\n                           )\n                        |> Seq.toList\n                        |> CubeM.sequenceM\n        return texts |> String.concat \", \" |> sprintf \"DB('%s', %s)\" thatCube.cubName\n      }\n    and cubeSlcRuleTextR refs slcCubId : CubeM<string> = cubeM {\n        let! thisCubId = CubeM.cubId\n        if   thisCubId = slcCubId && allFixedRefs refs\n        then return! localSlcRuleTextR            refs\n        else return! dbCallRuleText refs slcCubId\n      }\n    and calcSlcRuleTextR refs = calculationM {\n        let! meaDimId = CubeM.measureDim\n        let! calName  = CalculationM.calName\n        let  refsNew  = Map.add meaDimId (ElemDynamic(meaDimId, ExtString calName) ) refs\n        let! cubeId   = CubeM.cubId\n        return refsNew, cubeId\n      }\n    and slcRuleTextR (slc: Slice) : CubeM<string> = cubeM {\n        let refs = slc.sliDims\n        match slc.cube  , slc.calculation with\n        |     Some cubId, None            -> return! cubeSlcRuleTextR     refs cubId\n        |     _         , Some calId      -> let! calc          = ModelM.getCalcR calId\n                                             let! nRefs, cubId  = calcSlcRuleTextR refs |> CalculationM.runM calc\n                                             return! cubeSlcRuleTextR nRefs cubId\n        |     _         , _               -> let! thisCubId = CubeM.cubId\n                                             return! cubeSlcRuleTextR     refs thisCubId\n      }\n    and exnRuleTextR (exn:ExpressionNumber) : CubeM<string> = cubeM {\n        match exn with\n        | ExnNA                     -> return  \"#NA\"\n        | ExnStet                   -> return  \"STET\"\n        | ExnSlice      slc         -> return! slcRuleTextR slc\n        | ExnNumber     fn          -> return  sprintf \"%A\" fn\n        | ExnIsNA           n       -> let! v    = exnRuleTextR n\n                                       return  sprintf \"(%s) = #NA\"             v\n        | ExnIsNAt          n       -> let! v    = extRuleTextR n\n                                       return  sprintf \"(%s) = #NA\"             v\n        | ExnIsNAa          n       -> let! v    = exaRuleTextR n\n                                       return  sprintf \"(%s) = #NA\"             v\n        | ExnIf        (cn, th, el) -> let! cond = exnRuleTextR cn\n                                       let! theN = exnRuleTextR th\n                                       let! elsE = exnRuleTextR el\n                                       return  sprintf \"IF(%s, %s, %s)\"   cond theN elsE\n        | ExnUnaryN    (op, n     ) -> let! v   = exnRuleTextR n\n                                       let  opt = uoRuleText               op\n                                       return  sprintf \"(%s %s)\"           opt  v   \n        | ExnOperationN(op, n1, n2) -> let! v1  = exnRuleTextR n1\n                                       let  opt = opRuleText        false  op\n                                       let! v2  = exnRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnOperationT(op, n1, n2) -> let! v1  = extRuleTextR n1 \n                                       let  opt = opRuleText        true   op\n                                       let! v2  = extRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnOperationI(op, n1, n2) -> let! v1  = exaRuleTextR n1\n                                       let  opt = opRuleText        false  op\n                                       let! v2  = exaRuleTextR n2\n                                       return  sprintf \"(%s) %s (%s)\"           v1 opt v2\n        | ExnFunction(Function fn, ps) ->\n                                       let! parmTexts = ps |> Seq.toList |> CubeM.traverseM exaRuleTextR\n                                       return parmTexts |> String.concat \", \" |> sprintf \"%s(%s)\" fn\n      }\n    and extRuleTextR (ext:ExpressionText) : CubeM<string> = cubeM {\n        match ext with\n        | ExtNA                     -> return      \"#NA\"\n        | ExtStet                   -> return      \"STET\"\n        | ExtSlice      slc         -> return!     slcRuleTextR slc\n        | ExtString     str         -> return      sprintf \"'%s'\" (str.Replace(\"'\", \"''\"))\n        | ExtDimElement dId         -> let! dim   = ModelM.getDimR dId\n                                       let! dimNm = DimensionM.dimName |> DimensionM.runM dim\n                                       return       sprintf \"!%s\"  dimNm\n        | ExtDimName    dId         -> let! dim   = ModelM.getDimR dId\n                                       let! dimNm = DimensionM.dimName |> DimensionM.runM dim\n                                       return       sprintf \"'%s'\" dimNm\n        | ExtIf        (cn, th, el) -> let! cond  = exnRuleTextR cn\n                                       let! theN  = extRuleTextR th\n                                       let! elsE  = extRuleTextR el\n                                       return  sprintf \"IF(%s, %s, %s)\"   cond theN elsE\n        | ExtFunction(Function fn, ps) ->\n                                       let! parmTexts = ps |> Seq.toList |> CubeM.traverseM exaRuleTextR\n                                       return parmTexts |> String.concat \", \" |> sprintf \"%s(%s)\" fn\n      }\n    and exaRuleTextR (exa:ExpressionAny) : CubeM<string> = cubeM {\n        match exa with\n        | ExiNA                     -> return  \"#NA\"\n        | ExiStet                   -> return  \"STET\"\n        | ExiSlice      slc         -> return! slcRuleTextR slc\n        | ExNumeric     nmb         -> return! exnRuleTextR nmb\n        | ExText        txt         -> return! extRuleTextR txt\n        | ExiIf        (cn, th, el) -> let! cond = exnRuleTextR cn\n                                       let! theN = exaRuleTextR th\n                                       let! elsE = exaRuleTextR el\n                                       return sprintf \"IF(%s, %s, %s)\" cond theN elsE\n      }\n    let destRuleText ref = cubeM{\n        match ref with\n        | ElemFixed   ( dId, eId           ) -> let! dim = ModelM.getDimR dId\n                                                let! elm = elementTextR dId eId\n                                                return  sprintf \"%s: %s\" dim.dimName elm\n        | ElemDynamic ( dId, ExtString(txt)) -> let! dim = ModelM.getDimR dId\n                                                return  sprintf \"%s: %s\" dim.dimName txt                      \n        | ElemDynamic (_dId, exp           ) -> return! extRuleTextR exp\n      }\n      \n    let rulDestinationR rul = cubeM {\n        let! texts = rul.rulDestination |> CubeM.traverseM destRuleText\n        return texts |> String.concat \", \" |> sprintf \"[%s]\"\n     }\n\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"90cfafb9-9397-4dda-940b-8e33c4412d1c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ae673f6e-a1eb-4829-ad55-4761e20b9112"}, "snpName": "Messaging", "snpContent": "module Messaging =\n    open Useful\n    open CalculationModel\n    \n    let ruleXml rule = cubeM {\n        let doc      = System.Xml.XmlDocument()\n        doc.LoadXml   \"<Alea:Rules xmlns:Alea=\\\"http://www.misag.com\\\" OrderAccelerated=\\\"false\\\" />\"\n        let node     = doc.CreateElement    \"Rule\"  |> doc.FirstChild.AppendChild\n        let attr a v = (doc.CreateAttribute a |> node.Attributes.Append).Value <- v\n        attr \"Order\" rule.rulOrder\n        do match rule.rulType with\n           | ForBase         -> attr \"Cells\" \"Basic\"\n           | ForConsolidated -> attr \"Cells\" \"Consolidated\"\n           | ForAll          -> ()           \n        let! dest = RuleText.rulDestinationR rule\n        let! text = RuleText.exaRuleTextR    rule.rulExpression\n        do node.AppendChild(doc.CreateElement \"Target\" ).InnerText <- dest\n        do node.AppendChild(doc.CreateElement \"Formula\").InnerText <- text\n        let xml = doc.FirstChild\n                     .InnerXml.Replace(\"<Rule\"   , \"<Alea:Rule\"   ).Replace(\"</Rule\"   , \"</Alea:Rule\"  )\n                              .Replace(\"<Target\" , \"<Alea:Target\" ).Replace(\"</Target\" , \"</Alea:Target\")\n                              .Replace(\"<Formula\", \"<Alea:Formula\").Replace(\"</Formula\", \"</Alea:Formula\")\n        return xml\n    }\n\n    let textCubeRules = cubeM {\n        let! rules    = CubeM.cubRules\n        let! xmls     = \n            Map.toSeq rules \n            |> Seq.choose (function (key, Some rul) -> Some (key, rul) |_-> None)\n            |> Seq.sortBy (fun      (_  ,      rul) -> rul.rulOrder             )\n            |> Seq.map    (fun      (key,      rul) -> cubeM {\n                let! xml = ruleXml rul\n                return key, xml\n            })\n            |> Seq.toList\n            |> CubeM.sequenceM\n        return xmls |> Seq.toArray\n    }\n    \n    let processMsg (msg:RuleMsg) = wrap {\n        match msg with\n        | GetInitModelStats     ->\n            return \n                sprintf \"calcs = %d, dims = %d, cubes = %d\"\n                    InitModel.initModel.modCalculations.Length\n                    InitModel.initModel.modDims        .Length\n                    InitModel.initModel.modCubes       .Length\n                |> ReplyInformation \n        | GetRulesForCube   cid ->\n            let! cube = InitModel.initModel.modCubes |> Seq.tryFind (fun c  -> c.cubId = cid) |> Result.fromOptionW (fun () -> sprintf \"Could not find cube %A\" cid |> errSimple)\n            let! xml  = textCubeRules |> CubeM.run InitModel.initModel cube\n            return ReplyRules xml\n    }\n        \n    let mutable private endPoint = \"\"\n    let setEndPoint ep =\n        if endPoint <> \"\" then failwith (sprintf \"Endpoint already set to: %s\" endPoint) else\n        endPoint <- ep\n        let messaging = new WSMessagingBroker.WSMessagingClient(\"CalculationModel\", endPoint = endPoint)\n        printfn \"listening: %s\" messaging.EndPoint\n        messaging.ProcessIncoming processMsg", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"06aa50e4-05e5-4862-a528-57cdef08acfc"}, {"SnippetId" :"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8578db18-9dc2-4654-95af-dad8b6bb1547"}, "snpName": "CalculationModelDll", "snpContent": "// select the snippets that form the Assembly. The name of this snippet 'CalculationModelDll' will be the name of the Assembly", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"06aa50e4-05e5-4862-a528-57cdef08acfc"}, {"SnippetId" :"3425a36b-08fa-4a1e-8284-3785e56f8b06"}, {"SnippetId" :"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"}, {"SnippetId" :"ae673f6e-a1eb-4829-ad55-4761e20b9112"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"980cbebb-065e-4b10-86c5-87df2fab5cb7"}, "snpName": "xxxUpdate Model", "snpContent": "\nmodule UpdateModel =\n    open CalculationModel\n    open Alea\n    open AleaN\n\n    let serverOlap         model = Alea.Server model.server\n\n    let calcList model flt =\n        model.modCalculations\n        |> Seq.filter flt\n        |> Seq.map    (fun c -> sprintf \"%s\\t%s\" (if c.isText then \"S\" else \"N\" ) c.calName)\n        |> String.concat \"\\n\"\n\n    let measureFields = [\n            Field.newField \"Type\"          1s \"Type\"       0s  10s 0s \n            Field.newField \"Format_String\" 1s \"Format\"     0s 254s 0s \n    ]\n    \n    let tCalcFields =\n        measureFields @ [\n            Field.newField \"Cube\"          1s \"Cube\"       0s  50s 0s \n            Field.newField \"FreezeCube\"    1s \"FreezeCube\" 0s  50s 0s \n            Field.newField \"User\"          1s \"User\"       0s  50s 0s \n        ]\n        \n    let getFldByDesc d fs = fs |> List.tryFind (fun f -> f.fldDescription = d) |> Result.fromOption (ErrSimple (\"Attribute Field not found\", false))\n\n    let importDimension txt desc = dimensionN {\n        let  temp1   = new UsefulDotNet.TempFileName()\n        System.IO.File.WriteAllText(temp1.Name, txt )\n        let  temp2   = new UsefulDotNet.TempFileName()\n        let! res     = DimensionN.import temp1.Name temp2.Name  \"\\t\"  desc |> DimensionN.getResult\n        do  (temp1 :> IDisposable).Dispose()\n        do  (temp2 :> IDisposable).Dispose()  // Cannot use 'use' or 'use!' because the reader monad does not execute immediately\n        return res\n    }\n    \n    let createAttributeTable atTblN fields = dimensionN {\n        let! _r      = DimensionN.attTableDeleteR      atTblN  |> DimensionN.getResult\n        let! handle  = DimensionN.attTableCreateBeginR atTblN\n        let! handles = fields |> DimensionN.traverseM (fun fld -> FieldN.runD fld FieldN.fieldAddR)\n        let! commit  = handles|> HandleN.sequenceM |> HandleN.run DimensionN.createCommitR handle\n        return commit\n    }\n\n    let createMeasureDimension model cub = dimensionN {\n        let! _r      = importDimension (calcList model (fun c -> c.cube = Some cub.cubId)) (\"Measures for \" + cub.cubName)\n        let! _r      = createAttributeTable 1s measureFields\n        let! fType   = getFldByDesc \"Type\"     measureFields\n        let! fFormat = getFldByDesc \"Format\"   measureFields\n        for c in model.modCalculations |> Seq.filter (fun c -> c.cube = Some cub.cubId) do\n            let typ  = Calculation.calcType c\n            let! _r  = DimensionN.putValueR fType     typ    c.calName\n            let! _r  = DimensionN.putValueR fFormat c.format c.calName\n            ()\n    }\n    \n    let createCube model cub dimOlap = cubeN {\n        let  dims      = Cube.dims model cub\n        let  dimNames  = dims     |> Array.map (fun d -> d.dimName.ToUpper())\n        let  dimsOlap  = dimNames |> Array.map Dimension\n        let! currentDs = CubeN.dimensionsR |> CubeN.getResult\n        let  exists    = currentDs\n                         |> Result.map(\n                             Array.map (fun dimOlap -> (Dimension.name dimOlap).ToUpper() )\n                             >> ((=) dimNames))\n                         |> Result.ifError false\n        if not exists then\n            let! _r    = CubeN.delete |> CubeN.getResult\n            let! _r    = CubeN.create     dimsOlap\n            let! _r    = CubeN.setMeasure dimOlap \n            ()\n    }\n    \n    let createDimensionAndCube model cub = serverN {\n        let!    dimName   = Cube.measureDimNameR model cub\n        printfn \"creating dimension %s\" dimName\n        let     dim       = Dimension dimName\n        do!     createMeasureDimension model cub     |> DimensionN.runM dim\n        return! createCube             model cub dim |> CubeN     .runM (Alea.Cube cub.cubName)\n    }\n    \n    let createCubes = modelM {\n        let! modCubes = ModelM.modCubes\n        let! model    = ModelM Result.succeed\n        return serverN {\n            for cube in modCubes |> Seq.filter (fun cub -> cub.cubType = CtCalc) do\n                    do! createDimensionAndCube model cube\n        }\n    }\n\n    let createTCalcDimension model = dimensionN {\n        let! _r      = importDimension (calcList model <| fun _ -> true) \"Model Calculations\"\n        let! _r      = createAttributeTable 1s tCalcFields\n        let! fCube   = getFldByDesc \"Cube\"     tCalcFields\n        let! fType   = getFldByDesc \"Type\"     tCalcFields\n        let! fFormat = getFldByDesc \"Format\"   tCalcFields\n        for c in model.modCalculations do\n            let  typ  = Calculation.calcType c\n            let! cube = c.cube |> Option.map (swap Model.getCubeR model) |>  Result.fromOption (ErrSimple(\"Cube not found\", false)) |> Result.join\n            let! _r   = DimensionN.putValueR fCube    cube.cubName c.calName\n            let! _r   = DimensionN.putValueR fType    typ          c.calName\n            let! _r   = DimensionN.putValueR fFormat c.format      c.calName\n            ()\n    }\n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"90cfafb9-9397-4dda-940b-8e33c4412d1c"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cd877d32-4cbd-4d2f-9b7b-db85e57ad0f4"}, "snpName": "xxxxWriteRules", "snpContent": "module WriteRules =\n    open CalculationModel\n    //open AleaN\n\n    let ruleXml (doc:System.Xml.XmlDocument) rule = cubeM {\n        printf \".\"\n        let node    = doc.CreateElement    \"Rule\"  |> doc.FirstChild.AppendChild\n        let cells v = (doc.CreateAttribute \"Cells\" |> node.Attributes.Append).Value <- v\n        do match rule.rulType with\n           | ForBase         -> cells \"Basic\"\n           | ForConsolidated -> cells \"Consolidated\"\n           | ForAll          -> ()           \n        let! dest = RuleText.rulDestinationR rule\n        let! text = RuleText.exaRuleTextR    rule.rulExpression\n        do node.AppendChild(doc.CreateElement \"Target\" ).InnerText <- dest\n        do node.AppendChild(doc.CreateElement \"Formula\").InnerText <- text\n    }\n\n    let writeCubeRule() = cubeM {\n        let! cubName  = CubeM.cubName\n        printfn \"\\nWriting rules for cube %s\" cubName\n        let doc       = System.Xml.XmlDocument()\n        doc.LoadXml     \"<Alea:Rules xmlns:Alea=\\\"http://www.misag.com\\\" Accelerated=\\\"false\\\" />\"\n        let! rules    = CubeM.cubRules\n        let! addRules = rules \n                        |> Seq.choose (fun rkv -> rkv.Value   ) \n                        |> Seq.sortBy (fun rul -> rul.rulOrder)\n                        |> Seq.map    (ruleXml doc)\n                        |> Seq.toList\n                        |> CubeM.sequenceM \n        let xml = doc.InnerXml.Replace(\"<Rule\"   , \"<Alea:Rule\"   ).Replace(\"</Rule\"   , \"</Alea:Rule\"  )\n                              .Replace(\"<Target\" , \"<Alea:Target\" ).Replace(\"</Target\" , \"</Alea:Target\")\n                              .Replace(\"<Formula\", \"<Alea:Formula\").Replace(\"</Formula\", \"</Alea:Formula\")\n        return CubeN.putRulesForcedR xml |> CubeN.map ignore |> CubeN.runM (Alea.Cube cubName)\n    }\n    \n    let writeRules = modelM {\n        let!    cubes = ModelM.modCubes\n        return! cubes |> Seq.toList |> ModelM.traverseM (fun cube -> CubeM.runM cube <| writeCubeRule())\n    }\n        \n    open UpdateModel\n    open AleaN\n\n    let updateModel = modelM {\n        let! creates   = createCubes\n        let! model     = ModelM.model\n        let  creaTCalc = createTCalcDimension model |> DimensionN.runM (Alea.Dimension \"TCalc\")\n        let! writes    = writeRules  \n        let! server    = ModelM.server\n        let  actions   = List.append [ creates; creaTCalc] writes |> ServerN.sequenceM\n        let! res       = ServerN.run (Alea.Server server) actions\n        let! res       = ServerN.disconnectServer (Alea.Server server)\n        return res\n    }\n\n    let createCubesR model = ModelM.run model updateModel \n\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"746803c6-b7b3-4730-a3b6-4e6fd1f1c390"}, {"SnippetId" :"980cbebb-065e-4b10-86c5-87df2fab5cb7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"19f52d97-7978-4a6e-9fca-fd872eeb5eaf"}, "snpName": "xxxAlea Interfase", "snpContent": "//#I @\"D:\\Program Files (x86)\\Infor\\BI\\OLAP\\bin\"\n//#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\n#define FSI32BIT\n\n#r \"../packages/FSharp.ComProvider/lib/net40/FSharp.ComProvider.dll\"\n\nopen Useful\n\ntype ErrAlea(errn, msg, warning) =\n    interface ErrMsg with\n        member this.ErrMsg   : string = msg errn\n        member this.IsWarning: bool   = warning\n    override this.ToString() = msg errn\n\nmodule Alea =\n\n    type MdsAut = TypeLib.``Alea Automation Server (Inproc)``.``1.0``\n    let private g  = new MdsAut.GeneralClass        ()\n    let private s  = new MdsAut.ServersClass        ()\n    let private d  = new MdsAut.DimensionsClass     ()\n    let private c  = new MdsAut.TablesClass         ()\n    let private at = new MdsAut.AttributeTablesClass()\n    let private e  = new MdsAut.ElementsClass       ()\n    let private l  = new MdsAut.DataCellsClass      ()\n\n    let res = g.MdsInit 0\n\n    let callR<'T> ef (v: obj) =\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then Result.fail (ErrAlea(errN, (fun n -> g.MdsError n |> unbox<string> |> sprintf \"Alea %d: %s\" errN |> ef), false))\n        else v |> unbox<'T> |> Result.succeed\n        \n    let callR2<'T> ef f p = \n      result {\n        let v    = f p\n        let err  = g.MdsGetLastError()\n        let errN = unbox<int> err\n        if  errN <> 0 && v = err\n        then return! Result.fail (ErrAlea(errN, (fun n -> g.MdsError n |> unbox<string> |> sprintf \"Alea %d: %s\" errN), false))\n        else return v |> unbox<'T> \n      } |> Result.mapErr (fun e -> e.ToString() |> ef |> errSimple :> ErrMsg)\n\n    type Server    = Server    of string\n    type Dimension = Dimension of string\n    type Cube      = Cube      of string\n    type Element   = Element   of string\n    type Field     = {\n        fldName        : string\n        fldTable       : int16\n        fldDescription : string\n        fldType        : int16\n        fldLength      : int16\n        fldDecimals    : int16\n    }\n    type Handle    = Handle    of int\n    \n    module private Names =\n        let sname (Server    n    ) = n\n        let dname (Dimension n    ) = n\n        let cname (Cube      n    ) = n\n        let ename (Element   n    ) = n\n        let fname  f                = f.fldName\n    \n    module Server =\n        let address     server = Names.sname server\n        let ef       fn server = (sprintf \"Server.%s %A: %s\" fn server)\n        let connectRl    server = s.ServerConnectEx (address server, \"Admin\", \"\") |> callR<bool> (ef \"connectR\"    server)\n        let disconnectRl server = s.ServerDisconnect(address server             ) |> callR<bool> (ef \"disconnectR\" server)\n        let connectR            = Log.InOut \"connectRl\"    connectRl\n        let disconnectR         = Log.InOut \"disconnectRl\" disconnectRl\n\n    module Element = \n        open Names\n        let name                      elem   = ename elem\n        let ef          fn server dim elem   = (sprintf \"Element.%s %A %A %A: %s\" fn server dim elem)\n        let withR<'T>   fn server dim elem f = f <| sname server <| dname dim <| ename elem |> callR<'T> (ef fn server dim elem)\n        let childrenCountR server dim elem   = withR<int   > \"childrenCountR\" server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenCount(servAd, dimN, elemN) \n        let childrenNameR  server dim elem i = withR<string> \"childrenNameR\"  server dim elem  <| fun servAd dimN elemN -> e.ElementChildrenName (servAd, dimN, elemN, i)\n        let childrenR      server dim elem   = result {\n                                                   let! n     = childrenCountR server dim elem\n                                                   let! elems = seq [1..n] |> Result.Seq.traverseM (childrenNameR server dim elem)\n                                                   return elems |> Seq.map Element\n                                               }\n    module Handle =\n        let int   (Handle n) = n\n        let int16 (Handle n) = int16 n\n        \n    module Dimension = \n        open Names\n        let name         (Dimension n)                         = n\n        let ef          fn server dim                          = (sprintf \"Dimension.%s %A %A: %s\" fn server dim)\n        let withR<'T>   fn server dim f                        = f <| sname server <| dname dim |> callR<'T> (ef fn server dim)\n        let withL<'T>   fn server dim f                        = Log.InOut fn (fun dim -> withR<'T> fn server dim f)    <| dim\n        let import         server dim          df ef del desc  = withL<bool  > \"import\"         server dim   <| fun servAd dimN -> d.DimensionImport        (servAd, dimN, df, ef, (del:string), (desc:string))\n        let editBeginR     server dim          clear desc      = withL<bool  > \"editBeginR\"     server dim   <| fun servAd dimN -> d.DimensionEditBegin     (servAd, dimN, clear, desc |> Option.defaultValue dimN)\n        let addElementR    server dim eType elem parent weight = withR<bool  > \"addElementR\"    server dim   <| fun servAd dimN -> d.DimensionEditAddElement(servAd, dimN, eType, elem, parent, weight, \"\")\n        let editCommitR    server dim commit                   = withL<bool  > \"editCommitR\"    server dim   <| fun servAd dimN -> d.DimensionEditCommit    (servAd, dimN, commit) \n        let elementsCountR server dim                          = withR<int   > \"elementsCountR\" server dim   <| fun servAd dimN -> e.ElementsCount          (servAd, dimN) \n        let elementsNameR  server dim i                        = withR<string> \"elementsNameR\"  server dim   <| fun servAd dimN -> e.ElementsName           (servAd, dimN, i) \n        let topElements    server dim                          = let arr = ref [||]\n                                                                 withR<bool> \"ElementTopLevelGetArray\" server dim <| fun servAd dimN -> e.ElementTopLevelGetArray(servAd, dimN, arr)\n                                                                 |> Result.map (fun _ -> !arr |> Seq.map Element)\n     \n        let elementsR server dim = result {\n                                       let! n     = elementsCountR server dim\n                                       let! names = seq [1..n] |> Result.Seq.traverseM (elementsNameR server dim )\n                                       let  elems = names |> Seq.map Element\n                                       return elems\n                                   }\n        let inputsR   server dim = elementsR server dim\n                                   |> Result.bind (Result.Seq.traverseM (fun elem -> Element.childrenCountR server dim elem |> Result.map (fun cnt -> if cnt <> 0 then Some elem else None)) )\n                                   |> Result.map  (Seq.choose id)\n        let attTableDeleteR      server dim nT                  = withL<bool> \"attTableDeleteR\"      server dim <| fun servAd dimN -> at.ATableDelete     (servAd, dimN, nT |> int)\n        let attTableCreateBeginR server dim nT                  = withL<int > \"attTableCreateBeginR\" server dim <|(fun servAd dimN -> at.ATableCreateBegin(servAd, dimN, nT - 1s  )) |> Result.map Handle\n        let fieldAddR            handle fld                     = at.ATableFieldAdd(    Handle.int16 handle, fld.fldName, fld.fldDescription, fld.fldType, fld.fldLength, fld.fldDecimals) |> callR<bool> (sprintf \"Dimension.fieldAddR     %s %s\" fld.fldName) \n        let createCommitR        handle                         = at.ATableCreateCommit(Handle.int16 handle                             ) |> callR<bool> (sprintf \"Dimension.createCommitR %s\")\n\n    module Field =\n        open Names\n        let newField fldName fldTable fldDescription fldType fldLength fldDecimals   = {\n            fldName        = fldName       \n            fldTable       = fldTable      \n            fldDescription = fldDescription\n            fldType        = fldType       \n            fldLength      = fldLength     \n            fldDecimals    = fldDecimals   \n        }\n        let name                       fld        = Names.fname fld\n        let number                     fld        = fld.fldTable\n        let withR<'T>    fn server dim fld ef   f = f <| sname server <| dname dim <| number fld <| fname fld |> callR<'T> (ef fn server dim fld)\n        let ef           fn server dim fld        = sprintf \"Field.%s %A %A %A: %s\"     fn server dim fld\n        let ef2     elem fn server dim fld err    = sprintf \"%s Element: '%s'\"      (ef fn server dim fld err) elem\n        let getInfoDescR    server dim fld        = withR<string> \"getInfoDescR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 2)\n        let getInfoAtypR    server dim fld        = withR<int16 > \"getInfoAtypR\"    server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 3)\n        let getInfoLengthR  server dim fld        = withR<int16 > \"getInfoLengthR\"  server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 4)\n        let getInfoDecimalR server dim fld        = withR<int16 > \"getInfoDecimalR\" server dim fld  ef        <| fun servAd dimN nS field -> at.ATableFieldGetInfo(    servAd, dimN, nS,              field, 5)\n        let putValueR       server dim fld v elem = withR<bool  > \"putValueR\"       server dim fld (ef2 elem) <| fun servAd dimN nS field -> at.ATableFieldPutValue(v, servAd, dimN, nS |> int, elem, field   )\n\n    module Cube =\n        open Names\n        let name                    cube           = Names.cname cube\n        let ef            fn server cube           = (sprintf \"Cube.%s %A %A: %s\" fn server cube)\n        let withR<'T>     fn server cube f         = callR2<'T> (ef fn server cube) (f <| sname server) <| cname cube\n        let withL<'T>     fn server cube f         = Log.InOut fn (fun cube -> withR<'T> fn server cube f)    <| cube\n        let create           server cube ds        = withL<bool  > \"create\"           server cube <| fun servAd cubeN -> \n                                                        let dims = ds |> Array.map Dimension.name\n                                                        let dim n = Array.tryItem n dims |> Option.defaultValue null\n                                                        c.TablesAdd(servAd, cubeN, cubeN, dims.[0], dims.[1]\n                                                                  , dim  2, dim  3, dim  4, dim  5\n                                                                  , dim  6, dim  7, dim  8, dim  9\n                                                                  , dim 10, dim 11, dim 12, dim 13\n                                                                  , dim 14, dim 15, dim 16, dim 17\n                                                                  , dim 18, dim 19)\n        let delete           server cube           = withL<bool  > \"delete\"           server cube <| fun servAd cubeN -> c.TableKill(servAd, cubeN)\n        let putRulesForcedR  server cube xml       = withL<bool  > \"putRulesForced\"   server cube <| fun servAd cubeN -> c.TablePutRulesForced(servAd, cubeN, xml)\n        let setMeasure       server cube dim       = withR<bool  > \"setMeasure\"       server cube <| fun servAd cubeN -> c.TableSetMeasureDimension(servAd, cubeN, Dimension.name dim)\n        let dimensionsCountR server cube           = withR<int   > \"dimensionsCountR\" server cube <| fun servAd cubeN -> c.TableDimensionsCount(servAd, cubeN)\n        let exists           server cube           = dimensionsCountR                 server cube |> Result.map ((>) 0) |> Result.ifError false  \n        let dimensionsNameR  server cube i         = withR<string> \"dimensionsNameR\"  server cube <| fun servAd cubeN -> c.TableDimensionsName (servAd, cubeN, i)\n        let putValueExR      server cube v elems   = withR<bool  > \"putValueExR\"      server cube <| fun servAd cubeN -> l.DataPutValueEx (servAd, cubeN, v, elems)\n        let dimensionsR      server cube           = result {\n                                                        let! n    = dimensionsCountR server cube\n                                                        let! dims = seq [1..n]\n                                                                    |> Result.Seq.traverseM(dimensionsNameR server cube)\n                                                        return dims |> Seq.map Dimension |> Seq.toArray\n                                                     } \n        let bulkTransferBeginR  lType              = l.BulkTransferBegin(lType)             |> callR<bool> (sprintf \"Cube.bulkTransferBeginR: %s\")\n        let bulkTransferCommitR lType stop log     = l.BulkTransferCommit(lType, stop, log) |> callR<bool> (sprintf \"Cube.bulkTransferCommitR: %s\")\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7dd7ed3e-d73a-46e5-b4d3-fc1414536571"}, "snpName": "xxxMonadicAlea", "snpContent": "module AleaN =\n    open Alea\n    \n    type   ServerN<'T>           = ServerN   of (Server -> Result<'T>)\n    module ServerN =        \n        let address              = ServerN   (Server.address >> Result.succeed)\n        let connectR             = ServerN   Server.connectR\n        let disconnectR          = ServerN   Server.disconnectR\n        \n        let inline rtn a                                   = ServerN(fun _ -> Result.succeed a)\n        let inline rtnR a                                  = ServerN(fun _ ->                a)\n        let inline getResult                   (ServerN a) = ServerN(fun s -> a s |> Result.succeed )\n        let inline bind (f: 'a -> ServerN<'b>) (ServerN a) = ServerN(fun s -> a s |> Result.bind (f >> function ServerN b -> b s) )\n        let inline map f m                                 = bind (f >> rtn) m\n        let inline bindR  f                    (ServerN a) = ServerN(fun s -> a s |> Result.bind f)\n        let inline combine a b                             = a |> bind (fun _ -> b)\n        let mutable private servers = Set []\n        let        run server                  (ServerN m) = result {\n            if servers |> Set.contains server |> not then\n                let! r_  = Server.connectR    server\n                servers <- servers |> Set.add server\n            let! res = m                  server\n            return res\n        }\n        let         disconnectServer server =  result {\n            if servers |> Set.contains server then\n                 servers <- servers |> Set.remove server\n                 let! res = Server.disconnectR server\n                 return res\n            else return false\n        }\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n        \n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n                        \n                        \n    type   ElementN<'T>          = ElementN   of (Server -> Dimension -> Element-> Result<'T>)\n    module ElementN =         \n        let name                 = ElementN   (fun s d e -> Element.name               e |> Result.succeed)\n        let childrenCountR       = ElementN   (fun s d e -> Element.childrenCountR s d e)\n        let childrenNameR     i  = ElementN   (fun s d e -> Element.childrenNameR  s d e i)\n        let childrenR            = ElementN   (fun s d e -> Element.childrenR      s d e)\n                                              \n    type   HandleN<   'T>                                  = HandleN    of (Handle -> Result<'T>)\n    module HandleN                                         =\n        let inline rtn a                                   = HandleN(fun _ -> Result.succeed a)\n        let inline rtnR a                                  = HandleN(fun _ ->                a)\n        let inline bind (f: 'a -> HandleN<'b>) (HandleN a) = HandleN(fun h -> a h |> Result.bind (f >> function HandleN b -> b h) )\n        let inline map f m                                 = bind (f >> rtn) m\n        let inline combine a b                             = a |> bind (fun _ -> b)\n        let inline run closer handle (HandleN m)           = m handle |> Result.bind (fun _ -> closer handle)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n        \n    type   DimensionN<'T>                           = DimensionN of (Server -> Dimension -> Result<'T>)\n    module DimensionN                               = \n        let name                                    = DimensionN (fun s d -> Dimension.name                   d |> Result.succeed)\n        let import                  df ef del desc  = DimensionN (fun s d -> Dimension.import               s d          df ef del desc )\n        let editBeginR              clear desc      = DimensionN (fun s d -> Dimension.editBeginR           s d          clear desc     )\n        let addElementR    eType elem parent weight = DimensionN (fun s d -> Dimension.addElementR          s d eType elem parent weight)\n        let editCommitR    commit                   = DimensionN (fun s d -> Dimension.editCommitR          s d commit                  )\n        let elementsCountR                          = DimensionN (fun s d -> Dimension.elementsCountR       s d                         )\n        let elementsNameR  i                        = DimensionN (fun s d -> Dimension.elementsNameR        s d i                       )\n        let topElements                             = DimensionN (fun s d -> Dimension.topElements          s d                         )\n        let elementsR                               = DimensionN (fun s d -> Dimension.elementsR            s d                         )\n        let inputsR                                 = DimensionN (fun s d -> Dimension.inputsR              s d                         )\n        let attTableDeleteR          nT             = DimensionN (fun s d -> Dimension.attTableDeleteR      s d nT                      )\n        let attTableCreateBeginR     nT             = DimensionN (fun s d -> Dimension.attTableCreateBeginR s d nT                      )\n        let createCommitR                           =                        Dimension.createCommitR\n        let getInfoDescR                 fld        = DimensionN (fun s d -> Field.getInfoDescR             s d fld                     )\n        let getInfoAtypR                 fld        = DimensionN (fun s d -> Field.getInfoAtypR             s d fld                     )\n        let getInfoLengthR               fld        = DimensionN (fun s d -> Field.getInfoLengthR           s d fld                     )\n        let getInfoDecimalR              fld        = DimensionN (fun s d -> Field.getInfoDecimalR          s d fld                     )\n        let putValueR                    fld v elem = DimensionN (fun s d -> Field.putValueR                s d fld v elem              )\n\n        let  rtn  a                                        = DimensionN(fun _ _ -> Result.succeed a)\n        let  rtnR a                                        = DimensionN(fun _ _ ->                a)\n        let  getResult                      (DimensionN a) = DimensionN(fun s d -> a s d |> Result.succeed )\n        let  bind (f: 'a -> DimensionN<'b>) (DimensionN a) = DimensionN(fun s d -> a s d |> Result.bind (f >> function DimensionN b -> b s d) )\n        let  map f m                                       = bind (f >> rtn) m\n        let  bindR  f                       (DimensionN a) = DimensionN(fun s d -> a s d |> Result.bind f)\n        let  combine a b                                   = a |> bind (fun _ -> b)\n        let  run server dim                 (DimensionN m) = m server dim\n        let  runM dim m                                    = ServerN (fun s -> run s dim m)\n        let rec traverseM f list =\n            let (>>=) v f = bind f v\n            let retn      = rtn\n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        let inline sequenceM x = traverseM id x\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   FieldN<'T>                           = FieldN of (Server -> Dimension -> Field -> Result<'T>)\n    module FieldN                               = \n        let fieldAddR              = FieldN  (fun s d fld-> HandleN (fun h -> Dimension.fieldAddR h fld ) |> Result.succeed )\n        let getInfoDescR           = FieldN  (fun s d fld-> Field.getInfoDescR             s d fld        )\n        let getInfoAtypR           = FieldN  (fun s d fld-> Field.getInfoAtypR             s d fld        )\n        let getInfoLengthR         = FieldN  (fun s d fld-> Field.getInfoLengthR           s d fld        )\n        let getInfoDecimalR        = FieldN  (fun s d fld-> Field.getInfoDecimalR          s d fld        )\n        let putValueR       v elem = FieldN  (fun s d fld-> Field.putValueR                s d fld v elem )\n\n        let  rtn  a                                = FieldN(fun _ _ _ -> Result.succeed a)\n        let  rtnR a                                = FieldN(fun _ _ _ ->                a)\n        let  getResult                  (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.succeed )\n        let  bind (f: 'a -> FieldN<'b>) (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.bind (f >> function FieldN b -> b s d fl) )\n        let  map f m                               = bind (f >> rtn) m\n        let  bindR  f                   (FieldN a) = FieldN(fun s d fl -> a s d fl |> Result.bind f)\n        let  combine a b                           = a |> bind (fun _ -> b)\n        let  run server dim fld         (FieldN m) = m server dim fld\n        let  runD fld m                            = DimensionN (fun s dim -> run s dim fld m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n    type   CubeN<'T>                 = CubeN of (Server -> Cube -> Result<'T>)\n    module CubeN                     = \n        let name                     = CubeN(fun s c -> Cube.name               c |> Result.succeed )  \n        let exists                   = CubeN(fun s c -> Cube.exists           s c |> Result.succeed )  \n        let create           ds      = CubeN(fun s c -> Cube.create           s c ds     )  \n        let delete                   = CubeN(fun s c -> Cube.delete           s c        )  \n        let putRulesForcedR  xml     = CubeN(fun s c -> Cube.putRulesForcedR  s c xml    )  \n        let setMeasure       dim     = CubeN(fun s c -> Cube.setMeasure       s c dim    )  \n        let dimensionsCountR         = CubeN(fun s c -> Cube.dimensionsCountR s c        )  \n        let dimensionsNameR  i       = CubeN(fun s c -> Cube.dimensionsNameR  s c i      )  \n        let putValueExR      v elems = CubeN(fun s c -> Cube.putValueExR      s c v elems)  \n        let dimensionsR              = CubeN(fun s c -> Cube.dimensionsR      s c        )  \n\n        let inline rtn  a                              = CubeN(fun _ _ -> Result.succeed a)\n        let inline rtnR a                              = CubeN(fun _ _ ->                a)\n        let inline getResult                 (CubeN a) = CubeN(fun s d -> a s d |> Result.succeed )\n        let inline bind (f: 'a -> CubeN<'b>) (CubeN a) = CubeN(fun s d -> a s d |> Result.bind (f >> function CubeN b -> b s d) )\n        let inline map f m                             = bind (f >> rtn) m\n        let inline bindR  f                  (CubeN a) = CubeN(fun s d -> a s d |> Result.bind f)\n        let inline combine a b                         = a |> bind (fun _ -> b)\n        let inline run server cube           (CubeN m) = m server cube\n        let inline runM cube m                         = ServerN (fun s -> run s cube m)\n\n        type Builder() =\n            member inline this.Return      x                        = rtn x\n            member inline this.ReturnFrom  x                        = x\n            member inline this.Bind       (w , r )                  = bind r w\n            member inline this.Bind       (w , r )                  = bind r (rtnR w)\n            member inline this.Zero       ()                        = rtn ()\n            member inline this.Delay       f                        = f\n            member inline this.Combine    (a, b)                    = combine a b\n            member inline this.Run         f                        = f()\n            member this.While(guard, body) =\n                let rec whileLoop guard body =\n                    if guard() then body() |> bind (fun () -> whileLoop guard body)\n                    else rtn   ()\n                whileLoop guard body\n            member this.TryWith(body, handler) =\n                try this.ReturnFrom(body())\n                with e -> handler e\n            member this.TryFinally(body, compensation) =\n                try this.ReturnFrom(body())\n                finally compensation()\n            member this.Using(disposable:#System.IDisposable, body) =\n                let body' = fun () -> body disposable\n                this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n            member this.For(sequence:seq<_>, body) =\n                this.Using(sequence.GetEnumerator(),fun enum -> \n                    this.While(enum.MoveNext, \n                        this.Delay(fun () -> body enum.Current)))              \n\n\n    let dimensionN = DimensionN.Builder()\n    let cubeN      = CubeN     .Builder()\n    let serverN    = ServerN   .Builder()\n    let fieldN     = FieldN    .Builder()\n    let handleN    = HandleN   .Builder()\n\n", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"19f52d97-7978-4a6e-9fca-fd872eeb5eaf"}, {"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"637217cf-d9b8-4bef-9774-a28412f1e944"}, "snpName": "xxxSampleFormulas", "snpContent": "#r \"Compiled/CalculationModelDll/CalculationModelDll.dll\"\nopen System\nopen FSSGlobal.CalculationModel\nmodule SampleFormulas =\n    open CalculationModel\n    open InitModel\n    open CalculationSyntax\n    \n    setInitModel {\n        modId           = ModId <| Guid.NewGuid()\n        server          = @\"LOCAL\\CipherSpace\"\n        modCubes        = [| |]\n        modDims         = [| |]\n        modCalculations = [| |]\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    let TCalc                = newDim \"TCalc\"      DtTCalc    \"\"\n    let DataType             = newDim \"DataType\"   DtDataType \"\"\n    let Version              = newDim \"Version\"    DtVersion  \"\"\n    let Year                 = newDim \"Year\"       DtTime     \"\"\n    let Price                = newDim \"Price\"      DtOther    \"PR\"     \n    let Brand                = newDim \"Brand\"      DtOther    \"BR\"     \n    let Product              = newDim \"Product\"    DtOther    \"PD\"     \n    let Season               = newDim \"Season\"     DtOther    \"SE\"     \n    let CostCenter           = newDim \"CostCenter\" DtOther    \"CC\"     \n    let Account              = newDim \"Account\"    DtOther    \"AC\"     \n     \n    addDims()\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    let comb1                = [ Version; DataType; Price; Brand; Product; Season; CostCenter; Account ]\n  \n    let Sales_by_Brand                           = newCalc Input \"Sales_by_Brand                           \" \"AA\" comb1\n    let FP_vs_MD_Perc                            = newCalc Input \"FP_vs_MD_Perc                            \" \"AB\" comb1\n    let Sales_by_Brand_Price                     = newCalc  Calc \"Sales_by_Brand_Price                     \" \"AC\" comb1\n    let Gross_Perc                               = newCalc Input \"Gross_Perc                               \" \"AD\" comb1\n    let Gross_Sales_by_Brand_Price               = newCalc  Calc \"Gross_Sales_by_Brand_Price               \" \"AE\" comb1\n    let Seasonal_Allocation                      = newCalc Input \"Seasonal_Allocation                      \" \"AF\" comb1\n    let Seasonal_Allocation_2                    = newCalc  Calc \"Seasonal_Allocation_2                    \" \"AG\" comb1\n    let Seasonal_Allocation_Outlet               = newCalc Input \"Seasonal_Allocation_Outlet               \" \"AH\" comb1\n    let Discount                                 = newCalc Input \"Discount                                 \" \"AI\" comb1\n    let Sales_by_Season                          = newCalc  Calc \"Sales_by_Season                          \" \"AJ\" comb1\n    let Net_Sales_by_Season                      = newCalc  Calc \"Net_Sales_by_Season                      \" \"AK\" comb1\n    let Markup                                   = newCalc  Calc \"Markup                                   \" \"AL\" comb1\n    let Seasonal_Cost_Factor                     = newCalc Input \"Seasonal_Cost_Factor                     \" \"AM\" comb1\n    let COGS                                     = newCalc  Calc \"COGS                                     \" \"AN\" comb1\n    let Inventory_Beginning                      = newCalc  Calc \"Inventory_Beginning                      \" \"AO\" comb1\n    let Average_Price                            = newCalc Input \"Average_Price                            \" \"AP\" comb1\n    let Inventory_Beginning_Quantity             = newCalc  Calc \"Inventory_Beginning_Quantity             \" \"AQ\" comb1\n    let Inventory_Transfer_IN                    = newCalc  Calc \"Inventory_Transfer_IN                    \" \"AR\" comb1\n    let Purchases                                = newCalc  Calc \"Purchases                                \" \"AS\" comb1\n    let Inventory_Transfer_OUT                   = newCalc  Calc \"Inventory_Transfer_OUT                   \" \"AT\" comb1\n    let Sell_Through                             = newCalc Input \"Sell_Through                             \" \"AU\" comb1\n    let Purchases_Timing_Perc                    = newCalc Input \"Purchases_Timing_Perc                    \" \"AV\" comb1\n    let Total_Stock                              = newCalc  Calc \"Total_Stock                              \" \"AW\" comb1\n    let Inventory_Ending                         = newCalc  Calc \"Inventory_Ending                         \" \"AX\" comb1\n    let VAT_Rate_Sales_Tax                       = newCalc Input \"VAT_Rate_Sales_Tax                       \" \"AY\" comb1\n    let Selling_Squared_meters                   = newCalc Input \"Selling_Squared_meters                   \" \"AZ\" comb1\n    let Net_Squared_meters                       = newCalc Input \"Net_Squared_meters                       \" \"BA\" comb1\n    let Gross_Squared_Meters                     = newCalc Input \"Gross_Squared_Meters                     \" \"BB\" comb1\n    let CAPEX                                    = newCalc Input \"CAPEX                                    \" \"BC\" comb1\n    let CASHOUT                                  = newCalc Input \"CASHOUT                                  \" \"BD\" comb1\n    let Landed_Factor_Custom_Duties              = newCalc Input \"Landed_Factor_Custom_Duties              \" \"BE\" comb1\n    let Landed_Factor_Insurance                  = newCalc Input \"Landed_Factor_Insurance                  \" \"BF\" comb1\n    let Landed_Factor_Freight                    = newCalc Input \"Landed_Factor_Freight                    \" \"BG\" comb1\n    let Net_Sales_Stockist                       = newCalc Input \"Net_Sales_Stockist                       \" \"BH\" comb1\n    let Net_Sales_Inter_Company                  = newCalc Input \"Net_Sales_Inter_Company                  \" \"BI\" comb1\n    let PercNet_Sales_Full_Price                 = newCalc  Calc \"PercNet_Sales_Full_Price                 \" \"BJ\" comb1\n    let PercNet_Sales_Markdown                   = newCalc  Calc \"PercNet_Sales_Markdown                   \" \"BK\" comb1\n    let PercNet_Sales_Stockist                   = newCalc  Calc \"PercNet_Sales_Stockist                   \" \"BL\" comb1\n    let PercNet_Sales_InterCompany               = newCalc  Calc \"PercNet_Sales_InterCompany               \" \"BM\" comb1\n    let Average_Sales_Price_Full_Price           = newCalc Input \"Average_Sales_Price_Full_Price           \" \"BN\" comb1\n    let Average_Sales_Price_Markdown             = newCalc Input \"Average_Sales_Price_Markdown             \" \"BO\" comb1\n    let Average_Sales_Price_Stockist             = newCalc Input \"Average_Sales_Price_Stockist             \" \"BP\" comb1\n    let Average_Sales_Price_Intercompany         = newCalc Input \"Average_Sales_Price_Intercompany         \" \"BQ\" comb1\n    let Mark_Up_Boutique                         = newCalc  Calc \"Mark_Up_Boutique                         \" \"BR\" comb1\n    let Mark_Up_Outlet                           = newCalc  Calc \"Mark_Up_Outlet                           \" \"BS\" comb1\n    let Custom_Duties_Beginning_Inventory        = newCalc Input \"Custom_Duties_Beginning_Inventory        \" \"BT\" comb1\n    let Freight_Beginning_Inventory              = newCalc Input \"Freight_Beginning_Inventory              \" \"BU\" comb1\n    let Insurance_Beginning_Inventory            = newCalc Input \"Insurance_Beginning_Inventory            \" \"BV\" comb1\n    let Index_Perc                               = newCalc Input \"Index_Perc                               \" \"BW\" comb1\n    let Depreciation_IC_Initial_Provision        = newCalc Input \"Depreciation_IC_Initial_Provision        \" \"BX\" comb1\n    let Depreciation_IC_Final_Provision          = newCalc Input \"Depreciation_IC_Final_Provision          \" \"BY\" comb1\n    let Depreciation_TP_Initial_Provision        = newCalc Input \"Depreciation_TP_Initial_Provision        \" \"BZ\" comb1\n    let Depreciation_TP_Final_Provision          = newCalc Input \"Depreciation_TP_Final_Provision          \" \"BA\" comb1\n    let Depreciation_IC_Initial_Provision_Factor = newCalc  Calc \"Depreciation_IC_Initial_Provision_Factor \" \"BB\" comb1\n    let Depreciation_IC_Final_Provision_Factor   = newCalc  Calc \"Depreciation_IC_Final_Provision_Factor   \" \"BC\" comb1\n    let Depreciation_TP_Initial_Provision_Factor = newCalc  Calc \"Depreciation_TP_Initial_Provision_Factor \" \"BD\" comb1\n    let Depreciation_TP_Final_Provision_Factor   = newCalc  Calc \"Depreciation_TP_Final_Provision_Factor   \" \"BE\" comb1\n    let Depreciation_Beginning                   = newCalc  Calc \"Depreciation_Beginning                   \" \"BF\" comb1\n    let Depreciation_Ending                      = newCalc  Calc \"Depreciation_Ending                      \" \"BG\" comb1\n    let Depreciation_Change                      = newCalc  Calc \"Depreciation_Change                      \" \"BH\" comb1\n    let AMOUNT                                   = newCalc  Calc \"AMOUNT                                   \" \"BI\" comb1\n\n    addCalcs()\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    let Value                    = DataType?Value\n    let For_NoSeasonal           = [ Season?(\"21\")     ; Value ]\n    let For_FallWinterM1         = [ Season?(\"07\")     ; Value ]\n    let For_SeasonCarryOver      = [ Season?(\"19\")     ; Value ]\n    let For_NoSeasonalThirdParty =   Brand?( \"06\") :: For_NoSeasonal\n    \n    let isOutlet                  = SUBST(!CostCenter, 2, 1) &= \"O\"\n    let isThirdParty              = DE_ISCHILD(Product, \"TP\", !Product)\n    let isFallWinterM1            = !Season &= \"07\"\n    let isSeasonCarryOver         = !Season &= \"19\"\n    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    let inline  newForm a b c d = newForm a b c d \"\" \"\"\n    \n    newForm Sales_by_Brand_Price                     ForBase         <| Sales_by_Brand * FP_vs_MD_Perc                               <| []\n    newForm FP_vs_MD_Perc                            ForBase         <| 1 - FP_vs_MD_Perc.For[ Price?Full_Price ]                    <| [ Price?Mark_Down ; Value ]\n    newForm FP_vs_MD_Perc                            ForBase         <| Sales_by_Brand_Price / Sales_by_Brand                        <| []                                                             \n    newForm Gross_Sales_by_Brand_Price               ForBase         <| Sales_by_Brand_Price / (1 - Gross_Perc)                      <| [] \n    newForm Seasonal_Allocation                      ForBase         <| 1                                                            <| For_NoSeasonalThirdParty\n    newForm Seasonal_Allocation                      ForBase         <| 1 - Seasonal_Allocation.For[ Season?Seasons ]                <| For_SeasonCarryOver     \n    newForm Seasonal_Allocation_2                    ForBase         <| 1                                                            <| For_NoSeasonalThirdParty      \n    newForm Seasonal_Allocation_2                    ForBase         <| 0.5                                                          <| For_FallWinterM1                                                 \n    newForm Seasonal_Allocation_2                    ForBase         <| 0.5                                                          <| For_SeasonCarryOver                                         \n    newForm Seasonal_Allocation_2                    ForBase         <| 0                                                            <| []                                                                                                                           \n    newForm Seasonal_Allocation_2                    ForBase         <| IF(isFallWinterM1 || isSeasonCarryOver, 0.5, 0)              <| []\n    newForm Seasonal_Allocation_Outlet               ForBase         <| 1 - Seasonal_Allocation_Outlet.For[ Season?Seasons2 ]        <| For_NoSeasonal\n    newForm Sales_by_Season                          ForBase         <| Sales_by_Brand_Price    \n                                                                          * IF( isOutlet                                           \n                                                                              , Seasonal_Allocation_Outlet                                           \n                                                                              , IF(!CostCenter &= \"RBUS19\"                                           \n                                                                                || !CostCenter &= \"RBUS20\"                                           \n                                                                                || !CostCenter &= \"RBUS42\"                                           \n                                                                                || !CostCenter &= \"RBUS41\"                                          \n                                                                                  , Seasonal_Allocation_2                                          \n                                                                                  , Seasonal_Allocation                                          \n                                                                              )                                           \n                                                                           )                                                         <| []\n    newForm Discount                                 ForConsolidated <| 1 - Sales_by_Season / Net_Sales_by_Season                    <| []\n    newForm Net_Sales_by_Season                      ForBase         <|  Sales_by_Season / (1 - Discount)                            <| []                                                                  \n    newForm Markup                                   ForBase         <| IF (isOutlet, 1.25, 2.5)                                     <| [ Value ] \n    newForm Markup                                   ForConsolidated <| Net_Sales_by_Season / COGS   * Seasonal_Cost_Factor          <| []\n    newForm COGS                                     ForBase         <| Net_Sales_by_Season / Markup * Seasonal_Cost_Factor          <| []\n    newForm Inventory_Beginning                      ForBase         <| IF( isOutlet                                           \n                                                                          , NA                                          \n                                                                          , COGS \n                                                                            * (Inventory_Transfer_IN.For[ CostCenter?Outlets ]                                          \n                                                                               /  COGS.For[ CostCenter?Boutiques ]                                          \n                                                                               +  COGS.For[ CostCenter?Boutiques ] ) )               <| For_FallWinterM1\n    newForm Inventory_Beginning                      ForBase         <| IF (isOutlet, COGS, COGS / 0.47 * 0.55)                      <| []                                                                                                                                \n    newForm Inventory_Beginning_Quantity             ForBase         <| Inventory_Beginning / (Average_Price * Seasonal_Cost_Factor) <| []\n    newForm Inventory_Transfer_IN                    ForBase         <| COGS                                                         <| [ CostCenter?ROUS08 ]\n    newForm Inventory_Transfer_IN                    ForBase         <| IF( isOutlet, COGS / 0.35, NA)                               <| For_FallWinterM1 \n    newForm Inventory_Transfer_IN                    ForBase         <| IF( isOutlet                                           \n                                                                          , Inventory_Transfer_OUT.For[ CostCenter?Boutiques ]               \n                                                                            * Sales_by_Brand / Sales_by_Brand.For[ CostCenter?Outlets ]               \n                                                                          , NA)                                                                                                       <| []\n    newForm Purchases                                ForBase         <| COGS * Purchases_Timing_Perc / Sell_Through                                                                      <| []\n    newForm Inventory_Transfer_OUT                   ForBase         <| IF( isOutlet, NA, Inventory_Beginning + Purchases - COGS)                                                        <| []\n    newForm Total_Stock                              ForBase         <| Inventory_Beginning + Inventory_Transfer_IN - Inventory_Transfer_OUT + Purchases                                 <| []\n    newForm Inventory_Ending                         ForBase         <| Total_Stock - COGS                                                                                               <| []\n    newForm Mark_Up_Boutique                         ForBase         <| IF(isOutlet, NA    , Markup)                                                                                     <| []\n    newForm Mark_Up_Outlet                           ForBase         <| IF(isOutlet, Markup, NA    )                                                                                     <| []\n    newForm Depreciation_IC_Initial_Provision_Factor ForBase         <| IF(Depreciation_IC_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Initial_Provision) / Index_Perc) ) <| []\n    newForm Depreciation_IC_Final_Provision_Factor   ForBase         <| IF(Depreciation_IC_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_IC_Final_Provision  ) / Index_Perc) ) <| []\n    newForm Depreciation_TP_Initial_Provision_Factor ForBase         <| IF(Depreciation_TP_Initial_Provision <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Initial_Provision) / Index_Perc) ) <| []\n    newForm Depreciation_TP_Final_Provision_Factor   ForBase         <| IF(Depreciation_TP_Final_Provision   <= 0, 0, MAX(0, 1 - (1 - Depreciation_TP_Final_Provision  ) / Index_Perc) ) <| []\n    newForm Depreciation_Beginning                   ForBase         <| IF(isOutlet,              \n                                                                             IF( isThirdParty              \n                                                                              , Depreciation_TP_Initial_Provision_Factor              \n                                                                              , Depreciation_IC_Initial_Provision_Factor)              \n                                                                            * Inventory_Beginning              \n                                                                        , 0)                                                               <| []\n    newForm Depreciation_Ending                      ForBase         <| IF(isOutlet,              \n                                                                            IF( isThirdParty              \n                                                                              , Depreciation_TP_Final_Provision_Factor              \n                                                                              , Depreciation_IC_Final_Provision_Factor)              \n                                                                            * Inventory_Ending              \n                                                                        , 0)                                                               <| []\n    newForm Depreciation_Change                      ForBase         <| Depreciation_Beginning - Depreciation_Ending                       <| []\n    newForm AMOUNT                                   ForBase         <| Net_Sales_by_Season.For[ Price?Full_Price ; Product?All_Products ] <| [ Account?(\"BDG.002.02.FPR\") ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Net_Sales_by_Season.For[ Price?Mark_Down  ; Product?All_Products ] <| [ Account?(\"BDG.002.02.MKD\") ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Purchases_Timing_Perc                                              <| [ Account?(\"BDG.005.04\"    ) ; Product   ?ND ]\n    newForm AMOUNT                                   ForBase         <| Markup                                                             <| [ Account?(\"BDG.011.EC\"    ) ; CostCenter?ND ]\n    newForm AMOUNT                                   ForBase         <| IF( isOutlet, NA,  Markup)                                         <| [ Account?(\"BDG.011.W\"     ) ; CostCenter?ND ]\n\n    addFrms()\n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"303fbc46-6f96-4fb9-942f-02370a80f627"}, "snpName": "xxxFormula & Calculation Rules", "snpContent": "//open Useful\n\nmodule CalcRules =\n    let eq  = (=)\n    let And = (&&)\n    let (&) = (+)\n    open CalculationModel\n    open CalculationSyntax\n    open Useful\n    \n    let cubeActualRule          versionDim      = Rule.newRule [ versionDim?Actual   ]  ExtStet        ForBase \"B\"\n    let cubeActualRuleO       model             = Model.versionDimO model |> Option.map cubeActualRule\n    let cubeFormulaRule  txt _meaDim dataTypeDim _versionDim _timeDim = Rule.newRule [ dataTypeDim?Formula ] (ExtString txt) ForBase \"G1\"\n    let cubeInputRule                           = cubeFormulaRule \"<Input>\"\n    let cubeConsolidationRule                   = cubeFormulaRule \"<Consolidation>\"\n    let isFormulaText           dataTypeDim frm = Formula.getDimDest dataTypeDim frm |> Option.map (eq dataTypeDim?Formula) |> Option.defaultValue false\n    let isActual                versionDim  frm = Formula.getDimDest versionDim  frm |> Option.map (eq versionDim?Actual  ) |> Option.defaultValue false\n    let formulaRule (model: Model) (calc: Calculation) (cube:Cube) frm =\n        Model.withDimsO model cube <| fun _meaDim dataTypeDim versionDim _timeDim ->\n            Calculation.getElemRefO model calc \n            |> Option.map (fun ref -> \n                ref ::\n                if Cube.containsDim dataTypeDim.dimId cube then\n                    let  dataTypeDest = Formula.getDimDest dataTypeDim frm\n                    if   dataTypeDest.IsNone \n                    then dataTypeDim?Calculated_Value :: frm.forDestination\n                    else frm.forDestination\n                else     frm.forDestination\n            )\n            |> Option.map (fun dest -> Rule.newRule dest frm.forExpression frm.forType ((if isFormulaText dataTypeDim frm then \"E\" elif isActual versionDim frm then  \"A\" else \"M\") & calc.calOrder & frm.forOrder) )\n    let formulaTextRule (model: Model) (calc: Calculation) (cube:Cube) frm =\n        Model.withDimsO model cube <| fun _meaDim dataTypeDim _versionDim _timeDim ->\n            if not <| Cube.containsDim dataTypeDim.dimId cube then None else\n            let dataTypeDest = Formula.getDimDest dataTypeDim frm\n            if  dataTypeDest.IsSome then None else\n            Calculation.getElemRefO model calc\n            |> Option.map (fun ref -> Rule.newRule (dataTypeDim?Formula :: ref :: frm.forDestination) (ExtString frm.forText) frm.forType (\"F\" & calc.calOrder & frm.forOrder) )\n    let calculationRule (model: Model) (cube:Cube) calc =\n        Model.withDimsO model cube <| fun meaDim dataTypeDim versionDim timeDim ->\n            if not <| Cube.containsDim dataTypeDim.dimId cube then None else\n            let tCalcDimO        = Model.tCalcDimO     model\n            let freezeCubeO      = Model.freezeCubeO   model\n            let isActualCalcO    = Model.isActualCalcO model\n            let calculatedValue  = Cube.forElr [ dataTypeDim?Calculated_Value                ] cube\n            let manualAdjustment = Cube.forElr [ dataTypeDim?Manual_Adjustment               ] cube\n            let frozenValue      = Cube.forElr [ dataTypeDim?Frozen_Value                    ] cube\n            let valueCalc        = Cube.forElr [ dataTypeDim?Value ; meaDim?(calc.calName)   ] cube\n            let useActual        = seq { \n                                     yield isActualCalcO.IsSome\n                                     yield Cube.containsDim versionDim.dimId cube\n                                     yield Cube.containsDim timeDim   .dimId cube\n                                   } |> Seq.contains false |> not\n            let body1            = if calc.isInput then \n                                       ExiStet  \n                                   else\n                                       if calc.isText then\n                                           IFa(manualAdjustment &= ExtNA, calculatedValue, manualAdjustment) \n                                       else\n                                           calculatedValue + manualAdjustment |> ExNumeric\n            let body2            = if freezeCubeO.IsSome |> And tCalcDimO.IsSome\n                                   then IFa(Cube.forElr[tCalcDimO.Value?(calc.calName)] freezeCubeO.Value = 1, frozenValue, body1)\n                                   else body1\n            let body3            = if   useActual \n                                   then IFa(isActualCalcO.Value = 1, Cube.forElr [ versionDim?ActualElem ] cube, body2)\n                                   else body2\n            //if eq body3 ExiStet then None else                      \n            Rule.newRule (valueCalc.sliDims |> Map.toList |> List.map snd) body3 ForBase (\"N\" & calc.calOrder)\n            |> Some\n    let formulaRules (model: Model) (calc: Calculation) frm =\n        Calculation.withCube model calc <| fun cube        -> \n            seq {\n                yield cube.cubId, (FormulaKey frm.forId), formulaRule     model calc cube frm\n                yield cube.cubId, (ForTextKey frm.forId), formulaTextRule model calc cube frm\n            }\n            |> Some\n        |> Option.defaultValue Seq.empty\n    let calcRules (model: Model) calc =\n        Calculation.withCube model calc <| fun cube        -> \n            seq {\n                yield cube.cubId, CalcRuleKey calc.calId, calculationRule model cube calc\n                for frm in calc.calFormulas do\n                    yield! formulaRules model calc frm\n            }\n            |> Some\n        |> Option.defaultValue Seq.empty\n    let cubeRules (model: Model) cube =\n        seq {\n            yield cube.cubId, ActualRuleKey      ,                model |>   cubeActualRuleO\n            yield cube.cubId, InputRuleKey       , Model.withDims model cube cubeInputRule\n            yield cube.cubId, ConsolidatedRuleKey, Model.withDims model cube cubeConsolidationRule\n        }\n    let modelRules model =\n        seq {\n            for cube in model.modCubes |> Seq.filter Cube.isCalcCube do yield! cubeRules model cube\n            for calc in model.modCalculations                        do yield! calcRules model calc\n        }        \n    let addModelRules model = model |> Model.addRules (modelRules model)\n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"4f4d9d79-09fe-4df1-8af2-0ba6a4fffa2c"}, {"SnippetId" :"90cfafb9-9397-4dda-940b-8e33c4412d1c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7817de82-c2b4-4fa9-b768-6e3251334b5c"}, "snpName": "xxxTest", "snpContent": "#I @\"D:\\Program Files (x86)\\Infor\\BI\\OLAP\\bin\"\n#r @\"Compiled\\Alea\\Interop.MdsAut.dll\"\n#define FSI32BIT\n\nmodule Test =\n    open CalculationModel\n    open FSSGlobal.Useful\n    \n    \n    let printRules model =\n        model.modCubes\n        |> Seq.collect (fun  cub       -> cub.cubRules |> Seq   .map (fun rkv -> rkv, cub.cubId))\n        |> Seq.choose  (fun (rkv, cid) -> rkv.Value    |> Option.map (fun rul -> rul, cid      ))\n        |> Seq.sortBy  (fst >> (fun r -> r.rulOrder))        \n        |> Seq.map     (fun (rul, cid) -> rul.rulOrder, RuleText.aleaRule model cid rul)\n        |> Seq.iter    (printfn \"%A\")\n    //printRules ()\n\n    \n    //printfn \"%A\" model\n    \n    InitModel.initModel\n    |> Model.prepareModel \n    |> CalcRules.addModelRules\n    |> printRules\n    //|> WriteRules.createCubesR\n    //|> Result.getMsgs |> Seq.iter (printfn \"%A\")\n    ", "snpParentIdO": {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, "snpPredIds": [{"SnippetId" :"637217cf-d9b8-4bef-9774-a28412f1e944"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpName": "Tests", "snpContent": "#r @\"..\\packages\\Unquote\\lib\\net45\\Unquote.dll\"\nmodule Tests =", "snpParentIdO": {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"}, "snpName": "Tap Runner", "snpContent": "#r @\"..\\packages\\NUnit\\lib\\nunit.framework.dll\"\n/// Test Anything Protocol (TAP) NUnit runner by Phillip Trelford\nmodule Tap =\n\n    open System\n    open System.Collections\n    open System.Reflection\n    open NUnit.Framework\n    \n    type Args = obj[]\n    type ExpectedResult = obj option\n    type ExpectedException = Type option\n    type Timeout = int option\n    type Test = Test of MethodInfo * Args * ExpectedResult * ExpectedException * Timeout\n    \n    let internal getCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (mi:MethodInfo) = \n       mi.GetCustomAttribute(typeof<'TAttribute>, true) :?> 'TAttribute\n    \n    module internal SourceData =\n    \n       let (|SourceProperty|_|) (name,t:Type) =\n          let pi = t.GetProperty(name)\n          if pi <> null then Some(pi.GetGetMethod()) else None\n    \n       let (|SourceMethod|_|) (name,t:Type) =\n          let mi = t.GetMethod(name)\n          if mi <> null then Some(mi) else None\n    \n       let getSourceData (instance:obj, instanceType) (sourceName,sourceType:Type) =\n          match (sourceName,sourceType) with\n          | SourceProperty mi | SourceMethod mi->\n             let instance = \n                if instanceType <> sourceType \n                then Activator.CreateInstance(sourceType) \n                else instance\n             let result = mi.Invoke(instance, [||]) \n             result :?> IEnumerable\n          | _ -> invalidOp \"Expecting property or method\"\n    \n    module internal ParameterData =\n    \n       open SourceData\n    \n       module internal List =\n          let rec combinations = function\n          | [] -> [[]]\n          | hs :: tss ->\n             [for h in hs do\n                for ts in combinations tss ->\n                   h :: ts]\n    \n       let tryGetCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (pi:ParameterInfo) =\n          match pi.GetCustomAttribute(typeof<'TAttribute>, true) with\n          | :? 'TAttribute as attr -> Some attr\n          | _ -> None\n    \n       let (|Random|_|) = tryGetCustomAttribute<RandomAttribute>\n       let (|Range|_|) = tryGetCustomAttribute<RangeAttribute>\n       let (|Values|_|) = tryGetCustomAttribute<ValuesAttribute>\n       let (|ValueSource|_|) = tryGetCustomAttribute<ValueSourceAttribute>\n    \n       let getParameterData instance (pi:ParameterInfo) =\n          match pi with\n          | Random rand -> [for x in rand.GetData(pi) -> x]\n          | Range range -> [for x in range.GetData(pi) -> x]\n          | Values values -> [for x in values.GetData(pi) -> x]\n          | ValueSource source ->\n             let data = getSourceData instance (source.SourceName, source.SourceType)\n             [for x in data -> x]\n          | _ -> invalidOp \"Expecting values\"\n    \n    module internal TestGeneration =\n    \n       open SourceData\n       open ParameterData\n    \n       let (|Ignore|_|) (mi:MethodInfo) =\n          if getCustomAttribute<IgnoreAttribute>(mi) <> null then Some() else None\n    \n       let (|TestCases|_|) (mi:MethodInfo) =\n          let cases = mi.GetCustomAttributes(typeof<TestCaseAttribute>, true)\n          if cases.Length > 0 then Some(cases |> Seq.cast<TestCaseAttribute>)\n          else None\n    \n       let (|TestCaseSource|_|) (mi:MethodInfo) =\n          let source = getCustomAttribute<TestCaseSourceAttribute>(mi)\n          if source <> null then\n             let sourceType = \n                if source.SourceType <> null then source.SourceType else mi.DeclaringType\n             Some(source.SourceName, sourceType)\n          else None\n    \n       let (|VanillaTest|_|) (mi:MethodInfo) =\n          if getCustomAttribute<TestAttribute>(mi) <> null then Some() else None\n    \n       let tryGetExpectedException (mi:MethodInfo) =\n          let attr = getCustomAttribute<ExpectedExceptionAttribute>(mi)\n          if attr <> null then Some attr.ExpectedException else None\n    \n       let (|Timeout|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<TimeoutAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"Timeout\"] :?> int) else None\n    \n       let (|MaxTime|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<MaxTimeAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"MaxTime\"] :?> int) else None\n    \n       let tryGetTimeout = function Timeout ms | MaxTime ms -> Some ms | _ -> None\n      \n       let fromCases (mi:MethodInfo) (cases:TestCaseAttribute seq) =\n          let ex = tryGetExpectedException(mi)\n          let timeout = tryGetTimeout mi\n          [|for case in cases ->\n             let expected = if case.HasExpectedResult then Some case.ExpectedResult else None\n             let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n             Test(mi, case.Arguments, expected, ex, timeout)\n          |]\n    \n       let fromData instance (mi:MethodInfo) (data:IEnumerable) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [|for item in data ->\n             match item with\n             | :? TestCaseData as case ->\n                let expected = if case.HasExpectedResult then Some(case.Result) else None\n                let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n                Test(mi, case.Arguments, expected, ex, timeout) \n             | :? (obj[]) as args -> Test(mi, args, None, ex, timeout)\n             | arg -> Test(mi, [|arg|], None, ex, timeout)\n          |]\n    \n       let fromValues instance (mi:MethodInfo) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [| let ps = mi.GetParameters()\n             let argValues = [for pi in ps -> getParameterData instance pi]\n             match List.combinations argValues with\n             | [] -> yield Test(mi, [||], None, ex, timeout)\n             | xs -> yield! [for args in xs -> Test(mi, List.toArray args, None, ex, timeout)]\n          |]\n    \n       let generateTests instance (mi:MethodInfo) =\n          let instance = instance, mi.DeclaringType\n          match mi with\n          | Ignore -> [||]\n          | TestCases cases -> fromCases mi cases\n          | TestCaseSource source -> getSourceData instance source |> fromData instance mi\n          | VanillaTest -> fromValues instance mi\n          | _ -> [||]\n    \n    module internal TestRunner =\n    \n       let runTest instance (Test(mi,args,expected,exType,timeout)) = \n          try\n             let actual = \n                match timeout with\n                | Some ms -> Async.RunSynchronously(async { return mi.Invoke(instance,args) }, ms)\n                | None -> mi.Invoke(instance,args)\n             match expected with\n             | Some expected -> Assert.AreEqual(expected, actual)\n             | None -> ()\n             None\n          with ex ->        \n            match ex.InnerException with\n            | :? SuccessException -> None\n            | ex ->\n                match exType with         \n                | Some t when t = ex.GetType() -> None\n                | _ -> Some ex\n    \n       let color c =\n          let previous = Console.ForegroundColor\n          Console.ForegroundColor <- c\n          { new System.IDisposable with \n             member __.Dispose() = Console.ForegroundColor <- previous\n          }\n    \n       let showResult number (Test(mi,args,_,_,_)) error =\n          let name =\n             mi.Name + \n                if args.Length > 0 then \"(\" + String.Join(\",\", args) + \")\"\n                else \"\"\n          match error with\n          | None ->\n             using (color ConsoleColor.Green) <| fun _ ->\n                printfn \"ok %d - %s\" number name\n          | Some e ->\n             using (color ConsoleColor.Red) <| fun _ ->\n                printfn \"not ok %d - %s\" number name\n                printfn \"  %A\" e\n    \n       let runTests instance (setUp,tearDown) (tests:Test[]) =\n          printfn \"1..%d\" tests.Length\n          tests |> Array.iteri (fun i test ->\n             let result =\n                try setUp (); runTest instance test\n                finally tearDown ()\n             result |> showResult (i+1) test \n          )\n    \n    let Run (testType:Type) =\n       let constr = testType.GetConstructor([||])\n       let instance = if constr <> null then constr.Invoke([||]) else null\n       let methods = testType.GetMethods()\n       let tests = [|for mi in methods do yield! TestGeneration.generateTests instance mi|]\n      \n       let methodsWithAttribute attr =\n          methods |> Array.filter (fun mi -> mi.GetCustomAttribute(attr, true) <> null)\n    \n       let runMethods (methods:MethodInfo[]) = \n          methods |> Array.iter (fun mi -> mi.Invoke(instance,[||]) |> ignore)\n    \n       let setUps = methodsWithAttribute typeof<SetUpAttribute>\n       let tearDowns = methodsWithAttribute typeof<SetUpAttribute>\n       let setUp () = setUps |> runMethods\n       let tearDown () = tearDowns |> runMethods\n    \n       methodsWithAttribute typeof<TestFixtureSetUpAttribute> |> runMethods\n       TestRunner.runTests instance (setUp, tearDown) tests\n       methodsWithAttribute typeof<TestFixtureTearDownAttribute> |> runMethods", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}, "snpName": "Code for Testing", "snpContent": "open Useful\nopen NUnit.Framework\nopen Swensen.Unquote\n\nlet out, runStdOut =\n    let stdout = System.Text.StringBuilder()\n    (fun (s:string) -> stdout.Append s |> ignore)\n  , (fun f -> stdout.Clear() |> ignore\n              f()\n              stdout.ToString())\n\ntype Marker = interface end    \n\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"51ce1b75-40fe-4bf6-b5df-9eeae87f8506"}, "snpName": "not a test: SSH to android", "snpContent": "open Useful\nopen UsefulDotNet\nopen Garage\n\nlet mutable passwordO = Some \"spa3102\"\n\ntype Computer with\n    member this.sshClient    pwd        =\n       getClient    this.ip.Value (Option.defaultValue 22 this.sshPort) this.user.Value pwd\n    member this.sshClientRsa passphrase =\n       new Renci.SshNet.PrivateKeyFile(@\"D:\\Abelardo\\Documents\\MobaXterm\\home\\.ssh\\id_rsa\", passphrase)\n       |> getClientRsa this.ip.Value (Option.defaultValue 22 this.sshPort) this.user.Value\n\n[ doCmd (AbeRaspi      .sshClient    passwordO.Value)\n  doCmd (OldHtcComputer.sshClientRsa passwordO.Value)\n]\n|> Seq.iter (fun f -> f \"ps\")\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"555306ec-f8cc-455f-b01f-9d86fbb2682d"}, {"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b2f96f09-6749-4413-8f59-c542268369e2"}, "snpName": "not a test: syntactic issues (not a test)", "snpContent": "let name = \"world\"\nlet x = 2.0\nlet sqr x = x * x\nlet a = 3.0\nlet b = 4.0\n\nlet r = sin(x) + cos(x)\nlet c = sqr(a) + sqr(b)\nlet v = abs(r + c)\nprintfn \"Hello %s\"  name.Trim().ToUpper()\n\nlet r = (sin x) + (cos x)\nlet c = (sqr a) + (sqr b)\nlet v = (abs(r + c))\nprintfn \"Hello %s\" (name.Trim().ToUpper())\n\n\n\nlet f () = printf \"1\"; fun () -> printf \"2\"\n\nlet g () = printf \"g\"\n\n//then, rather bizarrely, the following \"two\" programs behave differently:\n\nf ()   (g ())   // evaluates to () printing out \"g12\"\nprintfn \"\"\n(f ()) (g ()) // evaluates to () printing out \"1g2\"\nprintfn \"\"\n\nlet x = \"Hello\"\nlet y = (1,2)\nlet msg = \"\"\n\n//x.Substring y\n//x.Substring 1 2\n\nlet  recipient = \"x\"\ntype Message = Message of string * string\ntype Error   = Error   of string * string\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Message(recipient, \"So Long\")\n| _       -> Message(recipient, \"\"       )\n\n//match msg with\n//| \"Hello\" -> Some Message(recipient, \"Hi\"     )\n//| \"Bye\"   -> Some Message(recipient, \"So Long\")\n//| _       -> None\n\nmatch msg with\n| \"Hello\" -> Some <| Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Some <| Message(recipient, \"So Long\")\n| _       -> None\n\nmatch msg with\n| \"Hello\" -> Some(Message(recipient, \"Hi\"     ))\n| \"Bye\"   -> Some(Message(recipient, \"So Long\"))\n| _       -> None\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     ) |> Some\n| \"Bye\"   -> Message(recipient, \"So Long\") |> Some\n| _       ->                                  None\n\n////////////////////////////\n\n//match msg with\n//| \"Hello\" -> Result.Ok    Message(recipient, \"Hi\"     )\n//| \"Bye\"   -> Result.Ok    Message(recipient, \"So Long\")\n//| _       -> Result.Error Error(\"unrecognized message\", msg)\n\nmatch msg with\n| \"Hello\" -> Result.Ok    <| Message(recipient, \"Hi\"     )\n| \"Bye\"   -> Result.Ok    <| Message(recipient, \"So Long\")\n| _       -> Result.Error <| Error(\"unrecognized message\", msg)\n\nmatch msg with\n| \"Hello\" -> Result.Ok   (Message(recipient, \"Hi\"     ))\n| \"Bye\"   -> Result.Ok   (Message(recipient, \"So Long\"))\n| _       -> Result.Error(Error(\"unrecognized message\", msg))\n\nmatch msg with\n| \"Hello\" -> Message(recipient, \"Hi\"     )      |> Result.Ok   \n| \"Bye\"   -> Message(recipient, \"So Long\")      |> Result.Ok   \n| _       -> Error(\"unrecognized message\", msg) |> Result.Error\n\nlet sqr n = n * n\n\n(fun x y -> x + y) (sqr 5)(7)\n|> printfn \"%d\"\n\nsqr (5)\nsqr(5)\n\n(2).ToString()\n|> printfn \"%A\"\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"71b30bbf-0f07-4f43-8376-de712a2697bf"}, "snpName": "wrap, result", "snpContent": "let wrapIf () =\n    wrap {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet asyncIf () =\n    async {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet resultIf () =\n    result {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello i =\n    printoutfn out \"before \"\n    wrap {\n        printoutfn out \"wrap \"\n        let! h =  async { printoutfn out \"Hello1 %d\" i } \n        return i + 1\n    }\n\nlet hellllo (i:int) =\n    wrap {\n        let! h = Some i\n        return h\n    }\n\nlet helllo i =\n    wrap {\n        let h = hello i\n        return! h\n    }\n\nlet helo i =\n    wrap {\n        do! wrap { return () }\n        return i\n    }\n\nlet whileR() = \n    let mutable i = 0\n    result {\n        let! a = Result.succeed 2\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsyncResult |> Async.RunSynchronously\n            i <- z\n            printoutfn out \" z = %d\" z\n    } |> ignore\n\nlet whileW() = \n    let mutable i = 0\n    wrap {\n        let! aR = async { return Result.succeed 2 }\n        let! a = aR\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            i <- z\n            printoutfn out \" z = %d\" z\n        return! WSome   ()\n    } |> Wrap.RunSynchronously\n\nlet whileWW() =\n    let mutable i = 0\n    let aAR = async { return Result.succeed 2 }\n    aAR |> WAsync |> Wrap.bind (fun aR ->\n        aR |> WResult |> Wrap.bind (fun a ->\n            let pred () = printoutfn out \"<%d>\" i ; i <= a \n            let body = fun () ->\n                printoutfn out \"%d: \" i\n                let zW = hello i\n                zW |> Wrap.bind (fun z ->\n                    i <- z\n                    printoutfn out \" z = %d\" i\n                    WSome   ()\n                )\n            let r = Wrap.whileLoop pred body\n            r\n        )\n    ) |> Wrap.RunSynchronously\n    \nlet helloA i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"async \"\n        do! async { printoutfn out \"HelloA %d\" i }\n        return i + 1\n    }\n\nlet whileA() = \n    let mutable i = 0\n    async {\n        let! a = async { return 2 }\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsync\n            i <- z\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet forR() = \n    result {\n        let! a = Result.succeed 2\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsyncResult |> Async.RunSynchronously\n            printoutfn out \" z = %d\" z\n    } |> ignore\n    \nlet forW() = \n    wrap {\n        let! aR = async { return Result.succeed 2 }\n        let! a = aR\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            printoutfn out \" z = %d\" z\n        return! WSome   ()\n    } |> Wrap.RunSynchronously\n    \nlet forA() = \n    async {\n        let! a = async { return 2 }\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Wrap.toAsync\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nopen UsefulDotNet\n\nlet deleteIt() =\n    wrap {\n        let file = \"hello.txt\"\n        System.IO.File.WriteAllText(file, \"this is the content\\njaja\")\n        printoutfn out \"before use\"\n        use toErase = new TempFileName(file)\n        printoutfn out \"using\"\n        do! Async.Sleep 5\n        printoutfn out \"still using\"\n        System.IO.File.ReadAllText file |> printoutfn out \"%s\"\n        printoutfn out \"used\"\n    } |> Wrap.RunSynchronously\n\n//runStdOut forR |> printfn \"%s\"\n//runStdOut forW |> printfn \"%s\"\n//runStdOut forA |> printfn \"%s\"\n\n\n//    let [<Test>]``when Divide by zero``() =               let divBy x y = x / y\n//                                                          test <@ divBy 10 0 = 10 @>\n//let [<Test>] formula                             () = test <@ (1+2)/3 = 2 @>\nlet [<Test>] ``whileA  must be diffrt. than \"\"`` () = runStdOut whileA  <>! \"\"     \nlet [<Test>] ``whileR  must be equal to whileA`` () = runStdOut whileR   =! runStdOut whileA     \nlet [<Test>] ``whileWW must be equal to whileA`` () = runStdOut whileWW  =! runStdOut whileA \nlet [<Test>] ``whileW  must be equal to whileA`` () = runStdOut whileW   =! runStdOut whileA \nlet [<Test>] ``forR    must be equal to forA``   () = runStdOut forR     =! runStdOut forA     \nlet [<Test>] ``forW    must be equal to forA``   () = runStdOut forW     =! runStdOut forA\nlet [<Test>] ``using TempFileName``              () = runStdOut deleteIt =! \"before use\\nusing\\nstill using\\nthis is the content\\njaja\\nused\\n\"\n   ", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8d27dca0-b87f-43b8-abe4-967e15467df4"}, "snpName": "ClientWebSocket .Net", "snpContent": "open Useful\nopen WSMessagingBroker\n\nlet out' s = printfn \"%s\" s\n\nlet clientId = \"ClientWebSocket .Net Test\"\nlet messaging = new WSMessagingClient(clientId)\n\nmessaging.ProcessIncoming <| fun msg -> Wrap.wrapper { printoutfn out' \"Message: %A\" msg }\n//messaging.Out <- out\n\nlet GetListeners() = messaging.MBListeners |> Wrap.RunSynchronously\n\nlet GetListeners4Times() =\n    GetListeners() |> printoutfn out \"1: %A\"\n    GetListeners() |> printoutfn out \"2: %A\"\n    GetListeners() |> printoutfn out \"3: %A\"\n    GetListeners() |> printoutfn out \"4: %A\"\n\nlet sendFromBroker() =\n    newMsg MessageBrokerAddress \"This is Information\"\n    |> replier Broker\n    |> msgType MsgFromBroker\n    |> messaging.SendMsg\n    |> Wrap.runSynchronouslyS false\n    |> printoutfn out \"%s\"\n\nlet sendFromBroker4Times() =\n    sendFromBroker()\n    sendFromBroker()\n    sendFromBroker()\n    sendFromBroker()\n\nlet timeouts() = \n    newMsg MessageBrokerAddress \"This should Timeout\"\n    |> replier Receiver\n    |> msgType MsgInformation\n    |> messaging.SendMsg\n    |> Wrap.runSynchronouslyS false\n    |> printoutfn out \"%s\"\n\nlet [<Test>] ``Get Listeners 4 times``           () = test <@ runStdOut(GetListeners4Times)  .Contains \"|]\\n4: [|\"             @>\nlet [<Test>] ``BMOnlyBrokerShouldUse 4 times``   () = test <@ runStdOut(sendFromBroker4Times).Contains \"Failed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\nFailed!\\nBMOnlyBrokerShouldUse\\n\" @>\nlet [<Test>] ``I must be one of the listeners``  () = test <@ GetListeners()           |> Seq.contains clientId                @>\nlet [<Test>] ``Must get a BMOnlyBrokerShouldUse``() = test <@ runStdOut(sendFromBroker)      .Contains \"BMOnlyBrokerShouldUse\" @>\nlet [<Test>] ``Must Timeout``                    () = raises<System.TimeoutException> <@ timeouts()                            @>\n    \n        ", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"2c0233fa-d7dd-4bc9-86fd-9f9da6f5dba3"}, {"SnippetId" :"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e291419f-5cb5-4751-b09b-3ca1e2fcd20d"}, "snpName": "FStationMessaging", "snpContent": "open WSMessagingBroker\n\nlet preds() =\n    let messaging = new FStationMessaging(\"FStationMessaging\")\n    let snpPath = \"FSSGlobal/F# Code/Tests/FStationMessaging\"\n\n    Wrap.wrapper {\n        let! preds = messaging.RequestPreds snpPath\n        return preds\n    } |> Wrap.RunSynchronously\n\nlet [<Test>] ``My code must contain myself``() = \n    test <@ preds() |> Seq.exists (fun snp -> snp.content.Contains \"supercalifragilisticexpialidocious, mxyzptlk & rumpelstiltskin are unusual words\") @>\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}, {"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2dcf05b8-45a7-4184-a8cd-322078244954"}, "snpName": "MailboxProcessor", "snpContent": "open Useful\n\nlet pause() = Async.Sleep 1000 |> Async.RunSynchronously\n\nlet logThisMsg = Mailbox.iter (printoutfn out \"Log1: %s\")\nlet [<Test>] ``logThisMsg.Post``  () =  runStdOut (fun () -> logThisMsg .Post \"message\"       ; pause()) =! \"Log1: message\\n\"\n\nlet logThisMsgA = Mailbox.iterA (fun msg -> async { printoutfn out \"Log2: %s\" msg } )\nlet [<Test>] ``logThisMsgA.Post`` () =  runStdOut (fun () -> logThisMsgA.Post \"message Async\" ; pause()) =! \"Log2: message Async\\n\"\n\nlet toUpperCase = Mailbox.call (fun (msg:string) -> msg.ToUpper() )\nlet [<Test>] ``call PostAndReply 1`` () = toUpperCase.PostAndReply(fun reply -> reply, \"message\") =! \"MESSAGE\"\nlet [<Test>] ``call PostAndReply 2`` () = toUpperCase.PostAndReply                     \"message\"  =! \"MESSAGE\"\n\nlet messageUpperA1 = async {\n    let! res = toUpperCase.PostAndAsyncReply(fun reply -> reply, \"message\")\n    return sprintf \"Async: %s\" res\n} \n\nlet messageUpperA2 = async {\n    let! res = toUpperCase.PostAndAsyncReply \"message\"\n    return sprintf \"Async: %s\" res\n} \n\nlet [<Test>] ``call PostAndAsyncReply 1`` () = messageUpperA1 |> Async.RunSynchronously =! \"Async: MESSAGE\"\nlet [<Test>] ``call PostAndAsyncReply 2`` () = messageUpperA2 |> Async.RunSynchronously =! \"Async: MESSAGE\"\n\nlet toUpperCaseA = Mailbox.callA (fun (msg:string) -> async { return msg.ToUpper() } )\nlet [<Test>] ``callA PostAndReply 1`` () = toUpperCaseA.PostAndReply(fun reply -> reply, \"message\") =! \"MESSAGE\"\nlet [<Test>] ``callA PostAndReply 2`` () = toUpperCaseA.PostAndReply                     \"message\"  =! \"MESSAGE\"\n\nlet messageUpperA3 = async {\n    let! res = toUpperCaseA.PostAndAsyncReply(fun reply -> reply, \"message\")\n    return sprintf \"Async: %s\" res\n} \n\nlet messageUpperA4 = async {\n    let! res = toUpperCaseA.PostAndAsyncReply \"message\"\n    return sprintf \"Async: %s\" res\n} \n\nlet [<Test>] ``call PostAndAsyncReply 3`` () = messageUpperA3 |> Async.RunSynchronously =! \"Async: MESSAGE\"\nlet [<Test>] ``call PostAndAsyncReply 4`` () = messageUpperA4 |> Async.RunSynchronously =! \"Async: MESSAGE\"\n\n\n\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"aa485846-7b78-4ca8-ae22-84ba0c42d962"}, {"SnippetId" :"c487f6a1-efbc-4a29-8c60-a9ebc73ae4e3"}, {"SnippetId" :"e24d6bc0-703c-4f12-aca8-8158af50b7cd"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fdb52749-398c-402a-8ecb-8137dafa37d2"}, "snpName": "", "snpContent": "\nopen canopy\nopen runner\nopen System\n\n//start an instance of the firefox browser\nstart firefox\n\n//this is how you define a test\n\"taking canopy for a spin\" &&& fun _ ->\n    //this is an F# function body, it's whitespace enforced\n\n    //go to url\n    url \"http://lefthandedgoat.github.io/canopy/testpages/\"\n\n    //assert that the element with an id of 'welcome' has\n    //the text 'Welcome'\n    \"#welcome\" == \"Welcome\"\n\n    //assert that the element with an id of 'firstName' has the value 'John'\n    \"#firstName\" == \"John\"\n\n    //change the value of element with\n    //an id of 'firstName' to 'Something Else'\n    \"#firstName\" << \"Something Else\"\n\n    //verify another element's value, click a button,\n    //verify the element is updated\n    \"#button_clicked\" == \"button not clicked\"\n    click \"#button\"\n    \"#button_clicked\" == \"button clicked\"\n\n//run all tests\nrun()\n\nprintfn \"press [enter] to exit\"\nSystem.Console.ReadLine() |> ignore\n\nquit()", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3268fd67-3dfe-47c4-afec-0231952e2294"}, "snpName": "Run All Tests", "snpContent": "// You can select which test to run just by making them predecessors of this\n\nTap.Run typeof<Marker>.DeclaringType    // run tests in module\n\n", "snpParentIdO": {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, "snpPredIds": [{"SnippetId" :"2dcf05b8-45a7-4184-a8cd-322078244954"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpName": "WebSharper Code", "snpContent": "#define WEBSHARPER\n(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)\n", "snpParentIdO": {"SnippetId" :"bf864f3c-1370-42f2-ac8a-565a604892e8"}, "snpPredIds": [{"SnippetId" :"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpName": "Library", "snpContent": "", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d785002c-20f8-4fa2-8838-cf29f59b2af8"}, "snpName": "isUndefined, findRootElement", "snpContent": "[< JavaScript >]\nmodule Several =\n\n    [< Inline \"\"\"(!$v)\"\"\">]\n    let isUndefined v = v.GetType() = v.GetType()\n    \n    let  findRootElement (e:Dom.Element) =\n        if isUndefined e.GetRootNode then JS.Document.Body\n        else\n            let root = e.GetRootNode()\n            if isUndefined root?body \n            then root.FirstChild :?> Dom.Element\n            else root?body  |> unbox<Dom.Element>\n            \n", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2749a2be-83f6-4e82-8947-a0a10ca51e83"}, "snpName": "ResizeObserver", "snpContent": "[< JavaScript >]\nmodule ResizeObserver =\n\n    [< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \n    let implementedResizeObserver() = false\n    \n    [< Inline \"new ResizeObserver($_f)\" >]\n    let newResizeObserver (_f: unit->unit) = X<_> \n    \n    [< Inline \"$_ro.observe($_el)\" >]\n    let RObserve _ro (_el:Dom.Element) = X<_> \n    \n    let mutable observers : obj list = []\n    \n    let domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n    \n    let [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n    \n    let dimsChanged (el:Dom.Element) = \n        let dims = ref <| el.GetBoundingClientRect()\n        fun () ->\n            let ndims = el.GetBoundingClientRect()\n            if domRect2Tuple !dims = domRect2Tuple ndims then false\n            else dims := ndims    ; true\n    \n    let addResizeObserver f el =\n        if implementedResizeObserver() then\n            let ro =  newResizeObserver f\n            observers <- ro::observers\n            RObserve ro el\n        else\n            let changed = dimsChanged el\n            async {\n                while isValidElement el do\n                    do! Async.Sleep 110\n                    if changed() then f()\n            } |> Async.Start\n            ", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c081fe7a-3047-4720-91eb-e175814c50d4"}, "snpName": "Hoverable", "snpContent": "open WebSharper.UI.Html\n\n[< JavaScript >]\nmodule Hoverable =\n\n    [<NoComparison ; NoEquality>]\n    type Hoverable         = { hover : Var<bool>        } with\n        static member  New() = { hover = Var.Create false }\n        member inline this.Attributes = [ attr.classDynPred (View.Const \"hovering\") this.hover.View\n                                          on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n                                          on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n                                        ]   \n        member inline this.Content    (ds: Doc seq) = div this.Attributes ds\n        member inline this.Content    ( e: Elt    ) = e.OnMouseEnter(fun _ _ -> e.AddClass    \"hovering\") // THIS ONE ADDS ONE EXTRA SPACE\n                                                       .OnMouseLeave(fun _ _ -> e.RemoveClass \"hovering\") // THAT THIS ONE DOES NOT REMOVE      \n        //member inline this.Content    ( e: Elt    ) = e.WithAttrs this.Attributes\n        static member  Demo  = Hoverable.New().Content(div [ attr.style \"flex-flow: column;\" ] [ text \"Hover over me!\" ])\n\n    let hoverable (e:Elt) = Hoverable.New().Content e\n    ", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ca76cee7-f319-4e40-828b-b15493fdffd1"}, "snpName": "TabStrip", "snpContent": "[< JavaScript >]\nmodule TabStrip =\n    let reorderList (ts:'a list) drag drop =\n        if drop < drag then\n           ts.[0       ..drop - 1     ]\n         @    [      ts.[drag]        ]\n         @ ts.[drop    ..drag - 1     ]\n         @ ts.[drag + 1..ts.Length - 1]\n        else\n           ts.[0..drag - 1            ]\n         @ ts.[drag + 1..drop         ]\n         @    [      ts.[drag]        ]\n         @ ts.[drop + 1..ts.Length - 1]\n    \n    let reorderArray (ts:'a []) drag drop =\n       (if drop < drag then\n          [|\n           ts.[0       ..drop - 1     ]\n           [|        ts.[drag]       |]\n           ts.[drop    ..drag - 1     ]\n           ts.[drag + 1..ts.Length - 1]\n          |]\n        else\n          [|\n           ts.[0..drag - 1            ]\n           ts.[drag + 1..drop         ]\n           [|        ts.[drag]       |]\n           ts.[drop + 1..ts.Length - 1]\n          |]\n       )|> Array.collect id \n    \n    \n    [< NoComparison >]\n    type TabStrip =\n        { selected  : Var<int>\n          tabs      : Var<(System.Guid * (string * Elt)) []>\n          top       : bool\n          horizontal: bool\n          id        : System.Guid\n        } \n    \n    let draggedTab: (TabStrip * int) option ref = ref None\n    \n    let uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n    \n    let selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n    \n    let setSelectedPanel group panelO = \n        selectedPanels.Value <- \n            match panelO with\n            | Some panel -> selectedPanels.Value.Add    (group, panel)\n            | None       -> selectedPanels.Value.Remove  group\n    \n    let mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\n    let RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n    \n    open WebSharper.UI.Html\n    open Hoverable\n    \n    type TabStrip with\n        member this.moveTab from drag drop =\n            let ts = this.tabs.Value\n            let ft = from.tabs.Value\n            let newTabsT =\n                [|\n                 ts.[0       ..drop - 1     ]\n                 [|        ft.[drag]       |]\n                 ts.[drop    ..ts.Length - 1]\n                |]\n                |> Array.collect id\n            let newTabsF =\n                [|\n                 ft.[0       ..drag - 1     ]\n                 ft.[drag + 1..ft.Length - 1]\n                |]\n                |> Array.collect id\n            from.tabs.Value     <- newTabsF\n            this.tabs.Value     <- newTabsT\n            this.selected.Value <- drop\n            if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n            RaiseTabMoved from this\n    \n        member this.reorder drop =\n            match !draggedTab with\n            | None                                      -> ()\n            | Some( from, drag) when from.id <> this.id -> this.moveTab from drag drop\n            | Some(_from, drag)                         ->\n            this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n            let sel = this.selected.Value\n            this.selected.Value <- if    sel = drag                then drop\n                                   elif (sel < drag && sel < drop)\n                                     || (sel > drag && sel > drop) then sel \n                                   elif  sel < drag                then sel + 1\n                                   else                                 sel - 1\n                                   \n        static member New(tabs)    =\n            { selected   = Var.Create 0\n              tabs       = tabs \n              top        = false \n              horizontal = true\n              id         = System.Guid.NewGuid() \n            } \n        static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n        member this.Top         = { this with top        = true  }\n        member this.Bottom      = { this with top        = false }\n        member this.SetTop    t = { this with top        = t     }\n        member this.Horizontal  = { this with horizontal = true  }\n        member this.Vertical    = { this with horizontal = false }\n        member this.Selected    = View.Map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs.View this.selected.View\n        member this.Select    n = this.selected.Value <- n\n        member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n        member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n        member this.Render      =\n            let strip =\n                this.tabs.View\n                |> Doc.BindView (\n                    fun tabs ->\n                        div [ attr.``class`` <| sprintf \"tab-strip %s %s\"\n                                                    (if this.top        then \"top\"        else \"bottom\"  ) \n                                                    (if this.horizontal then \"horizontal\" else \"vertical\")\n                            ]\n                            [\n                              for i, (_uid, (txt, _)) in  tabs |> Seq.indexed  do\n                                  yield Hoverable.New().Content (\n                                        div [ attr.classDyn <| View.Map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected.View\n                                              attr.draggable \"true\"\n                                              on.dragOver(fun _  ev -> ev.PreventDefault()                            )\n                                              on.drag    (fun _  _  ->                     draggedTab := Some(this, i))\n                                              on.drop    (fun _e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                              on.click   (fun _  _  ->                       this.selected.Value <- i ) \n                                            ]\n                                            [ text txt ]) :> Doc\n                            ] \n                )\n            View.Sink (setSelectedPanel this.id) this.Selected\n            let content = \n                this.tabs.View\n                |> Doc.BindView (fun tabs ->\n                   tabs\n                   |> Seq.map (fun (uid, (_txt, sub)) -> \n//                         sub.WithAttrs(\n//                           [ attr.styleDyn <| View.Map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels.View\n//                             attr.id       <| uid2s uid\n//                           ]) :> Doc)\n                         sub.SetAttribute(\"id\", uid2s uid)\n                         selectedPanels.View\n                         |> View.Sink (fun sels -> sub.SetStyle(\"display\", if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"none\") ) \n                         sub :> Doc)\n                    |> div [ attr.``class`` \"tab-children\" ; attr.id <| uid2s this.id ]\n                 )\n            let css = @\"\n.tab-panel {\n overflow  : hidden   ;\n display   : flex     ;\n flex-flow : column   ;\n background: lightgray;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n        \"\n            div [ attr.``class`` \"tab-panel\" \n                  on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n                  on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n                ]\n                [\n                  (if     this.top then strip else Elt.Empty)\n                  div [ attr.``class`` \"tab-content\" ] [ content ]\n                  (if not this.top then strip else Elt.Empty)\n                  Elt.Element \"style\" [] [ text css ]\n                ]\n                ", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"c081fe7a-3047-4720-91eb-e175814c50d4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"aaebfac9-964d-484e-b049-869d079d4198"}, "snpName": "WebComponent", "snpContent": "[< JavaScript >]\nmodule WebComponent =\n\n    [< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\n    let ReflectConstruct () = X<_>\n    \n    [< Inline \"\"\"console.log('defineWebComponent: ' + $_nm);\n                 Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n                 Object.setPrototypeOf($_c, $global.HTMLElement);\n                 Object.setPrototypeOf($_o.prototype, $_c.prototype);\n                 $global.customElements.define($_nm, $_o)\"\"\" >]\n    let defineWebComponent _nm _o _c = X<_>\n", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"22818e3c-9d73-493c-b064-3b7da34ccddd"}, "snpName": "WebComponent TabStrip", "snpContent": "[< JavaScript ; AutoOpen >]\nmodule WcTabStripT =\n    open WebComponent\n    open TabStrip\n    type WcTabStripT () =\n        let mutable added = false\n        do printfn \"WcTabStripT initializer\"\n        [< Inline \"\"\"$global.FSSGlobal.WcTabStripT.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n        static member Constructor() = \n            let this = ReflectConstruct()\n            WcTabStripT.NewPointer?call this\n            this\n        member this.connectedCallback() = \n            printfn \"my-el connected %A %A\" added this?outerHTML\n            if not added then\n                let el : Dom.Element = this |> box |> unbox\n                let top  = el.HasAttribute \"bottom\" |> not\n                let elsh = JS.Document.CreateElement \"div\"\n                let tabs = [ for i in 1..el.ChildNodes.Length do \n                                  let node = el.ChildNodes.[i - 1]\n                                  if node.NodeType = Dom.NodeType.Element then\n                                      let elem = node :?> Dom.Element\n                                      let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                      yield (tabName, elem)\n                           ]\n                TabStrip.New(tabs |> Seq.map (fun (nm,nd) -> nm, Doc.Static nd :> Doc |> Seq.singleton |> div []) )\n                |> (fun ts -> if top then ts.Top.Render else ts.Bottom.Render)\n                |> Doc.Run elsh\n                el.AppendChild elsh.FirstChild |> ignore\n                added <- true\n    let init() =\n        if IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n    ", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"aaebfac9-964d-484e-b049-869d079d4198"}, {"SnippetId" :"ca76cee7-f319-4e40-828b-b15493fdffd1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4becf2f9-2b9f-442e-bb70-02ac8d8d67f6"}, "snpName": "CodeMirror", "snpContent": "[< JavaScript >]\nmodule CodeMirror =\n    open WebSharper.UI.Html\n\n    type Pos = { line: int ; ch  : int }\n    let inline cmPos(l, c) = { line = l ; ch  = c }\n    \n    type Editor() =\n        do ()\n      with\n        [< Inline \"$global.CodeMirror($_elt)\" >]\n        static member SetupEditor _elt                                    : Editor           = X<_>\n        [< Inline \"$this.getValue()\"              >]      \n        member this.GetValue()                                            : string           = X<_>\n        [< Inline \"$this.setValue($_v)\"           >]      \n        member this.SetValue(_v:string)                                   : unit             = X<_>\n        [< Inline \"$this.refresh()\"               >]      \n        member this.Refresh()                                             : unit             = X<_>\n        [< Inline \"$this.setOption($_o, $_v)\"     >]      \n        member this.SetOption(_o:string, _v:obj)                          : unit             = X<_>\n        [< Inline \"$this.getOption($_o)\"          >]      \n        member this.GetOption(_o:string)                                  : obj              = X<_>\n        [< Inline \"$this.getCursor()\"             >]      \n        member this.GetCursor()                                           : Pos              = X<_>\n        [< Inline \"$this.setCursor($_line, $_col)\">]      \n        member this.SetCursor(_line:int, _col:int)                        : unit             = X<_>\n        [< Inline \"$this.focus()\"                 >]      \n        member this.Focus()                                               : unit             = X<_>\n        [< Inline \"$this.getLine($_l)\"            >]      \n        member this.GetLine(_l:int)                                       : string           = X<_>\n        [< Inline \"$this.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n        member this.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n        [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n        member this.RemoveMarks() : unit       = X<_>\n        [< Inline \"$this.getDoc().clearHistory()\" >]\n        member this.ClearHistory()                                        : unit             = X<_>\n        [< Inline \"$this.on($_event, $_f)\"        >]\n        member this.On(_event: string, _f:(Editor * obj)->unit)           : unit             = X<_>\n        [< Inline \"$this.on($_event, $_f)\"        >]\n        member this.On(_event: string, _f: Editor       ->unit)           : unit             = X<_>\n        [< Inline \"$this.addKeyMap($_keyMap)\"     >]\n        member this.AddKeyMap(_keyMap: obj)                               : unit             = X<_>\n        [< Inline \"$this.getWrapperElement()\"     >]\n        member this.GetWrapperElement()                                   : Dom.Element      = X<_>\n        [< Inline \"$this.replaceSelection($_v, $_s)\">]\n        member this.ReplaceSelection(_v:string, _s:string)                                    = ()\n    \n    [<NoComparison ; NoEquality>]\n    type CodeMirror = {\n        var             : Var<string>\n        onChange        : (unit   -> unit)\n        onRender        : (Editor -> unit) option\n        mutable editorO :  Editor option\n        disabled        : View<bool>\n    } with\n    \n      static member  New(var) = \n          { var      = var \n            onChange = ignore\n            onRender = None\n            editorO  = None\n            disabled = V false\n          }\n      member        this.Render                 =\n          div [ on.afterRender (fun elchild ->\n                       async {\n                           let editor        = Editor.SetupEditor elchild.ParentElement\n                           elchild.ParentNode.RemoveChild elchild |> ignore\n                           this.editorO     <- Some editor\n                           this.onRender |> Option.iter (fun onrender -> onrender editor)\n                           let editorChanged = ref 0L\n                           let varChanged    = ref 0L\n                           editor.On(\"changes\", fun (_cm, _change) ->\n                               let v = editor.GetValue() \n                               if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                           )\n                           this.var.View |> View.Sink (fun _ ->\n                               if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                               elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                           )\n                           this.disabled |> View.Sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                       } |> Async.Start\n                    )    \n              ] []\n      member inline this.SetVar   v    = { this with var       = v      }\n      member inline this.OnChange f    = { this with onChange  = f      }\n      member inline this.OnRender f    = { this with onRender  = Some f }\n      member inline this.Disabled dis  = { this with disabled  = dis    }\n      member inline this.Var           = this.var\n      static member  New(v:string)             = CodeMirror.New(Var.Create v)\n      static member  New(v:Var<string option>) = CodeMirror.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(V (Option.isNone v.V))\n\n    module Hint =\n        type Hint = {\n            text        : string\n            displayText : string\n            className   : string\n        }\n        \n        type Response  = {\n            list           : Hint []\n            from           : Pos   \n            ``to``         : Pos   \n        }\n        \n        type Func      = FuncWithArgs<Editor * (Response -> unit) * obj,  unit>\n        \n        type Options   = {\n            hint           : Func\n            completeSingle : bool   \n            container      : Dom.Element\n        }\n        \n        [< Inline \"($_v.hint.async = 1, $_ed.showHint($_v))\"          >]\n        let showHint_ (_ed:Editor) _v : unit       = X<_>\n        let showHints ( ed:Editor) getHints completeSingle _ =\n            showHint_   ed\n                {  completeSingle = completeSingle\n                   hint           = Func getHints\n                   container      = ed.GetWrapperElement() |> Several.findRootElement\n                }\n\n    module Lint =\n        type Response  = {\n            message        : string\n            severity       : string\n            from           : Pos   \n            ``to``         : Pos   \n        }\n        \n        type Func      = FuncWithArgs<string * (Response[] -> unit) * obj * Editor,  unit>\n        \n        [< Inline \"($_ed.setOption('lint', { async: 1, getAnnotations: $_f, container: $_elm }))\"          >]\n        let setLint_(_ed:Editor) (_f:Func) (_elm:Dom.Element)  : unit = X<_>\n        let setLint ( ed:Editor)   getAnnotations       = \n            setLint_  ed (Func getAnnotations) (ed.GetWrapperElement() |> Several.findRootElement)\n        \n                        \n                ", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"d785002c-20f8-4fa2-8838-cf29f59b2af8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ba3c73e8-9fe3-413e-86d8-edadb1d77d08"}, "snpName": "Serializer", "snpContent": "[< JavaScript >]\nmodule Serializer =\n    open Several\n    \n    type SerS<'T> = ('T  -> string)        //      Serialization function\n    type SerD<'T> = (obj -> 'T    )        //    deSerialization function\n    type Ser< 'T> = SerS<'T> * SerD<'T>    // both Serialization functions\n    \n    let inline ifUndef  def v   = if isUndefined v then def   else   v\n    let inline ifUndefF def f v = if isUndefined v then def v else f v\n    \n    let (|Exists|_|) field o = if isUndefined o?(field) then None else Some o?(field)\n    \n    let deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n\n    let [< Inline >] inline sprintU v = sprintf \"%A\"       v\n    let [< Inline >] inline sprintQ v = sprintf \"\\\"%A\\\"\"   v\n    let              inline sprintA v = String.concat \", \" v |> sprintf \"[%s]\"\n    \n    let serFloat  : Ser<float > = sprintU        , (unbox >> ifUndef 0.0   )\n    let serInt    : Ser<int   > = sprintU        , (unbox >> ifUndef 0     )\n    let serBool   : Ser<bool  > = sprintU        , (unbox >> ifUndef false )\n    let serString : Ser<string> = Json.Serialize , (unbox >> ifUndef \"\"    )\n\n    let [< Inline >] inline serId  (get: 'a->System.Guid) (set:System.Guid->'a) (print: 'a->string) : Ser<'a> =\n        let s           = System.Guid.Empty |> set |> print |> fun (s:string) -> s.Split ' ' |> Array.head\n        let sQ          = sprintf \"%A\" s\n        let serialize   = fun id       -> get id |> sprintf \"{%10s :%A}\" sQ\n        let deserialize = fun (x: obj) -> x?(s) |> deserGuid |> set\n        serialize, deserialize\n\n    let serField (name:string) (get:'D->'e) (set:'e->'D->'D) (serFuncs:('e->string) * (obj->'e)) : string * SerS<'D> * ('D -> SerD<'D>) = \n        serFuncs |> fun (ser, deser) -> name, get >> ser, (fun rc o -> set (deser o) rc) \n        \n    let [< Inline >] serRecord init (fields: #seq<(string * SerS<'D> * ('D -> SerD<'D>))>) : Ser<'D> =\n        let serialize   dim = fields |> Seq.map  (fun     (n,  ser, _deser) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n        let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, _ser,  deser) ->  deser dim (o?(n)) )   init\n        serialize, deserialize\n    \n    let serSeq (ser:Ser<'D>) : Ser<'D seq     > = (Seq   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser))               )\n    let serArr (ser:Ser<'D>) : Ser<'D []      > = (Array .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toArray)\n    let serLst (ser:Ser<'D>) : Ser<'D list    > = (List  .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Seq.toList )\n    let serSet (ser:Ser<'D>) : Ser<Set<'D>    > = (Set   .map (fst ser) >> sprintA                   ) , (unbox<obj[]> >> ifUndefF (fun _ -> Seq.empty) (Seq.map (snd ser)) >> Set        )\n    let serOpt (ser:Ser<'D>) : Ser<'D option  > = (Option.map (fst ser) >> Option.defaultValue \"null\") , (unbox<obj  > >> ifUndefF (fun _ -> None     ) (         snd ser   >> Some      ))\n    let serDup serFst serSnd : Ser<'a * 'b    > = (fun (f,s) -> sprintf \"[%s, %s]\" (fst serFst f) (fst serSnd s)), (unbox<obj[]> >> ifUndefF (fun _ -> snd serFst null, snd serSnd null ) (fun os -> snd serFst os.[0], snd serSnd os.[1] ) )\n    let serMap serKey serElm : Ser<Map<'k, 'e>> = serDup serKey serElm |> serSeq |> (fun serKVPs -> (Seq.map (fun kvp -> kvp.Key, kvp.Value) >> fst serKVPs) , (snd serKVPs >> Map)       )\n\n    let serVarField (name:string) (var:'D->Var<'e>) (serFuncs:Ser<'e>) : string * SerS<'D> * ('D -> SerD<'D>) = \n        serFuncs |> fun (ser, deser) -> name, (var >> Var.Get >> ser), (fun rc o -> var rc |> Var.Set <| deser o ; rc)\n\n    let serLMdField (name:string) (lmd:'D->ListModel<_,'e>) serE  : string * SerS<'D> * ('D -> SerD<'D>) = \n        let serS              = serSeq serE\n        let serializer   rc   = lmd rc |> (fun lm -> lm.Value) |> fst serS\n        let deserializer rc b = lmd rc |> (fun lm -> lm.Set  ) <| snd serS b ; rc\n        name, serializer, deserializer\n", "snpParentIdO": {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"d785002c-20f8-4fa2-8838-cf29f59b2af8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpName": "HtmlNode", "snpContent": "\n[<JavaScript>]\nmodule HtmlNode      =\n", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0f5719f0-e95e-498d-ab88-f89ff1440e32"}, "snpName": "Val", "snpContent": "[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of Var<'a>\n    | Dynamic   of View<'a>\n  with member this.ValTypeMember = 0\n\nmodule View =\n    let [<Inline>] inline consistent   (vl:View<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        View.Sink setPrior vl\n        !prior |> View.FromVar\n\nmodule Var =\n    let mutable private counter = 1\n    let freshId () =\n        counter <- counter + 1\n        \"varuid\" + string counter\n            \n//    let Make (init: 'T) (view: View<'T>) (set: 'T -> unit) =\n//        let id = freshId ()\n//        let current = ref init\n//        let view = view |> View.Map (fun x -> current := x; x)\n//        { new Var<'T>() with\n//            member this.View           = view\n//            member this.Get         () = !current\n//            member this.Set         x  = set x\n//            member this.SetFinal    x  = set x\n//            member this.UpdateMaybe f  = view |> View.Get (f >> Option.iter set)\n//            member this.Update      f  = view |> View.Get (f >>             set)\n//            member this.Id             = id\n//        }\n    let lensView get update view0 (var: Var<_>) =\n        let id   = freshId()\n        let view = View.Map2 (fun v _ -> get v) var.View view0\n        { new Var<'V>() with\n            member this.Get        () = get (var.Get())\n            member this.Set         v = var.Update(fun t -> update t v)\n            member this.SetFinal    v = this.Set(v)\n            member this.Update      f = var.Update(fun t -> update t (f (get t)))\n            member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n            member this.View          = view\n            member this.Id            = id\n        }\n\nmodule ListModel =\n    let currentLensUpd def curr upd (model:ListModel<_,_>) = \n        curr \n        |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                        (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                        model.View\n    let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n        let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n        Var.Make view upd\n    let currentLens def curr (model:ListModel<_,_>) = \n        model \n        |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n    \nmodule Val =\n    let swap = Useful.swap\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let getAsync v =\n        match v with\n        | Constant  a -> async.Return   a\n        | Dynamic  wa -> View.GetAsync wa\n        | DynamicV va -> async.Return  va.Value\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V (f_a_b_c: 'a->'b->'c) : Val<'a>->Val<'b>->Val<'c> =\n        let inline    f_aVbVc   a =  mapV  (f_a_b_c   a)\n        let inline    fVb_aVc  vb = (swap   f_aVbVc) vb\n        let inline    fVbVaVc  vb =  bindV (fVb_aVc  vb)\n        let inline    fVaVbVc  va = (swap   fVbVaVc) va\n        fVaVbVc\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View    \n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: Var<_            >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n(*    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSSGlobal.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n*)\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> As<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> As<Val<string>>  \n        | :?      Doc      as t   -> Val.Constant t |> As<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | :? Var< string>  as v   -> Val.DynamicV v        \n        | v when JS.In \"RSet\" v   -> Val.DynamicV (As<Var< string>> v)\n        | :? Function      as vw  -> Val.Dynamic  (As<View<string>> vw)        \n        | _ when o?get_ValTypeMember() = 0 -> o |> As<Val<string>> \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n\n    [< Direct \"$_f($v)\" >]\n    let inline fixitF _f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n\n    let [<Inline>] inline bindIRefO0 (f: 'a->Var< 'b> option) (view: View<'a>) = \n        let contentVar                          = Var.Create None\n        let changingIRefO : Var< 'b> option ref = ref        None\n        let contentVarChanged                   = ref 0L\n        let refVarChanged                       = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ ->            \n            match !changingIRefO, contentVar.Value with\n            | Some(r), Some(v) ->\n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> v                then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  v\n            | None, Some(_)    -> contentVar.Value <- None\n            | _   , None       -> ()\n         )\n    \n        view |> View.Bind (fun cur ->\n            let rO            = f cur\n            changingIRefO    := rO\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- rO |> Option.map (fun r -> r.Value)\n            rO |> Option.map (fun r -> r.View) |> Option.defaultWith (fun () -> View.Const Unchecked.defaultof<_>)\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif Some r.Value  <>  contentVar.Value  then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <- Some r.Value\n            )\n        )\n        contentVar\n        \n    let [<Inline>] inline bindIRef0 (f: 'a->Var< 'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : Var< 'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n        \n    let inline toDoc         v           = toView            (fixit v ) |> Doc.EmbedView\n    let [<Inline>] inline bindIRef  f  v           = bindIRef0  f (fixit v   |> toView)\n    let [<Inline>] inline bindIRefO f  v           = bindIRefO0 f (fixit v   |> toView)\n    let inline iter       f  v           = iterV           f (fixit v )\n    let inline bind       f  v           = bindV           f (fixit v )\n    let inline map        f  v           = mapV            f (fixit v )\n    let inline map2       f  v1 v2       = map2V           f (fixit v1) (fixit v2)\n    let inline map3       f  v1 v2 v3    = map3V           f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4       f  v1 v2 v3 v4 = map4V           f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n\n    let inline apply      va vf          = bindV(fun f-> mapV f va) vf\n  \n    let inline iter2      f  v1 v2       = map2            f v1 v2       |> iterV id\n    let inline iter3      f  v1 v2 v3    = map3            f v1 v2 v3    |> iterV id\n    let inline iter4      f  v1 v2 v3 v4 = map4            f v1 v2 v3 v4 |> iterV id\n  \n    let inline mapAsync   f  v           = View.MapAsync   f (fixit v |> toView) |> Dynamic\n    let inline sink       f  v           = View.Sink       f (fixit v |> toView) \n    let inline mapCached  f  v           = View.MapCached  f (      v |> toView) |> Dynamic\n\n    let [<Inline>] inline consistent   (vl:Val<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        let vw         = toView vl\n        View.Sink setPrior vw\n        !prior :> Var< _> |> DynamicV\n\n    type valBuilder() =\n        member inline this.Return     (x)                            = Constant x\n        member inline this.ReturnFrom (x)                            = x\n        member        this.Bind       (w:Val<'a> , r: 'a -> Val<'b>) = bind r w\n        member        this.Bind       (w:Var<'a> , r: 'a -> Val<'b>) = bind r w\n        member        this.Bind       (w:View<'a>, r: 'a -> Val<'b>) = bind r w\n        member inline this.Zero       ()                             = Constant ()\n        member inline this.Delay      (f)                            = f()\n    \n    let valFlow = valBuilder()\n", "snpParentIdO": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d9124644-0af6-4a7f-a711-ef76ca77f0de"}, "snpName": "HtmlNode", "snpContent": "[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlElementF   of func:(Attr seq -> Doc seq -> Doc) * children: HtmlNode seq\n    | HtmlElementV   of Val<HtmlNode>\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlElementF(func, children) -> Some <| (func             (getAttrsFromSeq children) (children |> Seq.choose chooseNode)       )\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | HtmlText     vtext           -> Some <| Val.tagDoc WebSharper.UI.Html.text vtext\n    | SomeDoc      doc             -> Some <| doc\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlElementF   func ch = HtmlElementF  (func, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline str            txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\nlet out (ps:HtmlNode list) =\n    match ps with\n    | [ ]            -> [ ]\n    | [h]            -> [h]\n    | h :: p :: tail -> addChildren [h] p :: tail\n    \nlet rec indent2Level lvl chn  (ps:HtmlNode list) =\n    match ps with\n    | l when l.Length < lvl -> chn :: l\n    | _                     -> indent2Level lvl chn <| out ps        \n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n    static member ( - ) (ps:HtmlNode list, chn : HtmlNode) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | []        -> []        \n    static member ( --- ) (ps:HtmlNode list, chn) : HtmlNode list = \n        match ps with \n        | [ ]            -> [ ]\n        | [h]            -> [ h.AddChildren [                 chn ] ]\n        | h :: p :: tail ->   p.AddChildren [ h.AddChildren [ chn ] ] :: tail\n    static member ( +  ) (ps:HtmlNode list, r:HtmlNode) : (HtmlNode list) =   r :: ps\n    static member ( --                   ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  2 chn ps\n    static member ( ----                 ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  3 chn ps    \n    static member ( ------               ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  4 chn ps    \n    static member ( --------             ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  5 chn ps    \n    static member ( ----------           ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  6 chn ps    \n    static member ( ------------         ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  7 chn ps    \n    static member ( --------------       ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  8 chn ps    \n    static member ( ----------------     ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level  9 chn ps    \n    static member ( ------------------   ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level 10 chn ps    \n    static member ( -------------------- ) (ps: HtmlNode list, chn:HtmlNode) : HtmlNode list = indent2Level 11 chn ps    \n\nlet rec finishO (ps:HtmlNode list) =\n    match ps with\n    | [ ]               -> None\n    | [h]               -> Some h\n    | _h :: _p :: _tail -> finishO <| out ps        \n\nlet endHtmlIndent ps = finishO ps |> Option.defaultWith (fun () -> htmlText \"Malformed HTMLNode\")\nlet ( !! ) (p:HtmlNode seq -> HtmlNode) l = [ p l ]\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ", "snpParentIdO": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpPredIds": [{"SnippetId" :"0f5719f0-e95e-498d-ab88-f89ff1440e32"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}, "snpName": "HTML Elements & Attributes", "snpContent": "let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline p           ch = htmlElement   \"p\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\nlet inline section     ch = htmlElement   \"section\"     ch\nlet inline strong      at = htmlElement   \"strong\"      at\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\nlet inline placeholder v  = htmlAttribute  \"placeholder\" v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\n//let inline ``xclass`` v  = \n//    match Val.fixit v with\n//    | Constant c  -> Attr.Class        c       \n//    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n//    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n//    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = v.GetType() = v.GetType()\n\nlet  findRootElement (e:Dom.Element) =\n    if isUndefined e.GetRootNode then JS.Document.Body\n    else\n        let root = e.GetRootNode()\n        if isUndefined root?body \n        then root.FirstChild :?> Dom.Element\n        else root?body  |> unbox<Dom.Element>\n", "snpParentIdO": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpPredIds": [{"SnippetId" :"d9124644-0af6-4a7f-a711-ef76ca77f0de"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"336d6f19-0c57-4af9-8716-1b3fbf6b112c"}, "snpName": "storeVar", "snpContent": "[< Inline >]\nlet inline storeVar<'T> storeName (var:Var<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n", "snpParentIdO": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpPredIds": [{"SnippetId" :"0f5719f0-e95e-498d-ab88-f89ff1440e32"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}, "snpName": "LoadFiles", "snpContent": "module LoadFiles =\n\n    [< Inline \"CIPHERSpaceLoadFiles($_files, $_cb)\" >]\n    let LoadFilesCb (_files: string []) (_cb: unit -> unit) : unit = X<_>\n    \n    let createScript fn =\n        let fileRef = JS.Document.CreateElement(\"script\")\n        fileRef.SetAttribute(\"type\", \"text/javascript\"  )\n        fileRef.SetAttribute(\"src\" , fn                 )\n        fileRef\n    \n    let createCss fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"stylesheet\"     )\n        fileRef.SetAttribute(\"type\", \"text/css\"       )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    let createHtml fn =\n        let fileRef = JS.Document.CreateElement(\"link\")\n        fileRef.SetAttribute(\"rel\" , \"import\"         )\n        fileRef.SetAttribute(\"type\", \"text/html\"      )\n        fileRef.SetAttribute(\"href\", fn               )\n        fileRef\n    \n    [< Inline \"\"\"(!$v)\"\"\">]\n    let isUndefined v = v.GetType() = v.GetType()\n    \n    let LoadFile(file: string) =\n        let (|EndsWith|_|) s (fn:string) = if fn.EndsWith s then Some() else None\n        match file with\n        | EndsWith \".js\"   ()\n        | EndsWith \".fsx\"  ()\n        | EndsWith \".fs\"   () when isUndefined <| JS.Document.QuerySelector(\"script[src='\" + file + \"']\") ->\n                                createScript file |> Some\n        | EndsWith \".css\"  ()-> createCss    file |> Some\n        | EndsWith \".html\" ()-> createHtml   file |> Some\n        | _                  -> None\n        |> Option.map         (fun ref -> \n            Async.FromContinuations <| \n                fun (cont, econt, _ccont) -> \n                    try \n                        ref?onload <- cont\n                        JS.Document.Head.AppendChild ref |> ignore\n                    with e -> econt e\n        )\n        |> Option.defaultWith (fun ()  -> async { return () })\n    \n    let LoadFilesAsync(files: string []) =\n        async {\n            for file in files do\n                do! LoadFile file\n        }\n    \n    let LoadFilesAsyncOld (files: string []) =\n        Async.FromContinuations <| \n            fun (cont, econt, _ccont) -> \n                try \n                    LoadFilesCb files cont\n                with e -> econt e\n    \n    ", "snpParentIdO": {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, "snpPredIds": [{"SnippetId" :"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}, "snpName": "", "snpContent": "open HtmlNode", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpName": "Template", "snpContent": "[<JavaScript>]\nmodule Template      =", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}, {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8fb54777-3046-4aae-9282-33401a45c280"}, "snpName": "", "snpContent": "let container content = div <| [ ``class`` \"container\" ] @ content", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"40614ad6-3f81-468b-a4ff-034124b82ae1"}, "snpName": "Bootstrap", "snpContent": "type Bootstrap() =\n    member this.Render =\n        div [\n          script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript\"    ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"   ; ``type`` \"text/javascript\" ; charset \"UTF-8\"      ]\n          link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n          link   [ href \"/EPFileX/css/main.css\"                                                ; ``type`` \"text/css\"        ; rel     \"stylesheet\" ]\n         ]\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, "snpName": "Button", "snpContent": "[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\"\n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ] \n    |> renderDoc |> SomeDoc\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, "snpName": "Input", "snpContent": "[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : Var<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n    disabled    : Val<bool>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                              disabled    = Val.fixit false\n                            }\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Prefix      p    = this.Prefix(htmlText p)\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Disabled    dis  = { this with disabled    = Val.fixit dis                   }\n  member inline this.Var              = this.var\n  static member  New(v:string)              = Input.New(Var.Create v)\n  static member  New(v:Var<string option>) = Input.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n  ", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}, "snpName": "Hoverable", "snpContent": "[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : Var<bool>\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n    }\n  member inline this.Content    (c: HtmlNode seq) = \n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  c\n    |> div\n  member inline this.Content    (c:HtmlNode) = \n      c.AddChildren \n          [ classIf \"hovering\" this.hover\n            SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n            SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n          ] \n  static member  Demo  = Hoverable.New.Content(div [ style \"flex-flow: column;\" ])\n  \nlet hoverable (c:HtmlNode) = Hoverable.New.Content c\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0a11766b-f227-4b38-88a3-919d964387bf"}, "snpName": "Panel", "snpContent": "[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty  }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt  }\n  member inline this.Header      h    = { this with header   =       h        }\n  member inline this.Content     c    = { this with content  =       c        }\n  member inline this.Disabled    dis  = { this with disabled =       dis      }\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"081bac32-e739-4124-87eb-eb7d6f2220bc"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, "snpName": "TextArea", "snpContent": "[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : Var<string>\n    disabled    : Val<bool>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                              disabled    = Val.fixit false\n                            }\n  member        this.RenderWith  more  =    \n    htmlElementF (fun att _ch -> Doc.InputArea att this.var :> Doc)\n        ([ \n          ``class``           this._class\n          Id                  this.id  \n          spellcheck       <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          title               this.title\n          style               \"height: 100%;  width: 100%; box-sizing: border-box; \"\n          placeholder         this.placeholder \n          SomeAttr         <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n        ] @ more)\n    |> Seq.singleton \n    //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n    |> div\n  member        this.Render           = this.RenderWith []    \n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Disabled    dis  = { this with disabled    = Val.fixit dis  }\n  member inline this.Var              = this.var\n  static member  New(v:string)              = TextArea.New(Var.Create v)\n  static member  New(v:Var<string option>) = TextArea.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n  ", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4180353c-9dc5-438d-862d-851539b02075"}, "snpName": "codeMirrorIncludes", "snpContent": "let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/none.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/css.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/javascript.js\"            \n      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/addon/hint/show-hint.js\"          \n      \"/EPFileX/codemirror/scripts/addon/lint/lint.js\"          \n   |]", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}, "snpName": "CodeMirror", "snpContent": "type CodeMirrorPos = { line: int ; ch  : int }\nlet inline cmPos(l, c) = { line = l ; ch  = c }\n\ntype CodeMirrorEditor() =\n    let _a = 1\n  with\n    [< Inline \"CodeMirror($_elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , gutters      : ['CodeMirror-lint-markers']\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($_elt)\" >]\n    static member SetupEditor _elt                                    : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]      \n    member this.GetValue()                                            : string           = X<_>\n    [< Inline \"$this.setValue($_v)\"           >]      \n    member this.SetValue(_v:string)                                   : unit             = X<_>\n    [< Inline \"$this.refresh()\"               >]      \n    member this.Refresh()                                             : unit             = X<_>\n    [< Inline \"$this.setOption($_o, $_v)\"     >]      \n    member this.SetOption(_o:string, _v:obj)                          : unit             = X<_>\n    [< Inline \"$this.getCursor()\"             >]      \n    member this.GetCursor()                                           : CodeMirrorPos    = X<_>\n    [< Inline \"$this.setCursor($_line, $_col)\">]      \n    member this.SetCursor(_line:int, _col:int)                        : unit             = X<_>\n    [< Inline \"$this.focus()\"                 >]      \n    member this.Focus()                                               : unit             = X<_>\n    [< Inline \"$this.getLine($_l)\"            >]      \n    member this.GetLine(_l:int)                                       : string           = X<_>\n    [< Inline \"$this.getDoc().markText({line:$_fl, ch:$_fc}, {line:$_tl, ch:$_tc}, {className: $_className, title: $_title})\" >]\n    member this.MarkText (_fl:int,_fc:int) (_tl:int,_tc:int) (_className: string) (_title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                        : unit             = X<_>\n    [< Inline \"$this.on($_event, $_f)\"        >]\n    member this.On(_event: string, _f:(CodeMirrorEditor * obj)->unit) : unit             = X<_>\n    [< Inline \"$this.addKeyMap($_keyMap)\"     >]\n    member this.AddKeyMap(_keyMap: obj)                               : unit             = X<_>\n    [< Inline \"$this.getWrapperElement()\"     >]\n    member this.GetWrapperElement()                                   : Dom.Element      = X<_>\n    [< Inline \"$this.replaceSelection($_v, $_s)\">]\n    member this.ReplaceSelection(_v:string, _s:string)                                    = ()\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : Var<string>\n    onChange        : (unit             -> unit)\n    onRender        : (CodeMirrorEditor -> unit) option\n    mutable editorO : CodeMirrorEditor option\n    disabled        : Val<bool>\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        onRender = None\n        editorO  = None\n        disabled = Val.fixit false\n      }\n  member        this.Render                 =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                   async {\n                       do! LoadFiles.LoadFilesAsync codeMirrorIncludes\n                       let editor        = CodeMirrorEditor.SetupEditor el\n                       this.editorO     <- Some editor\n                       this.onRender |> Option.iter (fun onrender -> onrender editor)\n                       let editorChanged = ref 0L\n                       let varChanged    = ref 0L\n                       editor.On(\"changes\", fun (_cm, _change) ->\n                           let v = editor.GetValue() \n                           if this.var.Value <> v then editorChanged := !editorChanged + 1L; this.var.Value <- v; this.onChange() \n                       )\n                       this.var.View |> View.Sink (fun _ ->\n                           if  !editorChanged      > !varChanged    then varChanged := !editorChanged\n                           elif editor.GetValue() <> this.var.Value then editor.SetValue this.var.Value ; editor.ClearHistory()\n                       )\n                       this.disabled |> Val.sink (fun dis -> editor.SetOption(\"readOnly\", if dis then \"nocursor\" :> obj else false :> obj) )\n                   } |> Async.Start\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/hint/show-hint.css\"     ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/lint/lint.css\"          ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.OnRender f    = { this with onRender  = Some f         }\n  member inline this.Disabled dis  = { this with disabled  = Val.fixit dis  }\n  member inline this.Var           = this.var\n  static member  New(v:string)             = CodeMirror.New(Var.Create v)\n  static member  New(v:Var<string option>) = CodeMirror.New(Var.Lens v (Option.defaultValue \"\") (fun sO s -> sO |> Option.map (fun _ -> s) )).Disabled(v |> Val.map Option.isNone)\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}, {"SnippetId" :"4180353c-9dc5-438d-862d-851539b02075"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a05dd36e-a15e-4394-8013-128e21e69574"}, "snpName": "CodeMirror Hints", "snpContent": "\ntype Hint = {\n    text        : string\n    displayText : string\n    className   : string\n}\n\ntype HintResponse  = {\n    list           : Hint []\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype HintFunc      = FuncWithArgs<CodeMirrorEditor * (HintResponse -> unit) * obj,  unit>\n\ntype HintOptions   = {\n    hint           : HintFunc\n    completeSingle : bool   \n    container      : Dom.Element\n}\n\n[< Inline \"($_v.hint.async = 1, $_ed.showHint($_v))\"          >]\nlet showHint_ (_ed:CodeMirrorEditor) _v : unit       = X<_>\nlet showHints (ed:CodeMirrorEditor) getHints completeSingle _ =\n    showHint_ ed\n        {  completeSingle = completeSingle\n           hint           = HintFunc getHints\n           container      = ed.GetWrapperElement() |> findRootElement\n        }\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"18d8153d-422c-42f6-8266-9a9d854bd6a1"}, "snpName": "CodeMirror Lint", "snpContent": "type LintResponse  = {\n    message        : string\n    severity       : string\n    from           : CodeMirrorPos   \n    ``to``         : CodeMirrorPos   \n}\n\ntype LintFunc      = FuncWithArgs<string * (LintResponse[] -> unit) * obj * CodeMirrorEditor,  unit>\n\n[< Inline \"($_ed.setOption('lint', { async: 1, getAnnotations: $_f, container: $_elm }))\"          >]\nlet setLint_(_ed:CodeMirrorEditor) (_f:LintFunc) (_elm:Dom.Element)  : unit = X<_>\nlet setLint (ed:CodeMirrorEditor) getAnnotations       = \n    setLint_ ed (LintFunc getAnnotations) (ed.GetWrapperElement() |> findRootElement)\n\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}, "snpName": "SplitterBar", "snpContent": "[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : Var<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit   5.0\n            max      = Val.fixit  95.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging (_: Dom.Element) (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                this.dragging <- true\n                this.startVer <- this.vertical |> Val.toView |> View.TryGet |> Option.get\n                this.startP   <- this.GetValue |> Val.toView |> View.TryGet |> Option.get\n                this.start    <- mouseCoord ev\n                this.size     <- size()\n                JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                ev.PreventDefault()\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5878287a-a18f-4c71-b086-bd6e146270a1"}, "snpName": "ResizeObserver", "snpContent": "[< Inline \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] \nlet implementedResizeObserver() = false\n\n[< Inline \"new ResizeObserver($_f)\" >]\nlet newResizeObserver (_f: unit->unit) = X<_> \n\n[< Inline \"$_ro.observe($_el)\" >]\nlet RObserve _ro (_el:Dom.Element) = X<_> \n\nlet mutable observers : obj list = []\n\nlet domRect2Tuple (r:Dom.DomRect) = (r.Top, r.Left, r.Width, r.Height)\n\nlet [< Inline \"$_el.isConnected\" >] isValidElement (_el:Dom.Element) = true\n\nlet dimsChanged (el:Dom.Element) = \n    let dims = ref <| el.GetBoundingClientRect()\n    fun () ->\n        let ndims = el.GetBoundingClientRect()\n        if domRect2Tuple !dims = domRect2Tuple ndims then false\n        else dims := ndims    ; true\n\nlet addResizeObserver f el =\n    if implementedResizeObserver() then\n        let ro =  newResizeObserver f\n        observers <- ro::observers\n        RObserve ro el\n    else\n        let changed = dimsChanged el\n        async {\n            while isValidElement el do\n                do! Async.Sleep 110\n                if changed() then f()\n        } |> Async.Start\n        ", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, "snpName": "Grid", "snpContent": "[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\ntype SectionType =\n| StVariable\n| StFixedPx\n| StFixedPerc\n\nlet setVar (vr:Var<_>) vl = if vr.Value <> vl then vr.Value <- vl \n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    widthHeight   : Var<float * float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       widthHeight   = Var.Create (1000.0, 100.0)\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: Var<float>, col) =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n    member this.NewSplitter        (f: float, col) = this.NewSplitter(Var.Create f, col)\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter(f, true)\n    member inline this.ColVariable (f:Var<float>)  = this.NewSplitter(f, true)\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter(f, false)\n    member inline this.RowVariable (f:Var<float>)  = this.NewSplitter(f, false)\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto             _spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto             _spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols (Val.map fst this.widthHeight)\n          style1 \"grid-template-rows\"    <| this.style this.rows (Val.map snd this.widthHeight)\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s; dispxlay: grid\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    |_i, Auto    _spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    |_i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    |_i, Auto    _spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    |_i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setDimensions () =\n                    el.GetBoundingClientRect()\n                    |> fun r -> setVar this.widthHeight (r.Width, r.Height)\n                //async {\n//                    do! Async.Sleep 60\n                do  setDimensions()\n                //} |> Async.Start\n                addResizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()\n    static member inline NewBisect(first, secT, ver, per:Var<float>, ch1, ch2) =\n        let sect, auto, areas = \n            if ver then match secT with\n                        | StVariable  -> fun (g:Grid) -> g.ColVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.ColFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.ColFixed    per\n                       ,                (fun (g:Grid) -> g.ColAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one   two' \" )\n                   else match secT with\n                        | StVariable  -> fun (g:Grid) -> g.RowVariable per\n                        | StFixedPx   -> fun (g:Grid) -> g.RowFixedPx  per\n                        | StFixedPerc -> fun (g:Grid) -> g.RowFixed    per\n                       ,                (fun (g:Grid) -> g.RowAuto 50.0)\n                       ,                 fun (g:Grid) -> g.Content( style \"grid-template-areas: 'one' 'two' \" )\n        Grid.New.Content(\"one\", ch1)\n                .Content(\"two\", ch2).Padding(0.0)\n        |> areas\n        |> (if first then sect >> auto\n                     else auto >> sect)\n        ", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"5878287a-a18f-4c71-b086-bd6e146270a1"}, {"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}, "snpName": "TabStrip", "snpContent": "let reorderList (ts:'a list) drag drop =\n    if drop < drag then\n       ts.[0       ..drop - 1     ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop    ..drag - 1     ]\n     @ ts.[drag + 1..ts.Length - 1]\n    else\n       ts.[0..drag - 1            ]\n     @ ts.[drag + 1..drop         ]\n     @    [      ts.[drag]        ]\n     @ ts.[drop + 1..ts.Length - 1]\n\nlet reorderArray (ts:'a []) drag drop =\n   (if drop < drag then\n      [|\n       ts.[0       ..drop - 1     ]\n       [|        ts.[drag]       |]\n       ts.[drop    ..drag - 1     ]\n       ts.[drag + 1..ts.Length - 1]\n      |]\n    else\n      [|\n       ts.[0..drag - 1            ]\n       ts.[drag + 1..drop         ]\n       [|        ts.[drag]       |]\n       ts.[drop + 1..ts.Length - 1]\n      |]\n   )|> Array.collect id \n\n\n[< NoComparison >]\ntype TabStrip =\n    { selected  : Var<int>\n      tabs      : Var<(System.Guid * (string * HtmlNode)) []>\n      top       : bool\n      horizontal: bool\n      id        : System.Guid\n    } \n\nlet draggedTab: (TabStrip * int) option ref = ref None\n\nlet uid2s (uid: System.Guid) = \"X\" + uid.ToString().Replace(\"-\", \"\")\n\nlet selectedPanels: Var<Map<System.Guid, System.Guid>> = Var.Create Map.empty \n\nlet setSelectedPanel group panelO = \n    selectedPanels.Value <- \n        match panelO with\n        | Some panel -> selectedPanels.Value.Add    (group, panel)\n        | None       -> selectedPanels.Value.Remove  group\n\nlet mutable TabMoved : ((TabStrip * TabStrip) -> unit) option = None\nlet RaiseTabMoved fromS toS = TabMoved |> Option.iter (fun f -> f (fromS, toS))\n\ntype TabStrip with\n    member this.moveTab from drag drop =\n        let ts = this.tabs.Value\n        let ft = from.tabs.Value\n        let newTabsT =\n            [|\n             ts.[0       ..drop - 1     ]\n             [|        ft.[drag]       |]\n             ts.[drop    ..ts.Length - 1]\n            |]\n            |> Array.collect id\n        let newTabsF =\n            [|\n             ft.[0       ..drag - 1     ]\n             ft.[drag + 1..ft.Length - 1]\n            |]\n            |> Array.collect id\n        from.tabs.Value     <- newTabsF\n        this.tabs.Value     <- newTabsT\n        this.selected.Value <- drop\n        if from.selected.Value >= newTabsF.Length then from.selected.Value <- 0\n        RaiseTabMoved from this\n\n    member this.reorder drop =\n        match !draggedTab with\n        | None                                      -> ()\n        | Some( from, drag) when from.id <> this.id -> this.moveTab from drag drop\n        | Some(_from, drag)                         ->\n        this.tabs.Value     <- reorderArray this.tabs.Value drag drop\n        let sel = this.selected.Value\n        this.selected.Value <- if    sel = drag                then drop\n                               elif (sel < drag && sel < drop)\n                                 || (sel > drag && sel > drop) then sel \n                               elif  sel < drag                then sel + 1\n                               else                                 sel - 1\n                               \n    static member New(tabs)    =\n        { selected   = Var.Create 0\n          tabs       = tabs \n          top        = false \n          horizontal = true\n          id         = System.Guid.NewGuid() \n        } \n    static member New(tabs) = TabStrip.New(tabs |> Seq.map (fun def -> System.Guid.NewGuid(), def) |> Seq.toArray |> Var.Create)\n    member this.Top         = { this with top        = true  }\n    member this.Bottom      = { this with top        = false }\n    member this.SetTop    t = { this with top        = t     }\n    member this.Horizontal  = { this with horizontal = true  }\n    member this.Vertical    = { this with horizontal = false }\n    member this.Selected    = Val.map2 (fun tabs sel -> tabs |> Seq.tryItem sel |> Option.map fst) this.tabs this.selected\n    member this.Select    n = this.selected.Value <- n\n    member this.Select   nm = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (_ , (tn, _))) -> if tn = nm then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Select   gi = this.tabs.Value |> Seq.indexed |> Seq.tryPick (fun (i, (ti, (_ , _))) -> if ti = gi then this.selected.Value <- i ; Some true else None) |> Option.defaultValue false\n    member this.Render      =\n        let strip =\n            this.tabs\n            |> bindHElem (\n                fun tabs ->\n                    div [ yield ``class`` <| sprintf \"tab-strip %s %s\"\n                                                (if this.top        then \"top\"        else \"bottom\"  ) \n                                                (if this.horizontal then \"horizontal\" else \"vertical\")\n                          \n                          for i, (_uid, (txt, _)) in  tabs |> Seq.indexed  do\n                              yield Hoverable.New.Content(\n                                    div [ htmlText txt\n                                          ``class`` <| Val.map (fun sel -> \"tab\" + (if sel = i then \" selected\" else \"\")) this.selected\n                                          draggable \"true\"\n                                          SomeAttr <| on.dragOver(fun _  ev -> ev.PreventDefault()                            )\n                                          SomeAttr <| on.drag    (fun _  _  ->                     draggedTab := Some(this, i))\n                                          SomeAttr <| on.drop    (fun _e ev -> ev.PreventDefault(); ev.StopPropagation() ; this.reorder i )\n                                          SomeAttr <| on.click   (fun _  _  ->                       this.selected.Value <- i ) \n                                        ])\n                        ]\n            )\n        Val.sink (setSelectedPanel this.id) this.Selected  \n        let content = \n            this.tabs\n            |> bindHElem (fun tabs ->\n                div [\n                  yield  ``class`` \"tab-children\"\n                  yield  Id <| uid2s this.id\n                  yield!\n                      tabs\n                      |> Seq.map (fun (uid, (_txt, sub)) -> \n                          sub.AddChildren(\n                            [ style <| Val.map (fun sels -> if sels |> Map.toSeq |> Seq.map snd |> Seq.contains uid then \"\" else \"display : none\") selectedPanels\n                              Id    <| uid2s uid\n                            ]))\n                ] \n             )\n        div [ ``class`` \"tab-panel\"\n              (if     this.top then strip else HtmlEmpty)\n              div [ content ; ``class`` \"tab-content\" ]\n              (if not this.top then strip else HtmlEmpty)\n              SomeAttr <| on.dragOver(fun _  ev -> ev.PreventDefault()                                      )\n              SomeAttr <| on.drop    (fun _e ev -> ev.PreventDefault() ; this.reorder this.tabs.Value.Length)\n              css @\"\n\n.tab-panel {\n overflow  : hidden   ;\n display   : flex     ;\n flex-flow : column   ;\n background: lightgray;\n}\n.tab-content {\n flex      : 1 1     ;\n overflow  : auto    ;\n position  : relative;\n}\n.tab-children {\n height    : 100%    ;\n width     : 100%    ;\n position  : absolute;\n display   : grid    ;\n}\n.tab-strip {\n padding   : 0pt     ;\n flex      : 0 0     ;\n}\n.tab {\n border     : 0.2pt solid transparent;\n padding    : 0pt 4pt;\n display    : inline-block;\n font-family: sans-serif;\n font-weight: 200;\n font-size  : small;\n color      : #666;\n cursor     : pointer;\n}\n.top>.tab {\n border-radius: 2pt 2pt 0pt 0pt;\n border-bottom-width: 0pt;\n vertical-align: bottom;\n}\n.bottom>.tab {\n border-top-width: 0pt;\n border-radius: 0pt 0pt 2pt 2pt;\n vertical-align: top;\n}\n.horizontal>.tab:not(:first-child) {\n border-left-width: 0pt;\n}\n.tab.hovering {\n background: red;\n}\n.tab.selected {\n background: white;\n border-left-width: 0.2pt;\n color: black;\n font-weight: 500;\n border-color: black;\n}\n.horizontal>.tab.selected {\n border-left-width: 0.2pt;\n}\n\"]", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a48d72fc-5220-4dac-b3b3-98bad48b0561"}, "snpName": "SplitterNode", "snpContent": "#nowarn \"1178\"\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | SHtmlNode of HtmlNode\n    | STabStrip of TabStrip\n    | Split     of SplitterNode * SplitterNode * (SplitterNode -> SplitterNode -> HtmlNode)\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | SHtmlNode node        -> node\n        | STabStrip strip       -> strip.Render  \n        | Split   (ch1, ch2, f) -> f ch1 ch2\n\nlet renderSplitter (per:float) ver ch1 ch2 = Grid.NewBisect(true, StVariable, ver, Var.Create per, renderSplitterNode ch1, renderSplitterNode ch2).Render\n\ntype SplitterStructure with    \n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2     ) = Split(SplitterNode (Var.Create              child1), SplitterNode (Var.Create              child2), renderSplitter 50.0 vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| SHtmlNode child1), SplitterNode (Var.Create <| SHtmlNode child2), renderSplitter per  vertical)\n    static member New(vertical : bool, child1, child2, per) = Split(SplitterNode (Var.Create <| STabStrip child1), SplitterNode (Var.Create <| STabStrip child2), renderSplitter per  vertical)\n    static member New(ss1, ss2, f                         ) = Split(SplitterNode (Var.Create ss1                ), SplitterNode (Var.Create ss2                ), f                      )\n    static member New(strip                               ) = STabStrip strip\n    static member New(node                                ) = SHtmlNode node\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, STabStrip node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, SHtmlNode node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.Navigate recFun                    =\n        match this.Value with\n        | SHtmlNode _           \n        | STabStrip _           -> recFun this.Value\n        | Split   (ch1, ch2, f) -> ch1.Navigate recFun || ch2.Navigate recFun\n    member this.SelectTab  (nm: string)            = this.Navigate (function | STabStrip strip -> strip.Select nm | _ -> false) \n    member this.IsEmpty                            =\n        match this.Value with\n        | SHtmlNode HtmlEmpty   -> true\n        | SHtmlNode _           -> false\n        | STabStrip strip       -> strip.tabs.Value.Length = 0\n        | Split   (ch1, ch2, f) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ch1, ch2, f) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                   elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                    else ch1.UnSplitEmpties()\n                                                         ch2.UnSplitEmpties()\n        | _                     -> ()  \n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}, "snpName": "MenuBar", "snpContent": "let inline menuEntry content   = li [ content ]\nlet inline refA      cont  t r = a  [ cont ; hrefO r ; target t ] \nlet inline refText   txt  _t r = bindHElem (fun t -> if t = \"\" then HtmlEmpty else refA(htmlText t) t r) txt\nlet inline entryTxt  txt   t r = menuEntry (refText  txt t  r)\n  \nlet inline entries    ch cl    =  ul ch |> addClass cl\nlet inline nav        ch       =  entries ch \"nav navbar-nav\"\nlet inline dropdown   ch       =  entries ch \"dropdown-menu\"\nlet navbar brand center right  =\n    div [ ``class``                     \"navbar navbar-default\"\n          div [ ``class``               \"container-fluid\"\n                div [ ``class``         \"navbar-header\"\n                      div [ ``class``   \"navbar-brand\"\n                            brand\n                          ]\n                    ]\n                div [ ``class``         \"navbar-collapse collapse\"\n                      center\n                      right |> addClass \"navbar-right\"\n                    ]\n              ]\n    ]\n    \n#nowarn \"1178\"    \n\ntype MenuEntry = {\n    text       : Val<string>\n    ref        : Val<string option>\n    active     : Val<bool>\n    disabled   : Val<bool>\n    subMenu    : Menu option\n    toolTip    : string option\n    target     : string option\n    divider    : bool\n    onClick    : (Dom.Element -> Dom.MouseEvent -> unit) option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        active    = Val.fixit  false \n        ref       = Val.Constant None\n        toolTip   = None\n        subMenu   = None\n        onClick   = None\n        target    = None\n        divider   = false\n        disabled  = Val.fixit false\n    } \n    static member inline New(txt, ref) = { MenuEntry.New(txt) with ref      = Val.map Some ref }\n    member this.Render           = \n        entryTxt this.text (this.target |> Option.defaultValue \"\") this.ref \n        |> addClassIf \"active\" this.active |> addClassIf \"disabled\" this.disabled\n        |> match this.subMenu with | None  -> id | Some m -> addChildren [ ``class`` \"dropdown\" ; m.Render ]\n        |> match this.onClick with | None  -> id | Some f -> addChildren [ SomeAttr  <| on.click <@ f @>   ; style \"cursor : pointer\" ]\n        |> match this.divider with | false -> id | true   -> addClass    \"divider\"\n    member inline this.Target   t   = { this with target   = Some t                         }\n    member inline this.Divider      = { this with divider  = true                           }\n    member inline this.OnClick  f   = { this with onClick  = Some f                         }\n    member inline this.Disabled dis = { this with disabled = Val.fixit dis                  }\n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New( es).DropDown } \n    member inline this.SubMenu  es  = { this with subMenu  = Some <| Menu.New2(es).DropDown } \n    member        this.MenuNode     = MenuEntry this\nand MenuNode =\n    | MenuHtml  of HtmlNode\n    | MenuEntry of MenuEntry \n  with\n    member this.Render = match this with | MenuHtml h -> h | MenuEntry e -> e.Render\nand Menu = {\n    entries  : MenuNode seq\n    dropdown : bool\n} with\n    static member New es : Menu = { \n        entries = es\n        dropdown = false\n    }    \n    static member New2 es : Menu = Menu.New(es |> Seq.map MenuEntry) \n    member this.DropDown        = { this      with dropdown = true  }\n    member this.Render          =\n        (if this.dropdown then dropdown else nav) <|\n            seq [\n                for entry in this.entries -> \n                    entry.Render\n            ]", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}, "snpName": "Action", "snpContent": "[<NoComparison ; NoEquality>]\ntype Action = {\n    text       : Val<string>\n    highlight  : Val<bool>\n    disabled   : Val<bool>\n    toolTip    : string option\n    onClick    : (Action -> Dom.Element -> Dom.MouseEvent -> unit) option\n    parms      : obj[] option\n} with\n    static member inline New txt = { \n        text      = Val.fixit  txt\n        highlight = Val.fixit  false \n        disabled  = Val.fixit  false\n        toolTip   = None\n        onClick   = None\n        parms     = None\n    } \n    member inline this.Text      txt = { this with text      = Val.fixit txt\n                                                   disabled  = Val.fixit false  }\n    member inline this.Parms     ps  = { this with parms     = Some ps          }\n    member inline this.OnClick   f   = { this with onClick   = Some (fun _ -> f)}\n    member inline this.OnClick2  f   = { this with onClick   = Some f           }\n    member inline this.Disabled  dis = { this with disabled  = Val.fixit dis    }\n    member inline this.Highlight h   = { this with highlight = Val.fixit h      }\n    member        this.MenuEntry     = {\n        MenuEntry.text      = this.text\n        MenuEntry.active    = this.highlight \n        MenuEntry.disabled  = this.disabled\n        MenuEntry.toolTip   = this.toolTip\n        MenuEntry.onClick   = this.onClick |> Option.map (fun f -> f this)\n        MenuEntry.ref       = Val.Constant None\n        MenuEntry.divider   = false\n        MenuEntry.subMenu   = None\n        MenuEntry.target    = None\n    }\n    member        this.Button       = {\n        Button.text      = this.text\n        Button.disabled  = this.disabled\n        Button.onClick   = this.onClick |> Option.map (fun f -> f this) |> Option.defaultValue (fun _ _ -> ())\n//        Button.toolTip   = this.toolTip\n        Button._class    = Val.map (fun h -> if h then \"btn btn-primary\" else \"btn\") this.highlight \n        Button._type     = Val.fixit \"button\" \n        Button.style     = Val.fixit \"\"\n        Button.id        = \"\"\n      }\n\nlet Do  f p = (fun     _ _ -> f     p)\nlet Do2 f p = (fun act _ _ -> f act p)\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, {"SnippetId" :"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}, "snpName": "Layout", "snpContent": "open Useful\n\ntype GuiPart     = \n   | GuiRoot       of string\n   | GuiNode       of HtmlNode\n   | GuiAction     of Action\n   | GuiSplit      of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip   of top  : bool * string []\n   | GuiCall       of name: string * action: string * parms: string[]\n\nlet HtmlGuiCall (p: string * string * string[]) = GuiCall p\n\ntype HtmlNodeFable = {\n    HtmlElementF    : (string * HtmlNodeFable [] ) option\n    HtmlAttributeF  : (string * string           ) option\n    HtmlAttributeOF : (string * string option    ) option\n    HtmlTextF       :  string                      option\n    HtmlEmptyF      :  string                      option\n    HtmlGuiPart     :  string                      option\n    HtmlGuiCall     : (string * string * string[]) option\n}\n\ntype LayoutDescriptionFable = \n    {\n       GuiRoot     :  string                                                          option  \n       GuiTabStrip : (bool * string[]                                               ) option\n       GuiSplit    : (bool * string * bool * float * string * string * float * float) option  \n       GuiNode     :  HtmlNodeFable                                                   option\n       GuiCall     : (string * string * string[]                                    ) option\n    }\n\ntype GuiPartSourceId =\n    | GPSI_Internal   of System.Guid\n    | GPSI_Json       of LayoutDescriptionFable\n    | GPSI_Root       of string\n    | GPSI_TabStrip   of bool * string[]                                               \n    | GPSI_Split      of first: bool * secT: SectionType * vertical: bool * string * string\n    | GPSI_Call       of string * string * string[]                                    \n    with static member New =  GPSI_Internal <| System.Guid.NewGuid()\n\nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string,GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        Map.add name guiPart parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n\nlet inline addValue k v (dict: System.Collections.Generic.Dictionary<_, _>) = \n    dict.Remove k |> ignore\n    dict.Add(k, v)\n\nlet (|PHtmlElementF   |_|) (hnf: HtmlNodeFable) = hnf.HtmlElementF   \nlet (|PHtmlAttributeF |_|) (hnf: HtmlNodeFable) = hnf.HtmlAttributeF \nlet (|PHtmlAttributeOF|_|) (hnf: HtmlNodeFable) = hnf.HtmlAttributeOF\nlet (|PHtmlTextF      |_|) (hnf: HtmlNodeFable) = hnf.HtmlTextF      \nlet (|PHtmlEmptyF     |_|) (hnf: HtmlNodeFable) = hnf.HtmlEmptyF     \nlet (|PHtmlGuiPart    |_|) (hnf: HtmlNodeFable) = hnf.HtmlGuiPart     \nlet (|PHtmlGuiCall    |_|) (hnf: HtmlNodeFable) = hnf.HtmlGuiCall\n\nlet (|PGuiTabStrip|_|) (ldf:LayoutDescriptionFable) = ldf.GuiTabStrip  \nlet (|PGuiSplit   |_|) (ldf:LayoutDescriptionFable) = ldf.GuiSplit \nlet (|PGuiRoot    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiRoot  \nlet (|PGuiNode    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiNode  \nlet (|PGuiCall    |_|) (ldf:LayoutDescriptionFable) = ldf.GuiCall  \n\nlet toSect s =\n    match s with \n    | \"StVariable\"  -> StVariable\n    | \"StFixedPx\"   -> StFixedPx\n    | _             -> StFixedPerc\n\n[<NoComparison ; NoEquality>]\ntype Layout = {\n    parts         : System.Collections.Generic.Dictionary<string, Var<GuiPartSourceId * GuiPart> * HtmlNode * Val<GuiPart -> unit>>\n    tabStrips     : System.Collections.Generic.Dictionary<string, TabStrip>\n}\n\nlet t1of3 = function v, _, _ -> v\nlet t2of3 = function _, v, _ -> v\nlet t3of3 = function _, _, v -> v\n\ntype GuiPart with\n    member this.GetHtmlNode (lyt: Layout) name =\n        match this with\n        | GuiRoot    _root                                             -> HtmlEmpty                          , ignore\n        | GuiNode     node                                             -> node                               , ignore\n        | GuiAction   act                                              -> act.Button.Render                  , ignore\n        | GuiCall    (name, action, parms)                             -> lyt.GetCallButton name action parms, ignore\n        | GuiTabStrip(top  , nodes                                   ) -> let ts = TabStrip.New(nodes |> Seq.map (fun node -> node, lyt.GetNode node)).SetTop(top)\n                                                                          addValue name ts lyt.tabStrips\n                                                                          ts.Render                          , ignore\n        | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> let minV   = Var.Create min\n                                                                          let maxV   = Var.Create max\n                                                                          let perV   = Var.Create per\n                                                                          let curper = ref        per\n                                                                          let grd = Grid.NewBisect(first, secT, vertical, perV, lyt.GetNode ch1, lyt.GetNode ch2).Min(minV).Max(maxV)\n                                                                          grd.Render\n                                                                         ,function \n                                                                          | GuiSplit   (_first, _secT , _vertical, per, _ch1, _ch2, min, max) -> \n                                                                              if !curper     <> per then\n                                                                                  curper     := per\n                                                                                  perV.Value <- per\n                                                                              minV.Value     <- min\n                                                                              maxV.Value     <- max\n                                                                          | _ -> ()\nand  Layout with\n    member this.GetGuiCallAction (name:string) (action:string) (parms:string[]) =\n        if this.parts.ContainsKey action then\n            match this.parts.[action] with\n            | partv, _, _ ->\n                match partv.Value with \n                | _, GuiAction act -> act.Text(name).Parms(parms |> Array.map (fun s -> s:>obj))           |> Result.succeed\n                | _                -> sprintf \"GuiPart %s is not a GuiAction\" action |> Result.failSimpleError\n        else                          sprintf \"GuiAction %s not found\"        action |> Result.failSimpleError\n    member this.GetCallButton name action parms =\n        match this.GetGuiCallAction name action parms with\n        | Result.Success(act, _) -> act.Button.Render\n        | Result.Failure ms      -> div [ ms |> Result.msgs2String |> String.concat \". \" |> htmlText ]\n    member this.AddNode name sid part =\n        let partV  = Var.Create (sid, part)\n        let nodeFv = partV  |> Val.map (fun (_si, p: GuiPart) -> p.GetHtmlNode this name)\n        let node   = nodeFv |> Val.map fst |> HtmlElementV \n        let update = nodeFv |> Val.map snd\n        this.parts.Add(name, (partV :> Var<_>, node, update))\n        node\n    member this.GetNode name =\n        let mutable res = Unchecked.defaultof<_>\n        let ok = this.parts.TryGetValue(name, &res)\n        if ok \n        then t2of3 res\n        else this.AddNode name GuiPartSourceId.New (GuiNode <| div [ htmlText (sprintf \"GuiPart %s not found\" name) ])\n    static member AddGuids steps = \n        steps \n        |> Seq.map (fun (name, part) -> \n            name\n           ,match part with\n             | GuiNode    _node                                             -> GuiPartSourceId.New\n             | GuiAction  _act                                              -> GuiPartSourceId.New\n             | GuiRoot     root                                             -> GPSI_Root     root                                            \n             | GuiSplit   (first, secT , vertical,_per, ch1, ch2,_min,_max) -> GPSI_Split   (first, secT , vertical, ch1, ch2)\n             | GuiTabStrip(top  , nodes                                   ) -> GPSI_TabStrip(top  , nodes                    )\n             | GuiCall    (name, action, parms)                             -> GPSI_Call    (name, action, parms)                            \n           ,part        )  \n        |> Seq.toArray\n    static member New(steps) =\n        let lyt = {\n            parts     = System.Collections.Generic.Dictionary<_, _>()\n            tabStrips = System.Collections.Generic.Dictionary<_, _>()\n        }\n        steps |> Seq.iter (fun (name, part, id) -> lyt.AddNode name part id |> ignore )\n        lyt\n    member this.Render  =\n        let node = \n            this.parts.Values \n            |> Seq.tryPick(t1of3 >> fun v -> match v.Value with | _, GuiRoot root -> Some root | _ -> None )\n            |> Option.defaultValue \"main\"\n        this.GetNode node\n    member this.AddNewSteps steps steps2 =\n        Array.append steps steps2\n        |> Array.groupBy (fun (name,_si,_part) -> name           )\n        |> Array.map     (fun(_name, det     ) -> det |> Seq.last)\n        |> Array.iter    (fun (name, si, part) -> if this.parts.ContainsKey name then\n                                                       let partv,_node, upd = this.parts.[name] \n                                                       let xsi,_xpart = partv.Value\n                                                       if xsi = si \n                                                       then Val.apply (Val.Constant part) upd |> Val.iter id\n                                                       else partv.Value <- (si, part)\n                                                  else this.AddNode name si part |> ignore\n        ) \n    member this.SetLayoutJson steps json =\n        let rec jsonF2HtmlNode =\n           function\n           | PHtmlElementF    (name, ch)          -> Some <| HtmlElement   (name, ch |> Seq.choose jsonF2HtmlNode)\n           | PHtmlAttributeF  (name, v )          -> Some <| HtmlAttribute (name, Val.Constant v  )\n           | PHtmlAttributeOF (name, vO)          -> Some <| HtmlAttributeO(name, Val.Constant vO )\n           | PHtmlTextF        txt                -> Some <| HtmlText      (      Val.Constant txt)\n           | PHtmlEmptyF       _                  -> Some <| HtmlEmpty\n           | PHtmlGuiPart      part               -> Some <| this.GetNode part\n           | PHtmlGuiCall     (name, call, parms) -> Some <| this.GetCallButton name call parms\n           | _                                    -> None\n        let jsonF2GuiRoot =\n           function\n           | PGuiNode      html                                                      -> Some <| GuiNode     (jsonF2HtmlNode html |> Option.defaultValue HtmlEmpty)\n           | PGuiRoot      root                                                      -> Some <| GuiRoot      root\n           | PGuiTabStrip  p                                                         -> Some <| GuiTabStrip  p\n           | PGuiSplit    (first, secT: string  , vertical, per, ch1, ch2, min, max) -> Some <| GuiSplit    (first, secT |> toSect, vertical, per, ch1, ch2, min, max)\n           | PGuiCall     (name, call, parms                                       ) -> Some <| GuiCall     (name, call, parms) \n           | _                                                                       -> None\n        try\n            let steps2 = if json = \"\" then [||] else\n                         json\n                         |> WebSharper.Json.Deserialize<(string * LayoutDescriptionFable)[]>\n                         |> Array.choose (fun (name, ldf) -> jsonF2GuiRoot ldf |> Option.map (fun v -> name, GPSI_Json ldf, v))\n            this.AddNewSteps steps steps2\n        with e -> printfn \"Error: %A\" e\n    member this.SelectTab (tName:string) =\n        this.tabStrips.Values\n        |> Seq.iter (fun ts -> ts.Select tName |> ignore )\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx  , false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixedVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx  , true , px, ch1, ch2, 5.0, 95.0)\nlet inline fixPcHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPerc, false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixPcVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPerc, true , px, ch1, ch2, 5.0, 95.0)\nlet inline varHorSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable , false, pc, ch1, ch2, min,  max)\nlet inline varVerSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable , true , pc, ch1, ch2, min,  max)\n\n", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}, {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}, {"SnippetId" :"f3c86328-e5b6-4ef1-a3d9-d82098f4ffe2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4bae423e-08d8-4c40-8d30-ffa15f9161d3"}, "snpName": "AllTemplates", "snpContent": "", "snpParentIdO": {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, "snpPredIds": [{"SnippetId" :"0a11766b-f227-4b38-88a3-919d964387bf"}, {"SnippetId" :"18d8153d-422c-42f6-8266-9a9d854bd6a1"}, {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"40614ad6-3f81-468b-a4ff-034124b82ae1"}, {"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}, {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}, {"SnippetId" :"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"}, {"SnippetId" :"8fb54777-3046-4aae-9282-33401a45c280"}, {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}, {"SnippetId" :"a05dd36e-a15e-4394-8013-128e21e69574"}, {"SnippetId" :"a48d72fc-5220-4dac-b3b3-98bad48b0561"}, {"SnippetId" :"aa485846-7b78-4ca8-ae22-84ba0c42d962"}, {"SnippetId" :"af2b60c6-a99f-433d-b938-f59fefe66c01"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpName": "RunCode", "snpContent": "[<JavaScript>]\nmodule RunCode       =", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"1095ae38-19fc-4195-840c-c368a3a486c4"}, {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"36fc221f-7e61-4a04-abf3-317f901e5211"}, "snpName": "completeJS", "snpContent": "let completeJS js = \n  \"\"\"", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"}, "snpName": "CIPHERSpaceLoadFiles", "snpContent": "    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      //try { window[key].$cctor(); } catch (e) {} \n      window[key].$cctor();\n  } \n})\n", "snpParentIdO": {"SnippetId" :"36fc221f-7e61-4a04-abf3-317f901e5211"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"afaac2af-143d-4745-9447-7e8d3044950f"}, "snpName": "\"\"\" + js", "snpContent": "                 \"\"\" + js", "snpParentIdO": {"SnippetId" :"36fc221f-7e61-4a04-abf3-317f901e5211"}, "snpPredIds": [{"SnippetId" :"a3676bbd-c1ea-4fc0-b599-6fde2c8d0816"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}, "snpName": "", "snpContent": "type RunNode(nodeName, ?clearNode: bool, ?useShadowRoot:bool) =\n  let bClearNode    = defaultArg clearNode     true\n  let useShadowRoot = defaultArg useShadowRoot true\n  let createNode() =\n      let e = JS.Document.CreateElement \"div\"\n      e?style <- \"height: 100%; width: 100%;\"\n      e\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      if not useShadowRoot then baseNode else\n      match baseNode.ShadowRoot with\n      | null -> let p = createNode()\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild p |> ignore\n                let e = createNode()\n                p.AppendChild e |> ignore\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool, ?useShadowRoot:bool) = RunNode(\"TestNode\", ?clearNode = clearNode, ?useShadowRoot = useShadowRoot)\n  member this.RunNode   = runNode\n", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"081bac32-e739-4124-87eb-eb7d6f2220bc"}, "snpName": "AddBootstrap", "snpContent": "  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.ParentElement.AppendChild el |> ignore\n    this", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6332dfb8-b57a-40de-b669-f796820883db"}, "snpName": "AddFontAwesome", "snpContent": "  member this.AddFontAwesome =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <-  @\"<link type='text/css' rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css'>\"\n        runNode.ParentElement.AppendChild el |> ignore\n    this", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"47bf25cf-e7f5-452a-9247-156146348a14"}, "snpName": "AddBulma", "snpContent": "  member this.AddBulma =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <-  @\"<link type='text/css' rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css'>\"\n        runNode.ParentElement.AppendChild el |> ignore\n    this", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}, "snpName": "RunDoc", "snpContent": "  member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"aba6c516-0ac9-4abe-95a2-7257d077e338"}, {"SnippetId" :"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}, "snpName": "RunHtml", "snpContent": "  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc\n  ", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"456562f7-0757-4431-9aeb-d58b050cecf7"}, "snpName": "RunHtmlPlusFree", "snpContent": "  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        Useful.Wrap.wrapper {\n            freeMsgs.Value <- \"Compiling to JavaScript...\"\n            freeJS.Value   <- \"\"\n            let    code      = freeFS.Value\n            let!   jsR       = FsTranslator.translateAR code false\n            let!   js        = jsR\n            let    jsc       = completeJS js\n            freeJS.Value    <- jsc\n            sendMsg            \"Compiled!\"\n            runJS()\n        } |> Useful.Wrap.start sendMsg\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}, {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, {"SnippetId" :"79f8f6c6-d1f5-4593-9775-60ba2863e94d"}, {"SnippetId" :"95a237c8-a9ff-40d1-bd72-bd298b20af8c"}, {"SnippetId" :"afaac2af-143d-4745-9447-7e8d3044950f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bf400a85-8264-4540-9381-f3be0c968c94"}, "snpName": "ShowHtmlResult", "snpContent": "  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"081bac32-e739-4124-87eb-eb7d6f2220bc"}, {"SnippetId" :"0a11766b-f227-4b38-88a3-919d964387bf"}, {"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}, "snpName": "ShowResult", "snpContent": "  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n", "snpParentIdO": {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, "snpPredIds": [{"SnippetId" :"bf400a85-8264-4540-9381-f3be0c968c94"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpName": "FSharpStation Code", "snpContent": "module FSharpStation =\n", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1787d1fe-db11-4716-b3f6-164048e8991b"}, "snpName": "CodeSnippet Extensions, Position", "snpContent": "open Template\nopen FsStationShared\nopen System.Collections.Generic\nopen Useful\nopen FsTranslator\nopen FsEvaluator\n\n[< JavaScript >]\nmodule FsGlobal =\n    [< Inline >]\n    let inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\n    \n    //let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n    //let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n\n    [< Inline \"(Date.now())\" >]\n    let now() = 0\n    let fsIds  = \"FSharpStation\" + (now() |> string)\n    \n    let tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n    \n    type CodeSnippet \n        with\n        static member PickIO       id   = codeSnippets.Value    |> tryPickI (fun (_, snp) -> snp.id = id)\n        static member FetchO       id   = codeSnippets.TryFindByKey id\n        static member FetchL       id   = CodeSnippet.FetchO id |> Option.toList\n        static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n        static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n        static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n        static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n        static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n        static member New(od, nm, pa, pred, co, cnt) =\n            let newS =\n                {\n                    name         = nm\n                    content      = cnt\n                    parent       = pa\n                    predecessors = pred\n                    id           = CodeSnippetId.New\n                    expanded     = true\n                    level        = 0\n                    levelCode    = 0\n                    properties   = System.Collections.Generic.Dictionary<string, string>()\n                }\n            match od, codeSnippets.Length with\n            | _, 0            -> codeSnippets.Append newS\n            | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n            | i, n when i < n -> codeSnippets.Value \n                                    |> Seq.toArray\n                                    |> Array.splitAt od\n                                    |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                    |> codeSnippets.Set \n            | _, _            -> codeSnippets.Append newS\n            newS\n        member this.Levels =\n            let rec levels (out, out2) snp = \n                snp.parent\n                |> Option.bind CodeSnippet.FetchO\n                |> Option.map (levels <| (out + 1, out2 + if snp.properties.ContainsKey \"NoIndent\" then 0 else 1)) \n                |> Option.defaultValue (out, out2)\n            levels (0, 0) this\n        member this.PrepareSnippet   =\n            let lvl, lvlCode = this.Levels\n            { this with level     = lvl\n                        levelCode = lvlCode\n                        content   = this.content\n                                        .Replace(\"##\" + \"FSHARPSTATION_ID\" + \"##\"      , fsIds                  )\n                                        .Replace(\"##\" + \"FSHARPSTATION_ENDPOINT\" + \"##\", JS.Window.Location.Href) }\n        member this.Predecessors     () =\n            let preds = this.UniquePredecessors CodeSnippet.FetchO |> Seq.toArray\n            codeSnippets.Value\n            |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n            |> Seq.map    (fun snp -> snp.PrepareSnippet)\n            |> Seq.toArray\n        member this.GetCodeAndStarts addLinePrepos = this.Predecessors() |> CodeSnippet.CodeAndStarts addLinePrepos\n        member this.GetCodeFsx       addLinePrepos = this.GetCodeAndStarts addLinePrepos |> fst\n        member this.IsDescendantOf antId =\n            let rec isDescendantOf snp =\n                match snp.parent with\n                | None       -> false\n                | Some parId ->\n                if parId = antId then true else\n                CodeSnippet.FetchO parId\n                |> Option.map isDescendantOf\n                |> Option.defaultValue false\n            isDescendantOf this\n        static member FetchByPathO names      = \n            let tryFindByName      snps name  = snps |> Seq.filter (fun (snp:CodeSnippet) -> snp.Name = name) |> Seq.tryHead\n            let rec tryFindByPath  snps names = \n                let first = names |> Seq.tryHead |> Option.bind (tryFindByName snps)\n                if names |> Seq.length <= 1 then first else\n                first\n                |> Option.bind (fun f ->\n                    names \n                    |> Seq.tail\n                    |> tryFindByPath  (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent = Some f.id))\n                )\n            names \n            |> tryFindByPath (codeSnippets.Value |> Seq.filter (fun snp -> snp.parent.IsNone))\n        member this.propValue p =\n            if this.properties.ContainsKey p \n            then Some this.properties.[p]\n            else this.parent |> Option.bind CodeSnippet.FetchO |> Option.bind (fun par -> par.propValue p)\n    \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n    \n    type ErrCompiler =\n        | JsCompilerMsg  of string * bool\n        | ``Snippet Missing``\n        | ``Could not open new browser, Popup blocker may be active``\n        interface ErrMsg with\n            member this.ErrMsg   : string = \n                match this with \n                | JsCompilerMsg(msg, err) -> sprintf \"%s\" msg\n                | _                       -> sprintf \"%A\" this\n            member this.IsWarning: bool   = \n                match this with \n                | JsCompilerMsg(msg, err) -> not err\n                | _                       -> false\n                \n    [< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\n    let saveAs (txt:string) (name:string) = ()\n    \n    type KeyMapAutoComplete = { \n        F2              : Template.CodeMirrorEditor -> unit \n        LeftDoubleClick : Template.CodeMirrorEditor -> unit\n        ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n        ``.``           : Template.CodeMirrorEditor -> unit\n    }\n    \n    type Property(setDirty: unit->unit, props: Dictionary<string, string>, keyP: string) =\n        inherit Var<string>()\n        let mutable key = keyP\n        let getK () = key\n        let setK k  = props.Add(k, props.[key]) ; props.Remove key |> ignore ; key <- k ; setDirty()\n        let getV () = props.[key]\n        let setV v  = props.[key] <- v ; setDirty()\n        override this.Id  = \"?\"\n        override this.SetFinal                              v = setK v\n        override this.Set                                   v = setK v\n        override this.Get ()                                  = getK()\n        override this.Update      (f:string -> string       ) = getK() |> f |>             setK\n        override this.UpdateMaybe (f:string -> string option) = getK() |> f |> Option.iter setK\n        override this.View                     : View<string> = getK() |> View.Const\n        member this.KeyVar   = this :> Var<string>  \n        member this.ValueVar = PropValue this\n        member this.GetK     = getK\n        member this.SetK     = setK\n        member this.GetV     = getV\n        member this.SetV     = setV\n        member this.Remove() = props.Remove key |> ignore ; setDirty()\n\n    and PropValue(prop: Property) =\n        inherit Var<string>()\n        let get  = prop.GetV\n        let set  = prop.SetV\n        override this.Id  = \"?\"\n        override this.SetFinal                              v = set v\n        override this.Set                                   v = set v\n        override this.Get ()                                  = get()\n        override this.Update      (f:string -> string       ) = get() |> f |>             set\n        override this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n        override this.View                     : View<string> = get() |> View.Const\n\n    let [< Inline >] inline genericPropertyVal currentCodeSnippetId p def f =\n        currentCodeSnippetId\n        |> Val.map\n            (CodeSnippet.FetchO\n             >> Option.bind (fun snp -> snp.propValue p |> Option.map f)\n             >> Option.defaultValue def\n            )\n        |> Val.consistent\n\n    let [< Inline \"Object.constructor('return function(parm) { return `' + $template + '`}')()($p)\" >] translateTemplate (template: string) p = \"\"\n\n\nopen FsGlobal                \n\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"2deb54e7-009e-4297-b2bc-1c86d04203a4"}, {"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"336d6f19-0c57-4af9-8716-1b3fbf6b112c"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}, {"SnippetId" :"95a237c8-a9ff-40d1-bd72-bd298b20af8c"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dca77d6a-5c2c-4c3e-9bef-14f0464f9ada"}, "snpName": "FableModule", "snpContent": "[< JavaScript >]\nmodule FableModule =\n    //open Useful\n    \n    //[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    type Babel() =    \n        [< Inline \"Babel.transformFromAst($ast , null, $options)\"                  >] static member transformFromAst(ast , xx, options)                = X<_>\n        [< Inline \"Babel.transform       ($ast ,       $options)\"                  >] static member transform       (ast ,     options)                = X<_>\n    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\")                          >]\n    type Fable() =\n        [< Inline \"Fable.createChecker($f, $references)\"                           >] static member createChecker(f, references)  : obj                = X<_>\n        [< Inline \"Fable.makeCompiler($replacements)\"                              >] static member makeCompiler(replacements)    : obj                = X<_>\n        [< Inline \"Fable.parseFSharpProject($checker, $com, $fileName, $source)\"   >] static member parseFSharpProject(checker, com, fileName, source) = X<_>\n        [< Inline \"Fable.compileAst($com, $fsharpAst, $fileName)\"                  >] static member compileAst(com, fsharpAst, fileName)               = X<_>\n        [< Inline \"Fable.convertToJson($babelAst)\"                                 >] static member convertToJson(babelAst)                            = X<_>\n    \n    let [< Inline \"getFileBlob($key, $url)\"                                        >] getFileBlob(key, url)                                            = X<_>\n    let [< Inline \"metadata[$fn]\"                                                  >] readAllBytes fn                                                  = X<_>\n    let [< Inline \"Object.getOwnPropertyNames(metadata).length\"                    >] metadataLength (): int                                           = X<_>\n    let [< Inline \"babelPlugins\"                                                   >] babelPlugins () : obj                                            = X<_>\n    \n    \n    let references = [|\n        \"mscorlib.dll\"\n        \"System.dll\"\n        \"System.Core.dll\"\n        \"System.Data.dll\"\n        \"System.IO.dll\"\n        \"System.Xml.dll\"\n        \"System.Numerics.dll\"\n        \"FSharp.Core.sigdata\"\n        \"FSharp.Core.dll\"\n        \"Fable.Core.dll\"\n        \"Fable.Import.Browser.dll\"\n        // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n        // However, adding the following reference prevents opening System namespace\n        // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n        // \"System.ValueTuple.dll\",\n    |]\n\n    let loadReferences =\n        lazy\n            async {\n                do! LoadFiles.LoadFilesAsync [| \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\" |] \n                let  options          = Object.Create null\n                options?skipDataMain <- 1\n                options?isBrowser    <- 1\n                JS.Window?require?config options\n                references |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n            } |> Async.Start\n        \n    let getChecker = \n        lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n        \n    let mutable addOutMsg : string -> unit = Console.Log\n\n    let ToConsole arg = \n        Console.Log arg\n        arg?cont addOutMsg\n\n    let fableTranslate source : Wrap<string> =\n        Wrap.wrapper {\n            loadReferences.Value\n            do! async { \n                    while metadataLength() < references.Length do\n                        do! Async.Sleep 200\n                }\n            let  checker       = getChecker.Value\n            let  com           = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                     , \"FSSGlobal.FSharpStation.FableModule.ToConsole($0)\" |]  \n            let  fileName      = \"stdin.fsx\"\n            let  fsharpAst     = Fable.parseFSharpProject(checker, com, fileName, source)\n            let  babelAst      = Fable.compileAst(com, fsharpAst, fileName)\n            let  jsonAst       = Fable.convertToJson(babelAst)\n            let  ast           = JSON.Parse(jsonAst)\n            let  options       = Object.Create null\n            options?plugins   <- [| babelPlugins()?transformMacroExpressions\n                                    babelPlugins()?removeUnneededNulls \n                                    \"transform-es2015-modules-amd\"    \n                                 |]\n            options?presets   <- [|  |]\n            options?filename  <- fileName\n            options?babelrc   <- false\n            let  transformed   = Babel.transformFromAst(ast , null, options)\n            let  jCode2:string = transformed?code\n            let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                       .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n            return jCode3\n        }\n    \n    ", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"1787d1fe-db11-4716-b3f6-164048e8991b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8fbd59ac-9417-4309-8d01-3ccd5d62452c"}, "snpName": "CIPHERPrototype Module", "snpContent": "#r @\"ZafirTranspiler.dll\"\n    \n[< JavaScript >]\ntype CIPHERPrototypeMsg(msg: string, warning: bool) =\n    interface ErrMsg with\n        member this.ErrMsg    = msg\n        member this.IsWarning = warning\n\n[< JavaScript >]\nlet translateAR fsCode minified = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.translate fsCode minified\n        let!   js     = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return js\n    } |> Wrap.getAsyncR\n\n[< JavaScript >]\nlet evaluateAR  fsCode = \n    Wrap.wrapper {\n        let! vO, msgs = CIPHERPrototype.Editor.evaluate fsCode\n        let!   txt    = Result (vO, [ CIPHERPrototypeMsg(msgs, vO.IsNone) :> ErrMsg ])\n        return txt\n    } |> Wrap.getAsyncR\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpName": "FSharpStationClient", "snpContent": "[< JavaScript >]\nlet FSharpStationClient (loadFromUri: string) =\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"336d6f19-0c57-4af9-8716-1b3fbf6b112c"}, {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"987560b0-1fe6-4835-ad99-aed93db7da1a"}, "snpName": "currentCodeSnippetId", "snpContent": "\nlet missingVar  = Var.Create \"\"\nlet missing def find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> def) (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name      ) (fun s n -> { s with name       = n }) <| k\nlet curSnippetCodeOf k = missing \"\"        codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content   ) (fun s n -> { s with content    = n }) <| k\nlet curSnippetPrpsOf k = missing (System.Collections.Generic.Dictionary<string, string>()) codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.properties) (fun s p -> { s with properties = p }) <| k\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n()    ", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"1787d1fe-db11-4716-b3f6-164048e8991b"}, {"SnippetId" :"2deb54e7-009e-4297-b2bc-1c86d04203a4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, "snpName": "CodeEditorMain", "snpContent": "\n\nlet noSelection cur      = CodeSnippet.FetchO cur = None\nlet noSelectionVal       = Val.map noSelection currentCodeSnippetId\n\nlet propertyCssVal       = genericPropertyVal  currentCodeSnippetId \"CSS\"      \"\"         id\nlet propertyCssLinkVal   = genericPropertyVal  currentCodeSnippetId \"CSSLink\"  \"\"         id   \nlet propertyModeVal      = genericPropertyVal  currentCodeSnippetId \"Mode\"     \"fsharp\"   id   \nlet propertyThemeVal     = genericPropertyVal  currentCodeSnippetId \"Theme\"    \"\"         id   \nlet propertyLayoutVal    = genericPropertyVal  currentCodeSnippetId \"Layout\"   \"\"         id   \nlet propertyLayoutJSVal  = genericPropertyVal  currentCodeSnippetId \"LayoutJS\" \"\"         id   \nlet disablePropertyVal p = genericPropertyVal  currentCodeSnippetId p          \"\"         id\n\nlet disableEval parse ev = if ev = \"\" then parse else ev <> \"0\"\n\nlet disableParseVal      = disablePropertyVal \"DisableParse\"      |> Val.map (fun p -> p <> \"0\" && p <> \"\")\nlet disableFSIVal        = disablePropertyVal \"DisableFSI\"        |> Val.map2 disableEval disableParseVal  \nlet disableFableVal      = disablePropertyVal \"DisableFable\"      |> Val.map2 disableEval disableParseVal  \nlet disableWebSharperVal = disablePropertyVal \"DisableWebSharper\" |> Val.map2 disableEval disableParseVal \n\nlet mutable lastCodeAndStarts : (CodeSnippetId * bool * ((string * int * int) [] * string [] * string [] * string [] * string [] * string []) option) option = None\n\nlet getPredecessors curO =\n    curO\n    |> Option.map (fun (snp:CodeSnippet) -> snp.UniquePredecessors CodeSnippet.FetchO |> HashSet)\n    |> Option.defaultValue (System.Collections.Generic.HashSet())\n\nlet getPredecessorsM = Useful.ResetableMemoize(getPredecessors)\n\nlet codeFS         = Var.Create \"\"\nlet codeJS         = Var.Create \"\"\nlet parserMsgs     = Var.Create \"\"\nlet outputMsgs     = Var.Create \"\"\nlet mutable parsed = false\nlet dirty          = Var.Create false \nlet setDirtyPart() = parsed            <- false\n                     dirty.Value       <- true       \nlet setDirty()     = lastCodeAndStarts <- None\n                     setDirtyPart               ()\nlet setDirtyPred() = setDirty                   ()\n                     getPredecessorsM.ClearCache()\n                     refreshView                ()\nlet setClean()     = getPredecessorsM.ClearCache()\n                     dirty.Value       <- false\n                     lastCodeAndStarts <- None\n                     \n\n//storeVarCodeEditor \"dirty\" dirty\nlet appendMsg (var:Var<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet setOutMsg msg = outputMsgs.Value <-  msg\nlet addOutMsg msg = appendMsg outputMsgs msg\nlet addPrsMsg msg = appendMsg parserMsgs msg\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.GetCodeFsx true )\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\n//let evalIFrameJS success failure js =\n//    createIFrame (fun frame ->\n//        try\n//             let window   = frame?contentWindow\n//             let eval   s = JS.Apply window \"eval\" [| s |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure\n//    )\n//    |> RunCode.RunNode().RunHtml\n//\n//let evalWindowUrlJS (url:string) success failure js =\n//    let window       = JS.Apply JS.Window \"open\" [| url |]\n//    match window with\n//    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n//    | _    ->\n//    800 \n//    |> JS.SetTimeout (fun () -> \n//        try\n//             let eval   s = JS.Apply window   \"eval\" [| s |]\n//             //printfn \"Evaluating...\"\n//             JS.Apply window   \"focus\" [|  |]\n//             eval js           |> success\n//        with e -> e.ToString() |> failure)\n//    |> ignore\n//\n//let runUrlJS url pos msgs js =\n//    sendMsg \"Running JavaScript...\"\n//    match pos with\n//    | NewBrowser -> evalWindowUrlJS url\n//    | _          -> evalIFrameJS\n//    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n//    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n//    <| js\n//\n//let processSnippet getCode msg processCode =\n//    CodeSnippet.FetchO currentCodeSnippetId.Value \n//    |> Option.iter (fun snp -> \n//        codeMsgs.Value <- msg\n//        codeJS.Value   <- \"\"\n//        let code = getCode snp\n//        codeFS.Value   <- code\n//        processCode       code\n//    )\n//\n//let compileSnippet fThen fFail = \n//    processSnippet (fun snp -> snp.GetCodeFsx true) \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n//\n//let compileRunP pos = compileSnippet (runJS pos)                                         sendMsg\n//let compileRun  ()  = compileRunP           position.Value\n//let justCompile ()  = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirtyPred()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirtyPred()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirtyPred()\n    )\n\nlet draggedId   = ref CodeSnippetId.New\n\n()", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"8efdcd5a-95c4-4212-9c75-1ebedce83dd8"}, {"SnippetId" :"987560b0-1fe6-4835-ad99-aed93db7da1a"}, {"SnippetId" :"a28fe808-236e-4b7e-9509-51ebe21e35fc"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"}, "snpName": "Compile", "snpContent": "let compileSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp         = snpO |> Result.fromOption ``Snippet Missing``\n        outputMsgs.Value  <- \"Compiling to JavaScript...\"\n        codeJS.Value      <- \"\"\n        let    code        = snp.GetCodeFsx true\n        codeFS.Value      <- code\n        let!   jsR         = translateAR code false\n        let!   js          = jsR\n        let    jsc         = RunCode.completeJS js\n        codeJS.Value      <- jsc\n        addOutMsg            \"Compiled!\"\n        return jsc\n    }\n    \nlet newWindow url = \n    JS.Apply JS.Window \"open\"  [| url |]\n    |> function\n       | null   -> Result.fail    ``Could not open new browser, Popup blocker may be active``\n       | window -> Result.succeed window\n    \nlet eval  window js = try JS.Apply window \"eval\"  [| js  |]           with e -> printfn \"%A\" e ; sprintf \"%A\" e\nlet focus window    = try JS.Apply window \"focus\" [|     |] |> ignore with e -> printfn \"%A\" e\n\nlet evalWindowUrlJSW (url:string) js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   window       = newWindow url\n        do     focus window\n        do!    Async.Sleep 800 \n        let    res : string = eval window js\n        return res\n    }\n\nlet createIFrameA () =\n    Async.FromContinuations\n        (fun (cb, errF: exn -> unit, canF: System.OperationCanceledException -> unit) ->\n            try\n                createIFrame cb |> RunCode.RunNode().RunHtml     \n            with e -> errF e\n        )\n\nlet evalIFrameJSW js =\n    Wrap.wrapper {\n        do!    Result.tryProtection()\n        let!   frame        = createIFrameA () \n        let    window       = frame?contentWindow\n        window?document?body?style?margin <- \"0px\"\n        let    res : string = eval window js\n        return res\n    }\n\nlet compileRunUrlW url pos snpO =\n    Wrap.wrapper {\n        let! js  = compileSnippetW snpO\n        outputMsgs.Value <-  \"Running JavaScript...\"\n        let! res = match pos with\n                   | NewBrowser -> evalWindowUrlJSW url js\n                   | _          -> evalIFrameJSW        js\n        addOutMsg res\n        addOutMsg \"Done!\"\n        return  pos, res\n    }\n\nlet getSnpO () = CodeSnippet.FetchO currentCodeSnippetId.Value\n\nlet evalCodeW (code: string) =\n    Wrap.wrapper {\n        codeFS.Value     <- code\n        let! resR         = evaluateAR fsIds JS.Window.Location.Href true code\n        let! res          = resR\n        return  \"\"\n    }\n\nlet evalSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        let    code       = snp.GetCodeFsx true\n        let!   res        = evalCodeW code\n        do!    Evaluator.addPresence (sprintf \"%A\" snp.id) \"ok\"\n        return res\n    }\n    \nlet doSomething msgStart msgFinish (doIt: unit -> Wrap<_>) = \n    Wrap.wrapper {\n        outputMsgs.Value <- msgStart // \"Evaluating F# code...\"\n        let! res          = doIt()\n        addOutMsg res\n        addOutMsg msgFinish          //\"Done!\"\n        return  res\n    }\n\nlet evaluateSnippetW snpO = doSomething \"Evaluating F# code...\" \"\" (fun () -> evalSnippetW snpO)\nlet evaluateCodeW    code = doSomething \"Evaluating F# code...\" \"\" (fun () -> evalCodeW    code)\n\nlet ToConsoleF arg = \n    Console.Log arg\n    arg?cont addOutMsg\n    \nFableModule.addOutMsg <- addOutMsg \n\nlet evalFableCodeW code =\n    Wrap.wrapper {\n        codeFS.Value     <- code\n        let! jsc          = FableModule.fableTranslate code\n        codeJS.Value     <- jsc\n        JS.Eval jsc |> ignore\n        return \"\"\n    }\n\nlet evalFableSnippetW (snpO: CodeSnippet option) =\n    Wrap.wrapper {\n        let!   snp        = snpO |> Result.fromOption ``Snippet Missing``\n        let    code       = snp.GetCodeFsx false\n        return!             evalFableCodeW code\n    }\n\nlet fableSnippetW snpO = doSomething \"Running Fable...\" \"Done!\" (fun () -> evalFableSnippetW snpO)\nlet fableCodeW    code = doSomething \"Running Fable...\" \"Done!\" (fun () -> evalFableCodeW    code)\n\n\nlet compileRunW = compileRunUrlW (JS.Window.Location.Origin + \"/Main.html\") \n\nlet compileRunP pos = getSnpO() |> compileRunW pos  //|> Wrap.map ignore |> Wrap.start addOutMsg\nlet justCompile     = getSnpO   >> compileSnippetW  //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet evaluateFS      = getSnpO   >> evaluateSnippetW //>> Wrap.map ignore >> Wrap.start addOutMsg\nlet fableFS         = getSnpO   >> fableSnippetW\nlet compileRun  ()  = compileRunP position.Value\n\n()", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, {"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"afaac2af-143d-4745-9447-7e8d3044950f"}, {"SnippetId" :"dca77d6a-5c2c-4c3e-9bef-14f0464f9ada"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"93f32df7-da8b-472f-8bad-e82cc58ec52b"}, "snpName": "Snippet List", "snpContent": "let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\n\nlet curPredecessors = Val.map getPredecessorsM.Call currentCodeSnippetO\n\nlet isIndirectPredecessor pre (predecessors: HashSet<CodeSnippetId>) = predecessors.Contains pre //predecessors |> Set.contains pre\n\n//let isIndirectPredecessorT (preId, curId) = getPredecessors curId |> Set.contains preId            // horrible performance\n//let isIndirectPredecessorM  preId  curId  = (Useful.memoize isIndirectPredecessorT) (preId, curId) // horrible performance\n\nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecessors CodeSnippet.FetchO |> HashSet) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirtyPred()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                    code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor    code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor  code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                               )\n                    SomeAttr <| on.drag    (fun _ _  ->                                               draggedId := code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id !draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"-\"        else \"+\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (code.Levels |> fst |> sprintf \"%dem\")\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n\nlet topScrollList = ref 0.0\n\nlet listEntries snps =\n    let list =\n      div [ \n        yield style \"overflow: auto\"\n        yield! \n            snps\n            |> Seq.indexed\n            |> Seq.mapFold (fun expanded (i, snp) ->\n                if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n                    let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n                    let isExpanded  = isParent && snp.expanded\n                    (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n                else  (None, expanded)\n            )  (Set [])\n            |> fst\n            |> Seq.choose id\n        yield SomeAttr <| on.scroll      (fun e _ -> topScrollList :=  e.ScrollTop   )\n        yield SomeAttr <| on.afterRender (fun e   -> e.ScrollTop   <- !topScrollList )\n      ]\n    list\n\n()    ", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, {"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"54304360-819a-498c-a091-e6ece880a35a"}, "snpName": "Deserialize", "snpContent": "let inline ifUndef def v = if isUndefined v then def else v\nlet obj2CodeSnippetId o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> CodeSnippetId \n\nlet obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n    if isUndefined o then\n        None\n    else\n        Some <| obj2CodeSnippetId o\n\nlet obj2Map o =\n    let dict = System.Collections.Generic.Dictionary<string, string>()\n    if isUndefined o then\n        dict\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Seq.iter dict.Add\n        dict\n\nlet deserializeCodeSnipets v = \n    try\n        let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n        printfn \"%A\" <| Array.length objs\n        let snps =\n            objs\n            |> Array.choose (fun o ->\n                 if isUndefined o then None else\n                 {\n                    name         = o?name         |> ifUndef \"\"\n                    content      = o?content      |> ifUndef \"\"\n                    parent       = o?parent       |> obj2CodeSnippetIdO\n                    predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n                    id           = o?id           |> obj2CodeSnippetId\n                    expanded     = o?expanded     |> ifUndef false\n                    level        = o?level        |> ifUndef 0\n                    levelCode    = o?levelCode    |> ifUndef 0\n                    properties   = o?properties   |> obj2Map\n                  } |> Some)\n        snps\n    with _ -> [||]\n    \n()    ", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"60191ea0-da20-4fbf-96b8-3871338a66d8"}, "snpName": "Add,Delete,Load,Save", "snpContent": "let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) ->\n        let rec nextI lvl k =\n            codeSnippets.Value \n            |> Seq.tryItem k \n            |> Option.map (fun s -> if (fst s.Levels) <= lvl then k else nextI lvl (k + 1) ) \n            |> Option.defaultValue k\n        CodeSnippet.New(nextI (fst snp.Levels) (i + 1), \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet parseText txt =\n    try\n        txt\n        |> deserializeCodeSnipets\n        |> codeSnippets.Set\n        setClean()\n        refreshView()\n    with e -> JS.Alert <| e.ToString()\n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = findRootElement e\n      loadTextFile \n          <| root.QuerySelector(\"#\" + fileInputElementId)\n          <| parseText\n\nlet downloadFile() = // Save as...\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n                \nlet do_LoadFile (e:Dom.Element) _ =          \n    let root = findRootElement e\n    (root.QuerySelector(\"#\" + fileInputElementId))?click()\n\nif loadFromUri <> \"\" then\n    async {\n        do! Async.Sleep 3000\n        printfn \"loading %s...\" loadFromUri\n        let  r = JQuery.JQuery.GetJSON(loadFromUri + \"?t=\" + (now() |> string))\n        r.Done (fun () -> parseText r.ResponseText) |> ignore\n    } |> Async.Start\n    \n    ", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"54304360-819a-498c-a091-e6ece880a35a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"47f7c0ba-35b0-466e-a759-4e4d9963e524"}, "snpName": "codeMirror", "snpContent": "let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"FSharpStation\", endPoint = JS.Window.Location.Href)\n\n#if FSS_SERVER\nlet parseFileName = fsIds + \".fsx\"\n#else\nlet parseFileName = \"..\\\\\" + fsIds + \".fsx\"\n#endif\n\nlet mutable latestParsedPrefix = \"a\"\nlet nextParsedPrefix() = if latestParsedPrefix = \"a\" then \"b\" else \"a\"\nlet parseFile prefix = prefix + parseFileName\n\nlet getCodeAndStartsFast (snp:CodeSnippet) addLinePrepos =\n    let redO, cur = \n        match lastCodeAndStarts with\n        | Some (pId, alp, redO) when pId = snp.id && alp = addLinePrepos -> redO, snp.PrepareSnippet\n        | _ -> \n        let preds = snp.Predecessors()        \n        let redO  = if preds.Length = 1 then None else CodeSnippet.ReducedCode addLinePrepos preds.[0..preds.Length - 2] |> Some\n        let cur   = preds.[preds.Length - 1]\n        lastCodeAndStarts <- Some(cur.id, addLinePrepos, redO)\n        redO, cur\n    let red1 = CodeSnippet.ReducedCode addLinePrepos [| cur |]\n    redO\n    |> Option.map (fun red0 -> CodeSnippet.AddSeps red0 red1)\n    |> Option.defaultValue red1\n    |> CodeSnippet.FinishCode addLinePrepos\n\nlet isParseDisabled = disableParseVal |> Val.toView |> View.GetAsync\n\nlet cancellationTokenSourceO = ref None\nlet parseCode() =\n    let asy = async {\n        let! disabled = isParseDisabled\n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        parserMsgs.Value         <- \"Parsing...\\n\" + String.skipFirstLine parserMsgs.Value\n        do!                         Async.Sleep 500\n        let  prefix               = nextParsedPrefix()\n        let  code, starts         = getCodeAndStartsFast cur false\n        let! res                  = autoCompleteClient.Parse(parseFile prefix, code, starts)\n        cancellationTokenSourceO := None\n        parsed                   <- true\n        latestParsedPrefix       <- prefix\n        parserMsgs.Value         <- \"Parsed!\\n\" + res\n     }\n    !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n    cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n    Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n\nlet setDirtyCond() =\n    match lastCodeAndStarts with\n    | Some (pId, _, red) when pId = currentCodeSnippetId.Value -> setDirtyPart()\n    | _                                                        -> setDirty    ()\n    parseCode()\n\nlet mutable parseIn     = 0\nlet mutable parseOut    = 0\nlet mutable parsingCode = \"\"\n\n//let rec parseRecFSA silent reparse =\n//    async {\n//        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n//        | None     -> ()\n//        | Some cur ->\n//        let  code, starts  = getCodeAndStartsFast cur false\n//        if code <> parsingCode || (parseIn = parseOut && reparse) then\n//           try\n//              parsed             <- false\n//              parseIn            <- parseIn + 1\n//              let  prefix         = nextParsedPrefix()\n//              printfn \"Parsing %s\" prefix\n//              if not silent then parserMsgs.Set (\"Parsing...\\n\" + String.skipFirstLine parserMsgs.Value)\n//              parsingCode        <- code\n//              let! res            = autoCompleteClient.Parse(parseFile prefix, code, starts)\n//              latestParsedPrefix <- prefix\n//              if not silent then\n//                  parserMsgs.Set  \"Parsed!\"\n//                  addPrsMsg res\n//              parsed             <- true\n//              printfn \"Parse result= %A\" (res <> \"\")\n//           finally\n//              parseOut <- parseOut + 1\n//           if parseIn = parseOut then\n//              do! parseRecFSA silent false\n//    }\n\nlet parseFSA silent = parseCode() // parseRecFSA silent true\n\n\nlet parseFS() = \n    Wrap.wrapper {\n        lastCodeAndStarts <- None\n        do parseFSA false\n    }\n\nlet mustParse (cur:CodeSnippet) =\n    async {\n        if not parsed then return true \n        else\n            let! must = autoCompleteClient.MustParse(parseFile latestParsedPrefix, cur.NameSanitized)\n            return must\n    }\n\nlet parseIfMustThen silent =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        let! must = mustParse cur\n        if must then \n            do parseFSA silent\n    }\n\nlet getStartWord (line:string) ch =\n    match line.Substring(0, ch) with\n    | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet getEndWord (line:string) ch =\n    match line.Substring(ch) with\n    | REGEX @\"^([a-zA-Z_]\\w*)\" \"g\" [| txt |] -> txt\n    | _                                      -> \"\"          \n\nlet showToolTip (ed:Template.CodeMirrorEditor) =\n    async {\n        let! disabled = isParseDisabled \n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        do!  parseIfMustThen false\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let  sub   = (getStartWord l pos.ch |> String.length)   \n        let  add0  = (getEndWord   l pos.ch |> String.length)    \n        let  add   = if sub = 0 && add0 = 0 then 2 else add0 \n        let! tip   = autoCompleteClient.ToolTip  (parseFile latestParsedPrefix, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        addPrsMsg <| sprintf \"InfoFSharp \\\"%s %A - %A %s \\\"\" cur.NameSanitized (pos.line + 1, pos.ch - sub + 1) (pos.line + 1, pos.ch + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        printfn \"calling parseIfMustThen\"\n        do!  parseIfMustThen false\n        match parserMsgs.Value with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n            if file.StartsWith cur.id.Text || file = sanitize cur.name then\n                let ind = if int indent > 0 then int indent else 0\n                { Template.LintResponse.message  = msg\n                  Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n                  Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n                  Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n                } |> Some\n            else     None\n          )        \n        |> cb\n    } |> Async.Start\n\nlet asyncStartDelayed = asyncStartCancelling()\nlet getAnnotationsDelayed parms =\n    //async {\n    //    printfn \"before delaying\"\n    //    do! Async.Sleep 400\n    //    printfn \"calling getAnnotations\"\n        do getAnnotations parms\n    //} |> asyncStartDelayed \n\nlet getSymbolType chr =\n    match chr with\n    | \"C\"   -> \"class\"     \n    | \"Cn\"  -> \"Constant\"  \n    | \"D\"   -> \"delegate\"  \n    | \"E\"   -> \"enum\"      \n    | \"P\"   -> \"property\"  \n    | \"e\"   -> \"event\"     \n    | \"X\"   -> \"exception\" \n    | \"F\"   -> \"field\"     \n    | \"I\"   -> \"interface\" \n    | \"M\"   -> \"function\"    \n    | \"N\"   -> \"module\"    \n    | \"S\"   -> \"struct\"    \n    | \"T\"   -> \"type\"      \n    | \"V\"   -> \"Variable\"  \n    | _     -> chr\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let! disabled = isParseDisabled\n        printfn \"getHints (Complete) %A\" disabled\n        if disabled then () else\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        //do!  parseIfMustThen true\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = getStartWord l pos.ch\n        let! com    = autoCompleteClient.Complete(parseFile latestParsedPrefix, l + \"a\", pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        cb { Template.list   = com \n                               |> Array.map (fun (dis, rep, cls, chr) -> \n                                    { text        = rep\n                                      displayText = (sprintf \"%-40s %20s\" dis (getSymbolType chr))\n                                      className   = cls                              \n                                    })\n             Template.from   = { pos with ch = pos.ch - word.Length }\n             Template.``to`` = pos \n           }\n    } |> asyncStartDelayed\n\nlet filterSnippet msgs (snpId:CodeSnippetId) =\n    match msgs with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, indent, int fl, int fc    , int tl, int tc, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, indent, int fl, int fc - 1, int fl, int fc, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.choose (fun (file, indent, fl, fc, tl, tc, sev, from, msg) ->\n        if file.StartsWith snpId.Text then\n            let ind = if int indent > 0 then int indent else 0\n            { Template.LintResponse.message  = msg\n              Template.LintResponse.severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" elif sev.ToUpper().StartsWith(\"INFO\") then \"info\" else \"warning\")\n              Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1 - ind) \n              Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1 - ind)\n            } |> Some\n        else     None\n      )        \n\nlet annotationsV = currentCodeSnippetId.View |> View.Map2 filterSnippet parserMsgs.View |> View.consistent\ncurrentCodeSnippetId.View |> View.Sink (fun _ -> parseIfMustThen() |> Async.Start)\n    \nlet codeMirror = \n    Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId)\n        .OnChange(setDirtyCond)\n        .OnRender(fun ed ->\n          ed.AddKeyMap({  F2              = showToolTip            \n                          LeftDoubleClick = showToolTip\n                          ``Ctrl-Space``  = Template.showHints ed getHints false\n                          ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\"))\n                                            >> Template.showHints ed getHints false\n                       })\n          View.Sink (fun _ -> ed?performLint() |> ignore) annotationsV\n          Template.setLint ed (fun (_t, send, _o, _ed) -> annotationsV |> View.Get send)\n          Val.sink (fun v ->\n              async {\n                  ed.SetOption(\"theme\", v)\n                  do! Async.Sleep(50)\n                  ed.Refresh()\n              } |> Async.Start                       ) propertyThemeVal \n          Val.sink (fun v -> ed.SetOption(\"mode\" , v)) propertyModeVal \n        )\n        .Style(\"height: 100%\")\n\nlet rec expandParents snp = \n    snp.parent\n    |> Option.bind CodeSnippet.FetchO\n    |> Option.iter (fun me -> \n        expandParents me\n        if not me.expanded then toggleExpanded me)\n\nlet goto codeId line col =\n    async {\n        currentCodeSnippetId.Value <- codeId\n        CodeSnippet.FetchO codeId |> Option.iter expandParents\n        do! Async.Sleep 200\n        codeMirror.editorO \n        |> Option.iter (fun ed -> \n            ed.SetCursor(line - 1, col - 1) \n            ed.Focus()\n        )\n    } |> Async.Start\n\nlet rexGuid = \"\"\"([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}).+?\\((\\d+)\\,\\s*(\\d+)\\)\"\"\"\n\nlet jumpToLine (line:string) = \n    match line with\n    | REGEX rexGuid \"\" [| _ ; guid ; line ; col |] -> goto <| CodeSnippetId (System.Guid guid) <| int line <| int col\n    | _                                            -> ()\n\nlet gotoDefinition () =\n    async {\n        match CodeSnippet.FetchO currentCodeSnippetId.Value, codeMirror.editorO with \n        | _       , None     \n        | None    , _       -> ()\n        | Some cur, Some ed ->\n        let  pos   = ed.GetCursor()\n        let  l     = ed.GetLine pos.line\n        let! kind  = autoCompleteClient.FindDecl(parseFile latestParsedPrefix, pos.line + 1, pos.ch + 1, cur.NameSanitized)\n        match kind with\n        | FSAutoCompleteIntermediary.CommTypes.KFindDecl decl -> jumpToLine <| sprintf \"%s (%d, %d) - (%d, %d)\" decl.File decl.Line decl.Column decl.Line decl.Column\n        | FSAutoCompleteIntermediary.CommTypes.KError    err  -> JS.Alert   <| sprintf \"%A\" err\n        | _                                                   -> JS.Alert   <| sprintf \"%A\" kind\n    } |> Async.Start\n\nlet refreshCodeMirror() = codeMirror.editorO |> Option.iter (fun cm -> cm.Refresh())\n\nlet delayedRefreshCM delay =\n    async {\n        do! Async.Sleep delay\n        refreshCodeMirror() \n    } |> Async.Start\n    \nlet codeMirrorRender = \n    codeMirror.Render.AddChildren [ \n        SomeAttr <| on.dblClick (fun _ _ -> showToolTip codeMirror.editorO.Value)  \n        htmlElement     \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type``    \"context\"\n            Id          \"right-menu\"\n            htmlElement \"menuitem\" [ \n                htmlAttribute \"label\" \"Goto Definition\"\n                SomeAttr <| on.click (fun _ _ -> gotoDefinition() )  \n            ] \n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n\nparserMsgs\n|> Val.sink (fun msgs ->\n    async {\n        if not parsed then () else\n        match codeMirror.editorO  with\n        | None    -> () \n        | Some ed ->\n        match CodeSnippet.FetchO currentCodeSnippetId.Value with \n        | None     -> ()\n        | Some cur ->\n        //let! must = autoCompleteClient.MustParse(parseFile latestParsedPrefix, cur.NameSanitized)\n        //if must       then do! Async.Sleep 400\n        ed?performLint() |> ignore\n    } |> Async.Start      \n)\n//let mutable prior = \"\", \"\"\n//Val.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n//|> Val.sink (fun (msgs, curO) ->\n//    async {\n//        match codeMirror.editorO  with\n//        | None        -> () \n//        | Some editor ->\n//            match curO with \n//            | None -> () \n//            | Some cur ->\n//            curSnippetNameOf cur.id\n//            |> Val.iter (fun name ->\n//                printfn \"RemoveMarks: %s\" name\n//                if prior = (msgs, name) then () else\n//                prior   <- (msgs, name)\n//                editor.RemoveMarks()\n//                match msgs with\n//                | REGEX rex \"g\" m -> m\n//                | _               -> [||]\n//                |> Array.choose (fun v ->\n//                    match v with\n//                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n//                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n//                    | _ -> None\n//                )\n//                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n//                    printfn \"inside -%s-%s-\" file (sanitize name)\n//                    if file.StartsWith cur.id.Text || file = sanitize name then\n//                        100\n//                        |> JS.SetTimeout (fun () ->\n//                            editor.MarkText (fl - 1, fc - 1) (tl - 1, tc - 1) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n//                        |> ignore\n//    \n//                )\n//            )\n//    } |> Async.Start\n//)\n", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, {"SnippetId" :"18d8153d-422c-42f6-8266-9a9d854bd6a1"}, {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"466e6783-0751-48d5-b79b-165aaa7d2173"}, {"SnippetId" :"93f32df7-da8b-472f-8bad-e82cc58ec52b"}, {"SnippetId" :"a05dd36e-a15e-4394-8013-128e21e69574"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}, {"SnippetId" :"ece85c79-829d-4bec-a607-a1cd01f9dafa"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}, "snpName": "", "snpContent": "let styleEditor =\n     \"\"\"\n", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"78648685-ff9c-4dc6-800a-3285f135dec4"}, "snpName": "CSS", "snpContent": "body { margin: 0px }     \n     \ndiv textarea {\n    font-family     : monospace;\n}\n.code-editor-list-tile {\n    white-space     : nowrap; \n    border-style    : solid none none;\n    border-color    : white;\n    border-width    : 1px;\n    background-color: #D8D8D8;\n    display         : flex;\n}\n.code-editor-list-text{\n    padding         : 1px 10px 1px 5px;\n    overflow        : hidden;\n    text-overflow   : ellipsis;\n    white-space     : nowrap;\n    flex            : 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\n    font-weight     : bold;\n}\n.code-editor-list-tile.indirect-predecessor {\n    color           : blue;\n}\n.code-editor-list-tile.selected {\n    background-color: #77F;\n    color           : white;\n}\n.code-editor-list-tile.hovering {\n    background      : lightgray;\n}\n.code-editor-list-tile.hovering.selected {\n    background      : blue;\n}\n.code-editor-list-tile>.predecessor {\n    font-weight     : bold;\n    border-style    : inset;\n    border-width    : 1px;\n    text-align      : center;\n    color           : transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\n    color           : blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color: white; \n    width           : 2ch; \n    color           : #A03; \n    font-weight     : bold; \n    text-align      : center;\n    font-family     : arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }", "snpParentIdO": {"SnippetId" :"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"aeb92943-97ea-4297-9097-926410e9d10f"}, "snpName": "", "snpContent": "\"\"\"", "snpParentIdO": {"SnippetId" :"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}, "snpPredIds": [{"SnippetId" :"78648685-ff9c-4dc6-800a-3285f135dec4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7cdba50e-5de9-4377-a7fc-705df0d909fa"}, "snpName": "Properties", "snpContent": "//let setProp k v = props.[k] <- v\n\nlet redraw = Var.Create ()\nlet setDirtyP () = dirty.Value <- true\nlet getProperty props key   = Property(setDirtyP, props, key) \nlet setProperty props key v = ((getProperty props key).ValueVar :> Var<_>).Set v\n\nlet tableProps =\n  currentCodeSnippetId\n  |> Val.bind (curSnippetPrpsOf >> DynamicV)\n  |> Val.map2 (fun () (props: Dictionary<string,string>) ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.sort\n            |> Seq.map (fun kvp ->\n                let prop = getProperty props kvp\n                tr [\n                    td [ Doc.Input     [                             ] prop.KeyVar   |> someElt ] \n                    td [ Doc.InputArea [ atr \"style\" \"height: 1.5em\" ] prop.ValueVar |> someElt ] \n                    td [ title \"remove\" ; style \" cursor: pointer \"\n                         htmlText \"x\" ; SomeAttr <| on.click (fun _ _ ->  prop.Remove()                    ; redraw.Value <- () ) ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\"    ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"\", \"1\") ; setDirtyP() ; redraw.Value <- () ) ] |> hoverable\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  ) redraw\n\nlet properties =\n    div [\n      HtmlElementV tableProps\n      css \"\"\" td.hovering { background: gray; } \"\"\"\n    ]\n\n()", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}, {"SnippetId" :"93f32df7-da8b-472f-8bad-e82cc58ec52b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}, "snpName": "Actions", "snpContent": "let triggerWSResult = Var.Create ()\n\nlet DoW  f p   _ _ = f p   |> Wrap.map ignore |> Wrap.start addOutMsg\nlet DoP  f p   _ _ = f p   |> Wrap.startV (function\n                                           | Some (Below, _), msgs -> msgs               |> addOutMsg ;  triggerWSResult.Value <- ()\n                                           | Some _         , msgs -> msgs               |> addOutMsg \n                                           | None           , msgs -> \"Failed!\\n\" + msgs |> addOutMsg)\n\nlet DoW2 f p t     = DoW (fun p' -> f t p') p\nlet DoP2 f p t     = DoP (fun p' -> f t p') p\n\nlet getSnippet     (act: Action) =\n    match act.parms with\n    | Some [| path |] -> path |> unbox<string> |> (fun s -> s.Split '/') |> CodeSnippet.FetchByPathO \n    | _               -> getSnpO()\n\nlet getCodeFromAct (act: Action) addOpen = \n    Wrap.wrap {\n        let! text = Val.getAsync act.text\n        setOutMsg (text + \"...\")\n        let snpO = getSnpO()\n        let propValue p = snpO |> Option.bind (fun snp -> snp.propValue p)\n        let openPre     = if addOpen then propValue \"open\" |> Option.map (__ (+) \"\\n\") |> Option.defaultValue \"\" else \"\"\n        let actionTempl = lazy (propValue \"action-template\" |> Option.defaultValue \"${parm}() |> printfn \\\"%A\\\"\")\n        let code =\n            act.parms\n            |> Option.map (Array.map unbox<string>)\n            |> function\n               | Some [| \"Code\"     ; code |] -> code |> Some\n               | Some [| \"Property\" ; prop |] -> prop |> propValue \n               | _                            -> None\n            |> Option.orElseWith  (fun () -> text |> propValue                           )\n            |> Option.defaultWith (fun () -> text |> translateTemplate actionTempl.Value )\n            |> (fun code -> if code.StartsWith \"////\" then code else openPre + code)\n        match snpO with\n        | None     -> return code\n        | Some snp -> let! presence = Evaluator.getPresence (Evaluator.extractConfig code) (sprintf \"%A\" snp.id) \n                      if presence = Some \"ok\" then return code else\n                      let! r = evalSnippetW snpO\n                      return code\n                      \n    }\n\nlet evalFsCode    (act: Action) () = getCodeFromAct act true  |> Wrap.bind evaluateCodeW\nlet evalFableCode (act: Action) () = getCodeFromAct act false |> Wrap.bind fableCodeW\nlet evaluateFS2   (act: Action) () = getSnippet     act       |>           evaluateSnippetW\nlet fableFS2      (act: Action) () = getSnippet     act       |>           fableSnippetW\nlet compileRunP2  (act: Action) p  = getSnippet     act       |>           compileRunW p\nlet setSnippetProp(act: Action) () =\n    Wrap.wrapper {\n        do!  Result.tryProtection()\n        let! res = \n            match act.parms with\n            | Some [| opth ; oprp; ov |] -> let path, prop, v = unbox<string> opth, unbox<string> oprp, unbox<string> ov\n                                            path.Split '/'\n                                            |> CodeSnippet.FetchByPathO \n                                            |> Option.map (fun snp -> setProperty snp.properties prop v)\n                                            |> Option.defaultWith (fun () -> printfn \"setSnippetProp snippet not found: %s\" path)\n                                            |> Result.succeed\n            | _                          -> sprintf \"setSnippetProp wrong parms: %A\" act.parms |> Result.failSimpleError\n        return res\n    }\n    \nlet showOutText (act: Action) () = \n    printfn \"showOutText: %A\" act\n    match act.parms with\n    | Some [|       txt |]                      -> setOutMsg <| unbox txt\n    | Some [| cmd ; txt |] when unbox cmd = \"\"  -> setOutMsg <| unbox txt\n    | Some [| cmd ; txt |] when unbox cmd = \"+\" -> addOutMsg <| unbox txt\n    | _                                         -> printfn \"error: showOutText %A\" act\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick( do_LoadFile                    )  \nlet actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick( Do   downloadFile      ()      ).Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick( Do   addCode           ()      )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick( Do   deleteCode        ()      ).Disabled(noSelectionVal      )\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick( Do   indentCodeIn      ()      ).Disabled(noSelectionVal      )\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick( Do   indentCodeOut     ()      ).Disabled(noSelectionVal      )\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick( Do   getFSCode         ()      ).Disabled(disableParseVal     )\nlet actSetSnippetProp = Template.Action.New(\"actSetSnippetProp\"          ).OnClick2(DoW2 setSnippetProp    ()      ).Disabled(disableFSIVal       )\nlet actEvalFsCode     = Template.Action.New(\"Run FSI on Code\"            ).OnClick2(DoW2 evalFsCode        ()      ).Disabled(disableFSIVal       )\nlet actEvalCode       = Template.Action.New(\"Run FSI\"                    ).OnClick2(DoW2 evaluateFS2       ()      ).Disabled(disableFSIVal       )\nlet actFableFsCode    = Template.Action.New(\"Run Fable on Code\"          ).OnClick2(DoW2 evalFableCode     ()      ).Disabled(disableFableVal     )\nlet actFableCode      = Template.Action.New(\"Run Fable\"                  ).OnClick2(DoW2 fableFS2          ()      ).Disabled(disableFableVal     )\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick2(DoW2 compileRunP2   NewBrowser ).Disabled(disableWebSharperVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick2(DoP2 compileRunP2   Below      ).Disabled(disableWebSharperVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick( DoP  compileRun        ()      ).Disabled(disableWebSharperVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick( DoW  parseFS           ()      ).Disabled(disableParseVal     )\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick( DoW  justCompile       ()      ).Disabled(disableWebSharperVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick( Do   gotoDefinition    ()      ).Disabled(disableParseVal     )\nlet actRefreshEditor  = Template.Action.New(\"Refresh CodeMirror\"         ).OnClick( Do   refreshCodeMirror ()      )\nlet actOutText        = Template.Action.New(\"Show Output text\"           ).OnClick2(Do2  showOutText       ()      )\nlet actAbortFsi       = Template.Action.New(\"Abort FSI\"                  ).OnClick( Do   abortFsiExe       ()      )\n     \nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n          actEvalCode      .Button.Render\n          actFableCode     .Button.Render\n          actRunWSIn       .Button.Render\n\n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []       \n          actGetFsCode     .Button.Render\n          actParseCode     .Button.Render\n          Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n\n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actRefreshEditor .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        actAbortFsi      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actFableCode     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n            .SubMenu [\n                MenuEntry.New(\"Source @ GitHub\", \"https://github.com/amieres/FSharpStation\").Target \"_blank\"\n            ]\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n           \n()           ", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"3f2ec5e2-8ab6-4e5b-bb89-1943ed3a4964"}, {"SnippetId" :"47f7c0ba-35b0-466e-a759-4e4d9963e524"}, {"SnippetId" :"60191ea0-da20-4fbf-96b8-3871338a66d8"}, {"SnippetId" :"7cdba50e-5de9-4377-a7fc-705df0d909fa"}, {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"}, "snpName": "CodeEditorGrid", "snpContent": "let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\n\nlet jumpToRef (e:obj) (_:Dom.MouseEvent) = \n    let v : string = e?value |> unbox\n    let s : int    = e?selectionStart |> unbox\n    let lines = v.Split '\\n'\n    lines \n    |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n    |> fst\n    |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n    |> jumpToLine\n\nlet scrollToBottom (e:obj) (_:obj) = \n    async { \n        do! Async.Sleep 100\n        do  e?scrollTop <- e?scrollHeight\n    } |> Async.Start\n\n(*\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1)\n     .ColAuto(     0.0)\n     .ColVariable( 0.0).Min(0.0).Max(Val.map ((-) 92.0) spl1.GetValue).Before.Children([ style \"grid-row   : 1 / 5\" ])\n     .RowFixedPx( 34.0) \n     .RowAuto(     0.0)\n     .RowVariable(17.0)                                               .Before.Children([ style \"grid-column: 2 / 3\" ])\n     .RowFixedPx( 80.0)\n     .Padding(1.0)\n     .Content(\"sidebar\", \n         codeSnippets.View\n         |> View.SnapshotOn codeSnippets.Value refresh.View\n         |> bindHElem listEntries\n      )\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TabStrip  .New(Messages).Top                                                                        .Render)\n     .Content(\"footer\"  ,       \n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actCompileWS     .Button.Render\n              actRunWSIn       .Button.Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n     .Style(\"\"\" \n            grid-template-areas:\n                'header0 header   sidebar2'\n                'sidebar content1 sidebar2'\n                'sidebar content2 sidebar2'\n                'footer  footer   sidebar2';\n            color      : #333;\n            height     : 100%;\n            font-size  : small;\n            font-family: monospace;\n            line-height: 1.2;\n                \"\"\")\n\n*)\n()", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"47f7c0ba-35b0-466e-a759-4e4d9963e524"}, {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, {"SnippetId" :"60191ea0-da20-4fbf-96b8-3871338a66d8"}, {"SnippetId" :"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}, {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}, {"SnippetId" :"93f32df7-da8b-472f-8bad-e82cc58ec52b"}, {"SnippetId" :"aeb92943-97ea-4297-9097-926410e9d10f"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}, {"SnippetId" :"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"}, {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}, {"SnippetId" :"e702bf50-ad01-45eb-8b7b-813cc9046bef"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4e040028-ff11-458e-a43b-e8a1b7fcaeec"}, "snpName": "Layout", "snpContent": "let snippetList = \n    codeSnippets.View\n       |> View.SnapshotOn codeSnippets.Value refresh.View\n       |> bindHElem listEntries\n\nlet steps = \n  Layout.AddGuids\n    [|\n        \"actLoadFile\"       , GuiAction actLoadFile      \n        \"actSaveFile\"       , GuiAction actSaveFile      \n        \"actAddSnippet\"     , GuiAction actAddSnippet    \n        \"actDeleteSnippet\"  , GuiAction actDeleteSnippet \n        \"actIndentSnippet\"  , GuiAction actIndentSnippet \n        \"actOutdentSnippet\" , GuiAction actOutdentSnippet\n        \"actGetFsCode\"      , GuiAction actGetFsCode     \n        \"actSetSnippetProp\" , GuiAction actSetSnippetProp\n        \"actEvalFsCode\"     , GuiAction actEvalFsCode\n        \"actEvalCode\"       , GuiAction actEvalCode\n        \"actRunFableFs\"     , GuiAction actFableFsCode\n        \"actRunFable\"       , GuiAction actFableCode\n        \"actRunWSNewTab\"    , GuiAction actRunWSNewTab   \n        \"actRunWSHere\"      , GuiAction actRunWSHere     \n        \"actRunWSIn\"        , GuiAction actRunWSIn       \n        \"actParseCode\"      , GuiAction actParseCode     \n        \"actCompileWS\"      , GuiAction actCompileWS     \n        \"actFindDefinition\" , GuiAction actFindDefinition    \n        \"actOutText\"        , GuiAction actOutText\n        \"Output\"            , GuiNode <| Template.TextArea.New(outputMsgs).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick jumpToRef |> SomeAttr; on.afterRender (fun e -> outputMsgs |> Val.sink (scrollToBottom e)) |> SomeAttr]\n        \"Parser\"            , GuiNode <| Template.TextArea.New(parserMsgs).Placeholder(\"Parser messages:\").Title(\"Parser\"                   ).RenderWith [ on.dblClick jumpToRef |> SomeAttr]\n        \"JavaScript\"        , GuiNode <| Template.TextArea.New(codeJS    ).Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n        \"F# code\"           , GuiNode <| Template.TextArea.New(codeFS    ).Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n        \"Properties\"        , GuiNode <| properties    \n        \"WS Result\"         , GuiNode <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n        \"title\"             , GuiNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\n        \"code\"              , GuiNode <| codeMirrorRender\n        \"snippets\"          , GuiNode <| snippetList\n        \"buttons\"           , GuiNode <| buttonsH\n        \"menu\"              , GuiNode <| menuBar\n        \"messagesR\"         , GuiTabStrip(     true ,  [| \"Properties\" |])\n        \"messagesB1\"        , GuiTabStrip(     true ,  [| \"Output\"    \n                                                          \"JavaScript\"\n                                                          \"F# code\"    |])\n        \"messagesB2\"        , GuiTabStrip(     true ,  [| \"Parser\"    \n                                                          \"WS Result\"  |])\n        \"messagesB\"         , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n        \"title_code\"        , fixedHorSplitter true   34.0 \"title\"         \"code\"\n        \"code_props\"        , varVerSplitter          85.0 \"title_code\"    \"messagesR\"     25.0 100.0\n        \"code_buttons\"      , fixedHorSplitter false  80.0 \"code_props\"    \"buttons\"\n        \"snippets_code\"     , varVerSplitter          15.0 \"snippets\"      \"code_buttons\"   5.0  95.0\n        \"main_messages\"     , varHorSplitter          82.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n        \"extrabuttons\"      , GuiNode <| div []\n        \"main_extra\"        , varVerSplitter         100.0 \"main_messages\" \"extrabuttons\"  20.0 100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n    |]   \n\nlet layout = Layout.New steps\n\nlet doGuiCallR(name:string, action:string, parms: string[]) =\n    Result.result {\n        do! Result.tryProtection()\n        let! act = layout.GetGuiCallAction name action parms\n        act.onClick |> Option.iter (fun f -> f act null null)\n    }\n    \nlet doGuiCall  v =\n    doGuiCallR v\n    |> function\n       | Result.Failure ms -> printfn \"Error doGuiCall %A: %A\" ms v\n       | _ -> ()\n\n\n\nlet addLayoutJson  json   = delayedRefreshCM 1000 ; delayedRefreshCM 2000 ; delayedRefreshCM 3000 ; layout.SetLayoutJson steps json\nlet addLayoutSteps steps2 = delayedRefreshCM 1000 ; delayedRefreshCM 2000 ; delayedRefreshCM 3000 ; layout.AddNewSteps steps steps2\nJS.Window?addLayoutJson <-    addLayoutJson\npropertyLayoutVal   |> Val.sink addLayoutJson \npropertyLayoutJSVal |> Val.sink (fun js -> if js = \"\" then addLayoutSteps [||] else eval JS.Window js |> ignore)\n\nlet setFSharpStationLayout (f:FuncWithArgs<Layout * CodeSnippet, _>)  =\n        CodeSnippet.FetchO currentCodeSnippetId.Value\n        |> Option.iter (fun cur -> f.Call(layout, cur) |> addLayoutSteps)\n\nJS.Window?doFSharpStationGuiCall <- doGuiCall\nJS.Window?setFSharpStationLayout <- setFSharpStationLayout\n\n// these are here so it gets included in the code for Layouts\nlet dict = Dictionary<string, string>()\nlet dictTryGetValue = Dict.tryGetValue \"\" dict \nlet pnl  = Template.Panel.New\n()\n", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"0a11766b-f227-4b38-88a3-919d964387bf"}, {"SnippetId" :"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}, {"SnippetId" :"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"}, {"SnippetId" :"7cdba50e-5de9-4377-a7fc-705df0d909fa"}, {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"}, "snpName": "Messaging", "snpContent": "#if NOMESSAGING\n#else\n\nlet wsStationClient = new WSMessagingBroker.WSMessagingClient(fsIds)\n//let fsStationClient = FsStationClient(fsIds, fsIds, endPoint = JS.Window.Location.Href)\n\nlet transMsgs (msgs: ErrMsg [])  =  msgs |> Seq.map (fun e -> e.ErrMsg, if e.IsWarning then FSWarning else FSError) |> Seq.toArray\n\nlet result2response res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map snd, b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet result2StringResponse res = \n    match res with \n    | Result (a, b) -> StringResponseR (a |> Option.map (sprintf \"%A\"), b |> Seq.map (fun err -> err.ErrMsg, if err.IsWarning then FSWarning else FSError) |> Seq.toArray ) \n\nlet respond (fromId:string) (msg:FSMessage) : Async<FSResponse> =\n    async {\n        match msg with\n        | GetWholeFile                     -> return  codeSnippets.Value            |> Seq.toArray |> Json.Serialize |> Some                                   |> StringResponse       \n        | GetSnippetContentById sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.content        )                             |> StringResponse       \n        | GetSnippetCodeById    sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse \n        | GetSnippetPredsById   sId        -> return  CodeSnippet.FetchO       sId  |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippetById        sId        -> return  CodeSnippet.FetchO       sId                                                                             |> SnippetResponse \n        | GetSnippetContent     path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.content        )                             |> StringResponse\n        | GetSnippetCode        path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.GetCodeFsx true)                             |> StringResponse\n        | GetSnippetJSCode      path       -> match   CodeSnippet.FetchByPathO path with\n                                              | Some snp -> let!    jsR = translateAR (snp.GetCodeFsx true) false\n                                                            return (jsR |> Result.map RunCode.completeJS |> Result.getOption, jsR |> Result.getMsgs |> transMsgs)      |> StringResponseR\n                                              | None     -> return (None, [| \"Snippet not found\" , FSError |] )                                                |> StringResponseR\n        | GetSnippetPreds       path       -> return  CodeSnippet.FetchByPathO path |> Option.map (fun snp -> snp.Predecessors ()) |> Option.defaultValue [||] |> SnippetsResponse\n        | GetSnippet            path       -> return  CodeSnippet.FetchByPathO path                                                                            |> SnippetResponse \n        | GenericMessage        txt        -> return  (Some <| \"Message received: \" + txt)                                                                     |> StringResponse\n        | GetIdentification                -> return  fsIds                                                                                                   |> IdResponse  \n        | RunSnippetUrlJSById  (sId , url) -> return! CodeSnippet.FetchO       sId  |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunSnippetUrlJS      (path, url) -> return! CodeSnippet.FetchByPathO path |> compileRunUrlW url NewBrowser |> Wrap.getAsyncR |> Async.map result2response\n        | RunActionCall        (nm,ac, ps) -> return  doGuiCallR(nm, ac, ps) |> Result.map (fun _ -> sprintf \"success: %s\" nm)                   |> result2StringResponse\n    }     \n     \n//async {\n//    do! Async.Sleep 1000\n//    do fsStationClient.MessagingClient.AwaitMessageG respond\n//} |> Async.Start\n\nasync {\n    do! Async.Sleep 1000\n    while true do\n        try       wsStationClient.ProcessIncoming (respond \"\" >> WAsync)\n                  do! Async.Sleep 60000\n        with e -> printfn \"%s\" e.Message\n                  do! Async.Sleep 1000\n} |> Async.Start\n\n#endif", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"4e040028-ff11-458e-a43b-e8a1b7fcaeec"}, {"SnippetId" :"70bc3916-4714-4ee1-a2d0-d3917eeadf9d"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}, "snpName": "MainForm", "snpContent": "Val.sink        (fun _  -> layout.SelectTab \"Output\"    |> ignore) outputMsgs \nVal.sink        (fun _  -> layout.SelectTab \"WS Result\" |> ignore) triggerWSResult\nAsync.sleepThen (fun () -> layout.SelectTab \"Parser\"    |> ignore) 1000 |> Async.Start\n\n\nlet cssLinks      = Var.Create [ \"/EPFileX/css/main.css\" ]\nlet addCssLink lnk =\n    if  cssLinks.Value |> List.contains lnk |> not then\n        cssLinks.Value <- lnk :: cssLinks.Value\n    delayedRefreshCM 300\n\nVal.sink addCssLink propertyCssLinkVal\nVal.sink (fun theme -> if theme <> \"\" then sprintf \"/EPFileX/codemirror/content/theme/%s.css\" theme |> addCssLink) propertyThemeVal\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n    Val.map (fun csslnks ->\n        div [\n            yield! csslnks |> Seq.map (fun csslnk -> link   [ href csslnk; ``type`` \"text/css\" ; rel \"stylesheet\" ])\n        ]\n    ) cssLinks \n    |> HtmlElementV \n    css propertyCssVal\n] |> renderDoc \n\n", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"081bac32-e739-4124-87eb-eb7d6f2220bc"}, {"SnippetId" :"4e040028-ff11-458e-a43b-e8a1b7fcaeec"}, {"SnippetId" :"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"07f11803-2084-4a0a-9066-a43fd11be1c7"}, "snpName": "CodeEditor (old not used)", "snpContent": "let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n", "snpParentIdO": {"SnippetId" :"c2188026-a06a-4963-a95a-93075e5f5b6e"}, "snpPredIds": [{"SnippetId" :"081bac32-e739-4124-87eb-eb7d6f2220bc"}, {"SnippetId" :"456562f7-0757-4431-9aeb-d58b050cecf7"}, {"SnippetId" :"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"}, {"SnippetId" :"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8d84a97a-8fbf-4ee6-81c3-cf70db4adfa4"}, "snpName": "Editor2", "snpContent": "// Version using ZafirTranspiler.dll & Remote.dll\n[< JavaScript >]\nlet Main = FSharpStationClient() |> Doc.Run JS.Document.Body\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}, {"SnippetId" :"8fbd59ac-9417-4309-8d01-3ccd5d62452c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b9ca9697-6cb4-4085-b509-9f702a62086f"}, "snpName": "Site", "snpContent": "// Version using internal Rpc's\n#define FSS_SERVER\n//#define NOMESSAGING\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Server\nopen WebSharper.UI\n\ntype EndPoint = \n    | [< EndPoint \"/\" >] EPStart\n    | EPLoad of string\n    | FSharpStation\n\nlet FSharpStationPage uri =\n    Content.Page(\n        Title = \"F# Station\"\n      , Head  = [ Html.script [ attr.``type`` \"text/javascript\"; attr.src \"https://code.jquery.com/jquery-3.1.1.min.js\"] [] \n                  Html.script [ attr.``type`` \"text/javascript\"; attr.src \"/EPFileX/CIPHERSpaceLoadFiles.js\"           ] [] \n                ]\n      , Body  = [ Html.client <@  FSharpStationClient uri @> ])\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    printfn \"%A\" endpoint\n    match endpoint with\n    | FSharpStation -> FSharpStationPage \"https://raw.githubusercontent.com/amieres/FSharpStation/master/Start.fsjson\"\n    | EPStart       -> FSharpStationPage \"\"\n    | EPLoad    uri -> uri |> System.Web.HttpUtility.UrlDecode |> System.Web.HttpUtility.UrlDecode |> FSharpStationPage\n\nlet site = Application.MultiPage content\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}, {"SnippetId" :"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0dbfcc9d-8ea2-42a3-8f81-ce2bf7d0fad4"}, "snpName": "FSharpStation", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Owin.Compression\\lib\\net452\\Owin.Compression.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n//#r @\"WebSharper.Core.JavaScript.dll\"\n//#r @\"..\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.StaticFiles.ContentTypes\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\nopen WSMessagingBroker\n\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://localhost\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"http://*\"\nWebSharper.Web.Remoting.AddAllowedOrigin \"file://\"\nWebSharper.Web.Remoting.DisableCsrfProtection()\n\n[< EntryPoint >]\nlet Main args =\n    printfn \"Usage: FSharpStation URL ROOT_DIRECTORY MaxMessageSize\"\n    let url           = args |> Seq.tryItem 0 |>                   Option.defaultValue \"http://localhost:9010/\"\n    let rootDirectory = args |> Seq.tryItem 1 |>                   Option.defaultValue \"website\"\n    let max           = args |> Seq.tryItem 2 |> Option.map int |> Option.defaultValue 1_000_000\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    Broker.BrokerAgent.FssWebSocketO <- Some brokerAgent\n    let provider = FileExtensionContentTypeProvider()\n    provider.Mappings.[\".fsjson\"] <- \"application/x-fsjson\"\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseCompressionModule()\n                .UseWebSharper( WebSharperOptions(ServerRootDirectory  = rootDirectory\n                                                , Sitelet              = Some site\n                                                , BinDirectory         = \".\"\n                                                , Debug                = true                             ))\n                .UseStaticFiles(StaticFileOptions(FileSystem           = PhysicalFileSystem(rootDirectory)\n                                                , ContentTypeProvider  = provider                         ))\n                .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = max                         )\n            |> ignore\n            //let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            //listener.SetRequestProcessingLimits(1000, 1000)\n            //let maxA : int ref = ref 0\n            //let maxB : int ref = ref 0\n            //listener.GetRequestProcessingLimits(maxA, maxB)\n            //printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"b9ca9697-6cb4-4085-b509-9f702a62086f"}, {"SnippetId" :"e137b990-172b-4879-bc74-8650123b7a5d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c165e3de-7838-42a4-a7ec-2b2f8e5b69c6"}, "snpName": "Invoke FSharpStation", "snpContent": "\n[< JavaScript >]\nlet fss =\n    FSharpStationClient \"\"\n    |> RunCode.RunNode().AddBootstrap.RunDoc\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5e8209e0-9203-4fe0-8289-fb4579b24038"}, "snpName": "compile & run FSharpStation", "snpContent": "open System.IO\nopen WSMessagingBroker\n//open FsStationShared\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.RunProcess\nopen CompOptionsModule\n\nWrap.wrap {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n                           + opDirectory    /= @\"Compiled\\FSharpStation2\"\n                           + siteOptions\n                           + (opGenInternal /= \"showoptions\")\n    let  exeFile            = options?OutputFile\n    let  workDir            = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n//    let! res             = FsStationClient(\"Compile WebSharper\").CompileSnippetW options\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn           \"%s\"              res\n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9020\"\n    let  parms           = sprintf \"%A %A\" url site \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"529e1429-a4ce-48be-a89f-f13fec19bef3"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpName": "Snippets1", "snpContent": "[< JavaScript >]\nmodule Snippets =", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0a1fa320-b731-473a-93e2-dae49cc296f7"}, "snpName": "Demo Button", "snpContent": "\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode(\"HEllo\").RunHtml//PlusFree\n   \nlet m = Var.Create 0\n\nView.Sink (fun currentValue -> printfn \"Value is now %d\" currentValue) m.View\n\nprintfn \"Value starts as  %d\" m.Value\nasync {\n// After this is set, a print will occur\n// Prints: \"Value is now 1\"\n    m.Value <- 1\n\n    do! Async.Sleep 1000\n// After this is set, a second print will occur with the new value\n// Prints: \"Value is now 2\"\n    m.Value <- 2\n} |> Async.Start\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"}, "snpName": "Demo Input", "snpContent": "let inp = Template.Input.New(\"Type something...\")\n\nlet inline show3Sizes txt styleP =\n    div [\n      style styleP\n      htmlText txt\n      h2 [ htmlText txt ]\n      h1 [ htmlText <| Val.map (fun (s: string) -> s.ToUpper()) txt ]\n    ]\n    \ndiv [\n  inp.Render\n  show3Sizes inp.Var \"\"\n]    \n|> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"87770aad-e1d9-4fcb-be12-ff3c4ce58b7b"}, "snpName": "Demo TextArea", "snpContent": "let inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.RenderWith [ on.dblClick (fun e m -> \n      let v : string = e?value |> unbox\n      let s : int    = e?selectionStart |> unbox\n      let lines = v.Split '\\n'\n      lines \n      |> Seq.mapFold (fun total line -> (line, total, total + line.Length + 1), total + line.Length + 1) 0 \n      |> fst\n      |> Seq.pick (fun (line, from, to_) -> if s >= from && s < to_ then Some line else None)\n      |> JS.Alert\n      ) ]\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n  htmlElement \"menu\" // does not work anymore. support for this was dropped by Chrome\n      [ ``type`` \"context\"\n        Id       \"right-menu\"\n        htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n      ]\n  htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"}, "snpName": "Demo CodeMirror", "snpContent": "open FSAutoComplete\nopen Template\nopen Useful\n\nlet  file               = @\"D:\\Abe\\CIPHERWorkspace\\CIPHERPrototype\\WebServer\\bin\\Test.fsx\"\nlet  autoCompleteClient = FSAutoCompleteClient(\"Demo Code\")\n\ntype KeyMapAutoComplete = { \n    F2             : CodeMirrorEditor -> unit \n    ``Ctrl-Space`` : CodeMirrorEditor -> unit\n}\n\n[< Inline \"$editor.setOption('extraKeys', { 'F2': function(cm) { var pos = cm.getCursor(); $f(pos) } })\" >]\nlet addMiddleClick (f: CodeMirrorPos -> unit) (editor:CodeMirrorEditor) = ()\n\nlet showToolTip (ed:CodeMirrorEditor) =\n    printfn \"showToolTip\"\n    async {\n        let  pos = ed.GetCursor()\n        let! tip = autoCompleteClient.ToolTip(file, pos.line + 1, pos.ch + 1)\n        do   JS.Alert tip\n    } |> Async.Start\n\nlet getHints (ed:Template.CodeMirrorEditor, cb, _) =\n    async {\n        let  pos    = ed.GetCursor()\n        let  l      = ed.GetLine pos.line\n        let  word   = match l.Substring(0, pos.ch) with\n                      | REGEX @\"([a-zA-Z_]\\w*)$\" \"g\" [| txt |] -> txt\n                      | _                                      -> \"\"          \n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        let! com    = autoCompleteClient.Complete(file, pos.line + 1, pos.ch + 1)\n        cb { list   = com |> Array.map (fun (dis, rep, cls, chr) -> \n                            { text        = rep\n                              displayText = chr + \"| \" + dis\n                              className   = cls                              \n                            })\n             from   = { pos with ch = pos.ch - word.Length }\n             ``to`` = pos \n           }\n    } |> Async.Start\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet getAnnotations (txt, cb, _, ed:Template.CodeMirrorEditor) =\n    async {\n        let! res    = autoCompleteClient.Parse   (file, ed.GetValue()           )\n        match res with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n            | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n            | _ -> None\n        )\n        |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n            { message  = msg\n              severity = (if sev.ToUpper().StartsWith(\"ERR\") then \"error\" else \"warning\")\n              from     = cmPos(fl - 1, fc - 1) \n              ``to``   = cmPos(tl - 1, tc - 1)\n            }\n          )\n        |> cb\n    } |> Async.Start\n\nlet code = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\")\n       .OnRender(fun ed -> \n          ed.SetOption(\"gutter\", [| \"CodeMirror-lint-markers\" |])\n          ed.AddKeyMap({ F2             = showToolTip \n                         ``Ctrl-Space`` = showHints   ed getHints false\n                       })\n          setLint ed getAnnotations\n       )\n\ndiv [ \n      code.Render.AddChildren [ SomeAttr <| on.dblClick (fun _ _ -> JS.Alert \"HIHI\")  ]\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.Fix it now.\"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      Template.Button.New(\"Parse\").OnClick(fun _ _ -> \n          code.editorO \n          |> Option.iter (fun ed -> autoCompleteClient.Parse(file, ed.GetValue()) |> Async.map ignore |> Async.Start)\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n      h1 [ htmlText code.Var ]      \n      htmlElement \"menu\" \n          [ ``type`` \"context\"\n            Id       \"right-menu\"\n            htmlElement \"menuitem\" [ htmlAttribute \"label\" \"Goto Definition\" ; SomeAttr <| on.click (fun _ _ -> JS.Alert \"Goto Definition\")  ] \n          ]\n      htmlAttribute \"contextmenu\" \"right-menu\"\n]\n|> RunCode.RunNode().RunHtmlPlusFree", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"08e9600a-804b-4aba-a262-85f22e0cc8de"}, {"SnippetId" :"18d8153d-422c-42f6-8266-9a9d854bd6a1"}, {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"a05dd36e-a15e-4394-8013-128e21e69574"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0aa90429-4e7c-42eb-b108-3dd70e710bf1"}, "snpName": "Demo SplitterBar", "snpContent": "let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n\nprintfn \"Demo SplitterBar\"\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9682eb8f-e1de-4d7c-adca-a5e2322558c2"}, "snpName": "Demo Grid", "snpContent": "open Template\nprintfn \"Demo Grid0\"\n\nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\nprintfn \"Demo Grid00\"\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\nprintfn \"Demo Grid1\"\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div22                                                          )\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\nprintfn \"Demo Grid2\"\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n\nprintfn \"Demo Grid3\"\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}, {"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a6148457-ad15-4de6-a038-af77ff4af675"}, "snpName": "F# Station Layout1", "snpContent": "printfn \"F# Station Layout\"\nopen Template\n        \nlet output = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\n\nlet Messages =\n    [\n     \"Output\"    , Template.TextArea.New( output     ).Placeholder(\"Output:\"    ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"Errors\"    , Template.TextArea.New(\"parserMsgs\").Placeholder(\"Errors:\"    ).Title(\"Messages\"                 ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n     \"JavaScript\", Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Render\n     \"F# code\"   , Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Render\n     \"WS Result\" , div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n    ]\n\nlet inline fixedHorSplitter first px ch1 ch2 = Grid.NewBisect(first, StFixedPx, false, px, renderSplitterNode ch1, renderSplitterNode ch2).Render\nlet inline split (min:float) (max:float) ver (per:float) ch1 ch2 = Grid.NewBisect(true, StVariable, ver, per, renderSplitterNode ch1, renderSplitterNode ch2).Min(min).Max(max).Render\n\nlet title          = SHtmlNode <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\nlet snippets       = SHtmlNode <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\nlet buttons        = SHtmlNode <| div [ htmlText \"Buttons\"  ; style \"background-color: magenta\"    ]\nlet menu           = SHtmlNode <| div [ htmlText \"Menu\"     ; style \"background-color: lightgray\"  ]\nlet code           = SHtmlNode <| codeMirror\nlet messagesT      = STabStrip <| TabStrip.New([]      ).Bottom\nlet messagesB      = STabStrip <| TabStrip.New(Messages).Top\nlet messagesL      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\nlet messagesR      = STabStrip <| TabStrip.New([]      ).Top   .Vertical\n\nlet title_code     = SplitterStructure.New(       title         , code          , fixedHorSplitter true  34.0)\nlet code_buttons   = SplitterStructure.New(       title_code    , buttons       , fixedHorSplitter false 80.0)\nlet snippets_code  = SplitterStructure.New(true , snippets      , code_buttons  ,                        15.0)\nlet main_messagesB = SplitterStructure.New(       snippets_code , messagesB     , split 30. 100. false   82.0)\nlet main_messagesT = SplitterStructure.New(       messagesT     , main_messagesB, split  0.  75. false    0.0)\nlet main_messagesR = SplitterStructure.New(       main_messagesT, messagesR     , split 25. 100. true    99.5)\nlet main_messagesL = SplitterStructure.New(       messagesL     , main_messagesR, split  0.  75. true     0.0)\nlet main_window    = SplitterStructure.New(       menu          , main_messagesL, fixedHorSplitter true  50.0)\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet rootSplitter = SplitterNode.New(main_window)\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}, {"SnippetId" :"a48d72fc-5220-4dac-b3b3-98bad48b0561"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a657ae67-b4ba-4249-a2f1-a4063843c9c6"}, "snpName": "F# Station Layout2", "snpContent": "open Useful\nopen Template\n\ntype GuiPart     = \n   | GuiNode     of HtmlNode\n   | GuiAction   of Template.Action\n\nprintfn \"F# Station Layout\"\n\nlet swapped       = Var.Create (false, 15.0)\n\nlet SetTheSwap(swp, size) = swapped.Value <-  swp, size\n\nlet DoTheswap() = swapped.Value <- (not <| fst swapped.Value), 100.0 - snd swapped.Value\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Swap!\"                      ).OnClick(Do DoTheswap () )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n\nlet output = Var.Create \"HEre\"        \nlet parser = Var.Create \"HEre\"        \n\nlet mutable x: obj =  0 :> obj\n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\nlet guiParts =\n    Map [\n       \"actLoadFile      \", GuiAction actLoadFile       \n       \"actSaveFile      \", GuiAction actSaveFile       \n       \"actAddSnippet    \", GuiAction actAddSnippet     \n       \"actDeleteSnippet \", GuiAction actDeleteSnippet  \n       \"actIndentSnippet \", GuiAction actIndentSnippet  \n       \"actOutdentSnippet\", GuiAction actOutdentSnippet \n       \"actGetFsCode     \", GuiAction actGetFsCode      \n       \"actEvalCode      \", GuiAction actEvalCode       \n       \"actRunWSNewTab   \", GuiAction actRunWSNewTab    \n       \"actRunWSHere     \", GuiAction actRunWSHere      \n       \"actRunWSIn       \", GuiAction actRunWSIn        \n       \"actParseCode     \", GuiAction actParseCode      \n       \"actCompileWS     \", GuiAction actCompileWS      \n       \"actFindDefinition\", GuiAction actFindDefinition \n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"editor\"           , GuiNode   <| codeMirror\n       \"buttons\"          , GuiNode   <| buttonsH\n       \"menu\"             , GuiNode   <| menuBar\n       \"Output\"           , GuiNode   <| Template.TextArea.New( output     ).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"Parser\"           , GuiNode   <| Template.TextArea.New( parser     ).Placeholder(\"Parser Messages:\").Title(\"Parser Messages\"          ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"JavaScript\"       , GuiNode   <| Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n       \"F# code\"          , GuiNode   <| Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n       \"WS Result\"        , GuiNode   <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n       \"Properties\"       , GuiNode   <| div [ htmlText \"Property   Value\"; style \"background-color: magenta ; font-weight: 900\"  ]\n    ]\n\ntype LayoutDescription =\n    | LdSplit    of first: bool * secT: SectionType * vertical: bool * per:float * string * string\n    | LdTabStrip of top  : bool * string []\n\nlet getNode name (parts: Map<string,GuiPart>) =\n    match Map.tryFind name parts with\n    | Some(GuiNode   node) -> node\n    | Some(GuiAction act ) -> act.Button.Render\n    | _                    -> div [ htmlText (sprintf \"GuiPart %s not found\" name) ]\n\nlet rec processLayoutSteps (steps: (string * LayoutDescription) seq) (parts: Map<string,GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, ld) ->\n        match ld with\n        | LdSplit   (first, secT , vertical, per, ch1, ch2) -> Grid.NewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts) .Render\n        | LdTabStrip(top  , nodes                         ) -> TabStrip.New(nodes |> Seq.map (fun node -> node, getNode node parts)).SetTop(top).Render\n        |> GuiNode \n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter first px ch1 ch2 = LdSplit(first, StFixedPx , false, px, ch1, ch2)\nlet inline varSplitter        ver pc ch1 ch2 = LdSplit(true , StVariable, ver  , pc, ch1, ch2)\n\nlet steps = \n    seq [\n        \"messages\"     , LdTabStrip(true \n                                  , [|\n                                       \"Output\"    \n                                       \"Parser\"    \n                                       \"JavaScript\"\n                                       \"F# code\"   \n                                       \"WS Result\" \n                                    |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"editor\"\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"title_code\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"\n        \"main_messages\", varSplitter      false 82.0 \"snippets_code\" \"messages\"                            \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet layoutSteps = Var.Create steps\n\nlet finalLayout = Val.map (finishLayout guiParts) layoutSteps |> HtmlElementV\n\nlet jsonLayout = \n    \"\"\"\n    [[\"messages\",{\"LdTabStrip\":[true,[\"Parser\",\"Output\",\"JavaScript\",\"F# code\",\"WS Result\"]]}],[\"title_code\",{\"LdSplit\":[true,\"StFixedPx\",false,34,\"title\",\"editor\"]}],[\"code_buttons\",{\"LdSplit\":[false,\"StFixedPx\",false,80,\"title_code\",\"buttons\"]}],[\"snippets_code\",{\"LdSplit\":[true,\"StVariable\",true,15,\"snippets\",\"code_buttons\"]}],[\"main_messages\",{\"LdSplit\":[true,\"StVariable\",false,82,\"snippets_code\",\"messages\"]}],[\"main_window\",{\"LdSplit\":[true,\"StFixedPx\",false,50,\"menu\",\"main_messages\"]}]]\n    \"\"\"\n\ntype LayoutDescriptionFable = \n    {\n       LdTabStrip : (bool * string[]                               ) option\n       LdSplit    : (bool * string * bool * float * string * string) option  \n    }\n\nlet toSect s =\n    match s with \n    | \"StVariable\"  -> StVariable\n    | \"StFixedPx\"   -> StFixedPx\n    | _ -> StFixedPerc\n\nlet setLayoutJson json =\n    try\n        let steps = \n            json\n            |> WebSharper.Json.Deserialize<(string * LayoutDescriptionFable)[]>\n            |> Array.choose (fun (name, ldf) ->\n                ldf.LdTabStrip\n                |> Option.map LdTabStrip\n                |> (function \n                    | Some e -> Some e \n                    | None   ->\n                    ldf.LdSplit\n                    |> Option.map (fun (first, secT: string  , vertical, per, ch1, ch2) -> \n                                LdSplit(first, secT |> toSect, vertical, per, ch1, ch2)))\n                |> Option.map (fun v -> name, v)\n            )\n        layoutSteps.Value <- steps\n        printfn \"updated layoutSteps\"\n    with e -> printfn \"Error: %A\" e\n\nsetLayoutJson jsonLayout\n\nJS.Window?setLayoutJson <- setLayoutJson\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    finalLayout.Style(\"height: 100%; width: 100% \")\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                                 ; ``type`` \"text/javascript\"             ]\n    link   [ href \"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css\"       ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> RunCode.RunNode().RunHtml\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"47bf25cf-e7f5-452a-9247-156146348a14"}, {"SnippetId" :"6332dfb8-b57a-40de-b669-f796820883db"}, {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}, {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1fe628a8-4e42-47d0-bc2d-90cb7abe2153"}, "snpName": "F# Station Layout3", "snpContent": "open Useful\nopen Template\n\nprintfn \"F# Station Layout\"\n\nlet actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick(Do id ()        )  \nlet actSaveFile       = Template.Action.New(\"Swap!\"                      ).OnClick(Do id ()        )//.Highlight(dirty)\nlet actAddSnippet     = Template.Action.New(\"Add Snippet\"                ).OnClick(Do id ()        )\nlet actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actEvalCode       = Template.Action.New(\"Evaluate F#\"                ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\").OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actCompileWS      = Template.Action.New(\"Compile WebSharper\"         ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\nlet actFindDefinition = Template.Action.New(\"Find Definition\"            ).OnClick(Do id ()        )//.Disabled(noSelectionVal)\n\nlet buttonsH =\n    div [ \n          actAddSnippet    .Button.Render\n          actOutdentSnippet.Button.Render\n          actIndentSnippet .Button.Render\n          span []       \n          span []       \n          actParseCode     .Button.Render\n          actEvalCode      .Button.Render\n          actGetFsCode     .Button.Render\n       \n          actDeleteSnippet .Button.Render\n          actFindDefinition.Button.Render\n          span []       \n          actSaveFile      .Button.Render\n          span []\n          actCompileWS     .Button.Render\n          actRunWSIn       .Button.Render\n          span []       \n          style \"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(8, 12.1%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\"\n        ]\n\nlet menuLeft =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile.MenuEntry\n                        actSaveFile.MenuEntry\n                    ]           \n            )            \n        MenuEntry.New(\"Code\")           \n            .SubMenu(           \n                    [           \n                        actAddSnippet    .MenuEntry\n                        actDeleteSnippet .MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actIndentSnippet .MenuEntry\n                        actOutdentSnippet.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actFindDefinition.MenuEntry\n                        MenuEntry.New(\"\").Divider           \n                        actGetFsCode     .MenuEntry\n                    ]     \n            )      \n        MenuEntry.New(\"Run\")     \n            .SubMenu(     \n                    [     \n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider     \n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet menuRight =\n    Menu.New2\n      [\n        MenuEntry.New(\"About\")\n      ]      \n\nlet menuBar =\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -17px\" ]\n           <| menuLeft .Render \n           <| menuRight.Render\n\nlet output = Var.Create \"HEre\"        \nlet parser = Var.Create \"HEre\"        \n\nlet codeMirror = \n    Template.CodeMirror.New(\"let a = \\\"123\\\" |> Str\").Style(\"height: 100%\").Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   -> \n                JS.SetTimeout\n                    (fun () ->\n                        addResizeObserver(fun () ->\n                            let r = el.GetBoundingClientRect()\n                            output.Value <- sprintf \"%A\" (r.Width, r.Height) ) el\n                        printfn \"F# Station Layout\"\n                    )\n                    2000 |> ignore\n            )\n        ]\n\nlet layout =\n  Layout.AddGuids\n    [\n       \"actLoadFile      \", GuiAction actLoadFile       \n       \"actSaveFile      \", GuiAction actSaveFile       \n       \"actAddSnippet    \", GuiAction actAddSnippet     \n       \"actDeleteSnippet \", GuiAction actDeleteSnippet  \n       \"actIndentSnippet \", GuiAction actIndentSnippet  \n       \"actOutdentSnippet\", GuiAction actOutdentSnippet \n       \"actGetFsCode     \", GuiAction actGetFsCode      \n       \"actEvalCode      \", GuiAction actEvalCode       \n       \"actRunWSNewTab   \", GuiAction actRunWSNewTab    \n       \"actRunWSHere     \", GuiAction actRunWSHere      \n       \"actRunWSIn       \", GuiAction actRunWSIn        \n       \"actParseCode     \", GuiAction actParseCode      \n       \"actCompileWS     \", GuiAction actCompileWS      \n       \"actFindDefinition\", GuiAction actFindDefinition \n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"editor\"           , GuiNode   <| codeMirror\n       \"buttons\"          , GuiNode   <| buttonsH\n       \"menu\"             , GuiNode   <| menuBar\n       \"Output\"           , GuiNode   <| Template.TextArea.New( output     ).Placeholder(\"Output:\"         ).Title(\"Output\"                   ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"Parser\"           , GuiNode   <| Template.TextArea.New( parser     ).Placeholder(\"Parser Messages:\").Title(\"Parser Messages\"          ).RenderWith [ on.dblClick (fun _ _ -> JS.Alert \"DblClick\") ]\n       \"JavaScript\"       , GuiNode   <| Template.TextArea.New(\"codeJS    \").Placeholder(\"Javascript:\"     ).Title(\"JavaScript code generated\").Render\n       \"F# code\"          , GuiNode   <| Template.TextArea.New(\"codeFS    \").Placeholder(\"F# code:\"        ).Title(\"F# code assembled\"        ).Render\n       \"WS Result\"        , GuiNode   <| div [ div [ Id \"TestNode\" ; style \"background: white; height: 100%; width: 100%; \"] ]\n       \"Properties\"       , GuiNode   <| div [ htmlText \"Property   Value\"; style \"background-color: magenta ; font-weight: 900\"  ]\n    ]\n\nlet steps = \n    seq [\n        \"messages\"     , GuiTabStrip(true \n                                   , [|\n                                        \"Output\"    \n                                        \"Parser\"    \n                                        \"JavaScript\"\n                                        \"F# code\"   \n                                        \"WS Result\" \n                                     |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"editor\"\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"title_code\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"\n        \"main_messages\", varSplitter      false 82.0 \"snippets_code\" \"messages\"                            \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet jsonLayout = \n    \"\"\"\n    [[\"messages\",{\"GuiTabStrip\":[true,[\"Parser\",\"Output\",\"JavaScript\",\"F# code\",\"WS Result\"]]}],[\"title_code\",{\"GuiSplit\":[true,\"StFixedPx\",false,34,\"title\",\"editor\"]}],[\"code_buttons\",{\"GuiSplit\":[false,\"StFixedPx\",false,80,\"title_code\",\"buttons\"]}],[\"snippets_code\",{\"GuiSplit\":[true,\"StVariable\",true,15,\"snippets\",\"code_buttons\"]}],[\"main_messages\",{\"GuiSplit\":[true,\"StVariable\",false,82,\"snippets_code\",\"messages\"]}],[\"main_window\",{\"GuiSplit\":[true,\"StFixedPx\",false,50,\"menu\",\"main_messages\"]}]]\n    \"\"\"\nlayout.ExportSetLayoutJson \"setLayoutJson\"\nlayout.SetLayoutJson jsonLayout\n\n\n//let code_messages = SplitterStructure.New(false, title_Code           , STabStrip messages,                   75.0)\n//let main_Buttons  = SplitterStructure.New(       snippets_code        , SHtmlNode buttons                 , fixedHorSplitter2 80.0)\n\nVal.sink (fun _ -> layout.SelectTab \"Output\"    |> ignore ) output \n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    css styleEditor                                                                                                               \n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> RunCode.RunNode().AddFontAwesome.AddBulma.RunHtml\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"47bf25cf-e7f5-452a-9247-156146348a14"}, {"SnippetId" :"6332dfb8-b57a-40de-b669-f796820883db"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a54701f2-1d68-4997-a1ea-62deaeb73e1b"}, "snpName": "", "snpContent": "let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"}, "snpName": "Test mouse", "snpContent": "//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"}, "snpName": "", "snpContent": "[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"38b21610-7350-4676-993b-88fea844314f"}, "snpName": "InputSelect", "snpContent": "module InputSelect = \n    type Position =\n        | Below\n        | Right\n        | Tab\n        | NewBrowser\n        \n    let positionTxt v =\n        match v with\n        | Below      -> \"Below\"\n        | Right      -> \"Right\"\n        | Tab        -> \"In Tab\"\n        | NewBrowser -> \"New Browser\" \n    \n    let position = Var.Create Below \n    \n    let inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n        match s with\n        | \"Below\"        -> Below     \n        | \"Right\"        -> Right     \n        | \"In Tab\"       -> Tab       \n        | \"New Browser\"  -> NewBrowser\n        | _              -> prev\n        ) )\n    \n    div [\n      inp.Render\n      Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n    ]\n    |> RunCode.RunNode().RunHtml\n        ", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7754c074-862e-4550-9d61-ea837adf6d85"}, "snpName": "Regex Pattern matching", "snpContent": "// WARNING THIS CAN GET FSHARPSTATION IN AN INFINITE LOOP. RUN IT FROM A SEPARATE INSTANCE\nmodule regex1 =\n    open WebSharper.UI\n    open WebSharper.UI.Client\n    open WebSharper.UI.Html\n    // from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\n    let str    = new String(\"Bob likes pineapples.\")\n    let regex  = new RegExp(@\"^\\w+\") // matches the first word\n    let newstr = str.Replace(regex,\"Alice\")\n    \n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None\n        \n    let duple a b = a, b\n    4 * 8\n    let txt = \"\"\"Compiling to JavaScript...\n    2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning|Info)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) ?)?F?#? ?(.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    //\"\n    let rex = rex1 + \"|\" + rex2\n    \n    //[ \"JavaScript RegExp:\"\n    //  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n    //  sprintf \"Active pattern: %A\" <|\n    //      match txt with\n    //      | REGEX rex m -> m\n    //      | _           -> \"<no match>\"\n    //]\n    //|> List.map  (fun t -> div [ htmlText t ] )\n    //|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n    //|> List.map  (htmlText >> List.singleton >> div )\n    //|> (duple (style \"text-align: left\") >> List.Cons) \n    //|> RunCode.RunNode().ShowHtmlResult\n    \n    let inpVar = Var.Create txt\n    let rexVar = Var.Create rex\n    let optVar = Var.Create \"g\"\n    \n    let inp = Doc.InputArea [ \n                attr.spellcheck       \"false\"\n                attr.style            \"height: 100%;  width: 100%; box-sizing: border-box; \"\n                attr.placeholder      \"Text\"\n              ] inpVar\n\n    let rx  = div [ attr.``class``        \"input-group\"       ]\n                  [ span [ attr.``class`` \"input-group-addon\" ]\n                         [ text \"RegEx  :\" ]\n                    Doc.Input [ attr.``type``     \"text\"\n                                attr.``class``    \"form-control\"\n                                attr.placeholder  \"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\" \n                              ] rexVar\n                  ]\n    \n    let opt = div [ attr.``class``        \"input-group\"       ]\n                  [ span [ attr.``class`` \"input-group-addon\" ]\n                         [ text \"Options:\"                    ]\n                    Doc.Input [ attr.``type``     \"text\"\n                                attr.``class``    \"form-control\"\n                                attr.placeholder  \"Options: g i m u y\"\n                              ] optVar\n                  ]\n    \n    h5 [] [\n      text \" WARNING! THIS CAN GET FSHARPSTATION IN AN INFINITE LOOP. RUN IT FROM A SEPARATE INSTANCE\"\n      inp\n      rx \n      opt\n      View.Map3 (fun inp rx opt ->\n          ul [] \n             [ match inp with\n               | REGEX rx opt m -> yield! m |> Array.map (text >> List.singleton >> (li [])) |> Seq.map (fun x -> x :> Doc)\n               | _              -> yield  text \"<no match>\" \n             ]\n          :> Doc\n          ) inpVar.View rexVar.View optVar.View\n      |> Doc.BindView id\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunDoc\n    \n    //#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n    //open System.Text.RegularExpressions\n    //\n    //let (|Regex|_|) pattern input =\n    //    let m = Regex.Match(input, pattern)\n    //    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    //    else None\n    //\n    ////Example:\n    //let phone = \"(555) 555-5555\"\n    //match phone with\n    //| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n    //    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n    //| _ -> printfn \"Not a phone number\"", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ff6bfed0-83ae-4497-b197-fea6432aa958"}, "snpName": "Regex Pattern matching2", "snpContent": "module regex2 =\n    let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n        if value = null then None else\n        try \n            match String(value).Match(RegExp(expr, opt)) with\n            | null         -> None\n            | [| |]        -> None\n            | m            -> Some m\n        with e -> None \n       \n    let txt = \"\"\"Compiling to JavaScript...\n    Compiling to JavaScript...\n    Compiled!\n    0 errors, 1 warnings\n    WarningFSharp\n      \"(6)47f7c0ba-35b0-466e-a759-4e4d9963e524 codeMirror (1,11) - (1,19) typecheck 1178: The struct, record or union type 'KeyMapF2' is not structurally comparable because the type 'obj' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type 'KeyMapF2' to clarify that the type is not comparable\"\n      2 errors, 0 warnings\n    ErrFSharp\n      \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\n    ErrFSharp\n      \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \n    Evaluating F# code...\n    (6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \n    Compiling to JavaScript...\n    6 errors, 1 warnings\n    WarningFSharp\n      \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\n    ErrWebSharper\n      \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n    \"\"\"\n    let rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\n    let rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n    let rex = rex1 + \"|\" + rex2\n    \n    match txt with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n        | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n        | _ -> None\n    )\n    |> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n    |> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n    |> h5\n    |> RunCode.RunNode().ShowHtmlResult\n    ", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"}, "snpName": "Load File", "snpContent": "let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"}, "snpName": "Storage", "snpContent": "module Storage =\n    let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\n    let max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\n    let value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n    \n    let settingsStorage = JS.Window.LocalStorage\n    \n    settingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\n    settingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n    \n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\n    Val.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n    \n    let styleT   p =\n      p |> sprintf \"\"\"\n    .SplitterArea {\n        display: grid;\n        grid-template-columns: %f%% auto;\n        grid-template-areas:   \"left right\";\n        background-color: #41414d;\n        color: #444;\n        height: 50px;\n        grid-gap: 9px;\n        padding : 9px;\n    }\n    \n    .SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n    .SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n    \n    .Splitter { \n        grid-column     :    2      ;\n        grid-row        :  1/2      ;\n        width           :    5px    ; \n        margin-left     : -7.5px    ; \n        border          :    0px    ; \n        padding         :    0px    ;\n        cursor          : col-resize;\n      \tbackground-color: #eef      ; \n    }   \"\"\"\n    \n    let splitter   = Template.SplitterBar\n                         .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                         .Min(Val.map float min.Var)\n                         .Max(Val.map float max.Var)\n                         \n    \n    let bar =\n        div [\n          ``class`` \"SplitterArea\"\n          div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n          div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n          styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n          splitter.Render\n        ]\n        \n    div [\n      bar\n      min  .Render\n      max  .Render\n      value.Render\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"70030378-692d-431d-bed9-c839a7f95798"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"}, "snpName": "Messaging Test", "snpContent": "//#r @\"remote.dll\"\n\n//open CIPHERPrototype.Messaging\nopen FsStationShared\nopen System\nopen Useful\n\nlet messageTypes = \n    [\n        GetSnippetContentById CodeSnippetId.New\n        GetSnippetCodeById    CodeSnippetId.New\n        GetSnippetPredsById   CodeSnippetId.New\n        GetSnippetById        CodeSnippetId.New\n        GetSnippetContent     [||]\n        GetSnippetPreds       [||]\n        GetSnippetCode        [||]\n        GetSnippetJSCode      [||]\n        GetSnippet            [||]\n        GenericMessage        \"\"\n        GetIdentification     \n        GetWholeFile\n    ]\n    \nlet messageTxt v =\n    match v with\n    | GetSnippetContentById _ -> \"GetSnippetContentById\"\n    | GetSnippetCodeById    _ -> \"GetSnippetCodeById   \"\n    | GetSnippetPredsById   _ -> \"GetSnippetCodeById   \"\n    | GetSnippetById        _ -> \"GetSnippetById       \"\n    | GetSnippetContent     _ -> \"GetSnippetContent    \"\n    | GetSnippetPreds       _ -> \"GetSnippetPreds      \"\n    | GetSnippetCode        _ -> \"GetSnippetCode       \"\n    | GetSnippetJSCode      _ -> \"GetSnippetJSCode     \" \n    | GetSnippet            _ -> \"GetSnippet           \"\n    | GenericMessage        _ -> \"GenericMessage       \"\n    | RunSnippetUrlJS       _ -> \"RunSnippetUrlJS      \"\n    | RunSnippetUrlJSById   _ -> \"RunSnippetUrlJSById  \"\n    | GetIdentification       -> \"GetIdentification    \"\n    | GetWholeFile            -> \"GetWholeFile         \"\n\nlet fsClient = FsStationClient(\"MessagingTest\")\n\nlet snpId       = Var.Create \"\" \nlet message     = Var.Create \"\"\nlet messageType = Var.Create GetIdentification\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet getListeners _ _ =\n    async {\n        let! ls          = fsClient.MessagingClient.POListeners()\n        do   if listeners.Value <> ls then listeners.Value <- ls\n    } |> Async.Start\n\nlet requestMessage msgT (content:string) : Async<string> =\n    let msg =\n        match msgT with\n        | GetSnippetContentById _ -> GetSnippetContentById  <| CodeSnippetId (Guid content)\n        | GetSnippetCodeById    _ -> GetSnippetCodeById     <| CodeSnippetId (Guid content)\n        | GetSnippetPredsById   _ -> GetSnippetPredsById    <| CodeSnippetId (Guid content)\n        | GetSnippetById        _ -> GetSnippetById         <| CodeSnippetId (Guid content)\n        | RunSnippetUrlJSById   _ -> RunSnippetUrlJSById    <|(CodeSnippetId (Guid content), \"http://localhost:9000\")\n        | RunSnippetUrlJS       _ -> RunSnippetUrlJS        <|(content.Split '/'           , \"http://localhost:9000\")\n        | GetSnippetContent     _ -> GetSnippetContent      <| content.Split '/'\n        | GetSnippetPreds       _ -> GetSnippetPreds        <| content.Split '/'\n        | GetSnippetCode        _ -> GetSnippetCode         <| content.Split '/'\n        | GetSnippetJSCode      _ -> GetSnippetJSCode       <| content.Split '/'\n        | GetSnippet            _ -> GetSnippet             <| content.Split '/'\n        | GenericMessage        _ -> GenericMessage         <| content\n        | GetIdentification       -> GetIdentification    \n        | GetWholeFile            -> GetWholeFile         \n    async {\n        let! response = fsClient.SendMessage(AddressId(listener.Value |> Option.defaultValue \"WebServer:PostOffice\"), msg) |> Wrap.getAsync\n        let resp =\n            match response with\n            | SnippetResponse(Some snp )    -> snp  |> Json.Serialize\n            | SnippetsResponse     snps     -> snps |> Json.Serialize\n            | StringResponse (Some code)    -> code\n            | IdResponse      id            -> id\n            | _                             -> sprintf \"<Incomplete response: %A>\" response\n        return resp\n    }\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(snpId  ).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          message.Value <- \"Sending request...\"\n          let! code = requestMessage messageType.Value snpId.Value\n          message.Value <- code\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"5597a227-c983-46fc-87e2-cbe241faa279"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cc84fb0b-d0c9-4374-af92-587174f75d64"}, "snpName": "Messaging Test WebSockets", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net45\\WebSharper.Owin.WebSocket.dll\"\n\nopen WSMessagingBroker\nopen System\nopen Useful\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\nlet messaging = new WSMessagingClient(\"Messaging Test WebSockets\")\n\n[< NamedUnionCases \"type\" >]\ntype Incoming  =\n| MessageInt    of int\n| MessageString of string\n\n[< NamedUnionCases \"type\" >]\ntype Replies  =\n| ReplyInt    of int\n| ReplyString of string\n\nlet processor msg = Wrap.wrapper {\n    return\n        match msg with\n        | MessageInt    i -> ReplyString (sprintf \"%d\" i)\n        | MessageString s -> ReplyInt    (int s)\n}\n    \nmessaging.ProcessIncoming processor    \n\nlet messageTypes = \n    [\n      MsgInformation             // does not expect a reply, payload may or may not be structured\n      MsgRequest                 // expects a reply, structured payload\n      MsgReply                   // structured payload.\n      MsgFromBroker              // Broker ErrorMessage. Only Broker should use this payload is error message\n      MsgRequestForId            // expects reply as Information with id\n      MsgRequestForEcho          // expects reply as Information with same payload\n    ]\n\nlet messageTxt (v: MessageType) = sprintf \"%A\" v\n\n(*\nlet messageTxt v =\n    match v with\n    | MsgInformation    -> \"MsgInformation\"\n    | MsgRequest        -> \"MsgRequest\"\n    | MsgReply          -> \"MsgReply\"\n    | MsgFromBroker     -> \"MsgFromBroker\"\n    | MsgRequestForId   -> \"MsgRequestForId\"\n    | MsgRequestForEcho -> \"MsgRequestForEcho\"\n*)    \n\nlet content     = Var.Create \"\"\nlet message     = Var.Create \"\"\nlet messageType = Var.Create MsgInformation\n\nlet listener  : Var<string option> = Var.Create None\nlet listeners : Var<string[]     > = Var.Create [||]\n\nlet clientId      = \"Messaging Test WebSockets\"\nlet clientAddress = Address clientId\n\nlet out     s   = message.Value <- message.Value + s\nmessaging.Out  <-            out \nlet printfn fmt = printoutfn out fmt\n\nlet sendMessage() : Wrap<string> =\n    match listener.Value with\n    | None        -> Wrap.wrapper.Return(\"\")\n    | Some destId ->\n    let dest = Address destId\n    match messageType.Value with\n    | MsgInformation    \n    | MsgRequestForEcho -> newMsg           dest content.Value\n    | MsgRequestForId   -> newMsgSerialized dest \"\"           \n    | _                 -> newMsgSerialized dest content.Value\n    |> msgType messageType.Value\n    |> messaging.SendMsg\n\nlet getListeners _ _ =\n    Wrap.wrapper {\n        let! ls0 = messaging.MBListeners\n        let  ls  = ls0 |> Array.append [| MessageBrokerId |]\n        if listeners.Value <> ls then listeners.Value <- ls\n    } |> Wrap.start (printoutfn out \"%s\")\n\ndiv [\n    Doc.SelectDynOptional [ on.click getListeners ] \"--\" id    (View.Map Seq.toList listeners.View) listener    |> someElt\n    Doc.Select            [ ] messageTxt messageTypes                         messageType |> someElt\n    Template.Input   .New(content).Render\n    Template.TextArea.New(message).Render\n    Template.Button.New(\"Send Message\").OnClick(fun _ _ ->\n          if listener.Value.IsSome then\n              message.Value <- sprintf \"Sending %s...\" ((sprintf \"%A\" messageType.Value).Substring(3, 30))\n              sendMessage() |> Wrap.map ignore |> Wrap.start (printoutfn out \"%s\")\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, {"SnippetId" :"e665bede-c870-4041-b7ed-8be419c52a83"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b47dbe9c-8623-4b35-98ee-5073edfc21b3"}, "snpName": "Json.Parse", "snpContent": "module JsonParse =\n    open Useful\n    open FsStationShared\n    //let provider = WebSharper.Json.Provider\n    let inp = Template.TextArea.New(\"[ { \\\"name\\\": \\\"Hello\\\" }, { \\\"name\\\": \\\"How are you?\\\" } ]\").Placeholder(\"Text\")\n    \n    let inline ifUndef def v = if isUndefined v then def else v\n    let obj2CodeSnippetId o = \n        if isUndefined o then\n            System.Guid(\"00000000-0000-0000-0000-000000000000\")\n        else\n            o?Item\n        |> CodeSnippetId \n    \n    let obj2CodeSnippetIdO o = // the json representation of an option is different from the internal representation\n        if isUndefined o then\n            None\n        else\n            Some <| obj2CodeSnippetId o\n    \n    let obj2Map o =\n        if isUndefined o then\n            Map.empty\n        else\n            JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Map.ofSeq\n    \n//    let deserializeCodeSnipets v = \n//        try\n//            let objs= WebSharper.Json.Parse v |> unbox<obj[]>\n//            printfn \"%A\" <| Array.length objs\n//            let snps =\n//                objs\n//                |> Array.choose (fun o ->\n//                     if isUndefined o then None else\n//                     {\n//                        name         = o?name         |> ifUndef \"\"\n//                        content      = o?content      |> ifUndef \"\"\n//                        parent       = o?parent       |> obj2CodeSnippetIdO\n//                        predecessors = o?predecessors |> ifUndef [||] |> Array.map  obj2CodeSnippetId |> Seq.toList\n//                        id           = o?id           |> obj2CodeSnippetId\n//                        expanded     = o?expanded     |> ifUndef false\n//                        level        = o?level        |> ifUndef 0\n//                        properties   = o?properties   |> obj2Map\n//                      } |> Some)\n//            snps\n//        with _ -> [||]\n    \n    let parse json =\n        try WebSharper.Json.Parse json |> sprintf \"%A\"\n        with e -> sprintf \"%A\" e\n    \n    h5 [\n      inp.Render\n      div [ htmlText <| Val.map parse inp.Var ]\n    ]\n    |> RunCode.RunNode().ShowHtmlResult\n    ", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"2deb54e7-009e-4297-b2bc-1c86d04203a4"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8f3b3ae9-09e3-42cb-868f-04e8fd9e7a03"}, "snpName": "Json Serialize Deserialize", "snpContent": "// CORS does not allow Ajax calls to a different origin\n\nmodule JsonSD =\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    let value = {\n        FileName  = \"hello.fsx\"\n        IsAsync   = true\n        Lines     = [| \"line1\" ; \"line2\" ; \"line3\" |]\n        Version  = 8\n    }\n    let json = Json.Serialize value\n    let des : ParseRequest = Json.Deserialize json\n    \n    let ajaxCall url m (data:string) =\n        let ajaxInvoke (ok, ko, _) =\n            let success (result:obj)         _ _ = result :?> string                   |> ok\n            let error   (jqXHR:JQuery.JqXHR) _ _ = System.Exception jqXHR.ResponseText |> ko\n            let ajaxSettings : JQuery.AjaxSettings =\n                JQuery.AjaxSettings(\n                    Url         = url\n                  , Type        = m\n                  , ContentType = Union2Of2 \"application/json\" \n                  , DataType    = JQuery.DataType.Text\n                  , Success     = System.Action<_,_,_> success\n                  , Error       = System.Action<_,_,_> error\n                  , Data        = data\n                  , Timeout     = 300000.0\n                  , CrossDomain = true\n                )\n            JQuery.JQuery.Post ajaxSettings |> ignore\n        Async.FromContinuations ajaxInvoke\n\n    let HttpRequestCall (url:string) method_ (data:string) =\n        async {\n            let! resp = ajaxCall url method_ data           \n//            req.ProtocolVersion <- HttpVersion.Version10\n            return       resp\n        }\n        \n    let resp = Var.Create \"calling ...\"\n    async { \n        let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\" JQuery.RequestType.POST json \n        //let! r = HttpRequestCall \"https://requestb.in/q01t7aq0\" //\"http://localhost:9001/parse\" JQuery.RequestType.POST json \n        resp.Value <- r\n    } |> Async.Start\n\n    h5 [\n      div [ htmlText (sprintf \"%A\" value) ]\n      div [ htmlText json                 ]\n      div [ htmlText (sprintf \"%A\" des  ) ]\n      div [ htmlText resp                 ]\n    ]\n    |> RunCode.RunNode().ShowHtmlResult", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"054a5cfc-2353-41a2-ab17-251c87cd4f38"}, "snpName": "Grid Bisect", "snpContent": "open Template\n\nGrid.NewBisect(true, StVariable, false, 38.1953\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"One\"   ], div[ htmlText \"Two\"  ]).Render\n      , Grid.NewBisect(true, StVariable, true , 38.1953, div[ htmlText \"Three\" ], div[ htmlText \"Four\" ]).Render\n    ).Content(style \"height: 100vh\").Render\n|> RunCode.RunNode().RunHtml\n\n", "snpParentIdO": {"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpName": "Snippets2", "snpContent": "[< JavaScript >]\nmodule Snippets2 = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}, {"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"58e71035-74ac-4b97-8798-3a15d4944467"}, "snpName": "Tab Panel", "snpContent": "printfn \"strip\"\nopen Template\n#nowarn \"1178\"\n\ntype SplitterNode = | SplitterNode of Var<SplitterStructure>\nand  SplitterStructure =\n    | HtmlNode of HtmlNode\n    | TabStrip of TabStrip\n    | Split    of bool * Var<float> * SplitterNode * SplitterNode\nwith    \n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create             child1), SplitterNode (Var.Create             child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| HtmlNode child1), SplitterNode (Var.Create <| HtmlNode child2))\n    static member New(vertical : bool, child1, child2) = Split(vertical, Var.Create 50.0, SplitterNode (Var.Create <| TabStrip child1), SplitterNode (Var.Create <| TabStrip child2))\n    static member New(strip                          ) = TabStrip strip\n    static member New(node                           ) = HtmlNode node\n\nlet rec renderSplitterNode      sn = match sn with SplitterNode chV -> bindHElem (fun ch -> renderSplitterStructure ch) chV \nand     renderSplitterStructure ss =\n        match ss with\n        | HtmlNode node                -> node\n        | TabStrip strip               -> strip.Render  \n        | Split   (ver, var, ch1, ch2) ->\n        let grid = Grid.New.Content(\"one\", renderSplitterNode ch1)\n                           .Content(\"two\", renderSplitterNode ch2).Padding(0.0)\n        if ver then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n               else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render\n\ntype SplitterNode with\n    static member New        ss           = SplitterNode <| Var.Create ss\n    static member New       (ss:HtmlNode) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    static member New       (ss:TabStrip) = SplitterNode <| Var.Create (SplitterStructure.New(ss))\n    member this.Render                    = renderSplitterNode this\n    member this.Var                       = match this with SplitterNode chV -> chV\n    member this.Value                     = this.Var.Value\n    member this.SplitMe(first, ver, node) =\n        this.Var.Value <- if first then SplitterStructure.New(ver, node      , this.Value) \n                                   else SplitterStructure.New(ver, this.Value, node      )\n    member this.SplitMe(first, ver, node:TabStrip) = this.SplitMe(first, ver, TabStrip  node      )\n    member this.SplitMe(first, ver, node:HtmlNode) = this.SplitMe(first, ver, HtmlNode  node      )\n    member this.SplitMe(first, ver               ) = this.SplitMe(first, ver, TabStrip.New([||])  )\n    member this.IsEmpty                            =\n        match this.Value with\n        | HtmlNode HtmlEmpty           -> true\n        | HtmlNode _                   -> false\n        | TabStrip strip               -> strip.tabs.Value.Length = 0\n        | Split   (ver, var, ch1, ch2) -> ch1.IsEmpty && ch2.IsEmpty\n    member this.UnSplitEmpties()                   =\n        if                                    this.IsEmpty then this.Var.Value <- SplitterStructure.New(TabStrip.New([||])) else\n        match this.Value with\n        | Split   (ver, var, ch1, ch2) -> if   ch1.IsEmpty then ch2.UnSplitEmpties() ; this.Var.Value <- ch2.Value \n                                          elif ch2.IsEmpty then ch1.UnSplitEmpties() ; this.Var.Value <- ch1.Value \n                                                           else ch1.UnSplitEmpties()\n                                                                ch2.UnSplitEmpties()\n        | _                            -> ()  \n\nlet tabs1 = \n      [|\n        \"Hello\"   \n        \"How\"   \n        \"Are\"   \n        \"You\"   \n        \"Today?\"\n      |]\n\nlet tabs2 = \n      [|\n        \"Very\"   \n        \"Well\"  \n        \"Thank\" \n        \"You\"   \n      |]\n\nlet direction    = Var.Create true\nlet createdNodes = System.Collections.Generic.Dictionary<System.Guid, Dom.Element>()\n\nlet getU tabs =\n    [| for tab in tabs do \n           yield tab\n               , Template.TextArea.New(tab:string).Render\n    |]\n    \nlet getU2 tabs = tabs |> getU |> Array.map (fun def -> System.Guid.NewGuid(), def)    \n\nlet tabs1V = TabStrip.New(getU tabs1).Top   \nlet tabs2V = TabStrip.New(getU tabs2).Bottom\n\nlet rootSplitter = SplitterNode.New(SplitterStructure.New(true, tabs1V, tabs2V))\n\ndo  TabMoved <- Some (fun _ -> rootSplitter.UnSplitEmpties())\n\ndiv [ style \"height: 500px\"\n      rootSplitter.Render.Style(\"height: 100%; width: 100% \")\n      //direction\n      //|> Val.map3 (fun t1 t2 dir-> t1,t2,dir) tabs1V.tabs tabs2V.tabs\n      //|> bindHElem (fun (t1,t2,dir) ->\n      //    match t1.Length, t2.Length with\n      //    | _, 0 -> tabs1V.Render\n      //    | 0, _ -> tabs2V.Render\n      //    | _, _ -> Grid.New\n      //                   .Content(\"one\", tabs1V.Render.Style(\"height: 100%; width: 100% \")\n      //                   .Content(\"two\", tabs2V.Render.Style(\"height: 100%; width: 100% \") )\n      //              |> (fun grid -> if dir then grid.ColVariable(50.0).ColAuto(50.0).Content( style \"grid-template-areas: 'one   two' \" ).Render\n      //                                     else grid.RowVariable(50.0).RowAuto(50.0).Content( style \"grid-template-areas: 'one' 'two' \" ).Render)\n      //    |> (fun html -> html.Style(\"height: 100%; width: 100% \")\n      //)\n      Button.New(\"print\"  ).OnClick(fun _ _ -> printfn \"strip\"                                                                ).Render\n      Button.New(\"Split\"  ).OnClick(fun _ _ -> direction.Value <- not direction.Value\n                                               rootSplitter.SplitMe(false, direction.Value)                                   ).Render\n      Button.New(\"New\"    ).OnClick(fun _ _ -> tabs1V.tabs.Value <- Array.append tabs1V.tabs.Value <| getU2 [| \"New1\" |] \n                                               tabs2V.tabs.Value <- Array.append tabs2V.tabs.Value <| getU2 [| \"New2\" |]      ).Render\n      //Button.New(\"UnSplit\").OnClick(fun _ _ -> rootSplitter.UnSplitEmpties()                                                  ).Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n\n//    css \"\n//:host {\n//  all: initial;\n//  display: block;\n//  contain: content; /* Boom. CSS containment FTW. */\n//}\"\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}, {"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}, {"SnippetId" :"cddabd38-7ecb-4692-99bd-13ca70e4232f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}, "snpName": "Grid Bug", "snpContent": "\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"332b130a-111b-48ca-bd75-26f96dcbb779"}, "snpName": "Demo Action", "snpContent": "printfn \"Menu00\"\nopen Template\n\nlet actionClick act () = Val.iter (fun txt -> JS.Alert <| txt + \" Clicked!\") act.text\n\nlet actLoadFile       = Action.New(\"Load...\"                    ).OnClick2(Do2 actionClick () ) \nlet actSaveFile       = Action.New(\"Save as...\"                 ).OnClick2(Do2 actionClick () ).Highlight(true)\nlet actAddSnippet     = Action.New(\"Add Snippet\"                ).OnClick2(Do2 actionClick () )\nlet actDeleteSnippet  = Action.New(\"Delete Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actIndentSnippet  = Action.New(\"Indent Snippet\"             ).OnClick2(Do2 actionClick () )\nlet actOutdentSnippet = Action.New(\"Outdent Snippet\"            ).OnClick2(Do2 actionClick () )\nlet actGetFsCode      = Action.New(\"Get F# Code\"                ).OnClick2(Do2 actionClick () )\nlet actEvalCode       = Action.New(\"Evaluate F#\"                ).OnClick2(Do2 actionClick () )\nlet actRunWSNewTab    = Action.New(\"Run WebSharper in new tab\"  ).OnClick2(Do2 actionClick () )\nlet actRunWSHere      = Action.New(\"Run WebSharper in WS Result\").OnClick2(Do2 actionClick () )\nlet actParseCode      = Action.New(\"Parse F#\"                   ).OnClick2(Do2 actionClick () )\nlet actCompileWS      = Action.New(\"Compile WebSharper\"         ).OnClick2(Do2 actionClick () )\n\nlet menu1 =\n    Menu.New2\n      [\n        MenuEntry.New(\"File\")\n            .SubMenu(\n                    [\n                        actLoadFile      .MenuEntry\n                        actSaveFile      .MenuEntry\n                    ]\n            ) \n        MenuEntry.New(\"Code\")\n            .SubMenu(\n                    [\n                        actAddSnippet    .MenuEntry.MenuNode\n                        actDeleteSnippet .MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actIndentSnippet .MenuEntry.MenuNode\n                        actOutdentSnippet.MenuEntry.MenuNode\n                        MenuHtml <| li [ ``class`` \"divider\" ] \n                        actGetFsCode     .MenuEntry.MenuNode \n                    ]\n            ) \n        MenuEntry.New(\"Run\")\n            .SubMenu(\n                    [\n                        actEvalCode      .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actRunWSNewTab   .MenuEntry\n                        actRunWSHere     .MenuEntry\n                        MenuEntry.New(\"\").Divider\n                        actParseCode     .MenuEntry\n                        actCompileWS     .MenuEntry\n                    ]\n            ) \n      ]\n\nlet buttons =\n        div [ \n              actAddSnippet    .Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              actLoadFile      .Button.Render\n              actParseCode     .Button.Render\n              actEvalCode      .Button.Render\n              actGetFsCode     .Button.Render\n       \n              actDeleteSnippet .Button.Render\n              span []       \n              span []       \n              actSaveFile      .Button.Render\n              span []\n              actRunWSNewTab   .Button.Render\n              actCompileWS     .Button.Render\n//              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n\n\nprintfn \"Menu1\"\n\ndiv [\n    navbar <| h1 [ htmlText \"F# Station\" ; style \"font-size: 48px; margin-top: -19px\" ]\n           <| menu1.Render \n           <| menu1.Render\n    buttons\n]       \n|> RunCode.RunNode().AddBootstrap.RunHtml", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"8346ae00-dde8-4368-acad-f8cca1164ff6"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"57b45464-1dcd-4ea0-b4a8-279d5cc5621e"}, "snpName": "Properties Table", "snpContent": "\nopen Template\n\nlet props = System.Collections.Generic.Dictionary<string, string>()\n\ndo [ for i in 1..300 do yield i ]\n   |> Seq.iter (fun i -> props.Add(string i, string i) )  \n\nlet setProp k v = props.[k] <- v\n\ntype TVar(key: string) =\n    let get () = props.[key]\n    let set v  = setProp key v\n    interface IRef<string> with\n       member this.Id  = \"?\"\n       member this.Set                                   v = set v\n       member this.Value                        with set v = set v\n       member this.Get ()                                  = get()\n       member this.Value                                   = get()\n       member this.Update      (f:string -> string       ) = get() |> f |>             set\n       member this.UpdateMaybe (f:string -> string option) = get() |> f |> Option.iter set\n       member this.View                     : View<string> = get() |> View.Const\n\nlet redraw = Var.Create ()\n\nlet tableProps =\n  redraw\n  |> Val.map (fun () ->\n      table [\n        yield thead [\n            th [ htmlText \"Property\" ; style \"padding-right:10px\" ] \n            th [ htmlText \"Value\"                                 ] \n        ] \n        yield! \n            props.Keys\n            |> Seq.map (fun kvp ->\n                tr [\n                    td [ htmlText kvp ] |> hoverable\n                    td [ Doc.Input [] <| (TVar kvp :> IRef<string>) |> someElt ] |> hoverable\n                ])\n        yield tr [\n            td [ htmlText \"Add...\" ; SomeAttr <| on.click (fun _ _ ->  props.Add(\"New\", \"Prop\") ; redraw.Value <- () )]\n            td [ htmlText \"\"    ] \n        ]\n      ]\n  )\n\n\ndiv [\n  HtmlElementV tableProps\n  css \"\"\"\n    td.hovering { background: lightgray; }\n     \"\"\"\n]\n\n|> RunCode.RunNode().AddBootstrap.RunHtml", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"}, "snpName": "kimsereyblog single-page-app-with-websharper-uinext", "snpContent": "// https://kimsereyblog.blogspot.com/2015/08/single-page-app-with-websharper-uinext.html\n\n#r \"WebSharper.JQuery.dll\"\n\nopen System\nopen WebSharper\n\n[<JavaScript>]\nmodule Domain =\n    type Claim = {\n        id: string\n        name: string\n    }\n\n    type Claims = Claim list\n\n    type User = {\n        id: string\n        fullName: string\n        emailAddress: Option<string>\n        phoneNumber: Option<string>\n        enabled: bool\n        claims: Claims\n    }\n\n[<JavaScript>]\nmodule Async =\n    let map f xAsync = async { let! x = xAsync\n                               return f x      }\n    let retn x       = async { return   x      }\n\n[<JavaScript>]\nmodule AsyncApi =\n    type ApiResult<'a> =\n        | Success of 'a\n        | Failure of ApiResponseException list\n\n    and ApiResponseException =\n        | Unauthorized of string\n        | NotFound of string\n        | UnsupportedMediaType of string\n        | BadRequest of string\n        | JsonDeserializeError of string\n        override this.ToString() =\n            match this with\n            | ApiResponseException.Unauthorized         err -> err\n            | ApiResponseException.NotFound             err -> err\n            | ApiResponseException.UnsupportedMediaType err -> err\n            | ApiResponseException.BadRequest           err -> err\n            | ApiResponseException.JsonDeserializeError err -> err\n\n    let map f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x   -> return Success(f x)\n            | Failure err -> return Failure err\n        }\n\n    let retn x = async { return ApiResult.Success x }\n\n    let apply fAsyncApiResult xAsyncApiResult =\n        async {\n            let! fApiResult = fAsyncApiResult\n            let! xApiResult = xAsyncApiResult\n            match fApiResult, xApiResult with\n            | Success f   , Success x    -> return Success(f x)\n            | Success f   , Failure err  -> return Failure err\n            | Failure err , Success f    -> return Failure err\n            | Failure err1, Failure err2 -> return Failure(List.concat [ err1; err2 ])\n        }\n\n    let bind f xAsyncApiResult =\n        async {\n            let! xApiResult = xAsyncApiResult\n            match xApiResult with\n            | Success x -> return! f x\n            | Failure err -> return (Failure err)\n        }\n\n    let start xAsyncApiRes =\n        xAsyncApiRes\n        |> Async.map (fun x -> ())\n        |> Async.Start\n\n    type ApiCallBuilder() =\n\n        member this.Bind(x, f) =\n            async {\n                let! xApiResult = x\n                match xApiResult with\n                | Success x -> return! f x\n                | Failure err -> return (Failure err)\n            }\n        member this.Return x = async { return ApiResult.Success x }\n        member this.ReturnFrom x = x\n\n    let apiCall = new ApiCallBuilder()\n\n[<JavaScript>]\nmodule ApiClient =\n    open WebSharper.JavaScript\n    open WebSharper.JQuery\n    open AsyncApi\n    open Domain\n    open WebSharper.UI.Next\n\n    type AuthToken =\n        { Token : string\n          Expiry : DateTime }\n        member this.IsExpired() = DateTime.UtcNow - this.Expiry < TimeSpan.FromMinutes(10.0)\n\n        static member Make token =\n            { Token = token\n              Expiry = DateTime.UtcNow }\n\n        static member Default =\n            { Token = \"\"\n              Expiry = DateTime.UtcNow }\n\n    type ValidToken =\n        | ValidToken of string\n\n    type Credentials =\n        { Username : string\n          Password : string }\n        static member Default =\n            { Username = \"admin\"\n              Password = \"admin\" }\n\n    type RequestSettings =\n        { RequestType :  JQuery.RequestType\n          Url         :  string\n          ContentType :  string option\n          Headers     : (string * string) list option\n          Data        :  string option }\n        member this.toAjaxSettings ok ko =\n            let success  (result:obj)  (_ : string) (_ : JqXHR ) : unit = ok (result :?> string)\n            let errorf   (jqXHR:JqXHR) (_ : string) (_ : string) : unit = ko (System.Exception(string jqXHR.Status))\n            let settings =\n                JQuery.AjaxSettings\n                    (Url      = \"http://localhost/api/\" + this.Url\n                   , Type     = this.RequestType\n                   , DataType = JQuery.DataType.Text\n                   , Success  = Action<obj,string,JqXHR> success\n                   , Error    = Action<JqXHR,string,string> errorf)\n\n            this.Headers     |> Option.iter (fun h -> settings.Headers     <- Object<string>(h |> Array.ofList))\n            this.ContentType |> Option.iter (fun c -> settings.ContentType <- Union2Of2 c                      )\n            this.Data        |> Option.iter (fun d -> settings.Data        <- d                                )\n            settings\n\n    type Api =\n        { Login     : Credentials -> Async<ApiResult<unit>>\n          Logout    : unit        -> unit\n          GetUsers  : unit        -> Async<ApiResult<User list>>\n          GetClaims : unit        -> Async<ApiResult<Claims>> }\n\n    [<Literal>]\n    let tokenStorageKey = \"authtoken\"\n\n    let private ajaxCall (requestSettings : RequestSettings) =\n        Async.FromContinuations <| fun (ok, ko, _) ->\n            requestSettings.toAjaxSettings ok ko\n            |> JQuery.Ajax\n            |> ignore\n\n    let private matchErrorStatusCode url code =\n        match code with\n        | \"401\" ->\n            Failure\n                [ ApiResponseException.Unauthorized\n                  <| sprintf \"\"\"\"%s\" - 401 The Authorization header did not pass security\"\"\" url ]\n        | \"404\" -> Failure [ ApiResponseException.NotFound <| sprintf \"\"\"\"%s\" - 404 Endpoint not found\"\"\" url ]\n        | \"415\" ->\n            Failure\n                [ ApiResponseException.UnsupportedMediaType\n                  <| sprintf \"\"\"\"%s\" - 415 The request Content-Type is not supported/invalid\"\"\" url ]\n        | code -> Failure [ ApiResponseException.BadRequest <| sprintf \"\"\"\"%s\" - %s Bad request\"\"\" url code ]\n\n    let private tryDeserialize deserialization input =\n        try\n            deserialization input |> ApiResult.Success\n        with _ ->\n            Failure [ ApiResponseException.JsonDeserializeError <| sprintf \"\"\"\"{%s}\" cannot be deserialized\"\"\" input ]\n        |> Async.retn\n\n    let private getToken() =\n        try\n            JS.Window.LocalStorage.GetItem tokenStorageKey\n            |> Json.Deserialize<AuthToken>\n            |> ApiResult.Success\n        with ex -> ApiResult.Failure [ Unauthorized \"Unauthorized\" ]\n        |> Async.retn\n\n    let private refreshToken (authToken : AuthToken) =\n        async {\n            let url = \"auth/login/token/renew\"\n            if not (authToken.IsExpired()) then return ApiResult.Success authToken.Token\n            else\n                try\n                    let! token = ajaxCall {\n                                    RequestType = JQuery.RequestType.POST\n                                    Url = url\n                                    ContentType = None\n                                    Headers = Some [ \"Authorization\", \"Bearer \" + authToken.Token ]\n                                    Data = None }\n                    return ApiResult.Success token\n                with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<string>)\n        |> AsyncApi.map (ValidToken)\n\n    let private login credentials =\n        async {\n            let url = \"auth/login/token\"\n            try\n                let! token = ajaxCall {\n                                RequestType = JQuery.RequestType.POST\n                                Url = url\n                                ContentType = Some \"application/json\"\n                                Headers = None\n                                Data = Some(Json.Serialize<Credentials>(credentials)) }\n                return ApiResult.Success token\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (Json.Deserialize<string>\n                          >> AuthToken.Make\n                          |> tryDeserialize)\n        |> AsyncApi.map (fun token -> JS.Window.LocalStorage.SetItem(tokenStorageKey, Json.Serialize<AuthToken>(token)))\n\n    let private logout() = JS.Window.LocalStorage.RemoveItem(tokenStorageKey)\n\n    let private getClaims (ValidToken token) =\n        async {\n            let url = \"auth/claims\"\n            try\n                let! claims = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success(claims)\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<Claims>)\n\n    let private getUsers (ValidToken token) =\n        async {\n            let url = \"users\"\n            try\n                let! users = ajaxCall {\n                                RequestType = JQuery.RequestType.GET\n                                Url = url\n                                ContentType = None\n                                Headers = Some [ \"Authorization\", \"Bearer \" + token ]\n                                Data = None\n                            }\n                return ApiResult.Success users\n            with ex -> return matchErrorStatusCode url ex.Message\n        }\n        |> AsyncApi.bind (tryDeserialize Json.Deserialize<User list>)\n\n    let api =\n        { Login    = login\n          Logout   = logout\n          GetUsers = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getUsers  validToken\n                                }\n          GetClaims = fun () -> apiCall {\n                                    let! token      = getToken()\n                                    let! validToken = refreshToken token\n                                    return! getClaims validToken\n                                } }\n\n[<JavaScript>]\nmodule BootstrapUI =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n\n    module Button =\n        type private ButtonColor =\n            | Default\n            | Primary\n\n        type private ButtonStyle =\n            | FullWidth\n            | Inline\n\n        let private makeButton txt btnColor btnStyle action =\n            let classes =\n                [ yield \"btn\"\n                  yield match btnColor with\n                        | Default -> \"btn-default\"\n                        | Primary -> \"btn-primary\"\n                  yield match btnStyle with\n                        | FullWidth -> \"full\"\n                        | Inline -> \"inline\" ]\n                |> String.concat (\" \")\n            Doc.Button <| txt <| [ attr.``class`` classes\n                                   attr.``type`` \"submit\" ]\n            <| action\n\n        let bsBtnDefaultInline txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.Inline action\n\n        let bsBtnDefaultFull txt action =\n            makeButton txt ButtonColor.Default ButtonStyle.FullWidth action\n\n        let bsBtnPrimaryInline txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.Inline action\n\n        let bsBtnPrimaryFull txt action =\n            makeButton txt ButtonColor.Primary ButtonStyle.FullWidth action\n\n    let bsNav brand leftLinks rightLinks =\n        let navHeader =\n            divAttr [ attr.``class`` \"navbar-header\" ]\n                    [ buttonAttr [ attr.``class`` \"navbar-toggle collapsed\"\n                                   Attr.Create \"data-toggle\" \"collapse\"\n                                   Attr.Create \"data-target\" \"#menu\"\n                                   Attr.Create \"aria-expanded\" \"false\" ]\n                                 [ spanAttr [ attr.``class`` \"sr-only\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] []\n                                   spanAttr [ attr.``class`` \"icon-bar\" ] [] ]\n                      aAttr [ attr.``class`` \"navbar-brand title\"\n                              attr.href \"#\" ] [ text brand ] ]\n\n        let navMenu =\n            divAttr [ attr.``class`` \"collapse navbar-collapse\"\n                      attr.id \"menu\" ]\n                    [ ulAttr [ attr.``class`` \"nav navbar-nav\" ] [ leftLinks ]\n                      ulAttr [ attr.``class`` \"nav navbar-nav navbar-right\" ]\n                             [ rightLinks ] ]\n\n        navAttr [ attr.``class`` \"navbar navbar-default\" ]\n            [ divAttr [ attr.``class`` \"container-fluid\" ]\n                      [ navHeader; navMenu ] ] :> Doc\n\n    let bsInput placeHolder rvTxt =\n        Doc.Input [ attr.``class`` \"form-control\"\n                    attr.placeholder placeHolder ] rvTxt\n\n    let bsPasswordInput placeHolder rvPwd =\n        Doc.PasswordBox [ attr.``class`` \"form-control\"\n                          attr.placeholder placeHolder ] rvPwd\n\n    let bsPanelDefault body =\n        divAttr [ attr.``class`` \"panel panel-default\" ] [ divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsPanelDefaultWithTitle title body =\n        divAttr [ attr.``class`` \"panel panel-default\" ]\n                [ divAttr [ attr.``class`` \"panel-heading\" ]\n                          [ h3Attr  [ attr.``class`` \"panel-title\" ]\n                                    [ text title ] ]\n                  divAttr [ attr.``class`` \"panel-body\" ] body ]\n\n    let bsAlertDanger message =\n        divAttr [ attr.``class`` \"alert alert-danger\"\n                  Attr.Create \"role\" \"alert\" ] [ text message ] :> Doc\n\n    let bsRow bsCol = divAttr [ attr.``class`` \"row\" ] bsCol\n\n    let bsCol3 body = divAttr [ attr.``class`` \"col-md-3\" ] body\n\n    let bsCol4 body = divAttr [ attr.``class`` \"col-md-4\" ] body\n\n    let bsContainer body = divAttr [ attr.``class`` \"container\" ] body\n\n    let bsJumbotron title body =\n        divAttr [ attr.``class`` \"jumbotron\" ]\n                [ divAttr [ attr.``class`` \"container\" ]\n                          [ h1 [ text title ] \n                            body ] ]\n\n[<JavaScript>]\nmodule ClientRoutes =\n    open WebSharper.UI.Next\n\n    type Page =\n        | Home\n        | Claims\n        | Users\n        | Login\n        override this.ToString() =\n            match this with\n            | Home -> \"Home\"\n            | Claims -> \"Claims\"\n            | Users -> \"Users\"\n            | Login -> \"Login\"\n\n    let private map =\n        function\n        | Home -> []\n        | Claims -> [ \"claims\" ]\n        | Users -> [ \"users\" ]\n        | Login -> [ \"login\" ]\n\n    let private reverMap =\n        function\n        | [] -> Home\n        | [ \"home\" ] -> Home\n        | [ \"claims\" ] -> Claims\n        | [ \"users\" ] -> Users\n        | [ \"login\" ] -> Login\n        | _ -> failwith \"404\"\n\n    let install () =\n        RouteMap.Create map reverMap\n        |> RouteMap.Install\n\n[<JavaScript>]\nmodule NavBarPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n    open ApiClient\n\n    let private makeNavlinks routerView go =\n        routerView\n        |> View.Map(fun currentPage ->\n               [ ClientRoutes.Home; ClientRoutes.Claims; ClientRoutes.Users ]\n               |> List.map\n                      (fun page ->\n                      liAttr [ if page = currentPage then yield attr.``class`` \"active\" ]\n                             [ Doc.Link (string page) [] (fun _ -> go page) ] :> Doc)\n               |> Doc.Concat)\n        |> Doc.EmbedView\n\n    let private logout go =\n        li [ Doc.Link \"Log out\" [] (fun () ->\n                                     api.Logout()\n                                     go ClientRoutes.Login) ] :> Doc\n\n    let doc routerView go = bsNav \"admin portal\" (makeNavlinks routerView go) (logout go)\n\n\n[<JavaScript>]\nmodule LoginPage =\n    open BootstrapUI\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open ApiClient\n\n    let private login rvUsername rvPassword rvLoginError go () =\n        async {\n            let! login = api.Login { Username = Var.Get rvUsername\n                                     Password = Var.Get rvPassword }\n            match login with\n            | AsyncApi.Failure err ->\n                Var.Set rvLoginError\n                        \"You may have keyed in an invalid Username or Password. Please try again.\"\n                api.Logout()\n            | _ -> ()\n            return login\n        }\n        |> AsyncApi.map (fun _ -> go ClientRoutes.Home)\n        |> AsyncApi.start\n\n    let doc go =\n        let rvUsername = Var.Create \"\"\n        let rvPassword = Var.Create \"\"\n        let rvErr = Var.Create \"\"\n\n        let nameInput = bsInput \"Username\" rvUsername\n        let pwdInput = bsPasswordInput \"Password\" rvPassword\n        let errDiv = rvErr.View\n                     |> View.Map(fun err ->     if err = \"\" then Doc.Empty\n                                                else bsAlertDanger err)\n                     |> Doc.EmbedView\n\n        let buttons =\n            bsPanelDefault\n                [ form [ errDiv\n                         nameInput\n                         pwdInput\n                         Button.bsBtnDefaultFull \"Log in\"\n                                                 (login rvUsername rvPassword rvErr go) ] ]\n        bsRow [ bsCol4 [ Doc.Empty ]\n                bsCol4 [ h1Attr [attr.``class`` \"title\"]\n                                [text \"admin portal\"]\n                         buttons ]\n                bsCol4 [ Doc.Empty ] ]\n\n\n[<JavaScript>]\nmodule HomePage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Hello,\"\n                    ([p [text \"Welcome to the admin portal v1.0.\"] :> Doc\n                      Button.bsBtnPrimaryInline \"View claims\"\n                                                (fun () -> go ClientRoutes.Claims) :> Doc\n                      Button.bsBtnPrimaryInline \"View users\"\n                                                (fun () -> go ClientRoutes.Users) :> Doc]\n                     |> Doc.Concat)\n\n[<JavaScript>]\nmodule ClaimsPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Claims\" Doc.Empty\n\n[<JavaScript>]\nmodule UsersPage =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let doc go =\n        bsJumbotron \"Users\" Doc.Empty\n\n[<JavaScript>]\nmodule Client =\n    open WebSharper.UI.Next\n    open WebSharper.UI.Next.Html\n    open WebSharper.UI.Next.Client\n    open BootstrapUI\n\n    let Main =\n        let router = ClientRoutes.install()\n\n        let doc =\n            router.View\n            |> View.Map(fun page ->\n                   let go = Var.Set router\n\n                   let addNavBar body =\n                       [ NavBarPage.doc router.View go\n                         body ]\n                       |> Doc.Concat\n\n                   let embedInContainer body = bsContainer [ body ]\n\n                   match page with\n                   | ClientRoutes.Login ->\n                       LoginPage.doc go\n                       |> embedInContainer :> Doc\n                   | ClientRoutes.Home ->\n                       HomePage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Claims ->\n                       ClaimsPage.doc go\n                       |> embedInContainer\n                       |> addNavBar\n                   | ClientRoutes.Users ->\n                       UsersPage.doc go\n                       |> embedInContainer\n                       |> addNavBar)\n            |> Doc.EmbedView\n\n        RunCode.RunNode().AddBootstrap.RunDoc doc", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dc02ec40-9891-482d-8bdf-d409dfd3582c"}, "snpName": "Trying Fable", "snpContent": "open Useful\n\nprintfn \"Fable\"\n\n[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n[< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")      >]    \ntype Babel() =    \n    [< Inline \"Babel.transformFromAst($ast , null, $options)\"                  >] static member transformFromAst(ast , xx, options)                = X<_>\n    [< Inline \"Babel.transform       ($ast ,       $options)\"                  >] static member transform       (ast ,     options)                = X<_>\n\n[< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\") >]\ntype Fable() =\n    [< Inline \"Fable.createChecker($f, $references)\"                           >] static member createChecker(f, references)  : obj                = X<_>\n    [< Inline \"Fable.makeCompiler($replacements)\"                              >] static member makeCompiler(replacements)    : obj                = X<_>\n    [< Inline \"Fable.parseFSharpProject($checker, $com, $fileName, $source)\"   >] static member parseFSharpProject(checker, com, fileName, source) = X<_>\n    [< Inline \"Fable.compileAst($com, $fsharpAst, $fileName)\"                  >] static member compileAst(com, fsharpAst, fileName)               = X<_>\n    [< Inline \"Fable.convertToJson($babelAst)\"                                 >] static member convertToJson(babelAst)                            = X<_>\n\n\nlet [< Inline \"require.config({ skipDataMain: 1, isBrowser: 1 }) \"             >] requireConfig : obj                                              = X<_>\nlet [< Inline \"getFileBlob($key, $url)\"                                        >] getFileBlob(key, url)                                            = X<_>\nlet [< Inline \"metadata\"                                                       >] metadata : obj []                                                = X<_> \nlet [< Inline \"metadata[$fn]\"                                                  >] readAllBytes fn                                                  = X<_>\nlet [< Inline \"Object.getOwnPropertyNames(metadata).length\"                    >] metadataLength : int                                             = X<_>\nlet [< Inline \"babelPlugins\"                                                   >] babelPlugins : obj                                               = X<_>\n\n\nlet references = [|\n    \"mscorlib.dll\"\n    \"System.dll\"\n    \"System.Core.dll\"\n    \"System.Data.dll\"\n    \"System.IO.dll\"\n    \"System.Xml.dll\"\n    \"System.Numerics.dll\"\n    \"FSharp.Core.sigdata\"\n    \"FSharp.Core.dll\"\n    \"Fable.Core.dll\"\n    \"Fable.Import.Browser.dll\"\n    // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n    // However, adding the following reference prevents opening System namespace\n    // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n    // \"System.ValueTuple.dll\",\n|]\n\nreferences |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n    \nlet getChecker = \n    lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n\nlet fsCode = Template.TextArea.New(\"let mul a b = a * b\\nlet add a b = a + b\\nprintfn \\\"Multiply = %d\\\" <| mul 7 8\\nprintfn \\\"Add = %d\\\" <| add 7 8\")\nlet jsCode = Template.TextArea.New(\"\")\nlet errors = Template.TextArea.New(\"\")\nlet output = Template.TextArea.New(\"\")\n\nlet addOutput v =\n    output.Var.Value <- output.Var.Value + (if output.Var.Value = \"\" then \"\" else \"\\n\") + v\n\nlet ToConsole arg = \n    Console.Log arg\n    arg?cont addOutput\n\nlet fableTranslate source : Async<string> =\n    async {\n        while metadataLength < references.Length do\n            do! Async.Sleep 200\n        let  checker      = getChecker.Value\n        let  com          = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                , \"FSSGlobal.Snippets2.ToConsole($0)\" |]  \n        let  fileName     = \"stdin.fsx\"\n        let  fsharpAst    = Fable.parseFSharpProject(checker, com, fileName, source)\n        let  babelAst     = Fable.compileAst(com, fsharpAst, fileName)\n        let  jsonAst      = Fable.convertToJson(babelAst)\n        let  ast          = JSON.Parse(jsonAst)\n        let  options      = Object.Create null\n        options?plugins  <- [| babelPlugins?transformMacroExpressions\n                               babelPlugins?removeUnneededNulls \n                            //   \"transform-es2015-modules-amd\"    \n                            |]\n        options?presets  <- [|  |]\n        options?filename <- fileName\n        options?babelrc  <- false\n        let  transformed  = Babel.transformFromAst(ast , null, options)\n        return transformed?code\n    }\n\nlet compileCode fCode =\n    Wrap.wrapper {\n        let! jCode        = fableTranslate fCode \n        jsCode.Var.Value <- jCode\n    } |> Wrap.start (fun errs -> errors.Var.Value <- errs) \n\nlet runCode     jCode =\n    Wrap.wrapper {\n        //do!  Result.tryProtection()\n        output.Var.Value  <- \"\"\n        let  options       = Object.Create null\n        options?plugins   <- [| \"transform-es2015-modules-amd\" |]\n        options?presets   <- [|  |]\n        options?babelrc   <- false\n        let  transformed   = Babel.transform(jCode, options)\n        let  jCode2:string = transformed?code\n        let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                   .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n        JS.Eval jCode3 |> ignore\n    } |> Wrap.start addOutput \n\nVal.sink compileCode fsCode.Var\nVal.sink     runCode jsCode.Var\n\ndiv [\n style \"height: 100%\"\n Template.Grid.NewBisect(   true, Template.SectionType.StVariable, false, 80.0\n  , Template.Grid.NewBisect(true, Template.SectionType.StVariable, true , 50.0\n                      , fsCode.Render\n                      , jsCode.Render).Render\n  , Template.Grid.NewBisect(true, Template.SectionType.StVariable, true , 50.0\n                      , errors.Render\n                      , output.Render).Render\n  ).Content(style \"height: 100%\").Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}, {"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dfd9972d-4887-4c01-88df-b4c1c16016bf"}, "snpName": "Fable inline error", "snpContent": "let counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()\n      }\n      \n    member        this.Method  (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.Method  ()       = { this with a = this.a * 10 }\n    member inline this.MethodI ()       = { this with a = this.a * 10 }\n\nType.New(5).Method(false).Method(true).Method()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"19bf49f6-8a7b-4f9a-906b-27a7c1c40cde"}, "snpName": "Reactive Disable", "snpContent": "\nlet layout       = Var.Create true\nlet value        = Var.Create \"d\"\nlet disabled     = Val.map ((=) \"d\"                                           ) value \nlet text         = Val.map (fun v -> if v then \"Test1\"      else \"Test2\"      ) layout\nlet color        = Val.map (fun v -> if v then \"color: red\" else \"color: blue\") disabled\nlet button       = Template.Button.New(text).Disabled(disabled).Render\n//let colorAttr    = attr.styleDyn                          color\n//let clicked      = (fun () -> JS.Alert(\"Click\"))\n\ndiv [\n    Template.Button.New(\"Toggle\").OnClick(fun _ _ -> layout.Value <- not layout.Value).Render\n    Template.Input.New(value).Render\n    layout\n    |> Val.map (fun ly ->\n        if ly then\n               div  [ button ]\n        else\n               span [ button ]\n        )\n    |> HtmlElementV\n]    \n|> RunCode.RunNode().RunHtml\n\n(*\nlet layout   = Var.Create true\nlet value    = Var.Create \"\"\nlet disabled = View.Map ((=) \"d\") value.View \nlet button   = Html.div [ Doc.Button \"Test1\" [ attr.disabledDynPred (View.Const \"\") disabled ] id ]\n\nHtml.div [\n    Doc.Button \"Toggle\" [ ] (fun () -> layout.Value <- not layout.Value)\n    Doc.Input           [ ] value\n    layout.View\n    |> View.Map (fun ly ->\n        if ly then\n            Html.div [\n                button\n            ]\n        else\n            Html.span [\n                button\n            ]\n    )\n    |> Doc.EmbedView\n]    \n|> RunCode.RunNode().RunDoc\n*)", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a3bec308-c3bd-4fad-b400-b9a33d1b15c8"}, "snpName": "Check All WebSharper Code", "snpContent": "// add everyone as a predecessor to check if they parse/compile", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"0a1fa320-b731-473a-93e2-dae49cc296f7"}, {"SnippetId" :"0aa90429-4e7c-42eb-b108-3dd70e710bf1"}, {"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"332b130a-111b-48ca-bd75-26f96dcbb779"}, {"SnippetId" :"38b21610-7350-4676-993b-88fea844314f"}, {"SnippetId" :"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"}, {"SnippetId" :"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"}, {"SnippetId" :"58e71035-74ac-4b97-8798-3a15d4944467"}, {"SnippetId" :"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"}, {"SnippetId" :"7754c074-862e-4550-9d61-ea837adf6d85"}, {"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}, {"SnippetId" :"9682eb8f-e1de-4d7c-adca-a5e2322558c2"}, {"SnippetId" :"9ff8bc4a-76c7-4db5-b59a-9252f82fa61d"}, {"SnippetId" :"a54701f2-1d68-4997-a1ea-62deaeb73e1b"}, {"SnippetId" :"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"}, {"SnippetId" :"b47dbe9c-8623-4b35-98ee-5073edfc21b3"}, {"SnippetId" :"b9ca9697-6cb4-4085-b509-9f702a62086f"}, {"SnippetId" :"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"}, {"SnippetId" :"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"}, {"SnippetId" :"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"}, {"SnippetId" :"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"}, {"SnippetId" :"ff6bfed0-83ae-4497-b197-fea6432aa958"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"da8cf1ea-25f9-47f2-a056-0eb7a26339b6"}, "snpName": "XSL Tester", "snpContent": "open Template\nopen Useful\n\nprintfn \"XSL Tester\"\n\n\nlet menuBar = h1 [ htmlText \"XSL Tester\" ; style \"font-size: 48px; margin-top: -17px\" ]\n(*\nlet delayedRefreshCM delay (cm: CodeMirrorEditor) =      \n    async {\n        do! Async.Sleep delay\n        printfn \"Refresh %s\" <| cm.GetValue()\n        cm.Refresh() \n    }\n\nlet code (var: Var<string>) onchange =\n    let mutable cm : CodeMirrorEditor option = None\n    Template.CodeMirror.New(var).Style(\"height: 100%\")\n        .OnChange(onchange)\n        .OnRender(fun ed -> cm <- Some ed ; printfn \"OnRender %s\" var.Value)\n        .Render\n        .AddChildren [\n            SomeAttr <| on.afterRender(fun el   ->\n                let asyncStart = asyncStartCancelling()\n                JS.SetTimeout\n                    (fun () ->\n                        printfn \"afterRender %s\" var.Value\n                        addResizeObserver(fun () -> printfn \"ResizeObs %s\" var.Value ; cm |> Option.iter (delayedRefreshCM 500 >> asyncStart)   ) el\n                    )\n                    2000 |> ignore\n            )\n        ]\n*)\n\nlet output     = Template.TextArea.New(\"\").Placeholder(\"Output:\").Title(\"Output\")      \nlet xslText    = Template.TextArea.New(\"\"\"  <xsl:template match=\"/hello-world\">\n    <HTML>\n      <HEAD>\n        <TITLE></TITLE>\n      </HEAD>\n      <BODY>\n        <H1>\n          <xsl:value-of select=\"greeting\"/>\n        </H1>\n        <xsl:apply-templates select=\"greeter\"/>\n      </BODY>\n    </HTML>\n  </xsl:template>\n  <xsl:template match=\"greeter\">\n    <DIV>from <I><xsl:value-of select=\".\"/></I></DIV>\n  </xsl:template>\"\"\").Placeholder(\"xsl\"    ).Title(\"xsl\"   )     \nlet xmlText    = Template.TextArea.New(\"\"\"<hello-world>   <greeter>An XSLT Programmer</greeter>   <greeting>Hello, World!</greeting></hello-world>\"\"\").Placeholder(\"xml\"    ).Title(\"xml\"   )     \nlet resultText = Template.TextArea.New(\"\").Placeholder(\"result\" ).Title(\"result\")\n\n\n\ntype XmlNode(b: int) =\n    let a = 1\n  with\n    [< Inline \"$this.outerHTML\"                                         >] member this.OuterHTML              : string  = \"\" \n    [< Inline \"$this.innerHTML\"                                         >] member this.InnerHTML  with get( ) : string  = \"\" \n    [< Inline \"$this.innerHTML = $v\"                                    >] member this.InnerHTML  with set(v  : string) = () \n    [< Inline \"$this.firstElementChild\"                                 >] member this.FirstElementChild : XmlNode = X<_> \n    [< Inline \"$this.setAttribute($att,$v)\"                             >] member this.SetAttribute (att:string) (v:string) = () \n\ntype XmlFragment(b: int) =\n    let a = 1\n  with\n    [< Inline \"$this.children\" >] member this.children : XmlNode[] = X<_>\n\ntype XmlDocument(b: int) =\n    let a = 1\n  with\n    [< Inline \"document.implementation.createDocument($name, $element, null)\" >] new(name:string, element:string) = XmlDocument(0)\n    [< Inline \"$this.firstElementChild\"                                 >] member this.FirstElementChild : XmlNode = X<_> \n\ntype XslProcessor(b: int) =\n    let a = 1\n  with\n    [< Inline \"new XSLTProcessor()\"                        >] new() = XslProcessor(0) \n    [< Inline \"$this.transformToFragment($node, document)\" >] member this.Transform  (node: XmlNode) : XmlFragment = X<_>\n    [< Inline \"$this.importStylesheet($xsl)\"               >] member this.ImportStylesheet  (xsl: XmlDocument)  = ()\n\nopen Result\n\nlet loadXmlDoc (name:string) (root:string) (xml:string) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"doc\"\n        let xmlDoc = XmlDocument(name, root)\n        xmlDoc.FirstElementChild.InnerHTML <- xml\n        return xmlDoc\n    }\n\nlet loadXslProc (xsl:string) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"proc\"\n        let  xslProc  = XslProcessor()\n        let! xslRef   = loadXmlDoc \"http://www.w3.org/1999/XSL/Transform\" \"xsl:stylesheet\" xsl\n        xslProc.ImportStylesheet xslRef\n        return xslProc\n    } \n\nlet transformer(xslProcR:Result<XslProcessor>, xmlDocR:Result<XmlDocument>) =\n    result {\n        do! Result.tryProtection()\n        printfn  \"transform\"\n        let! xmlDoc   = xmlDocR \n        let! xslProc  = xslProcR\n        let  result   = xslProc.Transform xmlDoc.FirstElementChild.FirstElementChild\n        return result.children |> Array.map (fun n -> n.OuterHTML) |> String.concat \"\\n\"\n    } \n    |> function\n       | Success (x, ms) -> x , ms\n       | Failure     ms  -> \"\", ms\n    |> fun (r, ms) -> \n        resultText.Var.Value <- r\n        output    .Var.Value <- getMessages ms\n\nVal.sink transformer (Val.map2 (fun a b -> a, b) \n                               (Val.map loadXslProc           xslText.Var) \n                               (Val.map (loadXmlDoc \"\" \"xml\") xmlText.Var))\n\nlet steps =\n  Layout.AddGuids\n    [\n       \"title\"            , GuiNode   <| div [ htmlText \"Title\"    ; style \"background-color: lightblue\"  ]\n       \"snippets\"         , GuiNode   <| div [ htmlText \"Snippets\" ; style \"background-color: lightgreen\" ]\n       \"Output\"           , GuiNode   <| output    .Render \n       \"XSL\"              , GuiNode   <| xslText   .Render\n       \"XML\"              , GuiNode   <| xmlText   .Render\n       \"Result\"           , GuiNode   <| resultText.Render\n       \"codeXX\"           , GuiTabStrip(     true ,  [| \"XSL\"    \n                                                        \"XML\"    |])\n       \"tResult\"          , GuiTabStrip(     true ,  [| \"Result\" |])\n       \"tOutput\"          , GuiTabStrip(     true ,  [| \"Output\" |])\n       \"menu\"             , GuiNode   <| menuBar\n//       \"codeXX\"           , varVerSplitter          50.0 \"tXML\"          \"tXSL\"            0.0 100.0\n       \"codeLR\"           , varVerSplitter          50.0 \"codeXX\"        \"tResult\"         0.0 100.0\n       \"main_messages\"    , varHorSplitter          82.0 \"codeLR\"        \"tOutput\"        35.0 100.0             \n       \"main\"             , fixedHorSplitter true   50.0 \"menu\"          \"main_messages\"\n    ]\n           \n\nlet layout = Layout.New steps\n\nlet styleEditor    =\n     \"\"\"\nbody { margin: 0px }     \n     \ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { text-decoration: underline lightblue } \n.Error   { text-decoration: underline red       } \n.body    { margin         : 0px                 }\n    \"\"\"\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    layout.Render.Style(\"height: 100%; width: 100% \")\n    script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ]\n    script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ]\n    link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n    style  \"\"\" \n          color      : #333;\n          font-size  : small;\n          font-family: monospace;\n          line-height: 1.2;\n              \"\"\"\n] \n|> renderDoc\n|> RunCode.RunNode().RunDoc\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}, {"SnippetId" :"ece85c79-829d-4bec-a607-a1cd01f9dafa"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c819dae6-fd00-440b-9eb8-c97750fa5efd"}, "snpName": "Html Indent Compact mode", "snpContent": "\nlet best =\n    !!section      [ ``class`` \"section\"     ]\n      --div        [ ``class`` \"container\"   ]\n      ----h1       [ ``class`` \"title\"       ]\n      ------str                \"Hello World\"\n      ----p        [ ``class`` \"subtitle\"    ]\n      ------str                \"My first website with \"\n      ------strong [ str       \"Bulma\"       ]\n      ------str                \"!\"\n    |> endHtmlIndent \n\nlet compact = \n    !!section      [ ``class`` \"section\"     ]\n      + div        [ ``class`` \"container\"   ]\n        + h1       [ ``class`` \"title\"       ]\n        --- str                \"Hello World\"\n        + p        [ ``class`` \"subtitle\"    ]\n          - str                \"My first website with \"\n          - strong [ str       \"Bulma\"       ]\n        --- str                \"!\"\n    |> endHtmlIndent\n    \nlet originalIndented =    \n    section [ ``class``            \"section\"   \n              div [ ``class``      \"container\" \n                    h1 [ ``class`` \"title\" \n                         str       \"Hello World\" ]\n                    p  [ ``class`` \"subtitle\"  \n                         str       \"My first website with \"\n                         strong [ str \"Bulma\"    ]\n                         str       \"!\"           ] ] ]\n\nlet originalBarelyIndented =\n    section [ \n      ``class`` \"section\"   \n      div   [ \n        ``class`` \"container\" \n        h1 [\n          ``class`` \"title\" \n          str \"Hello World\"\n        ]\n        p  [ \n          ``class`` \"subtitle\"  \n          str \"My first website with \"\n          strong [\n              str \"Bulma\"\n          ]\n          str \"!\"\n        ]\n      ]\n    ]\n\nmodule Try1 =  // this one does not indent out\n    let ( +- ) (a: HtmlNode) (b: HtmlNode) = a.AddChildren [ b ]\n    let ( -- ) (a: HtmlNode) (b: HtmlNode) = a.AddChildren [ b ]\n    let def =\n        section  [ ``class`` \"section\"   ]\n        +- div   [ ``class`` \"container\" ]\n           +- h1 [ ``class`` \"title\" ]\n              +- str \"Hello World\"\n           -- p  [ ``class`` \"subtitle\"  ]\n              +-   str \"My first website with \"\n              --  strong []\n                  +-    str \"Bulma\"\n              --   str \"!\"\n\nmodule Try2 =\n    let inline ( -  ) (ps:HtmlNode list) (chn) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:HtmlNode list) (r:HtmlNode list -> HtmlNode) : (HtmlNode list) = r [] ::ps\n    \n    let start (r:HtmlNode list -> HtmlNode)                            = [ r [] ]\n    let out (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.AddChildren [h] :: tail\n\n    let inline ( -<<- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n    let inline ( ---- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n\n    let x = 0\n\n    let rec finishO (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finishO <| out ps        \n\n    let finish ps = finishO ps |> Option.defaultWith (fun () -> str \"Malformed HTMLNode\")\n\n    let def =\n        start \n          section \n          -     ``class`` \"section\"   \n          + div   \n            -   ``class`` \"container\" \n            + h1\n              - ``class`` \"title\" \n              -   str     \"Hello World\"\n              ----x\n            + p  \n              - ``class`` \"subtitle\"  \n              -   str     \"My first website with \"\n              + strong \n                - str     \"Bulma\"\n                ----x\n              -   str     \"!\"\n      |> finish \n\nmodule Try3 =\n    let inline ( -  ) (ps:HtmlNode list) (chn) : HtmlNode list = \n        match ps with \n        | h :: tail -> h.AddChildren [chn] :: tail\n        | [] -> []        \n    let inline ( +  ) (ps:HtmlNode list) (r:HtmlNode) : (HtmlNode list) = r::ps\n    \n    let start (r:HtmlNode list -> HtmlNode) (l:HtmlNode list)                        = [ r l ]\n    let out (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> [ ]\n        | [h]            -> [h]\n        | h :: p :: tail -> p.AddChildren [h] :: tail\n\n    let inline ( -<<- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n    let inline ( ---- ) (ps:HtmlNode list) (_) : HtmlNode list = out ps\n\n    let x = 0\n\n    let rec finishO (ps:HtmlNode list) =\n        match ps with\n        | [ ]            -> None\n        | [h]            -> Some h\n        | h :: p :: tail -> finishO <| out ps        \n\n    let finish ps = finishO ps |> Option.defaultWith (fun () -> str \"Malformed HTMLNode\")\n\n    let def =\n        start \n          section      [ ``class`` \"section\"   ]\n          + div        [ ``class`` \"container\" ]\n            + h1       [ ``class`` \"title\"     ]\n              - str     \"Hello World\"\n              ----x\n            + p        [ ``class`` \"subtitle\"  ]\n              - str     \"My first website with \"\n              - strong [ str     \"Bulma\"  ]\n              - str     \"!\"\n      |> finish \n\ndiv [\n    best\n    compact\n    originalBarelyIndented\n    originalBarelyIndented\n    Try1.def\n    Try2.def\n    Try3.def\n]      \n|> RunCode.RunNode().AddFontAwesome.AddBulma.RunHtml\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"47bf25cf-e7f5-452a-9247-156146348a14"}, {"SnippetId" :"6332dfb8-b57a-40de-b669-f796820883db"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fa514631-1594-4dd9-b5ea-0dd24f2205b4"}, "snpName": "Ace Code Editor // does not mark the right place", "snpContent": "#nowarn \"1182\"\n\nlet mutable aceEditor : obj option = None\n\nlet aceFiles = [|\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ace.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-language_tools.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-options.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/mode-ocaml.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-beautify.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-elastic_tabstops_lite.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-emmet.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-error_marker.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-keybinding_menu.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-language_tools.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-linking.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-modelist.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-options.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-searchbox.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-settings_menu.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-spellcheck.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-split.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-static_highlight.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-statusbar.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-textarea.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-themelist.js\"\n    \"https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.1/ext-whitespace.js\"\n|]\n\n[< Inline \"window.ace\" >]\nlet ace:obj = X<_>\n\n[<Inline \"new $ace.Range($l1, $c1, $l2, $c2)\">]\nlet range0 ace (l1:int) (c1:int) (l2:int) (c2:int) :obj = ace?Range  l1 c1 l2 c2\nlet newRange   (l1:int) (c1:int) (l2:int) (c2:int) :obj = range0 ace l1 c1 l2 c2\n\nlet addMarker ed         startRow startColumn endRow endColumn =\n    let range = newRange startRow startColumn endRow endColumn\n    let session = ed?session\n    range?start   <- session?doc?createAnchor range?start\n    range?``end`` <- session?doc?createAnchor range?``end``\n    let id = JS.Apply session \"addMarker\" [| range ; \"marker\" |]\n    id\n\nlet editor =\n    div [ \n        css  \".aceEditor { width:  100%; height: 100%; }\n            .marker { background: blue; }\n        \"\n        div [\n            ``class`` \"aceEditor\"\n            Id        \"aceEditor\"\n            htmlText \"Hello World\"\n            SomeAttr <| on.afterRender (fun el ->\n                LoadFiles aceFiles\n                    (fun () ->                       \n                       let editor = ace?edit el\n                       JS.Window?console?log editor\n                       editor?setTheme        \"ace/theme/twilight\"\n                       editor?session?setMode \"ace/mode/ocaml\"\n                       editor?setOption?apply(\"enableBasicAutocompletion\", true)\n                       addMarker editor 0 1 0 4 |> ignore\n                       aceEditor <- Some editor\n                       ()\n                    )\n            )\n        ]\n     ]\n\neditor   \n|> fun el -> el.AddChildren [ style \"height: 600px ; width: 1000px\" ]\n|> RunCode.RunNode(useShadowRoot = false).ShowHtmlResult\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c6e83584-7ab1-4ff7-bb62-16cbc3198b65"}, "snpName": "FableModule", "snpContent": "[< JavaScript >]\nmodule FableModule =\n    open Useful\n    \n    //[< Require(typeof<Resources.BaseResource>, \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\")      >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    type Babel() =    \n        [< Inline \"Babel.transformFromAst($_ast , null, $_options)\"                  >] static member transformFromAst(_ast , _xx, _options)                = X<_>\n        [< Inline \"Babel.transform       ($_ast ,       $_options)\"                  >] static member transform       (_ast ,      _options)                = X<_>\n    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable/babel-standalone.js\")                               >]    \n    [< Require(typeof<Resources.BaseResource>, \"/EPFileX/Fable\", \"Fable.js\", \"Worker.js\")                          >]\n    type Fable() =\n        [< Inline \"Fable.createChecker($_f, $_references)\"                           >] static member createChecker(_f, _references)  : obj                  = X<_>\n        [< Inline \"Fable.makeCompiler($_replacements)\"                               >] static member makeCompiler(_replacements)     : obj                  = X<_>\n        [< Inline \"Fable.parseFSharpProject($_checker, $_com, $_fileName, $_source)\" >] static member parseFSharpProject(_checker, _com, _fileName, _source:string) = X<_>\n        [< Inline \"Fable.compileAst($_com, $_fsharpAst, $_fileName)\"                 >] static member compileAst(_com, _fsharpAst, _fileName)                = X<_>\n        [< Inline \"Fable.convertToJson($_babelAst)\"                                  >] static member convertToJson(_babelAst)                               = X<_>\n    \n    let [< Inline \"getFileBlob($_key, $_url)\"                                        >] getFileBlob(_key, _url)                                              = X<_>\n    let [< Inline \"metadata[$_fn]\"                                                   >] readAllBytes _fn                                                     = X<_>\n    let [< Inline \"Object.getOwnPropertyNames(metadata).length\"                      >] metadataLength (): int                                               = X<_>\n    let [< Inline \"babelPlugins\"                                                     >] babelPlugins () : obj                                                = X<_>\n    \n    \n    let references = [|\n        \"mscorlib.dll\"\n        \"System.dll\"\n        \"System.Core.dll\"\n        \"System.Data.dll\"\n        \"System.IO.dll\"\n        \"System.Xml.dll\"\n        \"System.Numerics.dll\"\n        \"FSharp.Core.sigdata\"\n        \"FSharp.Core.dll\"\n        \"Fable.Core.dll\"\n        \"Fable.Import.Browser.dll\"\n        // When loading the REPL the browser console always shows: \"Cannot find type System.ValueTuple`1\"\n        // However, adding the following reference prevents opening System namespace\n        // See https://github.com/fable-compiler/Fable/issues/1152#issuecomment-330315250\n        // \"System.ValueTuple.dll\",\n    |]\n\n    let loadReferences =\n        lazy\n            async {\n                do! LoadFilesAsync [| \"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js\" |] \n                let  options          = Object.Create null\n                options?skipDataMain <- 1\n                options?isBrowser    <- 1\n                JS.Window?require?config options\n                references |> Seq.iter (fun fn -> getFileBlob(fn, \"metadata/\" + fn))\n            } |> Async.Start\n        \n    let getChecker = \n        lazy Fable.createChecker(readAllBytes, references |> Array.choose (fun fn -> if fn.Contains \"sigdata\" then None else Some <| fn.Replace(\".dll\", \"\")) )\n        \n    let mutable addOutMsg : string -> unit = Console.Log\n\n    let ToConsole arg = \n        Console.Log arg\n        arg?cont addOutMsg\n\n    let fableTranslate source : Wrap<string> =\n        Wrap.wrapper {\n            loadReferences.Value\n            do! async { \n                    while metadataLength() < references.Length do\n                        do! Async.Sleep 200\n                }\n            let  checker       = getChecker.Value\n            let  com           = Fable.makeCompiler [| \"Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine\"\n                                                     , \"FSSGlobal.FSharpStation.FableModule.ToConsole($0)\" |]  \n            let  fileName      = \"stdin.fsx\"\n            let  fsharpAst     = Fable.parseFSharpProject(checker, com, fileName, source)\n            let  babelAst      = Fable.compileAst(com, fsharpAst, fileName)\n            let  jsonAst       = Fable.convertToJson(babelAst)\n            let  ast           = JSON.Parse(jsonAst)\n            let  options       = Object.Create null\n            options?plugins   <- [| babelPlugins()?transformMacroExpressions\n                                    babelPlugins()?removeUnneededNulls \n                                    \"transform-es2015-modules-amd\"    \n                                 |]\n            options?presets   <- [|  |]\n            options?filename  <- fileName\n            options?babelrc   <- false\n            let  transformed   = Babel.transformFromAst(ast , null, options)\n            let  jCode2:string = transformed?code\n            let  jCode3        = jCode2.Replace(\"define([\"       , \"require([\")\n                                       .Replace(\"\\\"use strict\\\";\", \"\\\"use strict\\\"; try { exports = exports || {}; } catch (err) {}\")\n            return jCode3\n        }\n    \n    ", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}, {"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"40e7813c-964c-4181-9832-54ec1f538386"}, "snpName": "Thermostat Layout", "snpContent": "open Template\n\nlet thermostatDisplay name temp mode state fanState (set: IRef<string>) =\n    let title       = \n        h2 [ htmlText name ; style \"\"]\n    let information = \n        div [ h3 [ htmlText (temp |> float |> sprintf \"%A°F\") ]\n              h4 [ div [ htmlText state    ]\n                   div [ htmlText fanState ]\n                 ]\n            ]\n    let settings    = \n        div [ Template.Input.New(set).Prefix(\n                  Template.Button.New(\"Set:\").OnClick(fun _ _ -> ()).Render\n              ).Render.Style(\"\")\n              css \"\n                  .thermostat {\n                      text-align      : center     ; \n                  }\n                  .thermostat h2, .thermostat h3, .thermostat h4  {\n                      margin-top      : 3px     ; \n                  }\n                  .thermostat.ModeCool {\n                      background-color: blueviolet; \n                      color: white;\n                  }\n                  .thermostat.ModeCool button {\n                      background-color: navy; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat {\n                      background-color: firebrick; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat button {\n                      background-color: darkred; \n                      color: white;\n                  }\n                \"\n            ]\n    let layout =            \n        Layout.AddGuids\n          [\n             \"title\"        , GuiNode title\n             \"information\"  , GuiNode information\n             \"settings\"     , GuiNode settings\n             \"data\"         , fixPcVerSplitter true  50.0 \"information\"   \"settings\"\n             \"main\"         , fixPcHorSplitter true  25.0 \"title\"         \"data\"\n          ]\n        |> Layout.New\n    layout.Render\n        .Style(\"\n            width   : 200px;\n            grid-gap: 0px  ; \n            margin  : 10px ; \n         \" )\n        .AddClass(sprintf \"shadow panel thermostat Mode%s\" mode)\n\ndiv [ thermostatDisplay \"Arriba\" \"74\"   \"Cool\" \"Cooling\" \"\"       <| Var.Create \"74.50\"\n      thermostatDisplay \"Abajo\"  \"72.5\" \"Heat\" \"Heating\" \"Fan:on\" <| Var.Create \"72.50\"\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"062caaa2-87ef-4794-8ed3-90f80dc529a8"}, "snpName": "purescript", "snpContent": "// PURESCRIPT (Haskell) code of a Flare reactive applet with state:  try.purescript.org\n//\n// module Main where\n// \n// import Prelude\n// import Math\n// import Flare\n// \n// fspipe  :: forall a b. a -> (a -> b) -> b\n// fspipe  a f = f a\n// infixl 1 fspipe  as |>\n// \n// fsbpipe :: forall a b. (a -> b) -> a -> b\n// fsbpipe f a = f a\n// infixl 1 fsbpipe as <|\n// \n// appButton txt   fU  =\n//   fU\n//   |> map      (\\f pressed -> if pressed then f else id)\n//   |> apply <| button txt false true\n// \n// incdec true v  state =  v + state\n// incdec _    v  state = -v + state\n// \n// main = \n//   pure incdec\n//   |> apply   <| boolean \"Increment\" true      \n//   |> apply   <| int     \"value\"     7   \n//   |> onclick \"Do it\"\n//   |> foldp   ($)  0\n//   |> runFlareShow \"controls\" \"output\"\n\n#r @\"../packages/WebSharper.Formlets/lib/net40/WebSharper.Formlets.dll\"\n#r @\"../packages/WebSharper.Html/lib/net40/WebSharper.Html.Client.dll\"\n#r @\"../packages/WebSharper.Reactive/lib/net40/IntelliFactory.Reactive.dll\"\n\nopen WebSharper.Formlets\n//open WebSharper.UI\n//open WebSharper.Html.Client\n\nlet incdec inc (v:int) = ((+) (if inc then v else -v))\n\nlet appButton txt   fU  =\n   fU\n   |> Formlet.Map      (fun f _pressed -> f)\n   <*> WebSharper.Formlets.Controls.Button  txt\n\nlet formlet = \n    Formlet.Return incdec\n    <*> WebSharper.Formlets.Controls.Checkbox true\n    <*> (WebSharper.Formlets.Controls.Input \"4\" |> Formlet.Map int)\n    |> appButton \"Do it\"\n    |> Formlet.Flowlet\n    |> Formlet.Run ignore\n    \nWebSharper.UI.Next.Doc.Element [ formlet ]\n//|> RunCode.RunNode().RunDoc", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cd685fab-7e8c-4161-a91b-3b82ff600c0c"}, "snpName": "WebSharper Data JsonProvider", "snpContent": "#r @\"..\\packages\\FSharp.Data\\lib\\net45\\FSharp.Data.dll\"\n#r @\"..\\packages\\WebSharper.Data\\lib\\net461\\WebSharper.Data.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\nopen FSharp.Data\n\ntype Simple = JsonProvider<\"\"\" { \"name\":\"John\", \"age\":94 } \"\"\">\nlet  simple = Simple.Parse(\"\"\" { \"name\":\"Tomas\", \"age\":4 } \"\"\")\n\nlet Main =\n    div [\n        htmlText (sprintf \"age: %d\" simple.Age)\n    ]\n    |> RunCode.RunNode().AddBootstrap.RunHtml\n\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3f0bf09c-1de2-414a-a616-60e0b4ea2b36"}, "snpName": "mbrace", "snpContent": "//let print x = printfn \"%A\" x\n\n//#load @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\HandsOnTutorial.FSharp\\ThespianCluster.fsx\"\n\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\HandsOnTutorial.FSharp\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools\" \n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/Streams/lib/net45\" \n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/Streams/lib/net45/Streams.dll\"\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Flow/lib/net45\" \n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Flow/lib/net45/MBrace.Flow.dll\"\n//#load @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/MBrace.Thespian.fsx\"\n\n#I @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Newtonsoft.Json.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/FsPickler.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/FsPickler.Json.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Mono.Cecil.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Vagabond.AssemblyParser.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Vagabond.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Thespian.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/Argu.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Core.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Runtime.dll\"\n#r @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/MBrace.Thespian.dll\"\n\nopen System.IO\nopen MBrace.Thespian\n\nThespianWorker.LocalExecutable <- Path.Combine(__SOURCE_DIRECTORY__,  @\"D:\\Abe\\CIPHERWorkspace\\MBrace.StarterKit\\packages/MBrace.Thespian/tools/mbrace.thespian.worker.exe\")\n\nmodule Config = \n\n    open MBrace.Core\n    open MBrace.Runtime\n    open MBrace.Thespian\n\n    // change to alter cluster size\n    let private workerCount = 4\n    \n    let mutable private thespian = None\n    /// Gets or creates a new Thespian cluster session.\n    let GetCluster() = \n        match thespian with \n        | None -> \n            let cluster = \n                ThespianCluster.InitOnCurrentMachine(workerCount, \n                                                     logger = new ConsoleLogger(), \n                                                     logLevel = LogLevel.Info)\n            thespian <- Some cluster\n        | Some t -> ()\n        thespian.Value\n\n    /// Kills the current cluster session\n    let KillCluster() =\n        match thespian with\n        | None -> ()\n        | Some t -> t.KillAllWorkers() ; thespian <- None\n\n\n\n(*** hide ***)\n//#load \"AzureCluster.fsx\"\n//#load \"AwsCluster.fsx\"\n\n// Note: Before running, choose your cluster version at the top of this script.\n// If necessary, edit AzureCluster.fsx to enter your connection strings.\n\nopen System\nopen System.IO\nopen MBrace.Core\nopen MBrace.Flow\n\n(**\n\n# Your First 'Hello World' Computation with MBrace\n\n> This tutorial is from the [MBrace Starter Kit](https://github.com/mbraceproject/MBrace.StarterKit).\n\nA guide to creating a cluster is [here](http://www.mbrace.io/#try).\n\nStart F# Interactive in your editor.  Highlight the text below and press \"Alt-Enter\" (Visual Studio) or the other\nappropriate execution command for your editor. This connects to the cluster.  If you are using a locally simulated\ncluster it also creates the cluster.\n\n*)\n\nlet cluster = Config.GetCluster()\n\n(**\nNext, get details of the workers in your cluster. Again, highlight the text below and\nexecute it in your scripting client:\n*)    \n\ncluster.ShowWorkers()\n\n\n(** Alternatively we can do this all in one line: *)\nlet quickText = \n    cloud { return \"Hello world!\" } \n    |> cluster.Run\n\n\n(** To check that you are running in the cloud, compare a workflow running locally \nwith one using cloud execution. (Note, if using an MBrace.Thespian locally simulated\ncluster, these will be identical.) *)\nlet localResult =\n    cloud { printfn \"hello, world\" ; return Environment.MachineName }\n    |> cluster.RunLocally\n\nlet remoteResult =\n    cloud { printfn \"hello, world\" ; return Environment.MachineName }\n    |> cluster.Run\n\n//(** \n//\n//## Controlling the Cluster\n//\n//To view the history of processes, execute the following line from your scriptin\n//*)\n//\n//cluster.ShowProcesses()\n//\n//(**\n//In case you run into trouble, you can clear all process records in the cluster\n//by executing the following from your scripting client:\n//*)\n//\n//cluster.ClearAllProcesses()\n//\n//(**\n//\n//> Note, you can use the above techniques from both scripts and compiled projects. To see the components referenced \n//> by this script, see [ThespianCluster.fsx](ThespianCluster.html) or [AzureCluster.fsx](AzureCluster.html).\n//\n//**)\n\n\n\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f5890da9-9fb8-4274-ab4f-23c77bc81cf0"}, "snpName": "mbrace2", "snpContent": "(** Now execute your first cloud workflow, returning a handle to the running job: *)\n//let task = \n//    cloud { return \"Hello world!\" } \n//    |> cluster.CreateProcess\n\n(** This submits a task to the cluster. To get details for the task, execute the \nfollowing in your scripting client: *)\n\n//task.ShowInfo()\n\n(** Your task is likely complete by now.  To get the result returned by your \ntask, execute the following in your scripting client: *)\nlet text = task.Result\n\nlet localResult =\n    cloud { printfn \"hello, local world\" ; return Environment.MachineName }\n    |> cluster.RunLocally\n\nlet remoteResult =\n    cloud { printfn \"hello, remote world\" ; return Environment.MachineName }\n    |> cluster.Run\n\n[\n    task.Result\n    localResult\n    remoteResult\n] |> printfn \"%A\"", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"52153260-1fc1-4a4d-b917-b4ad1776745f"}, "snpName": "", "snpContent": "open WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nopen WebSharper.UI\nopen WebSharper.UI.Client\nopen WebSharper.UI.Html\n\n\n[<JavaScript>]\nmodule Code =\n    type Person = { Username: string; Name: string }\n    \n    let myPeopleColl =\n        ListModel.Create (fun p -> p.Username)\n            [ { Username = \"johnny87\"; Name = \"John\" };\n              { Username = \"theana12\"; Name = \"Ana\" } ]\n\n    let inline concatn n x = \n        Console.Log (\"concat \" + n)\n        Doc.Concat x\n              \n    let myPeopleList =\n        myPeopleColl.ViewState\n        |> Doc.BindView (fun people ->\n            Console.Log \"people\"\n            ul [] [\n                people\n                |> Seq.map (fun p -> \n                    Console.Log p.Username\n                    li [] [ text p.Name ] :> Doc)\n                |> concatn \"BindView\"\n            ] :> Doc\n        )\n        \n    let myDoc =\n        myPeopleColl.Map(fun v ->\n            Console.Log v.Username\n            p [] [ text v.Name ] :> Doc\n        )\n        |> Doc.BindView (concatn \"Map\")\n        \n    let myDoc2 =\n        myPeopleColl.Map(fun k vp ->\n            Console.Log k\n            p [] [ text (vp.V.Name) ] :> Doc\n        )        \n        |> Doc.BindView (concatn \"Map2\")\n\n    let myDoc3 =\n        myPeopleColl.MapLens(fun k vp ->\n            Console.Log k\n            label [] [\n                text (vp.V.Username + \": \")\n                Doc.InputV [] vp.V.Name \n            ] :> Doc\n        )\n        |> Doc.BindView (concatn \"MapLens\")\n\n    let myDoc4 =\n        myPeopleColl.Doc(fun k vp ->\n            Console.Log k\n            p [] [ text (vp.V.Name) ] :> Doc\n        )        \n\n\n    let changes () =\n        myPeopleColl.Add({ Username = \"mynameissam\"; Name = \"Sam\" })\n        myPeopleColl.Add({ Username = \"johnny87\"; Name = \"Johnny\" })\n        \n\n    let Main =\n        [\n            myPeopleList\n            myDoc\n            myDoc2\n            myDoc3\n            myDoc4\n            button [ Html.on.click (fun _ _ -> changes()) ] [ text \"add\" ] :> Doc\n        ]\n        |> concatn \"Main\"\n        |> RunCode.RunNode().AddBootstrap.RunDoc\n", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bb2fefdb-6b76-4135-a5a0-3b38c428f0a3"}, "snpName": "Web Component", "snpContent": "[< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\nlet ReflectConstruct () = X<_>\n\n[< Inline \"\"\"Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n             Object.setPrototypeOf($_c, $global.HTMLElement);\n             Object.setPrototypeOf($_o.prototype, $_c.prototype);\n             $_o.observedAttributes = $_o.prototype.get_observedAttributes();\n             $global.customElements.define($_nm, $_o)\"\"\" >]\nlet defineWebComponent _nm _o _c = X<_>\n\nlet [< Inline >] inline slot     ch = htmlElement   \"slot\" ch\nlet [< Inline >] inline slotName v  = htmlAttribute \"slot\" v\nlet [< Inline >] inline name     v  = htmlAttribute \"name\" v\n\nopen Template\nprintfn \"before AppDrawerT\"\ntype AppDrawerT () =\n    let         value = Var.Create 50.0\n    let mutable added = false\n    do printfn \"AddDrawerT initializer\"\n    [< Inline \"\"\"$global.FSSGlobal.Snippets2.AppDrawerT.New\"\"\" >] static member NewPointer = X<_>\n    static member Constructor() = \n        let this = ReflectConstruct()\n        AppDrawerT.NewPointer?call this\n        this\n    member this.observedAttributes = printfn \"observedAttributes\"; [| \"value\" |]\n    member this.attributeChangedCallback(_name, _oldValue, newValue) =\n        printfn \"newvalue %s\" newValue\n        value.Set (JS.ParseFloat newValue)\n    member this.Value            = value.Value\n    member this.Value with set v = if v <> value.Value then value.Set (if JS.IsNaN v then 0. else v)\n    member this.connectedCallback() = \n        printfn \"my-el connected %A %A\" added this?outerHTML\n        if not added then\n            let el : Dom.Element = this |> box |> unbox\n            let shadowRoot = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n            let elsh = JS.Document.CreateElement \"div\"\n            let minV     = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n            let maxV     = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n            do (if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> value.Set\n            let first    =    el.HasAttribute \"second\"   |> not\n            let vertical =    el.HasAttribute \"vertical\"\n            let size     = ref         0.0\n            let padding  = ref         0.0\n            let gap      = ref         0.0\n            let sizeCalc ver (el:Dom.Element) : float =\n                let p1, p2 = if ver then \"padding-top\", \"padding-bottom\" else \"padding-left\", \"padding-right\"\n                let pt   = JQuery.JQuery(el.ParentElement.ParentElement).Css p1         |> JS.ParseFloat\n                let pb   = JQuery.JQuery(el.ParentElement.ParentElement).Css p2         |> JS.ParseFloat\n                gap     := JQuery.JQuery(el.ParentElement.ParentElement).Css \"grid-gap\" |> JS.ParseFloat\n                padding := pt + pb\n                el.ParentElement.ParentElement.GetBoundingClientRect() \n                |> fun r -> \n                     match ver, first with\n                     | true , true  ->  r.Width  \n                     | true , false -> -r.Width \n                     | false, true  ->  r.Height\n                     | false, false -> -r.Height\n            let styleSplitter, styleSections, styleRest = \n                if vertical then (fun g -> sprintf \"grid-column:2; grid-row   :1 / 1 ; cursor: row-resize; width : %Apx ; margin-left:-%Apx;\" g g)\n                               , (fun (p1,p2) -> sprintf \"grid-template-columns: %Apx %Apx \" p1 p2)\n                               , \"grid-template-rows:100%\"\n                            else (fun g -> sprintf \"grid-row   :2; grid-column:1 / 1 ; cursor: row-resize; height: %Apx ; margin-top :-%Apx;\" g g)\n                               , (fun (p1,p2) -> sprintf \"grid-template-rows:    %Apx %Apx \" p1 p2)\n                               , \"grid-template-columns:100%\"\n            let splitter =\n                let dragging : bool               ref = ref false   \n                let startVer : bool               ref = ref false    \n                let startP   : float              ref = ref 0.0\n                let start    : float              ref = ref 0.0\n                let domElem  : Dom.Element option ref = ref None                 \n                let mouseCoord (ev: Dom.MouseEvent) = if !startVer then float ev.ClientX else float ev.ClientY\n                let drag (ev: Dom.Event) =\n                    ev :?> Dom.MouseEvent\n                    |> mouseCoord\n                    |> fun m   -> (m - !start) * 100.0 / !size + !startP\n                    |> fun v   -> value.Value <- min maxV (max minV v)\n                   \n                let rec finishDragging (_: Dom.Event) =\n                    if !dragging then\n                        dragging := false\n                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                let startDragging (_: Dom.Element) (ev: Dom.MouseEvent) =\n                    if not !dragging then\n                        Val.map2 (fun startPos dirV ->\n                            dragging := true\n                            startVer := dirV\n                            startP   := startPos\n                            start    := mouseCoord ev\n                            size     := !domElem |> Option.map (sizeCalc !startVer) |> Option.defaultValue 100.0\n                            JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                            JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                            ev.PreventDefault()\n                        ) value vertical\n                        |> Val.iter id\n                div [\n                    SomeAttr  <| on.mouseDown startDragging\n                    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                    style     <| styleSplitter !gap\n                    style        \"z-index: 10; background-color: #eef\"\n                ]\n            let partSizes sz gap pad spl = (sz - gap - pad) * spl / 100.0, (sz - gap - pad) * (100.0 - spl) / 100.0\n            let styleSizes spl = partSizes !size !gap !padding spl |> styleSections\n            div [ \n                style <| sprintf \"display: grid; grid-gap: 7px; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                style <| Val.map styleSizes value\n                slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                slot [ name \"splitter\" ; splitter                                               ]\n            ]\n            |> renderDoc |> Doc.Run elsh\n            shadowRoot.AppendChild elsh.FirstChild |> ignore\n            added <- true\n\nif IsClient then defineWebComponent \"app-drawer\" AppDrawerT.Constructor AppDrawerT.NewPointer\n\nlet [< Inline >] inline appDrawer ch = htmlElement \"app-drawer\" ch\nlet value = Var.Create \"75\"\n\ndiv [ style \"height: 500px\"\n      htmlText \"HELLO!\"\n      appDrawer [\n          htmlAttribute \"gap\"   \"30\"\n          htmlAttribute \"value\" value\n          style \"height: 200px; display: grid\"\n          div [ style \"background-color: green; grid-area: one\"                    ]\n          div [ style \"background-color: beige; grid-area: two\" ; slotName \"part2\" ]\n      ]\n      Doc.Input [] value |> someElt\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [{"SnippetId" :"0047d2f0-ec1d-43b1-b432-95462c318445"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a879093b-832f-466a-bf97-014313c7578c"}, "snpName": "Custom Elementxxxx", "snpContent": "[< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], $_cons)\"\"\" >]\nlet ReflectConstruct _cons = X<_>\n\n[< Direct \"\"\"\n(function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n})($_instance, $_Constructor)\n\"\"\" >]\nlet _classCallCheck(_instance, _Constructor) = ()\n\n[< Inline \"\"\"\n(function (self, call) {\n  if (!self) {\n    throw new TypeError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n})($_this, ($_cons.__proto__ || Object.getPrototypeOf($_cons)).call($_this) )\n\"\"\" >]\nlet _possibleConstructorReturn(_this, _cons) = X<_>\n\n[< Direct \"\"\"\n(function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n})($_base, $_super)\n\"\"\" >]\nlet _inherits(_base, _super) = X<_>\n\n[< Inline \"$global.HTMLElement\" >]\nlet HTMLElementClass = X<obj>\n\n[< Inline \"\"\"$global.customElements.define($_nm, $_o)\"\"\" >]\nlet defineWebComponent _nm _o = X<_>\n\nopen Template\nprintfn \"before AppDrawerT\"\ntype AppDrawerT () as this =\n    do printfn \"AddDrawerT initializer\"\n    do _classCallCheck(this, AppDrawerT.ClassPointer?New)\n    //let _this = _possibleConstructorReturn(this, AppDrawerT.ClassPointer()?New)\n    let mutable added = false\n    [< Inline \"\"\"$global.FSSGlobal.Snippets2.AppDrawerT\"\"\" >] static member ClassPointer = X<_>\n    static member Constructor() = ReflectConstruct AppDrawerT.ClassPointer?New\n        \n\n_inherits(AppDrawerT.ClassPointer, HTMLElementClass) \ndefineWebComponent \"app-drawer\" AppDrawerT.ClassPointer\n    \nhtmlElement \"app-drawer\" []\n|> RunCode.RunNode().AddBootstrap.RunHtml\n    ", "snpParentIdO": {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpName": "Layout", "snpContent": "[< JavaScript >]\nmodule Layout = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"251bfd3b-3ea6-4761-8288-a978099aa06e"}, "snpName": "Translate Layout(s)", "snpContent": "open Useful\nopen UsefulDotNet\nopen CompOptionsModule\nopen FsTranslator\n\nlet fsClient = new WSMessagingBroker.FStationMessaging(\"Translate Layout(s)\", WSMessagingBroker.FSharp)\n\nlet translateR snippet = \n    Wrap.wrap {\n        let!   code    = fsClient.RequestCode snippet\n        let!   js      = TranslatorCaller.getJSW false [] code\n        let    js2     = \"(\" + js.[js.IndexOf(\" function()\") .. js.LastIndexOf(\"});\") - 1] + \"Layout.setLayout(Layout.getLayout);})()\"\n        return js2;\n    } \n\nlet translate  snip =\n    translateR snip \n    |> Wrap.runSynchronouslyS false\n    |> printfn \"%s\"\n\nlet translateNSet target =\n    Wrap.wrap {\n        let  snippet = target |> String. splitByChar '/' |> Array.last\n                       |> String.append \"FSSGlobal/WebSharper Code/Layout/Layout: \"\n        printfn \"%s\" snippet\n        let! js      = translateR snippet\n        printfn \"translated\"\n        let! res     = fsClient.RunActionCall(\"actSetSnippetProp\", \"actSetSnippetProp\", [| target ; \"LayoutJS\" ; js |])\n        return res\n    } \n    |> Wrap.runSynchronouslyS false\n    |> printfn \"%s\"\n\n//translate \"Layout translate button\"\n//translateNSet \"FSSGlobal/WebSharper Code/Layout/Translate Layout(s)\"\n", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"368caae7-6a67-4063-9af3-978c25b81ac2"}, {"SnippetId" :"4413b3ee-f968-458d-8a5f-7a7c9281c38f"}, {"SnippetId" :"96f91fe1-3aa2-4aa0-b04f-b428fd2f0948"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}, "snpName": "Layout", "snpContent": "//#r @\"Compiled\\RemotingDll\\RemotingDll.dll\"\n#r \"FSharpStation.exe\"\nopen FSSGlobal.Useful\nopen FSSGlobal.HtmlNode\nopen FSSGlobal.Template\nopen FSSGlobal\n\nlet actLoadFile       = \"actLoadFile\"\nlet actSaveFile       = \"actSaveFile\"\nlet actAddSnippet     = \"actAddSnippet\"\nlet actDeleteSnippet  = \"actDeleteSnippet\"\nlet actIndentSnippet  = \"actIndentSnippet\"\nlet actOutdentSnippet = \"actOutdentSnippet\"\nlet actGetFsCode      = \"actGetFsCode\"\nlet actEvalFsCode     = \"actEvalFsCode\"\nlet actEvalCode       = \"actEvalCode\"\nlet actRunFableFs     = \"actRunFableFs\"\nlet actRunFable       = \"actRunFable\"\nlet actRunWSNewTab    = \"actRunWSNewTab\"\nlet actRunWSHere      = \"actRunWSHere\"\nlet actRunWSIn        = \"actRunWSIn\"\nlet actParseCode      = \"actParseCode\"\nlet actCompileWS      = \"actCompileWS\"\nlet actFindDefinition = \"actFindDefinition\"\nlet titleX            = \"title\"            \nlet snippets          = \"snippets\"         \nlet code              = \"code\"           \nlet buttons           = \"buttons\"          \nlet menu              = \"menu\"             \nlet Output            = \"Output\"           \nlet Parser            = \"Parser\"           \nlet JavaScript        = \"JavaScript\"       \nlet FScode            = \"F# code\"          \nlet WSResult          = \"WS Result\"        \nlet Properties        = \"Properties\"  \n\nlet dummyAction = Action.New \"dummy\"\n\nlet guiParts =\n    Map[\n       actLoadFile      , GuiAction dummyAction \n       actSaveFile      , GuiAction dummyAction \n       actAddSnippet    , GuiAction dummyAction \n       actDeleteSnippet , GuiAction dummyAction \n       actIndentSnippet , GuiAction dummyAction \n       actOutdentSnippet, GuiAction dummyAction \n       actGetFsCode     , GuiAction dummyAction \n       actEvalCode      , GuiAction dummyAction \n       actRunWSNewTab   , GuiAction dummyAction \n       actRunWSHere     , GuiAction dummyAction \n       actRunWSIn       , GuiAction dummyAction \n       actParseCode     , GuiAction dummyAction \n       actCompileWS     , GuiAction dummyAction \n       actFindDefinition, GuiAction dummyAction \n       titleX           , GuiNode <| htmlText \"title\"       \n       snippets         , GuiNode <| htmlText \"snippets\"    \n       code             , GuiNode <| htmlText \"editor\"      \n       buttons          , GuiNode <| htmlText \"buttons\"     \n       menu             , GuiNode <| htmlText \"menu\"        \n       Output           , GuiNode <| htmlText \"Output\"      \n       Parser           , GuiNode <| htmlText \"Parser\"      \n       JavaScript       , GuiNode <| htmlText \"JavaScript\"  \n       FScode           , GuiNode <| htmlText \"F# code\"     \n       WSResult         , GuiNode <| htmlText \"WS Result\"   \n       Properties       , GuiNode <| htmlText \"Properties\"  \n    ]\n\nlet setLayout (f: Layout -> FsStationShared.CodeSnippet -> (string * GuiPartSourceId * GuiPart) [] ) =\n    JS.Window?setFSharpStationLayout f |> ignore\n \nlet doGuiCall (name: string) (action: string) (parms: string[]) =\n    JS.Window?doFSharpStationGuiCall (name, action, parms) |> ignore\n\nlet mutable layout :(string * GuiPartSourceId * GuiPart) [] = [||]\n\nlet extraButtonsLayout buttons =\n    Layout.AddGuids\n          [ \"extrabuttons\"      , div [ yield  style \"text-align: center ; overflow: auto ; \" \n                                        yield! buttons\n                                        yield  css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n            \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n            \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n          ]\n\nlet evalFsCodeButton (lyt: Layout) (txt, parms) = lyt.GetCallButton txt actEvalFsCode parms\nlet evalFsCodeButtons lyt           txts        = txts |> Seq.map (evalFsCodeButton lyt)\n\nlet runFableFsButton (lyt: Layout) (txt, parms) = lyt.GetCallButton txt actRunFableFs parms\n\nlet passNoParm  txt  = txt, [||]\nlet passNoParms txts = txts |> Seq.map passNoParm\n\nlet evalFsCodeButtonNoParm  lyt =                           passNoParm  >> evalFsCodeButton  lyt\nlet evalFsCodeButtonNoParms lyt = (Seq.filter ((<>) \"\")) >> passNoParms >> evalFsCodeButtons lyt\n\nlet sendPwd (code: unit -> string) (lyt:Layout) el ev = \n    lyt.GetGuiCallAction \"sendPwd\" \"actEvalFsCode\" [| \"Code\" ; code() |]\n    |> function\n       | Result.Success(act, _) -> act.onClick |> Option.map (fun f -> f act el ev) |> Option.defaultWith (printfn \"OnClick is %A\")\n       | Result.Failure ms      -> printfn \"%A\" ms\n    \nlet buttonPwd code lyt     = Button.New(\"Send\").OnClick(sendPwd code lyt).Render\n\nlet getButtonsLayout f (snp:FsStationShared.CodeSnippet) =\n    snp.properties\n    |> Dict.tryGetValue \"LayoutButtons\"\n    |> Option.defaultValue \"\"\n    |> String.splitByChar '\\n'\n    |> Seq.map    String.trim\n    |> Seq.filter ((<>) \"\")\n    |> f\n    |> extraButtonsLayout\n", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1444403d-05ba-4f4c-bc27-f1134d58a482"}, "snpName": "Layout: Adb Run OpenGarage3", "snpContent": "//open Template\n\nlet password       = Input.New(\"\").Placeholder(\"Enter Passhrase\").Type(\"Password\")\nlet sendPwdCode () = sprintf \"FSSGlobal.Garage.OldHtcPassword <- Some %A\" password.Var.Value\n\nlet mutable dragStartCoords = (0, 0)\n\nlet image (file: string) = \n    img [ src file\n          SomeAttr <| on.click     (fun em ev -> \n              doGuiCall \"clickScreen\" actEvalFsCode \n                  [| \"Code\" \n                     (ev?offsetX * em?naturalWidth / em?width, ev?offsetY * em?naturalHeight / em?height) |> sprintf \"click %A\" \n                  |]) \n          SomeAttr <| on.dragOver (fun _  ev -> ev.PreventDefault() )\n          SomeAttr <| on.drag     (fun _  ev -> ev.PreventDefault() )\n          SomeAttr <| on.dragStart(fun _  ev -> dragStartCoords <- (ev?offsetX, ev?offsetY))\n          SomeAttr <| on.drop     (fun em ev -> \n              ev.PreventDefault() \n              doGuiCall \"clickScreen\" actEvalFsCode \n                  [| \"Code\" \n                     ((fst dragStartCoords * em?naturalWidth / em?width, snd dragStartCoords * em?naturalHeight / em?height) \n                     ,(ev?offsetX          * em?naturalWidth / em?width, ev?offsetY          * em?naturalHeight / em?height))\n                     |> sprintf \"dragDrop %A\" \n                  |])\n          Id \"PhoneScreen\"\n          style \"width: 95%\"] \n                                 \nlet [< Inline \"Date.now()\" >] now() = 1\n\nlet getLayout lyt snp =\n    snp\n    |> getButtonsLayout (\n        Seq.map (\n            function\n            | \"Image\"      -> image (sprintf \"/screen.png?time=%d\" <| now())\n            | \"Refresh\"    -> runFableFsButton       lyt <| passNoParm \"Refresh\"\n            | \"Passphrase\" -> password.Prefix(buttonPwd sendPwdCode lyt).Render\n            | b            -> evalFsCodeButtonNoParm lyt b\n        )\n    )\n\n\n //Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1daccd12-b24a-45e0-9609-1f500500b69d"}, "snpName": "Layout: AbeRaspi", "snpContent": "let password       = Input.New(\"\").Placeholder(\"Enter Password\").Type(\"password\")\nlet sendPwdCode () = sprintf \"FSSGlobal.Garage.AbeRaspiPassword <- Some %A\" password.Var.Value\n\nlet getLayout lyt snp =\n    snp\n    |> getButtonsLayout (evalFsCodeButtonNoParms lyt \n                         >> Seq.append [ password.Prefix(buttonPwd sendPwdCode lyt).Render ])\n    ", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"161a6d53-ec0a-4b46-8445-ab14ec5e5ebe"}, "snpName": "Layout: Ping computers", "snpContent": "let getLayout lyt snp =\n    snp\n    |> getButtonsLayout (\n        Seq.collect (fun c ->\n            match c with\n            | \"computers\" -> Garage.computers |> Seq.map fst |> Seq.distinct |> Seq.sort\n            | _           -> Seq.singleton c\n        )\n        >> evalFsCodeButtonNoParms lyt\n    )\n       ", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"7bb04b3c-b71e-4827-bd9e-b18fbabc1495"}, {"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"03b4ea7d-508a-4553-9c5a-f2b18280a27a"}, "snpName": "Layout: Translate Layout(s)", "snpContent": "let getLayout lyt snp = snp |> getButtonsLayout (evalFsCodeButtonNoParms lyt)\n", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6972a03e-2093-495e-8c0d-bc0aa3aa9ab7"}, "snpName": "Layout: Thermostats", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen Template\nopen WSMessagingBroker\nopen Garage\nopen Useful\nopen FsStationShared\n\n[< Inline \"iwasherebefore = $v\">]\nlet setPrexistence v = ignore v\n[< Inline \"if (iwasherebefore) {} \">]\nlet checkPrexistence() = ()\n\ncheckPrexistence()\nlet messaging   = new WSMessagingClient(\"ThermostatsSite\")\nsetPrexistence messaging\n\nlet time2Str day hour minute =\n    match day with\n    | 0 -> \"Mon\"\n    | 1 -> \"Tue\"\n    | 2 -> \"Wed\"\n    | 3 -> \"Thu\"\n    | 4 -> \"Fri\"\n    | 5 -> \"Sat\"\n    | 6 -> \"Sun\"\n    | _ -> \"---\"\n    |> sprintf \"%s, %02d:%02d\" <| hour <| minute\n\n[<NoComparison ; NoEquality>]\ntype ThermostatData = {\n    name : string \n    data : Var<Map<string, Var<string>>>\n} \n\nlet getData key (therm: ThermostatData) =\n    Val.valFlow {\n        let! map   = therm.data\n        let  dataO = map |> Map.tryFind key\n        match dataO with \n        | None       -> return \"\" \n        | Some dataV -> \n        let!   data = dataV\n        return data\n    }\n    \nlet setData k v therm = \n    match therm.data.Value |> Map.tryFind k with\n    | None     -> therm.data.Value <- therm.data.Value |> Map.add k (Var.Create v)\n    | Some dat -> dat      .Value <- v\n    \nlet getMode        therm = Val.valFlow { return! getData \"tstat/tmode\" therm }\nlet getSettingParm therm = \n    Val.valFlow { \n        let! mode = getMode therm\n        return\n            match mode with\n            | \"1\" -> Some \"tstat/t_heat\"\n            | \"2\" -> Some \"tstat/t_cool\"\n            | _   -> None\n    }\n\nlet missingIRef = (Var.Create \"\").Lens (fun _ -> \"\") (fun _ _ -> \"\")\nlet getIRef key (therm: ThermostatData) = \n    therm.data.Value \n    |> Map.tryFind key\n    |> Option.map (fun v -> v :> Var<_>)\n    |> Option.defaultValue missingIRef\n    \nlet getSettingVar therm =\n    getSettingParm therm\n    |> Val.bindIRef (fun parmO ->\n        parmO\n        |> Option.map (fun key  -> getIRef key therm)\n        |> Option.map (fun iref -> (iref :?> Var<_>).Lens (float >> sprintf \"%A\") (fun _old newV -> newV))\n        |> Option.defaultValue missingIRef\n    )\n\nlet postTstat parm value therm =\n    async {\n        JS.Window?doFSharpStationGuiCall(\"setTstatParameter\", actEvalFsCode, [| \"Code\" ; sprintf \"postTstat %A %A %A \"  parm value therm.name |])\n    } |> Async.Start\n    JS.Alert(sprintf \"setting %s = %A\" parm value)\n\nlet setSetpoint therm =\n    async {\n        let!  parmO = therm |> getSettingParm |> Val.getAsync\n        match parmO with\n        | None -> ()\n        | Some parm ->\n        let! value  = therm |> getData parm   |> Val.getAsync\n        let parm2 = parm.[\"tstat/\".Length..]\n        therm |> postTstat parm2 value\n    }\n\nlet setHold v therm =\n    async {\n        let parm  = \"hold\"\n        let value = if v then \"1\" else \"0\"\n        therm |> setData parm (if v then \"1\" else \"0\")\n        therm |> postTstat parm value\n    }\n\nlet thermostatDisplay (therm:ThermostatData) =\n    let temp        = therm |> getData \"tstat/temp\"        |> Val.map (float >> sprintf \"%A°F\")\n    let mode        = therm |> getData \"tstat/tmode\"       |> Val.map (function | \"1\" -> \"Heat\"     | \"2\" -> \"Cool\"      | _ -> \"Off\")\n    let state       = therm |> getData \"tstat/tstate\"      |> Val.map (function | \"1\" -> \"Heating\"  | \"2\" -> \"Cooling\"   | _ -> \"\"   )\n    let fanState    = therm |> getData \"tstat/fstate\"      |> Val.map (function | \"1\" -> \"Fan:On\"   |                      _ -> \"\"   )\n    let hold        = therm |> getData \"tstat/hold\"\n    let day         = therm |> getData \"tstat/time/day\"    |> Val.map int\n    let hour        = therm |> getData \"tstat/time/hour\"   |> Val.map int\n    let minute      = therm |> getData \"tstat/time/minute\" |> Val.map int\n    let time        = Val.map3 time2Str day hour minute\n    let set         = getSettingVar therm\n    let title       = div [ h2  [ htmlText therm.name ]\n                            htmlText time\n                          ]\n    let information = div [ h3 [ htmlText temp           ]\n                            h4 [ div [ htmlText state    ]\n                                 div [ htmlText fanState ]\n                               ]\n                          ]\n    let settings    = div [ Template.Input.New(set).Prefix(\n                                Template.Button.New(\"Set:\").OnClick(fun _ _ -> therm |> setSetpoint |> Async.Start).Render\n                            ).Render.Style(\"\")\n                            label [\n                                ``class`` \"checkbox-inline\"\n                                htmlElement \"input\" \n                                      [ ``type`` \"checkbox\"\n                                        on.click       (fun e _ -> therm |>            setHold e?``checked`` |> Async.Start) |> SomeAttr\n                                        on.afterRender (fun e   -> hold  |> Val.sink (fun v -> e?``checked`` <- v = \"1\")   ) |> SomeAttr\n                                        style \"bottom: 0px\"\n                                      ]\n                                htmlText \"Hold\" \n                            ]\n                          ]\n    let layout      = Layout.AddGuids\n                          [\n                             \"title\"        , GuiNode title\n                             \"information\"  , GuiNode information\n                             \"settings\"     , GuiNode settings\n                             \"data\"         , fixPcVerSplitter true  50.0 \"information\"   \"settings\"\n                             \"main\"         , fixPcHorSplitter true  25.0 \"title\"         \"data\"\n                          ]\n                      |> Layout.New\n    layout.Render\n        .Style(\"\n            grid-gap: 0px  ; \n            margin  : 10px ; \n         \")\n        .AddClass(Val.map (sprintf \"shadow panel thermostat Mode%s\") mode)\n\nlet newThermostat n   = { name = n ; data = Var.Create Map.empty }\n    \nlet readProperties (snp:CodeSnippet) therm =\n    snp.properties.Keys\n    |> Seq.iter (fun k -> \n        match k with\n        | REGEX \"(.+)\\((.+)\\)\" \"\" v when v.[1] = therm.name -> therm |> setData v.[2] snp.properties.[k]\n        | _ -> () )\n\n\nlet         message     = Var.Create \"\"\nlet         temperature = Var.Create 0.0\nlet         tempText    = Val.map (sprintf \"%A\") temperature\nlet         deactivated = Var.Create \"\"\nlet mutable currentSnpO = None\n\nlet Thermostats =\n    [| \n        newThermostat \"Arriba\"\n        newThermostat \"Abajo\"\n    |]\n    \nlet getThermostat nm = Thermostats |> Array.tryFind (fun t -> t.name = nm)\n\nlet ThermostatHtmls =\n    Thermostats\n    |> Seq.map thermostatDisplay\n    |> Seq.append [ \n            htmlText message\n            css \"\"\"\n                  .thermostat {\n                      text-align      : center     ; \n                  }\n                  .thermostat h2, .thermostat h3, .thermostat h4  {\n                      margin-top      : 3px     ; \n                      margin-bottom   : 0px     ; \n                  }\n                  .thermostat.ModeCool {\n                      background-color: blue; \n                      color: white;\n                  }\n                  .thermostat.ModeCool button {\n                      background-color: navy; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat {\n                      background-color: firebrick; \n                      color: white;\n                  }\n                  .thermostat.ModeHeat button {\n                      background-color: darkred; \n                      color: white;\n                  }\n            \"\"\"\n       ]\n    |> div    \n\nlet weather (snp : CodeSnippet) =\n    let cityId        = snp.properties |> Dict.tryGetValue \"CityId\"        |> Option.defaultValue \"4711801\"\n    let openWeatherId = snp.properties |> Dict.tryGetValue \"OpenWeatherId\" |> Option.defaultValue \"1b76ef58915a2c784ce5dcb7899b81f2\"    \n    div [\n      div [ style \"height: 1em\"]\n      div [ Id \"openweathermap-widget\" ]\n      script [ src \"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/d3.min.js\" ]\n      script [ htmlText (sprintf \"window.myWidgetParam = [{id: 15,cityid: '%s',appid: '%s',units: 'imperial',containerid: 'openweathermap-widget',  }];\" cityId openWeatherId) ]\n      script [ src \"//openweathermap.org/themes/openweathermap/assets/vendor/owm/js/weather-widget-generator.js\" ]\n    ]\n \nlet readThermostatsProperties snp = \n    currentSnpO <- Some snp\n    Thermostats |> Seq.iter (readProperties snp)\n\nlet getLayout lyt snp =\n    readThermostatsProperties snp\n    snp\n    |> getButtonsLayout (\n        Seq.map (\n            function\n            | \"Thermostat\" -> ThermostatHtmls\n            | \"Weather\"    -> weather snp\n            | \"Refresh\"    -> runFableFsButton       lyt <| passNoParm \"Refresh\"\n            | b            -> evalFsCodeButtonNoParm lyt b\n        )\n    )\n\nlet processData (THMData(name, data: (string * string) [])) = \n    printfn \"Thermostats: %A %A\" name data\n    Wrap.wrap {\n        data\n        |> Array.iter (fun (cmd, dat) ->\n            let key = sprintf \"%s(%s)\" name cmd\n            getThermostat name |> Option.iter (setData cmd  dat)\n            currentSnpO        |> Option.iter (fun snp   -> snp.properties |> Dict.add key  dat)\n        )\n        return \"got it!\"\n    }    \n\nprintfn \"Thermostats registering\"\nmessaging.ProcessIncoming processData\n\n//Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ", "snpParentIdO": {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, "snpPredIds": [{"SnippetId" :"77ddaeb8-a657-4246-8f17-65e10712930f"}, {"SnippetId" :"de383f39-4beb-4e97-ba06-30b8b454ffb2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dd763e28-a1e1-4e69-bc18-6241efdf251d"}, "snpName": "Tests", "snpContent": "[< JavaScript >]\nmodule Tests =\n", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3dd43e2f-5818-47c0-bf53-0c49d8d3d344"}, "snpName": "Equal DomRects are not comparable", "snpContent": "\n\nlet r1 = JS.Window.Document.Body.GetBoundingClientRect()\nlet r2 = JS.Window.Document.Body.GetBoundingClientRect()\n\nprintfn \"%A = %A  : %b\" (r1.ToString()) r2 (r1 = r2)", "snpParentIdO": {"SnippetId" :"dd763e28-a1e1-4e69-bc18-6241efdf251d"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e29cd12a-a20d-4d1c-8c0e-316ea26ed87e"}, "snpName": "Two CodeMirrors", "snpContent": "open Template\n\nprintfn \"XSL Tester\"\n\nlet codeA = Template.CodeMirror.New(\"A\").OnRender(fun _ -> printfn \"OnRender A\").Style(\"height: 100%\").Render\nlet codeB = Template.CodeMirror.New(\"B\").OnRender(fun _ -> printfn \"OnRender B\").Style(\"height: 100%\").Render\n\ndiv [\n    style \"height: 100vh; width: 100% \"\n    codeA\n    codeB\n] \n|> RunCode.RunNode().RunHtml\n", "snpParentIdO": {"SnippetId" :"dd763e28-a1e1-4e69-bc18-6241efdf251d"}, "snpPredIds": [{"SnippetId" :"3038cd62-093c-4385-aa9b-799297bd379c"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"69b57aa2-2911-4e5e-93a4-87b38e3c8420"}, "snpName": "inline counter", "snpContent": "\n\nlet counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()  // <== should only be called once per invocation\n      }\n      \n    member        this.MethodN (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.MethodN ()       = { this with a = this.a * 10                 }\n    member inline this.MethodI ()       = { this with a = this.a * 10                 }\n\n[\n    Type.New(5).MethodN(false).MethodN(true).MethodN() |> sprintf \"not inline: %A\"    \n    Type.New(5).MethodN(false).MethodN(true).MethodN() |> sprintf \"not inline: %A\"    \n    Type.New(5).MethodI(false).MethodI(true).MethodI() |> sprintf \"inline: %A\"\n    Type.New(5).MethodI(false).MethodI(true).MethodI() |> sprintf \"inline: %A\"\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().RunHtml\n", "snpParentIdO": {"SnippetId" :"dd763e28-a1e1-4e69-bc18-6241efdf251d"}, "snpPredIds": [{"SnippetId" :"3709b431-1507-48ed-9487-dd49ce7be748"}, {"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpName": "WebSocket Demo", "snpContent": "module WSServer = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0dabc34f-673d-4f79-ae00-3960ca196392"}, "snpName": "Client (and Rpc)", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\Owin.WebSocket.dll\"\n#r @\"..\\packages\\WebSharper.Owin.WebSocket\\lib\\net461\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper.Owin.WebSocket\nopen WebSharper.Owin.WebSocket.Client\n\ntype [<JavaScript; NamedUnionCases>]\n    C2SMessage =\n    | Request1 of str: string[]\n    | Request2 of int: int   []\n\ntype [<JavaScript; NamedUnionCases \"type\">]\n    S2CMessage =\n    | [<Name \"int\"   >] Response2 of value: int\n    | [<Name \"string\">] Response1 of value: string\n\n[< JavaScript >]\nlet WebSocketClient (epWebSocket : Endpoint<S2CMessage, C2SMessage>) =\n    let output = Var.Create \"\"\n    let writen fmt = Printf.ksprintf (fun s -> output.Value <- output.Value + \"\\n\" + s) fmt\n    async {\n        do  writen \"Checking regression #4...\"\n            JQuery.AjaxSettings(Url     = \"/ws.txt\"\n                              , Method  = JQuery.RequestType.GET\n                              , Success = (fun x _ _ -> writen \"%s\" (x :?> _))\n                              , Error   = (fun _ _ e -> writen \"KO: %s.\" e)\n            )\n            |> JQuery.JQuery.Ajax\n            |> ignore\n        let! server =\n            ConnectStateful epWebSocket <| fun server -> async {\n                return 0, fun state msg -> async {\n                    match msg with\n                    | Message data ->\n                        match data with\n                        | Response1 x -> writen \"Response1 %s (state: %i)\" x state\n                        | Response2 x -> writen \"Response2 %i (state: %i)\" x state\n                        return (state + 1)\n                    | Close ->\n                        writen \"WebSocket connection closed.\"\n                        return state\n                    | Open ->\n                        writen \"WebSocket connection open.\"\n                        return state\n                    | Error ->\n                        writen \"WebSocket connection error!\"\n                        return state\n                }\n            }\n        \n        let lotsOfHellos = \"HELLO\" |> Array.create 1000\n        let lotsOf123s = 123 |> Array.create 1000\n        while true do\n            do! Async.Sleep 1000\n            server.Post (Request1 [| \"HELLO\" |])\n            do! Async.Sleep 1000\n            server.Post (Request2 lotsOf123s)\n    }\n    |> Async.Start\n    output\n\nlet invert (txt: string) : string = txt |> Seq.rev |> Seq.map string |> String.concat \"\"\n\n[< Rpc >]\nlet invertA txt = async { return invert txt }\n\n[< JavaScript >]\nlet ClientForm epWebSocket =\n    let inp    = Template.Input.New(\"Type something...\")\n    let output = WebSocketClient epWebSocket\n    div [ \n      ``class`` \"container\"    \n      Template.Bootstrap().Render\n      Template.Panel.New\n        .Title(\"Client Server Demo\")\n        .Header([])\n        .Content(\n          [ h3 [\n              inp.Render\n              htmlText inp.Var\n              htmlElement \"h2\" [ htmlText inp.Var ]\n              h1 [ htmlText <| Val.mapAsync invertA inp.Var ]\n            ]\n            htmlText output\n          ]).Render\n    ] |> renderDoc\n", "snpParentIdO": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpPredIds": [{"SnippetId" :"0a11766b-f227-4b38-88a3-919d964387bf"}, {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"40614ad6-3f81-468b-a4ff-034124b82ae1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"92837099-e4e4-4c7f-ac52-6c922824304f"}, "snpName": "Site", "snpContent": "//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\HtmlAgilityPack.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.Common.dll\"\n//#r @\"..\\packages\\WebSharper.UI.Next\\lib\\net40\\WebSharper.UI.Next.Templating.Runtime.dll\"\n\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Server\nopen WebSharper.UI.Templating\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\ntype MainTemplate = Template< @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin/Compiled/ClientServerDemo/website/test.html\">\n\nlet content epWebSocket (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    MainTemplate()\n        .Title(\"Main Page\")\n        .Body( [ Html.client <@  ClientForm epWebSocket @> ])\n        .Doc()\n    |> Content.Page\n\nlet site epWebSocket = Application.MultiPage (content epWebSocket)\n\n", "snpParentIdO": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpPredIds": [{"SnippetId" :"0dabc34f-673d-4f79-ae00-3960ca196392"}, {"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c93a7f5a-cf6f-4789-9998-47ee7b99bbb6"}, "snpName": "WebSocketServer", "snpContent": "module Server =\n    open WebSharper\n    open WebSharper.Owin.WebSocket.Server\n\n    let Start epWebSocket : StatefulAgent<S2CMessage, C2SMessage, int> =\n        /// print to debug output and stdout\n        let dprintfn x =\n            Printf.ksprintf (fun s ->\n                System.Diagnostics.Debug.WriteLine s\n                stdout.WriteLine s\n            ) x\n\n        fun client -> async {\n            let clientIp = client.Connection.Context.Request.RemoteIpAddress\n            return 0, fun state msg -> async {\n                eprintfn \"Received message #%i from %s\" state clientIp\n                match msg with\n                | Message data -> \n                    match data with\n                    | Request1 x -> do! client.PostAsync (Response1 x.[0])\n                    | Request2 x -> do! client.PostAsync (Response2 x.[0])\n                    return state + 1\n                | Error exn -> \n                    dprintfn \"Error in WebSocket server connected to %s: %s\" clientIp exn.Message\n                    do! client.PostAsync (Response1 (\"Error: \" + exn.Message))\n                    return state\n                | Close ->\n                    eprintfn \"Closed connection to %s\" clientIp\n                    return state\n            }\n        }\n\n", "snpParentIdO": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpPredIds": [{"SnippetId" :"0dabc34f-673d-4f79-ae00-3960ca196392"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7e36bd56-d4fa-4509-bece-b4444df38c5c"}, "snpName": "ClientServerDemo", "snpContent": "#r @\"..\\packages\\Owin.Compression\\lib\\net452\\Owin.Compression.dll\"\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\nopen WebSharper.Owin\nopen WebSharper.Owin.WebSocket\n\n[< EntryPoint >]\nlet Main args =\n    let rootDirectory, url =\n        match args with\n        | [| rootDirectory; url |] -> rootDirectory, url\n        | [| url                |] -> \"website\"    , url\n        | [|                    |] -> \"website\"    , \"http://localhost:9033/\"\n        | _ -> eprintfn \"Usage: WebServer3 ROOT_DIRECTORY URL\"; exit 1\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    //printfn \"Starting, hit <Enter>...\" ; stdin.ReadLine() |> ignore\n    use server = \n        WebApp.Start(url, fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = rootDirectory\n                                               , Sitelet             = Some (site epWebSocket)\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseWebSocket(  epWebSocket, Server.Start epWebSocket)\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(rootDirectory)))\n                .UseCompressionModule()\n            |> ignore\n            let listener = appB.Properties.[\"Microsoft.Owin.Host.HttpListener.OwinHttpListener\"] |> unbox<Microsoft.Owin.Host.HttpListener.OwinHttpListener>\n            listener.SetRequestProcessingLimits(1000, 1000)\n            let maxA = ref 0\n            let maxB = ref 0\n            listener.GetRequestProcessingLimits(maxA, maxB)\n            printfn \"Accepts: %d Requests:%d\" !maxA !maxB\n        )\n    stdout.WriteLine(\"Serving {0}\", url)\n    stdin.ReadLine() |> ignore\n    0\n    ", "snpParentIdO": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpPredIds": [{"SnippetId" :"92837099-e4e4-4c7f-ac52-6c922824304f"}, {"SnippetId" :"c93a7f5a-cf6f-4789-9998-47ee7b99bbb6"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c8c93861-321c-4d73-beb0-2fef0052bc7b"}, "snpName": "compile & run ClientServerDemo", "snpContent": "open System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options      = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/WebSocket Demo/ClientServerDemo\"\n                        + siteOptions + (opGenInternal /= \"showoptions\")\n    let  exeFile      = options?Output\n    let  site         = Path.GetFullPath(options?Website)\n    let! res          = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn        \"Starting %s\"     exeFile\n    let  url          = @\"http://localhost:9005/\"\n    let  parms        = sprintf \"%A %A\" site url \n    do   startProcess   exeFile parms |> ignore\n    do   startProcess   url     \"\"    |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, "snpName": "WebSocket demo Not Working", "snpContent": "", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e82e9f07-e611-4496-8247-03f03be16906"}, "snpName": "", "snpContent": "\nmodule WebSocket =\n    open Microsoft.Practices.ServiceLocation\n    open global.Owin\n    open Owin.WebSocket\n    open Owin.WebSocket.Extensions\n\n    module private Async =\n        let AwaitUnitTask (tsk : System.Threading.Tasks.Task) =\n            tsk.ContinueWith(ignore) |> Async.AwaitTask\n\n    [<JavaScript>]\n    type Endpoint<'T> =\n        private {\n            URI : string\n        }\n\n    type Endpoint =\n        static member FromUri (uri : string) =\n            { URI = uri }\n\n    module MessageCoder =\n        module J = WebSharper.Core.Json\n\n        let ToJString (jP: J.Provider) (msg: 'T) =\n            let enc = jP.GetEncoder<'T>()\n            enc.Encode msg\n            |> jP.Pack\n            |> J.Stringify\n\n        let FromJString (jP: J.Provider) str : 'T =\n            let dec = jP.GetDecoder<'T>()\n            J.Parse str\n            |> dec.Decode\n\n    type private InternalMessage<'T> =\n        | Message of WebSocketConnection * 'T\n        | Error of WebSocketConnection * exn\n        | Close of WebSocketConnection\n        | Open of WebSocketConnection\n\n    type Action<'T> =\n        | Message of 'T\n        | Close\n    \n    [<ReferenceEquality>]\n    type WebSocketClient<'T> =\n        {\n            Conn           : WebSocketConnection\n            ReplyChan      : AsyncReplyChannel<Action<'T>>\n        }\n\n    let private mkWSClient conn rc = { Conn = conn; ReplyChan = rc }\n\n    [<JavaScript>]\n    type Message<'T> =\n        | Message of 'T\n        | Error of exn\n        | Open of MailboxProcessor<Action<'T>>\n        | Close\n\n    [<JavaScript>]\n    module Client =\n        open WebSharper.JavaScript\n\n        let private processResponse (sock : WebSocket) msg =\n            async {\n//                while sock.ReadyState <> WebSocketReadyState.Open do\n//                    do! Async.Sleep 10\n                let! msg = msg\n                match msg with\n                | Action.Message (value : 'T) ->\n                    value \n                    |> Json.Stringify\n                    |> sock.Send\n                | Action.Close -> sock.Close ()\n            }\n\n        type private State =\n            | Open\n            | Closed\n\n        type private ServerStatus<'T> =\n            {\n                State : State\n                Queue : Action<'T> list\n            }\n\n        type private ServerMessage<'T> =\n            | Open\n            | Close\n            | Message of Action<'T>\n\n        let ConnectTo (endpoint : Endpoint<'T>) \n            (agent : MailboxProcessor<Message<'T> * AsyncReplyChannel<Action<'T>>>) =\n\n            let socket = new WebSocket(endpoint.URI)\n\n            let proc (msg : Message<'T>) =\n                agent.PostAndAsyncReply (fun chan -> msg, chan)\n                |> processResponse socket\n                |> Async.Start\n\n            let internalServer =\n                MailboxProcessor.Start <| fun inbox ->\n                    let rec loop (st : ServerStatus<'T>) : Async<unit> =\n                        async {\n                            let! msg = inbox.Receive ()\n                            match msg with\n                            | Open ->\n                                for a in st.Queue do\n                                    do! processResponse socket <| async.Return a\n                                return! loop { State = State.Open; Queue = [] }\n                            | Close ->\n                                return! loop { st with State = State.Closed }\n                            | Message msg ->\n                                match st.State with\n                                | State.Open -> \n                                    do! processResponse socket (async.Return msg)\n                                    return! loop st\n                                | State.Closed ->\n                                    return! loop { st with Queue = msg :: st.Queue }\n                        }\n                    loop { State = State.Closed; Queue = [] }\n\n            let server = MailboxProcessor.Start <| fun inbox ->\n                let rec loop () : Async<unit> =\n                    async {\n                        let! msg = inbox.Receive ()\n                        internalServer.Post <| ServerMessage.Message msg\n                        return! loop ()\n                    }\n                loop ()\n\n            socket.Onopen <- fun () -> \n                internalServer.Post Open\n                proc <| Message.Open server\n            socket.Onclose <- fun () -> \n                internalServer.Post Close\n                proc <| Message.Close\n            socket.Onmessage <- fun msg -> \n                As<string> msg.Data |> Json.Parse |> Json.Activate |> Message.Message |> proc\n            socket.Onerror <- fun () -> System.Exception \"error\" |> Message.Error |> proc\n\n            server\n\n    type private WebSocketProcessor<'T>\n        (agent : MailboxProcessor<WebSocketClient<'T> option * Message<'T>>,\n         jP: Core.Json.Provider) =\n\n        let processResponse (sock : WebSocketConnection) msg =\n            async {\n                let! msg = msg\n                match msg with\n                | Action.Message value ->\n                    let msg = MessageCoder.ToJString jP value\n                    let bytes = System.Text.Encoding.UTF8.GetBytes(msg)\n                    do! sock.SendText(bytes, true) |> Async.AwaitUnitTask\n                | Action.Close -> \n                    do! sock.Close (System.Net.WebSockets.WebSocketCloseStatus.NormalClosure,\n                                        \"Client requested.\") |> Async.AwaitUnitTask\n            }\n\n        let newClientProcessor (sock : WebSocketConnection) = \n            MailboxProcessor.Start <| fun inbox ->\n                let rec loop () = async {\n                    do! processResponse sock <| inbox.Receive()\n                    return! loop ()\n                }\n                loop ()\n        \n        let mailbox = \n            MailboxProcessor.Start <| fun inbox ->\n                async {\n                    while true do\n                        let! (msg, replyChan) = inbox.Receive()\n                        let conn, imsg =\n                            match msg with\n                            | InternalMessage.Open socket -> socket, Message.Open <| newClientProcessor socket\n                            | InternalMessage.Close soscket -> soscket, Message.Close\n                            | InternalMessage.Message (socket, msg) -> socket, Message.Message msg\n                            | InternalMessage.Error (socket, ex) -> socket, Message.Error ex\n                        agent.Post <| (Some <| mkWSClient conn replyChan, imsg) \n                }   \n                \n        member this.Mailbox = mailbox\n        member this.ProcessResponse socket msg = processResponse socket msg\n        member this.JsonProvider = jP\n\n    type private ProcessWebSocketonnection<'T>\n        (processor : WebSocketProcessor<'T>) =\n\n        inherit WebSocketConnection()\n\n        let proc socket msg =\n            processor.Mailbox.PostAndAsyncReply (fun chan -> msg, chan)\n            |> processor.ProcessResponse socket\n            |> Async.Start\n\n        override x.OnClose(status, desc) =\n            proc x <| InternalMessage.Close x\n\n        override x.OnOpen() =\n            proc x <| InternalMessage.Open x\n\n        override x.OnMessageReceived(message, typ) =\n            async {\n                let json = System.Text.Encoding.UTF8.GetString(message.Array)\n                let m = MessageCoder.FromJString processor.JsonProvider json\n                proc x <| InternalMessage.Message (x, m)\n            }\n            |> Async.StartAsTask :> _\n\n        override x.OnReceiveError(ex) = \n            proc x <| InternalMessage.Error (x, ex)\n\n    type private WebSocketServiceLocator<'T>(processor : WebSocketProcessor<'T>) =\n        interface IServiceLocator with\n\n            member x.GetService(typ) =\n                raise <| System.NotImplementedException()\n\n            member x.GetInstance(t : System.Type) =\n                let ctor = t.GetConstructor([| processor.GetType() |])\n                ctor.Invoke([| processor |])\n\n            member x.GetInstance(t, key) =\n                raise <| System.NotImplementedException()\n\n            member x.GetInstance<'TService>() =\n                let t = typeof<'TService>\n                let ctor = t.GetConstructor([| processor.GetType() |])\n                ctor.Invoke([| processor |]) :?> 'TService\n\n            member x.GetInstance<'TService>(key : string) : 'TService =\n                raise <| System.NotImplementedException()\n\n            member x.GetAllInstances(t) =\n                raise <| System.NotImplementedException()\n\n            member x.GetAllInstances<'TService>() : System.Collections.Generic.IEnumerable<'TService> =\n                raise <| System.NotImplementedException()\n\n    let GetWebSocketEndPoint (url : string) (route : string) =\n        let uri = System.Uri(System.Uri(url), route)\n        let wsuri = sprintf \"ws://%s%s\" uri.Authority uri.AbsolutePath\n        Endpoint.FromUri<'T> wsuri\n    \n    let StartWebSocketServer (route : string) (builder : IAppBuilder) (json: Core.Json.Provider)\n        (agent : MailboxProcessor<WebSocketClient<'T> option * Message<'T>>) =\n\n        let processor = WebSocketProcessor(agent, json)\n\n        builder.MapWebSocketRoute<ProcessWebSocketonnection<'T>>(route, WebSocketServiceLocator<'T>(processor))\n\n\n", "snpParentIdO": {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3336735a-2788-46aa-bcda-0ee282cd2d24"}, "snpName": "Server", "snpContent": "\nmodule Server =\n    open WebSharper.WebSockets.WebSocket\n\n    type Message =\n        | Request of string\n        | Response of string\n\n    let Server route json builder =\n        let wrtln (x : string) = System.Diagnostics.Debug.WriteLine x\n\n        let proc = MailboxProcessor.Start(fun inbox ->\n            async {\n                while true do\n                    let! (cl, msg) = inbox.Receive ()\n                    let a = msg.ToString ()\n                    match (msg, cl) with\n                    | Message data, Some cl -> \n                        match data with\n                        | Request x ->\n                            cl.ReplyChan.Reply <| Action.Message (Response x)\n                        | _ -> ()\n                    | Message data, _ -> \n                        ()\n                    | Error exn, _ -> \n                        wrtln <| sprintf \"Panic! %s\" exn.Message\n                    | Open a, _ -> ()\n                    | Close, _ -> ()\n                    | _ -> ()\n            }\n        )\n\n        StartWebSocketServer route builder json proc\n\n", "snpParentIdO": {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6673999d-4406-4484-aea4-a28158084671"}, "snpName": "Client", "snpContent": "\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.Html.Client\nopen WebSharper.WebSockets.WebSocket\n\n[<JavaScript>]\nmodule Client =\n\n    let WS (endpoint : Endpoint<Server.Message>) =\n\n        let server =\n            Client.ConnectTo endpoint <| MailboxProcessor.Start(fun inbox ->\n                let rec loop () : Async<unit> =\n                    async {\n                        let! (msg, rc) = inbox.Receive ()\n                        match msg with\n                        | Message data ->\n                            match data with\n                            | Server.Response x -> Console.Log x\n                            | _ -> ()\n                        | Close -> \n                            Console.Log \"Connection closed.\"\n                        | Open server ->\n                            Console.Log \"WebSocket conenction open.\"\n                        | Error ex ->\n                            Console.Log ex.Message\n                        return! loop ()\n                    }\n                loop ()\n            )\n\n        async {\n            while true do\n                do! Async.Sleep 1000\n                server.Post <| Action.Message (Server.Request \"HELLO\")\n        }\n        |> Async.Start\n\n        Text \"\"", "snpParentIdO": {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5f55d127-2a8c-4b4b-8121-bf8e56e15b3c"}, "snpName": "Main", "snpContent": "#r @\"Owin.dll\"\n#r @\"Microsoft.Owin.dll\"\n#r @\"Microsoft.Owin.Hosting.dll\"\n#r @\"Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"Microsoft.Owin.StaticFiles.dll\"\n#r @\"Microsoft.Owin.FileSystems.dll\"\n#r @\"WebSharper.Owin.dll\"\n#r @\"HttpMultipartParser.dll\"\n#r @\"WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Zafir.Owin.WebSocket\\lib\\net45\\WebSharper.Owin.WebSocket.dll\"\n\nopen WebSharper.Html.Server\nopen WebSharper\nopen WebSharper.Sitelets\n\ntype Action =\n    | Home\n\nmodule Skin =\n    open System.Web\n\n    type Page =\n        {\n            Title : string\n            Body : list<Element>\n        }\n\n    let MainTemplate =\n        Content.Template<Page>(\"~/Main.html\")\n            .With(\"title\", fun x -> x.Title)\n            .With(\"body\", fun x -> x.Body)\n\n    let WithTemplate title body : Content<Action> =\n        Content.WithTemplate MainTemplate <| fun context ->\n            {\n                Title = title\n                Body = body context\n            }\n\nmodule Site =\n\n    let ( => ) text url =\n        A [HRef url] -< [Text text]\n\n    let Links (ctx: Context<Action>) =\n        UL [\n            LI [\"Home\" => ctx.Link Home]\n        ]\n\n    let HomePage ep =\n        Skin.WithTemplate \"HomePage\" <| fun ctx ->\n            [\n                Div [Text \"HOME\"]\n                Div [ClientSide <@ Client.WS ep @>]\n                Links ctx\n            ]\n\n    let MainSitelet ep =\n        Sitelet.Sum [\n            Sitelet.Content \"/\" Home (HomePage ep)\n        ]\n\nmodule SelfHostedServer =\n\n    open global.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin\n    open WebSharper.Owin.WebSocket\n\n    [<EntryPoint>]\n    let Main args =\n        match args with\n        | [| rootDirectory; url |] ->\n            use server = WebApp.Start(url, fun appB ->\n                let ep = WebSocket.GetWebSocketEndPoint  url \"/ws\"\n                let options = Options.Create(rootDirectory)\n                appB.UseStaticFiles(\n                        StaticFileOptions(\n                            FileSystem = PhysicalFileSystem(rootDirectory)))\n                    .UseSitelet(rootDirectory, Site.MainSitelet ep)\n                |> Server.Server \"/ws\" options.Json)\n            stdout.WriteLine(\"Serving {0}\", url)\n            stdin.ReadLine() |> ignore\n            0\n        | _ ->\n            eprintfn \"Usage: WebSharper.WebSockets.Owin.Test ROOT_DIRECTORY URL\"\n            1", "snpParentIdO": {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, "snpPredIds": [{"SnippetId" :"3336735a-2788-46aa-bcda-0ee282cd2d24"}, {"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}, {"SnippetId" :"6673999d-4406-4484-aea4-a28158084671"}, {"SnippetId" :"e82e9f07-e611-4496-8247-03f03be16906"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"83d96c6d-a55e-4975-8d93-06a0fe00f01a"}, "snpName": "Simple Client-Server", "snpContent": "module WSServer = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3d2a9b7f-889c-4826-b539-6de57ee5f573"}, "snpName": "SimpleClientServer", "snpContent": "#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Html\n\n[< JavaScript >]\nmodule Client =\n    let mailbox = MailboxProcessor.Start(fun mail -> async {\n        while true do\n            let! m = mail.Receive()\n            printfn \"%s\" m\n    })\n    \n    let value = Var.Create \"Hello World!\"\n    let form () =\n        div [] [ \n            h3 [] [\n                text \"Type something: \"\n                Doc.Input [] value\n            ] \n            h2 [] [ textView value.View ]\n        ]\n\nopen WebSharper.UI.Server\n\ntype EndPoint = | [< EndPoint \"/\" >] EP\n\nlet content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n    Content.Page(Title = \"Main Page\" , Body  = [ Html.client <@  Client.form () @> ])\n\nopen global.Owin\nopen Microsoft.Owin.Hosting\nopen WebSharper.Owin\nopen Microsoft.Owin.StaticFiles\nopen Microsoft.Owin.FileSystems\n\n[< EntryPoint >]\nlet Main args =\n    use server = \n        WebApp.Start(\"http://localhost:9033/\", fun appB ->\n            appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = \"website\"\n                                               , Sitelet             = Some (Application.MultiPage content)\n                                               , BinDirectory        = \".\"\n                                               , Debug               = true))\n                .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n            |> ignore\n        )\n    stdout.WriteLine(\"Starting, hit enter to finish\")\n    stdin.ReadLine() |> ignore\n    0\n", "snpParentIdO": {"SnippetId" :"83d96c6d-a55e-4975-8d93-06a0fe00f01a"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dcc7ed8b-2697-4558-9bef-159e39fd3361"}, "snpName": "compile & run Simple Client-Server", "snpContent": "open System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Simple Client-Server/SimpleClientServer\"\n                           + siteOptions + (opGenInternal /= \"showoptions\")\n    let  exeFile         = options?OutputFile\n    let  workDir         = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9033/\"\n    let  parms           = sprintf \"%A %A\" site url \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"83d96c6d-a55e-4975-8d93-06a0fe00f01a"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpName": "Calculation Editor", "snpContent": "[< JavaScript >]\nmodule CalcEditor = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"04aeeaea-4302-4446-9fe0-aacd341550db"}, "snpName": "TemplateLib", "snpContent": "open WebSharper.UI.Templating\nlet [< Literal >] TemplatesFileName = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\RuleEditorNew\\website\\Templates.html\"\ntype TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n\nif IsClient then printfn \"%s\" TemplatesFileName", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e92e1677-f965-4aaf-a83b-55b5a7f2430d"}, "snpName": "WebComponent Splitter", "snpContent": "[< JavaScript ; AutoOpen >]\nmodule WcSplitterT =    \n    open ResizeObserver\n    open WebComponent\n    \n    type WcSplitterT () =\n        let mutable added = false\n        do printfn \"WcSplitterT initializer\"\n        [< Inline \"\"\"$global.FSSGlobal.CalcEditor.WcSplitterT.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n        static member Constructor() = \n            let this = ReflectConstruct()\n            WcSplitterT.NewPointer?call this\n            this\n        member this.connectedCallback() = \n            printfn \"my-el connected %A %A\" added this?outerHTML\n            if not added then\n                let el : Dom.Element = this |> box |> unbox\n                let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n                let elsh        = JS.Document.CreateElement \"div\"\n                let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n                let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n                let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n                let first       =    el.HasAttribute \"second\"   |> not\n                let vertical    =    el.HasAttribute \"vertical\"\n                let size        = ref        (0.0, 0.0)\n                let padding     = ref         0.0\n                let gap         = Var.Create  0.0\n                let sizeCalc (sh:Dom.Element) : float * float =\n                    let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                                 else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                    let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                    let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                    gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                    padding := pt + pb\n                    el.GetBoundingClientRect() \n                    |> fun r -> \n                         match vertical, first with\n                         | true , true  ->  r.Width , r.Height \n                         | true , false -> -r.Width , r.Height\n                         | false, true  ->  r.Height, r.Width\n                         | false, false -> -r.Height, r.Width\n                let dragging : bool               ref = ref false   \n                let startP   : float              ref = ref 0.0\n                let start    : float              ref = ref 0.0\n                let domElem  : Dom.Element option ref = ref None                 \n                let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n                let drag (ev: Dom.Event) =\n                    ev :?> Dom.MouseEvent\n                    |> mouseCoord\n                    |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                    |> fun v   -> value.Value <- min maxV (max minV v)\n                   \n                let rec finishDragging (_: Dom.Event) =\n                    if !dragging then\n                        dragging := false\n                        JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                        JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n                let startDragging (ev: Dom.MouseEvent) =\n                    if not !dragging then\n                        dragging := true\n                        startP   := value.Value\n                        start    := mouseCoord ev\n                        size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                        ev.PreventDefault()\n                    //div [\n                    //    SomeAttr  <| on.mouseDown startDragging\n                    //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                    //    style     <| styleSplitter !gap\n                    //    style        \"z-index: 10; background-color: #eef\"\n                    //]\n                let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                             , (sz - gap - pad) * (100.0 - spl) / 100.0\n                let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n                let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n                //div [ \n                //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n                //    style <| Val.map styleSizes value\n                //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n                //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n                //    slot [ name \"splitter\" ; splitter                                               ]\n                //]\n                let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n                //addResizeObserver recalc el\n                (if vertical then\n                  TemplateLib.WCompSplitterVer()\n                    .PartSizes(  View.Map styleSizes value.View )\n                    .AfterRender(  fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc())\n                    .AfterRenderSp(fun  sp              -> domElem :=          Some sp ; recalc())\n                    .MouseDown(  fun te -> startDragging te.Event)\n                    .Gap(        View.Map (sprintf \"%Apx\") gap.View)\n                    .Doc()\n                 else\n                  TemplateLib.WCompSplitterHor()\n                    .PartSizes(  View.Map styleSizes value.View )\n                    .AfterRender(  fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc())\n                    .AfterRenderSp(fun  sp              -> domElem :=          Some sp ; recalc())\n                    .MouseDown(  fun te -> startDragging te.Event)\n                    .Gap(        View.Map (sprintf \"%Apx\") gap.View)\n                    .Doc())\n                |> Doc.Run elsh\n                shadowRoot.AppendChild elsh.FirstChild |> ignore\n                added <- true\n    let init() =\n        if IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"04aeeaea-4302-4446-9fe0-aacd341550db"}, {"SnippetId" :"2749a2be-83f6-4e82-8947-a0a10ca51e83"}, {"SnippetId" :"aaebfac9-964d-484e-b049-869d079d4198"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"58a027f4-cef5-4199-9a78-6c8c2489be29"}, "snpName": "modules Array, View, Var, ListModel", "snpContent": "module Array =\n    let replace i item (array: _[]) = \n        seq {\n            if i > 0            then yield! array.[.. i - 1]\n            yield item\n            if i < array.Length then yield! array.[i + 1 ..]\n        } |> Seq.toArray\n\nmodule View =\n    let [<Inline>] inline consistent   (vl:View<_>)  = \n        let prior      = View.TryGet vl \n                         |> Option.defaultWith (fun () -> Unchecked.defaultof<_> ) \n                         |> Var.Create \n        let setPrior v = if prior.Value <> v then prior.Set v \n        View.Get  setPrior vl\n        View.Sink setPrior vl\n        prior.View\n\nmodule Var =\n    let mutable private counter = 1\n    let freshId () =\n        counter <- counter + 1\n        \"varuid\" + string counter\n            \n//    let Make (init: 'T) (view: View<'T>) (set: 'T -> unit) =\n//        let id = freshId ()\n//        let current = ref init\n//        let view = view |> View.Map (fun x -> current := x; x)\n//        { new Var<'T>() with\n//            member this.View           = view\n//            member this.Get         () = !current\n//            member this.Set         x  = set x\n//            member this.SetFinal    x  = set x\n//            member this.UpdateMaybe f  = view |> View.Get (f >> Option.iter set)\n//            member this.Update      f  = view |> View.Get (f >>             set)\n//            member this.Id             = id\n//        }\n    let lensView get update view0 (var: Var<_>) =\n        let id   = freshId()\n        let view = View.Map2 (fun v _ -> get v) var.View view0\n        { new Var<'V>() with\n            member this.Get        () = get (var.Get())\n            member this.Set         v = var.Update(fun t -> update t v)\n            member this.SetFinal    v = this.Set(v)\n            member this.Update      f = var.Update(fun t -> update t (f (get t)))\n            member this.UpdateMaybe f = var.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n            member this.View          = view\n            member this.Id            = id\n        }\nmodule ListModel =\n    let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.FindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.TryFindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let lensDef def k (m:ListModel<_,_>) =\n        let get = Option.defaultValue def\n        lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n\n    let currentLensUpd def curr upd (model:ListModel<_,_>) = \n        curr \n        |> Var.lensView (Option.bind (model.TryFindByKey) >> Option.defaultValue def) \n                        (fun kO v -> kO |> Option.iter (upd v) ; kO)\n                        model.View\n    let currentLensUpd' def curr upd (model:ListModel<_,_>) = \n        let view = curr |> View.Map2 (fun _mdl kO -> kO |> Option.bind model.TryFindByKey |> Option.defaultValue def) model.View\n        Var.Make view upd\n    let currentLens def curr (model:ListModel<_,_>) = \n        model \n        |> currentLensUpd' def curr (fun v -> model.UpdateBy (fun _ -> model.TryFindByKey (model.Key v) |> Option.map (fun _ -> v) ) <| model.Key v)\n    \n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9fae7897-61b9-4b7b-af4e-9fbd022d1ff8"}, "snpName": "TreeNode", "snpContent": "open Useful\nopen CalculationModel.CalculationModel\n\ntype TreeNodeId = TreeNodeId of System.Guid\n\ntype Weight =\n| Zero\n| Add\n| Subtract\n\nlet parents = System.Collections.Generic.Dictionary<TreeNodeId, obj>()\n\ntype TreeNode = {\n    nid      : TreeNodeId\n    expanded : bool\n    element  : NodeId\n    children : TreeNode []\n    weight   : Weight\n} with\n    static member FromNode (n:Tree.Node<_>) = n :?> TreeNode\n    interface Tree.Node<TreeNodeId> with\n        member node.Id                 = node.nid\n        member node.isExpanded         = node.expanded\n        member node.canHaveChildren    = match node.element with | Calc _ -> false | _ -> true\n        member node.path               =   \n            let rec getPath nid = parents |> Dict.tryGetValue nid |> Option.map Tree.toNode |> Option.map (fun n -> n.Id :: n.path) |> Option.defaultValue []\n            getPath node.nid\n        member node.children           =   node     .children   |> Tree.toSeqNode\n        member node.newChildren     ch = { node with children = ch \n                                                                |> Seq.map   (fun n -> n :?> TreeNode    ) \n                                                                |> Seq.filter(fun n -> \n                                                                    parents \n                                                                    |> Dict.tryGetValue n.nid \n                                                                    |> Option.map (fun v -> \n                                                                        if v :?> TreeNode <> node then \n                                                                            parents.Remove n.nid |> ignore\n                                                                            parents.Add(n.nid, node)\n                                                                    )\n                                                                    |> Option.defaultWith(fun () ->\n                                                                        parents.Add(n.nid, node)\n                                                                    )\n                                                                    true)\n                                                                |> Seq.toArray } |> Tree.toNode\n        member node.parent          ns = parents |> Dict.tryGetValue node.nid |> Option.map Tree.toNode\n\nmodule TreeNode =\n    let fromNode    n  = TreeNode.FromNode n\n    let fromSeqNode ns = ns |> Seq.map fromNode |> Seq.toArray\n\n    let newTreeNode ch = {\n        nid      = TreeNodeId <| System.Guid.NewGuid()\n        expanded = true\n        children = [||]\n        element  = ch\n        weight   = Add\n    }\n    let newNodeCalc cid = newTreeNode <| Calc cid\n    let newNodeTot  tid = newTreeNode <| Tot  tid\n    let removeNodes      p   (nodes: TreeNode seq) = nodes |> Tree.toSeqNode |> Tree.removeNodes (fromNode >> p) |> fromSeqNode\n    let getElement n = n.element\n    let getTId = function | Tot  tid -> Some tid | _ -> None\n    let getCId = function | Calc cid -> Some cid | _ -> None\n    let forTId p = getElement >> getTId >> (Option.map p ) >> Option.defaultValue false\n    let forCId p = getElement >> getCId >> (Option.map p ) >> Option.defaultValue false\n\n    let tryFindTreeNode  p   (nodes: TreeNode seq) = nodes |> Tree.toSeqNode |> Tree.tryFind     (fromNode >> p) |> Option.map fromNode\n    let tryFindNode      nid (nodes: TreeNode seq) = nodes |> tryFindTreeNode (fun n -> n.nid = nid)\n    let tryFindSelNode   sel (nodes: TreeNode seq) = sel   |> Option.map fst     |> Option.bind (swap tryFindNode nodes)\n//    let tryFindSelChild  sel (nodes: TreeNode seq) = nodes |> tryFindSelNode sel |> Option.map getElement\n    let tryFindNodeTId tid     (nodes: TreeNode seq) = nodes |> tryFindTreeNode (forTId ((=) tid) )\n    let tryFindNodeCId cid     (nodes: TreeNode seq) = nodes |> tryFindTreeNode (forCId ((=) cid) )    \n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"5d4bba38-c34d-40be-a19a-383bdb85c663"}, {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}, "snpName": "ModelUI", "snpContent": "//#r @\"Compiled\\CalculationModelDll\\CalculationModelDll.dll\"\n\ntype Selection  = (TreeNodeId * (ForId option)) option\n\ntype Version = {\n    major     : int\n    minor     : int\n    majorDate : string\n    minorDate : string\n}\n\nmodule Version =\n    let New() = {\n        major     = 0\n        minor     = 0\n        majorDate = \"\"\n        minorDate = \"\"\n    }\n    let incrementMinor v = { v with minor = v.minor + 1; minorDate = nowStamp() }\n    let incrementMajor v = {        major = v.major + 1; majorDate = nowStamp()\n                                    minor = 0          ; minorDate = nowStamp() }\n\ntype ModelUI = {\n    treeHierarchy : Var<TreeNode []>\n    calculations  : ListModel<CalId        , Calculation>\n    totals        : ListModel<TotId        , Total      >\n    dimensions    : ListModel<DimId        , Dimension  >\n    cubes         : ListModel<CubId        , Cube       >\n    globalDefs    : Var<string>\n    server        : Var<string>\n    selection     : Var<Selection>\n    selectedDim   : Var<DimId option>\n    selectedCube  : Var<CubId option>\n    collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n    cubePrefix    : Var<string>\n    measurePrefix : Var<string>\n    outputMsgs    : Var<string>\n    codeFS        : Var<string>\n    parserMsgs    : Var<string>\n    fileName      : Var<string>\n    version       : Var<Version>\n}\n\ntype MsgModel =\n| AddTotal\n| SelectTotal       of TotId\n| RemoveTotal       of TotId\n| AddCalculation\n| RemoveCube        of CubId\n| RenameCube        of CubId * string\n| AddCube           of         string * Set<DimId>\n| RemoveCalculation of CalId\n| SelectCalculation of CalId\n| AddFormula        of CalId\n| RemoveFormula     of ForId\n| SelectFormula     of ForId\n| SelectFormNode    of ForId * TreeNodeId\n| SelectNode        of         TreeNodeId\n| ExpandNode        of bool  * TreeNodeId\n| IndentNode        of bool  * TreeNodeId\n| MoveNode          of bool  * TreeNodeId * TreeNodeId\n| AddDimension\n| RemoveDimension   of DimId\n| SelectDimension   of DimId\n| AddFormDim        of ForId * DimId * string\n| RemoveFormDim     of ForId * DimId\n| RemoveCalcDim     of CalId * DimId\n| AddCalcDim        of CalId * DimId\n| RemoveForDest     of CalId * ForId * DimId \n| SetForDest        of CalId * ForId * DimId * string\n| NoOp\n\nmodule ModelUI =\n    let isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\n    let selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n    \n    let nonTotal        = { Total      .New()                with totId = TotId System.Guid.Empty }\n    let nonCalculation  = { Calculation.New()                with calId = CalId System.Guid.Empty } \n    let nonFormula      = { Formula    .New()                with forId = ForId System.Guid.Empty }\n    //let nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n    \n    let nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n    let nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\n    let nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n    \n    let isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n\n    let refreshView, refreshNow =\n        let refresh = Var.Create ()\n        refresh.View, fun () -> refresh.Value <- ()\n    let setHierarchy model (nodes: TreeNode seq) =\n        nodes\n        |> Seq.map (fun n -> parents.Remove n.nid |> ignore ; n)\n        |> Seq.toArray\n        |> model.treeHierarchy.Set\n\n    let [<Inline>] inline mapIds f vls = vls |> View.Map (Seq.map f >> Seq.toArray) |> View.consistent\n\n    let getDimsCubeO cubes = cubes\n    \n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"58a027f4-cef5-4199-9a78-6c8c2489be29"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}, {"SnippetId" :"5d4bba38-c34d-40be-a19a-383bdb85c663"}, {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}, {"SnippetId" :"9fae7897-61b9-4b7b-af4e-9fbd022d1ff8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d5bccf9b-eef5-4c86-8485-44d06c81db80"}, "snpName": "module DragDrop", "snpContent": "module DragDrop =\n\n    type DragInfo = \n        | DragNone\n        | DragNode of TreeNodeId\n        | DragForm of CalId * Formula\n    \n    let mutable drag        = DragNone\n    let setDragNone ()      = drag <- DragNone\n    let setDragNode tnid    = drag <- DragNode tnid\n    let setDragForm cid frm = drag <- DragForm(cid, frm)\n    \n    let getDragFormO cid fid = match drag with DragForm (dcid, dfor) when fid  <> dfor.forId && dcid = cid -> Some dfor | _ -> None\n    let getDragNIdO  tnId    = match drag with DragNode  dnid        when dnid <>       tnId               -> Some dnid | _ -> None\n    let isDragForm   cid fid = getDragFormO cid fid |> function None -> false | _ -> true\n    \n    let [< Inline >] inline moveItem dropId elems getId item =\n        elems\n        |> Seq.filter (getId >> ((<>) (getId item)) )\n        |> Seq.toArray\n        |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                     [fst ; [| item |] ; snd])\n        |> Seq.collect id\n        |> Seq.toArray\n    \n    let [< Inline >] inline value (x: ^T)   = (^T : (member Value : #seq<'U>        )  x    )\n    let [< Inline >] inline set   (x: ^T) v = (^T : (member Set   : #seq<'U> -> unit) (x, v))\n    \n    let [< Inline >] inline moveItemInListModel dropId lm getId itemO = itemO |> Option.iter( moveItem dropId (value lm) getId >> (set lm) )\n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"04aeeaea-4302-4446-9fe0-aacd341550db"}, {"SnippetId" :"58a027f4-cef5-4199-9a78-6c8c2489be29"}, {"SnippetId" :"5d4bba38-c34d-40be-a19a-383bdb85c663"}, {"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, "snpName": "module Global", "snpContent": "[< AutoOpen >]\nmodule Global =\n    let model = {\n        treeHierarchy = Var.Create [||]\n        calculations  = ListModel.Create (fun v -> v.calId) [||]\n        totals        = ListModel.Create (fun v -> v.totId) [||]\n        dimensions    = ListModel.Create (fun v -> v.dimId) [||]\n        cubes         = ListModel.Create (fun v -> v.cubId) [||]\n        globalDefs    = Var.Create \"\"\n        server        = Var.Create \"\"\n        selection     = Var.Create None\n        selectedDim   = Var.Create None\n        selectedCube  = Var.Create None\n        collapsed     = ListModel.Create id [||]\n        cubePrefix    = Var.Create \"Z\"\n        measurePrefix = Var.Create \"M\"\n        outputMsgs    = Var.Create \"\"\n        codeFS        = Var.Create \"\"\n        parserMsgs    = Var.Create \"\"\n        fileName      = Var.Create \"NewFile.json\"\n        version       = Var.Create <| Version.New()\n    }\n    \n    let mutable processor = fun (msg:MsgModel) -> ()\n    \n    let appendText (var:Var<string>) msg = \n        match var.Value, msg with\n        | \"\", m \n        | m , \"\" -> m\n        | v , m  -> v + \"\\n\" + m\n        |> var.Set\n        \n    let inline appendMsgs   msg = appendText model.outputMsgs msg\n    let inline appendParser msg = appendText model.parserMsgs msg\n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4f58224f-d544-4472-b96d-66c274500e8a"}, "snpName": "CodeMirror", "snpContent": "module CodeMirror =\n    open CodeMirror\n    open Useful\n    open CalculationModel.CalculationModel\n    \n    [<NoComparison ; NoEquality>]\n    type KeyMap = { \n        F2              : CodeMirror.Editor -> unit \n        F11             : CodeMirror.Editor -> unit\n        Tab             : CodeMirror.Editor -> unit\n        ``Ctrl-Space``  : CodeMirror.Editor -> unit\n        ``.``           : CodeMirror.Editor -> unit\n    }\n    \n    let codeMirrorRender (var           : Var<string>                         ) \n                         (annotationsWO : View<Lint.Response []>        option) \n                         (showToolTipO  :(string -> int -> int -> unit) option) \n                         (getHintsO     :(((string * string * string) [] -> int * int -> int * int -> unit) \n                                       -> string -> int -> int -> unit) option) =\n    \n        let setDirtyCond() = ()\n        let getHints    _  = ()\n\n        let showToolTip (ed:CodeMirror.Editor) =\n            showToolTipO |> Option.iter(fun showToolTipF ->\n                let  pos   = ed.GetCursor()\n                let  l     = ed.GetLine pos.line\n                showToolTipF l pos.line pos.ch\n            )\n            \n        let getHints    (ed:CodeMirror.Editor, callback, _) =\n            getHintsO |> Option.iter(fun getHintsF ->\n                let  pos   = ed.GetCursor()\n                let  l     = ed.GetLine pos.line\n                let showHints hints posFrom posTo =\n                    let hs = hints\n                             |> Array.map(fun (txt, dsp, cls) -> \n                                {\n                                    Hint.Hint.text        = txt\n                                    Hint.Hint.displayText = dsp\n                                    Hint.Hint.className   = cls\n                                })\n                    callback {\n                        Hint.Response.list   = hs\n                        Hint.Response.from   = cmPos posFrom\n                        Hint.Response.``to`` = cmPos posTo\n                    }\n                getHintsF showHints l pos.line pos.ch\n            )\n\n        let codeMirror =\n            CodeMirror.New(var)\n                .OnChange(setDirtyCond)\n                .OnRender(fun ed ->\n                  ed.AddKeyMap({  F2              = showToolTip\n                                  F11             = fun ed -> ed.SetOption(\"fullScreen\", ed.GetOption(\"fullScreen\") |> unbox |> not) \n                                  Tab             = fun ed -> ed.ReplaceSelection(\"    \", \"end\")\n                                  ``Ctrl-Space``  =    Hint.showHints ed getHints false\n                                  ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\"))\n                                                    >> Hint.showHints ed getHints false\n                               })\n                  ed.SetOption(\"mode\"         , \"fsharp\"  )\n                  ed.SetOption(\"theme\"        , \"rubyblue\")\n                  ed.SetOption(\"lineNumbers\"  , true      )\n                  ed.SetOption(\"matchBrackets\", true      )\n                  ed.SetOption(\"gutters\"      , [| \"CodeMirror-lint-markers\" |])\n                  ed.On(\"dblclick\", showToolTip)\n                  annotationsWO\n                  |> Option.iter(fun annotationsW ->\n                      View.Sink       (fun _ -> ed?performLint() |> ignore) annotationsW\n                      Lint.setLint ed (fun (_t, send, _o, _ed) -> annotationsW |> View.Get send)\n                  )\n                )\n        \n        //let refreshCodeMirror() = codeMirror.editorO |> Option.iter (fun cm -> cm.Refresh())\n        \n        //let delayedRefreshCM delay =\n        //    async {\n        //        do! Async.Sleep delay\n        //        refreshCodeMirror() \n        //    } |> Async.Start\n        //    \n        codeMirror.Render\n    \n    let filterGlobal msgs =\n        let rex  = \"\"\"Global  \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n        match msgs with\n        | REGEX rex \"g\" m -> m\n        | _               -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rex \"\" [| _ ; fl;     fc;     tl;     tc; msg |] \n                     -> Some (int fl, int fc, int tl, int tc, msg)\n            | _      -> None\n        )\n        |> Array.map (fun (fl, fc, tl, tc, msg) ->\n                { Lint.Response.message  = msg\n                  Lint.Response.severity = \"error\"\n                  Lint.Response.from     = cmPos(fl - 1, fc - 1) \n                  Lint.Response.``to``   = cmPos(tl - 1, tc - 1)\n                }\n          )        \n    \n    let rexFormula   = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\. ForId \"\"\" + \"\\\"\" + rexGuid // \"\n    let filterFormula msgs fidO =\n        match msgs with\n        | REGEX rexFormula \"g\" m -> m\n        | _                 -> [||]\n        |> Array.choose (fun v ->\n            match v with\n            | REGEX rexFormula \"\" [| _ ; fl;     fc;     tl;     tc; msg; guid |] when fidO = Some(guid |> System.Guid |> ForId) \n                            -> Some (int fl, int fc, int tl, int tc, msg)\n            | _             -> None\n        )\n        |> Array.map (fun (fl, fc, tl, tc, msg) ->\n                { Lint.Response.message  = msg\n                  Lint.Response.severity = \"error\"\n                  Lint.Response.from     = cmPos(fl - 1, fc - 1) \n                  Lint.Response.``to``   = cmPos(tl - 1, tc - 1)\n                }\n          )        \n    \n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"4becf2f9-2b9f-442e-bb70-02ac8d8d67f6"}, {"SnippetId" :"58a9fc2a-df09-42ef-ba7a-54e780167009"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5397c4a9-f60a-448c-9c2a-0e06e85289d2"}, "snpName": "FSCode", "snpContent": "module FSCode =\n\n    let trace = id\n\n    type LocationDet =\n    | InDimension   of DimId\n    | InCalculation of CalId\n    | InGlobalDefs\n    | InFormula     of ForId\n    | InFormulaDest of ForId\n    | InFsCode\n    \n    type MsgLocation = {\n        lines    : int\n        indent   : int\n        location : LocationDet\n    }\n    \n    let getDimO  did = model.dimensions  .TryFindByKey did\n    let getCalcO cid = model.calculations.TryFindByKey cid\n    let getFormO fid = model.calculations.Value |> Seq.tryPick (fun c -> c.calFormulas |> Seq.tryPick (fun f -> if f.forId = fid then Some(c, f) else None))\n    \n    let fixName (c:string) = c.Trim().Replace(\" \", \"_\").Replace(\"-\",\"_\")\n    \n    let newDimS  d = sprintf \"    let %s = newDim (DimId (Guid.Parse %A)) %A %A %A\" (fixName d.dimName) d.dimId.Id d.dimName d.dimType (if d.dimExclude then \"\" else d.dimPrefix) |> trace, InDimension d.dimId \n    \n//    let getDims () = model.dimensions.Value |> Seq.sortBy getorder |> Seq.map newDimS\n    \n    let dimMeasureName  cubeName = model.measurePrefix.Value + (cubeName:string).Substring(1)\n    let cubeMeasureName cube     = cube.cubName  |> dimMeasureName\n    let newMeasureDimS  cube     = cube |> cubeMeasureName |> (fun c -> sprintf \"    let %s = newDim (DimId (Guid.Parse %A)) %A %A %A\" (fixName c) cube.cubId.Id c DtCalc \"\" ) |> trace\n    \n    let getMeasureDims () =\n        model.cubes.Value\n        |> Seq.map newMeasureDimS\n    \n    let getCubeDims (c:Cube) =\n        c.cubDims\n        |> Seq.choose    (model.dimensions.TryFindByKey)\n        |> Seq.map       (fun d -> d.dimName)\n        |> Seq.append <| [ dimMeasureName c.cubName ]\n        |> String.concat \" ; \"\n    \n    let newCubeS c = sprintf \"    let %s = newCube (CubId (Guid.Parse %A)) %A CtCalc [ %s ] (Some %s)\" (fixName c.cubName) c.cubId.Id c.cubName (getCubeDims c) (cubeMeasureName c |> fixName) |> trace\n    //let getCubes () = model.cubes.Value |> Seq.map newCubeS\n    \n    let getCalcCubeNameW cdims = \n        model.cubes.TryFindAsView (fun cub -> cub.cubDims |> Set = cdims)\n        |> View.Map(\n           Option.map (fun c -> fixName c.cubName)\n        >> Option.defaultValue \"NoCubeYet\" >> trace\n        )\n        |> View.consistent\n    let newCalcSW c = V( sprintf \"    let %s = newCalc (CalId (Guid.Parse %A)) %s %A %A %A %s\" (fixName c.calName) c.calId.Id (if c.isInput then \"Input\" else \"Calc\") c.calName c.calOrder c.isText (getCalcCubeNameW c.calDims).V |> trace, InCalculation c.calId) \n\n    //let getCalcCubeName calc = \n    //    model.cubes.TryFind (fun cub -> cub.cubDims |> Set = calc.calDims)\n    //    |> Option.map (fun c -> fixName c.cubName)\n    //    |> Option.defaultValue \"NoCubeYet\" \n    //let newCalcS  c = sprintf \"    let %s = newCalc (CalId (Guid.Parse %A)) %s %A %A %A %s\" (fixName c.calName) c.calId.Id (if c.isInput then \"Input\" else \"Calc\") c.calName c.calOrder c.isText (getCalcCubeName c) |> trace, c.calId\n    //let getCalcs () = model.calculations.Value |> Seq.sortBy (fun c -> c.calOrder) |> Seq.map newCalcS\n    \n    let getDest f =\n        f.forDestDecl\n        |> Seq.choose (fun d -> getDimO d.Key |> Option.map (fun dim -> sprintf \"%s.[%A]\" dim.dimName d.Value ))\n        |> String.concat \" ; \"\n        |> sprintf \"[ %s ]\"\n    \n    let prepareFormula (f:string) =\n        f.Replace(\"@=\", \"&=\").Replace(\"@<\", \"&<\").Replace(\"@>\", \"&>\")\n        |> String.unindent\n        |> Seq.map ((+) \"    \")\n    \n    let fixText txt = (txt |> Seq.map String.trim |> Seq.map (fun s -> s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\\"\", \"\\\\\\\"\")) |> String.concat \" \")\n    \n    let newFormS (c, f) =\n        let txt   = prepareFormula f.forText\n        [ \n            yield! txt\n            yield  sprintf \"    |> newForm (ForId (Guid.Parse %A)) %s %s %s %A %A \"  f.forId.Id (fixName c.calName) (sprintf \"%A\" f.forType)    (getDest f)  f.forOrder (fixText txt |> extract 495)\n        ] |> String.concat \"\\n\"  |> trace\n      , InFormula f.forId\n    \n    let getForms c = \n        c.calFormulas\n        |> Seq.sortBy (fun f -> f.forOrder)\n        |> Seq.map    (fun f -> c, f)\n        |> Seq.map newFormS\n        |> Seq.toArray\n    \n    let preface majorVersion server =\n        sprintf \"\"\"\n        #nowarn \"86\"\n        #r @\"..\\CalculationModelDll\\CalculationModelDll.dll\"\n        module Definition%d =\n            open FSSGlobal.CalculationModel\n            open CalculationModel\n            open CalculationSyntax\n            open InitModel\n            open System\n            \n            let NoCubeYet = newCube (CubId <| Guid.NewGuid()) \"NOCUBEYET\" CtCalc [] None\n            \n            {\n                modId           = ModId <| System.Guid.NewGuid()\n                server          = @%A\n                actualElem      = \"Actual\"\n                modCubes        = [| |]\n                modDims         = [| |]\n                modCalculations = [| |]\n            } |> setInitModel\n                \"\"\" majorVersion server\n        |> trace |> String.unindent \n    \n    let fsCodeForCalc c =\n        let fsForms = getForms  c |> Seq.map fst |> String.concat \"\\n\"\n        let fsCalc  = newCalcSW c |> View.TryGet |> Option.map fst |> Option.defaultValue \"View.TryGet failed for some reason\"\n        let header  =\n            sprintf \"\n                module Formula =\n                    open FSSGlobal.CalculationModel\n                    open CalculationModel\n                    open CalculationSyntax\n                    open InitModel\n                    open System \n                    open Definition%d\\n\" model.version.Value.major\n            |> String.unindentStr\n        header\n        + fsCalc\n        + \"\\n    addCalcs()\\n\"\n        + fsForms\n        + \"\\n    addFrms() \" \n        + \"\\n    \"\n\n    let mapSeqCached0 map f (lmodel:ListModel<_, _>) =\n        lmodel.View\n        |> View.Map map\n        |> View.MapSeqCachedBy lmodel.Key  (lmodel.Key >> lmodel.TryFindByKeyAsView >> f )\n        \n    /// from 'a -> View<'x>   to:  'a option -> View<'x option>\n    let optviewMerge f = function | None -> View.Const None | Some v -> f v |> View.Map Some \n    let inline viewSeqChoose v = v |> View.Map View.Sequence |> View.Join |> View.Map (Seq.choose id)\n    let mapSeqCached  map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Map  (Option.map   f)) model   |> viewSeqChoose\n    let mapSeqCachedW map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Bind (optviewMerge f)) model   |> viewSeqChoose\n    let bindSeqCached map f (model:ListModel<_, _>) = mapSeqCached0 map (View.Map  (Option.bind  f)) model   |> viewSeqChoose\n\n    let loc     lc nl   = { lines = nl ; indent = 4 ; location = lc }\n    let txtLocn lc txts =   txts  |> String.concat \"\\n\", [| loc lc (txts |> Seq.length) |]\n    let txtLoc1 lc txt  = [ txt ] |> txtLocn lc\n\n    let groupLoc1s cs = cs |> Seq.map fst |> String.concat \"\\n\" , cs |> Seq.map (fun (_, lc) -> loc lc 1                           ) |> Seq.toArray\n    let groupLocns fs = fs |> Seq.map fst |> String.concat \"\\n\" , fs |> Seq.map (fun (t, lc) -> loc lc (t.Split '\\n' |> Seq.length)) |> Seq.toArray                         \n    \n    let collectCode v =\n        v |> Seq.filter (fst >> ((<>) \"\"))\n          |> Seq.toArray\n          |> Array.unzip\n          |> fun (ts, ls) -> ts |> String.concat \"\\n\", Array.collect id ls\n    \n    let fsCode() =\n        let prefaceV   = View.Do {\n            let! version = model.version.View\n            let! server  = model.server .View\n            return preface version.major server |> txtLocn InFsCode\n        }\n        let newDimsV   =    model.dimensions   |> mapSeqCached  Dimension.sort newDimS\n        let newMDimsV  =    model.cubes        |> mapSeqCached  id             newMeasureDimS\n        let newCubesV  =    model.cubes        |> mapSeqCached  id             newCubeS\n        let newCalcsV  =    model.calculations |> mapSeqCachedW id             newCalcSW\n        let newFormsV  =    model.calculations |> mapSeqCached  id             getForms\n        let globalDefV = V( model.globalDefs.V |> (String.indent 4 >> txtLocn InGlobalDefs ) )\n        let newMDimsSV = V( newMDimsV       .V |>                     txtLocn InFsCode       )\n        let newCubesSV = V( newCubesV       .V |>                     txtLocn InFsCode       )\n        let newFormsSV = V( newFormsV       .V |> (Seq.collect id  >> groupLocns        ) )\n        let newDimsSV  = V( newDimsV        .V |>                     groupLoc1s          )\n        let newCalcsSV = V( newCalcsV       .V |>                     groupLoc1s          )\n        [   prefaceV\n            newDimsSV\n            newMDimsSV\n            txtLoc1 InFsCode \"    addDims()\"  |> View.Const\n            newCubesSV\n            txtLoc1 InFsCode \"    addCubes()\" |> View.Const\n            newCalcsSV\n            txtLoc1 InFsCode \"    addCalcs()\" |> View.Const\n            globalDefV\n            newFormsSV\n            txtLoc1 InFsCode \"    addFrms()\"  |> View.Const\n        ] \n        |> View.Sequence\n        |> View.Map collectCode\n\n    let fsCodeVO = if IsClient then Some <| fsCode() else None\n\n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1414242b-3301-4071-aa25-19c67f0b5bff"}, "snpName": "Parse FSCode", "snpContent": "module ParseFS =\n    open FSCode\n    open Several\n\n    let adaptMessage locs (lf:int) (cf:int) (lt:int) (ct:int) msg =\n        locs \n        |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n        |> fst\n        |> Seq.tryFind (fun (from, l) -> lf - 1 >= from && lf - 1 < from + l.lines)\n        |> Option.bind (fun (from, l) -> \n            match l.location with \n            | InDimension   did -> getDimO  did      |> Option.map (fun  dim  -> sprintf \"%s: %A. %A\"                     dim.dimName                                                                 msg did )\n            | InCalculation cid -> getCalcO cid      |> Option.map (fun  clc  -> sprintf \"%s: %A. %A\"                     clc.calName                                                                 msg cid )\n            | InFormulaDest fid -> getFormO fid      |> Option.map (fun (c,f) -> sprintf \"%s: %A. %A\"                     c  .calName                                                                 msg fid )\n            | InFormula     fid -> getFormO fid      |> Option.map (fun (c,f) -> sprintf \"%s: (%d,%d) - (%d,%d): %A. %A\"  c  .calName (lf - from) (cf - l.indent) (lt - from) (ct - l.indent) msg fid )\n            | InFsCode          -> Some                            (             sprintf \"F# Code (%d,%d) - (%d,%d): %A.\"              lf          cf              lt          ct             msg     )\n            | InGlobalDefs      -> Some                            (             sprintf \"Global  (%d,%d) - (%d,%d): %A.\"             (lf - from) (cf - l.indent) (lt - from) (ct - l.indent) msg     )\n        )\n        |> Option.defaultWith (fun () -> sprintf \"%d %d - %d %d %s\" lf cf lt ct msg)\n\n    let adaptMessages locs ms =\n        let rex = \"\"\".*\\((\\d+),(\\d+)\\) - \\((\\d+),(\\d+)\\) ([^\"]*?)\"(?:\\n|$)\"\"\"\n        match ms with\n        | REGEX rex \"g\" m ->    m\n        |               m -> [| m |]\n        |> Array.map (\n            function\n            | REGEX rex \"\" [| _ ; lf ; cf ; lt ; ct ; msg |] -> adaptMessage locs (int lf) (int cf) (int lt) (int ct) msg \n            | o                                              -> o\n        )\n\n    let parseFile = \"RuleEditor.fsx\"\n\n    let autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"RuleEditor\")//, endPoint = JS.Window.Location.Href)\n\n    if IsClient then\n            \n        let cancellationTokenSourceO = ref None\n        let parseFsCode _ =\n            let asy = async {\n                model.parserMsgs.Value   <- \"Parsing...\\n\" + String.skipFirstLine model.parserMsgs.Value\n                do!                         Async.Sleep 1000\n                match FSCode.fsCodeVO with\n                | None                   -> ()\n                | Some fsCodeV           ->\n                let! fs, locs             = fsCodeV |> View.GetAsync\n                let! res0                 = autoCompleteClient.Parse(parseFile, fs)\n                let  res                  = adaptMessages locs res0 |> String.concat \"\\n\"\n                //model.outputMsgs.Value   <- locs |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\"\n                model.codeFS.Value       <- fs\n                cancellationTokenSourceO := None\n                model.parserMsgs.Value   <- \"Parsed!\\n\" + res\n             }\n            !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n            cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n            Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n                        \n        FSCode.fsCodeVO |> Option.iter (View.Sink parseFsCode)\n\n    let sForId = ForId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n    let sCalId = CalId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n    let sTotId = TotId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n    let sDimId = DimId System.Guid.Empty |> sprintf \"%A\" |> String.splitByChar ' ' |> Seq.head\n\n    let rexGlobal =      \"\"\"(Global)  \\(\"\"\"  \n    let rexTotId  = \"\"\"\\\"\\. (\"\"\" + sTotId + \") \" + \"\\\"\" + rexGuid\n    let rexCalcId = \"\"\"\\\"\\. (\"\"\" + sCalId + \") \" + \"\\\"\" + rexGuid\n    let rexFormId = \"\"\"\\\"\\. (\"\"\" + sForId + \") \" + \"\\\"\" + rexGuid\n    let rexDimId  = \"\"\"\\\"\\. (\"\"\" + sDimId + \") \" + \"\\\"\" + rexGuid\n\n    let jumpToLine (line:string) = \n        let rex = [ rexGlobal\n                    rexTotId \n                    rexCalcId\n                    rexFormId\n                    rexDimId     \n                  ] |> String.concat \"|\" |> sprintf \"(?:%s)\"\n        match line with\n        | REGEX rex \"\" p -> \n            p\n            |> Array.skip 1\n            |> Array.filter (isUndefined >> not)\n            |> function\n               | [| v ; guid |] when v = sForId -> SelectFormula     (System.Guid guid |> ForId) |> processor\n               | [| v ; guid |] when v = sCalId -> SelectCalculation (System.Guid guid |> CalId) |> processor\n               | [| v ; guid |] when v = sTotId -> SelectTotal       (System.Guid guid |> TotId) |> processor\n               | [| v ; guid |] when v = sDimId -> SelectDimension   (System.Guid guid |> DimId) |> processor       \n               | _ -> ()\n        | _ -> ()\n    \n    let jumpToRef (e:obj) = \n        let v : string = e?Target?value |> unbox\n        let s : int    = e?Target?selectionStart |> unbox\n        let i = v.[0..s].LastIndexOf '\\n'\n        jumpToLine v.[i+1..]\n\n    let showToolTips lc txt line col =\n        async {\n            match FSCode.fsCodeVO with\n            | None           -> ()\n            | Some fsv       ->\n            let! _, locs      = fsv  |> View.GetAsync\n            let   locsm,  _   = locs |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n            match locsm      |> Seq.tryFind (fun (_,l) -> l.location = lc) with\n            | None           -> () \n            | Some(from, loc)->\n            let  sub          = REGEX.getStartWord txt col |> String.length\n            let  add0         = REGEX.getEndWord   txt col |> String.length\n            let  add          = if sub = 0 && add0 = 0 then 2 else add0\n            let  lf           = line       + 1 + from\n            let  lt           = line       + 1 + from\n            let  cf           = col  - sub + 1 + loc.indent\n            let  ct           = col  + add + 1 + loc.indent\n            let! tip          = autoCompleteClient.ToolTip(parseFile, lf, cf)\n            let  msg          = adaptMessage locs lf cf lt ct tip\n            //let  msg          = sprintf \"Global  %A - %A: %A.\" (line + 1, col - sub + 1) (line + 1, col + add + 1) (tip.Replace(\"\\\"\",\"''\"))\n            if not <| model.parserMsgs.Value.Contains msg then \n                appendParser msg\n        } |> Async.Start\n\n    let getSymbolType chr =\n        match chr with\n        | \"C\"   -> \"class\"     \n        | \"Cn\"  -> \"Constant\"  \n        | \"D\"   -> \"delegate\"  \n        | \"E\"   -> \"enum\"      \n        | \"P\"   -> \"property\"  \n        | \"e\"   -> \"event\"     \n        | \"X\"   -> \"exception\" \n        | \"F\"   -> \"field\"     \n        | \"I\"   -> \"interface\" \n        | \"M\"   -> \"function\"    \n        | \"N\"   -> \"module\"    \n        | \"S\"   -> \"struct\"    \n        | \"T\"   -> \"type\"      \n        | \"V\"   -> \"Variable\"  \n        | _     -> chr\n\n\n    let getHints lc showHints txt line col =\n        async {\n            match FSCode.fsCodeVO with\n            | None           -> ()\n            | Some fsv       ->\n            let! _, locs      = fsv  |> View.GetAsync\n            let   locsm,  _   = locs |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n            match locsm      |> Seq.tryFind (fun (_,l) -> l.location = lc) with\n            | None           -> () \n            | Some(from, loc)->\n            let  word         = REGEX.getStartWord txt col\n            printfn \"getHints '%s' <= %d :%s => \" word col txt\n            let  lf           = line + 1 + from\n            let  cf           = col  + 1 + loc.indent\n            let! com          = autoCompleteClient.Complete(parseFile, String.replicate loc.indent \" \" + txt, lf, cf)\n            let  hints        = com  |> Array.map (fun (dis, rep, cls, chr) -> rep, (sprintf \"%-40s %20s\" dis (getSymbolType chr)), cls)\n            showHints hints (line, col - word.Length) (line, col)\n        } |> Async.Start //asyncStartDelayed\n\n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"466e6783-0751-48d5-b79b-165aaa7d2173"}, {"SnippetId" :"5397c4a9-f60a-448c-9c2a-0e06e85289d2"}, {"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"d785002c-20f8-4fa2-8838-cf29f59b2af8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d07d7f13-3a1f-40fa-8515-29c1446b285e"}, "snpName": "Serializer", "snpContent": "module Serializer =\n    open Serializer\n        \n    let serAttId      = serId (fun (AttId      v) -> v) AttId      (sprintf \"%A\")     \n    let serElmId      = serId (fun (ElmId      v) -> v) ElmId      (sprintf \"%A\")     \n    let serDimId      = serId (fun (DimId      v) -> v) DimId      (sprintf \"%A\")     \n    let serCalId      = serId (fun (CalId      v) -> v) CalId      (sprintf \"%A\")     \n    let serTotId      = serId (fun (TotId      v) -> v) TotId      (sprintf \"%A\")     \n    let serForId      = serId (fun (ForId      v) -> v) ForId      (sprintf \"%A\")     \n    let serRulId      = serId (fun (RulId      v) -> v) RulId      (sprintf \"%A\")\n    let serCubId      = serId (fun (CubId      v) -> v) CubId      (sprintf \"%A\")     \n    let serTreeNodeId = serId (fun (TreeNodeId v) -> v) TreeNodeId (sprintf \"%A\")     \n\n    let serDimType  : Ser<DimType > = (sprintf \"\\\"%A\\\"\"), unbox >> function\n                                                                   | \"DtDataType\"      -> DtDataType      \n                                                                   | \"DtTime\"          -> DtTime      \n                                                                   | \"DtVersion\"       -> DtVersion      \n                                                                   | \"DtTCalc\"         -> DtTCalc      \n                                                                   | \"DtCalc\"          -> DtCalc      \n                                                                   | \"DtMeasure\"       -> DtMeasure      \n                                                                   | _                 -> DtOther\n    let serWeight   : Ser<Weight  > = (sprintf \"\\\"%A\\\"\"), unbox >> function     \n                                                        | \"Add\"             -> Add      \n                                                        | \"Subtract\"        -> Subtract      \n                                                        | _                 -> Zero\n    let serAttType  : Ser<AttType > = (sprintf \"\\\"%A\\\"\"), unbox >> function     \n                                                        | \"AtNumber\"        -> AtNumber\n                                                        | _                 -> AtString\n    let serElmType  : Ser<ElmType > = (sprintf \"\\\"%A\\\"\"), unbox >> function     \n                                                        | \"EtNumber\"        -> EtNumber\n                                                        | _                 -> EtString\n    let serForType  : Ser<ForType > = (sprintf \"\\\"%A\\\"\"), unbox >> function \n                                                        | \"ForBase\"         -> ForBase  \n                                                        | \"ForConsolidated\" -> ForConsolidated \n                                                        | _                 -> ForAll\n    let serCubeType : Ser<CubeType> = (sprintf \"\\\"%A\\\"\"), unbox >> function\n                                                        | \"CtCalc\"          -> CtCalc\n                                                        | \"CtFreeze\"        -> CtFreeze\n                                                        | _                 -> CtOther\n\n    let serNodeId   : Ser<NodeId  > = function\n                                      | Calc cid -> fst serCalId cid\n                                      | Tot  tid -> fst serTotId tid\n                                     ,                  function\n                                                        | Exists \"CalId\" v -> CalId v |> Calc\n                                                        | Exists \"TotId\" v -> TotId v |> Tot\n                                                        | _                -> CalId System.Guid.Empty |> Calc\n    \n    let serRuleKey : Ser<RuleKey  > =(function\n                                      | RuleKey         rid -> \"RuleKey\"              , fst serRulId rid\n                                      | CalcRuleKey     cid -> \"CalcRuleKey\"          , fst serCalId cid\n                                      | FormulaKey      fid -> \"FormulaKey\"           , fst serForId fid\n                                      | ForTextKey      fid -> \"ForTextKey\"           , fst serForId fid\n                                      | ActualRuleKey       -> \"ActualRuleKey\"        , \"1\"\n                                      | InputRuleKey        -> \"InputRuleKey\"         , \"1\"\n                                      | ConsolidatedRuleKey -> \"ConsolidatedRuleKey\"  , \"1\"\n                                      >> (fun (n, v) -> sprintf \"{%A: %s}\" n v))\n                                         ,                  function\n                                                            | Exists \"RuleKey\"             v -> snd serRulId v |> RuleKey \n                                                            | Exists \"CalcRuleKey\"         v -> snd serCalId v |> CalcRuleKey \n                                                            | Exists \"FormulaKey\"          v -> snd serForId v |> FormulaKey \n                                                            | Exists \"ForTextKey\"          v -> snd serForId v |> ForTextKey \n                                                            | Exists \"ActualRuleKey\"       v ->                   ActualRuleKey      \n                                                            | Exists \"InputRuleKey\"        v ->                   InputRuleKey       \n                                                            | Exists \"ConsolidatedRuleKey\" v ->                   ConsolidatedRuleKey\n                                                            | _                              -> RulId System.Guid.Empty |> RuleKey\n    \n//    let serElmReference  : Ser<ElmReference > = (fun _ -> \"\"), (fun _ -> (null |> snd serDimId , ExtStet) |> ElemDynamic)\n//    let serExpressionAny : Ser<ExpressionAny> = (fun _ -> \"\"), (fun _ -> ExiStet)\n    \n    let serAttribute : Ser<Attribute> =\n        [|\n            serAttId                                            |> serField \"attId\"          (fun a -> a.attId         ) (fun v a -> { a with attId          = v } )\n            serString                                           |> serField \"attName\"        (fun a -> a.attName       ) (fun v a -> { a with attName        = v } )\n            serInt                                              |> serField \"attTableNum\"    (fun a -> a.attTableNum   ) (fun v a -> { a with attTableNum    = v } )\n            serAttType                                          |> serField \"attType\"        (fun a -> a.attType       ) (fun v a -> { a with attType        = v } )\n        |] |> serRecord (Attribute.New())\n    \n    let serElement   : Ser<Element  > = \n        [|\n            serElmId                                            |> serField \"elmId\"          (fun e -> e.elmId         ) (fun v e -> { e with elmId          = v } )\n            serDimId                                            |> serField \"elmDim\"         (fun e -> e.elmDim        ) (fun v e -> { e with elmDim         = v } )\n            serElmType                                          |> serField \"elmType\"        (fun e -> e.elmType       ) (fun v e -> { e with elmType        = v } )\n            serString                                           |> serField \"elmName\"        (fun e -> e.elmName       ) (fun v e -> { e with elmName        = v } )\n            serString                                           |> serField \"elmDescription\" (fun e -> e.elmDescription) (fun v e -> { e with elmDescription = v } )\n            serString                        |> serMap serAttId |> serField \"elmAttributes\"  (fun e -> e.elmAttributes ) (fun v e -> { e with elmAttributes  = v } )\n            serElmId                                  |> serArr |> serField \"elmParents\"     (fun e -> e.elmParents    ) (fun v e -> { e with elmParents     = v } )\n        |] |> serRecord (Element.newElement \"\")\n    \n    let serDimension     : Ser<Dimension    > =\n        [|\n            serDimId                                            |> serField \"dimId\"          (fun d -> d.dimId         ) (fun v d -> { d with dimId          = v } )\n            serString                                           |> serField \"dimName\"        (fun d -> d.dimName       ) (fun v d -> { d with dimName        = v } )\n            serString                                           |> serField \"dimPrefix\"      (fun d -> d.dimPrefix     ) (fun v d -> { d with dimPrefix      = v } )\n            serString                                           |> serField \"dimOrder\"       (fun d -> d.dimOrder      ) (fun v d -> { d with dimOrder       = v } )\n            serBool                                             |> serField \"dimExclude\"     (fun d -> d.dimExclude    ) (fun v d -> { d with dimExclude     = v } )\n            serBool                                             |> serField \"dimFreeze\"      (fun d -> d.dimFreeze     ) (fun v d -> { d with dimFreeze      = v } )\n            serBool                                             |> serField \"isCalcDim\"      (fun d -> d.isCalcDim     ) (fun v d -> { d with isCalcDim      = v } )\n            serDimType                                          |> serField \"dimType\"        (fun d -> d.dimType       ) (fun v d -> { d with dimType        = v } )\n            serAttribute                              |> serArr |> serField \"dimAttributes\"  (fun d -> d.dimAttributes ) (fun v d -> { d with dimAttributes  = v } )\n            serElmId                                  |> serOpt |> serField \"defaultElm\"     (fun d -> d.defaultElm    ) (fun v d -> { d with defaultElm     = v } )\n            serElement                                |> serArr |> serField \"dimElements\"    (fun d -> d.dimElements   ) (fun v d -> { d with dimElements    = v } )\n        |] |> serRecord (Dimension.New \"\")\n\n    let serFormula       : Ser<Formula> =\n        [|\n            serForId                                            |> serField \"forId\"          (fun f -> f.forId         ) (fun v f -> { f with forId          = v } )\n            serString                        |> serMap serDimId |> serField \"forDestDecl\"    (fun f -> f.forDestDecl   ) (fun v f -> { f with forDestDecl    = v } )             \n            serString                                           |> serField \"forDescription\" (fun f -> f.forDescription) (fun v f -> { f with forDescription = v } ) \n            serString                                           |> serField \"forText\"        (fun f -> f.forText       ) (fun v f -> { f with forText        = v } ) \n            serForType                                          |> serField \"forType\"        (fun f -> f.forType       ) (fun v f -> { f with forType        = v } )  \n            serString                                           |> serField \"forOrder\"       (fun f -> f.forOrder      ) (fun v f -> { f with forOrder       = v } ) \n//          serElmReference                           |> serLst |> serField \"forDestination\" (fun f -> f.forDestination) (fun v f -> { f with forDestination = v } )            \n//          serExpressionAny                                    |> serField \"forExpression\"  (fun f -> f.forExpression ) (fun v f -> { f with forExpression  = v } )        \n        |] |> serRecord (Formula.New())\n\n    let serCalculation   : Ser<Calculation > =\n        [|\n            serCalId                                            |> serField \"calId\"          (fun c -> c.calId         ) (fun v c -> { c with calId          = v } )\n            serString                                           |> serField \"calName\"        (fun c -> c.calName       ) (fun v c -> { c with calName        = v } )\n            serString                                           |> serField \"calDescription\" (fun c -> c.calDescription) (fun v c -> { c with calDescription = v } )\n            serString                                           |> serField \"calOrder\"       (fun c -> c.calOrder      ) (fun v c -> { c with calOrder       = v } )\n            serString                                           |> serField \"format\"         (fun c -> c.format        ) (fun v c -> { c with format         = v } )\n            serBool                                             |> serField \"isText\"         (fun c -> c.isText        ) (fun v c -> { c with isText         = v } )\n            serBool                                             |> serField \"isInput\"        (fun c -> c.isInput       ) (fun v c -> { c with isInput        = v } )\n            serBool                                             |> serField \"isBalance\"      (fun c -> c.isBalance     ) (fun v c -> { c with isBalance      = v } )\n            serDimId                                  |> serSet |> serField \"calDims\"        (fun c -> c.calDims       ) (fun v c -> { c with calDims        = v } )\n            serFormula                                |> serArr |> serField \"calFormulas\"    (fun c -> c.calFormulas   ) (fun v c -> { c with calFormulas    = v } )\n            serCubId                                  |> serOpt |> serField \"cubIdO\"         (fun c -> c.cubIdO        ) (fun v c -> { c with cubIdO         = v } )\n            serString                       |> serMap serString |> serField \"properties\"     (fun c -> c.properties    ) (fun v c -> { c with properties     = v } )\n        |] |> serRecord (Calculation.New())\n    \n    let serTotal : Ser<Total> =\n        [|\n            serTotId                                            |> serField \"totId\"          (fun t -> t.totId         ) (fun v t -> { t with totId          = v } )\n            serString                                           |> serField \"totName\"        (fun t -> t.totName       ) (fun v t -> { t with totName        = v } )\n            serString                                           |> serField \"totOrder\"       (fun t -> t.totOrder      ) (fun v t -> { t with totOrder       = v } )\n            serString                                           |> serField \"totFormat\"      (fun t -> t.totFormat     ) (fun v t -> { t with totFormat      = v } )\n            serDup serFloat serNodeId                 |> serArr |> serField \"children\"       (fun t -> t.children      ) (fun v t -> { t with children       = v } )\n        |] |> serRecord (Total.New())\n\n    let serRule : Ser<Rule> =\n        [|\n            serRulId                                            |> serField \"rulId\"          (fun t -> t.rulId         ) (fun v t -> { t with rulId          = v } )\n            serString                                           |> serField \"rulDescription\" (fun t -> t.rulDescription) (fun v t -> { t with rulDescription = v } )\n            serForType                                          |> serField \"rulType\"        (fun t -> t.rulType       ) (fun v t -> { t with rulType        = v } )\n            serString                                           |> serField \"rulOrder\"       (fun t -> t.rulOrder      ) (fun v t -> { t with rulOrder       = v } )\n//          serIComparable                                      |> serField \"rulSourceId\"    (fun t -> t.rulSourceId   ) (fun v t -> { t with rulSourceId    = v } )\n//          serElmReference                           |> serLst |> serField \"rulDestination\" (fun t -> t.rulDestination) (fun v t -> { t with rulDestination = v } )\n//          serExpressionAny                                    |> serField \"rulExpression\"  (fun t -> t.rulExpression ) (fun v t -> { t with rulExpression  = v } )\n        |] |> serRecord (Rule.New())\n\n    let serCube : Ser<Cube> =\n        [|\n            serCubId                                            |> serField \"cubId\"          (fun t -> t.cubId         ) (fun v t -> { t with cubId          = v } )\n            serString                                           |> serField \"cubName\"        (fun t -> t.cubName       ) (fun v t -> { t with cubName        = v } )\n            serRule              |> serOpt |> serMap serRuleKey |> serField \"cubRules\"       (fun t -> t.cubRules      ) (fun v t -> { t with cubRules       = v } )\n            serString                      |> serMap serRuleKey |> serField \"cubRuleXmls\"    (fun t -> t.cubRuleXmls   ) (fun v t -> { t with cubRuleXmls    = v } )\n            serDimId                                  |> serArr |> serField \"cubDims\"        (fun t -> t.cubDims       ) (fun v t -> { t with cubDims        = v } )\n            serDimId                                  |> serOpt |> serField \"measureDim\"     (fun t -> t.measureDim    ) (fun v t -> { t with measureDim     = v } )\n            serCubeType                                         |> serField \"cubType\"        (fun t -> t.cubType       ) (fun v t -> { t with cubType        = v } )\n        |] |> serRecord (Cube.New())\n    \n    let mutable serTreeNodeR : Ser<TreeNode> = (fun _ -> \"\"), (fun _ -> TreeNode.newNodeTot (TotId System.Guid.Empty))\n    let serTreeNode : Ser<TreeNode> = \n        [|\n            serTreeNodeId                                       |> serField \"nid\"            (fun t -> t.nid           ) (fun v t -> { t with nid            = v } )      \n            serBool                                             |> serField \"expanded\"       (fun t -> t.expanded      ) (fun v t -> { t with expanded       = v } )      \n            serNodeId                                           |> serField \"element\"        (fun t -> t.element       ) (fun v t -> { t with element        = v } )      \n            serTreeNodeR                              |> serArr |> serField \"children\"       (fun t -> t.children      ) (fun v t -> { t with children       = v } )      \n            serWeight                                           |> serField \"weight\"         (fun t -> t.weight        ) (fun v t -> { t with weight         = v } )      \n        |] |> serRecord (TreeNode.newNodeTot (TotId System.Guid.Empty))\n    do serTreeNodeR <- serTreeNode\n    \n    let serModelUI model : Ser<ModelUI> =\n        [|\n            serTreeNode                               |> serArr |> serVarField \"treeHierarchy\" (fun m -> m.treeHierarchy)\n            serCalculation                                      |> serLMdField \"calculations\"  (fun m -> m.calculations )\n            serTotal                                            |> serLMdField \"totals\"        (fun m -> m.totals       )\n            serDimension                                        |> serLMdField \"dimensions\"    (fun m -> m.dimensions   )\n            serCube                                             |> serLMdField \"cubes\"         (fun m -> m.cubes        )\n            serString                                           |> serVarField \"globalDefs\"    (fun m -> m.globalDefs   )\n            serString                                           |> serVarField \"server\"        (fun m -> m.server       )\n            serDup serTreeNodeId (serForId |> serOpt) |> serOpt |> serVarField \"selection\"     (fun m -> m.selection    )\n            serDimId                                  |> serOpt |> serVarField \"selectedDim\"   (fun m -> m.selectedDim  )\n            serCubId                                  |> serOpt |> serVarField \"selectedCube\"  (fun m -> m.selectedCube )\n            serDup serTotId      (serTotId |> serLst)           |> serLMdField \"collapsed\"     (fun m -> m.collapsed    )\n            serString                                           |> serVarField \"cubePrefix\"    (fun m -> m.cubePrefix   )\n            serString                                           |> serVarField \"measurePrefix\" (fun m -> m.measurePrefix)\n            serString                                           |> serVarField \"outputMsgs\"    (fun m -> m.outputMsgs   )\n            serString                                           |> serVarField \"codeFS\"        (fun m -> m.codeFS       )\n            serString                                           |> serVarField \"parserMsgs\"    (fun m -> m.parserMsgs   )\n        |] |> serRecord model    \n        ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}, {"SnippetId" :"ba3c73e8-9fe3-413e-86d8-edadb1d77d08"}, {"SnippetId" :"d785002c-20f8-4fa2-8838-cf29f59b2af8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f548880a-16c2-4993-9f7f-cc0ff5d814fb"}, "snpName": "SaveLoad", "snpContent": "module SaveLoad =\n#r \"../packages/FSharp.Data/lib/net45/FSharp.Data.dll\"\n\n    open FSharp.Data\n    open Several\n\n    [< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\n    let saveAs (_name:string) (_txt:string) = ()\n    \n    let dirty          = Var.Create     false\n    let setDirty()     = dirty.Value <- true       \n    let setClean()     = dirty.Value <- false\n    \n    let justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n    \n    let fileName  = Var.Create \"\"\n    let emptyFile = View.Map ((=) \"\") fileName.View\n\n    let loadTextFile element (f: string -> unit) =\n        let files = element |> FileList.OfElement \n        if files.Length > 0 then\n            let  reader  = TextFileReader()\n            reader.Onload <- (fun e -> f e.Target?result)\n            let  file = files.[0]\n            model.fileName.Set file.Name\n            reader.ReadAsText  file\n\n    let reorder() =\n        let rec folder (children, noparent, calcs, tots) (n:Tree.Node<_>) =\n            match (n :?> TreeNode).element with\n            | Tot  tid -> let ch, np, c2, t2 = n.children |> Seq.fold folder ([], noparent, calcs, tots)\n                          let ch2 = List.rev ch\n                          if model.totals      .ContainsKey tid then (n.newChildren ch2 :: children,      np      ,        c2   , tid :: t2  )\n                                                                else (                     children, ch @ np      ,        c2   ,        t2  )\n            | Calc cid -> if model.calculations.ContainsKey cid then (n                 :: children,      noparent, cid :: calcs,        tots)\n                                                                else (                     children,      noparent,        calcs,        tots)\n        parents.Clear()\n        let nodes, noparent, calcs, tots = model.treeHierarchy.Value |> Seq.fold folder ([], [], [], [])\n        [\n            nodes    |> Seq.rev      |> TreeNode.fromSeqNode\n            noparent |> Seq.rev      |> TreeNode.fromSeqNode\n            model.calculations.Value |> Seq.map (fun c -> c.calId) |> Seq.except calcs |> Seq.map TreeNode.newNodeCalc |> Seq.toArray\n            model.totals      .Value |> Seq.map (fun t -> t.totId) |> Seq.except tots  |> Seq.map TreeNode.newNodeTot  |> Seq.toArray\n        ]\n        |> Seq.collect id\n        |> Seq.toArray\n        |> model.treeHierarchy.Set\n\n\n    let parseText txt =\n        try\n            txt\n            |> Json.Parse\n            |> snd (Serializer.serModelUI Global.model)\n            |> ignore\n            reorder()\n    //        refreshView()\n        with e -> JS.Alert <| e.ToString()\n                  printfn \"%A\" e\n    \n    let fileInputElementId = \"RuleEditorFileSel\"\n    let loadFile (e: Dom.Element) =\n        if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n          let root = findRootElement e\n          loadTextFile \n              <| root.QuerySelector(\"#\" + fileInputElementId)\n              <| parseText\n    \n    let saveAsFile() = // Save as...\n        let name = match justFileName fileName.Value with \n                   | \"\"    -> \"rules.json\" \n                   | fname -> fname\n        model.outputMsgs.Set \"\"\n        model.parserMsgs.Set \"\"\n        model\n        |> fst (Serializer.serModelUI Global.model)\n        |> saveAs name\n        setClean()\n        ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"d07d7f13-3a1f-40fa-8515-29c1446b285e"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f93aecc9-fe1b-4f9a-b7a6-256ae106bc08"}, "snpName": "GetRules", "snpContent": "module GetRules =\n    open Useful\n    open CalculationModel.CalculationModel\n    \n    let nameRuleEditor  = \"RuleEditor\"\n    let messagingClient = new WSMessagingBroker.WSMessagingClient(\"RuleEditor\")\n    let destAddress     = WSMessagingBroker.Address \"CalculationModel\"\n    messagingClient.ProcessIncoming (fun msg -> wrap {\n        match msg with \n        | FsStationShared.RunActionCall(_,a, [| _ ; t |]) when a = \"actOutText\" \n                   -> appendMsgs t \n        | _ as msg -> appendMsgs <| sprintf \"%A\" msg\n        return FsStationShared.StringResponseR (Some \"Ok\", [||])\n    })\n    \n    let calcDllPresence    = \"CalculationModel.dll\"\n    let definitionPresence = \"ModelDefinition\"\n    let evalConfig         = \"\"\n    let eval str           = FsEvaluator.evaluateW nameRuleEditor \"\" true str |> Wrap.map ignore\n        \n    let initFSICode() = wrap {\n            let!  presence = FsEvaluator.Evaluator.getPresence evalConfig calcDllPresence\n            match presence with\n            | None -> appendMsgs \"Initializing FSI\"\n                      let action = WSMessagingBroker.extractEndPoint()\n                                   |> sprintf \n                                      \"\"\"\n                                        #r @\"..\\CalculationModelDll\\CalculationModelDll.dll\"\n                                        open FSSGlobal.CalculationModel\n                                        Messaging.setEndPoint \"%s/ws\"\n                                      \"\"\"\n                                   |> String.unindentStr\n                      do! eval action\n                      do! FsEvaluator.Evaluator.addPresence calcDllPresence \"v1\"\n            | _ -> ()\n        }\n        \n\n    let sendDefinition() = wrap {\n        do!  initFSICode()\n        appendMsgs \"Processing definition...\"\n        let! codeLoc = FSCode.fsCode () |> View.GetAsync\n        let  code    = fst codeLoc + \"\\n    CalcRules.addModelRules initModel |> setInitModel\"\n        do!  eval code\n        do!  FsEvaluator.Evaluator.addPresence definitionPresence model.fileName.Value\n    }\n\n    let getRuleCube cube =\n        wrap {\n                let  resW:Wrap<ReplyMsg> = RuleMsg.GetRulesForCube cube.cubId |> messagingClient.SendGetReply destAddress\n                let! res = resW\n                match res with\n                | ReplyInformation txt  -> appendMsgs txt\n                | ReplyRules       ruls -> model.cubes.Add { cube with cubRuleXmls = Map ruls }\n                                           sprintf \"Cube %30s, %4d rules translated \" cube.cubName ruls.Length |> appendMsgs \n        }\n\n    let getRules() =\n        wrap {\n            appendMsgs \"Getting rules...\"\n            for cube in model.cubes.Value do\n               do! getRuleCube cube\n        }\n\n    let createDimsCube cdims n =\n        model.cubes.Value\n        |> Seq.tryFind        (fun c  ->   c.cubDims = cdims    )\n        |> Option.map         (fun c  -> { c with cubName = n } )\n        |> Option.defaultWith (fun () -> Cube.newCube n cdims None CtCalc )\n        |> model.cubes.Add\n    \n    let createDimsCubeDef cdims =\n        let prefix   = model.cubePrefix.Value\n        let dims     = model.dimensions.Value |> Seq.filter (fun d -> Set.contains d.dimId cdims)\n        let nameBase =\n            dims\n            |> Seq.filter (fun d -> not d.dimExclude)\n            |> Seq.sortBy (fun d -> d.dimOrder  )\n            |> Seq.map    (fun d -> d.dimPrefix )\n            |> String.concat \"\" |> ((+) prefix)\n        model.cubes.Value\n        |> Seq.map    (fun c -> c.cubName)\n        |> Seq.choose (fun c -> \n            match c with\n            | n when n          = nameBase -> Some -1\n            | n when n.StartsWith nameBase -> n.Substring(nameBase.Length) |> parseInt\n            | _                            -> None\n        )\n        |>(function\n           | similar when Seq.isEmpty similar -> nameBase\n           | similar                          ->\n           similar\n           |> Seq.max\n           |> (+) 1\n           |> string\n           |> (+) nameBase\n          )\n        |> createDimsCube (dims |> Seq.map (fun d -> d.dimId) |> Seq.toArray )\n\n    let setCalcCubId() =\n        model.calculations.Value\n        |> Seq.toArray\n        |> Seq.map   (fun c -> c, model.cubes.TryFind (fun cub -> cub.cubDims |> Set = c.calDims) |> Option.map (fun cub -> cub.cubId) )\n        |> Seq.iter  (fun (c, cubIdO) -> if c.cubIdO <> cubIdO then model.calculations.Add { c with cubIdO = cubIdO })\n    \n    let createCubes() =\n        let cubeDims = model.cubes.Value    \n                       |> Seq.filter(fun c -> c.cubType = CtCalc) \n                       |> Seq.map   (fun c -> c.cubDims |> Set) \n                       |> Seq.toArray\n        model.calculations.Value\n        |> Seq.map      (fun c -> c.calDims)\n        |> Seq.distinct\n        |> Seq.filter   (swap Array.contains cubeDims >> not)\n        |> Seq.iter      createDimsCubeDef\n        setCalcCubId()\n    \n    let updateModel() = wrap {\n        model.version.Set <| Version.incrementMajor model.version.Value\n        model.outputMsgs.Set <| sprintf \"Updating Rules. V%d.%d\" model.version.Value.major model.version.Value.minor\n        do  createCubes()\n        do! sendDefinition()\n        do! getRules()\n    }\n     \n    let updateCalc() = wrap {\n        let! presence            = FsEvaluator.Evaluator.getPresence evalConfig definitionPresence \n        match presence with\n        | Some v when v = model.fileName.Value ->\n               let  nodes               = model.treeHierarchy.Value\n               let  selO                = model.selection    .Value\n               let  calcs               = model.calculations .Value\n               let! calc                = nodes \n                                          |> TreeNode.tryFindSelNode selO\n                                          |> Option.bind (fun node -> match node.element with Calc cid -> Some cid |_-> None)\n                                          |> Option.bind (fun cid  -> calcs |> Seq.tryFind (fun c -> c.calId = cid))    \n                                          |> Result.fromOption (errSimple \"Selected Calculation not found\") \n               model.version.Set <| Version.incrementMinor model.version.Value\n               do   model.outputMsgs.Set <| sprintf \"Updating %s. V%d.%d\" calc.calName model.version.Value.major model.version.Value.minor\n               do!  initFSICode()\n               let  calNameFixed        = FSCode.fixName calc.calName\n               do!  FSCode.fsCodeForCalc calc  + sprintf \"\\n    CalcRules.addCalcRules initModel %s.calId |> setInitModel\" calNameFixed |> eval\n               let  cubeO               = calc.cubIdO |> Option.bind model.cubes.TryFindByKey\n               let! cube                = cubeO |> Result.fromOption (errSimple \"No cube associated to calculation\")\n               do!  getRuleCube cube\n               return Some (cube.cubId |> model.cubes.FindByKey)\n        | _ -> do! updateModel()\n               return None\n    }\n        ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"5397c4a9-f60a-448c-9c2a-0e06e85289d2"}, {"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}, {"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3eeb4d2d-749b-4f9b-ae8e-85f2ae28f528"}, "snpName": "UpdateAlea", "snpContent": "module UpdateAlea =\n    module Alea = AleaAPI.Alea\n    open AleaAPI.AleaN\n    \n    [< Rpc >]\n    let importDimension txt desc server dim = \n      dimensionN {\n        use  temp1   = new UsefulDotNet.TempFileName()\n        System.IO.File.WriteAllText(temp1.Name, txt ) \n        use  temp2   = new UsefulDotNet.TempFileName()\n        return!        DimensionN.import temp1.Name temp2.Name  \"\\t\"  desc\n      } |> DimensionN.run server dim |> Wrap.toAsyncResult\n    \n    let createAttributeTable atTblN fields = dimensionN {\n        let! _r      = DimensionN.attTableDeleteR      atTblN  |> DimensionN.getResult\n        let! handle  = DimensionN.attTableCreateBeginR atTblN\n        let! handles = fields |> DimensionN.traverseM (fun fld -> FieldN.runD fld FieldN.fieldAddR)\n        let! commit  = handles|> HandleN.sequenceM |> HandleN.run DimensionN.createCommitR handle\n        return commit\n    }\n\n    let calcList flt =\n        model.calculations\n        |> Seq.filter flt\n        |> Seq.map    (fun c -> sprintf \"%s\\t%s\" (if c.isText then \"S\" else \"N\" ) c.calName)\n        |> String.concat \"\\n\"\n\n    let measureFields = [\n            Alea.Field.newField \"Type\"          1s \"Type\"       0s  10s 0s \n            Alea.Field.newField \"Format_String\" 1s \"Format\"     0s 254s 0s \n    ]\n    \n    let tCalcFields =\n        measureFields @ [\n            Alea.Field.newField \"Cube\"          1s \"Cube\"       0s  50s 0s \n            Alea.Field.newField \"FreezeCube\"    1s \"FreezeCube\" 0s  50s 0s \n            Alea.Field.newField \"User\"          1s \"User\"       0s  50s 0s \n        ]\n        \n    let getFldByDesc d fs = fs |> List.tryFind (fun (f:Alea.Field) -> f.fldDescription = d) |> Result.fromOption (ErrSimple (\"Attribute Field not found\", false)) |> Wrap.WResult\n\n    let createTCalcDimension = dimensionN {\n        let! serv, dim = DimensionN.serverDim\n        let! _r        = importDimension (calcList <| fun _ -> true) \"Model Calculations\" serv dim |> WAsyncR\n        let! _r        = createAttributeTable 1s tCalcFields\n        let! fCube     = getFldByDesc \"Cube\"     tCalcFields\n        let! fType     = getFldByDesc \"Type\"     tCalcFields\n        let! fFormat   = getFldByDesc \"Format\"   tCalcFields\n        for c in model.calculations do\n            let  typ   = if c.isInput then \"Input\" else \"Calc\"\n            let  cname = c.cubIdO |>  Option.bind model.cubes.TryFindByKey |> Option.map (fun c -> c.cubName)|> Option.defaultValue \"----\"\n            let! _r    = DimensionN.putValueR fCube    cname   c.calName\n            let! _r    = DimensionN.putValueR fType    typ     c.calName\n            let! _r    = DimensionN.putValueR fFormat c.format c.calName\n            ()\n    }\n\n    let isCalcCube (cub:Cube) (c:Calculation) = c.cubIdO = Some cub.cubId\n\n    let createMeasureDimension cub = dimensionN {\n        let! serv, dim = DimensionN.serverDim\n        let! _r        = importDimension (calcList (isCalcCube cub)) (\"Measures for \" + cub.cubName) serv dim |> WAsyncR\n        let! _r        = createAttributeTable 1s measureFields\n        let! fType     = getFldByDesc \"Type\"     measureFields\n        let! fFormat   = getFldByDesc \"Format\"   measureFields\n        for c in model.calculations.Value |> Seq.filter (isCalcCube cub) do\n            let typ    = if c.isInput then \"Input\" else \"Calc\"\n            let! _r    = DimensionN.putValueR fType    typ     c.calName\n            let! _r    = DimensionN.putValueR fFormat c.format c.calName\n            ()\n    }\n    \n    let updateCubeRules cube = cubeN {\n        appendMsgs <| sprintf \"Importing rules for Cube: %30s %8A\" cube.cubName cube.cubType\n        let xml = cube.cubRuleXmls \n                  |> Map.toSeq\n                  |> Seq.map   snd\n                  |> Seq.sort\n                  |> String.concat \"\"\n                  |> sprintf \"<Alea:Rules xmlns:Alea=\\\"http://www.misag.com\\\" Accelerated=\\\"false\\\" >%s</Alea:Rules>\"\n        return! CubeN.putRulesForcedR xml\n    }\n    \n    let createCube cub (meaDim:string) = cubeN {\n        let  dimNames  = seq {\n                             for did in cub.cubDims do\n                                 let dim = model.dimensions.FindByKey did\n                                 yield dim.dimName.ToUpper()\n                             yield     meaDim     .ToUpper()\n                         } |> Seq.toArray\n        let  dimsOlap  = dimNames          |> Array.map Alea.Dimension \n        let! currentDs = CubeN.dimensionsR |> CubeN.getResult\n        let  exists    = currentDs\n                         |> Result.map(\n                             Array.map (fun (Alea.Dimension dimOlap) -> dimOlap.ToUpper() )\n                             >> ((=) dimNames))\n                         |> Result.ifError false\n        if not exists then\n            let! _r    = CubeN.delete     |> CubeN.getResult\n            let! _r    = CubeN.create     <| dimsOlap\n            let! _r    = CubeN.setMeasure <| Alea.Dimension meaDim \n            ()\n    }\n    \n    let createDimensionAndCube cub = serverN {\n        let      dimName   = FSCode.dimMeasureName cub.cubName\n        do!      createMeasureDimension cub         |> DimensionN.runS (Alea.Dimension dimName)\n        do!      createCube             cub dimName |> CubeN     .runS (Alea.Cube  cub.cubName)\n        let! r = updateCubeRules        cub         |> CubeN     .runS (Alea.Cube  cub.cubName)\n        ()\n    }\n    \n    let createAleaCubes = serverN {\n        for cube in model.cubes do\n            if cube.cubType = CtCalc then\n                do! createDimensionAndCube cube\n    }\n\n    let updateModelN = serverN {\n        let tcalcDim = Alea.Dimension \"TCalc\"\n        do! createTCalcDimension |> DimensionN.runS tcalcDim\n        do! createAleaCubes \n    }\n    \n    let updateModel() =\n      wrap {\n        do! GetRules.updateModel()\n        let server = Alea.Server model.server.Value\n        do! updateModelN |> ServerN.run server\n        appendMsgs \"Finished!\"\n      }  |> Wrap.start appendMsgs\n        \n    let updateCalc() =\n      wrap {\n        let server = Alea.Server model.server.Value\n        let! cubO  = GetRules.updateCalc()\n        do!  match cubO with\n             | Some cube -> updateCubeRules cube |> CubeN.runS (Alea.Cube cube.cubName) |> ServerN.map ignore\n             | None      -> updateModelN \n             |> ServerN.run server\n        appendMsgs \"Finished!\"\n      } |> Wrap.start appendMsgs\n        \n        ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"5416e265-2418-4907-8810-4dc99bafe392"}, {"SnippetId" :"f93aecc9-fe1b-4f9a-b7a6-256ae106bc08"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpName": "module Render", "snpContent": "module Render =\n  // indented only 2 spaces because the inner snippets are indented 2 spaces\n  let scrollIntoView selW (e:Dom.Element) = selW |> View.Sink (fun s -> if s then e?scrollIntoViewIfNeeded()) \n  \n  //let selTotIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getTId)\n  //let selCalIdOV = model.treeHierarchy.View |> View.Map2 TreeNode.tryFindSelChild model.selection.View |> View.Map (Option.bind TreeNode.getCId)\n  //let selForIdOV =                                                                model.selection.View |> View.Map2 (Option.bind snd            )\n\n  //let lensForm getF view (calcV:Var<Calculation>) = \n  //    calcV |> Var.lensView\n  //               (fun c   -> c.calFormulas |> Seq.tryFind      getF |> Option.defaultValue ModelUI.nonFormula)\n  //               (fun c y -> c.calFormulas |> Seq.tryFindIndex getF |> Option.map (fun i -> { c with calFormulas = Array.replace i y c.calFormulas } )\n  //                                                                  |> Option.defaultValue c)\n  //               view\n\n  let mapDefW def = View.Map (Option.defaultValue def) \n\n  let currentCalcOW = View.Do {\n      let! nodes = model.treeHierarchy.View\n      let! selO  = model.selection    .View\n      let! calcs = model.calculations .View\n      return\n          nodes \n          |> TreeNode.tryFindSelNode selO\n          |> Option.bind (fun node -> match node.element with Calc cid -> Some cid |_-> None)\n          |> Option.bind (fun cid  -> calcs |> Seq.tryFind (fun c -> c.calId = cid))\n  }\n  let setCurrentCalc v = \n      async {\n          let! currCalcO = currentCalcOW |> View.GetAsync \n          if   currCalcO.IsNone then () else\n          model.calculations.Add v\n      } |> Async.Start\n  let currentCalcV  = Var.Make (mapDefW ModelUI.nonCalculation currentCalcOW ) setCurrentCalc\n  \n  //let currentCalcV  = ListModel.currentLens ModelUI.nonCalculation selCalIdOV model.calculations\n  //let currentFormV  = currentCalcV |> lensForm (fun f -> match model.selection.Value with Some(_, Some fid) -> fid = f.forId |_-> false) model.selection.View\n\n  let lensForm (calcV:Var<Calculation>) getFidO =\n      if not IsClient then ModelUI.nonFormulaV else\n      let calcFormsV = Lens calcV.V.calFormulas\n      let formOW = View.Do {\n          let! calc = calcV.View\n          return\n              getFidO()\n              |> Option.bind (fun fid -> \n                  if calc.calId = ModelUI.nonCalculation.calId then None else \n                  calc.calFormulas |> Seq.tryFind (fun f -> f.forId = fid) )\n      }\n      let setForm v = \n          async {\n              let! formO = formOW |> View.GetAsync \n              if   formO.IsNone then () else\n              calcFormsV.Value \n              |> Seq.tryFindIndex (fun f -> f.forId = v.forId)\n              |> Option.iter(fun i -> calcFormsV.Value <- calcFormsV.Value |> Array.replace i v)\n          } |> Async.Start\n      Var.Make (mapDefW ModelUI.nonFormula formOW) setForm\n  let currentFormV = lensForm currentCalcV (fun () -> model.selection.Value |> Option.bind snd)\n  \n  let calcTypeV (calcV:Var<Calculation>) = (Lens calcV.V.isInput).Lens (function true->\"Input\" |_->\"Calc\") (fun _ s -> match s with |\"Calc\" -> false | _ -> true) \n  let formTypeV (formV:Var<Formula    >) = (Lens formV.V.forType).Lens (fun t -> (sprintf \"%A\" t).[3..]  ) (fun _ s -> match s with |\"Base\" -> ForBase |\"Consolidated\" -> ForConsolidated | _ -> ForAll  ) \n  \n  let dtypes =   [ \n    DtDataType\n    DtTime\n    DtVersion\n    DtOther    ] \n\n\n  open WebSharper.UI.Html\n  ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"d5bccf9b-eef5-4c86-8485-44d06c81db80"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"894550e2-2af1-47dc-8201-6c9f7a10d6c0"}, "snpName": "tableCalculations", "snpContent": "let rowFormula (tnId:TreeNodeId) (calcV : Var<Calculation>) fid =\n    let cid      = calcV.Value.calId\n    let formsV   = Lens     calcV.V.calFormulas\n    let formV    = lensForm calcV (fun () -> Some fid) \n    let selFormW = V (ModelUI.isNodeFormSelected fid tnId model.selection.V)\n    let formForW = V (formV.V.forDestDecl \n                      |> Seq.map(fun f -> \n                          sprintf \"%s:%s\" \n                              (model.dimensions.View.V \n                               |> Seq.tryFind(fun d -> d.dimId = f.Key) \n                               |> function Some dim -> dim.dimName |_-> \"\") \n                              f.Value) \n                      |> String.concat \", \")\n    TemplateLib.FormulaRow()\n        .SelectedMark( ModelUI.selectedString \">\"        selFormW )\n        .Selected(     ModelUI.selectedString \"selected\" selFormW )\n        .FormulaFor(   formForW                                   )\n        .Formula(      Lens formV.V.forText                       )\n        .FormType(     formTypeV formV                            )\n        .Remove(       fun _  -> RemoveFormula  fid        |> processor                               )\n        .Select(       fun _  -> SelectFormNode(fid, tnId) |> processor                               )\n        .Drag(         fun ev ->    DragDrop.setDragForm cid formV.Value ; ev.Event.StopPropagation() )\n        .DragOver(     fun ev -> if DragDrop .isDragForm cid fid then      ev.Event.PreventDefault () )\n        .Drop(         fun ev -> do                                        ev.Event.PreventDefault ()\n                                 DragDrop.getDragFormO cid fid |> DragDrop.moveItemInListModel fid formsV Formula.forId )\n        .AfterRender(  scrollIntoView selFormW )\n        .Doc()\n        \nlet rowTreeNode (tnId:TreeNodeId, nid:NodeId, level:int) =\n    let depth             = sprintf \"%dem\" level\n    let isSelW            = V (ModelUI.isNodeSelected tnId model.selection.V)\n    let rowCalculation (calcV:Var<Calculation>) cid       =\n        let formsDoc      = V (calcV.V |> fun c -> c.calFormulas |> Seq.map Formula.forId) |> Doc.BindSeqCached (rowFormula tnId calcV)\n        TemplateLib.CalculationRow()\n            .SelectedMark( \"\" )\n            .Selected(     ModelUI.selectedString \"selected\" isSelW )\n            .Indent(       depth                            )\n            .CalcName(     Lens calcV.V.calName   )\n            .Format(       Lens calcV.V.format    )\n            .IsText(       Lens calcV.V.isText    )\n            .IsBalance(    Lens calcV.V.isBalance )\n            .OrderCalc(    Lens calcV.V.calOrder  )\n            .CalcType(     calcTypeV calcV        )\n            .Remove(       fun _ -> RemoveCalculation cid |> processor        )\n            .Select(       fun _ -> isSelW |> View.Get (fun s -> if not s then SelectNode tnId |> processor)  )\n            .Formulas(     formsDoc )\n            .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n            .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n            .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                     DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n            .AfterRender(  scrollIntoView isSelW )\n            .Doc()\n     \n    let rowTotal (totV:Var<Total>) tid =\n        let totV         = model.totals |> ListModel.lensDef ModelUI.nonTotal tid\n        let nodeW        = V (TreeNode.tryFindNode tnId model.treeHierarchy.V)\n        let markW        = V (nodeW.V |> Option.map (fun node -> if node.expanded then \"-\" else \"+\") |> Option.defaultValue \"*\")\n        TemplateLib.TotalRow()\n            .SelectedMark( markW                                           )\n            .Selected(     ModelUI.selectedString \"selected\" isSelW        )\n            .Indent(       depth                                           )\n            .TotName(      Lens totV.V.totName                             )\n            .Format(       Lens totV.V.totFormat                           )\n            .OrderTot(     Lens totV.V.totOrder                            )\n            .Remove(       fun _ -> RemoveTotal tid           |> processor )\n            .Select(       fun _ -> SelectNode  tnId          |> processor )\n            .Collapse(     fun _ -> nodeW |> View.Get (Option.iter (fun node -> (not node.expanded, node.nid) |> ExpandNode |> processor)) )\n            .Drag(         fun ev ->     DragDrop.setDragNode tnId            ; ev.Event.StopPropagation() )\n            .DragOver(     fun ev -> if (DragDrop.getDragNIdO tnId).IsSome then ev.Event.PreventDefault () )\n            .Drop(         fun ev -> do                                         ev.Event.PreventDefault () \n                                     DragDrop.getDragNIdO tnId |> Option.iter(fun fr -> MoveNode(true, fr, tnId) |> processor ) )\n            .AfterRender(  scrollIntoView isSelW )\n            .Doc()\n\n    match  nid with\n    | Calc cid -> rowCalculation (model.calculations |> ListModel.lensDef ModelUI.nonCalculation cid) cid\n    | Tot  tid -> rowTotal       (model.totals       |> ListModel.lensDef ModelUI.nonTotal       tid) tid\n    \nlet tableCalculations() =\n    TemplateLib.CalculationTable()\n        .TBody( \n            V (model.treeHierarchy.V\n               |> Seq.map Tree.toNode \n               |> Tree.listNodes 0 \n               |> (Seq.map (fun (tn,l) -> tn.Id, (TreeNode.fromNode tn).element, l) ) \n            )\n            |> Doc.BindSeqCached rowTreeNode\n         )\n        .Doc()\n", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [{"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"220c62de-5a4a-4297-a4ca-306fb9cf8987"}, "snpName": "details", "snpContent": "let details () =\n    let noCalcAttr             () = attr.disabledDynPred (V \"\") (V (currentCalcV.V.calId = ModelUI.nonCalculation.calId))\n    let noFormAttr             () = attr.disabledDynPred (V \"\") (V (currentFormV.V.forId = ModelUI.nonFormula    .forId))\n    let getAnnot                  = V (model.selection.V |> Option.bind snd |> CodeMirror.filterFormula model.parserMsgs.V) |> View.consistent\n    let showToolTips txt line col = currentFormV.View |> View.Get (fun frm -> ParseFS.showToolTips (FSCode.InFormula frm.forId)   txt line col)\n    let getHints   f txt line col = currentFormV.View |> View.Get (fun frm -> ParseFS.getHints     (FSCode.InFormula frm.forId) f txt line col)\n    let editor                    =\n        CodeMirror.codeMirrorRender \n            <| Lens currentFormV.V.forText\n            <| Some getAnnot\n            <| Some showToolTips\n            <| Some getHints\n    \n    TemplateLib.FormulaDetail()\n        .CalcName(    Lens currentCalcV.V.calName   )\n        .Format(      Lens currentCalcV.V.format    )\n        .IsText(      Lens currentCalcV.V.isText    )\n        .IsBalance(   Lens currentCalcV.V.isBalance )\n//        .AlsoActual(  Lens currentFormV.V.alsoActual)\n        .CalcType(    calcTypeV currentCalcV        )\n        .FormType(    formTypeV currentFormV        )\n        .Formula(     editor                        )\n        .DisableCalc1(noCalcAttr())\n        .DisableCalc2(noCalcAttr())\n        .DisableCalc3(noCalcAttr())\n        .DisableCalc4(noCalcAttr())\n        .DisableCalc5(noCalcAttr())\n        .DisableCalc6(noCalcAttr())\n        .DisableCalc7(noCalcAttr())\n        .DisableForm1(noFormAttr())\n        .DisableForm2(noFormAttr())\n        .AddFormula(  fun _ -> (V currentCalcV.V.calId) |> View.Get (AddFormula >> processor) )\n        .UpdateCalc(  fun _ -> UpdateAlea.updateCalc()  )\n        .Doc()\n    \n", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [{"SnippetId" :"1414242b-3301-4071-aa25-19c67f0b5bff"}, {"SnippetId" :"3eeb4d2d-749b-4f9b-ae8e-85f2ae28f528"}, {"SnippetId" :"4f58224f-d544-4472-b96d-66c274500e8a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"415cb30f-b920-4f3a-854e-ab9c1cb08429"}, "snpName": "tableDimensions", "snpContent": "let tableDimensions () =\n    TemplateLib.DimensionTable()\n      .TBody(\n          model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n              //let selDimW = V (model.selectedDim.V = Some did)\n              TemplateLib.DimensionRow()\n                  .Name(          Lens dimV.V.dimName       )\n                  .Abbreviation(  Lens dimV.V.dimPrefix     )\n                  .Order(         Lens dimV.V.dimOrder      )\n                  .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                  .ExcludeName(   Lens dimV.V.dimExclude    )\n                  .IncludeFreeze( Lens dimV.V.dimFreeze     )\n                  .Remove(        fun _ -> RemoveDimension did |> processor )\n                  .Select(        fun _ -> SelectDimension did |> processor )\n                  .Doc()        \n          )\n      )\n      .Doc()\n", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [{"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"63d1ea3a-f372-47bb-ae90-801036cd321f"}, "snpName": "dimsSelected", "snpContent": "let dimsSelected () =\n    let destV = Lens currentFormV.V.forDestDecl\n\n    let cubeBaseNameW  = View.Do {\n        let! prefix    = model.cubePrefix.View\n        let! dims      = model.dimensions.View\n        let  dimsSort  = dims     |> Dimension.filterSort dtypes\n        let  dimPrxs   = dimsSort |> Seq.map(fun d -> d.dimId, if d.dimExclude then \"\" else d.dimPrefix) |> Seq.toArray\n        let  dimIds    = dimPrxs  |> Array.map fst\n        let! cubes     = model.cubes     .View\n        let  cubeDims  = cubes    |> Seq.filter (fun c -> c.cubType = CtCalc) |> Seq.map(fun c -> c.cubDims |> Array.filter (swap Array.contains dimIds) |> Set , c) |> Seq.toArray\n        let! currCalc  = currentCalcV    .View\n        let  currDims  = currCalc.calDims\n        let  currCubeO = cubeDims |> Seq.tryFind(fst >> ((=) currDims)) |> Option.map snd\n        let  baseName  = if currCubeO.IsSome then \"\" else\n                         dimPrxs  |> Seq.choose (fun (did, pr) -> if Set.contains did currDims then Some pr else None)\n                                  |> String.concat \"\" |> ((+) prefix)\n        return currCubeO, baseName\n    }\n    let currCubeOW       = cubeBaseNameW |> View.Map  fst\n    let cubePlaceholderW = cubeBaseNameW |> View.Map  snd\n    let cubeNameW        = currCubeOW    |> View.Map (function Some cub -> cub.cubName |_-> \"\")\n    let setCubeName   (n:string) =\n        async { \n            let  nm = n.Trim()\n            let! currCubeO = currCubeOW |> View.GetAsync\n            match currCubeO with\n            | Some cube -> if nm = \"\" \n                           then RemoveCube  cube.cubId \n                           else RenameCube (cube.cubId , nm)\n            | None      -> if nm = \"\"\n                           then NoOp\n                           else AddCube    (nm, currentCalcV.Value.calDims)\n            |> processor\n        } |> Async.Start\n    TemplateLib.DimsSelected()\n        .CubeName(        Var.Make cubeNameW setCubeName)\n        .PossibleCubeName(cubePlaceholderW)\n        .TBody(\n            model.dimensions |> ListModel.docLensMapView (Dimension.filterSort dtypes) (fun did dimV ->\n                let destW     = View.Do {\n                    let!  currForm  = currentFormV.View\n                    match currForm.forDestDecl.TryFind did with\n                    | Some txt -> return txt\n                    | None     -> return \"\"\n                }\n                let setDest (v:string) =\n                    let t = v.Trim()\n                    if currentFormV.Value.forId = ModelUI.nonFormula.forId then () else\n                    destV.Value <- \n                        if  t = \"\" \n                        then destV.Value |> Map.remove did\n                        else destV.Value |> Map.add    did t\n                let dimCheckW = V (currentCalcV.V.calDims |> Seq.contains did)\n                let setCheck v = \n                    if v \n                    then    AddCalcDim(currentCalcV.Value.calId, did)\n                    else RemoveCalcDim(currentCalcV.Value.calId, did)\n                    |> processor\n                let visibFor = V(if currentFormV.V.forId <> ModelUI.nonFormula.forId && dimCheckW.V then \"\" else \"Hidden\")\n                TemplateLib.DimSelectedRow()\n                    .Dimension(      V dimV.V.dimName           )\n                    .DimensionCheck( Var.Make dimCheckW setCheck)\n                    .Destination(    Var.Make destW     setDest )\n                    .Hidden(         visibFor                   )\n                    .Doc()\n            )\n        )\n        .Doc()    \n", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"58d847ea-44e6-4693-9a6c-d07ccff802d6"}, "snpName": "globalDefs", "snpContent": "let globalDefs () =\n    let getAnnot = V (CodeMirror.filterGlobal model.parserMsgs.V) |> View.consistent\n    \n    CodeMirror.codeMirrorRender \n        <| model.globalDefs \n        <| Some getAnnot\n        <| Some (ParseFS.showToolTips FSCode.InGlobalDefs)\n        <| Some (ParseFS.getHints     FSCode.InGlobalDefs)\n", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [{"SnippetId" :"1414242b-3301-4071-aa25-19c67f0b5bff"}, {"SnippetId" :"4f58224f-d544-4472-b96d-66c274500e8a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e3b3ef34-f541-4fab-8e9a-c6e95ce753ab"}, "snpName": "TemplateLib.Layout", "snpContent": "let scrollToBottom (e:Dom.Element) (_:obj) = \n    async { \n        do! Async.Sleep 100\n        do  e.ScrollTop <- e.ScrollHeight\n    } |> Async.Start\n\nlet mainLayout() =\n    TemplateLib.Layout()\n        .CalculationTable( tableCalculations()                  )\n        .FormulaDetail(    details          ()                  )\n        .DimsSelected(     dimsSelected     ()                  )\n        .DimensionTable(   tableDimensions  ()                  )\n        .GlobalText(       globalDefs       ()                  )\n        .Server(           model.server                         )\n        .Output(           model.outputMsgs                     )\n        .FSCode(           model.codeFS                         )\n        .Parser(           model.parserMsgs                     )\n        .Filename(         model.fileName                       )\n        .AddCalculation(   fun _ -> AddCalculation |> processor )\n        .AddTotal(         fun _ -> AddTotal       |> processor )\n        .NewDimension(     fun _ -> AddDimension   |> processor )\n        .SaveAs(           fun _ -> SaveLoad.saveAsFile()       )\n        .LoadFileChanged(  fun e -> SaveLoad.loadFile e.Target  )\n        .LoadFileClear(    fun e -> e.Target?value <- \"\"        )\n        .UpdateRules(      fun _ -> UpdateAlea.updateModel()    )        \n        .IndentIn(         fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        .IndentOut(        fun _ -> model.selection.Value |> Option.map fst |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n    //    .Reorder(          fun _ -> reorder()                                    )\n        .JumpRef(ParseFS.jumpToRef)\n        .OutputAfterRender(fun e -> model.outputMsgs.View |> View.Sink (scrollToBottom e))\n        .Doc()\n    ", "snpParentIdO": {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, "snpPredIds": [{"SnippetId" :"1414242b-3301-4071-aa25-19c67f0b5bff"}, {"SnippetId" :"220c62de-5a4a-4297-a4ca-306fb9cf8987"}, {"SnippetId" :"3eeb4d2d-749b-4f9b-ae8e-85f2ae28f528"}, {"SnippetId" :"415cb30f-b920-4f3a-854e-ab9c1cb08429"}, {"SnippetId" :"5397c4a9-f60a-448c-9c2a-0e06e85289d2"}, {"SnippetId" :"58d847ea-44e6-4693-9a6c-d07ccff802d6"}, {"SnippetId" :"63d1ea3a-f372-47bb-ae90-801036cd321f"}, {"SnippetId" :"894550e2-2af1-47dc-8201-6c9f7a10d6c0"}, {"SnippetId" :"f548880a-16c2-4993-9f7f-cc0ff5d814fb"}, {"SnippetId" :"f93aecc9-fe1b-4f9a-b7a6-256ae106bc08"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f82d4870-b1f1-4379-b56a-78076d7b86d3"}, "snpName": "UpdateModelUI", "snpContent": "module UpdateModelUI =\n                                    \n    let rec updateModelR model msg = \n        let doForCalc cid f       = model.calculations.TryFindByKey cid |> Option.iter f\n        let doForForm cid fid f   = doForCalc cid <| fun c -> c.calFormulas |> Seq.tryFind(fun f -> f.forId = fid) |> Option.iter (f c)\n        let doForCube cid f       = model.cubes       .TryFindByKey cid |> Option.iter f\n        let setSelection sel      = if model.selection.Value = sel then false else\n                                    model.selection.Value   <- sel\n                                    true\n        let tryFindCalcForm fid   = model.calculations.Value |> Seq.tryFind(fun calc -> calc.calFormulas |> Seq.exists (fun f -> f.forId = fid))\n        match msg with\n        | AddCalculation         -> let n = Calculation.New()\n                                    model.calculations.Add n\n                                    let nn = TreeNode.newNodeCalc n.calId\n                                    model.treeHierarchy.Value\n                                    |> Array.append [| nn |]\n                                    |> model.treeHierarchy.Set\n                                    SelectNode  nn.nid |> updateModelR model\n        | AddTotal               -> let n = Total.New()\n                                    model.totals.Add n\n                                    let nn = TreeNode.newNodeTot  n.totId\n                                    model.treeHierarchy.Value\n                                    |> Array.append [| nn |]\n                                    |> model.treeHierarchy.Set\n                                    SelectNode  nn.nid |> updateModelR model\n        | AddFormula         cid -> if  cid = ModelUI.nonCalculation.calId then false else\n                                    let n = Formula.New()\n                                    model.calculations.TryFindByKey cid\n                                    |> Option.iter(fun calc -> { calc with calFormulas = Array.append calc.calFormulas [| n |] } |> model.calculations.Add)\n                                    model.treeHierarchy.Value \n                                    |> TreeNode.tryFindSelNode model.selection.Value\n                                    |> Option.map (fun nn -> SelectFormNode (n.forId, nn.nid ) |> updateModelR model)\n                                    |> Option.defaultValue true\n        | AddDimension           -> let n = Dimension.New \"\"\n                                    model.dimensions.Add n\n                                    SelectDimension n.dimId |> updateModelR model\n    //    | AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n    //                                true\n    ////    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n    ////                                    model.childrenRels.Value <- model.childrenRels.Value |> Map.add (tid, ch) we\n    ////                                    true\n    ////                                ) |> Option.defaultValue false\n    ////    | RemoveChild (tid, ch)  -> model.childrenRels.Value <- model.childrenRels.Value |> Map.remove (tid, ch)\n    ////                                true\n        | RemoveTotal        tid -> model.totals.RemoveByKey    tid\n                                    setSelection None |> ignore\n                                    model.treeHierarchy.Value \n                                    |> TreeNode.removeNodes (TreeNode.forTId ((=) tid)) \n                                    |> ModelUI.setHierarchy model\n                                    true\n        | RemoveCalculation  cid -> setSelection None |> ignore\n                                    model.calculations.RemoveByKey cid\n                                    model.totals.Value\n                                    |> Seq.choose (fun t -> \n                                        let eq, ne = t.children |> Array.partition (fun (_, nid) -> nid = Calc cid )\n                                        if eq.Length = 0 then None else\n                                        Some { t with children = ne }\n                                    )\n                                    |> Seq.iter model.totals.Add\n                                    model.treeHierarchy.Value \n                                    |> TreeNode.removeNodes (TreeNode.forCId ((=) cid)) \n                                    |> ModelUI.setHierarchy model\n                                    true\n        | RemoveFormula      fid -> tryFindCalcForm fid\n                                    |> Option.iter(fun calc -> { calc with calFormulas = calc.calFormulas |> Array.filter (fun f -> f.forId <> fid) } \n                                                               |> model.calculations.Add )\n                                    true\n        | RemoveDimension    did -> model.dimensions.RemoveByKey did\n                                    true\n    //    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n    //                                true\n        | SelectNode         nid -> (nid, None    ) |> Some |> setSelection\n        | ExpandNode    (ex, nid)-> let rec mapper finished (node:TreeNode) =\n                                        if finished             then node                       , true\n                                        elif node.nid = nid     then { node with expanded = ex }, true\n                                        else let ch, dn = node.children |> Seq.mapFold mapper false\n                                             { node with children = Seq.toArray ch }            , dn\n                                    model.treeHierarchy.Value \n                                    |> Seq.mapFold mapper false \n                                    |> fst\n                                    |> Seq.toArray\n                                    |> model.treeHierarchy.Set\n                                    true\n        | IndentNode   (iin, nid)-> let indent = if iin then Tree.indentNode else Tree.outdentNode\n                                    model.treeHierarchy.Value\n                                    |> TreeNode.tryFindNode nid\n                                    |> Option.iter(\n                                       Tree.toNode \n                                       >> swap indent (Tree.toSeqNode model.treeHierarchy.Value) \n                                       >> TreeNode.fromSeqNode \n                                       >> ModelUI.setHierarchy model)\n                                    true\n        | MoveNode(aft,fnid,tnid)-> Tree.moveToSibling2 aft fnid tnid (Tree.toSeqNode model.treeHierarchy.Value) \n                                    |> TreeNode.fromSeqNode \n                                    |> ModelUI.setHierarchy model\n                                    true\n        | SelectFormNode(fid,nid)-> (nid, Some fid) |> Some |> setSelection\n        | SelectTotal        tid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeTId tid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n        | SelectCalculation  cid -> model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid  |> Option.map (fun n -> n.nid, None    ) |> setSelection\n        | SelectFormula      fid -> tryFindCalcForm fid       |> Option.map(fun c -> c.calId) |> Option.bind(fun cid -> \n                                    model.treeHierarchy.Value |> TreeNode.tryFindNodeCId cid) |> Option.map (fun n -> n.nid, Some fid) |> setSelection\n        | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n                                    |> (fun s -> if s = model.selectedDim.Value then false else\n                                                 model.selectedDim.Value    <- s\n                                                 true)\n        | AddCalcDim   (cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.add    did }\n                                    false\n        | RemoveCalcDim(cid, did)-> doForCalc cid <| fun c -> model.calculations.Add { c with calDims = c.calDims |> Set.remove did }\n                                    false\n        | AddCube      (n, ds)   -> model.cubes.Add <| Cube.newCubeCalc n (ds |> Seq.toArray) None\n                                    false\n        | RemoveCube    cid      -> model.cubes.RemoveByKey cid\n                                    false\n        | RenameCube   (cid, n)  -> doForCube cid <| fun c -> model.cubes.Add { c with cubName = n }\n                                    false\n        | _ -> false\n\n    \n    let updateModel model msg = if updateModelR model msg then ModelUI.refreshNow()\n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"af5ca7ac-45c0-4c56-b1ba-3eccbb0f95f7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b49fc3c3-f6b4-4e2d-ab01-ad57df07cb42"}, "snpName": "init", "snpContent": "[< JavaScript >]\nmodule init =\n    open Global\n\n    let setGlobals txt = model.globalDefs.Value <- String.unindentStr txt\n  \n    let passAndPass f v =\n        f v\n        v\n    \n    let newDim n typ abb ord excName incFree =\n        Dimension.newDimension n false\n        |> fun d -> { d with dimPrefix  = abb     }\n        |> fun d -> { d with dimType    = typ     }\n        |> fun d -> { d with dimOrder   = ord     }\n        |> fun d -> { d with dimExclude = excName }\n        |> fun d -> { d with dimFreeze  = incFree }\n        |> passAndPass      model.dimensions.Append \n  \n    let newCalc n isInput ord isText isBalance (dims: Dimension seq) = \n        Calculation.New()\n        |> fun c -> { c with calName   = n         }\n        |> fun c -> { c with calOrder  = ord       }\n        |> fun c -> { c with isInput   = isInput   }\n        |> fun c -> { c with isText    = isText    }\n        |> fun c -> { c with isBalance = isBalance }\n        |> fun c -> { c with calDims   = dims |> Seq.map (fun d -> d.dimId) |> Set }\n        |> passAndPass  model.calculations.Append\n        \n    let (?) (dim:Dimension) elem = (dim.dimId, elem)\n    \n    let newForm (calc:Calculation) typR ord form refs =\n        Formula.New()\n        |> fun f -> { f with forType     = typR         }\n        |> fun f -> { f with forOrder    = ord          }\n        |> fun f -> { f with forText     = form         }\n        |> fun f -> { f with forDestDecl = refs |> Map  }\n        |> fun f -> { calc with calFormulas = Array.append calc.calFormulas [| f |] } |> model.calculations.Add\n  \n    if IsClient then\n      ()", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"988b02f5-9a47-4850-8fef-959cfbfc7d65"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4df0ca27-cb77-42d0-a1e0-f4887dabeaaa"}, "snpName": "Converted from CalcEditor", "snpContent": "    \n    setGlobals \"\"\"\n    let inline GetTime txt =  toExpT txt\n    let inline TT2 ref n = toExpN n |> ignore; ref\n    let ALL_SKU = Product?All_SKU\n    let PC      = Product?PC\n    let CP      = Product?CP\n    let SO      = Product?SO\n    \n    let inline INSRT(t1, t2, p) = toExpT t2 |> ignore; toExpN p |> ignore; toExpT t1\n    let inline STR(n1, n2, n3) = toExpN n2 |> ignore; toExpN n3 |> ignore; toExpN n1 |> ignore ; toExpT \"f\"\n    let inline NUMBR(t1) = toExpT t1 |> ignore; toExpN 4\n    let STET = ExnStet\n    let NAt  = ExtNA\n    let inline GETATTR(t1, t2, p, t3) = toExpT t2 |> ignore; toExpT t3 |> ignore; toExpN p |> ignore; toExpT t1\n    \n    let inline minus n = toExpN n\n    let ( ~- ) = minus\n    let inline plus n = toExpN n\n    let ( ~+ ) = plus\n    \n    module DE =\n        let inline INDEX(t1, t2) = toExpT t1 |> ignore; toExpT t2 |> ignore; toExpN 3\n        let inline PARENTNAME(t1, t2, n3) = toExpN n3 |> ignore; toExpT t1 |> ignore; toExpT t2\n        \"\"\"\n    \n    let Time = newDim \"Time\" DtOther \"TM\" \"10\" true true\n    let Version = newDim \"Version\" DtOther \"VE\" \"30\" true true\n    let DataType = newDim \"DataType\" DtOther \"DT\" \"35\" true false\n    let Customer = newDim \"Customer\" DtOther \"CU\" \"40\" false false\n    let Product = newDim \"Product\" DtOther \"PR\" \"50\" false false\n    \n    let BudgetStart = newCalc \"BudgetStart\" true \"A00\" true false [Version]\n    let AverageMonths = newCalc \"AverageMonths\" true \"A00\" true false [Version; DataType; Customer; Product]\n    let Current_Year = newCalc \"Current Year\" false \"A00a\" true false [Version]\n    let BudgetEnd = newCalc \"BudgetEnd\" true \"A00a\" true false [Version]\n    let IsActual = newCalc \"IsActual\" false \"A01\" false false [Time; Version]\n    let IsActual_Monthly = newCalc \"IsActual Monthly\" false \"A01b\" false false [Version]\n    let CVersionRef = newCalc \"CVersionRef\" true \"A02\" true false [Version]\n    let YOYVersionRef = newCalc \"YOYVersionRef\" true \"A02\" true false [Version]\n    let Discontinued_Period_Input = newCalc \"Discontinued Period Input\" true \"A02\" true false [Version; DataType; Customer; Product]\n    let TBudgetRefYear = newCalc \"TBudgetRefYear\" true \"A02\" true false [Version]\n    let Discontinued_Period = newCalc \"Discontinued Period\" true \"A02\" true false [Version; DataType; Customer; Product]\n    let DTimeRef = newCalc \"DTimeRef\" true \"A02\" true false [Version]\n    let ActualRef = newCalc \"ActualRef\" true \"A02\" true false [Version]\n    let CTimeRef = newCalc \"CTimeRef\" true \"A02\" true false [Version]\n    let TBudgetRef = newCalc \"TBudgetRef\" true \"A02\" true false [Version]\n    let DVersionRef = newCalc \"DVersionRef\" true \"A02\" true false [Version]\n    let IsDiscontinued = newCalc \"IsDiscontinued\" true \"A02\" true false [Time; Version; DataType; Customer; Product]\n    let UPTimeRef = newCalc \"UPTimeRef\" true \"A02\" true false [Version]\n    let zTimeRef = newCalc \"zTimeRef\" true \"A03\" true false [Version]\n    let zVersionRef = newCalc \"zVersionRef\" true \"A03\" true false [Version]\n    let Product_Basis = newCalc \"Product Basis\" true \"B00\" true false [Version; DataType; Customer; Product]\n    let Innovation_Allocation_Sales_Override = newCalc \"Innovation Allocation Sales Override\" true \"B00\" false false [Version; DataType; Customer; Product]\n    let Innovation_Allocation_Cases_Override = newCalc \"Innovation Allocation Cases Override\" true \"B00\" false false [Version; DataType; Customer; Product]\n    let Innovation_Allocation_Cases_Effective = newCalc \"Innovation Allocation Cases Effective\" true \"B00\" false false [Version; DataType; Customer; Product]\n    let Innovation_Allocation_Sales_Effective = newCalc \"Innovation Allocation Sales Effective\" true \"B00\" false false [Version; DataType; Customer; Product]\n    let Innovation_Allocation = newCalc \"Innovation Allocation\" true \"B00\" false false [Version; DataType; Customer; Product]\n    let Warehouse_Transfers_Inflation = newCalc \"Warehouse Transfers Inflation\" true \"B00i\" false false [Time; Version]\n    let Freight_Allowance_Inflation = newCalc \"Freight Allowance Inflation\" true \"B00i\" false false [Time; Version]\n    let Freight_Allowance_Seasonality = newCalc \"Freight Allowance Seasonality\" true \"B00i\" false false [Time; Version]\n    let Warehouse_Transfers_Seasonality = newCalc \"Warehouse Transfers Seasonality\" true \"B00i\" false false [Time; Version]\n    let Freight_Inflation = newCalc \"Freight Inflation\" true \"B00i\" false false [Time; Version]\n    let Freight_Seasonality = newCalc \"Freight Seasonality\" true \"B00i\" false false [Time; Version]\n    let Warehouse_Storage_Inflation = newCalc \"Warehouse Storage Inflation\" true \"B00i\" false false [Time; Version]\n    let Commission_Inflation = newCalc \"Commission Inflation\" true \"B00i\" false false [Time; Version]\n    let Warehouse_Storage_Seasonality = newCalc \"Warehouse Storage Seasonality\" true \"B00i\" false false [Time; Version]\n    let Commission_Rate = newCalc \"Commission Rate\" false \"B01\" false false [Time; Version; DataType; Customer; Product]\n    let Commission = newCalc \"Commission\" false \"B01\" false false [Time; Version; DataType; Customer; Product]\n    let Cases = newCalc \"Cases\" true \"B01\" false false [Time; Version; DataType; Customer; Product]\n    let Price = newCalc \"Price\" true \"B02\" false false [Time; Version; DataType; Customer; Product]\n    let Sales = newCalc \"Sales\" false \"B03\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Accum = newCalc \"Cases Accum\" false \"C01\" false false [Version; DataType; Customer; Product]\n    let Sales_3M = newCalc \"Sales 3M\" false \"C02\" false false [Version; DataType; Customer; Product]\n    let Price_3M = newCalc \"Price 3M\" false \"C03\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_3M = newCalc \"Commission 3M\" false \"C04\" false false [Version; DataType; Customer; Product]\n    let Commission_Rate_3M = newCalc \"Commission Rate 3M\" false \"C05\" false false [Version; DataType; Customer; Product]\n    let Commission_Rate_Base = newCalc \"Commission Rate Base\" true \"C06\" false false [Version; DataType; Customer; Product]\n    let Commission_Rate_Base_Month = newCalc \"Commission Rate Base Month\" false \"C06a\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Rate_Exception = newCalc \"Commission Rate Exception\" true \"C07\" true false [Time; Version; DataType; Customer; Product]\n    let CRE_Depth_Product = newCalc \"CRE Depth Product\" false \"C08\" false false [Time; Version; DataType; Customer; Product]\n    let CRE_Depth_Customer = newCalc \"CRE Depth Customer\" false \"C08\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Rate_Exception_2 = newCalc \"Commission Rate Exception 2\" true \"C09\" true false [Time; Version; DataType; Customer; Product]\n    let Commission_Rate_Base_Period = newCalc \"Commission Rate Base Period\" true \"C09a\" true false [Time; Version]\n    let Commission_Rate_Projected = newCalc \"Commission Rate Projected\" true \"C10\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Copy_No_Override = newCalc \"Commission Copy No Override\" true \"C11\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Adjustment_Flag = newCalc \"Commission Adjustment Flag\" true \"C11\" true false [Version; DataType; Customer; Product]\n    let Commission_Original_No_Override = newCalc \"Commission Original No Override\" true \"C11\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_New_Pct_Input = newCalc \"Commission New Pct Input\" true \"C11\" true false [Version; DataType; Customer; Product]\n    let Commission_Adjustment = newCalc \"Commission Adjustment\" true \"C11\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_No_Override = newCalc \"Commission No Override\" false \"C11\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Override = newCalc \"Commission Override\" false \"C11\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_Copy = newCalc \"Commission Copy\" false \"C12\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Buffer_New = newCalc \"Cases Buffer New\" true \"D00\" false false [Time; Version; DataType; Customer; Product]\n    let Sales_Input = newCalc \"Sales Input\" true \"D00\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Input = newCalc \"Cases Input\" true \"D00\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Buffer = newCalc \"Cases Buffer\" true \"D00\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Buffer_Dif = newCalc \"Cases Buffer Dif\" false \"D00a\" false false [Time; Version; DataType; Customer; Product]\n    let Price_Input = newCalc \"Price Input\" false \"D00b\" false false [Time; Version; DataType; Customer; Product]\n    let Customer_Parent = newCalc \"Customer Parent\" false \"D01\" true false [Version; DataType; Customer; Product]\n    let Product_Class_Exception_M = newCalc \"Product Class Exception M\" false \"D02\" true false [Time; Version; DataType; Customer; Product]\n    let Product_Class_Exception = newCalc \"Product Class Exception\" true \"D02\" true false [Version; DataType; Customer; Product]\n    let Product_Class = newCalc \"Product Class\" false \"D03\" true false [Version; DataType; Customer; Product]\n    let Product_Class_2 = newCalc \"Product Class 2\" false \"D03\" true false [Version; DataType; Customer; Product]\n    let Is_Exception = newCalc \"Is Exception\" false \"D03a\" false false [Version; DataType; Customer; Product]\n    let Allocation_Weight = newCalc \"Allocation Weight\" true \"D04\" false false [Version; DataType; Customer; Product]\n    let Cases_Proportion = newCalc \"Cases Proportion\" false \"D10\" false false [Version; DataType; Customer; Product]\n    let Cases_Projected = newCalc \"Cases Projected\" false \"E01\" false false [Time; Version; DataType; Customer; Product]\n    let Price_Projected = newCalc \"Price Projected\" false \"F01\" false false [Time; Version; DataType; Customer; Product]\n    let Pounds_per_case___Net = newCalc \"Pounds per case - Net\" true \"G00\" false false [Version; DataType; Product]\n    let Pounds_per_case___Gross = newCalc \"Pounds per case - Gross\" true \"G00\" false false [Version; DataType; Product]\n    let Pounds_Gross = newCalc \"Pounds Gross\" false \"G00a\" false false [Time; Version; DataType; Customer; Product]\n    let Pounds_Net = newCalc \"Pounds Net\" false \"G00a\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_per_pound_base = newCalc \"Freight per pound base\" true \"G01\" false false [Version; DataType; Customer; Product]\n    let Freight = newCalc \"Freight\" false \"G01\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_per_pound = newCalc \"Freight per pound\" false \"G01a\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Copy = newCalc \"Freight Copy\" true \"G01ax\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Original = newCalc \"Freight Original\" true \"G01ax\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Adjustment_Flag = newCalc \"Freight Adjustment Flag\" true \"G01ax\" true false [Version; DataType; Customer; Product]\n    let Freight_New_Pct_Input = newCalc \"Freight New Pct Input\" true \"G01ax\" true false [Version; DataType; Customer; Product]\n    let Freight_Adjustment = newCalc \"Freight Adjustment\" true \"G01ax\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_per_pound_base = newCalc \"Freight Allowance per pound base\" true \"G01b\" false false [Version; DataType; Customer; Product]\n    let Freight_Allowance = newCalc \"Freight Allowance\" false \"G01b\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_Adjustment_Flag = newCalc \"Freight Allowance Adjustment Flag\" true \"G01bx\" true false [Version; DataType; Customer; Product]\n    let Freight_Allowance_Copy = newCalc \"Freight Allowance Copy\" true \"G01bx\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_Original = newCalc \"Freight Allowance Original\" true \"G01bx\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_Adjustment = newCalc \"Freight Allowance Adjustment\" true \"G01bx\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_New_Pct_Input = newCalc \"Freight Allowance New Pct Input\" true \"G01bx\" true false [Version; DataType; Customer; Product]\n    let Freight_Allowance_per_pound = newCalc \"Freight Allowance per pound\" false \"G01c\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_per_pound = newCalc \"Warehouse Transfers per pound\" false \"G02\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_per_pound_base = newCalc \"Warehouse Transfers per pound base\" true \"G02\" false false [Version; DataType; Customer; Product]\n    let Warehouse_Transfers = newCalc \"Warehouse Transfers\" false \"G02\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_Original = newCalc \"Warehouse Transfers Original\" true \"G02x\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_Adjustment_Flag = newCalc \"Warehouse Transfers Adjustment Flag\" true \"G02x\" true false [Version; DataType; Customer; Product]\n    let Warehouse_Transfers_New_Pct_Input = newCalc \"Warehouse Transfers New Pct Input\" true \"G02x\" true false [Version; DataType; Customer; Product]\n    let Warehouse_Transfers_Adjustment = newCalc \"Warehouse Transfers Adjustment\" true \"G02x\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_Copy = newCalc \"Warehouse Transfers Copy\" true \"G02x\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage = newCalc \"Warehouse Storage\" false \"G03\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage_per_case_base = newCalc \"Warehouse Storage per case base\" true \"G03\" false false [Version; DataType; Customer; Product]\n    let Warehouse_Storage_per_case = newCalc \"Warehouse Storage per case\" false \"G03\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage_Adjustment = newCalc \"Warehouse Storage Adjustment\" true \"G03x\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage_Adjustment_Flag = newCalc \"Warehouse Storage Adjustment Flag\" true \"G03x\" true false [Version; DataType; Customer; Product]\n    let Warehouse_Storage_New_Pct_Input = newCalc \"Warehouse Storage New Pct Input\" true \"G03x\" true false [Version; DataType; Customer; Product]\n    let Warehouse_Storage_Copy = newCalc \"Warehouse Storage Copy\" true \"G03x\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage_Original = newCalc \"Warehouse Storage Original\" true \"G03x\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Pct_Input = newCalc \"Trade Pct Input\" true \"H00\" false false [Version; DataType; Customer; Product]\n    let Promotion = newCalc \"Promotion\" false \"H00\" false false [Time; Version; DataType; Customer; Product]\n    let Off_Invoice = newCalc \"Off Invoice\" false \"H00\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Input = newCalc \"Trade Input\" false \"H00a\" false false [Version; DataType; Customer; Product]\n    let Trade_Pct_Base_E = newCalc \"Trade Pct Base E\" true \"H01a\" false false [Version; DataType; Customer; Product]\n    let Trade_Base_Pre = newCalc \"Trade Base Pre\" false \"H01b\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Pct_Base_Pre = newCalc \"Trade Pct Base Pre\" false \"H01b\" false false [Version; DataType; Customer; Product]\n    let Trade_Actual = newCalc \"Trade Actual\" false \"H01d\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_YTD = newCalc \"Trade YTD\" true \"H01d\" false false [Version; DataType; Customer; Product]\n    let Sales_YTG = newCalc \"Sales YTG\" true \"H01d\" false false [Version; DataType; Customer; Product]\n    let Sales_FY = newCalc \"Sales FY\" true \"H01d\" false false [Version; DataType; Customer; Product]\n    let Trade_BOY = newCalc \"Trade BOY\" false \"H01e\" false false [Version; DataType; Customer; Product]\n    let Trade_Base = newCalc \"Trade Base\" false \"H01f\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Pct_Base = newCalc \"Trade Pct Base\" false \"H01f\" false false [Version; DataType; Customer; Product]\n    let Sales_YTG_Calc = newCalc \"Sales YTG Calc\" false \"H01f\" false false [Version; DataType; Customer; Product]\n    let Sales_FY_Calc = newCalc \"Sales FY Calc\" false \"H01f\" false false [Version; DataType; Customer; Product]\n    let Promotion_Split_Pct = newCalc \"Promotion Split Pct\" false \"H02\" false false [Version; DataType; Customer; Product]\n    let Trade_Override = newCalc \"Trade Override\" false \"H02\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Pct_Override_Input = newCalc \"Trade Pct Override Input\" true \"H02\" true false [Version; DataType; Customer; Product]\n    let Is_Trade_Override_Input = newCalc \"Is Trade Override Input\" true \"H02\" true false [Version; DataType; Customer; Product]\n    let Off_Invoice_Split_Pct = newCalc \"Off Invoice Split Pct\" false \"H02\" false false [Version; DataType; Customer; Product]\n    let Trade_Pct_Override = newCalc \"Trade Pct Override\" true \"H02\" false false [Version; DataType; Customer; Product]\n    let Is_Trade_Override = newCalc \"Is Trade Override\" true \"H02\" false false [Version; DataType; Customer; Product]\n    let Trade = newCalc \"Trade\" false \"H03\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_Pct = newCalc \"Trade Pct\" false \"H03\" false false [Version; DataType; Customer; Product]\n    let Trade_Pct_Transfer = newCalc \"Trade Pct Transfer\" false \"H03a\" false false [Version; DataType; Customer; Product]\n    let Trade_Pct_Calc = newCalc \"Trade Pct Calc\" false \"H04\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Basis = newCalc \"Cases Basis\" true \"M02\" false false [Version; DataType; Customer; Product]\n    let Is_Missing = newCalc \"Is Missing\" false \"N01\" false false [Time; Version; DataType; Customer; Product]\n    let Proportion_Exception = newCalc \"Proportion Exception\" false \"N02\" false false [Version; DataType; Customer; Product]\n    let Cases_No_Actual = newCalc \"Cases No Actual\" false \"O01\" false false [Time; Version; DataType; Customer; Product]\n    let Sales_No_Actual = newCalc \"Sales No Actual\" false \"O01b\" false false [Time; Version; DataType; Customer; Product]\n    let Sales_No_Actual_Calc = newCalc \"Sales No Actual Calc\" false \"O01b\" false false [Time; Version; DataType; Customer; Product]\n    let Cases_Input_No_Actual = newCalc \"Cases true No Actual\" false \"O02\" false false [Time; Version; DataType; Customer; Product]\n    let Sales_Input_No_Actual = newCalc \"Sales true No Actual\" false \"O03\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Storage_No_Actual = newCalc \"Warehouse Storage No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Promotion_No_Actual = newCalc \"Promotion No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Warehouse_Transfers_No_Actual = newCalc \"Warehouse Transfers No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Trade_No_Actual = newCalc \"Trade No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Off_Invoice_No_Actual = newCalc \"Off Invoice No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_Allowance_No_Actual = newCalc \"Freight Allowance No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Commission_No_Actual = newCalc \"Commission No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let Freight_No_Actual = newCalc \"Freight No Actual\" false \"O04\" false false [Time; Version; DataType; Customer; Product]\n    let zSales_CP_ALL_SKU = newCalc \"zSales-CP-ALL_SKU\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_ALL_SKU = newCalc \"zSales-ALL_SKU\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_PC = newCalc \"zSales-PC\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_SO_PC = newCalc \"zSales-SO-PC\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_SO_ALL_SKU = newCalc \"zSales-SO-ALL_SKU\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_CP = newCalc \"zSales-CP\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_CP_PC = newCalc \"zSales-CP-PC\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales = newCalc \"zSales\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zSales_SO = newCalc \"zSales-SO\" false \"Z00\" false false [Version; DataType; Customer; Product]\n    let zCommission_CP = newCalc \"zCommission-CP\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_ALL_SKU = newCalc \"zCommission-ALL_SKU\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_SO = newCalc \"zCommission-SO\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_SO_ALL_SKU = newCalc \"zCommission-SO-ALL_SKU\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_CP_PC = newCalc \"zCommission-CP-PC\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_CP_ALL_SKU = newCalc \"zCommission-CP-ALL_SKU\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_PC = newCalc \"zCommission-PC\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission = newCalc \"zCommission\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zCommission_SO_PC = newCalc \"zCommission-SO-PC\" false \"Z01\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_SO_PC = newCalc \"zPounds Net-SO-PC\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net = newCalc \"zPounds Net\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_CP_ALL_SKU = newCalc \"zPounds Net-CP-ALL_SKU\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_CP_PC = newCalc \"zPounds Net-CP-PC\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_SO_ALL_SKU = newCalc \"zPounds Net-SO-ALL_SKU\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_SO = newCalc \"zPounds Net-SO\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_ALL_SKU = newCalc \"zPounds Net-ALL_SKU\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_PC = newCalc \"zPounds Net-PC\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zPounds_Net_CP = newCalc \"zPounds Net-CP\" false \"Z02\" false false [Version; DataType; Customer; Product]\n    let zFreight_SO_PC = newCalc \"zFreight-SO-PC\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight = newCalc \"zFreight\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_CP_ALL_SKU = newCalc \"zFreight-CP-ALL_SKU\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_SO_ALL_SKU = newCalc \"zFreight-SO-ALL_SKU\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_PC = newCalc \"zFreight-PC\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_ALL_SKU = newCalc \"zFreight-ALL_SKU\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_SO = newCalc \"zFreight-SO\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_CP = newCalc \"zFreight-CP\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_CP_PC = newCalc \"zFreight-CP-PC\" false \"Z03\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_CP = newCalc \"zFreight Allowance-CP\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance = newCalc \"zFreight Allowance\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_CP_PC = newCalc \"zFreight Allowance-CP-PC\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_SO_ALL_SKU = newCalc \"zFreight Allowance-SO-ALL_SKU\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_SO_PC = newCalc \"zFreight Allowance-SO-PC\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_SO = newCalc \"zFreight Allowance-SO\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_ALL_SKU = newCalc \"zFreight Allowance-ALL_SKU\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_PC = newCalc \"zFreight Allowance-PC\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zFreight_Allowance_CP_ALL_SKU = newCalc \"zFreight Allowance-CP-ALL_SKU\" false \"Z04\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers = newCalc \"zWarehouse Transfers\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_SO_ALL_SKU = newCalc \"zWarehouse Transfers-SO-ALL_SKU\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_SO_PC = newCalc \"zWarehouse Transfers-SO-PC\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_CP_ALL_SKU = newCalc \"zWarehouse Transfers-CP-ALL_SKU\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_CP = newCalc \"zWarehouse Transfers-CP\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_PC = newCalc \"zWarehouse Transfers-PC\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_ALL_SKU = newCalc \"zWarehouse Transfers-ALL_SKU\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_CP_PC = newCalc \"zWarehouse Transfers-CP-PC\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Transfers_SO = newCalc \"zWarehouse Transfers-SO\" false \"Z05\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_CP_PC = newCalc \"zWarehouse Storage-CP-PC\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_CP = newCalc \"zWarehouse Storage-CP\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_SO_ALL_SKU = newCalc \"zWarehouse Storage-SO-ALL_SKU\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_SO_PC = newCalc \"zWarehouse Storage-SO-PC\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_SO = newCalc \"zWarehouse Storage-SO\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage = newCalc \"zWarehouse Storage\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_ALL_SKU = newCalc \"zWarehouse Storage-ALL_SKU\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_PC = newCalc \"zWarehouse Storage-PC\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zWarehouse_Storage_CP_ALL_SKU = newCalc \"zWarehouse Storage-CP-ALL_SKU\" false \"Z06\" false false [Version; DataType; Customer; Product]\n    let zCases_SO_PC = newCalc \"zCases-SO-PC\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases = newCalc \"zCases\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_CP_PC = newCalc \"zCases-CP-PC\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_SO_ALL_SKU = newCalc \"zCases-SO-ALL_SKU\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_CP_ALL_SKU = newCalc \"zCases-CP-ALL_SKU\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_SO = newCalc \"zCases-SO\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_ALL_SKU = newCalc \"zCases-ALL_SKU\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_PC = newCalc \"zCases-PC\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zCases_CP = newCalc \"zCases-CP\" false \"Z07\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input = newCalc \"zTrade Pct Input\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_CP_ALL_SKU = newCalc \"zTrade Pct Input-CP-ALL_SKU\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_CP_PC = newCalc \"zTrade Pct Input-CP-PC\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_CP = newCalc \"zTrade Pct Input-CP\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_SO_ALL_SKU = newCalc \"zTrade Pct Input-SO-ALL_SKU\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_SO_PC = newCalc \"zTrade Pct Input-SO-PC\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_SO = newCalc \"zTrade Pct Input-SO\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_PC = newCalc \"zTrade Pct Input-PC\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    let zTrade_Pct_Input_ALL_SKU = newCalc \"zTrade Pct Input-ALL_SKU\" false \"Z08\" false false [Version; DataType; Customer; Product]\n    \n    newForm Current_Year ForBase \"\"  \"\"\"SUBST(BudgetStart,1,4)\"\"\" []\n    newForm IsActual ForBase \"a\"  \"\"\"1\"\"\" [Version?Actual]\n    newForm IsActual ForBase \"b\"  \"\"\"IF((GetTime <| !Time) < (GetTime <| BudgetStart),1,0)\"\"\" []\n    newForm IsActual_Monthly ForBase \"\"  \"\"\"IF(DE.INDEX(\"Time\", INSRT(\"/\", STR(NUMBR(!Year) * 100 + NUMBR(!Period), 6, 0), 5)) <= 0, 0, IsActual.For[Time?(INSRT(\"/\", STR(NUMBR(!Year) * 100 + NUMBR(!Period), 6, 0), 5))])\"\"\" []\n    newForm Commission_Rate ForAll \"\"  \"\"\"Commission/Sales\"\"\" []\n    newForm Commission ForBase \"\"  \"\"\"\n       IF(Sales = 0, NA, Sales * IF(Commission_Rate_Projected = NA, Commission_Rate_Base, Commission_Rate_Projected) * (100 + Commission_Inflation) / 100 + Commission_Adjustment\n       )\"\"\" []\n    newForm Price ForConsolidated \"\"  \"\"\"Sales/Cases\"\"\" []\n    newForm Price ForBase \"\"  \"\"\"Sales/Cases\"\"\" [DataType?Value; Version?Actual]\n    newForm Sales ForBase \"a\"  \"\"\"STET\"\"\" [Version?Budget_Input]\n    newForm Sales ForBase \"b\"  \"\"\"STET\"\"\" [Version?Actual]\n    newForm Sales ForBase \"c\"  \"\"\"Cases*Price\"\"\" []\n    newForm Cases_Accum ForBase \"\"  \"\"\"       (Cases.For[Version?Actual;Time?(      ActualRef    )]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))]) \n           / 3\n    + IF( (Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -3))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -4))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -5))]) <> 0\n         , ( - (Cases.For[Version?Actual;Time?(      ActualRef    )]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))])  \n          + (Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -3))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -4))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -5))]))\n          / 6      \n          *  IF(AverageMonths.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))] @= \"6\",     1, NA)\n         , NA\n    )\"\"\" []\n    newForm Sales_3M ForAll \"\"  \"\"\"Sales.For[Version?Actual;Time?(ActualRef)]+Sales.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Sales.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))]\"\"\" []\n    newForm Price_3M ForAll \"\"  \"\"\"Sales_3M/{Cases 3M???) Not working\"\"\" []\n    newForm Commission_3M ForBase \"\"  \"\"\"(Commission.For[Version?Actual;Time?(ActualRef)]+Commission.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Commission.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))])/3\"\"\" []\n    newForm Commission_Rate_3M ForAll \"\"  \"\"\"Commission_3M/Sales_3M\"\"\" []\n    newForm Commission_Rate_Base ForBase \"\"  \"\"\"(Cases.For[DataType?Value] +  \n    Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] +\n    Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] +\n    Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] +\n    Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] +\n    Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\n    Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +                 \n    Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\n    Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n    ) * NA\n    +\n    IF(Cases.For[DataType?Value] = 0, NA,  \n       IF(                       \n            Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] <> NA\n           ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] /\n                Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value]\n           ,IF(\n                Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n               ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] /\n                        Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO]\n               ,IF(\n                             Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                    ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] /\n                     Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC]                 \n                    ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] /\n                                     Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                 )\n             )\n       )\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Commission_Rate_Base_Month ForBase \"\"  \"\"\"Commission_Rate_Base\"\"\" []\n    newForm CRE_Depth_Product ForAll \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n         MIN(\n              IF(de.parentname(\"Product\", !Product, 1) = NA, 999, \n                  IF(Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))] = NA, 999, \n                    CRE_Depth_Product.For[Product?(de.parentname(\"Product\", !Product, 1))] + 1\n                  )\n              ),\n              IF(de.parentname(\"Customer\", !Customer, 1) = NA, 999, \n                  IF(Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] = NA, 999, \n                    CRE_Depth_Product.For[Customer?(de.parentname(\"Customer\", !Customer, 1))]\n                  )\n              )\n        ),\n        0\n    )\"\"\" []\n    newForm CRE_Depth_Customer ForAll \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n         MIN(\n              IF(de.parentname(\"Customer\", !Customer, 1) = NA, 999, \n                  IF(Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] = NA, 999, \n                    CRE_Depth_Customer.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] + 1\n                  )\n              ),\n              IF(de.parentname(\"Product\", !Product, 1) = NA, 999, \n                  IF(Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))] = NA, 999, \n                    CRE_Depth_Customer.For[Product?(de.parentname(\"Product\", !Product, 1))]\n                  )\n              )\n        ),\n        0\n    )\"\"\" []\n    newForm Commission_Rate_Exception_2 ForAll \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n         IF(CRE_Depth_Product >= CRE_Depth_Customer, \n              IF(CRE_Depth_Product < 999, Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))], NA),\n              IF(CRE_Depth_Customer < 999, Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))], NA)\n         ),\n         Commission_Rate_Exception\n    )\"\"\" [DataType?Value]\n    newForm Commission_Override ForBase \"\"  \"\"\"IF(Commission_Rate_Projected = NA, NA, Commission_No_Actual)\"\"\" []\n    newForm Commission_Adjustment ForBase \"\"  \"\"\"Commission_Copy_No_Override - Commission_Original_No_Override\"\"\" [DataType?Calculated_Value]\n    newForm Commission_No_Override ForBase \"\"  \"\"\"Commission_No_Actual - Commission_Override\"\"\" []\n    newForm Commission_Copy ForBase \"\"  \"\"\"Commission_Override + Commission_Copy_No_Override\"\"\" []\n    newForm Cases_Buffer_Dif ForBase \"\"  \"\"\"Cases_Buffer_New-Cases_Buffer\"\"\" []\n    newForm Price_Input ForAll \"\"  \"\"\"Sales_Input/Cases_Input\"\"\" []\n    newForm Customer_Parent ForBase \"\"  \"\"\"GETATTR(\"Customer\", !Customer, 1, \"CustomerParent\")\"\"\" []\n    newForm Product_Class_Exception_M ForBase \"\"  \"\"\"Product_Class_Exception\"\"\" [Time?All_Years]\n    newForm Product_Class ForBase \"\"  \"\"\"IF(Customer_Parent @= \"\", \n       !Product,\n       IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\",\n          Product_Class_Exception.For[Customer?(Customer_Parent)],\n          IF(DE.INDEX(\"Product\", GETATTR(\"Product\", !Product, 1, \"ProductClass\")) <= 0, !Product, \n             IF(Product_Class_Exception.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))]@=\"\",\n                GETATTR(\"Product\", !Product, 1, \"ProductClass\"),\n                Product_Class_Exception.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))]))\n       )\n    )\"\"\" []\n    newForm Product_Class_2 ForBase \"\"  \"\"\"IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\",\n          !Product,\n          GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n       )\"\"\" []\n    newForm Is_Exception ForBase \"\"  \"\"\"GETATTR(\"Product\", !Product, 1, \"ProductClass\") @<> Product_Class\"\"\" []\n    newForm Cases_Proportion ForBase \"\"  \"\"\"IF(Cases_Basis=0,NA,Cases_Basis/Cases_Basis.For[Customer?(Customer_Parent);Product?(Product_Class_2)])\"\"\" []\n    newForm Cases_Projected ForBase \"b\"  \"\"\"IF(IsActual=1,Cases.For[Version?Actual],\n       IF(Cases_Basis=0,NA,\n          Cases_Proportion\n          *Cases_Input.For[Customer?(Customer_Parent);Product?(\n                IF(Product_Class_Exception.For[Customer?(Customer_Parent)]=NA\n                   ,GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n                  ,!Product)\n            )])\n    )\"\"\" []\n    newForm Price_Projected ForBase \"\"  \"\"\"IF(IsActual=1,Price.For[Version?Actual],\n       IF(Cases_Basis=0,NA,\n          Price_Input.For[Customer?(Customer_Parent);Product?(\n                IF(Product_Class_Exception.For[Customer?(Customer_Parent)]=NA\n                   ,GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n                  ,!Product)\n            )]\n        )\n    )\"\"\" []\n    newForm Pounds_per_case___Gross ForBase \"\"  \"\"\"IF(Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value] = NA, NA, Pounds_Gross.For[Version?Actual;Time?(UPTimeRef);DataType?Value] / Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value])\"\"\" [DataType?Calculated_Value]\n    newForm Pounds_per_case___Net ForBase \"\"  \"\"\"IF(Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value] = NA, NA, Pounds_Net.For[Version?Actual;Time?(UPTimeRef);DataType?Value] / Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value])\"\"\" [DataType?Calculated_Value]\n    newForm Pounds_Net ForBase \"\"  \"\"\"Cases * Pounds_per_case___Net\"\"\" []\n    newForm Pounds_Gross ForBase \"\"  \"\"\"Cases * Pounds_per_case___Gross\"\"\" []\n    newForm Freight_per_pound_base ForBase \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\n    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n    ) * NA\n    +\n    IF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n       IF(\n           Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n          ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n           Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n          ,IF(                 \n              Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n             ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n              ,IF(                     \n                  Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n                 ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n                  Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n                 ,IF(                     \n                     Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                    ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                     Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                    ,IF(                     \n                        Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                       ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                       ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                       )\n                    )\n                )\n            )\n        )\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Freight ForBase \"\"  \"\"\"IF( Cases = 0\n       ,NA \n       ,IF( [Value] = 0, 1, 0)\n    )\"\"\" [DataType?Validation]\n    newForm Freight ForBase \"\"  \"\"\" Freight_per_pound_base * Pounds_Net * ((100 + Freight_Inflation) / 100) * ((100 + Freight_Seasonality) / 100) + Freight_Adjustment\"\"\" []\n    newForm Freight_per_pound ForAll \"\"  \"\"\"Freight / Pounds_Net\"\"\" []\n    newForm Freight_Adjustment ForBase \"\"  \"\"\"Freight_Copy - Freight_Original\"\"\" [DataType?Calculated_Value]\n    newForm Freight_Allowance ForBase \"\"  \"\"\" Freight_Allowance_per_pound_base * Pounds_Net * ((100 + Freight_Allowance_Inflation) / 100) * ((100 + Freight_Allowance_Seasonality) / 100) + Freight_Allowance_Adjustment\"\"\" []\n    newForm Freight_Allowance_per_pound_base ForBase \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\n    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n    ) * NA\n    +\n    IF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n       IF(\n           Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n          ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n           Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n          ,IF(                 \n              Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n             ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n              ,IF(                     \n                  Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n                 ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n                  Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n                 ,IF(                     \n                     Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                    ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                     Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                    ,IF(                     \n                        Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                       ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                       ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                       )\n                    )\n                )\n            )\n        )\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Freight_Allowance_Adjustment ForBase \"\"  \"\"\"Freight_Allowance_Copy - Freight_Allowance_Original\"\"\" [DataType?Calculated_Value]\n    newForm Freight_Allowance_per_pound ForBase \"\"  \"\"\"Freight_Allowance / Pounds_Net\"\"\" []\n    newForm Warehouse_Transfers_per_pound ForAll \"\"  \"\"\"Warehouse_Transfers / Pounds_Net\"\"\" []\n    newForm Warehouse_Transfers ForBase \"\"  \"\"\"Warehouse_Transfers_per_pound_base * Pounds_Net *  ((100 + Warehouse_Transfers_Inflation) / 100) * ((100 + Warehouse_Transfers_Seasonality) / 100) + Warehouse_Transfers_Adjustment\"\"\" []\n    newForm Warehouse_Transfers_per_pound_base ForBase \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \n    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\n    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] \n    ) * NA\n    +\n    IF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n       IF(\n           Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n          ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n           Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n          ,IF(                 \n              Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n             ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n              ,IF(                     \n                  Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n                 ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n                  Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n                 ,IF(                     \n                     Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                    ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                     Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                    ,IF(                     \n                        Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                       ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                       ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                        Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                       )\n                    )\n                )\n            )\n        )\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Warehouse_Transfers ForBase \"\"  \"\"\"IF( Cases = 0\n       ,NA \n       ,IF( [Value] = 0, 1, 0)\n    )\"\"\" [DataType?Validation]\n    newForm Warehouse_Transfers_Adjustment ForBase \"\"  \"\"\"Warehouse_Transfers_Copy - Warehouse_Transfers_Original\"\"\" [DataType?Calculated_Value]\n    newForm Warehouse_Storage ForBase \"\"  \"\"\"IF( Cases = 0\n       ,NA \n       ,IF( [Value] = 0, 1, 0)\n    )\"\"\" [DataType?Validation]\n    newForm Warehouse_Storage_per_case_base ForBase \"\"  \"\"\"(Cases.For[DataType?Value] +\n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \n    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\n    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n    ) * NA\n    +\n    IF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n       IF(\n           Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n          ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n           Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n          ,IF(                 \n              Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n             ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n              Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n              ,IF(                     \n                  Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n                 ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n                  Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n                 ,IF(                     \n                     Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                    ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                     Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                    ,IF(                     \n                        Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                       ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                        Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                       ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                        Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                       )\n                    )\n                )\n            )\n        )\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Warehouse_Storage ForBase \"\"  \"\"\"Warehouse_Storage_per_case_base * Cases *  ((100 + Warehouse_Storage_Inflation) / 100) * ((100 + Warehouse_Storage_Seasonality) / 100) + Warehouse_Storage_Adjustment\"\"\" []\n    newForm Warehouse_Storage_per_case ForAll \"\"  \"\"\"Warehouse_Storage / Cases\"\"\" []\n    newForm Warehouse_Storage_Adjustment ForBase \"\"  \"\"\"Warehouse_Storage_Copy - Warehouse_Storage_Original\"\"\" [DataType?Calculated_Value]\n    newForm Trade_Pct_Input ForConsolidated \"\"  \"\"\"Trade_Input / Sales_No_Actual_Calc * 100\"\"\" []\n    newForm Promotion ForBase \"\"  \"\"\"Trade - Off_Invoice\"\"\" []\n    newForm Off_Invoice ForBase \"\"  \"\"\"Trade * Off_Invoice_Split_Pct\"\"\" []\n    newForm Trade_Input ForBase \"\"  \"\"\"IF(Sales_No_Actual <= 0, NA, Sales_No_Actual * IF(Trade_Pct_Input = -1, 0, Trade_Pct_Input) / 100)\"\"\" []\n    newForm Trade_Pct_Base_E ForBase \"\"  \"\"\"(Sales.For[DataType?Value] +\n    Trade_Pct_Input.For[DataType?Value;CP;ALL_SKU] +\n    Trade_Pct_Input.For[DataType?Value;CP;PC] +\n    Trade_Pct_Input.For[DataType?Value;CP] +\n    Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] + \n    Trade_Pct_Input.For[DataType?Value;SO;PC] +\n    Trade_Pct_Input.For[DataType?Value;SO] +\n    Trade_Pct_Input.For[DataType?Value;ALL_SKU] + \n    Trade_Pct_Input.For[DataType?Value;PC] +\n    Trade_Pct_Input\n    ) * NA\n    +\n    IF(Sales_No_Actual.For[DataType?Value] <= 0, NA,\n       IF(\n            Trade_Pct_Input = -1, 0, IF( Trade_Pct_Input = NA\n            ,IF(                 \n              Trade_Pct_Input.For[DataType?Value;PC] = -1, 0, IF(Trade_Pct_Input.For[DataType?Value;PC] = NA\n               ,IF(                     \n                  Trade_Pct_Input.For[DataType?Value;ALL_SKU] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;ALL_SKU] = NA\n                  ,IF(                     \n                     Trade_Pct_Input.For[DataType?Value;SO] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO] = NA\n                      ,IF(                     \n                        Trade_Pct_Input.For[DataType?Value;SO;PC] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO;PC] = NA\n                        ,IF(                     \n                           Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] = NA\n                           ,IF(                     \n                              Trade_Pct_Input.For[DataType?Value;CP] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;CP] = NA\n                               ,IF(                     \n                                 Trade_Pct_Input.For[DataType?Value;CP;PC] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;CP;PC] = NA\n                                ,Trade_Pct_Input.For[DataType?Value;CP;ALL_SKU] \n                                ,Trade_Pct_Input.For[DataType?Value;CP;PC]\n                                ))\n                               ,Trade_Pct_Input.For[DataType?Value;CP] \n                               ))\n                             ,Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] \n                            ))\n                            ,Trade_Pct_Input.For[DataType?Value;SO;PC] \n                        ))\n                        ,Trade_Pct_Input.For[DataType?Value;SO]\n                    ))\n                    ,Trade_Pct_Input.For[DataType?Value;ALL_SKU] \n                ))\n                ,Trade_Pct_Input.For[DataType?Value;PC] \n            ))\n            , Trade_Pct_Input\n        ))\n    )\"\"\" [DataType?Calculated_Value]\n    newForm Trade_Base_Pre ForBase \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Base_E / 100\"\"\" []\n    newForm Trade_Pct_Base_Pre ForConsolidated \"\"  \"\"\"Trade_Base_Pre / Sales_No_Actual_Calc * 100\"\"\" []\n    newForm Trade_Pct_Base_Pre ForBase \"\"  \"\"\"Trade_Pct_Base_E\"\"\" []\n    newForm Trade_Actual ForBase \"\"  \"\"\"IF(IsActual=1, Trade, NA)\"\"\" [DataType?Value]\n    newForm Sales_FY ForBase \"\"  \"\"\"Sales.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\n    newForm Sales_YTG ForBase \"\"  \"\"\"Sales_No_Actual.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\n    newForm Trade_YTD ForBase \"\"  \"\"\"Trade_Actual.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\n    newForm Trade_BOY ForBase \"\"  \"\"\"IF( Sales_FY > 0, \n         IF( Trade_Pct_Base_E * Sales_FY / 100 >= Trade_YTD, Trade_Pct_Base_E * Sales_FY / 100 - Trade_YTD, NA),\n         Trade_Pct_Base_E * Sales_FY / 100 - Trade_YTD\n    )\"\"\" []\n    newForm Trade_Pct_Base ForAll \"\"  \"\"\"IF(Sales_FY <> 0, \n         Trade_BOY / Sales_YTG_Calc * 100,\n         IF(Sales_No_Actual <> 0, Trade_Pct_Base_Pre , NA)\n    )\"\"\" []\n    newForm Sales_YTG_Calc ForBase \"\"  \"\"\"IF(Trade_BOY = NA, NA, Sales_YTG)\"\"\" []\n    newForm Sales_FY_Calc ForBase \"\"  \"\"\"IF(Trade_YTD + Trade_BOY = NA, NA, Sales_FY)\"\"\" []\n    newForm Trade_Base ForBase \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Base / 100\"\"\" []\n    newForm Trade_Pct_Override ForConsolidated \"\"  \"\"\"Trade_Override.For[Time?All_Years]/Sales_No_Actual.For[Time?All_Years]*100\"\"\" []\n    newForm Trade_Override ForBase \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Override / 100\"\"\" []\n    newForm Off_Invoice_Split_Pct ForBase \"\"  \"\"\"Off_Invoice.For[Time?(ActualRef);Version?Actual_12M]/Trade.For[Time?(ActualRef);Version?Actual_12M]\"\"\" []\n    newForm Promotion_Split_Pct ForBase \"\"  \"\"\"1-Off_Invoice_Split_Pct\"\"\" []\n    newForm Trade ForBase \"\"  \"\"\"Off_Invoice + Promotion\"\"\" [DataType?Value; Version?Actual]\n    newForm Trade_Pct ForConsolidated \"\"  \"\"\"Trade_No_Actual.For[Time?All_Years]/Sales_No_Actual.For[Time?All_Years]*100\"\"\" []\n    newForm Trade_Pct ForBase \"\"  \"\"\" IF(Is_Trade_Override =NA, Trade_Pct_Base, Trade_Pct_Override)\"\"\" []\n    newForm Trade ForBase \"\"  \"\"\"Sales_No_Actual * IF(Is_Trade_Override =NA, Trade_Pct_Base, Trade_Pct_Override) / 100\"\"\" []\n    newForm Trade_Pct_Transfer ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct)\"\"\" []\n    newForm Trade_Pct_Calc ForAll \"\"  \"\"\"Trade/Sales\"\"\" []\n    newForm Is_Missing ForBase \"\"  \"\"\"IF(Cases_Input = 0, NA, IF(Cases_Basis.For[Customer?(Customer_Parent);Product?(Product_Class)] = 0, 1, NA))\"\"\" []\n    newForm Proportion_Exception ForBase \"\"  \"\"\"IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\", 1\n       ,Allocation_Weight.For[Customer?(Customer_Parent)]\n       /Allocation_Weight.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))])\n    *Cases_Accum.For[Product?(Product_Class)]\"\"\" []\n    newForm Cases_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Cases)\"\"\" []\n    newForm Sales_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Sales)\"\"\" []\n    newForm Sales_No_Actual_Calc ForBase \"\"  \"\"\"IF(IsActual=1,NA, IF(Trade_Base_Pre = NA, NA, Sales))\"\"\" []\n    newForm Cases_Input_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Cases_Input)\"\"\" []\n    newForm Sales_Input_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Sales_Input)\"\"\" []\n    newForm Warehouse_Transfers_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Warehouse_Transfers)\"\"\" []\n    newForm Warehouse_Storage_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Warehouse_Storage)\"\"\" []\n    newForm Trade_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Trade)\"\"\" []\n    newForm Freight_Allowance_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Freight_Allowance)\"\"\" []\n    newForm Off_Invoice_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Off_Invoice)\"\"\" []\n    newForm Promotion_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Promotion)\"\"\" []\n    newForm Commission_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Commission)\"\"\" []\n    newForm Freight_No_Actual ForBase \"\"  \"\"\"IF(IsActual=1,NA, Freight)\"\"\" []\n    newForm zSales_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zSales_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCommission ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zPounds_Net_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zFreight_Allowance_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Transfers_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zWarehouse_Storage_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zCases_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\n    newForm zTrade_Pct_Input ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input)\"\"\" []\n    newForm zTrade_Pct_Input_CP_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP;ALL_SKU])\"\"\" []\n    newForm zTrade_Pct_Input_CP_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP;PC])\"\"\" []\n    newForm zTrade_Pct_Input_CP ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP])\"\"\" []\n    newForm zTrade_Pct_Input_SO_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO;ALL_SKU])\"\"\" []\n    newForm zTrade_Pct_Input_SO_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO;PC])\"\"\" []\n    newForm zTrade_Pct_Input_SO ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO])\"\"\" []\n    newForm zTrade_Pct_Input_PC ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[PC])\"\"\" []\n    newForm zTrade_Pct_Input_ALL_SKU ForBase \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[ALL_SKU])\"\"\" []\n    \n    \n    ", "snpParentIdO": {"SnippetId" :"b49fc3c3-f6b4-4e2d-ab01-ad57df07cb42"}, "snpPredIds": [{"SnippetId" :"b49fc3c3-f6b4-4e2d-ab01-ad57df07cb42"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"10a727f3-e6c1-4c81-a868-031e8483c9f3"}, "snpName": "mainProgram", "snpContent": "let mainProgram() =\n    WcSplitterT.init()\n    WcTabStripT.init()\n    Global.processor <- UpdateModelUI.updateModel model\n    Render.mainLayout()", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"22818e3c-9d73-493c-b064-3b7da34ccddd"}, {"SnippetId" :"e3b3ef34-f541-4fab-8e9a-c6e95ce753ab"}, {"SnippetId" :"e92e1677-f965-4aaf-a83b-55b5a7f2430d"}, {"SnippetId" :"f82d4870-b1f1-4379-b56a-78076d7b86d3"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7169d2ad-43a6-4fdb-9c85-cce375af9b23"}, "snpName": "RuleEditorNew", "snpContent": "#define FSS_SERVER\n#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Html\n\n[< JavaScript false >]\nmodule server =\n    open WebSharper.UI.Server\n    open WebSharper.UI.Templating\n    \n    type EndPoint = | [< EndPoint \"/\" >] EP\n    \n    let content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n        Content.Page(Title = \"Main Page\" \n                   , Body = [\n                       Html.client <@  mainProgram() @> \n                       Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                     ])\n    \n    open global.Owin\n    open WebSharper.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin.WebSocket\n    open WSMessagingBroker\n    \n    let url         = \"http://localhost:9040/\"\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    Broker.BrokerAgent.FssWebSocketO <- Some brokerAgent\n    [< EntryPoint >]\n    let Main args =\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = \"website\"\n                                                   , Sitelet             = Some (Application.MultiPage content)\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                    .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n                    .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = 1_000_000)\n                |> ignore\n            )        \n        stdout.WriteLine(\"Starting, hit enter to finish\")\n        stdin.ReadLine() |> ignore\n        0\n\n    \n    ", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"10a727f3-e6c1-4c81-a868-031e8483c9f3"}, {"SnippetId" :"1414242b-3301-4071-aa25-19c67f0b5bff"}, {"SnippetId" :"22818e3c-9d73-493c-b064-3b7da34ccddd"}, {"SnippetId" :"466e6783-0751-48d5-b79b-165aaa7d2173"}, {"SnippetId" :"e92e1677-f965-4aaf-a83b-55b5a7f2430d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1dda57eb-e256-4e62-adf7-17103a83fd4e"}, "snpName": "compile & run RuleEditorNew", "snpContent": "#if WEBSHARPER\n#else    \n#r @\"Compiled\\FSCompilerDll\\FSCompilerDll.dll\"\nopen FSSGlobal\n#endif    \n\nopen System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Calculation Editor/RuleEditorNew\"\n                           + siteOptions\n                           + (opGenInternal /= \"showoptions\")\n                           + (opPlatform    /= \"x86\"        )\n    let  exeFile         = options?OutputFile\n    let  workDir         = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n#if WEBSHARPER\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n#else    \n    let! res             = FStationMessaging(\"Compile WebSharper\", \"##FSHARPSTATION_ID##\").CompileSnippetW options\n#endif    \n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9040/\"\n    let  parms           = sprintf \"%A %A\" site url \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2f2a549d-677c-4bd7-90d9-c0baacaa8c1e"}, "snpName": "To do's", "snpContent": "Add Code Generation\nAdd Intellisense: \n    Tooltips\n    Jump to Definition\nDisable Formula CodeMirror when there is no formula", "snpParentIdO": {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpName": "Calculation Editor Code", "snpContent": "#if WEBSHARPER\n[< JavaScript >]\n#endif\nmodule CalcEditor = ", "snpParentIdO": {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c68a9ed7-9d5c-4d86-a7fd-79ba996d56be"}, "snpName": "FSAutoCompleteInterfase", "snpContent": "module FSAutoCompleteInterfase =\n    type ResponseError =\n        {\n          Code: int\n          Message: string\n          //AdditionalData: 'T\n        }\n    type Location =\n      {\n        File: string\n        Line: int\n        Column: int\n      }\n    type CompletionResponse =\n      {\n        Name: string\n        ReplacementText: string\n        Glyph: string\n        GlyphChar: string\n      }\n    //type ProjectResponse =\n    //  {\n    //    Project: ProjectFilePath\n    //    Files: List<SourceFilePath>\n    //    Output: string\n    //    References: List<ProjectFilePath>\n    //    Logs: Map<string, string>\n    //  }\n    type OverloadDescription =\n      {\n        Signature: string\n        Comment: string\n      }\n    type OverloadParameter =\n      {\n        Name : string\n        CanonicalTypeTextForSorting : string\n        Display : string\n        Description : string\n      }\n    type Overload =\n      {\n        Tip : OverloadDescription list list\n        TypeText : string\n        Parameters : OverloadParameter list\n        IsStaticArguments : bool\n      }\n    type Parameter = {\n        Name : string\n        Type : string\n      }\n    type SignatureData = {\n        OutputType : string\n        Parameters : Parameter list list\n      }\n    type MethodResponse =\n      {\n        Name : string\n        CurrentParameter : int\n        Overloads : Overload list\n      }\n    type SymbolUseRange =\n      {\n        FileName: string\n        StartLine: int\n        StartColumn: int\n        EndLine: int\n        EndColumn: int\n        IsFromDefinition: bool\n        IsFromAttribute : bool\n        IsFromComputationExpression : bool\n        IsFromDispatchSlotImplementation : bool\n        IsFromPattern : bool\n        IsFromType : bool\n      }\n    type SymbolUseResponse =\n      {\n        Name: string\n        Uses: SymbolUseRange list\n      }\n    type HelpTextResponse =\n      {\n        Name: string\n        Overloads: OverloadDescription list list\n      }\n    type CompilerLocationResponse =\n      {\n        Fsc: string\n        Fsi: string\n        MSBuild: string\n      }\n    type FSharpErrorInfo =\n      {\n        FileName: string\n        StartLine:int\n        EndLine:int\n        StartColumn:int\n        EndColumn:int\n       // Severity:FSharpErrorSeverity\n        Message:string\n        Subcategory:string\n      }\n    type ErrorResponse =\n      {\n        File: string\n        Errors: FSharpErrorInfo []\n      }\n    type Colorization =\n      {\n    //    Range: Range\n        Kind: string\n      }\n    type Declaration =\n      {\n        UniqueName: string\n        Name: string\n        Glyph: string\n        GlyphChar: string\n        IsTopLevel: bool\n    //  Range     : Utils.Range\n    //    BodyRange : Utils.Range\n        File : string\n        EnclosingEntity: string\n        IsAbstract: bool\n      }\n    type DeclarationResponse = {\n        Declaration : Declaration;\n        Nested : Declaration []\n    }\n    type OpenNamespace = {\n      Namespace : string\n      Name : string\n      Type : string\n      Line : int\n      Column : int\n      MultipleNames : bool\n    }\n    type QualifySymbol = {\n      Name : string\n      Qualifier : string\n    }\n    type ResolveNamespaceResponse = {\n      Opens : OpenNamespace []\n      Qualifies: QualifySymbol []\n      Word : string\n    }\n    type UnionCaseResponse = {\n      Text : string\n    //  Position : Pos\n    }\n    type Kind = \n    | KInfo             of string\n    | KError            of ResponseError\n    | KHelpText         of HelpTextResponse\n    | KCompletion       of CompletionResponse  []\n    | KSymbolUse        of SymbolUseResponse\n    | KHelp             of string\n    | KMethod           of MethodResponse\n    | KErrors           of ErrorResponse\n    | KColorizations    of Colorization list\n    | KFindDecl         of Location\n    | KDeclarations     of DeclarationResponse []\n    | KToolTip          of OverloadDescription [][]\n    | KTypeSig          of string\n    | KSignatureData    of SignatureData\n    | KCompilerLocation of CompilerLocationResponse\n    | KNamespaces       of ResolveNamespaceResponse\n    | KUnionCase        of UnionCaseResponse\n    | KMultiple         of Kind                []\n\n    type ParseRequest         = { FileName  : string ; IsAsync    : bool   ; Lines : string[]           ; Version : int                                            }\n    type DeclarationsRequest  = { FileName  : string ;                       Lines : string[]           ; Version : int                                            }\n    type CompletionRequest    = { FileName  : string ; SourceLine : string ; Line  : int                ; Column  : int ; Filter : string; IncludeKeywords : bool  }\n    type PositionRequest      = { FileName  : string ;                       Line  : int                ; Column  : int ; Filter : string                          }\n    type ProjectRequest       = { FileName  : string                                                                                                               }\n    type LintRequest          = { FileName  : string                                                                                                               }\n    type HelptextRequest      = { Symbol    : string                                                                                                               }\n    type WorkspacePeekRequest = { Directory : string ; Deep       : int    ; ExcludedDirs : string []                                                              }\n    \n    type FARequest =\n        | FarParse         of ParseRequest         \n        | FarTooltip       of PositionRequest      \n        | FarDeclaration   of PositionRequest  \n        | FarCompletion    of CompletionRequest    \n\n    let requestJson req =\n        match req with \n        | FarParse         data -> Json.Serialize data\n        | FarTooltip       data -> Json.Serialize data \n        | FarDeclaration   data -> Json.Serialize data \n        | FarCompletion    data -> Json.Serialize data \n\n    let requestCommand req =\n        match req with \n        | FarParse         _    -> \"parse\"\n        | FarTooltip       _    -> \"tooltip\"\n        | FarDeclaration   _    -> \"signatureData\"\n        | FarCompletion    _    -> \"completion\"\n\n    let UrlAddress = \"http://localhost:9001/\"\n\n    let ajaxCall url m (data:string) =\n        let ajaxInvoke (ok, ko, _) =\n            let success (result:obj)         _ _ = result :?> string                   |> ok\n            let error   (jqXHR:JQuery.JqXHR) _ _ = System.Exception jqXHR.ResponseText |> ko\n            let ajaxSettings : JQuery.AjaxSettings =\n                JQuery.AjaxSettings(\n                    Url         = url\n                  , Type        = m\n                  , ContentType = Union2Of2 \"application/json\" \n                  , DataType    = JQuery.DataType.Text\n                  , Success     = System.Action<_,_,_> success\n                  , Error       = System.Action<_,_,_> error\n                  , Data        = data\n                  , Timeout     = 300_000.0\n                )\n            JQuery.JQuery.Ajax ajaxSettings |> ignore\n        Async.FromContinuations ajaxInvoke\n\n    let HttpRequestCall (url:string) (data:string) =\n        async {\n            let! resp = ajaxCall url JQuery.RequestType.POST data           \n//            req.ProtocolVersion <- HttpVersion.Version10\n            return       resp\n        }\n    \n    let KindError msg = KError { Code = 0 ; Message = msg }\n    \n    let json2Kind (v:JsonValue) = \n        let item =JsonValue.Parse <| v.AsString()\n        match item?Kind.AsString() with\n        | \"info\"             -> jsonData2Obj item |> KInfo\n        | \"error\"            -> jsonData2Obj item |> KError\n        | \"errors\"           -> jsonData2Obj item |> KErrors\n        | \"tooltip\"          -> jsonData2Obj item |> KToolTip\n        | \"typesig\"          -> jsonData2Obj item |> KTypeSig\n        | \"completion\"       -> jsonData2Obj item |> KCompletion\n        | \"signatureData\"    -> jsonData2Obj item |> KSignatureData\n        | \"finddecl\"         -> jsonData2Obj item |> KFindDecl\n        | \"compilerlocation\" -> jsonData2Obj item |> KCompilerLocation\n        | _                  -> KindError <| v.ToString()\n    \n    let FSAutocompleteCall cmd f (req: FARequest) =\n        Wrap.wrapper {\n            let  data         = req.Json\n            let! jsonV        = HttpRequestCall (UrlAddress + cmd) data\n            let  several      = jsonV.AsArray() |> Array.map json2Kind\n            let  good, others = several |> Array.partition f\n            let  msgs         = others  |> Seq.map (fun v -> (v.ToString(), match v with | KInfo _ -> true | _ -> false) |> ErrSimple :> ErrMsg) |> Seq.toArray\n            let! result       = Result (Seq.tryHead good, msgs) \n            return result\n        } \n        ", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ecccc1a6-726e-438a-8804-16063c8a5107"}, "snpName": "calculations", "snpContent": "open Useful\nopen Template\n\nmodule ListModel =\n    let lensInto' (m:ListModel<_,_>) (get: 'T       -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.FindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v          |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> get i |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> get i |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let lensIntoO'(m: ListModel<_,_>) (get: 'T option -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) (view: View<'V>) : Var<'V> =\n        let id = Var.freshId()\n        { new Var<'V>() with\n            member r.Get         () = m.TryFindByKey key |> get\n            member r.Set         v  = m.UpdateBy (fun i -> v                  |>             update i |> Some) key\n            member r.Update      f  = m.UpdateBy (fun i -> Some i |> get |> f |>             update i |> Some) key\n            member r.UpdateMaybe f  = m.UpdateBy (fun i -> Some i |> get |> f |> Option.map (update i)       ) key\n            member r.SetFinal    v  = r.Set v\n            member r.View           = view\n            member r.Id             = id\n        }\n    let docLensMapView      mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensInto' m   id                        (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let docLensMapViewO def mapView (f: 'Key -> Var<'T> -> 'V) (m:ListModel<_,_>) =\n        let get k v = f k (lensIntoO' m (Option.defaultValue def)  (fun _ -> id) k v)\n        Doc.BindSeqCachedViewBy m.Key get (View.Map mapView m.View)\n    let lensDef def k (m:ListModel<_,_>) =\n        let get = Option.defaultValue def\n        lensIntoO' m get (fun _ -> id) k (m.TryFindByKeyAsView k |> View.Map get)\n\nlet trueV = Val.Constant true\n\n[< Inline >]\nlet getItemIRefO (listm:ListModel<'K,'T>) get upd kO =\n    kO\n    |> Option.bind (fun    k -> \n        listm.TryFindByKey k\n        |> Option.map(fun _ -> listm.LensInto get upd k)\n    )\n\n//[< Inline >]\n//let lensInto<'K, 'T, 'F> (def:'F) (find:'K -> 'T option) lens (k:'K) =        \n//    match find k with\n//    | Some _ -> lens k\n//    | None   -> (Var.Create ()).Lens   (fun _ -> def) (fun u _ -> u)\n\n//[< Inline >]\n//let getItemIRef def (listm:ListModel<'K,'T>) get upd k = lensInto<'K,'T,'F> def listm.TryFindByKey (listm.LensInto get upd) k\n\ntype TypeCalc = Input | Calc\n    with override this.ToString() = sprintf \"%A\" this\n\ntype CalcId   = CalcId of System.Guid\n    with member this.Guid = match this with CalcId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Calculation = {\n    id        : CalcId\n    name      : string\n    typeC     : TypeCalc\n    order     : string\n    isText    : bool\n    isBalance : bool\n    format    : string\n}\n\nlet newCalculation() = {\n    id        = CalcId <| System.Guid.NewGuid()\n    name      = \"\"\n    typeC     = Input\n    order     = \"\"\n    isText    = false\n    isBalance = false\n    format    = \"0,000\"\n}\n\ntype TotId   = TotId of System.Guid\n    with member this.Guid = match this with TotId gid -> gid\n\ntype Weight =\n| Zero\n| Add\n| Subtract\n\ntype Child =\n    | Leaf of CalcId\n    | Node of  TotId\n\nlet getChildCId = function | Leaf cid -> Some cid | _ -> None\nlet getChildTId = function | Node tid -> Some tid | _ -> None\n\ntype Total = {\n    id        : TotId\n    totName   : string\n    order     : string\n    format    : string\n}\n\nlet newTotal() = {\n    id        = TotId <| System.Guid.NewGuid()\n    totName   = \"\"\n    order     = \"\"\n    format    = \"0,000\"\n}\n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"7a655466-e218-4121-a7b6-f9c70a922e07"}, {"SnippetId" :"a21525b8-a16c-4e98-b05e-8eef61ff4539"}, {"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}, {"SnippetId" :"c7841be7-5cd5-40f3-b91c-c107b487bc0c"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, "snpName": "formulas, dimensions", "snpContent": "type TypeForm = Base | Consolidated | All\n    with override this.ToString() = sprintf \"%A\" this\n\ntype FormId   = FormId of System.Guid\n    with member this.Guid = match this with FormId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Formula   = {\n    id         : FormId\n    idCalc     : CalcId\n    formula    : string\n    typeF      : TypeForm\n    order      : string\n    alsoActual : bool\n} \n \nlet newFormula idCalc = {\n    id         = FormId <| System.Guid.NewGuid()\n    idCalc     = idCalc\n    formula    = \"\"\n    typeF      = Base\n    order      = \"\"\n    alsoActual = false\n} \n \ntype DimId     = DimId  of System.Guid\n    with member this.Guid = match this with DimId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype DimType =\n    | DtDataType\n    | DtTime\n    | DtVersion\n    | DtTCalc\n    | DtCalc\n    | DtMeasure\n    | DtOther\n    with override this.ToString() = (sprintf \"%A\" this).[2..]\n\n[< NamedUnionCases \"type\" >]\ntype Dimension = {\n    id            : DimId\n    dimension     : string\n    abbreviation  : string\n    order         : string\n    excludeCube   : bool\n    includeFreeze : bool\n    dimType       : DimType\n}\n\nlet newDimension() = {\n    id            = DimId <| System.Guid.NewGuid()\n    dimension     =  \"\"   \n    abbreviation  =  \"\"   \n    order         =  \"\"   \n    excludeCube   =  false\n    includeFreeze =  false    \n    dimType       =  DtOther\n}\n\n[< NamedUnionCases \"type\" >]\ntype Destination = {\n    idForm       : FormId\n    idDim        : DimId\n    destination  : string\n}\n\nlet getDstKey d = d.idForm, d.idDim\n\nlet newDestination fid did = {\n    idForm      = fid\n    idDim       = did\n    destination =  \"\"   \n}\n\ntype CubeId    = CubeId  of System.Guid\n    with member this.Guid = match this with CubeId gid -> gid\n\n[< NamedUnionCases \"type\" >]\ntype Cube = {\n    id            : CubeId\n    cube          : string\n}\n\nlet newCube() = {\n    id   = CubeId <| System.Guid.NewGuid()\n    cube =  \"\"   \n}\n\ntype ChildWithFormula =\n| ChildTotId  of TotId\n| ChildCalcId of CalcId * (FormId option)\ntype Path = Path of ChildWithFormula * (TotId list)\ntype TreeNodeId = TreeNodeId of System.Guid\ntype Selection  = (TreeNodeId * (FormId option)) option\n\nlet parents = System.Collections.Generic.Dictionary<TreeNodeId, obj>()\n\ntype TreeNode = {\n    nid      : TreeNodeId\n    expanded : bool\n    children : TreeNode []\n    element  : Child\n    weight   : Weight\n} with\n    static member FromNode (n:Tree.Node<_>) = n :?> TreeNode\n    interface Tree.Node<TreeNodeId> with\n        member node.Id                 = node.nid\n        member node.isExpanded         = node.expanded\n        member node.canHaveChildren    = match node.element with | Node _ -> true | _ -> false\n        member node.path               =   \n            let rec getPath nid = parents |> Dict.tryGetValue nid |> Option.map Tree.toNode |> Option.map (fun n -> n.Id :: n.path) |> Option.defaultValue []\n            getPath node.nid\n        member node.children           =   node     .children   |> Tree.toSeqNode\n        member node.newChildren     ch = { node with children = ch \n                                                                |> Seq.map   (fun n -> n :?> TreeNode    ) \n                                                                |> Seq.filter(fun n -> \n                                                                    parents \n                                                                    |> Dict.tryGetValue n.nid \n                                                                    |> Option.map (fun v -> \n                                                                        if v :?> TreeNode <> node then \n                                                                            parents.Remove n.nid |> ignore\n                                                                            parents.Add(n.nid, node)\n                                                                    )\n                                                                    |> Option.defaultWith(fun () ->\n                                                                        parents.Add(n.nid, node)\n                                                                    )\n                                                                    true)\n                                                                |> Seq.toArray } |> Tree.toNode\n        member node.parent          ns = parents |> Dict.tryGetValue node.nid |> Option.map Tree.toNode\n\nlet fromNode    n  = TreeNode.FromNode n\nlet fromSeqNode ns = ns |> Seq.map fromNode |> Seq.toArray\n\nlet newTreeNode ch = {\n    nid      = TreeNodeId <| System.Guid.NewGuid()\n    expanded = true\n    children = [||]\n    element  = ch\n    weight   = Add\n}\n\nlet newNodeCalc cid = newTreeNode <| Leaf cid\nlet newNodeTot  tid = newTreeNode <| Node tid\n\n\n[<NoComparison ; NoEquality>]\ntype Model = {\n    calculations  : ListModel<CalcId        , Calculation>\n    totals        : ListModel< TotId        , Total      >\n    formulas      : ListModel<FormId        , Formula    >\n    dimensions    : ListModel< DimId        , Dimension  >\n    cubes         : ListModel<CubeId        , Cube       >\n    destinations  : ListModel<FormId * DimId, Destination>\n    calcDims      : Var<Set<  CalcId * DimId        >    >\n    cubeDims      : Var<Set<  CubeId * DimId        >    >\n    globalDefs    : Var<string>\n    server        : Var<string>\n    selection     : Var<Selection>\n    selectedDim   : Var<DimId  option>\n    selectedCube  : Var<CubeId option>\n    collapsed     : ListModel<TotId * TotId list, TotId * TotId list>\n    cubePrefix    : Var<string>\n    measurePrefix : Var<string>\n    treeHierarchy : Var<TreeNode []>\n}\n\ntype MsgModel =\n| AddTotal\n//| AddChild          of TotId * Child * Weight\n| SelectTotal       of TotId\n| RemoveTotal       of TotId\n//| RemoveChild       of TotId * Child\n| AddCalculation\n| RemoveCalculation of CalcId\n| SelectCalculation of CalcId\n| AddFormula        of CalcId\n| RemoveFormula     of FormId\n| SelectFormula     of FormId\n| SelectFormNode    of FormId * TreeNodeId\n| SelectNode        of          TreeNodeId\n| ExpandNode        of bool   * TreeNodeId\n| IndentNode        of bool   * TreeNodeId\n| MoveNode          of bool   * TreeNodeId * TreeNodeId\n| AddDimension\n| RemoveDimension   of DimId\n| SelectDimension   of DimId\n| AddFormDim        of FormId * DimId * string\n| RemoveFormDim     of FormId * DimId\n\nlet [< Inline >] inline getId            (x: ^T) = (^T : (member id            : 'U) x)\nlet [< Inline >] inline getnid           (x: ^T) = (^T : (member nid           : 'U) x)\nlet [< Inline >] inline getname          (x: ^T) = (^T : (member name          : 'U) x)\nlet [< Inline >] inline gettotName       (x: ^T) = (^T : (member totName       : 'U) x)\nlet [< Inline >] inline gettypeC         (x: ^T) = (^T : (member typeC         : 'U) x)\nlet [< Inline >] inline getorder         (x: ^T) = (^T : (member order         : 'U) x)\nlet [< Inline >] inline getisText        (x: ^T) = (^T : (member isText        : 'U) x)\nlet [< Inline >] inline getisBalance     (x: ^T) = (^T : (member isBalance     : 'U) x)\nlet [< Inline >] inline getformat        (x: ^T) = (^T : (member format        : 'U) x)\nlet [< Inline >] inline getidCalc        (x: ^T) = (^T : (member idCalc        : 'U) x)\nlet [< Inline >] inline getidForm        (x: ^T) = (^T : (member idForm        : 'U) x)\nlet [< Inline >] inline getidDim         (x: ^T) = (^T : (member idDim         : 'U) x)\nlet [< Inline >] inline getformula       (x: ^T) = (^T : (member formula       : 'U) x)\nlet [< Inline >] inline getcube          (x: ^T) = (^T : (member cube          : 'U) x)\nlet [< Inline >] inline gettypeF         (x: ^T) = (^T : (member typeF         : 'U) x)\nlet [< Inline >] inline getdimension     (x: ^T) = (^T : (member dimension     : 'U) x)\nlet [< Inline >] inline getabbreviation  (x: ^T) = (^T : (member abbreviation  : 'U) x)\nlet [< Inline >] inline getexcludeCube   (x: ^T) = (^T : (member excludeCube   : 'U) x)\nlet [< Inline >] inline getincludeFreeze (x: ^T) = (^T : (member includeFreeze : 'U) x)\nlet [< Inline >] inline getdimType       (x: ^T) = (^T : (member dimType       : 'U) x)\nlet [< Inline >] inline getdestination   (x: ^T) = (^T : (member destination   : 'U) x)\nlet [< Inline >] inline getalsoActual    (x: ^T) = (^T : (member alsoActual    : 'U) x)\nlet [< Inline >] inline getKey           (x: ^T) = (^T : (member Key           : 'U) x)\nlet [< Inline >] inline getelement       (x: ^T) = (^T : (member element       : 'U) x)\nlet [< Inline >] inline getexpanded      (x: ^T) = (^T : (member expanded      : 'U) x)\nlet [< Inline >] inline getchildren      (x: ^T) = (^T : (member children      : 'U) x)\nlet [< Inline >] inline getweight        (x: ^T) = (^T : (member weight        : 'U) x)\n\nlet [< Inline >] inline setIdD           v x = { x with Dimension  .id     = v }\nlet [< Inline >] inline setIdC           v x = { x with Calculation.id     = v }\nlet [< Inline >] inline setIdT           v x = { x with Total      .id     = v }\nlet [< Inline >] inline setIdF           v x = { x with Formula    .id     = v }\nlet [< Inline >] inline setIdCu          v x = { x with Cube       .id     = v }\nlet [< Inline >] inline setname          v x = { x with name               = v }\nlet [< Inline >] inline settotName       v x = { x with totName            = v }\nlet [< Inline >] inline settypeC         v x = { x with typeC              = v }\nlet [< Inline >] inline setorderD        v x = { x with Dimension  .order  = v }\nlet [< Inline >] inline setorderC        v x = { x with Calculation.order  = v }\nlet [< Inline >] inline setorderT        v x = { x with Total      .order  = v }\nlet [< Inline >] inline setorderF        v x = { x with Formula    .order  = v }\nlet [< Inline >] inline setisText        v x = { x with isText             = v }\nlet [< Inline >] inline setisBalance     v x = { x with isBalance          = v }\nlet [< Inline >] inline setformatC       v x = { x with Calculation.format = v }\nlet [< Inline >] inline setformatT       v x = { x with Total      .format = v }\nlet [< Inline >] inline setidCalc        v x = { x with idCalc             = v }\nlet [< Inline >] inline setidForm        v x = { x with idForm             = v }\nlet [< Inline >] inline setidDim         v x = { x with idDim              = v }\nlet [< Inline >] inline setformula       v x = { x with formula            = v }\nlet [< Inline >] inline setcube          v x = { x with cube               = v }\nlet [< Inline >] inline settypeF         v x = { x with typeF              = v }\nlet [< Inline >] inline setdimension     v x = { x with dimension          = v }\nlet [< Inline >] inline setabbreviation  v x = { x with abbreviation       = v }\nlet [< Inline >] inline setexcludeCube   v x = { x with excludeCube        = v }\nlet [< Inline >] inline setincludeFreeze v x = { x with includeFreeze      = v }\nlet [< Inline >] inline setdimType       v x = { x with dimType            = v }\nlet [< Inline >] inline setdestination   v x = { x with destination        = v }\nlet [< Inline >] inline setalsoActual    v x = { x with alsoActual         = v }\nlet [< Inline >] inline setnid           v x = { x with nid                = v }\nlet [< Inline >] inline setelement       v x = { x with element            = v }\nlet [< Inline >] inline setexpanded      v x = { x with expanded           = v }\nlet [< Inline >] inline setchildren      v x = { x with children           = v } : TreeNode\nlet [< Inline >] inline setweight        v x = { x with weight             = v }\n\n\nlet selectedString txt (selectedV:View<bool>) = V(if selectedV.V then txt else \"\") \n\nlet refreshView, refreshNow =\n    let refresh = Var.Create ()\n    refresh.View, fun () -> refresh.Value <- ()\n\nlet modelNew() = {\n    calculations  = ListModel.Create getId     []\n    totals        = ListModel.Create getId     [] \n    formulas      = ListModel.Create getId     []\n    dimensions    = ListModel.Create getId     []\n    cubes         = ListModel.Create getId     []\n    destinations  = ListModel.Create getDstKey []\n    calcDims      = Var      .Create <| Set    []\n    cubeDims      = Var      .Create <| Set    []\n    globalDefs    = Var      .Create <| \"\"\n    server        = Var      .Create <| \"\"\n    selection     = Var      .Create <| None\n    selectedDim   = Var      .Create <| None\n    selectedCube  = Var      .Create <| None\n    collapsed     = if IsClient then ListModel.CreateWithStorage id (Storage.LocalStorage \"RuleEditor.collapsed\" Serializer.Default) \n                                else ListModel.Create            id []\n    cubePrefix    = Var      .Create <| \"Z\"\n    measurePrefix = Var      .Create <| \"M\"\n    treeHierarchy = Var      .Create <| [| |]\n}\n\nlet model = modelNew()\n\nlet nonTotal        = { newTotal       ()                with id = TotId  System.Guid.Empty }\nlet nonCalculation  = { newCalculation ()                with id = CalcId System.Guid.Empty } \nlet nonFormula      = { newFormula     nonCalculation.id with id = FormId System.Guid.Empty }\nlet nonDestination  = newDestination nonFormula.id (DimId System.Guid.Empty)\n\nlet nonTotalV       = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\nlet nonCalculationV = Var.Create nonCalculation |> Var.Lens <| id <| (fun v _ -> v)\nlet nonFormulaV     = Var.Create nonFormula     |> Var.Lens <| id <| (fun v _ -> v)\n\nlet forTId p = getelement >> getChildTId >> (Option.map p ) >> Option.defaultValue false\nlet forCId p = getelement >> getChildCId >> (Option.map p ) >> Option.defaultValue false\n\nlet selNIdO   (sel:Selection) = sel |> Option.map fst\n\nlet removeNodes      p   (nodes: TreeNode seq) = nodes |> Tree.toSeqNode |> Tree.removeNodes (fromNode >> p) |> fromSeqNode\nlet tryFindTreeNode  p   (nodes: TreeNode seq) = nodes |> Tree.toSeqNode |> Tree.tryFind     (fromNode >> p) |> Option.map fromNode\nlet tryFindNode      nid (nodes: TreeNode seq) = nodes |> tryFindTreeNode (fun n -> n.nid = nid)\nlet tryFindSelNode   sel (nodes: TreeNode seq) = sel   |> selNIdO |> Option.bind (swap tryFindNode nodes)\nlet tryFindSelChild  sel (nodes: TreeNode seq) = nodes |> tryFindSelNode sel |> Option.map getelement\nlet tryFindNodeTId   tid (nodes: TreeNode seq) = nodes |> tryFindTreeNode (forTId ((=) tid) )\nlet tryFindNodeCId   cid (nodes: TreeNode seq) = nodes |> tryFindTreeNode (forCId ((=) cid) )\nlet tryFindNodeFId   fid (nodes: TreeNode seq) = model.formulas.TryFindByKey fid |> Option.bind (getidCalc >> swap tryFindNodeCId nodes)\n\nlet selTotIdO (sel:Selection) = model.treeHierarchy.Value |> tryFindSelChild sel |> Option.bind getChildTId\nlet selCalIdO (sel:Selection) = model.treeHierarchy.Value |> tryFindSelChild sel |> Option.bind getChildCId\nlet selForIdO (sel:Selection) =                                              sel |> Option.bind snd\n//let selPathO  (sel:Selection) = match sel with | Some (Path(_                      , p )) -> Some p   | _ -> None\n\nlet currentTotalV = ListModel.currentLens nonTotal       (model.selection.View |> View.Map selTotIdO) model.totals\nlet currentCalcV  = ListModel.currentLens nonCalculation (model.selection.View |> View.Map selCalIdO) model.calculations\nlet currentFormV  = ListModel.currentLens nonFormula     (model.selection.View |> View.Map selForIdO) model.formulas     \n    \nlet isNodeSelected    nid (sel:Selection) = sel |> Option.map (fst >> ((=) nid) ) |> Option.defaultValue false\nlet isNodeFormSelected fid nid (sel:Selection) = sel = Some(nid, Some fid)\n\nlet tryFindTotal  model tid = model.totals      .TryFindByKey tid\nlet tryFindCalc   model cid = model.calculations.TryFindByKey cid\nlet getChildOrder model ch  = match ch with\n                              | Node tid -> tryFindTotal model tid |> Option.map getorder\n                              | Leaf cid -> tryFindCalc  model cid |> Option.map getorder\n//let getChildren   model tid = model.childrenRels.Value\n//                              |> Seq.map        getKey \n//                              |> Seq.filter    (fst >> (=) tid)\n//                              |> Seq.map        snd\n\n//let hasChildren   model tid = getChildren model tid |> Seq.isEmpty |> not\n//let getChildrenOrdered model tid = getChildren model tid //|> Seq.sortBy    (getChildOrder model)\n\n[< Inline >]\nlet inline sortByOrder cs = cs |> Seq.sortBy getorder\n\n//let totalsCalcsWithParent() = \n//    let children = model.childrenRels.Value |> Seq.map (getKey >> snd)\n//    children |> Seq.toArray |> Array.partition (function | Node _ -> true | _ -> false) |> fun (a, b) -> Set a, Set b\n//let inline totalsWithoutParent() = \n//    let totalsWithParent = totalsCalcsWithParent() |> fst\n//    model.totals       |> Seq.filter (getId >> Node >> (swap Set.contains totalsWithParent) >> not) |> sortByOrder\n//let inline calcsWithoutParent () = \n//    let calcsWithParent  = totalsCalcsWithParent() |> snd\n//    model.calculations |> Seq.filter (getId >> Leaf >> (swap Set.contains calcsWithParent ) >> not) |> sortByOrder\n\n//let tryFindParent model ch = model.childrenRels.Value |> Seq.tryPick (fun kvp -> if kvp.Key |> snd = ch then fst kvp.Key |> Some else None )\n\n//let rec getSomePath model p ch = \n//    match tryFindParent model ch with\n//    | Some tid -> getSomePath model (tid :: p) (Node tid)\n//    | None     -> p\n\nlet inline getDimSet objId (objDims:Set<_ * DimId>) =\n    objDims\n    |> Seq.filter (fst >> ((=) objId))\n    |> Seq.map     snd\n    |> Set\n\nlet orderedDims dimIds =\n    model.dimensions\n    |> Seq.filter (getexcludeCube >> not)\n    |> Seq.filter (getId >> swap Seq.contains dimIds )\n    |> Seq.sortBy getorder\n\nlet cubeNameBase prefix dimIds =\n    orderedDims dimIds\n    |> Seq.map getabbreviation\n    |> String.concat \"\"\n    |> ((+) prefix)\n\nlet getDimsCubeO0 cdims cubes cubeDims =\n    cubes |> Seq.tryFind (fun cub -> cubeDims |> getDimSet cub.id = cdims)\n\nlet getDimsCubeO cdims = getDimsCubeO0 cdims model.cubes.Value model.cubeDims.Value\n\nlet getCalcCubeO calId =\n    let cdims = model.calcDims.Value |> getDimSet calId\n    getDimsCubeO cdims\n\nlet createDimsCube cdims n =\n    match getDimsCubeO cdims with\n    | Some cube -> cube\n    | None      -> let cube = newCube()\n                   model.cubeDims.Value <- cdims |> Seq.map (fun did -> cube.id, did) |> Set |> Set.union model.cubeDims.Value\n                   cube\n    |> setcube n\n    |> model.cubes.Add\n\nlet createDimsCubeDef cdims =\n    let nameBase = cubeNameBase model.cubePrefix.Value cdims\n    model.cubes.Value\n    |> Seq.map getcube\n    |> Seq.choose (fun c -> \n        match c with\n        | n when n          = nameBase -> Some -1\n        | n when n.StartsWith nameBase -> n.Substring(nameBase.Length) |> parseInt\n        | _                            -> None\n    )\n    |>(function\n       | similar when Seq.isEmpty similar -> nameBase\n       | similar                          ->\n       similar\n       |> Seq.max\n       |> (+) 1\n       |> string\n       |> (+) nameBase\n      )\n    |> createDimsCube cdims\n\nlet createCubes() =\n    model.calculations.Value\n    |> Seq.map       getId\n    |> Seq.map      (swap getDimSet model.calcDims.Value)\n    |> Seq.distinct\n    |> Seq.filter   (getDimsCubeO >> Option.isNone)\n    |> Seq.iter      createDimsCubeDef\n\nlet setHierarchy (nodes: TreeNode seq) =\n    nodes\n    |> Seq.map (fun n -> parents.Remove n.nid |> ignore ; n)\n    |> Seq.toArray\n    |> model.treeHierarchy.Set\n\nlet reorder() =\n    model.calculations.Value\n    |> Seq.sortBy getorder\n    |> model.calculations.Set\n    model.formulas.Value\n    |> Seq.sortBy (fun f -> model.calculations.TryFindByKey f.idCalc |> Option.map getorder, f.order)\n    |> model.formulas.Set\n    let rec folder (children, noparent, calcs, tots) (n:Tree.Node<_>) =\n        match (n :?> TreeNode).element with\n        | Node tid -> let ch, np, c2, t2 = n.children |> Seq.fold folder ([], noparent, calcs, tots)\n                      let ch2 = List.rev ch\n                      if model.totals      .ContainsKey tid then (n.newChildren ch2 :: children,      np      ,        c2   , tid :: t2  )\n                                                            else (                     children, ch @ np      ,        c2   ,        t2  )\n        | Leaf cid -> if model.calculations.ContainsKey cid then (n                 :: children,      noparent, cid :: calcs,        tots)\n                                                            else (                     children,      noparent,        calcs,        tots)\n    parents.Clear()\n    let nodes, noparent, calcs, tots = model.treeHierarchy.Value |> Seq.fold folder ([], [], [], [])\n    [\n        nodes    |> Seq.rev      |> fromSeqNode\n        noparent |> Seq.rev      |> fromSeqNode\n        model.calculations.Value |> Seq.map getId |> Seq.except calcs |> Seq.map newNodeCalc |> Seq.toArray\n        model.totals      .Value |> Seq.map getId |> Seq.except tots  |> Seq.map newNodeTot  |> Seq.toArray\n    ]\n    |> Seq.collect id\n    |> setHierarchy\n    \nlet parserMsgs = Var.Create \"\"\n\nlet dtypes =   [ \n    DtDataType\n    DtTime\n    DtVersion\n    DtOther    ] \n    \nlet filterDims     : (Dimension seq -> Dimension seq) = Seq.filter (fun d -> dtypes |> Seq.contains d.dimType)\nlet sortDims      (ds:Dimension seq)                  = ds |> Seq.sortBy getorder\nlet filterSortDims : (Dimension seq -> Dimension seq) = filterDims >> sortDims\n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"5d4bba38-c34d-40be-a19a-383bdb85c663"}, {"SnippetId" :"995f98ae-4f13-4225-9d00-9aa3e630058a"}, {"SnippetId" :"9c870b72-8f9a-4e7d-ad81-7f1fd73fdd76"}, {"SnippetId" :"af2b60c6-a99f-433d-b938-f59fefe66c01"}, {"SnippetId" :"ecccc1a6-726e-438a-8804-16063c8a5107"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}, "snpName": "Parse", "snpContent": "type LocationDet =\n| InDimension   of DimId\n| InCalculation of CalcId\n| InGlobalDefs\n| InFormula     of FormId\n| InFormulaDest of FormId\n| InFsCode\n\ntype MsgLocation = {\n    lines    : int\n    indent   : int\n    location : LocationDet\n}\n\nlet codeFS     = Var.Create \"\"\n//let codeJS     = Var.Create \"\"\nlet outputMsgs = Var.Create \"\"\n\nlet appendMsg (var:Var<string>) msg =\n    if isUndefined msg then () else\n    let newM =\n        match var.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n    if newM <> var.Value then\n        var.Value  <- newM\n\nlet setOutMsg msg = outputMsgs.Value <-  msg\nlet addOutMsg msg = appendMsg outputMsgs msg\n\nlet showOutText ps = \n    match ps with\n    | [|       txt |]                      -> setOutMsg <| unbox txt\n    | [| cmd ; txt |] when unbox cmd = \"\"  -> setOutMsg <| unbox txt\n    | [| cmd ; txt |] when unbox cmd = \"+\" -> addOutMsg <| unbox txt\n    | _                                    -> printfn \"error: showOutText %A\" ps\n\nlet getDim  did = model.dimensions  .TryFindByKey did\nlet getCalc cid = model.calculations.TryFindByKey cid\nlet getForm fid = model.formulas    .TryFindByKey fid\n\nlet fixName (c:string) = c.Trim().Replace(\" \", \"_\").Replace(\"-\",\"_\")\n\nlet newDimS  d = sprintf \"let %s = newDim %A %A %A\" (fixName d.dimension) d.dimension d.dimType (if d.excludeCube then \"\" else d.abbreviation), d.id\n\nlet getDims () = model.dimensions.Value |> Seq.sortBy getorder |> Seq.map newDimS\n\nlet dimMeasureName cubeName = model.measurePrefix.Value + (cubeName:string).Substring(1)\nlet cubeMeasureName = getcube >> dimMeasureName\nlet newMeasureDimS = cubeMeasureName >> (fun c -> sprintf \"let %s = newDim %A %A %A\" (fixName c) c DtCalc \"\" )\n\nlet getMeasureDims () =\n    model.cubes.Value\n    |> Seq.map newMeasureDimS\n\nlet getCubeDims cid name =\n    model.cubeDims.Value\n    |> Seq.filter (fst >> ((=) cid))\n    |> Seq.map    (snd >> model.dimensions.FindByKey >> (fun d -> d.dimension))\n    |> Seq.append <| [ dimMeasureName name ]\n    |> String.concat \" ; \"\n\nlet newCubeS c = sprintf \"let %s = newCube %A CtCalc [ %s ] (Some %s)\" (fixName c.cube) c.cube (getCubeDims c.id c.cube) (cubeMeasureName c |> fixName) \nlet getCubes () = model.cubes.Value |> Seq.map newCubeS\n\nlet getCalcCubeName cid = getCalcCubeO cid |> Option.map (getcube >> fixName) |> Option.defaultValue \"(newCube \\\"NOCUBEYET\\\" CtCalc [] None)\" \nlet newCalcS c = sprintf \"let %s = newCalc %s %A %A %A %s\" (fixName c.name) (if c.typeC = Input then \"Input\" else \"Calc\") c.name c.order c.isText (getCalcCubeName c.id), c.id\nlet getCalcs () = model.calculations.Value |> Seq.sortBy getorder |> Seq.map newCalcS\n\nlet getDest fid =\n    model.destinations.Value\n    |> Seq.filter (fun d -> d.idForm = fid)\n    |> Seq.choose (fun d -> getDim d.idDim |> Option.map (fun dim -> sprintf \"%s.[%A]\" dim.dimension d.destination ))\n    |> String.concat \" ; \"\n    |> sprintf \"[ %s ]\"\n\nlet prepare (f:string) =\n    f.Replace(\"@=\", \"&=\").Replace(\"@<\", \"&<\").Replace(\"@>\", \"&>\")\n    |> String.indent 4\n\nlet newFormS0 (c, f) =\n    let txt = prepare f.formula\n    let n   = txt |> Seq.length\n    [ \n        yield  sprintf \"newForm %s %s (\" (fixName c.name) (if f.typeF = Base then \"ForBase\" else \"ForConsolidated\")\n        yield! txt\n        yield  sprintf \") %s %A %A\"     (getDest f.id)  f.order (txt |> Seq.map String.trim |> Seq.map (fun s -> s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\\"\", \"\\\\\\\"\")) |> String.concat \" \")\n    ]\n  , { lines = n + 2 ; indent = 4 ; location = InFormula f.id}\n\nlet newFormS f =\n    model.calculations.TryFindByKey f.idCalc\n    |> Option.map (fun c -> newFormS0 (c, f) |> fun (s, l) -> s |> String.concat \"\\n\", l)\n\nlet getForms () =\n    model.calculations.Value\n    |> Seq.sortBy getorder\n    |> Seq.collect (fun c -> \n        model.formulas.Value\n        |> Seq.filter (fun f -> f.idCalc = c.id)\n        |> Seq.sortBy getorder\n        |> Seq.map    (fun f -> c, f)\n    )\n    |> Seq.map newFormS0\n\nlet preface server =\n        sprintf \"\"\"\n        #nowarn \"86\"\n        #r @\"..\\CalculationModelDll\\CalculationModelDll.dll\"\n        open FSSGlobal.CalculationModel\n        open CalculationModel\n        open CalculationSyntax\n        open InitModel\n        \n        {\n            modId           = ModId <| System.Guid.NewGuid()\n            server          = @%A\n            actualElem      = \"Actual\"\n            modCubes        = [| |]\n            modDims         = [| |]\n            modCalculations = [| |]\n        } |> setInitModel\n            \"\"\" server\n        |> String.unindent\n\nlet getFSCode () =\n    createCubes()\n    let calcModel  = preface        model.server.Value\n    let dims       = getDims        ()\n    let mdims      = getMeasureDims ()\n    let cubes      = getCubes       ()\n    let calcs      = getCalcs       ()\n    let forms      = getForms       ()\n    let globalDefs = model.globalDefs.Value.Split '\\n'\n    let lines = seq [\n                    yield! calcModel\n                    yield! dims  |> Seq.map     fst\n                    yield! mdims\n                    yield  \"addDims()\"\n                    yield! cubes\n                    yield  \"addCubes()\"\n                    yield! calcs |> Seq.map     fst\n                    yield  \"addCalcs()\"\n                    yield! globalDefs\n                    yield! forms |> Seq.collect fst\n                    yield  \"addFrms()\"\n                ]\n    let code = lines |> String.concat \"\\n\"\n    codeFS.Value <- code\n    let locs  = seq [\n                    yield                          { lines = calcModel  |> Seq.length ; indent = 0 ; location = InFsCode          }\n                    for (_, did) in  dims do yield { lines = 1                        ; indent = 4 ; location = InDimension   did }\n                    for  _       in mdims do yield { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    for  _       in cubes do yield { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    for (_, cid) in calcs do yield { lines = 1                        ; indent = 4 ; location = InCalculation cid }\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                    yield                          { lines = globalDefs |> Seq.length ; indent = 0 ; location = InGlobalDefs      }\n                    for (_, fsd) in forms do yield fsd\n                    yield                          { lines = 1                        ; indent = 0 ; location = InFsCode          }\n                ]\n    code, locs\n    \nlet getFSCodeA = getFSCode >> ignore    \n\nlet adaptMessage locs (lf:int) (cf:int) (lt:int) (ct:int) msg =\n    locs \n    |> Seq.mapFold (fun  from  l  -> (from, l ), from + l.lines) 0\n    |> fst\n    |> Seq.tryFind (fun (from, l) -> lf - 1 >= from && lf - 1 < from + l.lines)\n    |> Option.bind  (fun (from, l) -> \n        match l.location with \n        | InDimension   did -> getDim  did      |> Option.map (fun dim -> sprintf \"%s: %A. %A\"                     dim.dimension                                                            msg did )\n        | InCalculation cid -> getCalc cid      |> Option.map (fun clc -> sprintf \"%s: %A. %A\"                     clc.name                                                                 msg cid )\n        | InFormulaDest fid -> getForm fid      |> Option.bind(fun f   ->\n                               getCalc f.idCalc |> Option.map (fun clc -> sprintf \"%s: %A. %A\"                     clc.name                                                                 msg fid ))\n        | InFormula     fid -> getForm fid      |> Option.bind(fun f   ->\n                               getCalc f.idCalc |> Option.map (fun clc -> sprintf \"%s: (%d,%d) - (%d,%d): %A. %A\"  clc.name (lf - 1 - from) (cf - l.indent) (lt - 1 - from) (ct - l.indent) msg fid ))\n        | InFsCode          -> Some                           (           sprintf \"F# Code (%d,%d) - (%d,%d): %A.\"           lf              cf              lt              ct             msg     )\n        | InGlobalDefs      -> Some                           (           sprintf \"Global  (%d,%d) - (%d,%d): %A.\"          (lf     - from) (cf - l.indent) (lt     - from) (ct - l.indent) msg     )\n    )\n    |> Option.defaultWith (fun () -> sprintf \"%d %d - %d %d %s\" lf cf lt ct msg)\n    \nlet adaptMessages locs ms =\n    let rex = \"\"\".*\\((\\d+),(\\d+)\\) - \\((\\d+),(\\d+)\\) ([^\"]*?)\"(?:\\n|$)\"\"\"\n    match ms with\n    | REGEX rex \"g\" m ->    m\n    |               m -> [| m |]\n    |> Array.map (\n        function\n        | REGEX rex \"\" [| _ ; lf ; cf ; lt ; ct ; msg |] -> adaptMessage locs (int lf) (int cf) (int lt) (int ct) msg \n        | o                                              -> o\n    )\n\nlet autoCompleteClient = FSAutoCompleteIntermediary.FSAutoCompleteIntermediaryClient(\"RuleEditor\")//, endPoint = JS.Window.Location.Href)\n\n\n//let goto codeId line col =\n//    async {\n//        currentCodeSnippetId.Value <- codeId\n//        CodeSnippet.FetchO codeId |> Option.iter expandParents\n//        do! Async.Sleep 200\n//        codeMirror.editorO \n//        |> Option.iter (fun ed -> \n//            ed.SetCursor(line - 1, col - 1) \n//            ed.Focus()\n//        )\n//    } |> Async.Start\n\nlet rexGlobal =      \"\"\"(Global)  \\(\"\"\"  \nlet rexTotId  = \"\"\"\\\"\\. (TotId) \"\"\"  + \"\\\"\" + rexGuid\nlet rexCalcId = \"\"\"\\\"\\. (CalcId) \"\"\" + \"\\\"\" + rexGuid\nlet rexFormId = \"\"\"\\\"\\. (FormId) \"\"\" + \"\\\"\" + rexGuid\nlet rexDimId  = \"\"\"\\\"\\. (DimId) \"\"\"  + \"\\\"\" + rexGuid\n\n\nlet mapSeqCached0 map f (model:ListModel<_, _>) =\n    model.View\n    |> View.Map map\n    |> View.MapSeqCachedBy model.Key  (fun elem ->\n        model.Key elem |> model.TryFindByKeyAsView |> View.Map f\n    )\n\nlet mapSeqCached  map f (model:ListModel<_, _>) = mapSeqCached0 map (Option.map  f) model\nlet bindSeqCached map f (model:ListModel<_, _>) = mapSeqCached0 map (Option.bind f) model\n\nlet loc l i lc = { lines = l ; indent = i ; location = lc }\nlet [< Inline >] inline valsGet       vals = vals |> Seq.choose View.TryGet |> Seq.choose id\nlet [< Inline >] inline valsToString  vals = vals |> valsGet |> Seq.map fst |> String.concat \"\\n\"\nlet [< Inline >] inline valsToInXs x  vals = vals |> valsGet |> Seq.map snd |> Seq.map (x >> loc 1 4)\nlet [< Inline >] inline valsToInForms vals = vals |> valsGet |> Seq.map snd                           \nlet [< Inline >] inline valsToInDims  vals = vals |> valsToInXs InDimension\nlet [< Inline >] inline valsToInCalcs vals = vals |> valsToInXs InCalculation\nlet locg txt    = (txt:string)               , seq [ loc (txt.Split '\\n' |> Seq.length) 0 InGlobalDefs ]\nlet locn txts   =  txts |> String.concat \"\\n\", seq [ loc (txts           |> Seq.length) 0 InFsCode     ]\nlet loc1 txt    = (txt:string)               , seq [ loc  1                             0 InFsCode     ]\nlet  dimLocs ds = valsToString ds            , valsToInDims  ds\nlet calcLocs cs = valsToString cs            , valsToInCalcs cs\nlet formLocs fs = valsToString fs            , valsToInForms fs\n\nlet concatStrs a b c d e f g = \n    [ yield a\n      yield b\n      yield c\n      yield loc1 \"addDims()\"\n      yield d\n      yield loc1 \"addCubes()\"\n      yield e\n      yield loc1 \"addCalcs()\"\n      yield f\n      yield g\n      yield loc1 \"addFrms()\" \n    ] \n    |> List.unzip\n    |> fun (ts, ls) -> ts |> String.concat \"\\n\", Seq.collect id ls\n    \nlet (<*>) a b = View.Apply a b\n\nlet fsCode() =\n    let newDimsV   = model.dimensions         |> mapSeqCached   (Seq.sortBy getorder) newDimS\n    let newMDimsV  = model.cubes              |> mapSeqCached   id                    newMeasureDimS\n    let newCubesV  = model.cubes              |> mapSeqCached   id                    newCubeS\n    let newCalcsV  = model.calculations       |> mapSeqCached   id                    newCalcS\n    let newFormsV  = model.formulas           |> bindSeqCached  id                    newFormS\n    let prefaceV   = model.server.View        |> View.Map     (                                                  preface >> locn  )\n    let newDimsSV  = model.dimensions  .View  |> View.MapAsync(fun _ -> newDimsV  |> View.GetAsync |> Async.map          dimLocs  )\n    let newMDimsSV = model.cubes       .View  |> View.MapAsync(fun _ -> newMDimsV |> View.GetAsync |> Async.map (valsGet >> locn) )\n    let newCubesSV = model.cubes       .View  |> View.MapAsync(fun _ -> newCubesV |> View.GetAsync |> Async.map (valsGet >> locn) )\n    let newCalcsSV = model.calculations.View  |> View.MapAsync(fun _ -> newCalcsV |> View.GetAsync |> Async.map         calcLocs  )\n    let globalDefV = model.globalDefs  .View  |> View.Map                                                                   locg\n    let newFormsSV = model.formulas    .View  |> View.MapAsync(fun _ -> newFormsV |> View.GetAsync |> Async.map         formLocs  )\n    View.Const concatStrs\n    <*> prefaceV\n    <*> newDimsSV \n    <*> newMDimsSV \n    <*> newCubesSV \n    <*> newCalcsSV \n    <*> globalDefV\n    <*> newFormsSV \n\nlet cancellationTokenSourceO = ref None\nlet getJSCode() =\n    let asy = async {\n        parserMsgs.Value         <- \"Parsing...\\n\" + String.skipFirstLine parserMsgs.Value\n        do!                         Async.Sleep 1000\n        let! fs, locs             = fsCode() |> View.GetAsync\n        let! res0                 = autoCompleteClient.Parse(\"RuleEditor.fsx\", fs)\n        let  res                  = adaptMessages locs res0 |> String.concat \"\\n\"\n        cancellationTokenSourceO := None\n        parserMsgs.Value         <- \"Parsed!\\n\" + res\n        codeFS.Value             <- fs\n     }\n    !cancellationTokenSourceO |> Option.iter (fun (tokenSource:System.Threading.CancellationTokenSource) -> tokenSource.Cancel())\n    cancellationTokenSourceO := Some <| new System.Threading.CancellationTokenSource()\n    Async.Start(asy, cancellationToken = (!cancellationTokenSourceO).Value.Token)\n    \n    \nlet getJSCodeA = getJSCode >> ignore    \n\nView.Const (fun a b c d e f g h i j k l m -> ())\n<*> model.dimensions   .View \n<*> model.cubes        .View \n<*> model.calculations .View \n<*> model.formulas     .View \n<*> model.totals       .View\n<*> model.destinations .View\n<*> model.calcDims     .View\n<*> model.cubeDims     .View\n<*> model.globalDefs   .View\n<*> model.server       .View\n<*> model.cubePrefix   .View\n<*> model.measurePrefix.View\n<*> model.treeHierarchy.View\n|> View.Sink getJSCode\n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, {"SnippetId" :"466e6783-0751-48d5-b79b-165aaa7d2173"}, {"SnippetId" :"68511118-6a1b-4ae9-aea0-942b6073ff67"}, {"SnippetId" :"9cc5cba5-719f-4e72-9216-be14381557bf"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"72c6586f-0129-40d8-8c3f-8e81325a4d0f"}, "snpName": "codemirror", "snpContent": "[<NoComparison ; NoEquality>]\ntype KeyMapAutoComplete = { \n    F2              : Template.CodeMirrorEditor -> unit \n    LeftDoubleClick : Template.CodeMirrorEditor -> unit\n    ``Ctrl-Space``  : Template.CodeMirrorEditor -> unit\n    ``.``           : Template.CodeMirrorEditor -> unit\n}\n\nlet codeMirrorRender (var:Var<string>) (annotationsVO: View<LintResponse []> option) =\n\n    let setDirtyCond() = ()\n    let showToolTip _  = ()\n    let getHints    _  = ()\n    \n    let codeMirror =\n        Template.CodeMirror.New(var)\n            .OnChange(setDirtyCond)\n            .OnRender(fun ed ->\n              ed.AddKeyMap({  F2              = showToolTip            \n                              LeftDoubleClick = showToolTip\n                              ``Ctrl-Space``  = Template.showHints ed getHints false\n                              ``.``           = (fun _ -> ed.ReplaceSelection(\".\", \"end\"))\n                                                >> Template.showHints ed getHints false\n                           })\n              ed.SetOption(\"mode\" , \"fsharp\"  )\n              ed.SetOption(\"theme\", \"rubyblue\")\n              annotationsVO \n              |> Option.iter(fun annotationsV ->\n                  View.Sink (fun _ -> ed?performLint() |> ignore) annotationsV\n                  Template.setLint ed (fun (_t, send, _o, _ed) -> annotationsV |> View.Get send)\n              )\n            )\n            .Style(\"height: 100%\")\n    \n    let refreshCodeMirror() = codeMirror.editorO |> Option.iter (fun cm -> cm.Refresh())\n    \n    let delayedRefreshCM delay =\n        async {\n            do! Async.Sleep delay\n            refreshCodeMirror() \n        } |> Async.Start\n        \n    codeMirror.Render.AddChildren [ \n        htmlElement     \"menu\" [  // does not work anymore. support for this was dropped by Chrome\n            ``type``    \"context\"\n            Id          \"right-menu\"\n        ]\n        htmlAttribute \"contextmenu\" \"right-menu\"\n    ]\n\nlet filterGlobal msgs =\n    let rex  = \"\"\"Global  \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\.\"\"\" //\"\n    match msgs with\n    | REGEX rex \"g\" m -> m\n    | _               -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rex \"\" [| _ ; fl;     fc;     tl;     tc; msg |] \n                 -> Some (int fl, int fc, int tl, int tc, msg)\n        | _      -> None\n    )\n    |> Array.map (fun (fl, fc, tl, tc, msg) ->\n            { Template.LintResponse.message  = msg\n              Template.LintResponse.severity = \"error\"\n              Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1) \n              Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1)\n            }\n      )        \n\nlet rexFormula   = \"\"\"\\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\)\\: \"([^\"]+?)\"\\. FormId \"\"\" + \"\\\"\" + rexGuid // \"\nlet filterFormula msgs fidO =\n    match msgs with\n    | REGEX rexFormula \"g\" m -> m\n    | _                 -> [||]\n    |> Array.choose (fun v ->\n        match v with\n        | REGEX rexFormula \"\" [| _ ; fl;     fc;     tl;     tc; msg; guid |] when fidO = Some(guid |> System.Guid |> FormId) \n                        -> Some (int fl, int fc, int tl, int tc, msg)\n        | _             -> None\n    )\n    |> Array.map (fun (fl, fc, tl, tc, msg) ->\n            { Template.LintResponse.message  = msg\n              Template.LintResponse.severity = \"error\"\n              Template.LintResponse.from     = Template.cmPos(fl - 1, fc - 1) \n              Template.LintResponse.``to``   = Template.cmPos(tl - 1, tc - 1)\n            }\n      )        \n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"18d8153d-422c-42f6-8266-9a9d854bd6a1"}, {"SnippetId" :"218507eb-4a87-4c11-b5d9-53a2213dd36a"}, {"SnippetId" :"4180353c-9dc5-438d-862d-851539b02075"}, {"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, {"SnippetId" :"a05dd36e-a15e-4394-8013-128e21e69574"}, {"SnippetId" :"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}, {"SnippetId" :"b03ba35c-a03c-4bbe-a373-1ce551524e56"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"dd65606a-9194-4699-8c83-25dd52970a44"}, "snpName": "renderers", "snpContent": "let levelitem                    = ``class`` \"level-item\"\nlet onClick                    f = on.click (fun _ -> f) |> SomeAttr\nlet check                      v = if v then \"\" else \"\"\nlet flipO (vo: Var<bool option>) = vo.Value |> Option.iter (fun v -> vo.Value <- Some <| not v)\nlet flip  (vv: Var<bool       >) = vv.Value |>             (fun v -> vv.Value <-         not v)\nlet disabled                   v = addChildren [SomeAttr  <| attr.disabledDynPred (View.Const \"\") (Val.toView v)]\nlet falseV                       = Val.Constant false\n\nlet tdl h = td [ levelitem ; h] \n\nopen WebSharper.UI.Templating\nlet [< Literal >] TemplatesFileName = @\"D:\\Abe\\CIPHERWorkspace\\FSharpStation\\bin\\Compiled\\RuleEditor\\website\\Templates.html\"\ntype TemplateLib  = Template< TemplatesFileName, ClientLoad.FromDocument, ServerLoad.WhenChanged, LegacyMode.New>\n\n[< Inline >]\nlet inline filterSortForms cid fs = fs |> Seq.filter (getidCalc >> ((=) cid)) //|> sortByOrder\n\n//let listNodesx (totals: seq<Total>) (calcs: seq<Calculation>)  =\n//    Console.Log \"listNodes\"\n//    let totalsWithParent\n//      , calcsWithParent     = totalsCalcsWithParent()\n//    let totalsWithoutParent = totals   |> Seq.filter (getId >> Node >> (swap Set.contains totalsWithParent) >> not) //|> sortByOrder\n//    let calcsWithoutParent  = calcs    |> Seq.filter (getId >> Leaf >> (swap Set.contains calcsWithParent ) >> not) //|> sortByOrder\n//    let rec totalChildrenIds tid path =\n//        let tot = totals |> Seq.find (fun t -> t.id = tid)\n//        let npath = tid :: path\n//        seq {\n//            yield Node tid, path\n//            if model.collapsed.TryFindByKey (tid, path) |> Option.isNone then\n//                for ch in getChildrenOrdered model tid do \n//                    match ch with\n//                    | Node chid -> yield! totalChildrenIds chid npath\n//                    | Leaf _    -> yield  ch, npath\n//        }\n//    seq {\n//        for tot  in totalsWithoutParent do yield! totalChildrenIds tot.id []\n//        for calc in calcsWithoutParent  do yield  Leaf calc.id,           []\n//    }\n\ntype DragInfo = \n    | DragNone\n    | DragNode of TreeNodeId\n    | DragForm of Calculation * Formula\n\nlet mutable drag = DragNone\n\nlet [< Inline >] inline moveItem dropId elems dragItem =\n    elems\n    |> Seq.filter (getId >> ((<>) (getId dragItem)) )\n    |> Seq.toArray\n    |> (fun s -> let fst, snd =  s |> Array.splitAt (s |> Array.findIndex (getId >> ((=) dropId)) )\n                 [fst ; [| dragItem |] ; snd])\n    |> Seq.collect id\n\nlet [< Inline >] inline moveItemInListModel dropId (lm:ListModel<_, _>) getDragItem = getDragItem drag |> Option.iter( moveItem dropId lm.Value >> lm.Set )\n\nlet rowTreeNode processor (totals: ListModel<_, _>) (calcs: ListModel<_, _>) (childLevel: View<TreeNodeId * Child * int>) =\n    let nid, child, level = childLevel |> View.TryGet |> Option.get\n    let depth  = sprintf \"%dem\" level\n    let isSelV = model.selection.View |> View.Map (isNodeSelected nid)\n    let getDragNIdO = function | DragNode dragnid when dragnid <> nid -> Some dragnid | _ -> None\n    let calcRow cid =\n        let calcV        = calcs |> ListModel.lensDef nonCalculation cid\n        TemplateLib.CalculationRow()\n               .SelectedMark( \"\" )\n               .Selected(     selectedString \"selected\" isSelV )\n               .Indent(       depth                            )\n               .CalcName(     Lens calcV.V.name      )\n               .Format(       Lens calcV.V.format    )\n               .IsText(       Lens calcV.V.isText    )\n               .IsBalance(    Lens calcV.V.isBalance )\n               .OrderCalc(    Lens calcV.V.order     )\n               .CalcType(    (Lens calcV.V.typeC).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Calc\" -> Calc | _ -> Input) )\n               .Remove(       fun _ -> RemoveCalculation cid |> processor        )\n               .AfterRender(  fun (e:Dom.Element) -> isSelV |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n               .Select(       fun _ -> isSelV |> View.Get (fun s -> if not s then SelectNode nid |> processor)  )\n               .Formulas(     model.formulas  |> ListModel.docLensMapView (filterSortForms cid) (fun fid formV ->\n                               let selCalcV = model.selection.View    |> View.Map (isNodeFormSelected fid nid)\n                               let formFor  = model.destinations.View \n                                              |> View.Map (Seq.filter (fun dest -> dest.idForm = fid) \n                                                           >> Seq.map (fun dest -> dest.destination)\n                                                           >> String.concat \", \")\n                               let getDragFormO = function | DragForm (calc, dragform) when calc.id = cid  && fid <> dragform.id -> Some dragform | _ -> None\n                               TemplateLib.FormulaRow()\n                                   .SelectedMark( selectedString \">\"        selCalcV )\n                                   .Selected(     selectedString \"selected\" selCalcV )\n                                   .Formula(      Lens formV.V.formula               )\n                                   .FormulaFor(   formFor                            )\n                                   .FormType(    (Lens formV.V.typeF).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Base\" -> Base |\"Consolidated\" -> Consolidated | _ -> All  ) )\n                                   .Remove(       fun _ -> RemoveFormula fid |> processor        )\n                                   .AfterRender(  fun (e:Dom.Element) -> selCalcV |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n                                   .Select(       fun _ -> SelectFormNode(fid, nid) |> processor                                        )\n                                   .Drag(         fun ev -> drag <- DragForm(calcV.Value, formV.Value) ; ev.Event.StopPropagation()          )\n                                   .DragOver(     fun ev -> if (getDragFormO drag).IsSome then           ev.Event.PreventDefault ()          )\n                                   .Drop(         fun ev -> ev.Event.PreventDefault() ; moveItemInListModel fid model.formulas getDragFormO  )\n                                   .Doc()\n                             )\n               )\n               .Drag(         fun ev -> drag <- DragNode nid             ; ev.Event.StopPropagation()                        )\n               .DragOver(     fun ev -> if (getDragNIdO drag).IsSome then ev.Event.PreventDefault ()                         )\n               .Drop(         fun ev -> ev.Event.PreventDefault() ; getDragNIdO drag |> Option.iter(fun fr -> MoveNode(true, fr, nid) |> processor ) )\n               .Doc()\n    \n    let totalRow tid =\n        let totV         = totals |> ListModel.lensDef nonTotal tid\n        let nodeV        = model.treeHierarchy.View |> View.Map (tryFindNode nid)\n        let markV        = nodeV |> View.Map (Option.map (fun node -> if node.expanded then \"-\" else \"+\") >> Option.defaultValue \"*\")\n        TemplateLib.TotalRow()\n            .SelectedMark( markV                                           )\n            .Selected(     selectedString \"selected\" isSelV                )\n            .Indent(       depth                                           )\n            .TotName(      Lens totV.V.totName                             )\n            .Format(       Lens totV.V.format                              )\n            .OrderTot(     Lens totV.V.order                               )\n            .Remove(       fun _ -> RemoveTotal tid           |> processor )\n            .Select(       fun _ -> SelectNode  nid           |> processor )\n            .Collapse(     fun _ -> nodeV |> View.Get (Option.iter (fun node -> (not node.expanded, node.nid) |> ExpandNode |> processor)) )\n            .Drag(         fun ev -> drag <- DragNode nid             ; ev.Event.StopPropagation()                        )\n            .DragOver(     fun ev -> if (getDragNIdO drag).IsSome then ev.Event.PreventDefault ()                         )\n            .Drop(         fun ev -> ev.Event.PreventDefault() ; getDragNIdO drag |> Option.iter(fun fr -> MoveNode(true, fr, nid) |> processor ) )\n            .AfterRender(  fun (e:Dom.Element) -> isSelV |> Val.sink (fun s -> if s then e?scrollIntoViewIfNeeded()) )\n            .Doc()\n\n    match child with\n    | Node tid -> totalRow tid\n    | Leaf cid -> calcRow  cid\n\nlet [<Inline>] inline getIds ls = ls |> Seq.map getId |> Seq.toArray\n\nlet renderTable processor (model:Model) =\n    let totalIds = View.Map getIds model.totals      .View |> View.consistent\n    let calcIds  = View.Map getIds model.calculations.View |> View.consistent\n    let ( <*> )  = View.Apply\n    TemplateLib.CalculationTable()\n        .TBody( \n//            View.Const (fun _ _ _ _ -> listNodes model.totals.Value model.calculations.Value) \n//                <*> totalIds <*> calcIds <*> refreshView <*> model.collapsed.View\n            model.treeHierarchy.View\n            |> View.Map (Seq.map Tree.toNode >> Tree.listNodes 0 >> (Seq.map (fun (tn,l) -> tn.Id, (fromNode tn).element, l) ) )\n            |> Doc.BindSeqCachedView (rowTreeNode processor model.totals model.calculations)\n         )\n        .Doc() |> someElt\n\nlet renderDetail processor (model: Model) =\n    let noCalcV () = attr.disabledDynPred (View.Const \"\") (V(currentCalcV.V.id = nonCalculation.id))\n    let noFormV () = attr.disabledDynPred (View.Const \"\") (V(currentFormV.V.id = nonFormula.id    ))\n    let getAnnot = model.selection.View |> View.Map selForIdO |> View.Map2 filterFormula parserMsgs.View |> View.consistent\n    TemplateLib.FormulaDetail()\n        .CalcName(    Lens currentCalcV.V.name      )\n        .Format(      Lens currentCalcV.V.format    )\n        .IsText(      Lens currentCalcV.V.isText    )\n        .IsBalance(   Lens currentCalcV.V.isBalance )\n        .AlsoActual(  Lens currentFormV.V.alsoActual)\n        .CalcType(   (Lens currentCalcV.V.typeC).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Calc\" -> Calc                                 | _ -> Input) )\n        .FormType(   (Lens currentFormV.V.typeF).Lens (sprintf \"%A\") (fun _ s -> match s with |\"Base\" -> Base |\"Consolidated\" -> Consolidated | _ -> All  ) )\n        .Formula(     codeMirrorRender(Lens currentFormV.V.formula) (Some getAnnot) |> renderDoc)\n        .DisableCalc1(noCalcV())\n        .DisableCalc2(noCalcV())\n        .DisableCalc3(noCalcV())\n        .DisableCalc4(noCalcV())\n        .DisableCalc5(noCalcV())\n        .DisableCalc6(noCalcV())\n        .DisableForm1(noFormV())\n        .DisableForm2(noFormV())\n        .AddFormula(  fun _ -> (V currentCalcV.V.id) |> View.Get (AddFormula >> processor) )\n        .Doc() |> SomeDoc\n    \n\nlet renderDimensions processor model =\n    div [\n      TemplateLib.DimensionTable()\n        .TBody(\n            model.dimensions |> ListModel.docLensMapView filterSortDims (fun did dimV ->\n                let selDim = Val.map ((=) (Some did)) model.selectedDim\n                TemplateLib.DimensionRow()\n                    .Name(          Lens dimV.V.dimension     )\n                    .Abbreviation(  Lens dimV.V.abbreviation  )\n                    .Order(         Lens dimV.V.order         )\n                    .Type(         (Lens dimV.V.dimType       ).Lens (sprintf \"%A\" >> fun s -> s.[2..]) (fun _ s -> match s with |\"DataType\" -> DtDataType |\"Time\" -> DtTime |\"Version\" -> DtVersion | _ -> DtOther) )\n                    .ExcludeName(   Lens dimV.V.excludeCube   )\n                    .IncludeFreeze( Lens dimV.V.includeFreeze )\n                    .Remove(        fun _ -> RemoveDimension did |> processor )\n                    .Select(        fun _ -> SelectDimension did |> processor )\n                    .Doc()        \n            )\n        )\n        .NewDimension(fun _ -> AddDimension |> processor)\n        .Doc() |> someElt\n    ]\n\nlet renderDimsSelected _processor model =\n    let setDestination (d:Destination) (fid, did) = \n        if d.destination.Trim() <> \"\" \n        then model.destinations.Add { idForm = fid ; idDim = did ; destination = d.destination }\n        else model.destinations.RemoveByKey (fid, did)\n    let currDimsV = View.Do {\n        let! calc      = currentCalcV.View\n        let! calcDims  = model.calcDims  .View\n        return getDimSet calc.id calcDims\n    }\n    let cubeNameVO = View.Do {\n        let! cubeDims  = model.cubeDims  .View\n        let! cubes     = model.cubes     .View\n        let! currDims  = currDimsV\n        return  getDimsCubeO0 currDims cubes cubeDims |> Option.map getcube\n    }        \n    let cubeBaseNameV = View.Do {\n        let! prefix    = model.cubePrefix.View\n        let! currDims  = currDimsV\n        return cubeNameBase prefix currDims\n    }        \n    let cubePlaceholderV = cubeNameVO |> View.Bind (Option.map View.Const >> Option.defaultWith(fun () -> cubeBaseNameV) )\n    let cubeNameV        = cubeNameVO |> View.Map  (Option.defaultValue \"\")\n    let setCubeName    n = \n        selCalIdO model.selection.Value \n        |> Option.iter(fun cid ->\n            let currDims = getDimSet cid model.calcDims.Value\n            if (n:string).Trim() = \"\" then\n                let cubes = model.cubes.Value |> Seq.map getId |> Seq.filter (swap getDimSet model.cubeDims.Value >> ((=) currDims) )\n                cubes |> Seq.iter model.cubes.RemoveByKey\n                model.cubeDims.Value <- model.cubeDims.Value |> Seq.filter (fun (cid, _) -> cubes |> Seq.contains cid |> not) |> Set\n            else\n                createDimsCube currDims n\n        )\n    div [\n      TemplateLib.DimsSelected()\n        .CubeName(        Var.Make cubeNameV setCubeName)\n        .PossibleCubeName(cubePlaceholderV)\n        .TBody(\n            model.dimensions |> ListModel.docLensMapView filterSortDims (fun did dimV ->\n                let currDest = currentFormV.Lens (fun form -> if form.id = nonFormula.id then None else Some(form.id, did)) (fun v _ -> v)\n                let destV    = model.destinations |> ListModel.currentLensUpd nonDestination currDest setDestination\n                let checkV   = model.calcDims     |> Var.lensView \n                                (fun cds   -> model.selection.Value |> selCalIdO |> Option.map (fun cid -> cds |> Set.contains(cid, did)                         ) |> Option.defaultValue false ) \n                                (fun cds v -> model.selection.Value |> selCalIdO |> Option.map (fun cid -> cds |> (if v then Set.add else Set.remove) (cid, did) ) |> Option.defaultValue cds   )\n                                model.selection.View                                     \n                let visibFor = V(if currentFormV.V.id <> nonFormula.id && checkV.V then \"\" else \"Hidden\")\n                TemplateLib.DimSelectedRow()\n                    .Dimension(    V dimV.V.dimension )\n                    .DimensionCheck( checkV                                )\n                    .Destination(    Lens destV.V.destination              )\n                    .Hidden(         visibFor                              )\n                    .Doc()\n            )\n        )\n        .Doc() |> someElt\n    ]\n    \nlet renderGlobalDefs _processor model =\n    let getAnnot = View.Map filterGlobal parserMsgs.View |> View.consistent\n    div [  \n//        TemplateLib.GlobalText()\n//            .Var(model.globalDefs)\n//            .Doc() |> SomeDoc\n        codeMirrorRender model.globalDefs (Some getAnnot)\n    ]\n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, {"SnippetId" :"657c8f34-c917-4659-825d-c9ead206efcf"}, {"SnippetId" :"72c6586f-0129-40d8-8c3f-8e81325a4d0f"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9d50c3d6-b8b4-4e9e-b4d4-78b864810b65"}, "snpName": "WebComponent Splitter", "snpContent": "[< Inline \"\"\"return Reflect.construct($global.HTMLElement, [], this.__proto__.constructor);\"\"\" >]\nlet ReflectConstruct () = X<_>\n\n[< Inline \"\"\"Object.setPrototypeOf($_c.prototype, $global.HTMLElement.prototype);\n             Object.setPrototypeOf($_c, $global.HTMLElement);\n             Object.setPrototypeOf($_o.prototype, $_c.prototype);\n             $global.customElements.define($_nm, $_o)\"\"\" >]\nlet defineWebComponent _nm _o _c = X<_>\n\nlet [< Inline >] inline slot     ch = htmlElement   \"slot\" ch\nlet [< Inline >] inline slotName v  = htmlAttribute \"slot\" v\nlet [< Inline >] inline name     v  = htmlAttribute \"name\" v\n\nopen Template\n\ntype WcSplitterT () =\n    let mutable added = false\n    do printfn \"WcSplitterT initializer\"\n    [< Inline \"\"\"$global.FSSGlobal.CalcEditor.WcSplitterT.New\"\"\" >] static member NewPointer = X<_>\n    static member Constructor() = \n        let this = ReflectConstruct()\n        WcSplitterT.NewPointer?call this\n        this\n    member this.connectedCallback() = \n        printfn \"my-el connected %A %A\" added this?outerHTML\n        if not added then\n            let el : Dom.Element = this |> box |> unbox\n            let shadowRoot  = el.AttachShadow (Dom.ShadowRootInit Dom.ShadowRootMode.Open)\n            let elsh        = JS.Document.CreateElement \"div\"\n            let minV        = if el.HasAttribute \"min\"      then el.GetAttribute \"min\"   |> JS.ParseFloat else  4.0\n            let maxV        = if el.HasAttribute \"max\"      then el.GetAttribute \"max\"   |> JS.ParseFloat else 96.0\n            let value       =(if el.HasAttribute \"value\"    then el.GetAttribute \"value\" |> JS.ParseFloat else 50.0)|> Var.Create\n            let first       =    el.HasAttribute \"second\"   |> not\n            let vertical    =    el.HasAttribute \"vertical\"\n            let size        = ref        (0.0, 0.0)\n            let padding     = ref         0.0\n            let gap         = Var.Create  0.0\n            let sizeCalc (sh:Dom.Element) : float * float =\n                let p1, p2, gp = if vertical then \"padding-left\", \"padding-right\" , \"grid-column-gap\"\n                                             else \"padding-top\" , \"padding-bottom\", \"grid-row-gap\" \n                let pt   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p1 |> (+) \"0\" |> JS.ParseFloat\n                let pb   = JQuery.JQuery(sh.ParentElement.ParentElement).Css p2 |> (+) \"0\" |> JS.ParseFloat\n                gap.Set   (JQuery.JQuery(sh.ParentElement.ParentElement).Css gp |> (+) \"0\" |> JS.ParseFloat)\n                padding := pt + pb\n                el.GetBoundingClientRect() \n                |> fun r -> \n                     match vertical, first with\n                     | true , true  ->  r.Width , r.Height \n                     | true , false -> -r.Width , r.Height\n                     | false, true  ->  r.Height, r.Width\n                     | false, false -> -r.Height, r.Width\n            let dragging : bool               ref = ref false   \n            let startP   : float              ref = ref 0.0\n            let start    : float              ref = ref 0.0\n            let domElem  : Dom.Element option ref = ref None                 \n            let mouseCoord (ev: Dom.MouseEvent) = if vertical then float ev.ClientX else float ev.ClientY\n            let drag (ev: Dom.Event) =\n                ev :?> Dom.MouseEvent\n                |> mouseCoord\n                |> fun m   -> (m - !start) * 100.0 / (fst !size) + !startP\n                |> fun v   -> value.Value <- min maxV (max minV v)\n               \n            let rec finishDragging (_: Dom.Event) =\n                if !dragging then\n                    dragging := false\n                    JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                    JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false)\n            let startDragging (ev: Dom.MouseEvent) =\n                if not !dragging then\n                    dragging := true\n                    startP   := value.Value\n                    start    := mouseCoord ev\n                    size     := !domElem |> Option.map sizeCalc |> Option.defaultValue (100.0, 500.0)\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                //div [\n                //    SomeAttr  <| on.mouseDown startDragging\n                //    SomeAttr  <| on.afterRender (fun el -> domElem := Some el; size := sizeCalc vertical el ; value.Set value.Value)\n                //    style     <| styleSplitter !gap\n                //    style        \"z-index: 10; background-color: #eef\"\n                //]\n            let partSizes sz gap pad spl = (sz - gap - pad) *          spl  / 100.0          \n                                         , (sz - gap - pad) * (100.0 - spl) / 100.0\n            let styleSections (p1:float, p2:float) = sprintf \" %.2fpx %.2fpx ; %s : %.2fpx; \" p1 p2 (if vertical then \"height\" else \"width\") (snd !size)\n            let styleSizes           spl = partSizes (fst !size) gap.Value !padding spl |> styleSections\n            //div [ \n            //    style <| sprintf \"display: grid; grid-template-areas: 'one' 'two' ; %s\" styleRest\n            //    style <| Val.map styleSizes value\n            //    slot [                   div [ style \"background-color: red ; grid-area: one\" ] ]\n            //    slot [ name \"part2\"    ; div [ style \"background-color: blue; grid-area: two\" ] ]\n            //    slot [ name \"splitter\" ; splitter                                               ]\n            //]\n            let recalc() = !domElem |> Option.iter (fun sh -> size := sizeCalc sh); value.Set value.Value\n            //addResizeObserver recalc el\n            (if vertical then\n              TemplateLib.WCompSplitterVer()\n                .PartSizes(  View.Map styleSizes value.View )\n                .AfterRender(  fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc())\n                .AfterRenderSp(fun  sp              -> domElem :=          Some sp ; recalc())\n                .MouseDown(  fun te -> startDragging te.Event)\n                .Gap(        View.Map (sprintf \"%Apx\") gap.View)\n                .Doc()\n             else\n              TemplateLib.WCompSplitterHor()\n                .PartSizes(  View.Map styleSizes value.View )\n                .AfterRender(  fun (sh:Dom.Element) -> addResizeObserver recalc el ; recalc())\n                .AfterRenderSp(fun  sp              -> domElem :=          Some sp ; recalc())\n                .MouseDown(  fun te -> startDragging te.Event)\n                .Gap(        View.Map (sprintf \"%Apx\") gap.View)\n                .Doc())\n            |> Doc.Run elsh\n            shadowRoot.AppendChild elsh.FirstChild |> ignore\n            added <- true\n\nif IsClient then defineWebComponent \"wcomp-splitter\" WcSplitterT.Constructor WcSplitterT.NewPointer\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"dd65606a-9194-4699-8c83-25dd52970a44"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"54807aa7-91ba-442b-8a0e-ef96fb9b681b"}, "snpName": "WebComponent TabStrip", "snpContent": "type WcTabStripT () =\n    let mutable added = false\n    do printfn \"WcTabStripT initializer\"\n    [< Inline \"\"\"$global.FSSGlobal.CalcEditor.WcTabStripT.New\"\"\" >] static member NewPointer = X<_>\n    static member Constructor() = \n        let this = ReflectConstruct()\n        WcTabStripT.NewPointer?call this\n        this\n    member this.connectedCallback() = \n        printfn \"my-el connected %A %A\" added this?outerHTML\n        if not added then\n            let el : Dom.Element = this |> box |> unbox\n            let top = el.HasAttribute \"bottom\" |> not\n            let elsh        = JS.Document.CreateElement \"div\"\n            TabStrip.New([ for i in 1..el.ChildNodes.Length do \n                              let node = el.ChildNodes.[i - 1]\n                              if node.NodeType = Dom.NodeType.Element then\n                                  let elem = node :?> Dom.Element\n                                  let tabName = if elem.HasAttribute \"tabname\" then elem.GetAttribute \"tabname\" else sprintf \"Tab %d\" i\n                                  yield (tabName, Doc.Static elem |> someElt |> Seq.singleton |> div ) \n                          ])\n                          \n            |> (fun ts -> if top then ts.Top.Render else ts.Bottom.Render)\n            |> renderDoc |> Doc.Run elsh\n            el.AppendChild elsh.FirstChild |> ignore\n            added <- true\n\nif IsClient then defineWebComponent \"wcomp-tabstrip\" WcTabStripT.Constructor WcTabStripT.NewPointer\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"9d50c3d6-b8b4-4e9e-b4d4-78b864810b65"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e58f6eb7-bde5-4404-a752-1451fec828c7"}, "snpName": "updateModel", "snpContent": "let rec updateModelR model msg =\n    let setSelection sel          = if model.selection.Value = sel then false else\n                                    model.selection.Value   <- sel\n                                    true\n    match msg with\n    | AddCalculation         -> let n = newCalculation()\n                                model.calculations.Add n\n                                let nn = newNodeCalc n.id\n                                model.treeHierarchy.Value\n                                |> Array.append [| nn |]\n                                |> model.treeHierarchy.Set\n                                SelectNode  nn.nid |> updateModelR model\n    | AddTotal               -> let n = newTotal()\n                                model.totals.Add n\n                                let nn = newNodeTot  n.id\n                                model.treeHierarchy.Value\n                                |> Array.append [| nn |]\n                                |> model.treeHierarchy.Set\n                                SelectNode  nn.nid |> updateModelR model\n    | AddFormula         cid -> if  cid = nonCalculation.id then false else\n                                let n = newFormula cid\n                                model.formulas.Add n\n                                model.treeHierarchy.Value \n                                |> tryFindSelNode model.selection.Value\n                                |> Option.map (fun nn -> SelectFormNode (n.id, nn.nid ) |> updateModelR model)\n                                |> Option.defaultValue true\n    | AddDimension           -> let n = newDimension()\n                                model.dimensions.Add n\n                                SelectDimension n.id |> updateModelR model\n    | AddFormDim(fid, did, s)-> model.destinations.Add   { idForm = fid ; idDim = did ; destination = s }\n                                true\n//    | AddChild(tid, ch, we)  -> model.totals.TryFindByKey tid |> Option.map( fun tot ->\n//                                    model.childrenRels.Value <- model.childrenRels.Value |> Map.add (tid, ch) we\n//                                    true\n//                                ) |> Option.defaultValue false\n//    | RemoveChild (tid, ch)  -> model.childrenRels.Value <- model.childrenRels.Value |> Map.remove (tid, ch)\n//                                true\n    | RemoveTotal        tid -> model.totals.RemoveByKey    tid\n                                setSelection None |> ignore\n//                                model.childrenRels.Value <- model.childrenRels.Value |> Map.filter (fun k _ -> fst k <> tid)\n                                model.treeHierarchy.Value |> removeNodes (forTId ((=) tid)) |> setHierarchy\n                                true\n    | RemoveCalculation  cid -> model.calcDims.Value <- model.calcDims.Value |> Set.filter (fst >> ((<>) cid))\n                                model.formulas.Value\n                                |> Seq.filter (fun f -> f.idCalc = cid)\n                                |> Seq.map    (getId >> RemoveFormula)\n                                |> Seq.iter   (updateModelR model >> ignore)\n                                setSelection None |> ignore\n                                model.calculations.RemoveByKey cid\n                                model.treeHierarchy.Value |> removeNodes (forCId ((=) cid)) |> setHierarchy\n                                true\n    | RemoveFormula      fid -> model.formulas.RemoveByKey fid\n                                model.destinations.RemoveBy (fun d -> d.idForm = fid)\n                                model.treeHierarchy.Value \n                                |> tryFindSelNode model.selection.Value\n                                |> Option.map (fun nn -> SelectNode nn.nid |> updateModelR model)\n                                |> Option.defaultValue true\n    | RemoveDimension    did -> model.dimensions.RemoveByKey did\n                                true\n    | RemoveFormDim(fid, did)-> model.destinations.RemoveByKey(fid, did)\n                                true\n    | SelectNode         nid -> (nid, None    ) |> Some |> setSelection\n    | ExpandNode    (ex, nid)-> let rec mapper finished (node:TreeNode) =\n                                    if finished             then node                       , true\n                                    elif node.nid = nid     then { node with expanded = ex }, true\n                                    else let ch, dn = node.children |> Seq.mapFold mapper false\n                                         { node with children = Seq.toArray ch }            , dn\n                                model.treeHierarchy.Value \n                                |> Seq.mapFold mapper false \n                                |> fst\n                                |> Seq.toArray\n                                |> model.treeHierarchy.Set\n                                true\n    | IndentNode   (iin, nid)-> let indent = if iin then Tree.indentNode else Tree.outdentNode\n                                model.treeHierarchy.Value\n                                |> tryFindNode nid\n                                |> Option.iter(\n                                   Tree.toNode \n                                   >> swap indent (Tree.toSeqNode model.treeHierarchy.Value) \n                                   >> fromSeqNode \n                                   >> setHierarchy)\n                                true\n    | MoveNode(aft,fnid,tnid)-> Tree.moveToSibling2 aft fnid tnid (Tree.toSeqNode model.treeHierarchy.Value) \n                                |> fromSeqNode \n                                |> setHierarchy\n                                true\n    | SelectFormNode(fid,nid)-> (nid, Some fid) |> Some |> setSelection\n    | SelectTotal        tid -> model.treeHierarchy.Value |> tryFindNodeTId tid |> Option.map(fun n -> n.nid, None    ) |> setSelection\n    | SelectCalculation  cid -> model.treeHierarchy.Value |> tryFindNodeCId cid |> Option.map(fun n -> n.nid, None    ) |> setSelection\n    | SelectFormula      fid -> model.treeHierarchy.Value |> tryFindNodeFId fid |> Option.map(fun n -> n.nid, Some fid) |> setSelection\n    | SelectDimension    did -> (if did = DimId System.Guid.Empty then None  else Some did)\n                                |> (fun s -> if s = model.selectedDim.Value then false else\n                                             model.selectedDim.Value    <- s\n                                             true)\n\nlet updateModel model msg = if updateModelR model msg then refreshNow()\n\nlet processor = updateModel model\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"09876215-2ab1-4978-926b-51922548dbae"}, "snpName": "UpdateAlea", "snpContent": "\nmodule UpdateAlea =\n    module Alea = AleaAPI.Alea\n    open AleaAPI.AleaN\n    \n    [< Rpc >]\n    let importDimension txt desc server dim = \n      dimensionN {\n        use  temp1   = new UsefulDotNet.TempFileName()\n        System.IO.File.WriteAllText(temp1.Name, txt ) \n        use  temp2   = new UsefulDotNet.TempFileName()\n        return!        DimensionN.import temp1.Name temp2.Name  \"\\t\"  desc\n      } |> DimensionN.run server dim |> Wrap.toAsyncResult\n    \n    let createAttributeTable atTblN fields = dimensionN {\n        let! _r      = DimensionN.attTableDeleteR      atTblN  |> DimensionN.getResult\n        let! handle  = DimensionN.attTableCreateBeginR atTblN\n        let! handles = fields |> DimensionN.traverseM (fun fld -> FieldN.runD fld FieldN.fieldAddR)\n        let! commit  = handles|> HandleN.sequenceM |> HandleN.run DimensionN.createCommitR handle\n        return commit\n    }\n\n    let calcList model flt =\n        model.calculations\n        |> Seq.filter flt\n        |> Seq.map    (fun c -> sprintf \"%s\\t%s\" (if c.isText then \"S\" else \"N\" ) c.name)\n        |> String.concat \"\\n\"\n\n    let measureFields = [\n            Alea.Field.newField \"Type\"          1s \"Type\"       0s  10s 0s \n            Alea.Field.newField \"Format_String\" 1s \"Format\"     0s 254s 0s \n    ]\n    \n    let tCalcFields =\n        measureFields @ [\n            Alea.Field.newField \"Cube\"          1s \"Cube\"       0s  50s 0s \n            Alea.Field.newField \"FreezeCube\"    1s \"FreezeCube\" 0s  50s 0s \n            Alea.Field.newField \"User\"          1s \"User\"       0s  50s 0s \n        ]\n        \n    let getFldByDesc d fs = fs |> List.tryFind (fun (f:Alea.Field) -> f.fldDescription = d) |> Result.fromOption (ErrSimple (\"Attribute Field not found\", false)) |> Wrap.WResult\n\n    let createTCalcDimension model = dimensionN {\n        let! serv, dim = DimensionN.serverDim\n        let! _r        = importDimension (calcList model <| fun _ -> true) \"Model Calculations\" serv dim |> WAsyncR\n        let! _r        = createAttributeTable 1s tCalcFields\n        let! fCube     = getFldByDesc \"Cube\"     tCalcFields\n        let! fType     = getFldByDesc \"Type\"     tCalcFields\n        let! fFormat   = getFldByDesc \"Format\"   tCalcFields\n        for c in model.calculations do\n            let  typ   = c.typeC.ToString()\n            let  dims  = getDimSet c.id model.calcDims.Value\n            let  cubeO = getDimsCubeO0 dims model.cubes.Value model.cubeDims.Value\n            let  cname = cubeO |> Option.map getcube |> Option.defaultValue \"----\"\n            let! _r    = DimensionN.putValueR fCube    cname   c.name\n            let! _r    = DimensionN.putValueR fType    typ     c.name\n            let! _r    = DimensionN.putValueR fFormat c.format c.name\n            ()\n    }\n\n    let isCalcCube (cub:Cube) (c:Calculation) = getCalcCubeO c.id |> Option.map getId = Some cub.id\n\n    let createMeasureDimension model cub = dimensionN {\n        let! serv, dim = DimensionN.serverDim\n        let _r       = importDimension (calcList model (isCalcCube cub)) (\"Measures for \" + cub.cube) serv dim |> WAsyncR\n        let! _r      = createAttributeTable 1s measureFields\n        let! fType   = getFldByDesc \"Type\"     measureFields\n        let! fFormat = getFldByDesc \"Format\"   measureFields\n        for c in model.calculations.Value |> Seq.filter (isCalcCube cub) do\n            let typ  = c.typeC.ToString()\n            let! _r    = DimensionN.putValueR fType    typ     c.name\n            let! _r    = DimensionN.putValueR fFormat c.format c.name\n            ()\n    }\n    \n//    let createCube model cub dimOlap = cubeN {\n//        let  dims      = Cube.dims model cub\n//        let  dimNames  = dims     |> Array.map (fun d -> d.dimName.ToUpper())\n//        let  dimsOlap  = dimNames |> Array.map Dimension\n//        let! currentDs = CubeN.dimensionsR |> CubeN.getResult\n//        let  exists    = currentDs\n//                         |> Result.map(\n//                             Array.map (fun dimOlap -> (Dimension.name dimOlap).ToUpper() )\n//                             >> ((=) dimNames))\n//                         |> Result.ifError false\n//        if not exists then\n//            let! _r    = CubeN.delete |> CubeN.getResult\n//            let! _r    = CubeN.create     dimsOlap\n//            let! _r    = CubeN.setMeasure dimOlap \n//            ()\n//    }\n//    \n//    let createDimensionAndCube model cub = serverN {\n//        let!    dimName   = Cube.measureDimNameR model cub\n//        let     dim       = Alea.Dimension dimName\n//        do!     createMeasureDimension model cub     |> DimensionN.runM dim\n//        return! createCube             model cub dim |> CubeN     .runM (Alea.Cube cub.cube)\n//    }\n//    \n//    let createAleaCubes (model:Model) = serverN {\n//        for cube in model.cubes.Value do\n//            do! createDimensionAndCube model cube\n//    }\n\n    let updateModel (model:Model) = serverN {\n        //do! createAleaCubes model\n        let tcalcDim = Alea.Dimension \"TCalc\"\n        //let! x = createTCalcDimension model |> DimensionN.runM tcalcDim\n        ()\n    }\n    \n    let run model = \n        createCubes()\n        let server = Alea.Server model.server.Value\n        updateModel model |> ServerN.run server\n        |> Wrap.start (printfn \"%s\")\n\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"4137cad8-fd64-426e-98de-16a92a56388d"}, {"SnippetId" :"5416e265-2418-4907-8810-4dc99bafe392"}, {"SnippetId" :"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"601c8cf3-33cd-41f9-94d0-79ac3be4f164"}, "snpName": "Serializer", "snpContent": "let inline ifUndef  def v   = if isUndefined v then def   else   v\nlet inline ifUndefF def f v = if isUndefined v then def v else f v\n\nlet deserGuid = ifUndef (System.Guid \"00000000-0000-0000-0000-000000000000\")\n\nlet serializerDimId      = (fun(DimId      v) -> sprintf \"\"\"{\"DimId\"      :%A}\"\"\" v)  , (fun (x: obj) -> x?DimId      |> deserGuid |> DimId     )\nlet serializerCalcId     = (fun(CalcId     v) -> sprintf \"\"\"{\"CalcId\"     :%A}\"\"\" v)  , (fun (x: obj) -> x?CalcId     |> deserGuid |> CalcId    )\nlet serializerTotId      = (fun(TotId      v) -> sprintf \"\"\"{\"TotId\"      :%A}\"\"\" v)  , (fun (x: obj) -> x?TotId      |> deserGuid |> TotId     )\nlet serializerFormId     = (fun(FormId     v) -> sprintf \"\"\"{\"FormId\"     :%A}\"\"\" v)  , (fun (x: obj) -> x?FormId     |> deserGuid |> FormId    )\nlet serializerCubeId     = (fun(CubeId     v) -> sprintf \"\"\"{\"CubeId\"     :%A}\"\"\" v)  , (fun (x: obj) -> x?CubeId     |> deserGuid |> CubeId    )\nlet serializerTreeNodeId = (fun(TreeNodeId v) -> sprintf \"\"\"{\"TreeNodeId\" :%A}\"\"\" v)  , (fun (x: obj) -> x?TreeNodeId |> deserGuid |> TreeNodeId)\nlet serializerDimType    = (fun v -> sprintf \"\\\"%A\\\"\"            (v:DimType ))        , (unbox >> function\n                                                                                                  | \"DtDataType\" -> DtDataType      \n                                                                                                  | \"DtTime\"     -> DtTime      \n                                                                                                  | \"DtVersion\"  -> DtVersion      \n                                                                                                  | \"DtTCalc\"    -> DtTCalc      \n                                                                                                  | \"DtCalc\"     -> DtCalc      \n                                                                                                  | \"DtMeasure\"  -> DtMeasure      \n                                                                                                  | _            -> DtOther      )\nlet serializerWeight     = (fun v -> sprintf \"\\\"%A\\\"\"            (v:Weight  ))        , (unbox >> function\n                                                                                                  | \"Add\"        -> Add      \n                                                                                                  | \"Subtract\"   -> Subtract      \n                                                                                                  | _            -> Zero      )\nlet serializerTypeC      = (fun v -> sprintf \"\\\"%A\\\"\"            (v:TypeCalc))        , (unbox >> function | \"Input\" -> Input | \"Calc\"         -> Calc         | _ -> Input)\nlet serializerTypeF      = (fun v -> sprintf \"\\\"%A\\\"\"            (v:TypeForm))        , (unbox >> function | \"Base\"  -> Base  | \"Consolidated\" -> Consolidated | _ -> All  )\nlet serializerFloat      = (fun v -> sprintf \"%A\"                (v:float   ))        , (fun (x: obj) -> x |> unbox<float>  |> ifUndef 0.0   )\nlet serializerInt        = (fun v -> sprintf \"%A\"                (v:int     ))        , (fun (x: obj) -> x |> unbox<int>    |> ifUndef 0     )\nlet serializerBool       = (fun v -> sprintf \"%A\"                (v:bool    ))        , (fun (x: obj) -> x |> unbox<bool>   |> ifUndef false )\nlet serializerString     = (fun v -> Json.Serialize              (v:string  ))        , (fun (x: obj) -> x |> unbox<string> |> ifUndef \"\"    )\n\nlet serializerField name (serFuncs:('e->string) * (obj->'e)) (get:'D->'e) (set:'e->'D->'D) = \n    name, serFuncs |> (fun (ser, deser) -> get >> ser, (fun o obj -> obj |> set (deser o)) )\n\nlet dimensionFields =\n    [|\n        serializerField \"id\"            serializerDimId   getId            setIdD       \n        serializerField \"dimension\"     serializerString  getdimension     setdimension \n        serializerField \"abbreviation\"  serializerString  getabbreviation  setabbreviation \n        serializerField \"order\"         serializerString  getorder         setorderD       \n        serializerField \"excludeCube\"   serializerBool    getexcludeCube   setexcludeCube  \n        serializerField \"includeFreeze\" serializerBool    getincludeFreeze setincludeFreeze\n        serializerField \"dimType\"       serializerDimType getdimType       setdimType      \n    |] \n    \nlet [< Inline >] serializerRecord init (fields: (string * (('D -> string) * (obj -> 'D -> 'D))) []) =\n    let serialize   dim = fields |> Seq.map  (fun     (n, ( ser, _deser)) -> sprintf \"%A: %s\" n (ser dim)) |> String.concat \", \" |> sprintf \"{%s}\"\n    let deserialize o   = if isUndefined o then init else fields |> Seq.fold (fun dim (n, (_ser,  deser)) ->  deser (o?(n)) dim )   init\n    serialize, deserialize\n\nlet serializerArray (ser: 'D -> string, deser:obj -> 'D) =\n    let serialize   arr = arr |>                 Array.map   ser |> String.concat \", \" |> sprintf \"[%s]\"\n    let deserialize o   = o   |> unbox<obj[]> |> ifUndefF (fun _ -> [||]) (Array.map deser)\n    serialize, deserialize\n    \nlet serializerDuple serFst serSnd =\n    let serialize (f, s) = sprintf \"[%s, %s]\" (fst serFst <| f) (fst serSnd <| s)\n    let deserialize o    =  o |> unbox<obj[]> |> ifUndefF (fun _ -> snd serFst o, snd serSnd o ) (fun os -> snd serFst <| os.[0], snd serSnd <| os.[1] )\n    serialize, deserialize\n\nlet serializerMap   serFst serSnd =\n    let arrSer, arrDeser           = serializerArray (serializerDuple serFst serSnd)\n    let serialize   (map:Map<_,_>) = map |> Seq.map (fun kvp -> kvp.Key, kvp.Value) |> Seq.toArray |> arrSer\n    let deserialize o              = o                                                             |> arrDeser |> Map\n    serialize, deserialize\n\nlet calculationFields =\n    [|\n        serializerField \"id\"        serializerCalcId getId        setIdC\n        serializerField \"name\"      serializerString getname      setname           \n        serializerField \"typeC\"     serializerTypeC  gettypeC     settypeC          \n        serializerField \"order\"     serializerString getorder     setorderC           \n        serializerField \"isText\"    serializerBool   getisText    setisText         \n        serializerField \"isBalance\" serializerBool   getisBalance setisBalance    \n        serializerField \"format\"    serializerString getformat    setformatC\n    |]\n\nlet serializerChild = \n    (function\n     | Node tid -> (fst serializerTotId ) tid |> sprintf \"\"\"{\"Node\" :%s}\"\"\" \n     | Leaf cid -> (fst serializerCalcId) cid |> sprintf \"\"\"{\"Leaf\" :%s}\"\"\" \n    )\n  , (fun (x: obj) -> \n      if   isUndefined x?Node |> not then x?Node |> (snd serializerTotId ) |> Node\n      elif isUndefined x?Leaf |> not then x?Leaf |> (snd serializerCalcId) |> Leaf\n                                     else x?Leaf |>  deserGuid |>  CalcId  |> Leaf\n    )\n\n//let serializerTotIdChild   = serializerDuple serializerTotId      serializerChild\n//let serializerchildrenRels = serializerMap   serializerTotIdChild serializerWeight  \n\nlet totalFields =\n    [|\n        serializerField \"id\"        serializerTotId    getId        setIdT\n        serializerField \"totName\"   serializerString   gettotName   settotName           \n        serializerField \"format\"    serializerString   getorder     setformatT\n        serializerField \"order\"     serializerString   getorder     setorderT\n    |]\n\nlet formulaFields =\n    [|\n        serializerField \"id\"         serializerFormId getId         setIdF\n        serializerField \"idCalc\"     serializerCalcId getidCalc     setidCalc          \n        serializerField \"formula\"    serializerString getformula    setformula          \n        serializerField \"typeF\"      serializerTypeF  gettypeF      settypeF         \n        serializerField \"order\"      serializerString getorder      setorderF          \n        serializerField \"alsoActual\" serializerBool   getalsoActual setalsoActual        \n    |]\n\nlet cubeFields =\n    [|\n        serializerField \"id\"         serializerCubeId getId         setIdCu\n        serializerField \"cube\"       serializerString getcube       setcube\n    |]\n\nlet destinationFields =\n    [|\n        serializerField \"idForm\"      serializerFormId getidForm      setidForm\n        serializerField \"idDim\"       serializerDimId  getidDim       setidDim\n        serializerField \"destination\" serializerString getdestination setdestination          \n    |]\n\nlet mutable tnSer = None\nlet delTnSer   () = tnSer |> Option.get\nlet [< Inline >] inline delayedSer  f = (fun x -> (f() |> fst) x), (fun x -> (f() |> snd) x)\n\nlet treeNodeFields = \n    [|\n        serializerField \"nid\"      serializerTreeNodeId  getnid      setnid       \n        serializerField \"element\"  serializerChild       getelement  setelement   \n        serializerField \"expanded\" serializerBool        getexpanded setexpanded  \n        serializerField \"children\" (delayedSer delTnSer) getchildren setchildren  \n        serializerField \"weight\"   serializerWeight      getweight   setweight                \n    |]    \n\nlet serializertreeNode       = serializerRecord ( newNodeCalc(nonCalculation.id) ) treeNodeFields\nlet serializertreeNodes      = serializerArray serializertreeNode\n\ntnSer <- Some serializertreeNodes\n\nlet getdimensions     model = model.dimensions   .Value |> Seq.toArray\nlet getcalculations   model = model.calculations .Value |> Seq.toArray\nlet gettotals         model = model.totals       .Value |> Seq.toArray\nlet getformulas       model = model.formulas     .Value |> Seq.toArray\nlet getcubes          model = model.cubes        .Value |> Seq.toArray\n//let getchildrenRels   model = model.childrenRels .Value \nlet getdestinations   model = model.destinations .Value |> Seq.toArray\nlet getcalcDims       model = model.calcDims     .Value |> Seq.toArray\nlet getcubeDims       model = model.cubeDims     .Value |> Seq.toArray\nlet getglobalDefs     model = model.globalDefs   .Value\nlet getserver         model = model.server       .Value\nlet getcubePrefix     model = model.cubePrefix   .Value\nlet getmeasurePrefix  model = model.measurePrefix.Value\nlet gettreeHierarchy  model = model.treeHierarchy.Value |> Seq.toArray\n\nlet setdimensions    v model =                  model.dimensions   .Set      v ; model\nlet setcalculations  v model =                  model.calculations .Set      v ; model\nlet settotals        v model =                  model.totals       .Set      v ; model\nlet setformulas      v model =                  model.formulas     .Set      v ; model\nlet setcubes         v model =                  model.cubes        .Set      v ; model\n//let setchildrenRels  v model =                  model.childrenRels .Set      v ; model \nlet setdestinations  v model =                  model.destinations .Set      v ; model\nlet setcalcDims      v model =                  model.calcDims     .Set (Set v); model\nlet setcubeDims      v model =                  model.cubeDims     .Set (Set v); model\nlet setglobalDefs    v model =                  model.globalDefs   .Set      v ; model\nlet setserver        v model =                  model.server       .Set      v ; model\nlet setcubePrefix    v model = (if v <> \"\" then model.cubePrefix   .Set      v); model\nlet setmeasurePrefix v model = (if v <> \"\" then model.measurePrefix.Set      v); model\nlet settreeHierarchy v model =                  model.treeHierarchy.Set      v ; model\n\nlet serializerdimension      = serializerRecord (newDimension  ()                                                 ) dimensionFields  \nlet serializercalculation    = serializerRecord (newCalculation()                                                 ) calculationFields\nlet serializertotal          = serializerRecord (newTotal()                                                       ) totalFields\nlet serializerformula        = serializerRecord (newFormula    (CalcId System.Guid.Empty)                         ) formulaFields    \nlet serializercube           = serializerRecord (newCube       ()                                                 ) cubeFields\nlet serializerdestination    = serializerRecord (newDestination(FormId System.Guid.Empty)(DimId System.Guid.Empty)) destinationFields\nlet serializercalcDim        = serializerDuple serializerCalcId serializerDimId\nlet serializercubeDim        = serializerDuple serializerCubeId serializerDimId\n  \nlet serializerdimensions     = serializerArray serializerdimension  \nlet serializercalculations   = serializerArray serializercalculation\nlet serializertotals         = serializerArray serializertotal\nlet serializerformulas       = serializerArray serializerformula    \nlet serializercubes          = serializerArray serializercube\nlet serializerdestinations   = serializerArray serializerdestination\nlet serializercalcDims       = serializerArray serializercalcDim\nlet serializercubeDims       = serializerArray serializercubeDim\n\nlet modelFields =\n    [|\n        serializerField \"dimensions\"    serializerdimensions   getdimensions    setdimensions     \n        serializerField \"calculations\"  serializercalculations getcalculations  setcalculations     \n        serializerField \"totals\"        serializertotals       gettotals        settotals\n        serializerField \"formulas\"      serializerformulas     getformulas      setformulas     \n        serializerField \"cubes\"         serializercubes        getcubes         setcubes        \n//        serializerField \"childrenRels\"  serializerchildrenRels getchildrenRels  setchildrenRels        \n        serializerField \"destinations\"  serializerdestinations getdestinations  setdestinations        \n        serializerField \"calcDims\"      serializercalcDims     getcalcDims      setcalcDims        \n        serializerField \"cubeDims\"      serializercubeDims     getcubeDims      setcubeDims        \n        serializerField \"globalDefs\"    serializerString       getglobalDefs    setglobalDefs        \n        serializerField \"server\"        serializerString       getserver        setserver        \n        serializerField \"cubePrefix\"    serializerString       getcubePrefix    setcubePrefix\n        serializerField \"measurePrefix\" serializerString       getmeasurePrefix setmeasurePrefix\n        serializerField \"treeHierarchy\" serializertreeNodes    gettreeHierarchy settreeHierarchy\n    |] \n\nlet serializeModel   model     = (serializerRecord model modelFields |> fst) model\nlet deserializeModel model obj = (serializerRecord model modelFields |> snd) obj\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"1da05dcf-8d1b-4f21-b570-389d3e1030b2"}, "snpName": "Load Save", "snpContent": "#r \"../packages/FSharp.Data/lib/net45/FSharp.Data.dll\"\n\nopen FSharp.Data\n\n[< Inline \"saveAs(new Blob([$_txt], {type: 'text/plain;charset=utf-8'}), $_name)\" >]\nlet saveAs (_name:string) (_txt:string) = ()\n    \nlet layout() = \n    let dirty          = Var.Create     false\n    let setDirty()     = dirty.Value <- true       \n    let setClean()     = dirty.Value <- false\n    \n    let justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n    \n    let fileName  = Var.Create \"\"\n    let emptyFile = Val.map (fun v -> v = \"\") fileName\n    \n    let loadTextFile element (f: string -> unit) =\n        let files = element |> FileList.OfElement \n        if files.Length > 0 then\n            let  reader  = TextFileReader()\n            reader.Onload <- (fun e -> f e.Target?result)\n            reader.ReadAsText files.[0] \n    \n    //let setModel models =\n    //    model.dimensions  .Set     models.dimensions  \n    //    model.calculations.Set     models.calculations\n    //    model.formulas    .Set     models.formulas    \n    //    model.destinations.Set     models.destinations\n    //    model.calcDims    .Value <- models.calcDims   \n    //    model.cubeDims    .Value <- models.cubeDims   \n    //    model.globalDefs  .Value <- models.globalDefs \n    //    model.server      .Value <- models.server   \n    \n    let parseText txt =\n        try\n            txt\n            |> Json.Parse\n            |> deserializeModel model\n            |> ignore\n            reorder()\n    //        refreshView()\n        with e -> JS.Alert <| e.ToString()\n                  printfn \"%A\" e\n    \n    let fileInputElementId = \"RuleEditorFileSel\"\n    let loadFile (e: Dom.Element) =\n        if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n          let root = findRootElement e\n          loadTextFile \n              <| root.QuerySelector(\"#\" + fileInputElementId)\n              <| parseText\n    \n    let downloadFile() = // Save as...\n        let name = match justFileName fileName.Value with \n                   | \"\"    -> \"rules.json\" \n                   | fname -> fname\n        model\n        |> serializeModel\n        |> saveAs name\n        setClean()\n        \n    let loadFileElement =\n        Template.Input.New(fileName.Lens justFileName (fun prev _n -> prev) )\n            .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                             Template.Input.New(fileName)\n                                     .Type(\"file\")\n                                     .Style(\"display: none\")\n                                     .Content([ on.change (fun el _ -> loadFile el   )\n                                                on.click  (fun el _ -> el?value <- \"\")\n                                              ])\n                                     .Id(fileInputElementId)\n                                     .Render \n                            ]\n                    )\n    \n    let do_LoadFile (e:Dom.Element) () =          \n        let root = findRootElement e\n        (root.QuerySelector(\"#\" + fileInputElementId))?click() |> ignore\n        \n    ()", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, {"SnippetId" :"601c8cf3-33cd-41f9-94d0-79ac3be4f164"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"162d452a-3f08-4bfe-8adb-2f3bf1585560"}, "snpName": "LayoutNew", "snpContent": "    let jumpToLine (line:string) = \n        let rex = [ rexGlobal\n                    rexTotId \n                    rexCalcId\n                    rexFormId\n                    rexDimId     \n                  ] |> String.concat \"|\" |> sprintf \"(?:%s)\"\n        match line with\n        | REGEX rex \"\" p -> \n            p\n            |> Array.skip 1\n            |> Array.filter (isUndefined >> not)\n            |> function\n               | [| \"FormId\" ; guid |] -> SelectFormula     (System.Guid guid |> FormId) |> processor\n               | [| \"CalcId\" ; guid |] -> SelectCalculation (System.Guid guid |> CalcId) |> processor\n               | [| \"TotId\"  ; guid |] -> SelectTotal       (System.Guid guid |> TotId ) |> processor\n               | [| \"DimId\"  ; guid |] -> SelectDimension   (System.Guid guid |> DimId ) |> processor       \n               | _ -> ()\n        | _ -> ()\n    \n    let jumpToRef (e:obj) = \n        let v : string = e?Target?value |> unbox\n        let s : int    = e?Target?selectionStart |> unbox\n        let i = v.[0..s].LastIndexOf '\\n'\n        jumpToLine v.[i+1..]\n    \n    let scrollToBottom (e:Dom.Element) = \n        async { \n            do! Async.Sleep 100\n            do  e.ScrollTop <- e.ScrollHeight\n        } |> Async.Start\n\n    let calculations      = renderTable        processor model\n    let calcDetail        = renderDetail       processor model\n    let dimsSelected      = renderDimsSelected processor model\n    let dimensions        = renderDimensions   processor model\n    let globalDefinitions = renderGlobalDefs   processor model\n    \n    TemplateLib.Layout()\n        .CalculationTable( calculations      |> renderDoc)\n        .FormulaDetail(    calcDetail        |> renderDoc)\n        .DimsSelected(     dimsSelected      |> renderDoc)\n        .DimensionTable(   dimensions        |> renderDoc)\n        .GlobalText(       globalDefinitions |> renderDoc)\n        .Output(           outputMsgs                    )\n        .FSCode(           codeFS                        )\n        .Parser(           parserMsgs                    )\n        .AddCalculation(   fun _ -> AddCalculation |> processor                  )\n        .AddTotal(         fun _ -> AddTotal       |> processor                  )\n        .Parse(            fun _ -> getJSCodeA()                                 )\n        .GetFSCode(        fun _ -> getFSCodeA()                                 )\n        //.UpdateRules(      fun _ -> updateRules() |> Wrap.toAsync |> Async.Start )\n        .UpdateRules(      fun _ -> UpdateAlea.run model                         )\n        .SaveAs(           fun _ -> downloadFile()                               )\n        .LoadFileChanged(  fun e -> loadFile e.Target                            )\n        .LoadFileClear(    fun e -> e.Target?value <- \"\"                         )\n        .IndentIn(         fun _ -> model.selection.Value |> selNIdO |> Option.iter (fun nid -> IndentNode(true , nid) |> processor) )\n        .IndentOut(        fun _ -> model.selection.Value |> selNIdO |> Option.iter (fun nid -> IndentNode(false, nid) |> processor) )\n        .Server(                    model.server                                 )\n        .Reorder(          fun _ -> reorder()                                    )\n        .JumpRef(jumpToRef)\n        .OutputAfterRender(scrollToBottom)\n        .Doc()\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"09876215-2ab1-4978-926b-51922548dbae"}, {"SnippetId" :"1da05dcf-8d1b-4f21-b570-389d3e1030b2"}, {"SnippetId" :"dd65606a-9194-4699-8c83-25dd52970a44"}, {"SnippetId" :"e58f6eb7-bde5-4404-a752-1451fec828c7"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"80056cda-4f3b-46ee-85a9-bd085fc10ea1"}, "snpName": "init", "snpContent": "module init =\n\n  let setGlobals txt = model.globalDefs.Value <- unindentStr txt\n\n  let passAndPass f v =\n      f v\n      v\n  \n  let newDim n typ abb ord excName incFree =\n      newDimension()\n      |> setdimension     n\n      |> setabbreviation  abb\n      |> setdimType       typ\n      |> setorderD        ord\n      |> setexcludeCube   excName\n      |> setincludeFreeze incFree\n      |> passAndPass      model.dimensions.Append \n\n  let newCalc n typ ord isText isBalance (dims: Dimension seq) = \n      newCalculation()\n      |> setname      n\n      |> setorderC    ord\n      |> settypeC     typ\n      |> setisText    isText\n      |> setisBalance isBalance\n      |> passAndPass  model.calculations.Append\n      |> passAndPass  (fun calc -> model.calcDims.Value <- dims |> Seq.map (fun d -> calc.id, d.id) |> Set |> Set.union model.calcDims.Value)\n      \n  let (?) (dim:Dimension) elem = (dim.id, elem)\n  \n  let newForm (calc:Calculation) typR ord form refs =\n      newFormula      calc.id\n      |> settypeF     typR\n      |> setorderF    ord\n      |> setformula   form\n      |> passAndPass  model.formulas.Append\n      |> (fun frm -> refs |> Seq.map (fun (did, elem) -> newDestination frm.id did |> setdestination elem) |> model.destinations.AppendMany)\n\nopen init  \nlet initData() =", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b27a75c8-70c5-487f-9650-2b2851f3d30e"}, "snpName": "Converted from CalcEditor", "snpContent": "\nsetGlobals \"\"\"\nlet inline GetTime txt =  toExpT txt\nlet inline TT2 ref n = toExpN n |> ignore; ref\nlet ALL_SKU = Product?All_SKU\nlet PC      = Product?PC\nlet CP      = Product?CP\nlet SO      = Product?SO\n\nlet inline INSRT(t1, t2, p) = toExpT t2 |> ignore; toExpN p |> ignore; toExpT t1\nlet inline STR(n1, n2, n3) = toExpN n2 |> ignore; toExpN n3 |> ignore; toExpN n1 |> ignore ; toExpT \"f\"\nlet inline NUMBR(t1) = toExpT t1 |> ignore; toExpN 4\nlet STET = ExnStet\nlet NAt  = ExtNA\nlet inline GETATTR(t1, t2, p, t3) = toExpT t2 |> ignore; toExpT t3 |> ignore; toExpN p |> ignore; toExpT t1\n\nlet inline minus n = toExpN n\nlet ( ~- ) = minus\nlet inline plus n = toExpN n\nlet ( ~+ ) = plus\n\nmodule DE =\n    let inline INDEX(t1, t2) = toExpT t1 |> ignore; toExpT t2 |> ignore; toExpN 3\n    let inline PARENTNAME(t1, t2, n3) = toExpN n3 |> ignore; toExpT t1 |> ignore; toExpT t2\n    \"\"\"\n\nlet Time = newDim \"Time\" DtOther \"TM\" \"10\" true true\nlet Version = newDim \"Version\" DtOther \"VE\" \"30\" true true\nlet DataType = newDim \"DataType\" DtOther \"DT\" \"35\" true false\nlet Customer = newDim \"Customer\" DtOther \"CU\" \"40\" false false\nlet Product = newDim \"Product\" DtOther \"PR\" \"50\" false false\n\nlet BudgetStart = newCalc \"BudgetStart\" Input \"A00\" true false [Version]\nlet AverageMonths = newCalc \"AverageMonths\" Input \"A00\" true false [Version; DataType; Customer; Product]\nlet Current_Year = newCalc \"Current Year\" Calc \"A00a\" true false [Version]\nlet BudgetEnd = newCalc \"BudgetEnd\" Input \"A00a\" true false [Version]\nlet IsActual = newCalc \"IsActual\" Calc \"A01\" false false [Time; Version]\nlet IsActual_Monthly = newCalc \"IsActual Monthly\" Calc \"A01b\" false false [Version]\nlet CVersionRef = newCalc \"CVersionRef\" Input \"A02\" true false [Version]\nlet YOYVersionRef = newCalc \"YOYVersionRef\" Input \"A02\" true false [Version]\nlet Discontinued_Period_Input = newCalc \"Discontinued Period Input\" Input \"A02\" true false [Version; DataType; Customer; Product]\nlet TBudgetRefYear = newCalc \"TBudgetRefYear\" Input \"A02\" true false [Version]\nlet Discontinued_Period = newCalc \"Discontinued Period\" Input \"A02\" true false [Version; DataType; Customer; Product]\nlet DTimeRef = newCalc \"DTimeRef\" Input \"A02\" true false [Version]\nlet ActualRef = newCalc \"ActualRef\" Input \"A02\" true false [Version]\nlet CTimeRef = newCalc \"CTimeRef\" Input \"A02\" true false [Version]\nlet TBudgetRef = newCalc \"TBudgetRef\" Input \"A02\" true false [Version]\nlet DVersionRef = newCalc \"DVersionRef\" Input \"A02\" true false [Version]\nlet IsDiscontinued = newCalc \"IsDiscontinued\" Input \"A02\" true false [Time; Version; DataType; Customer; Product]\nlet UPTimeRef = newCalc \"UPTimeRef\" Input \"A02\" true false [Version]\nlet zTimeRef = newCalc \"zTimeRef\" Input \"A03\" true false [Version]\nlet zVersionRef = newCalc \"zVersionRef\" Input \"A03\" true false [Version]\nlet Product_Basis = newCalc \"Product Basis\" Input \"B00\" true false [Version; DataType; Customer; Product]\nlet Innovation_Allocation_Sales_Override = newCalc \"Innovation Allocation Sales Override\" Input \"B00\" false false [Version; DataType; Customer; Product]\nlet Innovation_Allocation_Cases_Override = newCalc \"Innovation Allocation Cases Override\" Input \"B00\" false false [Version; DataType; Customer; Product]\nlet Innovation_Allocation_Cases_Effective = newCalc \"Innovation Allocation Cases Effective\" Input \"B00\" false false [Version; DataType; Customer; Product]\nlet Innovation_Allocation_Sales_Effective = newCalc \"Innovation Allocation Sales Effective\" Input \"B00\" false false [Version; DataType; Customer; Product]\nlet Innovation_Allocation = newCalc \"Innovation Allocation\" Input \"B00\" false false [Version; DataType; Customer; Product]\nlet Warehouse_Transfers_Inflation = newCalc \"Warehouse Transfers Inflation\" Input \"B00i\" false false [Time; Version]\nlet Freight_Allowance_Inflation = newCalc \"Freight Allowance Inflation\" Input \"B00i\" false false [Time; Version]\nlet Freight_Allowance_Seasonality = newCalc \"Freight Allowance Seasonality\" Input \"B00i\" false false [Time; Version]\nlet Warehouse_Transfers_Seasonality = newCalc \"Warehouse Transfers Seasonality\" Input \"B00i\" false false [Time; Version]\nlet Freight_Inflation = newCalc \"Freight Inflation\" Input \"B00i\" false false [Time; Version]\nlet Freight_Seasonality = newCalc \"Freight Seasonality\" Input \"B00i\" false false [Time; Version]\nlet Warehouse_Storage_Inflation = newCalc \"Warehouse Storage Inflation\" Input \"B00i\" false false [Time; Version]\nlet Commission_Inflation = newCalc \"Commission Inflation\" Input \"B00i\" false false [Time; Version]\nlet Warehouse_Storage_Seasonality = newCalc \"Warehouse Storage Seasonality\" Input \"B00i\" false false [Time; Version]\nlet Commission_Rate = newCalc \"Commission Rate\" Calc \"B01\" false false [Time; Version; DataType; Customer; Product]\nlet Commission = newCalc \"Commission\" Calc \"B01\" false false [Time; Version; DataType; Customer; Product]\nlet Cases = newCalc \"Cases\" Input \"B01\" false false [Time; Version; DataType; Customer; Product]\nlet Price = newCalc \"Price\" Input \"B02\" false false [Time; Version; DataType; Customer; Product]\nlet Sales = newCalc \"Sales\" Calc \"B03\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Accum = newCalc \"Cases Accum\" Calc \"C01\" false false [Version; DataType; Customer; Product]\nlet Sales_3M = newCalc \"Sales 3M\" Calc \"C02\" false false [Version; DataType; Customer; Product]\nlet Price_3M = newCalc \"Price 3M\" Calc \"C03\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_3M = newCalc \"Commission 3M\" Calc \"C04\" false false [Version; DataType; Customer; Product]\nlet Commission_Rate_3M = newCalc \"Commission Rate 3M\" Calc \"C05\" false false [Version; DataType; Customer; Product]\nlet Commission_Rate_Base = newCalc \"Commission Rate Base\" Input \"C06\" false false [Version; DataType; Customer; Product]\nlet Commission_Rate_Base_Month = newCalc \"Commission Rate Base Month\" Calc \"C06a\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Rate_Exception = newCalc \"Commission Rate Exception\" Input \"C07\" true false [Time; Version; DataType; Customer; Product]\nlet CRE_Depth_Product = newCalc \"CRE Depth Product\" Calc \"C08\" false false [Time; Version; DataType; Customer; Product]\nlet CRE_Depth_Customer = newCalc \"CRE Depth Customer\" Calc \"C08\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Rate_Exception_2 = newCalc \"Commission Rate Exception 2\" Input \"C09\" true false [Time; Version; DataType; Customer; Product]\nlet Commission_Rate_Base_Period = newCalc \"Commission Rate Base Period\" Input \"C09a\" true false [Time; Version]\nlet Commission_Rate_Projected = newCalc \"Commission Rate Projected\" Input \"C10\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Copy_No_Override = newCalc \"Commission Copy No Override\" Input \"C11\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Adjustment_Flag = newCalc \"Commission Adjustment Flag\" Input \"C11\" true false [Version; DataType; Customer; Product]\nlet Commission_Original_No_Override = newCalc \"Commission Original No Override\" Input \"C11\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_New_Pct_Input = newCalc \"Commission New Pct Input\" Input \"C11\" true false [Version; DataType; Customer; Product]\nlet Commission_Adjustment = newCalc \"Commission Adjustment\" Input \"C11\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_No_Override = newCalc \"Commission No Override\" Calc \"C11\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Override = newCalc \"Commission Override\" Calc \"C11\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_Copy = newCalc \"Commission Copy\" Calc \"C12\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Buffer_New = newCalc \"Cases Buffer New\" Input \"D00\" false false [Time; Version; DataType; Customer; Product]\nlet Sales_Input = newCalc \"Sales Input\" Input \"D00\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Input = newCalc \"Cases Input\" Input \"D00\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Buffer = newCalc \"Cases Buffer\" Input \"D00\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Buffer_Dif = newCalc \"Cases Buffer Dif\" Calc \"D00a\" false false [Time; Version; DataType; Customer; Product]\nlet Price_Input = newCalc \"Price Input\" Calc \"D00b\" false false [Time; Version; DataType; Customer; Product]\nlet Customer_Parent = newCalc \"Customer Parent\" Calc \"D01\" true false [Version; DataType; Customer; Product]\nlet Product_Class_Exception_M = newCalc \"Product Class Exception M\" Calc \"D02\" true false [Time; Version; DataType; Customer; Product]\nlet Product_Class_Exception = newCalc \"Product Class Exception\" Input \"D02\" true false [Version; DataType; Customer; Product]\nlet Product_Class = newCalc \"Product Class\" Calc \"D03\" true false [Version; DataType; Customer; Product]\nlet Product_Class_2 = newCalc \"Product Class 2\" Calc \"D03\" true false [Version; DataType; Customer; Product]\nlet Is_Exception = newCalc \"Is Exception\" Calc \"D03a\" false false [Version; DataType; Customer; Product]\nlet Allocation_Weight = newCalc \"Allocation Weight\" Input \"D04\" false false [Version; DataType; Customer; Product]\nlet Cases_Proportion = newCalc \"Cases Proportion\" Calc \"D10\" false false [Version; DataType; Customer; Product]\nlet Cases_Projected = newCalc \"Cases Projected\" Calc \"E01\" false false [Time; Version; DataType; Customer; Product]\nlet Price_Projected = newCalc \"Price Projected\" Calc \"F01\" false false [Time; Version; DataType; Customer; Product]\nlet Pounds_per_case___Net = newCalc \"Pounds per case - Net\" Input \"G00\" false false [Version; DataType; Product]\nlet Pounds_per_case___Gross = newCalc \"Pounds per case - Gross\" Input \"G00\" false false [Version; DataType; Product]\nlet Pounds_Gross = newCalc \"Pounds Gross\" Calc \"G00a\" false false [Time; Version; DataType; Customer; Product]\nlet Pounds_Net = newCalc \"Pounds Net\" Calc \"G00a\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_per_pound_base = newCalc \"Freight per pound base\" Input \"G01\" false false [Version; DataType; Customer; Product]\nlet Freight = newCalc \"Freight\" Calc \"G01\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_per_pound = newCalc \"Freight per pound\" Calc \"G01a\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Copy = newCalc \"Freight Copy\" Input \"G01ax\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Original = newCalc \"Freight Original\" Input \"G01ax\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Adjustment_Flag = newCalc \"Freight Adjustment Flag\" Input \"G01ax\" true false [Version; DataType; Customer; Product]\nlet Freight_New_Pct_Input = newCalc \"Freight New Pct Input\" Input \"G01ax\" true false [Version; DataType; Customer; Product]\nlet Freight_Adjustment = newCalc \"Freight Adjustment\" Input \"G01ax\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_per_pound_base = newCalc \"Freight Allowance per pound base\" Input \"G01b\" false false [Version; DataType; Customer; Product]\nlet Freight_Allowance = newCalc \"Freight Allowance\" Calc \"G01b\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_Adjustment_Flag = newCalc \"Freight Allowance Adjustment Flag\" Input \"G01bx\" true false [Version; DataType; Customer; Product]\nlet Freight_Allowance_Copy = newCalc \"Freight Allowance Copy\" Input \"G01bx\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_Original = newCalc \"Freight Allowance Original\" Input \"G01bx\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_Adjustment = newCalc \"Freight Allowance Adjustment\" Input \"G01bx\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_New_Pct_Input = newCalc \"Freight Allowance New Pct Input\" Input \"G01bx\" true false [Version; DataType; Customer; Product]\nlet Freight_Allowance_per_pound = newCalc \"Freight Allowance per pound\" Calc \"G01c\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_per_pound = newCalc \"Warehouse Transfers per pound\" Calc \"G02\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_per_pound_base = newCalc \"Warehouse Transfers per pound base\" Input \"G02\" false false [Version; DataType; Customer; Product]\nlet Warehouse_Transfers = newCalc \"Warehouse Transfers\" Calc \"G02\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_Original = newCalc \"Warehouse Transfers Original\" Input \"G02x\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_Adjustment_Flag = newCalc \"Warehouse Transfers Adjustment Flag\" Input \"G02x\" true false [Version; DataType; Customer; Product]\nlet Warehouse_Transfers_New_Pct_Input = newCalc \"Warehouse Transfers New Pct Input\" Input \"G02x\" true false [Version; DataType; Customer; Product]\nlet Warehouse_Transfers_Adjustment = newCalc \"Warehouse Transfers Adjustment\" Input \"G02x\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_Copy = newCalc \"Warehouse Transfers Copy\" Input \"G02x\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage = newCalc \"Warehouse Storage\" Calc \"G03\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage_per_case_base = newCalc \"Warehouse Storage per case base\" Input \"G03\" false false [Version; DataType; Customer; Product]\nlet Warehouse_Storage_per_case = newCalc \"Warehouse Storage per case\" Calc \"G03\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage_Adjustment = newCalc \"Warehouse Storage Adjustment\" Input \"G03x\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage_Adjustment_Flag = newCalc \"Warehouse Storage Adjustment Flag\" Input \"G03x\" true false [Version; DataType; Customer; Product]\nlet Warehouse_Storage_New_Pct_Input = newCalc \"Warehouse Storage New Pct Input\" Input \"G03x\" true false [Version; DataType; Customer; Product]\nlet Warehouse_Storage_Copy = newCalc \"Warehouse Storage Copy\" Input \"G03x\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage_Original = newCalc \"Warehouse Storage Original\" Input \"G03x\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Pct_Input = newCalc \"Trade Pct Input\" Input \"H00\" false false [Version; DataType; Customer; Product]\nlet Promotion = newCalc \"Promotion\" Calc \"H00\" false false [Time; Version; DataType; Customer; Product]\nlet Off_Invoice = newCalc \"Off Invoice\" Calc \"H00\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Input = newCalc \"Trade Input\" Calc \"H00a\" false false [Version; DataType; Customer; Product]\nlet Trade_Pct_Base_E = newCalc \"Trade Pct Base E\" Input \"H01a\" false false [Version; DataType; Customer; Product]\nlet Trade_Base_Pre = newCalc \"Trade Base Pre\" Calc \"H01b\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Pct_Base_Pre = newCalc \"Trade Pct Base Pre\" Calc \"H01b\" false false [Version; DataType; Customer; Product]\nlet Trade_Actual = newCalc \"Trade Actual\" Calc \"H01d\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_YTD = newCalc \"Trade YTD\" Input \"H01d\" false false [Version; DataType; Customer; Product]\nlet Sales_YTG = newCalc \"Sales YTG\" Input \"H01d\" false false [Version; DataType; Customer; Product]\nlet Sales_FY = newCalc \"Sales FY\" Input \"H01d\" false false [Version; DataType; Customer; Product]\nlet Trade_BOY = newCalc \"Trade BOY\" Calc \"H01e\" false false [Version; DataType; Customer; Product]\nlet Trade_Base = newCalc \"Trade Base\" Calc \"H01f\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Pct_Base = newCalc \"Trade Pct Base\" Calc \"H01f\" false false [Version; DataType; Customer; Product]\nlet Sales_YTG_Calc = newCalc \"Sales YTG Calc\" Calc \"H01f\" false false [Version; DataType; Customer; Product]\nlet Sales_FY_Calc = newCalc \"Sales FY Calc\" Calc \"H01f\" false false [Version; DataType; Customer; Product]\nlet Promotion_Split_Pct = newCalc \"Promotion Split Pct\" Calc \"H02\" false false [Version; DataType; Customer; Product]\nlet Trade_Override = newCalc \"Trade Override\" Calc \"H02\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Pct_Override_Input = newCalc \"Trade Pct Override Input\" Input \"H02\" true false [Version; DataType; Customer; Product]\nlet Is_Trade_Override_Input = newCalc \"Is Trade Override Input\" Input \"H02\" true false [Version; DataType; Customer; Product]\nlet Off_Invoice_Split_Pct = newCalc \"Off Invoice Split Pct\" Calc \"H02\" false false [Version; DataType; Customer; Product]\nlet Trade_Pct_Override = newCalc \"Trade Pct Override\" Input \"H02\" false false [Version; DataType; Customer; Product]\nlet Is_Trade_Override = newCalc \"Is Trade Override\" Input \"H02\" false false [Version; DataType; Customer; Product]\nlet Trade = newCalc \"Trade\" Calc \"H03\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_Pct = newCalc \"Trade Pct\" Calc \"H03\" false false [Version; DataType; Customer; Product]\nlet Trade_Pct_Transfer = newCalc \"Trade Pct Transfer\" Calc \"H03a\" false false [Version; DataType; Customer; Product]\nlet Trade_Pct_Calc = newCalc \"Trade Pct Calc\" Calc \"H04\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Basis = newCalc \"Cases Basis\" Input \"M02\" false false [Version; DataType; Customer; Product]\nlet Is_Missing = newCalc \"Is Missing\" Calc \"N01\" false false [Time; Version; DataType; Customer; Product]\nlet Proportion_Exception = newCalc \"Proportion Exception\" Calc \"N02\" false false [Version; DataType; Customer; Product]\nlet Cases_No_Actual = newCalc \"Cases No Actual\" Calc \"O01\" false false [Time; Version; DataType; Customer; Product]\nlet Sales_No_Actual = newCalc \"Sales No Actual\" Calc \"O01b\" false false [Time; Version; DataType; Customer; Product]\nlet Sales_No_Actual_Calc = newCalc \"Sales No Actual Calc\" Calc \"O01b\" false false [Time; Version; DataType; Customer; Product]\nlet Cases_Input_No_Actual = newCalc \"Cases Input No Actual\" Calc \"O02\" false false [Time; Version; DataType; Customer; Product]\nlet Sales_Input_No_Actual = newCalc \"Sales Input No Actual\" Calc \"O03\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Storage_No_Actual = newCalc \"Warehouse Storage No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Promotion_No_Actual = newCalc \"Promotion No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Warehouse_Transfers_No_Actual = newCalc \"Warehouse Transfers No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Trade_No_Actual = newCalc \"Trade No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Off_Invoice_No_Actual = newCalc \"Off Invoice No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_Allowance_No_Actual = newCalc \"Freight Allowance No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Commission_No_Actual = newCalc \"Commission No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet Freight_No_Actual = newCalc \"Freight No Actual\" Calc \"O04\" false false [Time; Version; DataType; Customer; Product]\nlet zSales_CP_ALL_SKU = newCalc \"zSales-CP-ALL_SKU\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_ALL_SKU = newCalc \"zSales-ALL_SKU\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_PC = newCalc \"zSales-PC\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_SO_PC = newCalc \"zSales-SO-PC\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_SO_ALL_SKU = newCalc \"zSales-SO-ALL_SKU\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_CP = newCalc \"zSales-CP\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_CP_PC = newCalc \"zSales-CP-PC\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales = newCalc \"zSales\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zSales_SO = newCalc \"zSales-SO\" Calc \"Z00\" false false [Version; DataType; Customer; Product]\nlet zCommission_CP = newCalc \"zCommission-CP\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_ALL_SKU = newCalc \"zCommission-ALL_SKU\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_SO = newCalc \"zCommission-SO\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_SO_ALL_SKU = newCalc \"zCommission-SO-ALL_SKU\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_CP_PC = newCalc \"zCommission-CP-PC\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_CP_ALL_SKU = newCalc \"zCommission-CP-ALL_SKU\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_PC = newCalc \"zCommission-PC\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission = newCalc \"zCommission\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zCommission_SO_PC = newCalc \"zCommission-SO-PC\" Calc \"Z01\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_SO_PC = newCalc \"zPounds Net-SO-PC\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net = newCalc \"zPounds Net\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_CP_ALL_SKU = newCalc \"zPounds Net-CP-ALL_SKU\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_CP_PC = newCalc \"zPounds Net-CP-PC\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_SO_ALL_SKU = newCalc \"zPounds Net-SO-ALL_SKU\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_SO = newCalc \"zPounds Net-SO\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_ALL_SKU = newCalc \"zPounds Net-ALL_SKU\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_PC = newCalc \"zPounds Net-PC\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zPounds_Net_CP = newCalc \"zPounds Net-CP\" Calc \"Z02\" false false [Version; DataType; Customer; Product]\nlet zFreight_SO_PC = newCalc \"zFreight-SO-PC\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight = newCalc \"zFreight\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_CP_ALL_SKU = newCalc \"zFreight-CP-ALL_SKU\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_SO_ALL_SKU = newCalc \"zFreight-SO-ALL_SKU\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_PC = newCalc \"zFreight-PC\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_ALL_SKU = newCalc \"zFreight-ALL_SKU\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_SO = newCalc \"zFreight-SO\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_CP = newCalc \"zFreight-CP\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_CP_PC = newCalc \"zFreight-CP-PC\" Calc \"Z03\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_CP = newCalc \"zFreight Allowance-CP\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance = newCalc \"zFreight Allowance\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_CP_PC = newCalc \"zFreight Allowance-CP-PC\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_SO_ALL_SKU = newCalc \"zFreight Allowance-SO-ALL_SKU\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_SO_PC = newCalc \"zFreight Allowance-SO-PC\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_SO = newCalc \"zFreight Allowance-SO\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_ALL_SKU = newCalc \"zFreight Allowance-ALL_SKU\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_PC = newCalc \"zFreight Allowance-PC\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zFreight_Allowance_CP_ALL_SKU = newCalc \"zFreight Allowance-CP-ALL_SKU\" Calc \"Z04\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers = newCalc \"zWarehouse Transfers\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_SO_ALL_SKU = newCalc \"zWarehouse Transfers-SO-ALL_SKU\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_SO_PC = newCalc \"zWarehouse Transfers-SO-PC\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_CP_ALL_SKU = newCalc \"zWarehouse Transfers-CP-ALL_SKU\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_CP = newCalc \"zWarehouse Transfers-CP\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_PC = newCalc \"zWarehouse Transfers-PC\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_ALL_SKU = newCalc \"zWarehouse Transfers-ALL_SKU\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_CP_PC = newCalc \"zWarehouse Transfers-CP-PC\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Transfers_SO = newCalc \"zWarehouse Transfers-SO\" Calc \"Z05\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_CP_PC = newCalc \"zWarehouse Storage-CP-PC\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_CP = newCalc \"zWarehouse Storage-CP\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_SO_ALL_SKU = newCalc \"zWarehouse Storage-SO-ALL_SKU\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_SO_PC = newCalc \"zWarehouse Storage-SO-PC\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_SO = newCalc \"zWarehouse Storage-SO\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage = newCalc \"zWarehouse Storage\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_ALL_SKU = newCalc \"zWarehouse Storage-ALL_SKU\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_PC = newCalc \"zWarehouse Storage-PC\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zWarehouse_Storage_CP_ALL_SKU = newCalc \"zWarehouse Storage-CP-ALL_SKU\" Calc \"Z06\" false false [Version; DataType; Customer; Product]\nlet zCases_SO_PC = newCalc \"zCases-SO-PC\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases = newCalc \"zCases\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_CP_PC = newCalc \"zCases-CP-PC\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_SO_ALL_SKU = newCalc \"zCases-SO-ALL_SKU\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_CP_ALL_SKU = newCalc \"zCases-CP-ALL_SKU\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_SO = newCalc \"zCases-SO\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_ALL_SKU = newCalc \"zCases-ALL_SKU\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_PC = newCalc \"zCases-PC\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zCases_CP = newCalc \"zCases-CP\" Calc \"Z07\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input = newCalc \"zTrade Pct Input\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_CP_ALL_SKU = newCalc \"zTrade Pct Input-CP-ALL_SKU\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_CP_PC = newCalc \"zTrade Pct Input-CP-PC\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_CP = newCalc \"zTrade Pct Input-CP\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_SO_ALL_SKU = newCalc \"zTrade Pct Input-SO-ALL_SKU\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_SO_PC = newCalc \"zTrade Pct Input-SO-PC\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_SO = newCalc \"zTrade Pct Input-SO\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_PC = newCalc \"zTrade Pct Input-PC\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\nlet zTrade_Pct_Input_ALL_SKU = newCalc \"zTrade Pct Input-ALL_SKU\" Calc \"Z08\" false false [Version; DataType; Customer; Product]\n\nnewForm Current_Year Base \"\"  \"\"\"SUBST(BudgetStart,1,4)\"\"\" []\nnewForm IsActual Base \"a\"  \"\"\"1\"\"\" [Version?Actual]\nnewForm IsActual Base \"b\"  \"\"\"IF((GetTime <| !Time) < (GetTime <| BudgetStart),1,0)\"\"\" []\nnewForm IsActual_Monthly Base \"\"  \"\"\"IF(DE.INDEX(\"Time\", INSRT(\"/\", STR(NUMBR(!Year) * 100 + NUMBR(!Period), 6, 0), 5)) <= 0, 0, IsActual.For[Time?(INSRT(\"/\", STR(NUMBR(!Year) * 100 + NUMBR(!Period), 6, 0), 5))])\"\"\" []\nnewForm Commission_Rate All \"\"  \"\"\"Commission/Sales\"\"\" []\nnewForm Commission Base \"\"  \"\"\"\n   IF(Sales = 0, NA, Sales * IF(Commission_Rate_Projected = NA, Commission_Rate_Base, Commission_Rate_Projected) * (100 + Commission_Inflation) / 100 + Commission_Adjustment\n   )\"\"\" []\nnewForm Price Consolidated \"\"  \"\"\"Sales/Cases\"\"\" []\nnewForm Price Base \"\"  \"\"\"Sales/Cases\"\"\" [DataType?Value; Version?Actual]\nnewForm Sales Base \"a\"  \"\"\"STET\"\"\" [Version?Budget_Input]\nnewForm Sales Base \"b\"  \"\"\"STET\"\"\" [Version?Actual]\nnewForm Sales Base \"c\"  \"\"\"Cases*Price\"\"\" []\nnewForm Cases_Accum Base \"\"  \"\"\"       (Cases.For[Version?Actual;Time?(      ActualRef    )]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))]) \n       / 3\n+ IF( (Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -3))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -4))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -5))]) <> 0\n     , ( - (Cases.For[Version?Actual;Time?(      ActualRef    )]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))])  \n      + (Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -3))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -4))]+Cases.For[Version?Actual;Time?((TT2 <| ActualRef <| -5))]))\n      / 6      \n      *  IF(AverageMonths.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))] @= \"6\",     1, NA)\n     , NA\n)\"\"\" []\nnewForm Sales_3M All \"\"  \"\"\"Sales.For[Version?Actual;Time?(ActualRef)]+Sales.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Sales.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))]\"\"\" []\nnewForm Price_3M All \"\"  \"\"\"Sales_3M/{Cases 3M???) Not working\"\"\" []\nnewForm Commission_3M Base \"\"  \"\"\"(Commission.For[Version?Actual;Time?(ActualRef)]+Commission.For[Version?Actual;Time?((TT2 <| ActualRef <| -1))]+Commission.For[Version?Actual;Time?((TT2 <| ActualRef <| -2))])/3\"\"\" []\nnewForm Commission_Rate_3M All \"\"  \"\"\"Commission_3M/Sales_3M\"\"\" []\nnewForm Commission_Rate_Base Base \"\"  \"\"\"(Cases.For[DataType?Value] +  \nCommission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] +\nSales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] +\nCommission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] +\nSales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] +\nCommission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\nSales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +                 \nCommission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\nSales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n) * NA\n+\nIF(Cases.For[DataType?Value] = 0, NA,  \n   IF(                       \n        Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] <> NA\n       ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value] /\n            Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value]\n       ,IF(\n            Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n           ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO] /\n                    Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);SO]\n           ,IF(\n                         Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC] /\n                 Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;PC]                 \n                ,Commission.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] /\n                                 Sales.For[Time?(CTimeRef.For[Version?Actual]);Version?(CVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n             )\n         )\n   )\n)\"\"\" [DataType?Calculated_Value]\nnewForm Commission_Rate_Base_Month Base \"\"  \"\"\"Commission_Rate_Base\"\"\" []\nnewForm CRE_Depth_Product All \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n     MIN(\n          IF(de.parentname(\"Product\", !Product, 1) = NA, 999, \n              IF(Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))] = NA, 999, \n                CRE_Depth_Product.For[Product?(de.parentname(\"Product\", !Product, 1))] + 1\n              )\n          ),\n          IF(de.parentname(\"Customer\", !Customer, 1) = NA, 999, \n              IF(Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] = NA, 999, \n                CRE_Depth_Product.For[Customer?(de.parentname(\"Customer\", !Customer, 1))]\n              )\n          )\n    ),\n    0\n)\"\"\" []\nnewForm CRE_Depth_Customer All \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n     MIN(\n          IF(de.parentname(\"Customer\", !Customer, 1) = NA, 999, \n              IF(Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] = NA, 999, \n                CRE_Depth_Customer.For[Customer?(de.parentname(\"Customer\", !Customer, 1))] + 1\n              )\n          ),\n          IF(de.parentname(\"Product\", !Product, 1) = NA, 999, \n              IF(Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))] = NA, 999, \n                CRE_Depth_Customer.For[Product?(de.parentname(\"Product\", !Product, 1))]\n              )\n          )\n    ),\n    0\n)\"\"\" []\nnewForm Commission_Rate_Exception_2 All \"\"  \"\"\"IF(Commission_Rate_Exception = NA,\n     IF(CRE_Depth_Product >= CRE_Depth_Customer, \n          IF(CRE_Depth_Product < 999, Commission_Rate_Exception_2.For[Product?(de.parentname(\"Product\", !Product, 1))], NA),\n          IF(CRE_Depth_Customer < 999, Commission_Rate_Exception_2.For[Customer?(de.parentname(\"Customer\", !Customer, 1))], NA)\n     ),\n     Commission_Rate_Exception\n)\"\"\" [DataType?Value]\nnewForm Commission_Override Base \"\"  \"\"\"IF(Commission_Rate_Projected = NA, NA, Commission_No_Actual)\"\"\" []\nnewForm Commission_Adjustment Base \"\"  \"\"\"Commission_Copy_No_Override - Commission_Original_No_Override\"\"\" [DataType?Calculated_Value]\nnewForm Commission_No_Override Base \"\"  \"\"\"Commission_No_Actual - Commission_Override\"\"\" []\nnewForm Commission_Copy Base \"\"  \"\"\"Commission_Override + Commission_Copy_No_Override\"\"\" []\nnewForm Cases_Buffer_Dif Base \"\"  \"\"\"Cases_Buffer_New-Cases_Buffer\"\"\" []\nnewForm Price_Input All \"\"  \"\"\"Sales_Input/Cases_Input\"\"\" []\nnewForm Customer_Parent Base \"\"  \"\"\"GETATTR(\"Customer\", !Customer, 1, \"CustomerParent\")\"\"\" []\nnewForm Product_Class_Exception_M Base \"\"  \"\"\"Product_Class_Exception\"\"\" [Time?All_Years]\nnewForm Product_Class Base \"\"  \"\"\"IF(Customer_Parent @= \"\", \n   !Product,\n   IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\",\n      Product_Class_Exception.For[Customer?(Customer_Parent)],\n      IF(DE.INDEX(\"Product\", GETATTR(\"Product\", !Product, 1, \"ProductClass\")) <= 0, !Product, \n         IF(Product_Class_Exception.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))]@=\"\",\n            GETATTR(\"Product\", !Product, 1, \"ProductClass\"),\n            Product_Class_Exception.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))]))\n   )\n)\"\"\" []\nnewForm Product_Class_2 Base \"\"  \"\"\"IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\",\n      !Product,\n      GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n   )\"\"\" []\nnewForm Is_Exception Base \"\"  \"\"\"GETATTR(\"Product\", !Product, 1, \"ProductClass\") @<> Product_Class\"\"\" []\nnewForm Cases_Proportion Base \"\"  \"\"\"IF(Cases_Basis=0,NA,Cases_Basis/Cases_Basis.For[Customer?(Customer_Parent);Product?(Product_Class_2)])\"\"\" []\nnewForm Cases_Projected Base \"b\"  \"\"\"IF(IsActual=1,Cases.For[Version?Actual],\n   IF(Cases_Basis=0,NA,\n      Cases_Proportion\n      *Cases_Input.For[Customer?(Customer_Parent);Product?(\n            IF(Product_Class_Exception.For[Customer?(Customer_Parent)]=NA\n               ,GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n              ,!Product)\n        )])\n)\"\"\" []\nnewForm Price_Projected Base \"\"  \"\"\"IF(IsActual=1,Price.For[Version?Actual],\n   IF(Cases_Basis=0,NA,\n      Price_Input.For[Customer?(Customer_Parent);Product?(\n            IF(Product_Class_Exception.For[Customer?(Customer_Parent)]=NA\n               ,GETATTR(\"Product\", !Product, 1, \"ProductClass\")\n              ,!Product)\n        )]\n    )\n)\"\"\" []\nnewForm Pounds_per_case___Gross Base \"\"  \"\"\"IF(Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value] = NA, NA, Pounds_Gross.For[Version?Actual;Time?(UPTimeRef);DataType?Value] / Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value])\"\"\" [DataType?Calculated_Value]\nnewForm Pounds_per_case___Net Base \"\"  \"\"\"IF(Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value] = NA, NA, Pounds_Net.For[Version?Actual;Time?(UPTimeRef);DataType?Value] / Cases.For[Version?Actual;Time?(UPTimeRef);DataType?Value])\"\"\" [DataType?Calculated_Value]\nnewForm Pounds_Net Base \"\"  \"\"\"Cases * Pounds_per_case___Net\"\"\" []\nnewForm Pounds_Gross Base \"\"  \"\"\"Cases * Pounds_per_case___Gross\"\"\" []\nnewForm Freight_per_pound_base Base \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\nFreight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n) * NA\n+\nIF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n   IF(\n       Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n      ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n       Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n      ,IF(                 \n          Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n         ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n          Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n          ,IF(                     \n              Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n             ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n             ,IF(                     \n                 Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                 Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                ,IF(                     \n                    Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                   ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                   ,Freight.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                   )\n                )\n            )\n        )\n    )\n)\"\"\" [DataType?Calculated_Value]\nnewForm Freight Base \"\"  \"\"\"IF( Cases = 0\n   ,NA \n   ,IF( [Value] = 0, 1, 0)\n)\"\"\" [DataType?Validation]\nnewForm Freight Base \"\"  \"\"\" Freight_per_pound_base * Pounds_Net * ((100 + Freight_Inflation) / 100) * ((100 + Freight_Seasonality) / 100) + Freight_Adjustment\"\"\" []\nnewForm Freight_per_pound All \"\"  \"\"\"Freight / Pounds_Net\"\"\" []\nnewForm Freight_Adjustment Base \"\"  \"\"\"Freight_Copy - Freight_Original\"\"\" [DataType?Calculated_Value]\nnewForm Freight_Allowance Base \"\"  \"\"\" Freight_Allowance_per_pound_base * Pounds_Net * ((100 + Freight_Allowance_Inflation) / 100) * ((100 + Freight_Allowance_Seasonality) / 100) + Freight_Allowance_Adjustment\"\"\" []\nnewForm Freight_Allowance_per_pound_base Base \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\nFreight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n) * NA\n+\nIF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n   IF(\n       Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n      ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n       Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n      ,IF(                 \n          Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n         ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n          Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n          ,IF(                     \n              Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n             ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n             ,IF(                     \n                 Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                 Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                ,IF(                     \n                    Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                   ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                   ,Freight_Allowance.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                   )\n                )\n            )\n        )\n    )\n)\"\"\" [DataType?Calculated_Value]\nnewForm Freight_Allowance_Adjustment Base \"\"  \"\"\"Freight_Allowance_Copy - Freight_Allowance_Original\"\"\" [DataType?Calculated_Value]\nnewForm Freight_Allowance_per_pound Base \"\"  \"\"\"Freight_Allowance / Pounds_Net\"\"\" []\nnewForm Warehouse_Transfers_per_pound All \"\"  \"\"\"Warehouse_Transfers / Pounds_Net\"\"\" []\nnewForm Warehouse_Transfers Base \"\"  \"\"\"Warehouse_Transfers_per_pound_base * Pounds_Net *  ((100 + Warehouse_Transfers_Inflation) / 100) * ((100 + Warehouse_Transfers_Seasonality) / 100) + Warehouse_Transfers_Adjustment\"\"\" []\nnewForm Warehouse_Transfers_per_pound_base Base \"\"  \"\"\"(Pounds_Net.For[DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \nPounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\nWarehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] \n) * NA\n+\nIF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n   IF(\n       Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n      ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n       Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n      ,IF(                 \n          Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n         ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n          Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n          ,IF(                     \n              Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n             ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n              Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n             ,IF(                     \n                 Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                 Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                ,IF(                     \n                    Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                   ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                   ,Warehouse_Transfers.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                    Pounds_Net.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                   )\n                )\n            )\n        )\n    )\n)\"\"\" [DataType?Calculated_Value]\nnewForm Warehouse_Transfers Base \"\"  \"\"\"IF( Cases = 0\n   ,NA \n   ,IF( [Value] = 0, 1, 0)\n)\"\"\" [DataType?Validation]\nnewForm Warehouse_Transfers_Adjustment Base \"\"  \"\"\"Warehouse_Transfers_Copy - Warehouse_Transfers_Original\"\"\" [DataType?Calculated_Value]\nnewForm Warehouse_Storage Base \"\"  \"\"\"IF( Cases = 0\n   ,NA \n   ,IF( [Value] = 0, 1, 0)\n)\"\"\" [DataType?Validation]\nnewForm Warehouse_Storage_per_case_base Base \"\"  \"\"\"(Cases.For[DataType?Value] +\nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] +\nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] + \nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] +\nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] + \nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] + \nCases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] +\nWarehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n) * NA\n+\nIF(Cases_No_Actual.For[DataType?Value] = 0, NA,\n   IF(\n       Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] <> NA\n      ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value] / \n       Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value]\n      ,IF(                 \n          Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] <> NA\n         ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC] / \n          Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;PC]\n          ,IF(                     \n              Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] <> NA\n             ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU] / \n              Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;ALL_SKU]\n             ,IF(                     \n                 Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] <> NA\n                ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO] / \n                 Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO]\n                ,IF(                     \n                    Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] <> NA\n                   ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC] / \n                    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;PC]\n                   ,Warehouse_Storage.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU] / \n                    Cases.For[Time?(DTimeRef.For[Version?Actual]);Version?(DVersionRef.For[Version?Actual]);DataType?Value;SO;ALL_SKU]\n                   )\n                )\n            )\n        )\n    )\n)\"\"\" [DataType?Calculated_Value]\nnewForm Warehouse_Storage Base \"\"  \"\"\"Warehouse_Storage_per_case_base * Cases *  ((100 + Warehouse_Storage_Inflation) / 100) * ((100 + Warehouse_Storage_Seasonality) / 100) + Warehouse_Storage_Adjustment\"\"\" []\nnewForm Warehouse_Storage_per_case All \"\"  \"\"\"Warehouse_Storage / Cases\"\"\" []\nnewForm Warehouse_Storage_Adjustment Base \"\"  \"\"\"Warehouse_Storage_Copy - Warehouse_Storage_Original\"\"\" [DataType?Calculated_Value]\nnewForm Trade_Pct_Input Consolidated \"\"  \"\"\"Trade_Input / Sales_No_Actual_Calc * 100\"\"\" []\nnewForm Promotion Base \"\"  \"\"\"Trade - Off_Invoice\"\"\" []\nnewForm Off_Invoice Base \"\"  \"\"\"Trade * Off_Invoice_Split_Pct\"\"\" []\nnewForm Trade_Input Base \"\"  \"\"\"IF(Sales_No_Actual <= 0, NA, Sales_No_Actual * IF(Trade_Pct_Input = -1, 0, Trade_Pct_Input) / 100)\"\"\" []\nnewForm Trade_Pct_Base_E Base \"\"  \"\"\"(Sales.For[DataType?Value] +\nTrade_Pct_Input.For[DataType?Value;CP;ALL_SKU] +\nTrade_Pct_Input.For[DataType?Value;CP;PC] +\nTrade_Pct_Input.For[DataType?Value;CP] +\nTrade_Pct_Input.For[DataType?Value;SO;ALL_SKU] + \nTrade_Pct_Input.For[DataType?Value;SO;PC] +\nTrade_Pct_Input.For[DataType?Value;SO] +\nTrade_Pct_Input.For[DataType?Value;ALL_SKU] + \nTrade_Pct_Input.For[DataType?Value;PC] +\nTrade_Pct_Input\n) * NA\n+\nIF(Sales_No_Actual.For[DataType?Value] <= 0, NA,\n   IF(\n        Trade_Pct_Input = -1, 0, IF( Trade_Pct_Input = NA\n        ,IF(                 \n          Trade_Pct_Input.For[DataType?Value;PC] = -1, 0, IF(Trade_Pct_Input.For[DataType?Value;PC] = NA\n           ,IF(                     \n              Trade_Pct_Input.For[DataType?Value;ALL_SKU] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;ALL_SKU] = NA\n              ,IF(                     \n                 Trade_Pct_Input.For[DataType?Value;SO] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO] = NA\n                  ,IF(                     \n                    Trade_Pct_Input.For[DataType?Value;SO;PC] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO;PC] = NA\n                    ,IF(                     \n                       Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] = NA\n                       ,IF(                     \n                          Trade_Pct_Input.For[DataType?Value;CP] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;CP] = NA\n                           ,IF(                     \n                             Trade_Pct_Input.For[DataType?Value;CP;PC] = -1, 0, IF( Trade_Pct_Input.For[DataType?Value;CP;PC] = NA\n                            ,Trade_Pct_Input.For[DataType?Value;CP;ALL_SKU] \n                            ,Trade_Pct_Input.For[DataType?Value;CP;PC]\n                            ))\n                           ,Trade_Pct_Input.For[DataType?Value;CP] \n                           ))\n                         ,Trade_Pct_Input.For[DataType?Value;SO;ALL_SKU] \n                        ))\n                        ,Trade_Pct_Input.For[DataType?Value;SO;PC] \n                    ))\n                    ,Trade_Pct_Input.For[DataType?Value;SO]\n                ))\n                ,Trade_Pct_Input.For[DataType?Value;ALL_SKU] \n            ))\n            ,Trade_Pct_Input.For[DataType?Value;PC] \n        ))\n        , Trade_Pct_Input\n    ))\n)\"\"\" [DataType?Calculated_Value]\nnewForm Trade_Base_Pre Base \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Base_E / 100\"\"\" []\nnewForm Trade_Pct_Base_Pre Consolidated \"\"  \"\"\"Trade_Base_Pre / Sales_No_Actual_Calc * 100\"\"\" []\nnewForm Trade_Pct_Base_Pre Base \"\"  \"\"\"Trade_Pct_Base_E\"\"\" []\nnewForm Trade_Actual Base \"\"  \"\"\"IF(IsActual=1, Trade, NA)\"\"\" [DataType?Value]\nnewForm Sales_FY Base \"\"  \"\"\"Sales.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\nnewForm Sales_YTG Base \"\"  \"\"\"Sales_No_Actual.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\nnewForm Trade_YTD Base \"\"  \"\"\"Trade_Actual.For[Time?(TBudgetRefYear.For[Version?Actual])]\"\"\" [DataType?Calculated_Value]\nnewForm Trade_BOY Base \"\"  \"\"\"IF( Sales_FY > 0, \n     IF( Trade_Pct_Base_E * Sales_FY / 100 >= Trade_YTD, Trade_Pct_Base_E * Sales_FY / 100 - Trade_YTD, NA),\n     Trade_Pct_Base_E * Sales_FY / 100 - Trade_YTD\n)\"\"\" []\nnewForm Trade_Pct_Base All \"\"  \"\"\"IF(Sales_FY <> 0, \n     Trade_BOY / Sales_YTG_Calc * 100,\n     IF(Sales_No_Actual <> 0, Trade_Pct_Base_Pre , NA)\n)\"\"\" []\nnewForm Sales_YTG_Calc Base \"\"  \"\"\"IF(Trade_BOY = NA, NA, Sales_YTG)\"\"\" []\nnewForm Sales_FY_Calc Base \"\"  \"\"\"IF(Trade_YTD + Trade_BOY = NA, NA, Sales_FY)\"\"\" []\nnewForm Trade_Base Base \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Base / 100\"\"\" []\nnewForm Trade_Pct_Override Consolidated \"\"  \"\"\"Trade_Override.For[Time?All_Years]/Sales_No_Actual.For[Time?All_Years]*100\"\"\" []\nnewForm Trade_Override Base \"\"  \"\"\"Sales_No_Actual * Trade_Pct_Override / 100\"\"\" []\nnewForm Off_Invoice_Split_Pct Base \"\"  \"\"\"Off_Invoice.For[Time?(ActualRef);Version?Actual_12M]/Trade.For[Time?(ActualRef);Version?Actual_12M]\"\"\" []\nnewForm Promotion_Split_Pct Base \"\"  \"\"\"1-Off_Invoice_Split_Pct\"\"\" []\nnewForm Trade Base \"\"  \"\"\"Off_Invoice + Promotion\"\"\" [DataType?Value; Version?Actual]\nnewForm Trade_Pct Consolidated \"\"  \"\"\"Trade_No_Actual.For[Time?All_Years]/Sales_No_Actual.For[Time?All_Years]*100\"\"\" []\nnewForm Trade_Pct Base \"\"  \"\"\" IF(Is_Trade_Override =NA, Trade_Pct_Base, Trade_Pct_Override)\"\"\" []\nnewForm Trade Base \"\"  \"\"\"Sales_No_Actual * IF(Is_Trade_Override =NA, Trade_Pct_Base, Trade_Pct_Override) / 100\"\"\" []\nnewForm Trade_Pct_Transfer Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct)\"\"\" []\nnewForm Trade_Pct_Calc All \"\"  \"\"\"Trade/Sales\"\"\" []\nnewForm Is_Missing Base \"\"  \"\"\"IF(Cases_Input = 0, NA, IF(Cases_Basis.For[Customer?(Customer_Parent);Product?(Product_Class)] = 0, 1, NA))\"\"\" []\nnewForm Proportion_Exception Base \"\"  \"\"\"IF(Product_Class_Exception.For[Customer?(Customer_Parent)]@<>\"\", 1\n   ,Allocation_Weight.For[Customer?(Customer_Parent)]\n   /Allocation_Weight.For[Customer?(Customer_Parent);Product?(GETATTR(\"Product\", !Product, 1, \"ProductClass\"))])\n*Cases_Accum.For[Product?(Product_Class)]\"\"\" []\nnewForm Cases_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Cases)\"\"\" []\nnewForm Sales_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Sales)\"\"\" []\nnewForm Sales_No_Actual_Calc Base \"\"  \"\"\"IF(IsActual=1,NA, IF(Trade_Base_Pre = NA, NA, Sales))\"\"\" []\nnewForm Cases_Input_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Cases_Input)\"\"\" []\nnewForm Sales_Input_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Sales_Input)\"\"\" []\nnewForm Warehouse_Transfers_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Warehouse_Transfers)\"\"\" []\nnewForm Warehouse_Storage_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Warehouse_Storage)\"\"\" []\nnewForm Trade_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Trade)\"\"\" []\nnewForm Freight_Allowance_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Freight_Allowance)\"\"\" []\nnewForm Off_Invoice_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Off_Invoice)\"\"\" []\nnewForm Promotion_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Promotion)\"\"\" []\nnewForm Commission_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Commission)\"\"\" []\nnewForm Freight_No_Actual Base \"\"  \"\"\"IF(IsActual=1,NA, Freight)\"\"\" []\nnewForm zSales_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zSales_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Sales.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCommission Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Commission.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zPounds_Net_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Pounds_Net.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zFreight_Allowance_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Freight_Allowance.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Transfers_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Transfers.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zWarehouse_Storage_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Warehouse_Storage.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[SO;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[ALL_SKU;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[PC;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zCases_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Cases.For[CP;Time?(zTimeRef.For[Version?Actual]);Version?(zVersionRef.For[Version?Actual])])\"\"\" []\nnewForm zTrade_Pct_Input Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input)\"\"\" []\nnewForm zTrade_Pct_Input_CP_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP;ALL_SKU])\"\"\" []\nnewForm zTrade_Pct_Input_CP_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP;PC])\"\"\" []\nnewForm zTrade_Pct_Input_CP Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[CP])\"\"\" []\nnewForm zTrade_Pct_Input_SO_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO;ALL_SKU])\"\"\" []\nnewForm zTrade_Pct_Input_SO_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO;PC])\"\"\" []\nnewForm zTrade_Pct_Input_SO Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[SO])\"\"\" []\nnewForm zTrade_Pct_Input_PC Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[PC])\"\"\" []\nnewForm zTrade_Pct_Input_ALL_SKU Base \"\"  \"\"\"IF(Sales_No_Actual = NA, NA, Trade_Pct_Input.For[ALL_SKU])\"\"\" []\n\n\n", "snpParentIdO": {"SnippetId" :"80056cda-4f3b-46ee-85a9-bd085fc10ea1"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e8ed4b6d-8930-46e8-ada3-663f0d90fe13"}, "snpName": "RuleEditor", "snpContent": "#define FSS_SERVER\n#r @\"..\\packages\\Owin\\lib\\net40\\Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin\\lib\\net45\\Microsoft.Owin.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Hosting\\lib\\net45\\Microsoft.Owin.Hosting.dll\"\n#r @\"..\\packages\\Microsoft.Owin.Host.HttpListener\\lib\\net45\\Microsoft.Owin.Host.HttpListener.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\WebSharper.Owin.dll\"\n#r @\"..\\packages\\WebSharper.Owin\\lib\\net461\\HttpMultipartParser.dll\"\n#r @\"..\\packages\\WebSharper\\lib\\net461\\WebSharper.Core.JavaScript.dll\"\n#r @\"..\\packages\\Microsoft.Owin.StaticFiles\\lib\\net45\\Microsoft.Owin.StaticFiles.dll\"\n#r @\"..\\packages\\Microsoft.Owin.FileSystems\\lib\\net45\\Microsoft.Owin.FileSystems.dll\"\n\nopen WebSharper.Sitelets\nopen WebSharper.UI.Html\n\n[< JavaScript false >]\nmodule server =\n    open WebSharper.UI.Server\n    open WebSharper.UI.Templating\n    \n    type EndPoint = | [< EndPoint \"/\" >] EP\n    \n    let content (ctx:Context<EndPoint>) (endpoint:EndPoint) : Async<Content<EndPoint>> =\n        Content.Page(Title = \"Main Page\" \n                   , Body = [\n                       Html.client <@  layout() @> \n                       Doc.Verbatim (System.IO.File.ReadAllText TemplatesFileName)\n                     ])\n    \n    open global.Owin\n    open WebSharper.Owin\n    open Microsoft.Owin.Hosting\n    open Microsoft.Owin.StaticFiles\n    open Microsoft.Owin.FileSystems\n    open WebSharper.Owin.WebSocket\n    open WSMessagingBroker\n    \n    let url         = \"http://localhost:9041/\"\n    let epWebSocket = Endpoint.Create(url, \"/ws\", JsonEncoding.Readable)\n    let brokerAgent = Broker.BrokerAgent epWebSocket\n    Broker.BrokerAgent.FssWebSocketO <- Some brokerAgent\n    [< EntryPoint >]\n    let Main args =\n        use server = \n            WebApp.Start(url, fun appB ->\n                appB.UseWebSharper(WebSharperOptions(ServerRootDirectory = \"website\"\n                                                   , Sitelet             = Some (Application.MultiPage content)\n                                                   , BinDirectory        = \".\"\n                                                   , Debug               = true))\n                    .UseStaticFiles(StaticFileOptions(FileSystem = PhysicalFileSystem(\"website\")))\n                    .UseWebSocket(epWebSocket, brokerAgent.Start, maxMessageSize = 1_000_000)\n                |> ignore\n            )\n        stdout.WriteLine(\"Starting, hit enter to finish\")\n        stdin.ReadLine() |> ignore\n        0\n    \n    ", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"09876215-2ab1-4978-926b-51922548dbae"}, {"SnippetId" :"162d452a-3f08-4bfe-8adb-2f3bf1585560"}, {"SnippetId" :"5416e265-2418-4907-8810-4dc99bafe392"}, {"SnippetId" :"54807aa7-91ba-442b-8a0e-ef96fb9b681b"}, {"SnippetId" :"9d50c3d6-b8b4-4e9e-b4d4-78b864810b65"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bf6c3b8a-e25f-41ac-be85-fc2563b1da77"}, "snpName": "compile & run RuleEditor", "snpContent": "#if WEBSHARPER\n#else    \n#r @\"Compiled\\FSCompilerDll\\FSCompilerDll.dll\"\nopen FSSGlobal\n#endif    \n\nopen System.IO\nopen WSMessagingBroker\nopen Useful\nopen UsefulDotNet\nopen UsefulDotNet.CompOptionsModule\nopen RunProcess\n\nWrap.wrapper {\n    let  options         = compileOptionsExeDebug \"FSSGlobal/WebSharper Code/Calculation Editor Code/RuleEditor\"\n                           + siteOptions\n                           + (opGenInternal /= \"showoptions\")\n                           + (opPlatform    /= \"x86\"        )\n    let  exeFile         = options?OutputFile\n    let  workDir         = options?Directory\n    let  site            = Path.GetFullPath(options?Website)\n#if WEBSHARPER\n    let! res             = FStationMessaging(\"Compile WebSharper\", FSharp).CompileSnippetW options\n#else    \n    let! res             = FStationMessaging(\"Compile WebSharper\", \"##FSHARPSTATION_ID##\").CompileSnippetW options\n#endif    \n    do   printfn           \"Starting %s\"     exeFile\n    let  url             = @\"http://localhost:9041/\"\n    let  parms           = sprintf \"%A %A\" site url \n    do   startProcessDir   exeFile parms workDir |> ignore\n    do   startProcess      url     \"\"            |> ignore\n    return res\n} |> Wrap.runSynchronouslyS true |> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"aa468704-7a6b-4fb2-be60-76807b2eb65d"}, "snpName": "---- General design -----", "snpContent": "User Interface:\n- Calculations\n- Formulas\n- Cubes:\n    - Calc cubes\n    - Other Cubes\n- Converted Rules text with keys\n\nSave/Load API:\n  - Load\n  - Save\n  - Dirty Flag\n\nAlea Interfase using RPC:\n- Create calc Dimensions including TCalc\n\t- Load Attributes\n- Create Cubes\n- Load Rules\n\nF# Calculation Model (FSI):\n    Input Always:\n    \tDimensions\n    \tCubes(calc)\n    \tCubes(other)\n    \tGlobal Definitions\n    \tCalculation: names, types\n    Input Partial:\n    \tOther Cube Rules\n    \tCalculations\n    Output\n\t    Cube Rules (keys + text)", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e01c4aa8-1574-4de8-8d1f-856c822592af"}, "snpName": "///translate", "snpContent": "open FsEvaluator\n\nlet updateRules() =\n    Wrap.wrap {\n        outputMsgs.Value <- \"Updating rules...\"\n        let  fs0          = codeFS.Value\n        let  pre          = \"////-d:FSI32BIT\\n\"\n        let  fs           = pre + fs0 + unindentStr \"\"\"\n                open FSSGlobal.Useful\n                \n                InitModel.initModel\n                |> Model.prepareModel \n                |> CalcRules.addModelRules\n                |> WriteRules.createCubesR\n                |> Result.getMsgs |> Seq.iter (printfn \"%A\")\n        \"\"\"\n#if FSS_SERVER\n        let! resA         = evaluateAR \"RuleEditor\" JS.Window.Location.Href true fs\n        let! res          = resA\n        ()\n#else\n        let! res          = autoCompleteClient.MessagingClient.EvaluateFS fs\n        showOutText [| \"+\" ; res |]\n#endif        \n    }\n    \nlet updateRulesA = updateRules >> ignore    \n\nopen FsStationShared\n\nlet respond (msg:FSMessage) : Wrap<FSResponse> =\n    wrap {\n        match msg with\n        | RunActionCall (nm,ac, ps) when ac = \"actOutText\" -> showOutText ps\n                                                              return StringResponseR(Some \"ok\", [|                                                   |])\n        | _                                                -> return StringResponseR(None     , [| \"Sorry I don't know, just a Rule Editor\", FSError |])\n    }     \n\nlet wsStationClient = new WSMessagingBroker.WSMessagingClient \"RuleEditor\"\nif IsClient then\n    async {\n        do! Async.Sleep 1000\n        while true do\n            try       wsStationClient.ProcessIncoming respond\n                      do! Async.Sleep 60000\n            with e -> printfn \"%s\" e.Message\n                      do! Async.Sleep 1000\n    } |> Async.Start\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f74e568b-473d-4f0e-a38a-ad8c70d05abb"}, "snpName": "///Actions", "snpContent": "    let DoW  f p   _ _ = f p   |> Wrap.map ignore |> Wrap.start addOutMsg\n    let DoW2 f p t     = DoW (fun p' -> f t p') p\n    \n    \n    //let actLoadFile       = Template.Action.New(\"Load...\"                    ).OnClick( do_LoadFile                    )  \n    let actSaveFile       = Template.Action.New(\"Save as...\"                 ).OnClick( Do   downloadFile      ()      ).Highlight(dirty)\n    let actAddCalculation = Template.Action.New(\"Add Calculation\"            ).OnClick( Do (updateModel model) AddCalculation )\n    let actDeleteSnippet  = Template.Action.New(\"Delete Snippet\"             )//.OnClick( Do   deleteCode        ()      ).Disabled(noSelectionVal      )\n    let actIndentSnippet  = Template.Action.New(\"Indent In  >>\"              )//.OnClick( Do   indentCodeIn      ()      ).Disabled(noSelectionVal      )\n    let actOutdentSnippet = Template.Action.New(\"Indent Out <<\"              )//.OnClick( Do   indentCodeOut     ()      ).Disabled(noSelectionVal      )\n    let actGetFsCode      = Template.Action.New(\"Get F# Code\"                ).OnClick( Do   getFSCodeA        ()      )//.Disabled(disableParseVal     )\n    let actSetSnippetProp = Template.Action.New(\"actSetSnippetProp\"          )//.OnClick2(DoW2 setSnippetProp    ()      ).Disabled(disableFSIVal       )\n    let actEvalFsCode     = Template.Action.New(\"Run FSI on Code\"            )//.OnClick2(DoW2 evalFsCode        ()      ).Disabled(disableFSIVal       )\n    let actEvalCode       = Template.Action.New(\"Update Rules\"               ).OnClick(DoW   updateRules       ()      )//.Disabled(disableFSIVal       )\n    let actFableFsCode    = Template.Action.New(\"Run Fable on Code\"          )//.OnClick2(DoW2 evalFableCode     ()      ).Disabled(disableFableVal     )\n    let actFableCode      = Template.Action.New(\"Run Fable\"                  )//.OnClick2(DoW2 fableFS2          ()      ).Disabled(disableFableVal     )\n    let actRunWSNewTab    = Template.Action.New(\"Run WebSharper in new tab\"  )//.OnClick2(DoW2 compileRunP2   NewBrowser ).Disabled(disableWebSharperVal)\n    let actRunWSHere      = Template.Action.New(\"Run WebSharper in WS Result\")//.OnClick2(DoP2 compileRunP2   Below      ).Disabled(disableWebSharperVal)\n    let actRunWSIn        = Template.Action.New(\"Run WebSharper in ...\"      )//.OnClick( DoP  compileRun        ()      ).Disabled(disableWebSharperVal)\n    let actParseCode      = Template.Action.New(\"Parse F#\"                   ).OnClick( Do   getJSCodeA        ()      )//.Disabled(disableParseVal     )\n    let actCompileWS      = Template.Action.New(\"Compile WebSharper\"         )//.OnClick( DoW  justCompile       ()      ).Disabled(disableWebSharperVal)\n    let actFindDefinition = Template.Action.New(\"Find Definition\"            )//.OnClick( Do   gotoDefinition    ()      ).Disabled(disableParseVal     )\n    let actRefreshEditor  = Template.Action.New(\"Refresh CodeMirror\"         )//.OnClick( Do   refreshCodeMirror ()      )\n    let actOutText        = Template.Action.New(\"Show Output text\"           )//.OnClick2(Do2  showOutText       ()      )\n    let actAbortFsi       = Template.Action.New(\"Abort FSI\"                  )//.OnClick( Do   abortFsiExe       ()      )\n\n    let selectChild ch p =\n        match ch with\n        | Node tid -> SelectTotal       tid |> processor\n        | Leaf cid -> SelectCalculation cid |> processor\n\n    let buttonsHOld =\n        div [ \n              actAddCalculation.Button.Render\n              actOutdentSnippet.Button.Render\n              actIndentSnippet .Button.Render\n              loadFileElement         .Render.AddChildren([ style \"grid-column: 4/6\" ])\n              actEvalCode      .Button.Render\n              actFableCode     .Button.Render\n              actRunWSIn       .Button.Render\n    \n              actDeleteSnippet .Button.Render\n              actFindDefinition.Button.Render\n              span []       \n              actSaveFile      .Button.Render\n              span []       \n              actGetFsCode     .Button.Render\n              actParseCode     .Button.Render\n              //Doc.Select [ attr.id \"Position\" ] positionTxt [ NewBrowser ; Below ] position |> someElt\n    \n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n    \n    let menuLeft =\n        Menu.New2\n          [\n            MenuEntry.New(\"File\")\n                .SubMenu(\n                        [\n                            //actLoadFile.MenuEntry\n                            actSaveFile.MenuEntry\n                        ]           \n                )            \n            MenuEntry.New(\"Code\")           \n                .SubMenu(           \n                        [           \n                            actAddCalculation.MenuEntry\n                            actDeleteSnippet .MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actIndentSnippet .MenuEntry\n                            actOutdentSnippet.MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actFindDefinition.MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actGetFsCode     .MenuEntry\n                            MenuEntry.New(\"\").Divider           \n                            actRefreshEditor .MenuEntry\n                        ]     \n                )      \n            MenuEntry.New(\"Run\")     \n                .SubMenu(     \n                        [     \n                            actEvalCode      .MenuEntry\n                            actAbortFsi      .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actFableCode     .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actRunWSNewTab   .MenuEntry\n                            actRunWSHere     .MenuEntry\n                            MenuEntry.New(\"\").Divider     \n                            actParseCode     .MenuEntry\n                            actCompileWS     .MenuEntry\n                        ]\n                ) \n          ]\n    \n    let menuRight =\n        Menu.New2\n          [\n            MenuEntry.New(\"About\")\n                .SubMenu [\n                    MenuEntry.New(\"Source @ GitHub\", \"https://github.com/amieres/FSharpStation\").Target \"_blank\"\n                ]\n          ]      \n    \n    let menuBar =\n        navbar <| h1 [ htmlText \"Rule Editor\" ; style \"font-size: 48px; margin-top: -17px\" ]\n               <| menuLeft .Render \n               <| menuRight.Render\n\n    ()", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"1da05dcf-8d1b-4f21-b570-389d3e1030b2"}, {"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}, {"SnippetId" :"a6966f1d-4d4c-4ac2-be2d-7aeb76e2e2e2"}, {"SnippetId" :"dd65606a-9194-4699-8c83-25dd52970a44"}, {"SnippetId" :"e01c4aa8-1574-4de8-8d1f-856c822592af"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"df220a82-0d24-4992-ba0c-4e043b9c596d"}, "snpName": "///Layout", "snpContent": "  \n    Layout.AddGuids\n      [|\n          //\"actLoadFile\"       , GuiAction actLoadFile      \n          \"actSaveFile\"       , GuiAction actSaveFile      \n          \"actAddCalculation\" , GuiAction actAddCalculation\n          \"actDeleteSnippet\"  , GuiAction actDeleteSnippet \n          \"actIndentSnippet\"  , GuiAction actIndentSnippet \n          \"actOutdentSnippet\" , GuiAction actOutdentSnippet\n          \"actGetFsCode\"      , GuiAction actGetFsCode     \n          \"actSetSnippetProp\" , GuiAction actSetSnippetProp\n          \"actEvalFsCode\"     , GuiAction actEvalFsCode\n          \"actEvalCode\"       , GuiAction actEvalCode\n          \"actRunFableFs\"     , GuiAction actFableFsCode\n          \"actRunFable\"       , GuiAction actFableCode\n          \"actRunWSNewTab\"    , GuiAction actRunWSNewTab   \n          \"actRunWSHere\"      , GuiAction actRunWSHere     \n          \"actRunWSIn\"        , GuiAction actRunWSIn       \n          \"actParseCode\"      , GuiAction actParseCode     \n          \"actCompileWS\"      , GuiAction actCompileWS     \n          \"actFindDefinition\" , GuiAction actFindDefinition    \n          \"actOutText\"        , GuiAction actOutText\n          \"Output\"            , GuiNode <| div [ TemplateLib.Output().Var(outputMsgs)                   .Doc() |> SomeDoc ]\n          \"Parser\"            , GuiNode <| div [ TemplateLib.Parser().Var(parserMsgs).JumpRef(jumpToRef).Doc() |> SomeDoc ] \n          \"F# code\"           , GuiNode <| div [ TemplateLib.FSCode().Var(codeFS    )                   .Doc() |> SomeDoc ] \n          //\"Properties\"        , GuiNode <| properties    \n          \"Dimensions\"        , GuiNode dimensions\n          \"Dimensionality\"    , GuiNode dimsSelected\n          \"Global\"            , GuiNode globalDefinitions\n          //\"title\"             , GuiNode <| Template.Input.New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\").Render\n          //\"code\"              , GuiNode <| codeMirrorRender\n          //\"snippets\"          , GuiNode <| snippetList\n          \"calculations\"      , GuiNode <| calculations\n          \"calcDetail\"        , GuiNode <| calcDetail\n          \"buttons\"           , GuiNode <| buttonsH\n          \"menu\"              , GuiNode <| HtmlEmpty //menuBar\n          \"messagesR\"         , GuiTabStrip(     true ,  [| \"Dimensionality\" \n                                                            \"Dimensions\"     \n                                                            \"Global\"         |])\n          \"messagesB1\"        , GuiTabStrip(     true ,  [| \"Output\"    \n                                                            \"F# code\"        |])\n          \"messagesB2\"        , GuiTabStrip(     true ,  [| \"Parser\"         |])\n          \"messagesB\"         , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n          \"title_code\"        , fixedHorSplitter true   34.0 \"title\"         \"code\"\n          \"calc-detail\"       , varHorSplitter          65.0 \"calculations\"  \"calcDetail\"    25.0  90.0\n          \"code_props\"        , varVerSplitter          85.0 \"calc-detail\"   \"messagesR\"     25.0 100.0\n          \"code_buttons\"      , fixedHorSplitter false  80.0 \"code_props\"    \"buttons\"\n          \"snippets_code\"     , varVerSplitter          00.0 \"snippets\"      \"code_buttons\"   0.0  95.0\n          \"main_messages\"     , varHorSplitter          82.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n          \"extrabuttons\"      , GuiNode <| div []\n          \"main_extra\"        , varVerSplitter         100.0 \"main_messages\" \"extrabuttons\"  20.0 100.0\n          \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n      |]   \n  \nlet layout() = Layout.New <| steps()\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"1da05dcf-8d1b-4f21-b570-389d3e1030b2"}, {"SnippetId" :"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"}, {"SnippetId" :"dd65606a-9194-4699-8c83-25dd52970a44"}, {"SnippetId" :"f74e568b-473d-4f0e-a38a-ad8c70d05abb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a603acee-c77c-4720-9158-0aa9b96c18be"}, "snpName": "///Main", "snpContent": "let main() =\n    div [\n        style \"height: 100vh; width: 100% \"\n        layout().Render.Style(\"height: 100%; width: 100% \")\n        //layout() |> SomeDoc \n        script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                ; ``type`` \"text/javascript\" ]\n        script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"     ; ``type`` \"text/javascript\" ]\n        link   [ href \"/fontello-9bad3f16/css/checkbox.css\"                                         ; rel \"stylesheet\" ]\n        link   [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\" ; ``type`` \"text/css\"        ; rel \"stylesheet\" ]    \n        style  \"\"\" \n              color      : #333;\n              font-size  : small;\n              font-family: monospace;\n              line-height: 1.2;\n               \"\"\"\n        link [ href \"/fontello-9bad3f16/css/checkbox.css\" ; rel \"stylesheet\" ]\n        \n    ] \n\n//main() |> RunCode.RunNode().RunHtml\n\n//if IsClient then initData()\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"162d452a-3f08-4bfe-8adb-2f3bf1585560"}, {"SnippetId" :"1f1aa135-fd74-42cc-b9a5-87f380c113a9"}, {"SnippetId" :"2f12f36b-fde1-48ab-ab97-0d3ca54021cb"}, {"SnippetId" :"e01c4aa8-1574-4de8-8d1f-856c822592af"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f9904d88-58cb-4f2e-a9fc-a2e2a73808ec"}, "snpName": "////Deserialize", "snpContent": "\n\nlet desArr f v = v |> ifUndef [||] |> Array.choose f\n\n[< Inline >]\nlet inline ifUndefT<'T> def v = if isUndefined v then def else sprintf \"{\\\"type\\\":%A}\" v?``type`` |> Json.Deserialize<'T>\n\nlet deserializeGuid f o = \n    if isUndefined o then\n        System.Guid(\"00000000-0000-0000-0000-000000000000\")\n    else\n        o?Item\n    |> f\n\nlet obj2Map o =\n    let dict = System.Collections.Generic.Dictionary<string, string>()\n    if isUndefined o then\n        dict\n    else\n        JS.GetFields o |> Array.map (fun (f, v) -> f, v :?> string ) |> Seq.iter dict.Add\n        dict\n\nlet deserializeDimension o =\n    printfn \"Dimension: %A\" o\n    try\n        if isUndefined o then None else\n        {\n           id            = o?id            |> deserializeGuid DimId\n           dimension     = o?dimension     |> ifUndef \"\"   \n           abbreviation  = o?abbreviation  |> ifUndef \"\"   \n           order         = o?order         |> ifUndef \"\"   \n           excludeCube   = o?excludeCube   |> ifUndef false\n           includeFreeze = o?includeFreeze |> ifUndef false    \n           dimType       = o?dimType       |> ifUndefT DtOther\n        } |> Some\n    with _ -> None\n\nlet deserializeFormula o = \n    try\n        if isUndefined o then None else\n        {\n           id         = o?id         |> deserializeGuid FormId\n           idCalc     = o?idCalc     |> deserializeGuid CalcId\n           formula    = o?formula    |> ifUndef \"\"\n           typeF      = o?typeF      |> ifUndef Base\n           order      = o?order      |> ifUndef \"\"\n           alsoActual = o?alsoActual |> ifUndef false\n        } |> Some\n    with _ -> None\n\nlet deserializeCalculation o = \n    try\n        if isUndefined o then None else\n        {\n           id        = o?id        |> deserializeGuid CalcId\n           name      = o?name      |> ifUndef \"\"\n           typeC     = o?typeC     |> ifUndef Input\n           order     = o?order     |> ifUndef \"\"\n           isText    = o?isText    |> ifUndef false\n           isBalance = o?isBalance |> ifUndef false\n           format    = o?format    |> ifUndef \"0,000\"\n        } |> Some\n    with _ -> None\n\nlet deserializeDestination o = \n    try\n        if isUndefined o then None else\n        {\n           idForm      = o?idForm       |> deserializeGuid FormId\n           idDim       = o?idDim        |> deserializeGuid DimId\n           destination = o?destination  |> ifUndef \"\"   \n        } |> Some\n    with _ -> None\n\nlet setModel models =\n    model.dimensions  .Set    ( models?dimensions   |> desArr deserializeDimension   )\n    model.calculations.Set    ( models?calculations |> desArr deserializeCalculation )\n    model.formulas    .Set    ( models?formulas     |> desArr deserializeFormula     )\n    model.destinations.Set    ( models?destinations |> desArr deserializeDestination )\n    model.calcDims    .Value <- models?calcDims     |> ifUndef Array.empty |> Array.map (fun (a,b) -> deserializeGuid CalcId a, deserializeGuid DimId b) |> Set\n    model.cubeDims    .Value <- models?cubeDims     |> ifUndef Array.empty |> Array.map (fun (a,b) -> deserializeGuid CubeId a, deserializeGuid DimId b) |> Set\n    model.globalDefs  .Value <- models?globalDefs   |> ifUndef \"\"\n    model.server      .Value <- models?server       |> ifUndef \"\"\n", "snpParentIdO": {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, "snpPredIds": [{"SnippetId" :"437b9bbe-6a66-4892-a0c5-1f82e49fc9ae"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ba90a7d3-7af6-4637-a92f-5d30657d63f2"}, "snpName": "Fable Code", "snpContent": "", "snpParentIdO": {"SnippetId" :"bf864f3c-1370-42f2-ac8a-565a604892e8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpName": "Layout", "snpContent": "module Layout =\n", "snpParentIdO": {"SnippetId" :"ba90a7d3-7af6-4637-a92f-5d30657d63f2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"67ac26db-54cb-46df-a1b8-c6e5856d4b1c"}, "snpName": "Eval", "snpContent": "#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\n[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\nlet evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n\n[< Emit \"eval($0) \" >]\nlet eval                         (code:string) : obj = 0 :> obj\n\nlet evalCode (nodeO: string option) code =\n    try \n        match nodeO with\n        | Some node -> evalInContext node code\n        | None      -> eval code\n        |> unbox<obj option> |> Option.iter (printfn \"%A\")\n    with e -> printfn \"Error: %s\" e.StackTrace\n\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f142ff32-fb36-408b-86b6-c0a09b020136"}, "snpName": "HtmlNode", "snpContent": "type HtmlNodeFable =\n    | HtmlElementF    of name: string * children: HtmlNodeFable seq\n    | HtmlAttributeF  of name: string * value:    string\n    | HtmlAttributeOF of name: string * value:    string option\n    | HtmlTextF       of string\n    | HtmlEmptyF\n    | HtmlGuiPart     of string\n    | HtmlGuiCall     of name: string * action: string * parms: string[]\n\nlet inline htmlElement    name ch = HtmlElementF   (name, ch )\nlet inline htmlAttribute  name v  = HtmlAttributeF (name, v  )\nlet inline htmlAttributeO name v  = HtmlAttributeOF(name, v  )\nlet inline HtmlText       txt     = HtmlTextF       txt\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\nlet inline onclick     v  = htmlAttribute  \"onclick\"     v\n\nlet inline css         v  = styleH [ HtmlText v ] \n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}, "snpName": "Layout ", "snpContent": "#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n#r \"..\\packages\\Fable.Import.Browser\\lib\\netstandard1.6\\Fable.Import.Browser.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x  -> x\n        | None    -> v\n    let defaultWith  f =\n        function\n        | Some x  -> x\n        | None    -> f()\n\ntype SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n\ntype GuiPart = \n   | GuiRoot       of string\n   | GuiNode       of HtmlNodeFable\n   | GuiAction \n   | GuiSplit      of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip   of top  : bool * string []\n   | GuiCall       of name: string * action: string * parms: obj[]\n\n\nlet actLoadFile       = \"actLoadFile\"\nlet actSaveFile       = \"actSaveFile\"\nlet actAddSnippet     = \"actAddSnippet\"\nlet actDeleteSnippet  = \"actDeleteSnippet\"\nlet actIndentSnippet  = \"actIndentSnippet\"\nlet actOutdentSnippet = \"actOutdentSnippet\"\nlet actGetFsCode      = \"actGetFsCode\"\nlet actEvalFsCode     = \"actEvalFsCode\"\nlet actEvalCode       = \"actEvalCode\"\nlet actRunFableFs     = \"actRunFableFs\"\nlet actRunFable       = \"actRunFable\"\nlet actRunWSNewTab    = \"actRunWSNewTab\"\nlet actRunWSHere      = \"actRunWSHere\"\nlet actRunWSIn        = \"actRunWSIn\"\nlet actParseCode      = \"actParseCode\"\nlet actCompileWS      = \"actCompileWS\"\nlet actFindDefinition = \"actFindDefinition\"\nlet titleX            = \"title\"            \nlet snippets          = \"snippets\"         \nlet code              = \"code\"           \nlet buttons           = \"buttons\"          \nlet menu              = \"menu\"             \nlet Output            = \"Output\"           \nlet Parser            = \"Parser\"           \nlet JavaScript        = \"JavaScript\"       \nlet FScode            = \"F# code\"          \nlet WSResult          = \"WS Result\"        \nlet Properties        = \"Properties\"  \n\nlet guiParts =\n    Map[\n       actLoadFile      , GuiAction \n       actSaveFile      , GuiAction \n       actAddSnippet    , GuiAction \n       actDeleteSnippet , GuiAction \n       actIndentSnippet , GuiAction \n       actOutdentSnippet, GuiAction \n       actGetFsCode     , GuiAction \n       actEvalCode      , GuiAction \n       actRunWSNewTab   , GuiAction \n       actRunWSHere     , GuiAction \n       actRunWSIn       , GuiAction \n       actParseCode     , GuiAction \n       actCompileWS     , GuiAction \n       actFindDefinition, GuiAction \n       titleX           , GuiNode <| HtmlText \"title\"       \n       snippets         , GuiNode <| HtmlText \"snippets\"    \n       code             , GuiNode <| HtmlText \"editor\"      \n       buttons          , GuiNode <| HtmlText \"buttons\"     \n       menu             , GuiNode <| HtmlText \"menu\"        \n       Output           , GuiNode <| HtmlText \"Output\"      \n       Parser           , GuiNode <| HtmlText \"Parser\"      \n       JavaScript       , GuiNode <| HtmlText \"JavaScript\"  \n       FScode           , GuiNode <| HtmlText \"F# code\"     \n       WSResult         , GuiNode <| HtmlText \"WS Result\"   \n       Properties       , GuiNode <| HtmlText \"Properties\"  \n    ]\n\nlet  gridNewBisect(first, secT, vertical, per, ch1, ch2, min, max) = \n    let spltH, spltV =\n        match secT with\n        | StVariable  -> \"\\n----------------------------------------\\n\", \"|\"\n        | StFixedPx\n        | StFixedPerc -> \"\\n\", \" \"\n    let splt = if vertical then spltV else spltH\n    sprintf \"%s%s%s\" ch1 splt ch2\n\nlet rec getNode name (parts: Map<string,GuiPart>) =\n    Map.tryFind name parts\n    |> Option.map(\n       function\n       | GuiRoot     root                                             -> \"\"\n       | GuiNode     node                                             -> \"some HtmlNode\"\n       | GuiAction                                                    -> sprintf \"Button: %s\" name\n       | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> gridNewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts, min, max)\n       | GuiTabStrip(top  , nodes                                   ) -> nodes |> Seq.map (fun node -> getNode node parts) |> String.concat \", \" |> sprintf \"TabStrip: %s\"\n       | GuiCall    (name, call, parms)                               -> sprintf \"Button: %s\" name\n    )\n    |> Option.defaultWith (fun () -> sprintf \"GuiPart %s not found\" name) \n    \nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string, GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        guiPart\n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , false, px, ch1, ch2, 5.0, 95.0)\nlet inline fixedVerSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , true , px, ch1, ch2, 5.0, 95.0)\nlet inline varHorSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable, false, pc, ch1, ch2, min,  max)\nlet inline varVerSplitter          pc ch1 ch2 min max = GuiSplit(true , StVariable, true , pc, ch1, ch2, min,  max)\n\nlet addLayoutJsonFable (v:string) = sprintf \"addLayoutJson('%s')\" (v.Replace(\"'\", \"''\")) |> evalCode None \nlet addLayout           s         = \n    let json = toJson s\n    printfn \"%s\"       json\n    addLayoutJsonFable json\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"67ac26db-54cb-46df-a1b8-c6e5856d4b1c"}, {"SnippetId" :"f142ff32-fb36-408b-86b6-c0a09b020136"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"46aa9bde-8f66-44c6-a403-781508aae4c8"}, "snpName": "One TabStrip", "snpContent": "[\n    \"messagesB\"    , GuiTabStrip(     true ,  [| Output    \n                                                 Parser    \n                                                 JavaScript\n                                                 FScode   \n                                                 WSResult\n                                              |])\n    \"buttons\"      , GuiNode (h1 [ HtmlGuiPart actRunWSHere ])\n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d1a99b64-a179-4ca4-aac0-354f5f824809"}, "snpName": "Run WebSharper Here", "snpContent": "[\n    \"code_props\"   , varVerSplitter         100.0 \"title_code\"    \"messagesR\"     25.0 100.0\n    \"main_messages\", varHorSplitter          65.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSHere ; HtmlGuiPart actSaveFile ; style \"text-align: center\" ])\n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7d5aded1-f858-444e-a5d4-0ee046381787"}, "snpName": "Split TabStrip", "snpContent": "[\n    \"messagesB1\"   , GuiTabStrip(     true ,  [| \"Output\"    \n                                                 \"JavaScript\"\n                                                 \"F# code\"    |])\n    \"messagesB2\"   , GuiTabStrip(     true ,  [| \"Parser\"    \n                                                 \"WS Result\"  |])\n    \"messagesB\"    , varVerSplitter          55.0 \"messagesB1\"    \"messagesB2\"     0.0 100.0             \n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f643d95a-d4cf-4375-acda-1713f207a8d5"}, "snpName": "WebSharper", "snpContent": "let divider = div [ style \" width:9px; height:auto; display:inline-block;\" ]\n\n[\n    \"main_messages\", varHorSplitter          18.0 \"messagesB\"     \"snippets_code\"  0.0  75.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSNewTab ; divider ; HtmlGuiPart actSaveFile ; style \"text-align: center\" ])\n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5a29dd45-dea6-42f4-af00-961257b64362"}, "snpName": "Tutorial", "snpContent": "[\n    \"code_props\"   , varVerSplitter         100.0 \"title_code\"    \"messagesR\"     25.0 100.0\n    \"main_messages\", varHorSplitter          65.0 \"snippets_code\" \"messagesB\"     35.0 100.0             \n    \"buttons\"      , GuiNode (div [ HtmlGuiPart actRunWSHere\n                                    style     \"text-align: center\" \n                                   // ``class`` \"btn-primary\"\n                                  ])\n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"124f7c78-5725-431e-acbb-d715ac398c4f"}, "snpName": "FSharpStation", "snpContent": "let divider = div [ style \" width:9px; height:auto; display:inline-block;\" ]\n\nlet buttonsH =\n    div [ \n          HtmlGuiPart actAddSnippet    \n          HtmlGuiPart actOutdentSnippet\n          HtmlGuiPart actIndentSnippet \n          span []       \n          HtmlGuiPart \"compileFSStation\"       \n          HtmlGuiPart \"NewTabFSStation\" \n\n          HtmlGuiPart actDeleteSnippet \n          HtmlGuiPart actFindDefinition\n          span []       \n          HtmlGuiPart actSaveFile      \n          HtmlGuiPart actGetFsCode     \n          HtmlGuiPart actParseCode     \n\n          style (\"\"\"\n              overflow: hidden;\n              display: grid;\n              grid-template-columns: repeat(6, 16.5%);\n              bxackground-color: #eee;\n              padding : 5px;\n              grid-gap: 5px;\n          \"\"\".Replace(\"\\n\", \" \"))\n        ]\n\n[\n    \"main_messages\"   , varHorSplitter          18.0 \"messagesB\"     \"snippets_code\"  0.0  75.0       \n    \"compileFSStation\", GuiCall (\"Compile & Run F# Station\", actEvalCode   , [| \"FSSGlobal/WebSharper Code/FSharpStation Code/compile & run FSharpStation\" |])\n    \"NewTabFSStation\" , GuiCall (\"F# Station in New Tab\"   , actRunWSNewTab, [| \"FSSGlobal/WebSharper Code/FSharpStation Code/Invoke FSharpStation\"        |])\n    buttons           , GuiNode buttonsH \n]             \n|> addLayout\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8015b71a-e594-44d4-b9e8-b73fe12e39f4"}, "snpName": "OpenGarage", "snpContent": "let localimage (file: string) = img [ file.Replace('\\\\', '/') |> sprintf \"file:///%s\" |> src ] // not allowed to load local image\n\nlet image      (file: string) = img [ src file ; onclick \"alert([event.offsetX, event.offsetY])\" ; Id \"PhoneScreen\" ; style \"width: 95%\"] \nlet [< Emit \"Date.now()\" >] now() = 1\n\n[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"Capture Screen\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Refresh\"         , actRunFableFs, [||] )\n                                    image (sprintf \"/screen.png?time=%d\" <| now())\n                                    div [\n                                        HtmlGuiCall(\"Camera\"          , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"MENU\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"HOME\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"BACK\"            , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"run OpenGarage3\" , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"CHECK\"           , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"version\"         , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"devices\"         , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"killServer\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"connectUSB\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"AbeFi.connect\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"OldHtc.connect\"  , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"activateWifi\"    , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"ls\"              , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"cat\"             , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"shell\"           , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"flash On\"        , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"flash Off\"       , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"checkScreenOn\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"enableWifi\"      , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"supplicantWifi\"  , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"unlock\"          , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"activateWifi\"    , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"reboot\"          , actEvalFsCode, [||] )\n                                        \n                                        HtmlGuiCall(\"Screen lock\"     , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"Screen unlock\"   , actEvalFsCode, [||] )\n                                        HtmlGuiCall(\"Screen off\"      , actEvalFsCode, [||] )\n                                        \n                                    ]\n                                    css \" button.btn { margin: 2px; font-size: smaller; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n \n //Fable.Import.Browser.document.getElementById(\"PhoneScreen\").getAttribute(\"src\")\n ", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"0ed9daa7-abef-4d65-af8d-f3ed6f9aa692"}, "snpName": "Ping computers", "snpContent": "[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"ALL\"           , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"localhost\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"NeoRouter\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router1\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router2\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OOMA\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"EXSi\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Modem\"         , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"ABEHOME\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRaspi\"      , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OldHTC\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeWCam\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"FILESERVER1\"   , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRainMachine\", actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Abajo\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Arriba\" , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Google DNS\"    , actEvalFsCode, [||] )\n                                    css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"016f7d49-ce7d-45e9-9f8b-57aed43dbba5"}, "snpName": "", "snpContent": "[\n        \"extrabuttons\"      , div [ style \"text-align: center ; overflow: auto ; \" \n                                    HtmlGuiCall(\"ls -la\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"activateDoor\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"NeoRouter\"     , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router1\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Router2\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OOMA\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"EXSi\"          , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Modem\"         , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"ABEHOME\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRaspi\"      , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"OldHTC\"        , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeWCam\"       , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"FILESERVER1\"   , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"AbeRainMachine\", actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Abajo\"  , actEvalFsCode, [||] )\n                                    HtmlGuiCall(\"Thermo-Arriba\" , actEvalFsCode, [||] )\n                                    css \" button.btn { margin: 2px; font-size: small; } \" \n                                  ] |> GuiNode \n        \"main_extra\"        , varVerSplitter          85.0 \"main_messages\" \"extrabuttons\"   50.0  100.0\n        \"main\"              , fixedHorSplitter true   50.0 \"menu\"          \"main_extra\"\n] |> addLayout\n\n", "snpParentIdO": {"SnippetId" :"f936b296-080b-45ce-a242-f6eea88ec459"}, "snpPredIds": [{"SnippetId" :"3078283c-3b72-4e35-b833-c4d801c30eb9"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpName": "Snippets", "snpContent": "module Snippets =\n", "snpParentIdO": {"SnippetId" :"ba90a7d3-7af6-4637-a92f-5d30657d63f2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c5973f54-8747-439f-8101-0dd00a216aff"}, "snpName": "Fable calling WebSharper", "snpContent": "//[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1)\" >]\n//let evalInContext (tnode:string) (code:string) = ()\n\n#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nmodule testFable =\n\n    open Fable.Core\n\n//    [< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\n    [< Emit \"eval($1) \" >]\n    let evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n    \n    let evalCode code =\n        try \n            evalInContext \"TestNode\" code |> printfn \"%A\"\n        with e -> printfn \"Error: %s\" e.StackTrace\n        \n    evalCode \"FSSGlobal.FSharpStation.FableModule\"    \nlet IF(c,a,b) = 1\nlet LEFT(a,b) = 2\nlet B2 = 1\nlet B3 = 1\nlet x     =\n  IF(LEFT(B2,2)<>LEFT(B3,2),2,IF(LEFT(B2,3)<>LEFT(B3,3),3,IF(LEFT(B2,4)<>LEFT(B3,4),4,IF(LEFT(B2,5)<>LEFT(B3,5),5,IF(LEFT(B2,6)<>LEFT(B3,6),6,IF(LEFT(B2,7)<>LEFT(B3,7),7,IF(LEFT(B2,8)<>LEFT(B3,8),8,99)))))))\n    ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"61378232-d27c-4c83-8214-d030f0573421"}, "snpName": "Layout test", "snpContent": "#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x  -> x\n        | None    -> v\n    let defaultWith  f =\n        function\n        | Some x  -> x\n        | None    -> f()\n\ntype SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n\ntype GuiPart = \n   | GuiNode     of string\n   | GuiAction \n   | GuiSplit    of first: bool * secT: SectionType * vertical: bool * per:float * string * string * min: float * max: float\n   | GuiTabStrip of top  : bool * string []\n\nlet guiParts =\n    Map [\n       \"actLoadFile      \", GuiAction \n       \"actSaveFile      \", GuiAction \n       \"actAddSnippet    \", GuiAction \n       \"actDeleteSnippet \", GuiAction \n       \"actIndentSnippet \", GuiAction \n       \"actOutdentSnippet\", GuiAction \n       \"actGetFsCode     \", GuiAction \n       \"actEvalCode      \", GuiAction \n       \"actRunWSNewTab   \", GuiAction \n       \"actRunWSHere     \", GuiAction \n       \"actRunWSIn       \", GuiAction \n       \"actParseCode     \", GuiAction \n       \"actCompileWS     \", GuiAction \n       \"actFindDefinition\", GuiAction \n       \"title\"            , GuiNode \"title\"       \n       \"snippets\"         , GuiNode \"snippets\"    \n       \"editor\"           , GuiNode \"editor\"      \n       \"buttons\"          , GuiNode \"buttons\"     \n       \"menu\"             , GuiNode \"menu\"        \n       \"Output\"           , GuiNode \"Output\"      \n       \"Parser\"           , GuiNode \"Parser\"      \n       \"JavaScript\"       , GuiNode \"JavaScript\"  \n       \"F# code\"          , GuiNode \"F# code\"     \n       \"WS Result\"        , GuiNode \"WS Result\"   \n       \"Properties\"       , GuiNode \"Properties\"  \n    ]\n\nlet  gridNewBisect(first, secT, vertical, per, ch1, ch2, min, max) = \n    let spltH, spltV =\n        match secT with\n        | StVariable  -> \"\\n----------------------------------------\\n\", \"|\"\n        | StFixedPx\n        | StFixedPerc -> \"\\n\", \" \"\n    let splt = if vertical then spltV else spltH\n    sprintf \"%s%s%s\" ch1 splt ch2\n\nlet rec getNode name (parts: Map<string,GuiPart>) =\n    Map.tryFind name parts\n    |> Option.map(\n       function\n       | GuiNode     node                                             -> node\n       | GuiAction                                                    -> sprintf \"Button: %s\" name\n       | GuiSplit   (first, secT , vertical, per, ch1, ch2, min, max) -> gridNewBisect(first, secT, vertical, per, getNode ch1 parts, getNode ch2 parts, min, max)\n       | GuiTabStrip(top  , nodes                                   ) -> nodes |> Seq.map (fun node -> getNode node parts) |> String.concat \", \" |> sprintf \"TabStrip: %s\"\n    )\n    |> Option.defaultWith (fun () -> sprintf \"GuiPart %s not found\" name) \n    \nlet rec processLayoutSteps (steps: (string * GuiPart) seq) (parts: Map<string, GuiPart>) =\n    steps\n    |> Seq.tryHead\n    |> Option.map (fun (name, guiPart) ->\n        guiPart\n        |> Map.add name <| parts\n        |> processLayoutSteps (steps |> Seq.skip 1)\n       )\n    |> Option.defaultValue parts\n    \nlet finishLayout parts steps  =\n    let name = steps |> Seq.last |> fst\n    processLayoutSteps steps parts\n    |> getNode name\n\nlet inline fixedHorSplitter  first px ch1 ch2         = GuiSplit(first, StFixedPx , false, px, ch1, ch2, 5.0, 95.0)\nlet inline varSplitter         ver pc ch1 ch2 min max = GuiSplit(true , StVariable, ver  , pc, ch1, ch2, min,  max)\n\nlet steps = \n    [\n        \"messagesR\"    , GuiTabStrip(     true ,  [| \"Properties\" |])\n        \"messagesB\"    , GuiTabStrip(     true ,  [| \"Output\"    \n                                                     \"Parser\"    \n                                                     \"JavaScript\"\n                                                     \"F# code\"   \n                                                     \"WS Result\"  |])\n        \"title_code\"   , fixedHorSplitter true  34.0 \"title\"         \"code\"\n        \"code_props\"   , varSplitter      true  85.0 \"title_code\"    \"messagesR\"     25.0 100.0\n        \"code_buttons\" , fixedHorSplitter false 80.0 \"code_props\"    \"buttons\"\n        \"snippets_code\", varSplitter      true  15.0 \"snippets\"      \"code_buttons\"   5.0  95.0\n        \"main_messages\", varSplitter      false 16.0 \"messagesB\"     \"snippets_code\"  5.0 80.0             \n        \"main_window\"  , fixedHorSplitter true  50.0 \"menu\"          \"main_messages\"\n    ]             \n\nlet layoutSteps = steps\n\nlet finalLayout = (finishLayout guiParts) layoutSteps \n\nprintfn \"%s\" finalLayout\n\nprintfn \"%s\" <| toJson steps\n\n//[< Emit \"document.getElementById($0).shadowRoot.firstElementChild.firstElementChild.firstElementChild.contentWindow.eval($1) \" >]\n[< Emit \"eval($1) \" >]\nlet evalInContext (tnode:string) (code:string) : obj = 0 :> obj\n    \nlet evalCode code =\n    try \n        evalInContext \"TestNode\" code |> printfn \"%A\"\n    with e -> printfn \"Error: %s\" e.StackTrace\n\n\nlet setLayoutJsonFable (v:string) = sprintf \"setLayoutJson('%s')\" (v.Replace(\"'\", \"''\")) |> evalCode |> printfn \"::%A\"\nlet setLayout           s          = toJson s |> setLayoutJsonFable\n//setLayout steps\n\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2c9efa31-479c-4c06-b74b-16102accf58b"}, "snpName": "parenthesis", "snpContent": "let times2 v = v * 2 \n\nprintfn   \"this is a test %A %d\"   (times2)(3) \nprintfn   \"this is a test %A %d\"    times2 (3) \nprintfn   \"this is a test %A %d\"    times2  3\n\nprintfn   \"this is a test %A   \"   (times2  3) \nprintfn   \"this is a test %A   \" <| times2  3 \n//printfn \"this is a test %A   \"    times2( 3) \n\n4   + times2(5) - 33 |> printfn \"%A\"\n4   + times2 5  - 33 |> printfn \"%A\"\n4   + times2 5-33    |> printfn \"%A\"\n4   + times2(5)-33   |> printfn \"%A\"\n//4 + times2 5  -33  |> printfn \"%A\"\n//4 + times2 5  +33  |> printfn \"%A\"\n\n    ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ac152670-fb8a-4549-9659-1b6ee81d64ef"}, "snpName": "WebSharper Interop JS, Dom", "snpContent": "#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Dom =\n\n    type DomRect = {\n        top    : float\n        left   : float\n        width  : float\n        height : float\n    }\n      with\n        static member New(r) ={\n            top    = r.top   \n            left   = r.left  \n            width  = r.width \n            height = r.height\n        }\n        member inline this.Top                                                                           = this.top   \n        member inline this.Left                                                                          = this.left  \n        member inline this.Width                                                                         = this.width \n        member inline this.Height                                                                        = this.height\n\n    type Event() =\n        let a = 1\n      with\n        [< Emit \"$0.preventDefault()\"            >] member this.PreventDefault()                  = ()\n    \n    type MouseEvent() =    \n        inherit Event()    \n      with    \n        [< Emit \"$0.clientX\"                     >] member this.ClientX                           = 0.\n        [< Emit \"$0.clientY\"                     >] member this.ClientY                           = 0.\n    \n    [< AllowNullLiteral >]\n    type Node() =     \n        let a = 1    \n      with    \n        [< Emit \"$0.appendChild($1)\"             >] member this.AppendChild(ch:Node)                           = Node()\n        [< Emit \"$0.firstChild\"                  >] member this.FirstChild                                     = Node()\n        [< Emit \"$0.parentElement\"               >] member this.ParentElement                                  = Element()\n        [< Emit \"$0.parentNode\"                  >] member this.ParentNode                                     = Node()\n                        \n    and [< AllowNullLiteral >] Element() =     \n        inherit Node()\n        let a = 1    \n      with    \n        [< Emit \"$0.getBoundingClientRect()\"     >] member this.GetBoundingClientRect() : DomRect              = jsNative\n        [< Emit \"$0.setAttribute($1, $2)\"        >] member this.SetAttribute(name, value)                      = ()\n        [< Emit \"$0.shadowRoot\"                  >] member this.ShadowRoot                                     = Element()\n        [< Emit \"$0.attachShadow($1)\"            >] member this.AttachShadow(sh)                               = Element()\n        [< Emit \"$0.innerHTML\"                   >] member this.InnerHTML  with get ()                         = \"\"\n        [< Emit \"$0.innerHTML = $1\"              >] member this.InnerHTML  with set (v:string)                 = ()\n\n    type Document() =\n        let a = 1\n      with\n        [< Emit \"$0.createElement(      $1)\"     >] member this.CreateElement(   ev: string)                   = Element()\n        [< Emit \"$0.getElementById(     $1)\"     >] member this.GetElementById(id:string)                      = Element()\n        [< Emit \"$0.body\"                        >] member this.Body                                           = Element()\n\ntype Window() =\n    let a = 1\n  with\n    [< Emit \"$0.addEventListener(   $1, $2, $3)\" >] member this.AddEventListener(   ev: string, f, flag: bool) = ()\n    [< Emit \"$0.removeEventListener($1, $2, $3)\" >] member this.RemoveEventListener(ev: string, f, flag: bool) = ()\n\ntype JS() =\n    let a = 1\n  with\n    [< Emit \"window\"                             >] static member Window                                       = Window()\n    [< Emit \"document\"                           >] static member Document                                     = Dom.Document()\n    [< Emit \"setInterval($0, $1)\"                >] static member SetInterval f (t:int)                        = Dom.Document()\n    [< Emit \"alert($0)\"                          >] static member Alert v                                      = ()\n    [< Emit \"console.log($0)\"                    >] static member ConsoleLog v                                 = ()\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"13151ce6-c10f-4773-b6fc-ef448af463e4"}, "snpName": "WebSharper Interop Doc, Attr, Var, View, Val", "snpContent": "#r \"..\\packages\\Fable.Core\\lib\\netstandard1.6\\Fable.Core.dll\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nmodule Option =\n    let defaultValue v =\n        function\n        | Some x -> x\n        | None   -> v\n\ntype Attr() =\n    let a = 1\n\ntype Doc() = \n    let a = 1\n\ntype Elt() = \n    inherit Doc()\n    let a = 1\n\ntype IRef<'V> = {\n    initial : 'V\n} \n\ntype View<'V> =\n    | FromConst of      'V\n    | FromVar   of IRef<'V>\n    | FromView  of prior: View<obj> * vFunction : (obj -> View<'V>)\n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule View =    \n    let [< Emit \"WebSharper.UI.Next.View.Const(    $0)\"     >] Const    (v : 'a            )                 = FromConst v\n    let [< Emit \"WebSharper.UI.Next.View.FromVar(  $0)\"     >] FromVar  (v : IRef<'a>      )                 = FromVar   v\n    let [< Emit \"WebSharper.UI.Next.View.Get(      $0, $1)\" >] Get      (f: 'a ->  unit    ) (vw : View<'a>) = ()\n    let [< Emit \"WebSharper.UI.Next.View.Bind(     $0, $1)\" >] Bind     (f: 'a ->  View<'b>) (vw : View<'a>) = FromView(FromConst (vw :> obj), fun o -> f (o :?> 'a))\n    let [< Emit \"WebSharper.UI.Next.View.Map(      $0, $1)\" >] Map      (f: 'a ->       'b ) (vw : View<'a>) = Bind (f >> Const) vw\n    let [< Emit \"WebSharper.UI.Next.View.MapCached($0, $1)\" >] MapCached(f: 'a ->       'b ) (vw : View<'a>) = Bind (f >> Const) vw\n//    let [< Emit \"WebSharper.UI.Next.View.MapAsync( $0, $1)\" >] MapAsync (f: 'a -> Async<'b>) (vw : View<'a>) = (fun v -> async { return! f v } |> Async.RunSynchronously) |> Map <| vw\n    let [< Emit \"WebSharper.UI.Next.View.Sink(     $0, $1)\" >] Sink     (f: 'a ->  unit    ) (vw : View<'a>) = Get f vw\n    \n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Doc =\n    let [< Emit \"WebSharper.UI.Next.Doc.TextNode($0)\"        >] TextNode txt                     = Doc()\n    let [< Emit \"WebSharper.UI.Next.Doc.Run($0, $1)\"         >] Run     (el: Dom.Element) (node:Doc)  = ()\n    let [< Emit \"WebSharper.UI.Next.Doc.RunById($0, $1)\"     >] RunById (id: string) (node:Doc)  = ()\n    let [< Emit \"WebSharper.UI.Next.Doc.Empty()\"             >] Empty                            = Doc()\n    let [< Emit \"WebSharper.UI.Next.Doc.Element($0, $1, $2)\" >] Element0 a (b: Attr[]) (c:Doc[]) = Elt()\n    let [< Emit \"WebSharper.UI.Next.Doc.InputArea($0, $1)\"   >] InputArea0 (b: Attr[])  c        = Elt()\n    let [< Emit \"WebSharper.UI.Next.Doc.BindView($0, $1)\"    >] BindView f vw                    = Doc()\n    let Element a b c = Element0   a (b |> Seq.toArray) (c |> Seq.toArray)\n    let InputArea b c = InputArea0   (b |> Seq.toArray)  c\n    \n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Var =\n    let [< Emit \"WebSharper.UI.Next.Var.Create$1($0)\" >] Create v = { initial = v }\n\ntype Doc with\n    [< Emit \"WebSharper.UI.Next.Doc.EmbedView($0)\"   >]\n    static member EmbedView (d:View<#Doc>)        = Doc()\n//    [< Emit \"WebSharper.UI.Next.Doc.EmbedView($0)\"   >]\n//    static member EmbedView (d:View<Elt>)         = Doc()\n\n\n[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n  with member this.FooBar = 0\n  \ntype IRef<'V> with\n    [< Emit \"$0.RView()\"       >]\n    member this.View  = View.FromVar this\n    [< Emit \"$0.RVal()\"       >]\n    member this.Value with get ()      = this.initial\n    [< Emit \"$0.set_RVal($1)\" >]\n    member this.Value with set (v:'V)  = ()\n\nmodule Attr =\n    let [< Emit \"WebSharper.UI.Next.AttrProxy.Create(      $0, $1)\"     >] Create      (att:string)  v                          = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrModule.Dynamic(    $0, $1)\"     >] Dynamic     (att:string) (vw :View<_>)               = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrModule.DynamicPred($0, $1, $1)\" >] DynamicPred (att:string) (vw1:View<_>) (vw2:View<_>) = Attr()\n    let [< Emit \"WebSharper.UI.Next.AttrProxy.Handler($0,$1)\"           >] HandlerLinq a f                                      = Attr()\n    \nmodule on =\n    let click       f = Attr.HandlerLinq \"click\"       f\n    let mouseMove   f = Attr.HandlerLinq \"mousemove\"   f\n    let mouseDown   f = Attr.HandlerLinq \"mousedown\"   f\n    let mouseUp     f = Attr.HandlerLinq \"mouseup\"     f\n    let [< Emit \"WebSharper.UI.Next.AttrModule.OnAfterRender($0)\" >] afterRender f = Attr.HandlerLinq \"afterrender\" f\n    \nmodule attr =\n    let disabledDynPred pred view = Attr.DynamicPred \"disabled\" pred view\n\nmodule Input =\n    module Mouse =\n        [< Emit \"WebSharper.UI.Next.Input.Mouse.get_MousePressed()\" >]\n        let MousePressed = true \n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrVO att       vao     =\n            match vao with\n            | Constant (Some a)-> Attr.Create      att   a\n            | Constant  None   -> Attr.DynamicPred att  (View.Const false              ) (View.Const                      \"\"         )\n            | Dynamic       wa -> Attr.DynamicPred att  (View.Map Option.isSome wa     ) (View.Map   (Option.defaultValue \"\") wa     )\n            | DynamicV      va -> Attr.DynamicPred att  (View.Map Option.isSome va.View) (View.Map   (Option.defaultValue \"\") va.View)\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View    \n\n    type HelperType = HelperType with\n        static member (&>) (HelperType, a :     string option   ) = Constant  a\n        static member (&>) (HelperType, a :     string          ) = Constant  a\n        static member (&>) (HelperType, a :     bool            ) = Constant  a\n        static member (&>) (HelperType, a :     int             ) = Constant  a\n        static member (&>) (HelperType, a :     float           ) = Constant  a\n        static member (&>) (HelperType, a :     Doc             ) = Constant  a\n        static member (&>) (HelperType, va: Val<string option>  ) =          va\n        static member (&>) (HelperType, va: Val<string       >  ) =          va\n        static member (&>) (HelperType, va: Val<bool         >  ) =          va\n        static member (&>) (HelperType, va: Val<int          >  ) =          va\n        static member (&>) (HelperType, va: Val<float        >  ) =          va\n        static member (&>) (HelperType, va: Val<Doc          >  ) =          va\n        static member (&>) (HelperType, va: Val<_            >  ) =          va\n        static member (&>) (HelperType, vr: IRef<_           >  ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_           >  ) = Dynamic  vw\n\n    [< Emit \"($0 in $1)\" >]\n    let In (a:string) b = true\n    \n    [< Emit \"($0 instanceof WebSharper.UI.Next.Doc)\" >]\n    let isDoc d = false\n\n    [< Emit \"(typeof $0 == 'function')\" >]\n    let isView d = false\n\n    [< Emit \"($0 instanceof WebSharper.UI.Next.Var)\" >]\n    let isVar  d = false\n\n    let toVal (o: obj) =\n        match o with\n        | :?      string   as t   -> Val.Constant t \n        | :?      int      as t   -> Val.Constant t |> unbox<Val<string>> \n        | :?      bool     as t   -> Val.Constant t |> unbox<Val<string>>  \n        | d    when isDoc     d   -> Val.Constant o |> unbox<Val<string>>  \n        | :? Val< string>  as v   ->              v        \n        | v    when isVar     v   -> Val.DynamicV (unbox<IRef<string>> v)\n        | v    when In \"RSet\" v   -> Val.DynamicV (unbox<IRef<string>> v)\n        | vw   when isView    vw  -> Val.Dynamic  (unbox<View<string>> vw)        \n        | _                       -> failwith <| sprintf \"Could not convert %A\" o\n      \n    [< Emit \"$0($1)\" >]\n    let inline fixitF f v = HelperType &> v\n    let inline fixit    v = fixitF toVal v\n    \n    let inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n        let contentVarChanged = ref 0L\n        let refVarChanged     = ref 0L\n    \n        contentVar.View \n        |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !contentVarChanged  > !refVarChanged   then refVarChanged := !contentVarChanged\n                elif r.Value           <> contentVar.Value then refVarChanged := !refVarChanged       + 1L ; r.Value         <-  contentVar.Value\n               )\n           )\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            refVarChanged    := !contentVarChanged + 100L\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun _ -> \n            !changingIRefO \n            |> Option.iter (fun r -> \n                if  !refVarChanged  > !contentVarChanged then contentVarChanged := !refVarChanged\n                elif r.Value       <> contentVar.Value   then contentVarChanged := !contentVarChanged + 10L; contentVar.Value  <-  r.Value\n               )\n            )\n        contentVar\n        \n    let inline toDoc         v           = toView            (fixit v ) |> Doc.EmbedView\n    let inline bindIRef   f  v           = bindIRef0       f (fixit v   |> toView)\n    let inline iter       f  v           = iterV           f (fixit v )\n    let inline bind       f  v           = bindV           f (fixit v )\n    let inline map        f  v           = mapV            f (fixit v )\n    let inline map2       f  v1 v2       = map2V           f (fixit v1) (fixit v2)\n    let inline map3       f  v1 v2 v3    = map3V           f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4       f  v1 v2 v3 v4 = map4V           f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n  \n    let inline iter2      f  v1 v2       = map2            f v1 v2       |> iterV id\n    let inline iter3      f  v1 v2 v3    = map3            f v1 v2 v3    |> iterV id\n    let inline iter4      f  v1 v2 v3 v4 = map4            f v1 v2 v3 v4 |> iterV id\n  \n    //let inline mapAsync   f  v           = View.MapAsync   f (fixit v |> toView) |> Dynamic\n    let inline sink       f  v           = View.Sink       f (fixit v |> toView) \n    let inline mapCached  f  v           = View.MapCached  f (      v |> toView) |> Dynamic\n\n    let inline consistent   (vl:Val<_>)  = \n        let prior      = ref <| Var.Create Unchecked.defaultof<_>\n        let setPrior v = if (!prior).Value <> v then (!prior).Value <- v \n        let vw         = toView vl\n        View.Sink setPrior vw\n        !prior |> DynamicV\n    \n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"ac152670-fb8a-4549-9659-1b6ee81d64ef"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b19dacf2-ac2a-4f05-9e43-a62bfc3c4bed"}, "snpName": "Fable UI.Next 2", "snpContent": "[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement    of name: string * children: HtmlNode seq\n    | HtmlAttribute  of name: string * value:    Val<string>\n    | HtmlAttributeO of name: string * value:    Val<string option>\n    | HtmlText       of Val<string>\n    | HtmlEmpty\n    | HtmlElementV   of Val<HtmlNode>\n    | SomeDoc        of Doc\n    | SomeAttr       of Attr\n    \nlet addClassX    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\n//let removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\n//let callAddClassX = addClassX \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV    name value\n    | HtmlAttributeO(name, valueO  ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrVO   name valueO\n    | SomeAttr             attr      -> Some <| attr\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\n\nlet concat s a b = a + s + b\n\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement (name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText     vtext           -> Some <| Val.tagDoc Doc.TextNode vtext\n    | SomeDoc      doc             -> Some <| doc\n    | HtmlElementV vnode           -> Some <| (vnode |> Val.toView |> Doc.BindView (chooseNode >> Option.defaultValue Doc.Empty))\n    | _                            -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet rec mapHtmlElement (f:string -> seq<HtmlNode> -> string * HtmlNode seq) (element:HtmlNode) :HtmlNode =\n    match element with\n    | HtmlElement (name, children) -> f name  children                    |> HtmlElement\n    | HtmlElementV vnode           -> vnode |> Val.map (mapHtmlElement f) |> HtmlElementV\n    | _                            -> element\n\n//let getAttr attr element =\n//    match element with\n//    | HtmlElement(_, children) -> children\n//    | _                        -> seq []\n//    |> getAttrChildren attr\n//\n//let getClass = getAttr \"class\"\n//let getStyle = getAttr \"style\"\n\n//let replaceAttribute att (children: HtmlNode seq) newVal =\n//    HtmlAttribute(att, newVal)\n//    :: (children\n//        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n//        |> Seq.toList\n//       )\n//\n//let replaceAtt att node newVal = mapHtmlElement (fun n ch -> n, replaceAttribute att ch newVal |> Seq.ofList) node\n\nlet inline htmlElement    name ch = HtmlElement   (name, ch           )\nlet inline htmlAttribute  name v  = HtmlAttribute (name, Val.fixit v  )\nlet inline htmlAttributeO name v  = HtmlAttributeO(name, Val.fixit v  )\nlet inline htmlText       txt     = HtmlText      (      Val.fixit txt)\nlet inline someElt        elt     = SomeDoc       (elt :> Doc         )    \n  \nlet inline addChildren    add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append ch   add)\nlet inline insertChildren add (h:HtmlNode) = h |> mapHtmlElement (fun n ch -> n, Seq.append add  ch )\nlet inline addClass       c    h           = h |> addChildren [ htmlAttribute  \"class\" c ] \nlet inline addClassIf     c v              = addClass <| Val.map (fun b -> if b then c else \"\") (Val.fixit v)\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    // member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = this |> addChildren    add\n    member          this.InsertChildren add  = this |> insertChildren add\n    member inline   this.AddClass       c    = this |> addClass       c\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"13151ce6-c10f-4773-b6fc-ef448af463e4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}, "snpName": "Fable UI.Next 3", "snpContent": "let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Doc.TextNode v\n\nlet inline a           ch = htmlElement   \"a\"           ch\nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline target      v  = htmlAttribute  \"target\"      v\nlet inline href        v  = htmlAttribute  \"href\"        v\nlet inline hrefO       vO = htmlAttributeO \"href\"        vO\nlet inline rel         v  = htmlAttribute  \"rel\"         v\nlet inline charset     v  = htmlAttribute  \"charset\"     v\nlet inline src         v  = htmlAttribute  \"src\"         v\nlet inline ``class``   v  = htmlAttribute  \"class\"       v\nlet inline ``type``    v  = htmlAttribute  \"type\"        v\nlet inline width       v  = htmlAttribute  \"width\"       v\nlet inline title       v  = htmlAttribute  \"title\"       v\nlet inline Id          v  = htmlAttribute  \"id\"          v\nlet inline frameborder v  = htmlAttribute  \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute  \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute  \"draggable\"   v\nlet inline style       v  = htmlAttribute  \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\ntype HtmlNode with\n    member inline   this.Style          sty  = this.AddChildren([ style sty ])\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\n//let string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\n//let composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElemF v  = Val.map hElemF  (Val.fixit v) |> HtmlElementV\n(*\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n*)\n//[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true\n(*\nlet  findRootElement (e:Dom.Element) =\n    if isUndefined e.GetRootNode then JS.Document.Body\n    else\n        let root = e.GetRootNode()\n        if isUndefined root?body \n        then root.FirstChild :?> Dom.Element\n        else root?body  |> unbox<Dom.Element>\n*)\n\n[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ //SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"b19dacf2-ac2a-4f05-9e43-a62bfc3c4bed"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"da5508bb-2f38-4096-bd2b-1015d26e131b"}, "snpName": "Template", "snpContent": "module Template =\n    let log f v = JS.ConsoleLog( sprintf f v); v \n\n    [<NoComparison ; NoEquality>]\n    type Panel = {\n        _class   : Val<string>\n        _style   : Val<string>\n        title    : Val<string>\n        header   : HtmlNode seq\n        content  : HtmlNode seq\n        disabled : Val<bool>\n    } with\n      static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                               _style   = Val.fixit <| \"text-align:center\" \n                               title    = Val.fixit <| \"Panel\"        \n                               header   =          [ htmlText \"Some text\"    ] \n                               content  =          [ htmlText \"Some Content\" ] \n                               disabled = Val.fixit <| Var.Create false\n                             }\n      member        this.Render          =  \n        fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n                   div [ ``class`` this._class\n                         div (Seq.append\n                                  [ ``class`` \"panel-heading\"\n                                    label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                                  ]\n                                  this.header)\n    \n                         div (Seq.append\n                                  [ ``class`` \"panel-body\"\n                                    style     this._style \n                                  ]\n                                  this.content)\n                       ] \n                 ]\n      member inline this.Class       clas = { this with _class   = Val.fixit clas }\n      member inline this.Style       sty  = { this with _style   = Val.fixit sty  }\n      member inline this.Title       txt  = { this with title    = Val.fixit txt  }\n      member inline this.Header      h    = { this with header   =       h        }\n      member inline this.Content     c    = { this with content  =       c        }\n      member inline this.Disabled    dis  = { this with disabled =       dis      }\n\n\n    [<NoComparison ; NoEquality>]\n    type HtmlMeasure =\n    | Percentage of Val<float>\n    | Pixel      of Val<float>\n    \n    [<NoComparison ; NoEquality>]\n    type SplitterBar = {\n        value            : IRef<float>\n        min              : Val<float>\n        max              : Val<float>\n        vertical         : Val<bool>\n        node             : HtmlNode\n        children         : HtmlNode seq\n        after            : bool\n        mutable dragging : bool\n        mutable startVer : bool \n        mutable startP   : float \n        mutable start    : float \n        mutable size     : float \n        mutable domElem  : Dom.Element option\n    }\n    with\n        static member New(var) = \n            {\n                value    = var\n                min      = Val.fixit   5.0\n                max      = Val.fixit  95.0\n                vertical = Val.fixit  true  \n                node     = div [ ``class`` \"Splitter\" ]\n                children = []\n                after    = true\n                dragging = false\n                startVer = true\n                startP   = 0.0\n                start    = 0.0\n                size     = 0.0\n                domElem  = None\n            }\n        static member New(value)    = SplitterBar.New(Var.Create value)\n        member        this.Var      = this.value\n        member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n        member        this.Render   =\n            let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n            let size () : float =\n                match this.domElem with\n                | None    -> 100.0\n                | Some el -> \n                 el.ParentElement.GetBoundingClientRect() \n                 |> fun r -> \n                     match this.startVer, this.after with\n                     | true , true  ->  r.Width  \n                     | true , false -> -r.Width \n                     | false, true  ->  r.Height\n                     | false, false -> -r.Height\n                 |> log \"size %A\"\n            let drag (ev: Dom.Event) =\n                ev :?> Dom.MouseEvent\n                |> mouseCoord                                                                //|> log \"mouseCoord: %A\"\n                |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP             //|> log \"Value: %A\"\n                |> fun v   -> this.value.Value <- v \n               \n            let rec finishDragging (_: Dom.Event) =\n                if this.dragging then\n                    this.dragging <- false\n                    JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                    JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                    //printfn \"mouseup\"\n            let startDragging _ (ev: Dom.MouseEvent) =\n                if not this.dragging then\n                    Val.map2 (fun startP dirV ->\n                        this.dragging <- true\n                        this.startVer <- dirV\n                        this.startP   <- startP\n                        this.start    <- mouseCoord ev\n                        this.size     <- size()\n                        JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                        JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                        ev.PreventDefault()\n                    ) this.GetValue this.vertical\n                    |> Val.iter id\n            this.node\n              .AddChildren(\n              [\n                ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n                SomeAttr  <| on.mouseDown startDragging\n                SomeAttr  <| on.afterRender (fun el -> log \"afterRender %A\" (); this.domElem <- Some el)\n                css \"\n                    .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                    .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n                \"\n              ])\n              .AddChildren this.children\n        member inline this.Value       v =   this.value.Value <- v  ; this\n        member inline this.Node     node = { this with node         = node                        }\n        member inline this.Min         v = { this with min          = Val.fixit v                 }\n        member inline this.Max         v = { this with max          = Val.fixit v                 }\n        member inline this.VerticalV   v = { this with vertical     = Val.fixit v                 }\n        member inline this.HorizontalV v = { this with vertical     = Val.fixit v |> Val.map not  }\n        member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n        member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n        member inline this.Before        = { this with after        =           false             }\n        member inline this.After         = { this with after        =           true              }\n        member inline this.Children   ch = { this with children     = ch                          }\n        \n    \n    let [< Emit \"try { return !!(ResizeObserver) } catch(e) { return false }\" >] implementedResizeObserver() = false\n    let [< Emit \"new ResizeObserver($0)\" >] newResizeObserver (f: unit->unit) = jsNative    \n    let [< Emit \"$0.observe($1)\"         >] RObserve ro (el:Dom.Element)      = jsNative\n    \n    let mutable observers : obj list = []\n\n    let rec isValidElement (el:Dom.Element) = \n        let r = el.GetBoundingClientRect()\n        (r.Top, r.Left, r.Width, r.Height) <> (0., 0., 0., 0.)\n\n    let addResizeObserver f el =\n        if implementedResizeObserver() then\n            let ro =  newResizeObserver f\n            observers <- ro::observers\n            RObserve ro el\n        else \n            JS.SetInterval f 110 |> ignore\n//            async {\n//                while isValidElement el do\n//                    do! Async.Sleep 110\n//                    f()\n//            } |> Async.Start\n            \n    [<NoComparison ; NoEquality>]\n    type Area =\n    | Auto     of SplitterBar\n    | Fixed    of HtmlMeasure\n    | Splitter of SplitterBar\n    \n    type SectionType =\n    | StVariable\n    | StFixedPx\n    | StFixedPerc\n    \n    [<NoComparison ; NoEquality>]\n    type Grid = {\n        padding       : float\n        gap           : float\n        content       : (string option * HtmlNode) []\n        cols          : Area []\n        rows          : Area []\n        width         : IRef<float>\n        height        : IRef<float>\n        lastSplitter  : (int * bool) option\n    }\n    with\n        static member New = {\n           padding       = 9.0\n           gap           = 9.0\n           cols          = [| |]\n           rows          = [| |]\n           content       = [| |]\n           width         = Var.Create 1000.0\n           height        = Var.Create  100.0\n           lastSplitter  = None\n        }\n        member this.NewSplitter  (f: float)  col =\n            let spl = SplitterBar.New(f)\n            if col then\n                { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols  [| spl              |> Splitter |] }\n            else \n                { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows  [| spl.Horizontal() |> Splitter |] }\n        member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n        member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n        member inline this.ColVariableS(s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n        member inline this.ColVariable (f:float)       = this.NewSplitter f true\n        member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n        member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n        member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n        member inline this.RowVariableS(s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n        member inline this.RowVariable (f:float)       = this.NewSplitter f false\n        member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n        member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n        member        this.Content0       html         = { this with content = Array.append this.content [| None     , html                                  |] }\n        member inline this.Padding      f              = { this with padding = f                                                                                }\n        member inline this.Gap          f              = { this with gap     = f                                                                                }\n        member this.changeSplitter f =\n            this.lastSplitter\n            |> Option.iter (fun (pos, col) ->\n                if col then\n                    match this.cols.[pos] with\n                    | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                    | _            -> ()\n                else \n                    match this.rows.[pos] with\n                    | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                    | _            -> ()\n            )\n            this\n        member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n        member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n        member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n        member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n        member this.style    (areas:Area[]) size =\n            if areas.Length = 0 then Val.Constant \"100%\" else\n            let pcs, pxs = \n                areas \n                |> Seq.fold (fun (pcs, pxs) a ->\n                    match a with\n                    | Auto              spl -> (                          pcs,                pxs)          \n                    | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                    | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                    | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n                ) (Val.Constant 0.0, Val.Constant 0.0)\n            let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n            let autoPct   = Val.map  ((-) 100.0)  pcs \n            let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n            let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n            areas\n            |> Seq.foldBack (fun a state ->\n                match a with\n                |  Auto              spl -> perc  autoPct          \n                |  Splitter          spl -> perc  spl.GetValue\n                |  Fixed (Percentage v)  -> perc  v\n                |  Fixed (Pixel      v)  -> pixel v\n                |> Val.map2(fun state v -> v::state) state\n               )  <| (Val.Constant [])\n            |> Val.map (String.concat \" \")\n        member this.styles() =\n            [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n              style1 \"grid-template-rows\"    <| this.style this.rows this.height\n            ]\n        member this.GridTemplate() =\n            [ \n                yield!\n                    this.content\n                    |> Seq.map (fun (area, html) ->\n                        match area with\n                        | None   -> html\n                        | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s; dispxlay: grid\" a ])\n                       )\n                yield!\n                    this.cols\n                    |> Seq.indexed\n                    |> Seq.choose (function\n                        | i, Auto     spl -> None           \n                        | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                                [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                                  style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                        | i, Fixed    _   -> None\n                   )\n                yield!\n                    this.rows\n                    |> Seq.indexed\n                    |> Seq.choose (function\n                        | i, Auto     spl -> None           \n                        | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                                [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                                  style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                        | i, Fixed    _   -> None\n                   )\n                yield! this.styles() \n                yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n                yield SomeAttr <| on.afterRender(fun (el:Dom.Element) -> \n                    let setVar (vr:IRef<_>) vl = if vr.Value <> vl then vr.Value <- vl \n                    let setDimensions () =\n                        el.GetBoundingClientRect()\n                        |> fun r ->  \n                            setVar this.width  r.Width\n                            setVar this.height r.Height\n                    do  setDimensions()\n                    addResizeObserver setDimensions el\n                  ) \n            ]\n        member this.Render =\n            div <| this.GridTemplate()\n        static member inline NewBisect(first, secT, ver, per:float, ch1, ch2) =\n            let sect, auto, areas = \n                if ver then match secT with\n                            | StVariable  -> fun (g:Grid) -> g.ColVariable per\n                            | StFixedPx   -> fun (g:Grid) -> g.ColFixedPx  per\n                            | StFixedPerc -> fun (g:Grid) -> g.ColFixed    per\n                           ,                (fun (g:Grid) -> g.ColAuto 50.0)\n                           ,                 fun (g:Grid) -> g.Content0( style \"grid-template-areas: 'one   two' \" )\n                       else match secT with\n                            | StVariable  -> fun (g:Grid) -> g.RowVariable per\n                            | StFixedPx   -> fun (g:Grid) -> g.RowFixedPx  per\n                            | StFixedPerc -> fun (g:Grid) -> g.RowFixed    per\n                           ,                (fun (g:Grid) -> g.RowAuto 50.0)\n                           ,                 fun (g:Grid) -> g.Content0( style \"grid-template-areas: 'one' 'two' \" )\n            Grid.New.Content(\"one\", ch1)\n                    .Content(\"two\", ch2).Padding(0.0)\n            |> areas\n            |> (if first then sect >> auto\n                         else auto >> sect)\n                         ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}, {"SnippetId" :"ac152670-fb8a-4549-9659-1b6ee81d64ef"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6f21cac6-796b-4cec-9242-3133e24a9f98"}, "snpName": "", "snpContent": "\ntype Elem =\n    | Div      of Elem list\n    | HtmlText of string\n    | Style    of string\n    \nlet div      = Div\nlet htmlText = HtmlText\nlet style    = Style\n\ntype Grid = {\n    something : string\n}\nwith     \n    static member New = { something = \"New\" } \n    member this.ColFixed    n = { this with something = this.something |> sprintf \"%s.ColFixed(%f)\"    <| n      }\n    member this.ColVariable n = { this with something = this.something |> sprintf \"%s.ColVariable(%f)\" <| n      }\n    member this.ColAuto     n = { this with something = this.something |> sprintf \"%s.ColAuto(%f)\"     <| n      }\n    member this.RowFixed    n = { this with something = this.something |> sprintf \"%s.RowFixed(%f)\"    <| n      }\n    member this.RowVariable n = { this with something = this.something |> sprintf \"%s.RowVariable(%f)\" <| n      }\n    member this.RowAuto     n = { this with something = this.something |> sprintf \"%s.RowAuto(%f)\"     <| n      }\n    member this.Before        = { this with something = this.something |> sprintf \"%s.Before\"                    }\n    member this.Max         n = { this with something = this.something |> sprintf \"%s.Max(%f)\"         <| n      }\n    member this.Content     c = { this with something = this.something |> sprintf \"%s.Content(%A)\"     <| c      }\n    member this.Content(p, c) = { this with something = this.something |> sprintf \"%s.Content(%s, %A)\" <| p <| c }\n\nlet sc1 = 30.0\nlet sr1 = 30.0\n\nlet grid =\n  Grid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(54.) //Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(54.) //Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div [ htmlText \"Div22\" ; style \"background-color: lightblue\"  ])\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\ngrid\n|> printfn \"%A\" ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"}, "snpName": "RunCode", "snpContent": "module RunCode =\n    type RunNode(nodeName, ?clearNode: bool) =\n      let bClearNode    = defaultArg clearNode true\n      let createNode() =\n          let e = JS.Document.CreateElement \"div\"\n          e?style <- \"height: 100%; width: 100%;\"\n          e\n      let createBaseNode () =\n          let el = JS.Document.CreateElement \"div\"\n          el.SetAttribute(\"id\", nodeName)\n          JS.Document.Body.AppendChild el |> ignore\n          el\n      let baseNode = \n          match JS.Document.GetElementById nodeName with\n          | null -> createBaseNode()\n          | node -> node\n      let runNode =\n          let shadowRootInit = createObj [ \"mode\" ==> \"open\" ]\n          match baseNode.ShadowRoot with\n          | null -> let p = createNode()\n                    baseNode.AttachShadow(shadowRootInit).AppendChild p |> ignore\n                    let e = createNode()\n                    p.AppendChild e |> ignore\n                    e\n          | root -> root.FirstChild :?> Dom.Element\n      do if bClearNode then runNode.InnerHTML <- \"\"\n    with\n      new(?clearNode: bool) = RunNode(\"TestNode\", ?clearNode = clearNode)\n      member this.RunNode   = runNode\n      member this.AddBootstrap =\n        JS.Document.CreateElement \"div\"\n        |> fun el -> \n            el.InnerHTML <- \n              @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n                <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n                <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n                <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n               \"\n            runNode.ParentNode.AppendChild el |> ignore\n        this\n      member inline this.RunDoc doc = doc :> Doc |> Doc.Run this.RunNode\n      member inline this.RunHtml node = node |> renderDoc |> this.RunDoc\n      member this.ShowHtmlResult res =\n        this.AddBootstrap |> ignore\n        div [ ``class`` \"container\"\n              Template.Panel.New\n                .Title(\"Result:\")\n                .Header([])\n                .Content([ h3 res ; style \"font-family:monospace;\" ])\n                .Render\n         ] |> this.RunHtml\n      member this.ShowHtmlResult res = this.ShowHtmlResult [res]\n    ", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"13151ce6-c10f-4773-b6fc-ef448af463e4"}, {"SnippetId" :"ac152670-fb8a-4549-9659-1b6ee81d64ef"}, {"SnippetId" :"da5508bb-2f38-4096-bd2b-1015d26e131b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2ed09262-d6f2-4b9d-a035-6d1c9cf9bc3f"}, "snpName": "Demo Button", "snpContent": "module JS =\n    let [< Emit \"alert($0)\" >] Alert v = ()\n    \nmodule Template =\n    [<NoComparison ; NoEquality>]\n    type Button = {\n        _class  : Val<string>\n        _type   : Val<string>\n        style   : Val<string>\n        text    : Val<string>\n        onClick : Dom.Element -> Dom.MouseEvent -> unit\n        disabled: Val<bool>\n        id      : string\n    } with\n      static member inline New txt = \n          { _class   = Val.fixit \"btn\" \n            _type    = Val.fixit \"button\" \n            style    = Val.fixit \"\"\n            text     = Val.fixit txt\n            onClick  = fun _ _ -> ()\n            disabled = Val.fixit false\n            id       = \"\"\n          }\n      member        this.Render     =         \n        button [ ``type``  <| this._type\n                 ``class`` <| this._class\n                 Id        <| this.id  \n                 style     <| this.style\n//                 SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n                 SomeAttr  <| on.click <@ this.onClick @>\n                 HtmlText  <| this.text \n               ] \n        |> renderDoc |> SomeDoc\n      member inline this.Id          id   = { this with id       = id             }\n      member inline this.Class       clas = { this with _class   = Val.fixit clas }\n      member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n      member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n      member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n      member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n      member inline this.OnClick     f    = { this with onClick  = f              }\n\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n   \n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f56e40da-45c8-4844-9bb3-b713a1e90248"}, "snpName": "Test Mouse", "snpContent": "printfn \"Running\"\n\n\nlet panel1 res =\n    Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n\nprintfn \"Ran\"\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"211f2565-8bc1-434c-8470-dd629f82bb57"}, "snpName": "Demo TextArea", "snpContent": "module Template =\n    [<NoComparison ; NoEquality>]\n    type TextArea = {\n        _class      : Val<string>\n        placeholder : Val<string>\n        title       : Val<string>\n        spellcheck  : Val<bool>\n        id          : string\n        var         : IRef<string>\n    } with\n      static member  New(var) = { _class      = Val.fixit \"form-control\"\n                                  placeholder = Val.fixit \"Enter text:\"\n                                  title       = Val.fixit \"\"\n                                  spellcheck  = Val.fixit false\n                                  id          = \"\"\n                                  var         = var \n                                }\n      static member  New(v)   = TextArea.New(Var.Create v)\n      member        this.RenderWith  more  =    \n        Doc.InputArea\n            ([ \n              _class              this._class\n              //attr.id             this.id  \n              atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n              atr \"title\"         this.title\n              atr \"style\"        \"height: 100%;  width: 100%; box-sizing: border-box; \"\n              _placeholder        this.placeholder \n             ] @ more)\n            this.var\n        |> someElt \n        |> Seq.singleton \n        |> Seq.toArray\n        //|> Seq.append [ style \"height: 100%;  width: 100%; box-sizing: border-box; \" ] \n        |> div\n      member        this.Render           = this.RenderWith []    \n      member inline this.Class       clas = { this with _class      = Val.fixit clas }\n      member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n      member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n      member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n      member inline this.Id          id   = { this with id          = id             }\n      member inline this.SetVar      v    = { this with var         = v              }\n      member inline this.Var              = this.var\n  \n\nlet inp = Template.TextArea.New(\"Type Something...\").Placeholder(\"Output:\"    ).Title(\"Output\"                   )\nprintfn \"Runnning\"\n\nlet text = htmlText inp.Var\n\nh3 [\n  inp.Render\n  text\n  htmlElement \"h2\" [ text ]\n  h1 [ text ]\n] \n:: []\n|> div\n|> renderDoc\n|> Doc.RunById \"TestNode\" \n\nprintfn \"Ran\"\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f7841b2d-7812-4d81-b3bf-81f8f813be2e"}, "snpName": "Demo SplitterBar", "snpContent": "let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Var.Create 25.0 //Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Var.Create 75.0 //Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Var.Create 40.0 //Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value)//(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(min)\n                     .Max(max)\n\nprintfn \"Demo SplitterBar\"\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  div [ htmlText <| Val.map (sprintf \"Min: %f\") min   ] // .Render\n  div [ htmlText <| Val.map (sprintf \"Max: %f\") max   ] // .Render\n  div [ htmlText <| Val.map (sprintf \"Val: %f\") value ] // .Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml//PlusFree\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"}, {"SnippetId" :"da5508bb-2f38-4096-bd2b-1015d26e131b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"af851ad2-7069-4b5e-b682-9e2d148138de"}, "snpName": "Demo Grid", "snpContent": "\n            \n    \nopen Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nlet inline fixedHorSplitter1 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowFixedPx(px).RowAuto(50.0).Content0( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet inline fixedHorSplitter2 px ch1 ch2 =\n    let grid = Grid.New.Content(\"one\", ch1)\n                       .Content(\"two\", ch2).Padding(0.0)\n    grid.RowAuto(50.0).RowFixedPx(px).Content0( style \"grid-template-areas: 'one' 'two' \" ).Render\n\nlet div22 =\n        fixedHorSplitter2 80.0    \n            <| (fixedHorSplitter1 34.0 \n                <| div [ htmlText \"Fixed34px\" ; style \"background-color: lightblue\"  ]\n                <| div [ htmlText \"Variable \" ; style \"background-color: lightgreen\" ])\n            <| div [ htmlText \"Fixed80px\" ; style \"background-color: magenta\"    ]\n\nlet grid0 =\n    Grid.New\n      .ColFixed(8.0).ColVariableS(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\nlet grid1 =\n    grid0\n      .RowFixed(8.0).RowVariableS(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\nlet grid2 =\n    grid1\n      .Content0(        div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n      .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n      .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n      .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\nlet grid =\n    grid2\n      .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n      .Content(\"2 / 2\", div22                                                          )\n      .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n      .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n\nprintfn \"Demo Grid\"\n\ngrid.Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [{"SnippetId" :"82012458-72e3-453b-be38-9fc0b913fad8"}, {"SnippetId" :"ac152670-fb8a-4549-9659-1b6ee81d64ef"}, {"SnippetId" :"bdeadbd2-e1a4-41b7-87ab-f61643b0f5be"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a12aaea2-fcec-4a6e-9f94-b76e1054bbef"}, "snpName": "JavaScript", "snpContent": "require([\"exports\", \"fable-core/Symbol\", \"fable-core/Util\", \"fable-core/String\", \"fable-core/Seq\", \"fable-core/Set\", \"fable-core/Comparer\", \"fable-core/CurriedLambda\", \"fable-core/List\", \"fable-core/Array\"], function (exports, _Symbol2, _Util, _String, _Seq, _Set, _Comparer, _CurriedLambda, _List, _Array2) {\n  \"use strict\"; try { exports = exports || {}; } catch (err) {}\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.grid = exports.grid2 = exports.grid1 = exports.grid0 = exports.div22 = exports.sr1 = exports.sc1 = exports.RunCode = exports.Template = exports.Panel = exports.renderDoc = exports.HtmlNode = exports.ValModule = exports.attr = exports.on = exports.Val = exports.DocModule = exports.View = exports.IRef = exports.Elt = exports.Doc = exports.Attr = exports.Option = exports.JS = exports.Window = exports.Dom = undefined;\n  exports.addClassX = addClassX;\n  exports.chooseThisAttr = chooseThisAttr;\n  exports.concat = concat;\n  exports.groupAttr = groupAttr;\n  exports.chooseNode = chooseNode;\n  exports.getAttrChildren = getAttrChildren;\n  exports.mapHtmlElement = mapHtmlElement;\n  exports.style2pairs = style2pairs;\n  exports.isUndefined = isUndefined;\n\n  var _Symbol3 = _interopRequireDefault(_Symbol2);\n\n  var _Comparer2 = _interopRequireDefault(_Comparer);\n\n  var _CurriedLambda2 = _interopRequireDefault(_CurriedLambda);\n\n  var _List2 = _interopRequireDefault(_List);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const Dom = exports.Dom = function (__exports) {\n    const DomRect = __exports.DomRect = class DomRect {\n      constructor(top, left, width, height) {\n        this.top = top;\n        this.left = left;\n        this.width = width;\n        this.height = height;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.DomRect\",\n          interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n          properties: {\n            top: \"number\",\n            left: \"number\",\n            width: \"number\",\n            height: \"number\"\n          }\n        };\n      }\n\n      Equals(other) {\n        return (0, _Util.equalsRecords)(this, other);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareRecords)(this, other) | 0;\n      }\n\n      get Top() {\n        return this.top;\n      }\n\n      get Left() {\n        return this.left;\n      }\n\n      get Width() {\n        return this.width;\n      }\n\n      get Height() {\n        return this.height;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.DomRect\", DomRect);\n\n    const _Event = __exports.Event = class _Event {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Event\",\n          properties: {}\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Event\", _Event);\n    const MouseEvent = __exports.MouseEvent = class MouseEvent extends _Event {\n      [_Symbol3.default.reflection]() {\n        return (0, _Util.extendInfo)(MouseEvent, {\n          type: \"FSSGlobal.Snippets.Dom.MouseEvent\",\n          interfaces: [],\n          properties: {\n            ClientX: \"number\",\n            ClientY: \"number\"\n          }\n        });\n      }\n\n      constructor() {\n        super();\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.MouseEvent\", MouseEvent);\n\n    const _Node = __exports.Node = class _Node {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Node\",\n          nullable: true,\n          properties: {\n            FirstChild: _Node,\n            ParentElement: _Element,\n            ParentNode: _Node\n          }\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Node\", _Node);\n\n    const _Element = __exports.Element = class _Element extends _Node {\n      [_Symbol3.default.reflection]() {\n        return (0, _Util.extendInfo)(_Element, {\n          type: \"FSSGlobal.Snippets.Dom.Element\",\n          nullable: true,\n          interfaces: [],\n          properties: {\n            InnerHTML: \"string\",\n            ShadowRoot: _Element\n          }\n        });\n      }\n\n      constructor() {\n        super();\n      }\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Element\", _Element);\n\n    const _Document = __exports.Document = class _Document {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Dom.Document\",\n          properties: {\n            Body: _Element\n          }\n        };\n      }\n\n      constructor() {}\n\n    };\n\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Dom.Document\", _Document);\n    return __exports;\n  }({});\n\n  class _Window {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Window\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Window = _Window;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Window\", _Window);\n\n  class JS {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.JS\",\n        properties: {\n          Document: Dom.Document,\n          Window: _Window\n        }\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.JS = JS;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.JS\", JS);\n\n  const Option = exports.Option = function (__exports) {\n    const defaultValue = __exports.defaultValue = function (v, _arg1) {\n      if (_arg1 == null) {\n        return v;\n      } else {\n        return _arg1;\n      }\n    };\n\n    return __exports;\n  }({});\n\n  class _Attr {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Attr\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Attr = _Attr;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Attr\", _Attr);\n\n  class Doc {\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Doc\",\n        properties: {}\n      };\n    }\n\n    constructor() {}\n\n  }\n\n  exports.Doc = Doc;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Doc\", Doc);\n\n  class Elt extends Doc {\n    [_Symbol3.default.reflection]() {\n      return (0, _Util.extendInfo)(Elt, {\n        type: \"FSSGlobal.Snippets.Elt\",\n        interfaces: [],\n        properties: {}\n      });\n    }\n\n    constructor() {\n      super();\n    }\n\n  }\n\n  exports.Elt = Elt;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Elt\", Elt);\n\n  class IRef {\n    constructor(initial) {\n      this.initial = initial;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.IRef\",\n        interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n        properties: {\n          initial: (0, _Util.GenericParam)(\"V\")\n        }\n      };\n    }\n\n    Equals(other) {\n      return (0, _Util.equalsRecords)(this, other);\n    }\n\n    CompareTo(other) {\n      return (0, _Util.compareRecords)(this, other) | 0;\n    }\n\n  }\n\n  exports.IRef = IRef;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.IRef\", IRef);\n\n  class View {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.View\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"FromConst\", (0, _Util.GenericParam)(\"V\")], [\"FromVar\", (0, _Util.makeGeneric)(IRef, {\n          V: (0, _Util.GenericParam)(\"V\")\n        })], [\"FromView\", (0, _Util.makeGeneric)(View, {\n          V: _Util.Any\n        }), (0, _Util.Function)([_Util.Any, (0, _Util.makeGeneric)(View, {\n          V: (0, _Util.GenericParam)(\"V\")\n        })])]]\n      };\n    }\n\n  }\n\n  exports.View = View;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.View\", View);\n\n  const DocModule = exports.DocModule = function (__exports) {\n    const _Element_1 = __exports.Element = function (a, b, c) {\n      return WebSharper.UI.Next.Doc.Element(a, Array.from(b), Array.from(c));\n    };\n\n    const InputArea = __exports.InputArea = function (b, c) {\n      return WebSharper.UI.Next.Doc.InputArea(Array.from(b), c);\n    };\n\n    return __exports;\n  }({});\n\n  class Val {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Val\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"Constant\", (0, _Util.GenericParam)(\"a\")], [\"DynamicV\", (0, _Util.makeGeneric)(IRef, {\n          V: (0, _Util.GenericParam)(\"a\")\n        })], [\"Dynamic\", (0, _Util.makeGeneric)(View, {\n          V: (0, _Util.GenericParam)(\"a\")\n        })]]\n      };\n    }\n\n    get FooBar() {\n      return 0;\n    }\n\n  }\n\n  exports.Val = Val;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Val\", Val);\n\n  const on = exports.on = function (__exports) {\n    const click = __exports.click = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"click\", f);\n    };\n\n    const mouseMove = __exports.mouseMove = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseMove\", f);\n    };\n\n    const mouseDown = __exports.mouseDown = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseDown\", f);\n    };\n\n    const mouseUp = __exports.mouseUp = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"mouseUp\", f);\n    };\n\n    const afterRender = __exports.afterRender = function (f) {\n      return WebSharper.UI.Next.AttrProxy.Handler(\"afterRender\", f);\n    };\n\n    return __exports;\n  }({});\n\n  const attr = exports.attr = function (__exports) {\n    const disabledDynPred = __exports.disabledDynPred = function (pred, view) {\n      return WebSharper.UI.Next.AttrModule.DynamicPred(\"disabled\", pred, pred);\n    };\n\n    return __exports;\n  }({});\n\n  const ValModule = exports.ValModule = function (__exports) {\n    const mapV = __exports.mapV = function (f, va) {\n      if (va.tag === 2) {\n        return new Val(2, function (vw) {\n          return WebSharper.UI.Next.View.Map(f, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return new Val(2, function (vw_1) {\n          return WebSharper.UI.Next.View.Map(f, vw_1);\n        }(va.data.RView()));\n      } else {\n        return new Val(0, f(va.data));\n      }\n    };\n\n    const iterV = __exports.iterV = function (f, va) {\n      if (va.tag === 2) {\n        WebSharper.UI.Next.View.Get(f, va.data);\n      } else if (va.tag === 1) {\n        f(va.data.RVal());\n      } else {\n        f(va.data);\n      }\n    };\n\n    const toView = __exports.toView = function (v) {\n      if (v.tag === 2) {\n        return v.data;\n      } else if (v.tag === 1) {\n        return v.data.RView();\n      } else {\n        return WebSharper.UI.Next.View.Const(v.data);\n      }\n    };\n\n    const bindV = __exports.bindV = function (f, v) {\n      if (v.tag === 2) {\n        return new Val(2, WebSharper.UI.Next.View.Bind($var1 => function (v_1) {\n          return toView(v_1);\n        }(f($var1)), v.data));\n      } else if (v.tag === 1) {\n        return new Val(2, WebSharper.UI.Next.View.Bind($var2 => function (v_2) {\n          return toView(v_2);\n        }(f($var2)), v.data.RView()));\n      } else {\n        return f(v.data);\n      }\n    };\n\n    const tagDoc = __exports.tagDoc = function (tag, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw) {\n          return WebSharper.UI.Next.View.Map(tag, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw_1) {\n          return WebSharper.UI.Next.View.Map(tag, vw_1);\n        }(va.data.RView()));\n      } else {\n        return tag(va.data);\n      }\n    };\n\n    const tagElt = __exports.tagElt = function (tag, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw) {\n          return WebSharper.UI.Next.View.Map(tag, vw);\n        }(va.data));\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.Doc.EmbedView(function (vw_1) {\n          return WebSharper.UI.Next.View.Map(tag, vw_1);\n        }(va.data.RView()));\n      } else {\n        return tag(va.data);\n      }\n    };\n\n    const attrVO = __exports.attrVO = function (att, vao) {\n      if (vao.tag === 2) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Map(      $0, $1)\", WebSharper.UI.Next.View.Map(function (option) {\n          return option != null;\n        }, vao.data));\n      } else if (vao.tag === 1) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Map(      $0, $1)\", WebSharper.UI.Next.View.Map(function (option_1) {\n          return option_1 != null;\n        }, vao.data.RView()));\n      } else if (vao.data == null) {\n        return WebSharper.UI.Next.AttrModule.DynamicPred(att, \"WebSharper.UI.Next.View.Const(    $0)\", WebSharper.UI.Next.View.Const(false));\n      } else {\n        return WebSharper.UI.Next.AttrProxy.Create(att, vao.data);\n      }\n    };\n\n    const attrV = __exports.attrV = function (att, va) {\n      if (va.tag === 2) {\n        return WebSharper.UI.Next.AttrModule.Dynamic(att, va.data);\n      } else if (va.tag === 1) {\n        return WebSharper.UI.Next.AttrModule.Dynamic(att, va.data.RView());\n      } else {\n        return WebSharper.UI.Next.AttrProxy.Create(att, va.data);\n      }\n    };\n\n    const HelperType = __exports.HelperType = class HelperType {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.ValModule.HelperType\",\n          interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n          cases: [[\"HelperType\"]]\n        };\n      }\n\n      Equals(other) {\n        return this === other || this.tag === other.tag && (0, _Util.equals)(this.data, other.data);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareUnions)(this, other) | 0;\n      }\n\n      static op_AmpGreater_0(_arg1, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_1(_arg2, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_2(_arg3, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_3(_arg4, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_4(_arg5, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_5(_arg6, a) {\n        return new Val(0, a);\n      }\n\n      static op_AmpGreater_6(_arg7, va) {\n        return va;\n      }\n\n      static op_AmpGreater_7(_arg8, va) {\n        return va;\n      }\n\n      static op_AmpGreater_8(_arg9, va) {\n        return va;\n      }\n\n      static op_AmpGreater_9(_arg10, va) {\n        return va;\n      }\n\n      static op_AmpGreater_10(_arg11, va) {\n        return va;\n      }\n\n      static op_AmpGreater_11(_arg12, va) {\n        return va;\n      }\n\n      static op_AmpGreater_12(_arg13, va) {\n        return va;\n      }\n\n      static op_AmpGreater_13(_arg14, vr) {\n        return new Val(1, vr);\n      }\n\n      static op_AmpGreater_14(_arg15, vw) {\n        return new Val(2, vw);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.ValModule.HelperType\", HelperType);\n\n    const toVal = __exports.toVal = function (o) {\n      if (typeof o === \"string\") {\n        return new Val(0, o);\n      } else if (typeof o === \"number\") {\n        return new Val(0, o);\n      } else if (typeof o === \"boolean\") {\n        return new Val(0, o);\n      } else if (o instanceof WebSharper.UI.Next.Doc) {\n        return new Val(0, o);\n      } else if (o instanceof Val) {\n        return o;\n      } else if (o instanceof WebSharper.UI.Next.Var) {\n        return new Val(1, o);\n      } else if (\"RSet\" in o) {\n        return new Val(1, o);\n      } else if (typeof o == 'function') {\n        return new Val(2, o);\n      } else {\n        throw new Error((0, _String.toText)((0, _String.printf)(\"Could not convert %A\"))(o));\n      }\n    };\n\n    return __exports;\n  }({});\n\n  class HtmlNode {\n    constructor(tag, data) {\n      this.tag = tag;\n      this.data = data;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.HtmlNode\",\n        interfaces: [\"FSharpUnion\"],\n        cases: [[\"HtmlElement\", \"string\", (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\")], [\"HtmlAttribute\", \"string\", (0, _Util.makeGeneric)(Val, {\n          a: \"string\"\n        })], [\"HtmlAttributeO\", \"string\", (0, _Util.makeGeneric)(Val, {\n          a: (0, _Util.Option)(\"string\")\n        })], [\"HtmlText\", (0, _Util.makeGeneric)(Val, {\n          a: \"string\"\n        })], [\"HtmlEmpty\"], [\"HtmlElementV\", (0, _Util.makeGeneric)(Val, {\n          a: HtmlNode\n        })], [\"SomeDoc\", Doc], [\"SomeAttr\", _Attr]]\n      };\n    }\n\n    AddChildren(add) {\n      return (h => mapHtmlElement((n, ch) => [n, (0, _Seq.append)(ch, add)], h))(this);\n    }\n\n    InsertChildren(add) {\n      return (h => mapHtmlElement((n, ch) => [n, (0, _Seq.append)(add, ch)], h))(this);\n    }\n\n  }\n\n  exports.HtmlNode = HtmlNode;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.HtmlNode\", HtmlNode);\n\n  function addClassX(classes, add) {\n    return (0, _String.join)(\" \", (0, _Set.union)((0, _Set.create)((0, _String.split)(add, \" \"), new _Comparer2.default(_Util.comparePrimitives)), (0, _Set.create)((0, _String.split)(classes, \" \"), new _Comparer2.default(_Util.comparePrimitives))));\n  }\n\n  function chooseThisAttr(_this, node) {\n    const $var3 = node.tag === 1 ? node.data[0] === _this ? [0, node.data[0], node.data[1]] : [1] : [1];\n\n    switch ($var3[0]) {\n      case 0:\n        return (0, _Util.some)($var3[2]);\n\n      case 1:\n        return null;\n    }\n  }\n\n  function concat(s, a, b) {\n    return a + s + b;\n  }\n\n  function groupAttr(name, sep, children) {\n    return function (ss) {\n      return (0, _Seq.isEmpty)(ss) ? null : (0, _Util.some)(function (va) {\n        return ValModule.attrV(name, va);\n      }((0, _Seq.reduce)(($var14, $var15) => function (f, v1, v2) {\n        return (($var12, $var13) => function (f_4, a_1, b_1) {\n          return f_4(b_1, a_1);\n        }((0, _CurriedLambda2.default)(function (vb) {\n          const f_3 = $var9 => {\n            return function (f_2, a, b) {\n              return f_2(b, a);\n            }(($var10, $var11) => ($var8 => ($var6 => $var7 => function (f_1, va_1) {\n              return ValModule.mapV(f_1, va_1);\n            }($var6, $var7))(($var4 => $var5 => f($var4, $var5))($var8)))($var10)($var11), vb, $var9);\n          };\n\n          return function (v) {\n            return ValModule.bindV(f_3, v);\n          };\n        }), $var12, $var13))(function (o) {\n          return ValModule.toVal(o);\n        }(v1), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(v2));\n      }(function (a_2, b_2) {\n        return concat(sep, a_2, b_2);\n      }, $var14, $var15), ss)));\n    }((0, _Seq.choose)(function (node) {\n      return chooseThisAttr(name, node);\n    }, children));\n  }\n\n  function chooseNode(node) {\n    switch (node.tag) {\n      case 0:\n        return (0, _Util.some)(DocModule.Element(node.data[0], (0, _Seq.append)((0, _List.choose)(function (x) {\n          return x;\n        }, (0, _List.ofArray)([groupAttr(\"class\", \" \", node.data[1]), groupAttr(\"style\", \"; \", node.data[1])])), function (source) {\n          return (0, _Seq.choose)(function (node_1) {\n            const $var16 = node_1.tag === 1 ? (node_1.data[0] !== \"class\" ? node_1.data[0] !== \"style\" : false) ? [0, node_1.data[0], node_1.data[1]] : [1] : [1];\n\n            switch ($var16[0]) {\n              case 0:\n                return (0, _Util.some)(ValModule.attrV($var16[1], $var16[2]));\n\n              case 1:\n                const $var17 = node_1.tag === 2 ? (node_1.data[0] !== \"class\" ? node_1.data[0] !== \"style\" : false) ? [0, node_1.data[0], node_1.data[1]] : [1] : [1];\n\n                switch ($var17[0]) {\n                  case 0:\n                    return (0, _Util.some)(ValModule.attrVO($var17[1], $var17[2]));\n\n                  case 1:\n                    if (node_1.tag === 7) {\n                      return (0, _Util.some)(node_1.data);\n                    } else {\n                      return null;\n                    }\n\n                }\n\n            }\n          }, source);\n        }(node.data[1])), (0, _Seq.choose)(function (node_2) {\n          return chooseNode(node_2);\n        }, node.data[1])));\n\n      case 3:\n        return (0, _Util.some)(ValModule.tagDoc(function (txt) {\n          return WebSharper.UI.Next.Doc.TextNode(txt);\n        }, node.data));\n\n      case 6:\n        return (0, _Util.some)(node.data);\n\n      case 5:\n        return (0, _Util.some)(WebSharper.UI.Next.Doc.BindView($var18 => function (_arg1) {\n          return Option.defaultValue(WebSharper.UI.Next.Doc.Empty(), _arg1);\n        }(function (node_3) {\n          return chooseNode(node_3);\n        }($var18)), ValModule.toView(node.data)));\n\n      default:\n        return null;\n    }\n  }\n\n  function getAttrChildren(attr_1) {\n    return $var19 => Option.defaultValue(new Val(0, \"\"), (0, _Seq.tryPick)(function (_arg1) {\n      const $var20 = _arg1.tag === 1 ? _arg1.data[0] === attr_1 ? [0, _arg1.data[0], _arg1.data[1]] : [1] : [1];\n\n      switch ($var20[0]) {\n        case 0:\n          return (0, _Util.some)($var20[2]);\n\n        case 1:\n          return null;\n      }\n    }, $var19));\n  }\n\n  function mapHtmlElement(f, element) {\n    if (element.tag === 0) {\n      return function (tupledArg) {\n        return new HtmlNode(0, [tupledArg[0], tupledArg[1]]);\n      }(f(element.data[0], element.data[1]));\n    } else if (element.tag === 5) {\n      return new HtmlNode(5, ValModule.mapV(function (element_1) {\n        return mapHtmlElement(f, element_1);\n      }, function (o) {\n        return ValModule.toVal(o);\n      }(element.data)));\n    } else {\n      return element;\n    }\n  }\n\n  const renderDoc = exports.renderDoc = $var21 => function (_arg1) {\n    return Option.defaultValue(WebSharper.UI.Next.Doc.Empty(), _arg1);\n  }(function (node) {\n    return chooseNode(node);\n  }($var21));\n\n  function style2pairs(ss) {\n    return (0, _Array2.map)(function (d) {\n      return [(0, _String.trim)(d[0], \"both\"), (0, _String.trim)(d[1], \"both\")];\n    }, (0, _Array2.map)(function (s) {\n      return (0, _String.split)(s, \":\");\n    }, (0, _String.split)(ss, \";\"), Array).filter(function (d_1) {\n      return d_1.length === 2;\n    }), Array);\n  }\n\n  function isUndefined(v) {\n    return true;\n  }\n\n  class Panel {\n    constructor(_class, _style, title, header, content, disabled) {\n      this._class = _class;\n      this._style = _style;\n      this.title = title;\n      this.header = header;\n      this.content = content;\n      this.disabled = disabled;\n    }\n\n    [_Symbol3.default.reflection]() {\n      return {\n        type: \"FSSGlobal.Snippets.Panel\",\n        interfaces: [\"FSharpRecord\"],\n        properties: {\n          _class: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          _style: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          title: (0, _Util.makeGeneric)(Val, {\n            a: \"string\"\n          }),\n          header: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n          content: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n          disabled: (0, _Util.makeGeneric)(Val, {\n            a: \"boolean\"\n          })\n        }\n      };\n    }\n\n    static get New() {\n      return new Panel(function (o) {\n        return ValModule.toVal(o);\n      }(\"panel panel-default shadow\"), function (o_1) {\n        return ValModule.toVal(o_1);\n      }(\"text-align:center\"), function (o_2) {\n        return ValModule.toVal(o_2);\n      }(\"Panel\"), (0, _List.ofArray)([new HtmlNode(3, function (o_3) {\n        return ValModule.toVal(o_3);\n      }(\"Some text\"))]), (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n        return ValModule.toVal(o_4);\n      }(\"Some Content\"))]), function (o_5) {\n        return ValModule.toVal(o_5);\n      }(WebSharper.UI.Next.Var.Create$1(false)));\n    }\n\n    get Render() {\n      return new HtmlNode(0, [\"fieldset\", (0, _List.ofArray)([new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(this._class)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_1 => ValModule.toVal(o_1))(\"panel-heading\")]), new HtmlNode(0, [\"label\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_2 => ValModule.toVal(o_2))(\"panel-title text-center\")]), new HtmlNode(3, (o_3 => ValModule.toVal(o_3))(this.title))])])]), this.header)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(\"panel-body\")]), new HtmlNode(1, [\"style\", (o_5 => ValModule.toVal(o_5))(this._style)])]), this.content)])])])])]);\n    }\n\n  }\n\n  exports.Panel = Panel;\n  (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Panel\", Panel);\n\n  const Template = exports.Template = function (__exports) {\n    const Panel = __exports.Panel = class Panel {\n      constructor(_class, _style, title, header, content, disabled) {\n        this._class = _class;\n        this._style = _style;\n        this.title = title;\n        this.header = header;\n        this.content = content;\n        this.disabled = disabled;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Panel\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            _class: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            _style: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            title: (0, _Util.makeGeneric)(Val, {\n              a: \"string\"\n            }),\n            header: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            content: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            disabled: (0, _Util.makeGeneric)(Val, {\n              a: \"boolean\"\n            })\n          }\n        };\n      }\n\n      static get New() {\n        return new Panel(function (o) {\n          return ValModule.toVal(o);\n        }(\"panel panel-default shadow\"), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(\"text-align:center\"), function (o_2) {\n          return ValModule.toVal(o_2);\n        }(\"Panel\"), (0, _List.ofArray)([new HtmlNode(3, function (o_3) {\n          return ValModule.toVal(o_3);\n        }(\"Some text\"))]), (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n          return ValModule.toVal(o_4);\n        }(\"Some Content\"))]), function (o_5) {\n          return ValModule.toVal(o_5);\n        }(WebSharper.UI.Next.Var.Create$1(false)));\n      }\n\n      get Render() {\n        return new HtmlNode(0, [\"fieldset\", (0, _List.ofArray)([new HtmlNode(7, attr.disabledDynPred(WebSharper.UI.Next.View.Const(\"\"), ValModule.toView(this.disabled))), new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(this._class)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_1 => ValModule.toVal(o_1))(\"panel-heading\")]), new HtmlNode(0, [\"label\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_2 => ValModule.toVal(o_2))(\"panel-title text-center\")]), new HtmlNode(3, (o_3 => ValModule.toVal(o_3))(this.title))])])]), this.header)]), new HtmlNode(0, [\"div\", (0, _Seq.append)((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(\"panel-body\")]), new HtmlNode(1, [\"style\", (o_5 => ValModule.toVal(o_5))(this._style)])]), this.content)])])])])]);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Panel\", Panel);\n    const HtmlMeasure = __exports.HtmlMeasure = class HtmlMeasure {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.HtmlMeasure\",\n          interfaces: [\"FSharpUnion\"],\n          cases: [[\"Percentage\", (0, _Util.makeGeneric)(Val, {\n            a: \"number\"\n          })], [\"Pixel\", (0, _Util.makeGeneric)(Val, {\n            a: \"number\"\n          })]]\n        };\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.HtmlMeasure\", HtmlMeasure);\n    const SplitterBar = __exports.SplitterBar = class SplitterBar {\n      constructor(value, min, max, vertical, node, children, after, dragging, startVer, startP, start, size, domElem) {\n        this.value = value;\n        this.min = min;\n        this.max = max;\n        this.vertical = vertical;\n        this.node = node;\n        this.children = children;\n        this.after = after;\n        this.dragging = dragging;\n        this.startVer = startVer;\n        this.startP = startP;\n        this.start = start;\n        this.size = size;\n        this.domElem = domElem;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.SplitterBar\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            value: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            min: (0, _Util.makeGeneric)(Val, {\n              a: \"number\"\n            }),\n            max: (0, _Util.makeGeneric)(Val, {\n              a: \"number\"\n            }),\n            vertical: (0, _Util.makeGeneric)(Val, {\n              a: \"boolean\"\n            }),\n            node: HtmlNode,\n            children: (0, _Util.Interface)(\"System.Collections.Generic.IEnumerable\"),\n            after: \"boolean\",\n            dragging: \"boolean\",\n            startVer: \"boolean\",\n            startP: \"number\",\n            start: \"number\",\n            size: \"number\",\n            domElem: (0, _Util.Option)(Dom.Element)\n          }\n        };\n      }\n\n      static New_0(_var) {\n        return new SplitterBar(_var, function (o) {\n          return ValModule.toVal(o);\n        }(5), function (o_1) {\n          return ValModule.toVal(o_1);\n        }(95), function (o_2) {\n          return ValModule.toVal(o_2);\n        }(true), new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", function (o_3) {\n          return ValModule.toVal(o_3);\n        }(\"Splitter\")])])]), new _List2.default(), true, false, true, 0, 0, 0, null);\n      }\n\n      static New_1(value) {\n        return SplitterBar.New_0(WebSharper.UI.Next.Var.Create$1(value));\n      }\n\n      get Var() {\n        return this.value;\n      }\n\n      get GetValue() {\n        return (($var40, $var41) => ((f_7, a_3, b_3) => f_7(b_3, a_3))((0, _CurriedLambda2.default)(vb_1 => {\n          const f_6 = $var37 => {\n            return ((f_5, a_2, b_2) => f_5(b_2, a_2))(($var38, $var39) => ($var36 => ($var34 => $var35 => ((f_4, va_1) => ValModule.mapV(f_4, va_1))($var34, $var35))(($var32 => $var33 => ((e1, e2) => e1 < e2 ? e1 : e2)($var32, $var33))($var36)))($var38)($var39), vb_1, $var37);\n          };\n\n          return v_1 => ValModule.bindV(f_6, v_1);\n        }, this), $var40, $var41))((o_2 => ValModule.toVal(o_2))(this.max), (o_3 => ValModule.toVal(o_3))((($var30, $var31) => ((f_3, a_1, b_1) => f_3(b_1, a_1))((0, _CurriedLambda2.default)(vb => {\n          const f_2 = $var27 => {\n            return ((f_1, a, b) => f_1(b, a))(($var28, $var29) => ($var26 => ($var24 => $var25 => ((f, va) => ValModule.mapV(f, va))($var24, $var25))(($var22 => $var23 => ((e1_1, e2_1) => e1_1 > e2_1 ? e1_1 : e2_1)($var22, $var23))($var26)))($var28)($var29), vb, $var27);\n          };\n\n          return v => ValModule.bindV(f_2, v);\n        }, this), $var30, $var31))((o => ValModule.toVal(o))(this.min), (o_1 => ValModule.toVal(o_1))(this.value))));\n      }\n\n      get Render() {\n        const mouseCoord = ev => {\n          if (this.startVer) {\n            return ev.clientX;\n          } else {\n            return ev.clientY;\n          }\n        };\n\n        const size = () => {\n          const matchValue = this.domElem;\n\n          if (matchValue != null) {\n            return (r => {\n              const matchValue_1 = [this.startVer, this.after];\n\n              if (matchValue_1[0]) {\n                if (matchValue_1[1]) {\n                  return r.Width;\n                } else {\n                  return -r.Width;\n                }\n              } else if (matchValue_1[1]) {\n                return r.Height;\n              } else {\n                return -r.Height;\n              }\n            })(matchValue.parentElement.getBoundingClientRect());\n          } else {\n            return 100;\n          }\n        };\n\n        const drag = ev_1 => {\n          (v => {\n            this.value.set_RVal(v);\n          })((m => (m - this.start) * 100 / this.size + this.startP)(mouseCoord(ev_1)));\n        };\n\n        const finishDragging = _arg1 => {\n          if (this.dragging) {\n            this.dragging = false;\n            window.removeEventListener(\"mousemove\", drag, false);\n            window.removeEventListener(\"mouseup\", finishDragging, false);\n          }\n        };\n\n        const startDragging = (_arg2, ev_2) => {\n          if (!this.dragging) {\n            ValModule.iterV(() => {}, (o_2 => ValModule.toVal(o_2))((($var50, $var51) => ((f_3, a_1, b_1) => f_3(b_1, a_1))((0, _CurriedLambda2.default)(vb => {\n              const f_2 = $var47 => {\n                return ((f_1, a, b) => f_1(b, a))(($var48, $var49) => ($var46 => ($var44 => $var45 => ((f, va) => ValModule.mapV(f, va))($var44, $var45))(($var42 => $var43 => {\n                  ((startP, dirV) => {\n                    this.dragging = true;\n                    this.startVer = dirV;\n                    this.startP = startP;\n                    this.start = mouseCoord(ev_2);\n                    this.size = size();\n                    window.addEventListener(\"mousemove\", drag, false);\n                    window.addEventListener(\"mouseup\", finishDragging, false);\n                    ev_2.preventDefault;\n                  })($var42, $var43);\n                })($var46)))($var48)($var49), vb, $var47);\n              };\n\n              return v_1 => ValModule.bindV(f_2, v_1);\n            }, this), $var50, $var51))((o => ValModule.toVal(o))(this.GetValue), (o_1 => ValModule.toVal(o_1))(this.vertical))));\n          }\n        };\n\n        return this.node.AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"class\", (o_4 => ValModule.toVal(o_4))(ValModule.mapV(ver => ver ? \"Vertical\" : \"Horizontal\", (o_3 => ValModule.toVal(o_3))(this.vertical)))]), new HtmlNode(7, on.mouseDown((0, _CurriedLambda2.default)(startDragging))), new HtmlNode(7, on.afterRender(el => {\n          this.domElem = (0, _Util.some)(el);\n        })), new HtmlNode(0, [\"style\", (0, _List.ofArray)([new HtmlNode(3, (o_5 => ValModule.toVal(o_5))(\"\\n                          .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\\n                          .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\\n                      \"))])])])).AddChildren(this.children);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.SplitterBar\", SplitterBar);\n    let observers = __exports.observers = (0, _Util.createAtom)(new _List2.default());\n\n    const isValidElement = __exports.isValidElement = function (el) {\n      const r = el.getBoundingClientRect();\n      return !(0, _Util.equals)([r.Top, r.Left, r.Width, r.Height], [0, 0, 0, 0]);\n    };\n\n    const addResizeObserver = __exports.addResizeObserver = function (f, el) {\n      if (!!ResizeObserver) {\n        const ro = new ResizeObserver(f);\n        observers(new _List2.default(ro, observers()));\n        ro.observe(el);\n      } else {\n        (function (arg00, arg10) {\n          return setInterval(arg00, arg10);\n        })(f, 110);\n      }\n    };\n\n    const Area = __exports.Area = class Area {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Area\",\n          interfaces: [\"FSharpUnion\"],\n          cases: [[\"Auto\", SplitterBar], [\"Fixed\", HtmlMeasure], [\"Splitter\", SplitterBar]]\n        };\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Area\", Area);\n    const SectionType = __exports.SectionType = class SectionType {\n      constructor(tag, data) {\n        this.tag = tag;\n        this.data = data;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.SectionType\",\n          interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n          cases: [[\"StVariable\"], [\"StFixedPx\"], [\"StFixedPerc\"]]\n        };\n      }\n\n      Equals(other) {\n        return this === other || this.tag === other.tag && (0, _Util.equals)(this.data, other.data);\n      }\n\n      CompareTo(other) {\n        return (0, _Util.compareUnions)(this, other) | 0;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.SectionType\", SectionType);\n    const Grid = __exports.Grid = class Grid {\n      constructor(padding, gap, content, cols, rows, width, height, lastSplitter) {\n        this.padding = padding;\n        this.gap = gap;\n        this.content = content;\n        this.cols = cols;\n        this.rows = rows;\n        this.width = width;\n        this.height = height;\n        this.lastSplitter = lastSplitter;\n      }\n\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.Template.Grid\",\n          interfaces: [\"FSharpRecord\"],\n          properties: {\n            padding: \"number\",\n            gap: \"number\",\n            content: (0, _Util.Array)((0, _Util.Tuple)([(0, _Util.Option)(\"string\"), HtmlNode])),\n            cols: (0, _Util.Array)(Area),\n            rows: (0, _Util.Array)(Area),\n            width: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            height: (0, _Util.makeGeneric)(IRef, {\n              V: \"number\"\n            }),\n            lastSplitter: (0, _Util.Option)((0, _Util.Tuple)([\"number\", \"boolean\"]))\n          }\n        };\n      }\n\n      static get New() {\n        const cols = [];\n        const rows = [];\n        return new Grid(9, 9, [], cols, rows, WebSharper.UI.Next.Var.Create$1(1000), WebSharper.UI.Next.Var.Create$1(100), null);\n      }\n\n      NewSplitter(f, col) {\n        const spl = SplitterBar.New_1(f);\n\n        if (col) {\n          const lastSplitter = (0, _Util.some)([this.cols.length, col]);\n          const cols = this.cols.concat([new Area(2, spl)]);\n          return new Grid(this.padding, this.gap, this.content, cols, this.rows, this.width, this.height, lastSplitter);\n        } else {\n          const lastSplitter_1 = (0, _Util.some)([this.rows.length, col]);\n          const rows = this.rows.concat([new Area(2, (() => {\n            const vertical = (o => ValModule.toVal(o))(false);\n\n            return new SplitterBar(spl.value, spl.min, spl.max, vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n          })())]);\n          return new Grid(this.padding, this.gap, this.content, this.cols, rows, this.width, this.height, lastSplitter_1);\n        }\n      }\n\n      Content(area, html) {\n        const content = this.content.concat([[(0, _Util.some)(area), html]]);\n        return new Grid(this.padding, this.gap, content, this.cols, this.rows, this.width, this.height, this.lastSplitter);\n      }\n\n      Content0(html) {\n        const content = this.content.concat([[null, html]]);\n        return new Grid(this.padding, this.gap, content, this.cols, this.rows, this.width, this.height, this.lastSplitter);\n      }\n\n      changeSplitter(f) {\n        (0, _Seq.iterate)(tupledArg => {\n          if (tupledArg[1]) {\n            const matchValue = this.cols[tupledArg[0]];\n\n            if (matchValue.tag === 2) {\n              this.cols[tupledArg[0]] = new Area(2, f(matchValue.data));\n            }\n          } else {\n            const matchValue_1 = this.rows[tupledArg[0]];\n\n            if (matchValue_1.tag === 2) {\n              this.rows[tupledArg[0]] = new Area(2, f(matchValue_1.data));\n            }\n          }\n        }, (0, _Util.defaultArg)(this.lastSplitter, [], $var52 => [$var52]));\n        return this;\n      }\n\n      get Before() {\n        return this.changeSplitter(spl => new SplitterBar(spl.value, spl.min, spl.max, spl.vertical, spl.node, spl.children, false, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem));\n      }\n\n      style(areas, size) {\n        if (areas.length === 0) {\n          return new Val(0, \"100%\");\n        } else {\n          const patternInput = (() => {\n            const folder = (tupledArg, a) => {\n              if (a.tag === 2) {\n                return [(($var61, $var62) => ((f_3, a_2, b_1) => f_3(b_1, a_2))((0, _CurriedLambda2.default)(vb => {\n                  const f_2 = $var58 => {\n                    return ((f_1, a_1, b) => f_1(b, a_1))(($var59, $var60) => ($var57 => ($var55 => $var56 => ((f, va) => ValModule.mapV(f, va))($var55, $var56))(($var53 => $var54 => ((x, y) => x + y)($var53, $var54))($var57)))($var59)($var60), vb, $var58);\n                  };\n\n                  return v => ValModule.bindV(f_2, v);\n                }, this), $var61, $var62))((o => ValModule.toVal(o))(a.data.GetValue), (o_1 => ValModule.toVal(o_1))(tupledArg[0])), tupledArg[1]];\n              } else if (a.tag === 1) {\n                if (a.data.tag === 1) {\n                  return [tupledArg[0], (($var71, $var72) => ((f_7, a_4, b_3) => f_7(b_3, a_4))((0, _CurriedLambda2.default)(vb_1 => {\n                    const f_6 = $var68 => {\n                      return ((f_5, a_3, b_2) => f_5(b_2, a_3))(($var69, $var70) => ($var67 => ($var65 => $var66 => ((f_4, va_1) => ValModule.mapV(f_4, va_1))($var65, $var66))(($var63 => $var64 => ((x_1, y_1) => x_1 + y_1)($var63, $var64))($var67)))($var69)($var70), vb_1, $var68);\n                    };\n\n                    return v_1 => ValModule.bindV(f_6, v_1);\n                  }, this), $var71, $var72))((o_2 => ValModule.toVal(o_2))(a.data.data), (o_3 => ValModule.toVal(o_3))(tupledArg[1]))];\n                } else {\n                  return [(($var81, $var82) => ((f_11, a_6, b_5) => f_11(b_5, a_6))((0, _CurriedLambda2.default)(vb_2 => {\n                    const f_10 = $var78 => {\n                      return ((f_9, a_5, b_4) => f_9(b_4, a_5))(($var79, $var80) => ($var77 => ($var75 => $var76 => ((f_8, va_2) => ValModule.mapV(f_8, va_2))($var75, $var76))(($var73 => $var74 => ((x_2, y_2) => x_2 + y_2)($var73, $var74))($var77)))($var79)($var80), vb_2, $var78);\n                    };\n\n                    return v_2 => ValModule.bindV(f_10, v_2);\n                  }, this), $var81, $var82))((o_4 => ValModule.toVal(o_4))(a.data.data), (o_5 => ValModule.toVal(o_5))(tupledArg[0])), tupledArg[1]];\n                }\n              } else {\n                return [tupledArg[0], tupledArg[1]];\n              }\n            };\n\n            const arg = [new Val(0, 0), new Val(0, 0)];\n            return source => (0, _Seq.fold)(folder, [arg[0], arg[1]], source);\n          })()(areas);\n\n          const finalPerc = (($var91, $var92) => ((f_15, a_8, b_7) => f_15(b_7, a_8))((0, _CurriedLambda2.default)(vb_3 => {\n            const f_14 = $var88 => {\n              return ((f_13, a_7, b_6) => f_13(b_6, a_7))(($var89, $var90) => ($var87 => ($var85 => $var86 => ((f_12, va_3) => ValModule.mapV(f_12, va_3))($var85, $var86))(($var83 => $var84 => ((v_3, size_1) => (size_1 - this.padding * 2 - this.gap * (areas.length - 1) - v_3) / (size_1 - this.padding * 2))($var83, $var84))($var87)))($var89)($var90), vb_3, $var88);\n            };\n\n            return v_4 => ValModule.bindV(f_14, v_4);\n          }, this), $var91, $var92))((o_6 => ValModule.toVal(o_6))(patternInput[1]), (o_7 => ValModule.toVal(o_7))(size));\n\n          const autoPct = ValModule.mapV(y_3 => 100 - y_3, (o_8 => ValModule.toVal(o_8))(patternInput[0]));\n\n          const perc = pc => {\n            return (($var101, $var102) => ((f_19, a_10, b_9) => f_19(b_9, a_10))((0, _CurriedLambda2.default)(vb_4 => {\n              const f_18 = $var98 => {\n                return ((f_17, a_9, b_8) => f_17(b_8, a_9))(($var99, $var100) => ($var97 => ($var95 => $var96 => ((f_16, va_4) => ValModule.mapV(f_16, va_4))($var95, $var96))(($var93 => $var94 => ((finalPerc_1, pc_1) => (0, _String.toText)((0, _String.printf)(\"%f%%\"))(0 > finalPerc_1 * pc_1 ? 0 : finalPerc_1 * pc_1))($var93, $var94))($var97)))($var99)($var100), vb_4, $var98);\n              };\n\n              return v_5 => ValModule.bindV(f_18, v_5);\n            }, this), $var101, $var102))((o_9 => ValModule.toVal(o_9))(finalPerc), (o_10 => ValModule.toVal(o_10))(pc));\n          };\n\n          const pixel = px => {\n            return ValModule.mapV(px_1 => (0, _String.toText)((0, _String.printf)(\"%fpx\"))(0 > px_1 ? 0 : px_1), (o_11 => ValModule.toVal(o_11))(px));\n          };\n\n          return ValModule.mapV(strings => (0, _String.join)(\" \", strings), (o_14 => ValModule.toVal(o_14))(($var113 => (() => {\n            const folder_1 = (a_11, state) => {\n              return (() => {\n                const f_20 = (state_1, v_6) => {\n                  return new _List2.default(v_6, state_1);\n                };\n\n                return v2 => (($var111, $var112) => ((f_24, a_13, b_11) => f_24(b_11, a_13))((0, _CurriedLambda2.default)(vb_5 => {\n                  const f_23 = $var108 => {\n                    return ((f_22, a_12, b_10) => f_22(b_10, a_12))(($var109, $var110) => ($var107 => ($var105 => $var106 => ((f_21, va_5) => ValModule.mapV(f_21, va_5))($var105, $var106))(($var103 => $var104 => f_20($var103, $var104))($var107)))($var109)($var110), vb_5, $var108);\n                  };\n\n                  return v_7 => ValModule.bindV(f_23, v_7);\n                }, this), $var111, $var112))((o_12 => ValModule.toVal(o_12))(state), (o_13 => ValModule.toVal(o_13))(v2));\n              })()(a_11.tag === 2 ? perc(a_11.data.GetValue) : a_11.tag === 1 ? a_11.data.tag === 1 ? pixel(a_11.data.data) : perc(a_11.data.data) : perc(autoPct));\n            };\n\n            return (source_1, state_2) => (0, _Seq.foldBack)(folder_1, source_1, state_2);\n          })()(areas, $var113))(new Val(0, new _List2.default()))));\n        }\n      }\n\n      styles() {\n        return (0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_1 => ValModule.toVal(o_1))(ValModule.mapV((() => {\n          const x = \"grid-template-columns:\";\n          return y => x + y;\n        })(), (o => ValModule.toVal(o))(((arg00, arg10) => this.style(arg00, arg10))(this.cols, this.width))))]), new HtmlNode(1, [\"style\", (o_3 => ValModule.toVal(o_3))(ValModule.mapV((() => {\n          const x_1 = \"grid-template-rows:\";\n          return y_1 => x_1 + y_1;\n        })(), (o_2 => ValModule.toVal(o_2))(((arg00_1, arg10_1) => this.style(arg00_1, arg10_1))(this.rows, this.height))))])]);\n      }\n\n      GridTemplate() {\n        return (0, _Seq.toList)((0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.map)(tupledArg => tupledArg[0] != null ? tupledArg[1].AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o => ValModule.toVal(o))((0, _String.toText)((0, _String.printf)(\"grid-area: %s; dispxlay: grid\"))(tupledArg[0]))])])) : tupledArg[1], this.content), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.choose)(_arg1 => {\n          if (_arg1[1].tag === 2) {\n            const spl = _arg1[1].data;\n            return (0, _Util.some)(spl.Render.InsertChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_2 => ValModule.toVal(o_2))(ValModule.mapV((() => {\n              const x = \"grid-column:\";\n              return y => x + y;\n            })(), (o_1 => ValModule.toVal(o_1))((_arg1[0] + (spl.after ? 2 : 1)).toString())))]), new HtmlNode(1, [\"style\", (o_4 => ValModule.toVal(o_4))(ValModule.mapV((() => {\n              const x_1 = \"grid-row:\";\n              return y_1 => x_1 + y_1;\n            })(), (o_3 => ValModule.toVal(o_3))((0, _String.toText)((0, _String.printf)(\"1 / %d\"))(this.rows.length + 1))))])])));\n          } else if (_arg1[1].tag === 1) {\n            return null;\n          } else {\n            const spl_1 = _arg1[1].data;\n            return null;\n          }\n        }, (0, _Seq.indexed)(this.cols)), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.choose)(_arg2 => {\n          if (_arg2[1].tag === 2) {\n            const spl_2 = _arg2[1].data;\n            return (0, _Util.some)(spl_2.Render.InsertChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", (o_6 => ValModule.toVal(o_6))(ValModule.mapV((() => {\n              const x_2 = \"grid-row:\";\n              return y_2 => x_2 + y_2;\n            })(), (o_5 => ValModule.toVal(o_5))((_arg2[0] + (spl_2.after ? 2 : 1)).toString())))]), new HtmlNode(1, [\"style\", (o_8 => ValModule.toVal(o_8))(ValModule.mapV((() => {\n              const x_3 = \"grid-column:\";\n              return y_3 => x_3 + y_3;\n            })(), (o_7 => ValModule.toVal(o_7))((0, _String.toText)((0, _String.printf)(\"1 / %d\"))(this.cols.length + 1))))])])));\n          } else if (_arg2[1].tag === 1) {\n            return null;\n          } else {\n            const spl_3 = _arg2[1].data;\n            return null;\n          }\n        }, (0, _Seq.indexed)(this.rows)), (0, _Seq.delay)(() => (0, _Seq.append)(this.styles(), (0, _Seq.delay)(() => (0, _Seq.append)((0, _Seq.singleton)(new HtmlNode(1, [\"style\", (o_9 => ValModule.toVal(o_9))((0, _String.toText)((0, _String.printf)(\"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\"))(this.gap, this.padding))])), (0, _Seq.delay)(() => (0, _Seq.singleton)(new HtmlNode(7, on.afterRender(el => {\n          const setVar = (vr, vl) => {\n            if (!(0, _Util.equals)(vr.RVal(), vl)) {\n              vr.set_RVal(vl);\n            }\n          };\n\n          const setDimensions = () => {\n            (r => {\n              setVar(this.width, r.Width);\n              setVar(this.height, r.Height);\n            })(el.getBoundingClientRect());\n          };\n\n          setDimensions();\n          addResizeObserver(setDimensions, el);\n        })))))))))))))));\n      }\n\n      get Render() {\n        return new HtmlNode(0, [\"div\", this.GridTemplate()]);\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.Template.Grid\", Grid);\n    return __exports;\n  }({});\n\n  const RunCode = exports.RunCode = function (__exports) {\n    const RunNode = __exports.RunNode = class RunNode {\n      [_Symbol3.default.reflection]() {\n        return {\n          type: \"FSSGlobal.Snippets.RunCode.RunNode\",\n          properties: {\n            AddBootstrap: RunNode,\n            RunNode: Dom.Element\n          }\n        };\n      }\n\n      constructor(nodeName, clearNode) {\n        this.nodeName = nodeName;\n        const bClearNode = clearNode != null ? clearNode : true;\n        let baseNode;\n        const matchValue = document.getElementById(this.nodeName);\n\n        if (matchValue == null) {\n          baseNode = this.createBaseNode();\n        } else {\n          baseNode = matchValue;\n        }\n\n        const shadowRootInit = {\n          mode: \"open\"\n        };\n        const matchValue_1 = baseNode.shadowRoot;\n\n        if (matchValue_1 == null) {\n          const p = this.createNode();\n          baseNode.attachShadow(shadowRootInit).appendChild(p);\n          const e = this.createNode();\n          p.appendChild(e);\n          this.runNode = e;\n        } else {\n          this.runNode = matchValue_1.firstChild;\n        }\n\n        if (bClearNode) {\n          this.runNode.innerHTML = \"\";\n        }\n      }\n\n      static [\".ctor\"](clearNode) {\n        return new RunNode(\"TestNode\", clearNode);\n      }\n\n      get RunNode() {\n        return this.runNode;\n      }\n\n      get AddBootstrap() {\n        (el => {\n          el.innerHTML = \"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\\n                      <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\\n                      <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\\n                      <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\\n                     \";\n          this.runNode.parentNode.appendChild(el);\n        })(document.createElement(\"div\"));\n\n        return this;\n      }\n\n      createNode() {\n        const e = document.createElement(\"div\");\n        e.style = \"height: 100%; width: 100%;\";\n        return e;\n      }\n\n      createBaseNode() {\n        const el = document.createElement(\"div\");\n        el.setAttribute(\"id\", this.nodeName);\n        document.body.appendChild(el);\n        return el;\n      }\n\n    };\n    (0, _Symbol2.setType)(\"FSSGlobal.Snippets.RunCode.RunNode\", RunNode);\n    return __exports;\n  }({});\n\n  const sc1 = exports.sc1 = Template.SplitterBar.New_1(30);\n\n  const sr1 = exports.sr1 = (() => {\n    const vertical = (o => ValModule.toVal(o))(false);\n\n    return new Template.SplitterBar(Template.SplitterBar.New_1(30).value, Template.SplitterBar.New_1(30).min, Template.SplitterBar.New_1(30).max, vertical, Template.SplitterBar.New_1(30).node, Template.SplitterBar.New_1(30).children, Template.SplitterBar.New_1(30).after, Template.SplitterBar.New_1(30).dragging, Template.SplitterBar.New_1(30).startVer, Template.SplitterBar.New_1(30).startP, Template.SplitterBar.New_1(30).start, Template.SplitterBar.New_1(30).size, Template.SplitterBar.New_1(30).domElem);\n  })();\n\n  const div22 = exports.div22 = ($var115 => function (ch1, ch2) {\n    const grid = new Template.Grid(0, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).gap, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).content, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).cols, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).rows, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).width, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).height, Template.Grid.New.Content(\"one\", ch1).Content(\"two\", ch2).lastSplitter);\n    return (() => {\n      const rows_1 = (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_1 => ValModule.toVal(o_1))(80)))]);\n\n      return new Template.Grid((() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().padding, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().gap, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().content, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().width, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().height, (() => {\n        const rows = grid.rows.concat([new Template.Area(0, (() => {\n          const vertical = (o => ValModule.toVal(o))(false);\n\n          return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n        })())]);\n        return new Template.Grid(grid.padding, grid.gap, grid.content, grid.cols, rows, grid.width, grid.height, grid.lastSplitter);\n      })().lastSplitter);\n    })().Content0(new HtmlNode(1, [\"style\", function (o_2) {\n      return ValModule.toVal(o_2);\n    }(\"grid-template-areas: 'one' 'two' \")])).Render;\n  }(($var114 => function (ch1_1, ch2_1) {\n    const grid_1 = new Template.Grid(0, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).gap, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).content, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).cols, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).rows, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).width, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).height, Template.Grid.New.Content(\"one\", ch1_1).Content(\"two\", ch2_1).lastSplitter);\n    return (() => {\n      const rows_3 = (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().rows.concat([new Template.Area(0, (() => {\n        const vertical_1 = (o_4 => ValModule.toVal(o_4))(false);\n\n        return new Template.SplitterBar(Template.SplitterBar.New_1(50).value, Template.SplitterBar.New_1(50).min, Template.SplitterBar.New_1(50).max, vertical_1, Template.SplitterBar.New_1(50).node, Template.SplitterBar.New_1(50).children, Template.SplitterBar.New_1(50).after, Template.SplitterBar.New_1(50).dragging, Template.SplitterBar.New_1(50).startVer, Template.SplitterBar.New_1(50).startP, Template.SplitterBar.New_1(50).start, Template.SplitterBar.New_1(50).size, Template.SplitterBar.New_1(50).domElem);\n      })())]);\n\n      return new Template.Grid((() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().padding, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().gap, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().content, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().cols, rows_3, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().width, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().height, (() => {\n        const rows_2 = grid_1.rows.concat([new Template.Area(1, new Template.HtmlMeasure(1, (o_3 => ValModule.toVal(o_3))(34)))]);\n        return new Template.Grid(grid_1.padding, grid_1.gap, grid_1.content, grid_1.cols, rows_2, grid_1.width, grid_1.height, grid_1.lastSplitter);\n      })().lastSplitter);\n    })().Content0(new HtmlNode(1, [\"style\", function (o_5) {\n      return ValModule.toVal(o_5);\n    }(\"grid-template-areas: 'one' 'two' \")])).Render;\n  }(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_6) {\n    return ValModule.toVal(o_6);\n  }(\"Fixed34px\")), new HtmlNode(1, [\"style\", function (o_7) {\n    return ValModule.toVal(o_7);\n  }(\"background-color: lightblue\")])])]), $var114))(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_8) {\n    return ValModule.toVal(o_8);\n  }(\"Variable \")), new HtmlNode(1, [\"style\", function (o_9) {\n    return ValModule.toVal(o_9);\n  }(\"background-color: lightgreen\")])])])), $var115))(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_10) {\n    return ValModule.toVal(o_10);\n  }(\"Fixed80px\")), new HtmlNode(1, [\"style\", function (o_11) {\n    return ValModule.toVal(o_11);\n  }(\"background-color: magenta\")])])]));\n\n  const grid0 = exports.grid0 = ((arg00, arg10) => (() => {\n    const cols_2 = (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().cols.concat([new Template.Area(0, Template.SplitterBar.New_1(16))]);\n\n    return new Template.Grid((() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().padding, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().gap, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().content, cols_2, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().rows, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().width, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().height, (() => {\n      const cols_1 = (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().cols.concat([new Template.Area(2, sc1)]);\n\n      return new Template.Grid((() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().padding, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().gap, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().content, cols_1, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().rows, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().width, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().height, (() => {\n        const cols = Template.Grid.New.cols.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(Template.Grid.New.padding, Template.Grid.New.gap, Template.Grid.New.content, cols, Template.Grid.New.rows, Template.Grid.New.width, Template.Grid.New.height, Template.Grid.New.lastSplitter);\n      })().lastSplitter);\n    })().lastSplitter);\n  })().NewSplitter(arg00, arg10))(50, true).Before.changeSplitter(spl => {\n    const max = (o_2 => ValModule.toVal(o_2))(ValModule.mapV(function (y) {\n      return 84 - y;\n    }, function (o_1) {\n      return ValModule.toVal(o_1);\n    }(sc1.GetValue)));\n\n    return new Template.SplitterBar(spl.value, spl.min, max, spl.vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n  });\n\n  const grid1 = exports.grid1 = ((arg00, arg10) => (() => {\n    const rows_2 = (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().rows.concat([new Template.Area(0, (() => {\n      const vertical = (o_1 => ValModule.toVal(o_1))(false);\n\n      return new Template.SplitterBar(Template.SplitterBar.New_1(16).value, Template.SplitterBar.New_1(16).min, Template.SplitterBar.New_1(16).max, vertical, Template.SplitterBar.New_1(16).node, Template.SplitterBar.New_1(16).children, Template.SplitterBar.New_1(16).after, Template.SplitterBar.New_1(16).dragging, Template.SplitterBar.New_1(16).startVer, Template.SplitterBar.New_1(16).startP, Template.SplitterBar.New_1(16).start, Template.SplitterBar.New_1(16).size, Template.SplitterBar.New_1(16).domElem);\n    })())]);\n\n    return new Template.Grid((() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().padding, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().gap, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().content, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().cols, rows_2, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().width, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().height, (() => {\n      const rows_1 = (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().rows.concat([new Template.Area(2, sr1)]);\n\n      return new Template.Grid((() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().padding, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().gap, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().content, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().cols, rows_1, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().width, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().height, (() => {\n        const rows = grid0.rows.concat([new Template.Area(1, new Template.HtmlMeasure(0, (o => ValModule.toVal(o))(8)))]);\n        return new Template.Grid(grid0.padding, grid0.gap, grid0.content, grid0.cols, rows, grid0.width, grid0.height, grid0.lastSplitter);\n      })().lastSplitter);\n    })().lastSplitter);\n  })().NewSplitter(arg00, arg10))(50, false).Before.changeSplitter(spl => {\n    const max = (o_3 => ValModule.toVal(o_3))(ValModule.mapV(function (y) {\n      return 84 - y;\n    }, function (o_2) {\n      return ValModule.toVal(o_2);\n    }(sr1.GetValue)));\n\n    return new Template.SplitterBar(spl.value, spl.min, max, spl.vertical, spl.node, spl.children, spl.after, spl.dragging, spl.startVer, spl.startP, spl.start, spl.size, spl.domElem);\n  });\n\n  const grid2 = exports.grid2 = grid1.Content0(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o) {\n    return ValModule.toVal(o);\n  }(\"Div11\")), new HtmlNode(1, [\"style\", function (o_1) {\n    return ValModule.toVal(o_1);\n  }(\"background-color: lightblue\")])])])).Content(\"1 / 2\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_2) {\n    return ValModule.toVal(o_2);\n  }(\"Div12\")), new HtmlNode(1, [\"style\", function (o_3) {\n    return ValModule.toVal(o_3);\n  }(\"background-color: lightgreen\")])])])).Content(\"1 / 3\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n    return ValModule.toVal(o_4);\n  }(\"Div13\")), new HtmlNode(1, [\"style\", function (o_5) {\n    return ValModule.toVal(o_5);\n  }(\"background-color: pink\")])])])).Content(\"1 / 4\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_6) {\n    return ValModule.toVal(o_6);\n  }(\"Div14\")), new HtmlNode(1, [\"style\", function (o_7) {\n    return ValModule.toVal(o_7);\n  }(\"background-color: magenta\")])])]));\n  const grid = exports.grid = grid2.Content(\"2 / 1\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o) {\n    return ValModule.toVal(o);\n  }(\"Div21\")), new HtmlNode(1, [\"style\", function (o_1) {\n    return ValModule.toVal(o_1);\n  }(\"background-color: lightblue\")])])])).Content(\"2 / 2\", div22).Content(\"3 / 3\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_2) {\n    return ValModule.toVal(o_2);\n  }(\"Div33\")), new HtmlNode(1, [\"style\", function (o_3) {\n    return ValModule.toVal(o_3);\n  }(\"background-color: pink\")])])])).Content(\"4 / 4\", new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(3, function (o_4) {\n    return ValModule.toVal(o_4);\n  }(\"Div44\")), new HtmlNode(1, [\"style\", function (o_5) {\n    return ValModule.toVal(o_5);\n  }(\"background-color: magenta\")])])]));\n  (() => {\n    const objectArg = RunCode.RunNode[\".ctor\"]();\n    return function (arg00) {\n      objectArg.AddBootstrap;\n\n      (arg00_1 => {\n        (arg00_2 => {\n          WebSharper.UI.Next.Doc.Run(objectArg.RunNode, arg00_2);\n        })(renderDoc(arg00_1));\n      })(new HtmlNode(0, [\"div\", (0, _List.ofArray)([new HtmlNode(1, [\"class\", (o => ValModule.toVal(o))(\"container\")]), new Template.Panel(new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled)._class, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled)._style, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).title, new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).header, (0, _List.ofArray)([new HtmlNode(0, [\"h3\", arg00]), new HtmlNode(1, [\"style\", (o_2 => ValModule.toVal(o_2))(\"font-family:monospace;\")])]), new Template.Panel((() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._class, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })()._style, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().title, new _List2.default(), (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().content, (() => {\n        const title = (o_1 => ValModule.toVal(o_1))(\"Result:\");\n\n        return new Template.Panel(Template.Panel.New._class, Template.Panel.New._style, title, Template.Panel.New.header, Template.Panel.New.content, Template.Panel.New.disabled);\n      })().disabled).disabled).Render])]));\n    };\n  })()(function (el) {\n    return el.AddChildren((0, _List.ofArray)([new HtmlNode(1, [\"style\", function (o_3) {\n      return ValModule.toVal(o_3);\n    }(\"height: 600px\")])]));\n  }(grid.Render));\n});", "snpParentIdO": {"SnippetId" :"b30f728e-eb7c-40d1-b4ac-596e372b4e84"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5c2c508d-5c37-489f-a539-90b0b13e1e45"}, "snpName": "Tests", "snpContent": "#if WEBSHARPER\n[<WebSharper.JavaScript>]\n#endif\nmodule Tests =", "snpParentIdO": {"SnippetId" :"ba90a7d3-7af6-4637-a92f-5d30657d63f2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"5a35850e-b3e7-40ad-b844-73516566a80f"}, "snpName": "inline errors", "snpContent": "\n\nlet counter =\n    let mutable i = 0\n    fun () ->\n        i <- i + 1\n        i\n    \ntype Type = {\n    a     : int\n    b     : int\n    c     : int\n    d     : int\n    count : int\n}\n  with\n    static member New(n) = {\n        a     = n\n        b     = n * 2\n        c     = n * 3\n        d     = n * 4\n        count = counter()  // <== should only be called twice\n      }\n      \n    member        this.MethodN (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member inline this.MethodI (v:bool) = { this with a = this.a * if v then 2 else 3 }\n    member        this.MethodN ()       = { this with a = this.a * 10                 }\n    member inline this.MethodI ()       = { this with a = this.a * 10                 }\n\nType.New(5).MethodN(false).MethodN(true).MethodN()\n|> printfn \"not inline: %A\"\n    \nType.New(5).MethodI(false).MethodI(true).MethodI()\n|> printfn \"inline: %A\"\n\n#define WEBSHARPER \n", "snpParentIdO": {"SnippetId" :"5c2c508d-5c37-489f-a539-90b0b13e1e45"}, "snpPredIds": [{"SnippetId" :"60bffe71-edde-4971-8327-70b9f5c578bb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpName": "F# STATION TUTORIALS", "snpContent": "// go to 1. Hello World\n#nowarn \"20\"\n#nowarn \"52\"\n#nowarn \"1178\"\n#nowarn \"3180\"\n\n#if WEBSHARPER\n[<JavaScript>]\n#endif\nmodule Tutorials =\n", "snpParentIdO": {"SnippetId" :"bf864f3c-1370-42f2-ac8a-565a604892e8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fde83d46-bd7c-48e4-80f4-647639de87b9"}, "snpName": "1.1 Hello World WebSharper", "snpContent": "\"Hello World!\"                                // Mandatory Hello World example\n|> RunCode.RunNode().AddBootstrap.ShowResult  // <=== ShowResult shows any value as a text in an html pane  \n\n\n\n// Click on \"Run WebSharper\" button below to run example\n// Simple, right?\n\n\n// Intellisense:\n// Double click once on ShowResult to see a tooltip\n\n\n\"\"\"\n\nRun WebSharper can show the result in a new browser tab or in the \"WS Result\" tab below\nDisable pop up blocker for this page\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9657d144-25d9-4d2d-907a-af0245e13f8c"}, "snpName": "1.1 Hello World Fable", "snpContent": "\"Hello World!\"                                // Mandatory Hello World example\n|> printfn \"%A\"                               // <=== What is printed out shows in the Output pane below \n\n\n\n// Click on \"Run Fable\" button below to run example\n// Simple, right?\n\n\"\"\"\n\n\"Run FSI\" and \"Run Fable\" show in the Output pane what is printed out with printfn\n\"Run FSI\" is deactivated over the web, but it works when installed locally\n\nFable was recently added to F# Station and so the integration is still very experimental\nand it is not fully operating.\n\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7df1af66-2085-4125-aa78-ce48ecbe8838"}, "snpName": "2. Working with Predecessors", "snpContent": "// Expand me and go to: \"2.3 Many Hellos\"", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"c47adc01-4550-4830-8df5-e1ebedaee7d0"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a9437ce3-e291-46e8-ab1b-6879efee4b53"}, "snpName": "2.1 countTo", "snpContent": "let countTo n = [| 1..n |]\n\n\n\"\"\"\n\nParent snippets are automatically predecessors too\n\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"7df1af66-2085-4125-aa78-ce48ecbe8838"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}, "snpName": "2.2 sayItManyTimes", "snpContent": "let sayItManyTimes s n = \n    countTo n                            // <=== countTo is defined above\n    |> Array.map (sprintf \"%s %A\" s)\n\n\n\"\"\"\n\nThis snippet has a direct predecessor: \"2.1 countTo\"\n\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"7df1af66-2085-4125-aa78-ce48ecbe8838"}, "snpPredIds": [{"SnippetId" :"a9437ce3-e291-46e8-ab1b-6879efee4b53"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c93f1a5c-0145-4456-b71b-78923fc8a4f7"}, "snpName": "2.3 Many Hellos", "snpContent": "// Working with predecessors\n\nsayItManyTimes \"Hello\" 10                     // \"sayItManyTimes\" is defined in the prior snippet\n|> RunCode.RunNode().AddBootstrap.ShowResult \n\n\n\"\"\" \nClick on \"Run WebSharper\" button below to run example\n\n\nBy using the predecessor mechanism a bunch of code is added with this snippet.\nAll predecessors direct and indirect are highlighted in blue on the left.\nDirect predecessors are marked with an X on the right side of the snippet list.\nTry toggling the direct predecessor 2.2\n\nThe parent of a snippet is automatically a predecessor.\nBy default children snippets code is indented, except when NoIndent property is used.\n\nONLY the highlighted snippets are included in the final code.\n\nTo see the F# code generated, select the \"F# code\" tab below.\n(click on \"Get F# Code\" if it is empty)\n\nThe F# code is translated into JavaScript by WebSharper\nSelect the \"JavaScript\" tab to see the translated JS Code\n(click on \"Run WebSharper\" or \"Compile WebSharper\" if it is empty)\n\n\"\"\"\n// Intellisense:\n// ShowResult is defined somewhere else, to find it\n// click on it and then use <Find Definition> button\n\n", "snpParentIdO": {"SnippetId" :"7df1af66-2085-4125-aa78-ce48ecbe8838"}, "snpPredIds": [{"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9c57f2d5-6e05-410c-8262-1f0573cf7c8e"}, "snpName": "3. Using Html", "snpContent": "div [                                              // an Html tag:  <div>\n    htmlText \"Many Hellos!\"                        // some text\n    ul [                                           // more tags:    <ul> <li>\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield li [ htmlText hello ]\n    ]\n]\n|> RunCode.RunNode().AddBootstrap.ShowHtmlResult   // \"ShowHtmlResult\" displays Html instead of plain text\n\n\n\"\"\"\n\nThis is a simplified version of the WebSharper syntax.\nSubtags and attributes are combined in the same sequence.\n\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4d7c9a6a-9610-49df-9e97-1292a0608074"}, "snpName": "4. Html Attributes", "snpContent": "div [                                              \n    style \"background: beige; color: red\"          // an attribute: \"style\"\n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\" // and another one!\n    ul [\n        for hello in sayItManyTimes \"Hello\" 10 do\n            yield li [\n                    style    \"color: blue\"\n                    htmlText hello \n                  ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"                    // attributes can be in any order\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml         // \"RunHtml\" also displays Html but not in a pane\n\n\"\"\"\n\nMultiple \"style\" and \"class\" attributes are combined automatically.\n\n\n\"\"\"\n\n// Intellisense: Ctrl-Space for autocomplete\n// try it: place cursor right after \"AddBootstrap.\" and press ctrl-space\n\n", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f5d15bec-c4fa-4a62-998d-24a91c4981a2"}, "snpName": "5. Calculated Attributes", "snpContent": "let fontSize i = sprintf \"font-size: %dpx\" ((i + 1) * 3) // <== a nice formula to calculate font size\n\ndiv [                                              \n    style \"background: beige; color: red\"         \n    h1 [ htmlText \"Many Hellos!\" ]\n    style \"font-style: italic; font-family: Times\"\n    ul [\n        for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n            yield \n                li [\n                    style    \"color: blue\"\n                    style <| fontSize i                    // <=== applied here, as a static style\n                    htmlText hello \n                ]\n        yield style \"font-style: normal\"\n    ]\n    style \"text-align: center\"   \n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   ", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cdb3cc85-46be-44a5-9a92-599f080e01e2"}, "snpName": "6. Using Templates and Variables", "snpContent": "let multiplier = Template.Input.New(\"3\")                                          // a Template for text input\n                         .Placeholder(\"Enter multiplier:\")                        // with some nice predefined features\n                         .Prefix(\"Multiplier:\")\n\nlet fontSizeVal i = \n    multiplier.Var                                                                // Use UI.Next Var from the template object\n    |> Val.map (fun m -> sprintf \"font-size: %dpx\" ((i + 1) * int m))             // <=== not static anymore, this one is dynamic!\n\ndiv [\n    multiplier.Render                                                             // Render text input into HtmlNode type\n    div [                                              \n        style \"background: beige; color: red\"         \n        h1 [ htmlText <| Val.map (sprintf \"Many Hellos! x %spx\") multiplier.Var ] // <=== a dynamic text\n        style \"font-style: italic; font-family: Times\"\n        ul [\n            for i, hello in sayItManyTimes \"Hello\" 10 |> Seq.indexed do\n                yield \n                    li [\n                        style    \"color: blue\"\n                        style <| fontSizeVal i                                     // <=== apply dynamic style\n                        htmlText hello \n                    ]\n            yield style \"font-style: normal\"\n        ]\n        style \"text-align: center\"   \n    ]\n]\n|> RunCode.RunNode().AddBootstrap.RunHtml   \n\n\"\"\"\n\n\nThe Val type is a wrapper class that unifies WebSharper's UI.Next Var, View and constant values for a simpler syntax.\n\n\n\"\"\"", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}, {"SnippetId" :"6ec1d5bf-6a84-471a-89aa-d9e9f8ffd141"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b3f2df8c-b6d9-46e2-b09a-a6550b02d5a6"}, "snpName": "7. Work in progress", "snpContent": "FSharpStation.FSharpStationClient \"\"\n|> RunCode.RunNode().AddBootstrap.RunDoc    // Run WebSharper (preferrably in New Browser)\n\n\"\"\"\n\nYes, the tutorial is short. This is a work in progress.\nBut there are more interesting Snippets inside \"WebSharper Code\", go check them out.\n\nPeople usually complain that examples in tutorials are only Mickey Mouse versions \nbut \"F# Station\" is fully coded in F# Station. \nI mean the code is all here including client and server sides, \nfeel free to explore and discover.\n\nEven though it is client-server it isn't intended to be used over the Web,\n\"Run FSI\" uses FSI which gives full access to the server computer which is dangerous.\nThat is why \"Run FSI\" is disabled over the web.\n\n\"Run Fable\" was recently added, still in development.\n\nTo get the full power of F# Station install locally in your computer.\n\n\"\"\" // To install locally goto: https://github.com/amieres/FSharpStation \n", "snpParentIdO": {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, "snpPredIds": [{"SnippetId" :"8ee8705a-f115-437e-8d7d-418773f3c6d4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpName": "ACTIONS", "snpContent": "module Actions =", "snpParentIdO": {"SnippetId" :"bc1521b8-a408-454d-9857-de5d145cfd77"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 45}, {"snpId": {"SnippetId" :"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"}, "snpName": "SAVE FSharpStation.js", "snpContent": "FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetJS @\"website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"\n", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"b37f91be-7579-4fea-8263-bd10ec60f7e4"}, {"SnippetId" :"b5ce4e03-57ad-4ec2-a8f2-445831815f01"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"56b4fb1e-909e-4b83-b312-8993751d0685"}, "snpName": "SAVE FSharpStation.fsx", "snpContent": "FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveSnippetFsx @\"..\\bin\\website\\EPFileX\" \"FSSGlobal/WebSharper Code/FSharpStation Code/FSharpStation\"", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"b37f91be-7579-4fea-8263-bd10ec60f7e4"}, {"SnippetId" :"b5ce4e03-57ad-4ec2-a8f2-445831815f01"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"df25d045-936b-4f0e-9a22-429cd4f8848a"}, "snpName": "SAVE FsJson File", "snpContent": "FSSGlobal.FsStationShared.FsStationClient(\"SAVE CodeEditor\")\n    .SaveWholeFile @\"..\\..\" \"CodeEditor\"", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"b37f91be-7579-4fea-8263-bd10ec60f7e4"}, {"SnippetId" :"b5ce4e03-57ad-4ec2-a8f2-445831815f01"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e307def4-b29d-4abf-9ec6-8744c0b8d75a"}, "snpName": "DO Saves", "snpContent": "// Click Evaluate F#", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"07a3e5d2-a793-49cf-bb87-88a98c5d9c7d"}, {"SnippetId" :"56b4fb1e-909e-4b83-b312-8993751d0685"}, {"SnippetId" :"df25d045-936b-4f0e-9a22-429cd4f8848a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpName": "Compile Modules", "snpContent": "#define COMPILING\nopen FSSGlobal.WSMessagingBroker // open's need to be here\nopen FSSGlobal.Useful\nopen FSSGlobal.UsefulDotNet.CompOptionsModule\n\nlet fsStation = FStationMessaging(\"Compile Modules\")\n[\n\n", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"d9c4540a-85f5-4c62-91be-fcb2d60e9f17"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b89801cc-5412-4025-bd88-c6ec0624a970"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/FsTranslator/FsTranslator\"        |> compileOptionsExeDebug\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2db6dbb4-6c03-4c3d-990f-abfb997e9855"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/FsStationShared/SelfHostedServer\" |> compileOptionsExeDebug\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8deb7606-0602-4a16-83b4-4528985f267e"}, "snpName": "", "snpContent": "(\"FSSGlobal/F# Code/UsefulDotNet/RemotingDll\"        |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + opDirectory   /= \"Compiled/RemotingDll2\"\n  + wsProjectOptions\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7b5a4715-f440-41ed-aad3-47930c2f259d"}, "snpName": "", "snpContent": "(\"FSSGlobal/WebSharper Code/Template/AllTemplates\"   |> compileOptionsDllDebug)\n  + opGenWSharper /= \"ws:library\" \n  + wsProjectOptions\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"53c32bfe-219e-4ff1-8913-adbc067b40d4"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/FSAutoComplete/FSAutoCompleteDll\" |> compileOptionsDllDebug\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2f153bcc-4e41-479b-8275-09f4446d22d7"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/CalculationModel/CalculationModelDll\" |> compileOptionsDllDebug", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"03007562-4ff3-484e-9b11-d68a9c774a60"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/WSMessagingBroker/FSCompilerDll\"  |> compileOptionsDllDebug", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7196e914-b38c-489b-a119-c980432ac41b"}, "snpName": "", "snpContent": "\"FSSGlobal/F# Code/Snippets/Calculate primes\"        |> compileOptionsWinExeDebug", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a9d20f7f-1748-43cf-82af-34ee09de85a1"}, "snpName": "", "snpContent": "\"FSI Zone/DeserializeTest\"        |> compileOptionsExeDebug\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"d39e3783-fb76-4963-b9fe-2da76c4b2a86"}, "snpName": "Compile selected modules", "snpContent": "// select the module(s) to compile\n\n] |> Seq.iter (id \n        >> swap (+) [ opGenInternal /= \"showoptions\" ] \n        //>> swap (+) [ opGenFSharp2  /= \"standalone\"  ] \n        >> fsStation.CompileSnippetW \n        >> Wrap.runSynchronouslyS true\n        >> printfn \"%s\"\n     )\n", "snpParentIdO": {"SnippetId" :"15ddb111-736f-4f18-9ff3-9b13f9560cb8"}, "snpPredIds": [{"SnippetId" :"a9d20f7f-1748-43cf-82af-34ee09de85a1"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"64f180f8-8781-4630-9239-b5610a6329b6"}, "snpName": "DO/check all ACTIONS", "snpContent": "// Just Select as predecessors all the actions you want to execute \n// and then click on Evaluate F#\n", "snpParentIdO": {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, "snpPredIds": [{"SnippetId" :"24394c61-747d-41ff-816e-c70e46573bb7"}, {"SnippetId" :"5e8209e0-9203-4fe0-8289-fb4579b24038"}, {"SnippetId" :"c578e375-e299-4450-957e-1596e7af2007"}, {"SnippetId" :"c8c93861-321c-4d73-beb0-2fef0052bc7b"}, {"SnippetId" :"d39e3783-fb76-4963-b9fe-2da76c4b2a86"}, {"SnippetId" :"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"}, {"SnippetId" :"e307def4-b29d-4abf-9ec6-8744c0b8d75a"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e83d0347-89ba-4fbf-8bd0-02723299e948"}, "snpName": "FSNew", "snpContent": "module FSNew =", "snpParentIdO": {"SnippetId" :"bc1521b8-a408-454d-9857-de5d145cfd77"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 45}, {"snpId": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpName": "Useful", "snpContent": "module Useful =", "snpParentIdO": {"SnippetId" :"e83d0347-89ba-4fbf-8bd0-02723299e948"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"}, "snpName": "swap", "snpContent": "\nlet inline swap f a b = f b a\nlet inline __   f a b = f b a\n\n", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"414d2960-2447-4fef-9c37-b1b7098d8355"}, "snpName": "extract, now, Async, String", "snpContent": "let extract n (s:string) = s.Substring(0, min n s.Length)\n\n#if WEBSHARPER\n[< Inline \"(function (n) { return n.getFullYear() + '-' +(n.getMonth() + 1) + '-' +  n.getDate() + ' '+n.getHours()+ ':'+n.getMinutes()+ ':'+n.getSeconds()+ ':'+n.getMilliseconds() })(new Date(Date.now()))\" >]\n#endif\nlet nowStamp() = \n    let t = System.DateTime.UtcNow // in two steps to avoid Warning: The value has been copied to ensure the original is not mutated\n    t.ToString(\"yyyy-MM-dd HH:mm:ss.fff\", System.Globalization.CultureInfo.InvariantCulture)\n\nmodule Async =\n    let map f va = \n        async { \n            let! a = va\n            return f a \n        } \n    let iter f va = \n        async { \n            let! a = va\n            do f a \n        } \n\n    let Return x = async.Return x\n\n    let apply fAsync xAsync = async {\n        let! fChild = Async.StartChild fAsync\n        let! xChild = Async.StartChild xAsync\n        let! f = fChild\n        let! x = xChild \n        return f x \n        }\n\n    let bind f va = async.Bind(va, f)\n    let sleepThen f milliseconds =\n        async {\n            do! Async.Sleep milliseconds\n            do  f()\n        }\n\nmodule KeyVal =\n    //let inline getEnumerator dict = (^a : (member get_Enumerator : _) (dict, ()))\n    let inline tryGetValue key (dict) =\n        dict \n        :> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<_, _>> \n        |> Seq.tryPick (fun kp -> if kp.Key = key then Some kp.Value else None)\n\n\nmodule String =\n    let splitByChar (c: char) (s: string) = s.Split c\n    let trim                  (s: string) = s.Trim()\n    let append     (a: string)(b: string) =  a + b\n    \n    ", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c7c27124-cfb8-4516-89ce-fb351d991fdb"}, "snpName": "XResult", "snpContent": "\ntype Message<'M> = \n    | Error     of string\n    | Warning   of string\n    | Message   of 'M\n    | Exception of System.Exception\n    with \n    override msg.ToString() =\n        match msg with\n        | Error     m -> m         |> sprintf \"Error    : %s\"\n        | Warning   m -> m         |> sprintf \"Warning  : %s\"\n        | Message   m -> m         |> sprintf \"%O\"\n        | Exception m -> m.Message |> sprintf \"Exception: %s\"\n\ntype XResult<'TValue, 'TMessage> = XResult  of 'TValue option * Message<'TMessage> []     \n\nmodule XResult =\n    let inline succeed                x     = XResult (Some x, [|  |])\n    let inline succeedWithMsg      m  x     = XResult (Some x, [|m |])\n    let inline succeedWithMsgs     ms x     = XResult (Some x,   ms  )\n    let inline fail                m        = XResult (None  , [|m |])\n    let inline failWithMsgs        ms       = XResult (None  ,   ms  )\n    let inline failException             e  = e |> Exception |> fail\n    let inline Return              x        = succeed x\n                                                                                    /// map without try protection\n    let inline map0      f (XResult(o, ms)) =       XResult(o |> Option.map f, ms)\n                                                                                    /// map with try protection in case of exceptions\n    let inline map       f (XResult(o, ms)) = try   XResult(o |> Option.map f, ms)\n                                              with  e -> failException e\n    let inline mapErr    f (XResult(o, ms)) = XResult (o                ,   ms |> Array.map f)\n    let inline mapMsg    f (XResult(o, ms)) = XResult (o                ,   ms |> Array.map f)\n    let inline mapMsgs   f (XResult(o, ms)) = XResult (o                ,   ms |>           f)\n    let inline getOption   (XResult(o, _ )) =         o                   \n    let inline getMsgs     (XResult(_, ms)) =                             ms\n    let inline mergeMsgs              ms r  = r |> mapMsgs   (Array.append ms)\n    let inline combine     (XResult(o, ms)) (rb: unit -> XResult<_,_>) = o |> Option.map (fun _ -> rb() |> mergeMsgs ms) |> Option.defaultValue (XResult(None, ms))\n    let inline join arr                     =\n        match arr with\n        | XResult(None                 , ms ) -> XResult(None, ms                  ) \n        | XResult(Some(XResult(b, ms1)), ms2) -> XResult(b   , Array.append ms2 ms1) \n                                                                                    /// bind with no try protection\n    let inline bind0     f  ar             = map0 f ar |> join \n                                                                                    /// bind with try protection in case of exceptions\n    let inline bind      f  ar             = map  f ar |> join \n                                                                                    /// apply with try protection in case of exceptions\n    let internal applyMap mapF (XResult(fO, fMs)) aR =\n        match fO with\n        | None   -> aR |> getMsgs |> Array.append fMs |> failWithMsgs\n        | Some f -> aR |> mapF f\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply0    fR aR = applyMap map0 fR aR\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply     fR aR = applyMap map  fR aR\n\n    let (|Success|Failure|) =\n        function \n        | XResult(Some x, ms) -> Success (x, ms) \n        | XResult(None  , ms) -> Failure     ms  \n\n//    let successTee f result =                           // given an RopResult, call a unit function on the success branch\n//        let fSuccess (x,msgs) =                         // and pass thru the result\n//            f (x,msgs)\n//            Success (x,msgs) \n//        either fSuccess Failure result\n//\n//    let fFailure2 f errs = \n//        f errs\n//        Failure errs \n//    let failureTee f result =                           /// given an RopResult, call a unit function on the failure branch\n//        either Success (fFailure2 f) result\n//\n//    let mapMessagesR f result =                         /// given an RopResult, map the messages to a different error type\n//        match result with \n//        | Success (x,msgs) -> \n//            let msgs' = List.map f msgs\n//            Success (x, msgs')\n//        | Failure errors -> \n//            let errors' = List.map f errors \n//            Failure errors' \n//\n//    let valueOrDefault f result =                       /// given an RopResult, in the success case, return the value.\n//        match result with                               /// In the failure case, determine the value to return by \n//        | Success (x,_) -> x                            /// applying a function to the errors in the failure case\n//        | Failure errors -> f errors\n//\n//    let failIfNone message = function                   /// lift an option to a RopResult.\n//        | Some x -> succeed x                           /// Return Success if Some\n//        | None -> fail message                          /// or the given message if None\n//\n//    let failIfNoneR message = function                  /// given an RopResult option, return it\n//        | Some rop -> rop                               /// or the given message if None\n//        | None -> fail message \n\n\n///            tryCall: (exn -> Result<'b>) ->  ('a -> Result<'b>) -> 'a -> Result<'b> =\n\n    type ropBuilder0() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member        this.Bind       (w , r )                  = bind0 r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = f()\n        member this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind0 (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n    /// computational expression without try protection\n    let xresult0 = ropBuilder0()\n\n    type ropBuilder() =\n        member inline this.Return     (x)                       = succeed x\n        member inline this.ReturnFrom (x)                       = x\n        member inline this.Bind       (w, r )                   = bind r w\n        member inline this.Zero       ()                        = succeed ()\n        member inline this.Delay      (f)                       = f\n        member inline this.Combine    (a, b)                    = combine a b\n        member inline this.Run        (f)                       = f()\n        member inline this.While(guard, body) =\n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member inline this.TryWith(body, handler) =\n            try this.ReturnFrom(body())\n            with e -> handler e\n        member inline this.TryFinally(body, compensation) =\n            try this.ReturnFrom(body())\n            finally compensation()\n        member inline this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member inline this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))              \n\n    /// computational expression with try protection\n    let xresult = ropBuilder()\n    \n//    let fromChoice context c =  context?????\n    let fromChoice c =\n        match c with | Choice1Of2 v -> succeed v\n                     | Choice2Of2 e -> fail    e\n\n    let fromOption m =\n        function | None   -> fail    m\n                 | Some v -> succeed v\n\n    let toOption   (XResult(o, _ )) = o\n    let toOptionMs (XResult(o, ms)) = o, ms\n\n    let tryProtection() = succeed ()\n\n    let failIfFalse m v = if v then succeed () else m |> fail \n    let failIfTrue  m v = if v then m |> fail  else succeed () \n            \n    let ifError   def (XResult(o, _ )) = o |> Option.defaultValue            def\n    let withError f   (XResult(o, ms)) = o |> Option.defaultWith  (fun () -> f ms)\n\n//    let processMessages mtype (msgs: PossibleMessages list) =\n//        msgs\n//        |> List.iter (fun o -> WebSharper.JavaScript.JS.Alert     <| mtype + \": \" + (sprintf \"%A\" o)\n//                               WebSharper.JavaScript.Console.Log o)\n//\n//    let notifyMessages R =\n//        match R with | Success (_, m) -> processMessages \"N\" m\n//                     | Failure     m  -> processMessages \"E\" m\n//\n//    let messagesDo f =\n//        function | Success (_, ms) -> f false ms\n//                 | Failure     ms  -> f true  ms\n\n    let seqCheck s = \n        s \n        |> (fun elems -> match      elems |> Seq.exists(function | Failure _    -> true    | _ -> false) with\n                         | true  -> elems |> Seq.pick  (function | Failure ms   -> Some ms | _ -> None ) |> failWithMsgs\n                         | false -> elems |> Seq.map   (function | XResult(vO,_)-> vO.Value            ) |> succeed\n        )\n\n    let msgs2String   (ms: Message<_> []) = ms |> Array.map (sprintf \"%O\")\n    let getMessages      (XResult(_, ms)) = ms |> msgs2String |> String.concat \"\\n\"\n//    let countMessages (ms: ErrMsg []) =\n//        if ms = [||] then \"\" else\n//        let errors   = ms |> Array.filter(fun m -> m.IsWarning |> not)\n//        let warnings = ms |> Array.filter(fun m -> m.IsWarning       )\n//        match errors.Length, warnings.Length with\n//        | 0, 0 -> sprintf \"%s\"\n//        | 1, 0 -> sprintf \"%s\"\n//        | 0, 1 -> sprintf \"%s\"\n//        | 1, 1 -> sprintf \"1 error, 1 warning\\n%s\"\n//        | e, 0 -> sprintf \"%d errors\\n%s\" e\n//        | 0, w -> sprintf \"%d warnings\\n%s\" w\n//        | e, w -> sprintf \"%d errors, %d warnings\\n%s\" e w\n//        <| getMessages ms\n\n    let result2String (XResult(vO, ms)) =\n        Array.append [| vO |> Option.defaultValue \"Failed: \" |] (Array.map (sprintf \"%A\") ms)\n        |> String.concat \"\\n\"\n\n[< AutoOpen >]\nmodule XResultAutoOpen =\n    let xresult = XResult.xresult\n", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [{"SnippetId" :"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e8de7075-496c-4b12-a801-91db57db3fa4"}, "snpName": "XAsync", "snpContent": "\ntype XAsync< 'T, 'M> = XAsync of Async<XResult< 'T, 'M>>\n\nmodule XAsync =\n    open XResult\n    \n    let inline Return v = succeed v |> Async.Return |> XAsync\n                                                                                    /// map with no try protection\n    let inline map0 f  (XAsync vRA ) = Async.map (XResult.map0 f) vRA |> XAsync\n                                                                                    /// map with try protection in case of exceptions\n    let inline map  f  (XAsync vRA ) = Async.map (XResult.map  f) vRA |> XAsync\n    let inline join    (XAsync vXRA) =\n        async {\n            let!  vXR = vXRA\n            match vXR with\n            | XResult(None            , ms) -> return XResult.failWithMsgs ms\n            | XResult(Some(XAsync vXA), ms) -> let!   vX = vXA\n                                               return vX                 |> XResult.mergeMsgs ms\n        } |> XAsync\n                                                                                    /// bind with no try protection \n    let inline bind0  f  vX = vX |> map0 f |> join\n                                                                                    /// bind with try protection in case of exceptions\n    let inline bind   f  vX = vX |> map  f |> join\n                                                                                    /// apply with no try protection\n    let inline apply0 fX vX = fX |> bind0 (swap map0 vX)\n                                                                                    /// apply with try protection in case of exceptions\n    let inline applyx fX vX = fX |> bind  (swap map  vX)\n\n                                                                                    /// apply with try protection in case of exceptions\n    let inline apply (XAsync fRA) (XAsync vRA) = \n        async {\n            let! fChild = Async.StartChild fRA\n            let! vChild = Async.StartChild vRA\n            let! fR     = fChild\n            let! vR     = vChild \n            return XResult.apply fR vR \n        } |> XAsync\n\n    let rec whileLoop guard body =\n        if guard() then body() |> bind0 (fun () -> whileLoop guard body)\n        else Return   ()\n\n//    let inline getAsyncR (wb: Wrap<'T>) =\n//        match wb with\n//        | WAsync      va  -> async {\n//                               let! v = va\n//                               return      succeed                           v}\n//        | WSome       v   -> async.Return (succeed                           v)\n//        | WNone           -> async.Return (Result.fail       errOptionIsNone  )\n//        | WResult     v   -> async.Return                                    v\n//        | WAsyncR     vra -> vra\n//        \n//        \n    let toAsyncResult (XAsync vRA) = vRA\n    let inline toAsyncWithDefault f x = toAsyncResult x |> Async.map (XResult.withError f)\n//    let inline getAsync              w = \n//\n    let toAsync            x = toAsyncWithDefault (fun ms -> ms |> Seq.map (sprintf \"%A\") |> String.concat \"\\n\" |> exn |> raise) x\n//    let toAsyncOption      w = getAsyncR w |> Async.map Result.toOption\n//    let toAsyncOptionMs    w = getAsyncR w |> Async.map Result.toOptionMs\n//    let toAsyncWithDefault w = getAsyncWithDefault w\n//\n////    let call wb = wb |> getR Rop.notifyMessages\n//    let startV (processVal: ('t option * string) ->unit) (w: Wrap<'t>) =\n//        w\n//        |> getAsyncR\n//        |> fun asy -> Async.StartWithContinuations\n//                        (asy \n//                       , Result.mapMsgs Result.getMessages  >> processVal\n//                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal\n//                       , sprintf \"%O\" >> (fun m -> None, m) >> processVal)\n//                       \n//    let start (printMsg: string->unit) (w: Wrap<unit>) = \n//        startV (function\n//                | Some (), msgs ->               msgs |> printMsg \n//                | None   , msgs -> \"Failed!\\n\" + msgs |> printMsg) w\n//\n//    let wrapper2Async (f: 'a -> Wrap<'b>) a : Async<Result<'b>> =\n//        let wb = tryCall f a\n//        match wb with\n//        | WNone                   \n//        | WSome   _               -> wb |> wb2arb [||]\n//        | WResult (Result(_, ms)) -> wb |> wb2arb ms\n//        | WAsync  ab              -> async { let!   b = ab\n//                                             return succeed b }\n//        | WAsyncR arb             -> arb\n//\n//    let addMsgs errOptionIsNone ms wb =\n//        if ms = [||] then wb else\n//        match wb with\n//        | WSome            v       -> WResult (succeedWithMsgs                        v ms)\n//        | WNone                    -> WResult (fail errOptionIsNone |> Result.mergeMsgs ms)\n//        | WResult r                -> WResult (r                    |> Result.mergeMsgs ms)\n//        | WAsync           va      -> async {\n//                                        let! v = va\n//                                        return succeedWithMsgs v ms\n//                                      } |> WAsyncR\n//        | WAsyncR          vra     -> async {\n//                                        let! vr = vra\n//                                        return vr                    |> Result.mergeMsgs ms\n//                                      } |> WAsyncR\n//\n    let inline combine (XAsync vRA ) (wX: unit -> XAsync<_, _>) =\n        async { \n            let!  vR = vRA\n            match vR with\n            | Failure    ms -> return failWithMsgs ms\n            | Success(_, ms)-> let!   wR = wX() |> toAsyncResult\n                               return wR        |> mergeMsgs ms\n        } |> XAsync\n        \n    type Builder() =\n        member inline this.Bind (wrapped: XAsync< 'v, 'M> , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped                                |> bind restOfCExpr \n        member inline this.Bind (wrapped: Async<  'v    > , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped |> Async.map succeed |> XAsync |> bind restOfCExpr  \n        member inline this.Bind (wrapped: XResult<'v, 'M> , restOfCExpr: 'v -> XAsync<'w, 'M>) = wrapped |> Async.Return      |> XAsync |> bind restOfCExpr \n        member inline this.Zero         ( ) = Return   ()\n        member inline this.Return       (x) = Return   x\n        member inline this.ReturnFrom   (w) = w\n        member inline this.Delay        (f) = f\n        member inline this.Run(f) = f()\n        member inline this.Combine   (a, b) = combine a b\n        member inline this.While(guard, body) = \n            let rec whileLoop guard body =\n                if guard() then body() |> bind (fun () -> whileLoop guard body)\n                else Return   ()\n            whileLoop guard body\n        member inline this.TryWith(body, handler) =\n            async {\n                let! r = body() |> toAsyncResult |> Async.Catch \n                return\n                    match r with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> handler e\n            } |> XAsync\n        member inline this.TryFinally(body, compensation) =\n            async {\n                let! r1 = body() |> toAsyncResult |> Async.Catch \n                let _r2 = compensation()     \n                return\n                    match r1 with\n                    | Choice1Of2 v -> v\n                    | Choice2Of2 e -> raise e\n            } |> XAsync\n        member inline this.Using(disposable:#System.IDisposable, body) =\n            let body' = fun () -> body disposable\n            this.TryFinally(body', fun () -> if disposable :> obj <> null then disposable.Dispose() )\n        member inline this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(),fun enum -> \n                this.While(enum.MoveNext, \n                    this.Delay(fun () -> body enum.Current)))            \n\n    let xasync = Builder()\n    \n//\n//    let getResult callback (wb: Wrap<'T>) =\n//        match wb with\n//        | WSome        s  -> s               |> succeed                                              |> callback\n//        | WNone           -> errOptionIsNone |> fail                                                 |> callback\n//        | WResult      rb -> rb                                                                      |> callback\n//        | WAsync       ab -> Async.StartWithContinuations(ab , (fun v   -> succeed v                 |> callback), \n//                                                               (fun exc -> failException exc |> fail |> callback), \n//                                                                fun can -> failException can |> fail |> callback)\n//        | WAsyncR     arb -> Async.StartWithContinuations(arb,                                          callback , \n//                                                               (fun exc -> failException exc |> fail |> callback), \n//                                                                fun can -> failException can |> fail |> callback)\n//\n//\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronouslyR x =\n        x\n        |> toAsyncResult\n        |> Async.RunSynchronously\n#if WEBSHARPER\n    [< Inline \"console.log('runSynchronously should not be used in Javascript')\" >]                       \n#endif\n    let runSynchronously x =\n        x\n        |> toAsync\n        |> Async.RunSynchronously\n//    let runSynchronouslyO count (w: Wrap<_>) =\n//        w\n//        |> runSynchronouslyR\n//        |> (Result.mapMsgs (if count then Result.countMessages else Result.getMessages))\n//    let runSynchronouslyS count (w: Wrap<_>) =\n//        w\n//        |> runSynchronouslyO count\n//        |> function\n//           | Some r, msgs -> sprintf \"%O\\n%s\" r    msgs\n//           | None  , msgs -> sprintf \"Failed!\\n%s\" msgs\n//           \ntype XAsync<'T, 'M> with\n    static member Start           (w:XAsync<_,_>,           ?cancToken) = Async.Start           (XAsync.toAsync       w,                                ?cancellationToken= cancToken)\n    static member StartAsTask     (w:XAsync<_,_>, ?options, ?cancToken) = Async.StartAsTask     (XAsync.toAsync       w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n    static member StartAsTaskR    (w:XAsync<_,_>, ?options, ?cancToken) = Async.StartAsTask     (XAsync.toAsyncResult w, ?taskCreationOptions= options, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronouslyR should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronouslyR(w:XAsync<_,_>, ?timeout, ?cancToken) = Async.RunSynchronously(XAsync.toAsyncResult w, ?timeout            = timeout, ?cancellationToken= cancToken)\n#if WEBSHARPER\n    [< Inline \"console.log('RunSynchronously should not be used in Javascript')\" >]                       \n#endif\n    static member RunSynchronously( w:XAsync<_,_>, ?timeout, ?cancToken) = Async.RunSynchronously(XAsync.toAsync  w, ?timeout            = timeout, ?cancellationToken= cancToken)\n//\n\n[< AutoOpen >]\nmodule XAsyncAutoOpen =\n    let xasync = XAsync.xasync\n", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [{"SnippetId" :"414d2960-2447-4fef-9c37-b1b7098d8355"}, {"SnippetId" :"c7c27124-cfb8-4516-89ce-fb351d991fdb"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}, "snpName": "List traverse & sequence", "snpContent": "module List =\n    let cons head tail = head :: tail\n\n    module XAsync =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XAsync<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = XAsync.bind f v\n            let retn      = XAsync.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<XAsync>\" into a \"XAsync<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n        \n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using applicative style\n        /// ('a -> XAsync<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseA f list =\n            let (<*>)     = XAsync.apply\n            let retn      = XAsync.Return  \n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState \n        /// Transform a \"list<XAsync>\" into a \"XAsync<list>\"\n        /// and collect the results using bind.\n        let inline sequenceA x = traverseA id x\n    \n    module XResult =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> XResult<'b>) -> 'a list -> XResult<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = XResult.bind f v\n            let retn      = XResult.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<XResult>\" into a \"XResult<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map a Result producing function over a list to get a new Result \n        /// using applicative style\n        /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n        let rec traverseA f list =\n            let (<*>)     = XResult.apply\n            let retn      = XResult.Return\n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState\n        /// Transform a \"list<Result>\" into a \"Result<list>\" \n        /// and collect the results using apply.\n        let inline sequenceA x = traverseA id x\n    \n    module Async =\n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using monadic style\n        /// ('a -> Async<'b>) -> 'a list -> Async<'b list>\n        let rec traverseM f list =\n            let (>>=) v f = Async.bind f v\n            let retn      = Async.Return  \n            let initState = retn []\n            let folder head tail = f head >>= (fun h -> tail >>= (fun t -> retn (cons h t) ))\n            List.foldBack folder list initState \n        /// Transform a \"list<Async>\" into a \"Async<list>\"\n        /// and collect the results using bind.\n        let inline sequenceM x = traverseM id x\n    \n        /// Map an AsyncResult producing function over a list to get a new AsyncResult\n        /// using applicative style\n        /// ('a -> Async<'b>) -> 'a list -> XAsync<'b list>\n        let rec traverseA f list =\n            let (<*>)     = Async.apply\n            let retn      = Async.Return  \n            let initState = retn []\n            let folder head tail = retn cons <*> f head <*> tail\n            List.foldBack folder list initState \n        /// Transform a \"list<Async>\" into a \"Async<list>\"\n        /// and collect the results using bind.\n        let inline sequenceA x = traverseA id x\n    \n    ", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [{"SnippetId" :"e8de7075-496c-4b12-a801-91db57db3fa4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"a1c1eae6-9927-45aa-868e-93ac25ec764a"}, "snpName": "dprintfn, oprintfn, printoutfn", "snpContent": "let dprintfn       fmt = fmt |> Printf.ksprintf ignore //(fun s -> printfn \"%s\"  s)\nlet printoutfn out fmt = fmt |> Printf.ksprintf (fun s -> s + \"\\n\" |> out)\n//let printoutf  out fmt = Printf.kprintf                        out  fmt\nlet print    v = printfn \"%A\" v\nlet mapPrint v = print        v; v\n", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"cbde8669-d188-4274-b4ef-129dd359c6be"}, "snpName": "update Monad", "snpContent": "\ntype UpdateMonad<'TState, 'TUpdate, 'T> = UM of ('TState -> 'TUpdate * 'T)\n\nmodule UpdateM =\n    /// Represents an update monad - given a state, produce \n    /// value and an update that can be applied to the state\n    \n    let inline unit<    ^U when ^U:(static member Unit   : unit    -> ^U )> ()  = \n                               (^U:(static member Unit   : unit    -> ^U )  ()  ) \n    let inline combine< ^U when ^U:(static member Combine: ^U * ^U -> ^U )> a  b = \n                               (^U:(static member Combine: ^U * ^U -> ^U ) (a, b)) \n    let inline apply<'S,^U when ^U:(static member Apply  : 'S * ^U -> 'S )> s  a = \n                               (^U:(static member Apply  : ^S * ^U -> ^S ) (s, a)) \n\n    let inline (++) a b = combine a b\n\n    let inline rtn v = UM (fun _ -> (unit(),v))\n    let inline bind f (UM u1f) =  \n        UM (fun s -> \n          let (u1, x ) = u1f s\n          let (UM u2f) = f   x\n          let (u2, y ) = u2f (apply s u1)\n          (u1 ++ u2, y))\n\n    let inline map f m = bind (f >> rtn) m\n\n    type UpdateBuilder() = \n      member inline x.Return(v) : UpdateMonad<'S, 'U, 'T> = rtn v\n      member inline x.Bind(u, f) = bind f u\n      member inline x.Zero() = x.Return(())    \n      member inline x.Delay(f) = x.Bind(x.Zero(), f)\n      member inline x.Combine(c1, c2) = x.Bind(c1, fun () -> c2)\n      member inline x.ReturnFrom(m : UpdateMonad<'S, 'P, 'T>) = m\n      member inline x.Using(r,f) = UM(fun s -> use rr = r in let (UM g) = f rr in g s)\n      member inline x.For(sq:seq<'V>, f:'V -> UpdateMonad<'S, 'P, unit>) = \n        let rec loop (en:System.Collections.Generic.IEnumerator<_>) = \n          if en.MoveNext() then x.Bind(f en.Current, fun _ -> loop en)\n          else x.Zero()\n        x.Using(sq.GetEnumerator(), loop)\n      member inline x.While(t, f:unit -> UpdateMonad<'S, 'P, unit>) =\n        let rec loop () = if t() then x.Bind(f(), loop)\n                                 else x.Zero()\n        loop()\n\n    type ReaderUpdate = \n      | NoUpdate\n      static member inline Unit()                      = NoUpdate\n      static member inline Combine(NoUpdate, NoUpdate) = NoUpdate\n      static member inline Apply(s, NoUpdate)          = s\n\n    let inline read()           = UM (fun s -> NoUpdate, s)\n    let inline readRun s (UM f) = f s |> snd\n\n    /// Updates of writer monad form a list\n    type WriterUpdate< ^TLog> = \n      | Log of list< ^TLog>\n      static member inline Unit()                = Log []\n      static member inline Combine(Log a, Log b) = Log(List.append a b)    /// Combines two logs (operation of the monoid)\n      static member inline Apply((), _)          = ()                      /// Applying updates to state does not affect the state\n    \n    let inline write  v = UM (fun s -> (Log [v], ()))                      /// Writes the specified value to the log \n    let inline writeRun (UM f) = match f () with (Log l, v) -> l, v\n\n    /// Wraps a state of type 'T\n    type StateState<'T> = State of 'T\n    \n    /// Represents updates on state of type 'T\n    type StateUpdate<'T> = \n      | SetNop\n      | Set of 'T \n      static member inline Unit()        = SetNop\n      static member inline Combine(a, b) = match b with | Set _ -> b       | _ -> a\n      static member inline Apply  (c, p) = match p with | Set n -> State n | _ -> c \n\n    let inline set    s        = UM (fun _         -> (Set s ,()) )\n    let inline get   ()        = UM (fun (State s) -> (SetNop, s) )\n    let inline setRun s (UM f) = f (State s) |> snd      \n\n    type ReaderWriterUpdate< ^TLog> = \n      | Log of list< ^TLog>\n      static member inline Unit   ()             = Log []\n      static member inline Combine(Log a, Log b) = Log(List.append a b)\n      static member inline Apply  (s, Log _)     = s\n\n    let inline readRW       ()       = UM (fun s -> Log [ ], s)\n    let inline writeRW      v        = UM (fun s -> Log [v], s)\n    let inline readWriteRun s (UM f) = match f s with (Log l, v) -> l, v\n\n[< AutoOpen >]\nmodule UpdateMBuilder =\n    /// Instance of the computation builder\n    /// that defines the update { .. } block\n    let update = UpdateM.UpdateBuilder()      \n          \n          ", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"86c4e893-d144-41b0-bd3e-4934423ff808"}, "snpName": "imperative", "snpContent": "type ImperativeResult<'T> = \n  | ImpValue of 'T\n  | ImpJump  of int * bool\n  | ImpNone \n  \ntype Imperative<'T> = unit -> ImperativeResult<'T>\n\ntype ImperativeBuilder() = \n  member x.Return (v)     :  Imperative<_>                 = (fun () -> ImpValue v)\n  member x.Zero   ()                                       = (fun () -> ImpNone   )\n  member x.Delay  (f:unit -> Imperative<_>)                = (fun () -> f()()     )\n  member x.Combine(a, b)                                   = (fun () -> match a() with \n                                                                        | ImpNone -> b()\n                                                                        | res     -> res\n                                                              )\n  member x.CombineLoop(a, b)                               = (fun () -> match a() with \n                                                                        | ImpValue v         -> ImpValue v\n                                                                        | ImpJump( 0, false) -> ImpNone\n                                                                        | ImpJump( 0, true )\n                                                                        | ImpNone            -> b() \n                                                                        | ImpJump(depth, b)  -> ImpJump(depth - 1, b)\n                                                             )\n  member x.Run    (imp)                                    = match imp() with \n                                                             | ImpValue v                       -> v\n                                                             | ImpJump  _                       -> failwith \"invalid use of break/continue outside a loop!\"\n                                                             | _ when typeof<'T> = typeof<unit> -> Unchecked.defaultof<'T>\n                                                             | ImpNone                          -> failwith \"nothing returned!\"\n  member x.For    (inp:seq<_>, f)                          = let rec loop(en:System.Collections.Generic.IEnumerator<_>) = \n                                                               if not(en.MoveNext()) then x.Zero() else\n                                                                 x.CombineLoop(f(en.Current), x.Delay(fun () -> loop(en)))\n                                                             loop(inp.GetEnumerator())\n  member x.While  (gd, body)                               = let rec loop() =\n                                                               if not(gd()) then x.Zero() else\n                                                                 x.CombineLoop(body, x.Delay(fun () -> loop()))\n                                                             loop()\n  member x.Bind(v:Imperative<unit>, f:unit->Imperative<_>) = (fun () -> match v() with\n                                                                        | ImpJump(depth, kind) -> ImpJump(depth, kind)\n                                                                        | _ -> f()() \n                                                             )\nlet imperative  = new ImperativeBuilder()\nlet break'      = (fun () -> ImpJump(0, false))\nlet continue'   = (fun () -> ImpJump(0, true ))\nlet breakn    n = (fun () -> ImpJump(n, false))\nlet continuen n = (fun () -> ImpJump(n, true ))", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"895519c3-573d-4f22-a320-192c99fd8105"}, "snpName": "treeZiper", "snpContent": "", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"6674933a-4097-4b6c-83ea-074828955729"}, "snpName": "unindent, unindentStr, indent", "snpContent": "let unindent (s:string) =\n    let lines = s.Split '\\n'\n    let n     = lines.[1] |> Seq.tryFindIndex ((<>) ' ') |> Option.defaultValue 0\n    lines \n    |> Seq.map (fun l -> l.Substring n)\n    |> Seq.filter (fun s -> s.StartsWith \"# 1 \" |> not)\n\nlet unindentStr = unindent >> String.concat \"\\n\"\n\nlet indent n (s:string) =\n    s.Split '\\n'\n    |> Seq.map ((+) (String.replicate n \" \"))", "snpParentIdO": {"SnippetId" :"46b53936-0e96-4e86-a196-9b76399a1d68"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpName": "Tests", "snpContent": "#r @\"..\\packages\\Unquote\\lib\\net45\\Unquote.dll\"\nmodule Tests =", "snpParentIdO": {"SnippetId" :"e83d0347-89ba-4fbf-8bd0-02723299e948"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2795dea6-7cd5-43f6-b530-fe56935a3964"}, "snpName": "TapRunner", "snpContent": "#r @\"..\\packages\\NUnit\\lib\\nunit.framework.dll\"\n/// Test Anything Protocol (TAP) NUnit runner by Phillip Trelford\nmodule Tap =\n\n    open System\n    open System.Collections\n    open System.Reflection\n    open NUnit.Framework\n    \n    type Args = obj[]\n    type ExpectedResult = obj option\n    type ExpectedException = Type option\n    type Timeout = int option\n    type Test = Test of MethodInfo * Args * ExpectedResult * ExpectedException * Timeout\n    \n    let internal getCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (mi:MethodInfo) = \n       mi.GetCustomAttribute(typeof<'TAttribute>, true) :?> 'TAttribute\n    \n    module internal SourceData =\n    \n       let (|SourceProperty|_|) (name,t:Type) =\n          let pi = t.GetProperty(name)\n          if pi <> null then Some(pi.GetGetMethod()) else None\n    \n       let (|SourceMethod|_|) (name,t:Type) =\n          let mi = t.GetMethod(name)\n          if mi <> null then Some(mi) else None\n    \n       let getSourceData (instance:obj, instanceType) (sourceName,sourceType:Type) =\n          match (sourceName,sourceType) with\n          | SourceProperty mi | SourceMethod mi->\n             let instance = \n                if instanceType <> sourceType \n                then Activator.CreateInstance(sourceType) \n                else instance\n             let result = mi.Invoke(instance, [||]) \n             result :?> IEnumerable\n          | _ -> invalidOp \"Expecting property or method\"\n    \n    module internal ParameterData =\n    \n       open SourceData\n    \n       module internal List =\n          let rec combinations = function\n          | [] -> [[]]\n          | hs :: tss ->\n             [for h in hs do\n                for ts in combinations tss ->\n                   h :: ts]\n    \n       let tryGetCustomAttribute<'TAttribute when 'TAttribute :> Attribute> (pi:ParameterInfo) =\n          match pi.GetCustomAttribute(typeof<'TAttribute>, true) with\n          | :? 'TAttribute as attr -> Some attr\n          | _ -> None\n    \n       let (|Random|_|) = tryGetCustomAttribute<RandomAttribute>\n       let (|Range|_|) = tryGetCustomAttribute<RangeAttribute>\n       let (|Values|_|) = tryGetCustomAttribute<ValuesAttribute>\n       let (|ValueSource|_|) = tryGetCustomAttribute<ValueSourceAttribute>\n    \n       let getParameterData instance (pi:ParameterInfo) =\n          match pi with\n          | Random rand -> [for x in rand.GetData(pi) -> x]\n          | Range range -> [for x in range.GetData(pi) -> x]\n          | Values values -> [for x in values.GetData(pi) -> x]\n          | ValueSource source ->\n             let data = getSourceData instance (source.SourceName, source.SourceType)\n             [for x in data -> x]\n          | _ -> invalidOp \"Expecting values\"\n    \n    module internal TestGeneration =\n    \n       open SourceData\n       open ParameterData\n    \n       let (|Ignore|_|) (mi:MethodInfo) =\n          if getCustomAttribute<IgnoreAttribute>(mi) <> null then Some() else None\n    \n       let (|TestCases|_|) (mi:MethodInfo) =\n          let cases = mi.GetCustomAttributes(typeof<TestCaseAttribute>, true)\n          if cases.Length > 0 then Some(cases |> Seq.cast<TestCaseAttribute>)\n          else None\n    \n       let (|TestCaseSource|_|) (mi:MethodInfo) =\n          let source = getCustomAttribute<TestCaseSourceAttribute>(mi)\n          if source <> null then\n             let sourceType = \n                if source.SourceType <> null then source.SourceType else mi.DeclaringType\n             Some(source.SourceName, sourceType)\n          else None\n    \n       let (|VanillaTest|_|) (mi:MethodInfo) =\n          if getCustomAttribute<TestAttribute>(mi) <> null then Some() else None\n    \n       let tryGetExpectedException (mi:MethodInfo) =\n          let attr = getCustomAttribute<ExpectedExceptionAttribute>(mi)\n          if attr <> null then Some attr.ExpectedException else None\n    \n       let (|Timeout|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<TimeoutAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"Timeout\"] :?> int) else None\n    \n       let (|MaxTime|_|) (mi:MethodInfo) =\n          let attr = getCustomAttribute<MaxTimeAttribute>(mi)\n          if attr <> null then Some (attr.Properties.[\"MaxTime\"] :?> int) else None\n    \n       let tryGetTimeout = function Timeout ms | MaxTime ms -> Some ms | _ -> None\n      \n       let fromCases (mi:MethodInfo) (cases:TestCaseAttribute seq) =\n          let ex = tryGetExpectedException(mi)\n          let timeout = tryGetTimeout mi\n          [|for case in cases ->\n             let expected = if case.HasExpectedResult then Some case.ExpectedResult else None\n             let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n             Test(mi, case.Arguments, expected, ex, timeout)\n          |]\n    \n       let fromData instance (mi:MethodInfo) (data:IEnumerable) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [|for item in data ->\n             match item with\n             | :? TestCaseData as case ->\n                let expected = if case.HasExpectedResult then Some(case.Result) else None\n                let ex = if case.ExpectedException <> null then Some(case.ExpectedException) else ex\n                Test(mi, case.Arguments, expected, ex, timeout) \n             | :? (obj[]) as args -> Test(mi, args, None, ex, timeout)\n             | arg -> Test(mi, [|arg|], None, ex, timeout)\n          |]\n    \n       let fromValues instance (mi:MethodInfo) =\n          let ex = tryGetExpectedException mi\n          let timeout = tryGetTimeout mi\n          [| let ps = mi.GetParameters()\n             let argValues = [for pi in ps -> getParameterData instance pi]\n             match List.combinations argValues with\n             | [] -> yield Test(mi, [||], None, ex, timeout)\n             | xs -> yield! [for args in xs -> Test(mi, List.toArray args, None, ex, timeout)]\n          |]\n    \n       let generateTests instance (mi:MethodInfo) =\n          let instance = instance, mi.DeclaringType\n          match mi with\n          | Ignore -> [||]\n          | TestCases cases -> fromCases mi cases\n          | TestCaseSource source -> getSourceData instance source |> fromData instance mi\n          | VanillaTest -> fromValues instance mi\n          | _ -> [||]\n    \n    module internal TestRunner =\n    \n       let runTest instance (Test(mi,args,expected,exType,timeout)) = \n          try\n             let actual = \n                match timeout with\n                | Some ms -> Async.RunSynchronously(async { return mi.Invoke(instance,args) }, ms)\n                | None -> mi.Invoke(instance,args)\n             match expected with\n             | Some expected -> Assert.AreEqual(expected, actual)\n             | None -> ()\n             None\n          with ex ->        \n            match ex.InnerException with\n            | :? SuccessException -> None\n            | ex ->\n                match exType with         \n                | Some t when t = ex.GetType() -> None\n                | _ -> Some ex\n    \n       let color c =\n          let previous = Console.ForegroundColor\n          Console.ForegroundColor <- c\n          { new System.IDisposable with \n             member __.Dispose() = Console.ForegroundColor <- previous\n          }\n    \n       let showResult number (Test(mi,args,_,_,_)) error =\n          let name =\n             mi.Name + \n                if args.Length > 0 then \"(\" + String.Join(\",\", args) + \")\"\n                else \"\"\n          match error with\n          | None ->\n             using (color ConsoleColor.Green) <| fun _ ->\n                printfn \"ok %d - %s\" number name\n          | Some e ->\n             using (color ConsoleColor.Red) <| fun _ ->\n                printfn \"not ok %d - %s\" number name\n                printfn \"  %A\" e\n    \n       let runTests instance (setUp,tearDown) (tests:Test[]) =\n          printfn \"1..%d\" tests.Length\n          tests |> Array.iteri (fun i test ->\n             let result =\n                try setUp (); runTest instance test\n                finally tearDown ()\n             result |> showResult (i+1) test \n          )\n    \n    let Run (testType:Type) =\n       let constr = testType.GetConstructor([||])\n       let instance = if constr <> null then constr.Invoke([||]) else null\n       let methods = testType.GetMethods()\n       let tests = [|for mi in methods do yield! TestGeneration.generateTests instance mi|]\n      \n       let methodsWithAttribute attr =\n          methods |> Array.filter (fun mi -> mi.GetCustomAttribute(attr, true) <> null)\n    \n       let runMethods (methods:MethodInfo[]) = \n          methods |> Array.iter (fun mi -> mi.Invoke(instance,[||]) |> ignore)\n    \n       let setUps = methodsWithAttribute typeof<SetUpAttribute>\n       let tearDowns = methodsWithAttribute typeof<SetUpAttribute>\n       let setUp () = setUps |> runMethods\n       let tearDown () = tearDowns |> runMethods\n    \n       methodsWithAttribute typeof<TestFixtureSetUpAttribute> |> runMethods\n       TestRunner.runTests instance (setUp, tearDown) tests\n       methodsWithAttribute typeof<TestFixtureTearDownAttribute> |> runMethods", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}, "snpName": "code for Testing", "snpContent": "open NUnit.Framework\nopen Swensen.Unquote\n\n\nlet stdout = System.Text.StringBuilder()\nlet out (s:string) = stdout.Append s |> ignore\nlet runStdOutCall func parm =\n    stdout.Clear() |> ignore\n    func parm, stdout.ToString()\n\nlet runStdOut f =\n    runStdOutCall f ()\n    |> snd\n    \ntype Marker = interface end    \n\n", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"2795dea6-7cd5-43f6-b530-fe56935a3964"}, {"SnippetId" :"73ddcc57-6d46-4f49-b4f3-e397aa3d3963"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"e8866bb4-926b-4330-a0ab-051f89661640"}, "snpName": "XResult", "snpContent": "open Useful\n\nlet asyncIf () =\n    async {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet resultIf () =\n    xresult {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"wrap \"\n        let! h =  async { printoutfn out \"Hello1 %d\" i } \n        return i + 1\n    }\n    \nlet whileR() = \n    let mutable i = 0\n    xresult {\n        let! a = XResult.succeed 2\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Async.RunSynchronously |> XResult.succeed\n            i <- z\n            printoutfn out \" z = %d\" z\n    } |> ignore\n\n\n    \nlet helloA i =\n    printoutfn out \"before \"\n    async {\n        printoutfn out \"async \"\n        do! async { printoutfn out \"HelloA %d\" i }\n        return i + 1\n    }\n\nlet whileA() = \n    let mutable i = 0\n    async {\n        let! a = async { return 2 }\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello i \n            i <- z\n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet forR() = \n    xresult {\n        let! a = XResult.succeed 2\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i |> Async.RunSynchronously |> XResult.succeed\n            printoutfn out \" z = %d\" z\n    } |> ignore\n    \nlet forA() = \n    async {\n        let! a = async { return 2 }\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i \n            printoutfn out \" z = %d\" z\n        ()\n    } |> Async.RunSynchronously\n\nlet [<Test>] ``whileA  must be diffrt. than \"\"`` () = runStdOut whileA  <>! \"\"     \nlet [<Test>] ``whileR  must be equal to whileA`` () = runStdOut whileR   =! runStdOut whileA     \nlet [<Test>] ``forR    must be equal to forA``   () = runStdOut forR     =! runStdOut forA     \n   ", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"a1c1eae6-9927-45aa-868e-93ac25ec764a"}, {"SnippetId" :"c7c27124-cfb8-4516-89ce-fb351d991fdb"}, {"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"fc2c1396-c30c-487e-a16d-62bdea734490"}, "snpName": "XAsync", "snpContent": "let xasyncIf () =\n    xasync {\n        let a = 1\n        if a = 1 then\n            let r = 3\n            ()\n        ()\n    }\n\nlet hello2 i =\n    printoutfn out \"before \"\n    xasync {\n        printoutfn out \"wrap \"\n        let hA  =  async { printoutfn out \"Hello1 %d\" i } \n        let! h  =  hA\n        return i + 1\n    }\n\nlet helllo i =\n    xasync {\n        let h = hello i\n        return! h\n    }\n\nlet helo i =\n    xasync {\n        do! xasync { return () }\n        return i\n    }\n\nlet whileW() = \n    let mutable i = 0\n    xasync {\n        let! aR  = async { return XResult.succeed 2 } \n        let! a = aR\n        while (printoutfn out \"<%d>\" i ; i <= a) do\n            printoutfn out \"%d: \" i\n            let! z = hello2 i\n            i <- z\n            printoutfn out \" z = %d\" z\n        return! XAsync.Return   ()\n    } |> XAsync.runSynchronously\n\nlet whileWW() =\n    let mutable i = 0\n    let aAR = async { return XResult.succeed 2 }\n    aAR |> Async.map XResult.succeed |> XAsync |> XAsync.bind (fun aR ->\n        aR |> Async.Return |> XAsync |> XAsync.bind (fun a ->\n            let pred () = printoutfn out \"<%d>\" i ; i <= a \n            let body = fun () ->\n                printoutfn out \"%d: \" i\n                let zW = hello i\n                zW |> Async.map XResult.succeed |> XAsync |> XAsync.bind (fun z ->\n                    i <- z\n                    printoutfn out \" z = %d\" i\n                    XAsync.Return   ()\n                )\n            let r = XAsync.whileLoop pred body\n            r\n        )\n    ) |> XAsync.runSynchronously\n    \n    \nlet forW() = \n    xasync {\n        let! aR = async { return XResult.succeed 2 }\n        let! a = aR\n        for i = 0 to a do\n            printoutfn out \"%d: \" i\n            let! z = hello i\n            printoutfn out \" z = %d\" z\n        return! XAsync.Return   ()\n    } |> XAsync.runSynchronously\n    \nlet [<Test>] ``whileWW must be equal to whileA`` () = runStdOut whileWW  =! runStdOut whileA \nlet [<Test>] ``whileW  must be equal to whileA`` () = runStdOut whileW   =! runStdOut whileA \nlet [<Test>] ``forW    must be equal to forA``   () = runStdOut forW     =! runStdOut forA\n\n   ", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"e8866bb4-926b-4330-a0ab-051f89661640"}, {"SnippetId" :"e8de7075-496c-4b12-a801-91db57db3fa4"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ad8af4ea-2ff7-4b3c-ab63-4364625732d7"}, "snpName": "update Monad", "snpContent": "open Useful\n\nlet inline (|>>) a f = a |> UpdateM.map  f \nlet inline (>>=) m f = m |> UpdateM.bind f \nlet inline (>=>) g f = g >> UpdateM.bind f\nlet inline tee   g f v = g v |>> (fun _ -> f v)\nlet inline (>->) g f = tee g f\n\n/// Returns state + 1\nlet demo1 = update { \n    let! v = UpdateM.read()\n    return v + 1\n}\n  \n/// Returns the result of demo1 + 1\nlet demo2 = update { \n    let! v = demo1\n    return v + 1 |> sprintf \"value = %d\"\n}\n\n// Run it with state     40 \nlet res2 = demo2 |> UpdateM.readRun 40\n\nlet greeter         = UpdateM.read() |> UpdateM.map (fun  n         -> \"hello, \" + n + \"!\")\nlet calc (s:string) = UpdateM.read() |> UpdateM.map (fun (n:string) -> s.Length - n.Length)\nlet resr            = (greeter >>= calc) |> UpdateM.readRun \"leon\"\n\nmodule Reader =    // another implementation taken from https://gist.github.com/leon737/6056653\n    type Reader<'v> = Reader of 'v\n    let Return v = Reader v\n    let runReader mx d = match mx with | Reader v -> v d\n    let Bind      mx f = match mx with | Reader v -> Reader (fun z -> (v z) |> f |> runReader <| z)\n    let (>>=)          = Bind\n    \n    let greeter         = Return (fun n          -> \"hello, \" + n + \"!\") \n    let calc (s:string) = Return (fun (n:string) -> s.Length - n.Length)\n    let configOrGlobalStateOrEnvironment = \"leon\"\n    let resr = runReader (greeter >>= calc) configOrGlobalStateOrEnvironment\n\n/// Writes '20' to the log and returns \"world\"\nlet demo3 = update {\n    do! UpdateM.write 20\n    return \"world\" \n}\n  \n/// Calls 'demo3' and then writes 10 to the log\nlet demo4 = update {\n    do! UpdateM.write 30\n    let! w = demo3\n    do! UpdateM.write 10\n    return \"Hello \" + w \n}\n\n/// Returns \"Hello world\" with 20 and 10 in the log\nlet res4 = demo4 |> UpdateM.writeRun\n\nlet        half         x   = x / 2\nlet inline half_        x _ = half x\nlet        halfMessage  x   = sprintf \"I just halved %d ! \" x\nlet inline halfMessageW x   = halfMessage x |> UpdateM.write\n\nlet half1 x =  update  {\n    do!    halfMessageW x\n    return half         x\n}\nlet resw1   = half1 8 >>= half1 |> UpdateM.writeRun\n\nlet half2 x = halfMessageW x |>> half_ x\nlet quart2  = half2 >=> half2\nlet resw2   = quart2 8 |> UpdateM.writeRun\n\nmodule Writer =     // another implementation taken from https://gist.github.com/leon737/6056653\n    type Writer<'d, 'v> = Writer of 'd * 'v\n    let Tell d f = f [ d ]\n    let Return  v      = fun d ->      Writer(d,v)\n    let Join    d mx   = match mx with Writer(x,v) -> Writer(d @ x, v)\n    let Bind      mx f = match mx with Writer(d,v) -> f v |> Join d\n    let runWriter mx   = match mx with Writer(d,v) -> d,v\n    let (>>=) = Bind\n\n    let half      x = Tell ( sprintf \"I just halved %d ! \" x ) <| Return ( x / 2 )\n    let resw        = half 8 >>= half |> runWriter\n    \n/// Increments the state by one\nlet demo5 = update { \n  let! v = UpdateM.get()\n  do!      UpdateM.set (v + 1) \n}\n\n/// Call 'demo5' repeatedly in a loop\n/// and then return the final state\nlet demo6 = update {\n  for i in 1 .. 10 do \n    do! demo5\n  return! UpdateM.get()\n}\n\n// Run the sample with initial state 0\nlet res6 = demo6 |> UpdateM.setRun 0\n\ntype RWMonad<'a, 'S> = UpdateMonad<'S,UpdateM.ReaderWriterUpdate<string>,'a>\n\nlet halfRWf  = halfMessage      >>  UpdateM.writeRW >-> half  \nlet quartRWf = halfRWf          >=> halfRWf\nlet quartRW  = UpdateM.readRW() >>= quartRWf\nlet resRw    = quartRW          |>  UpdateM.readWriteRun 8\n\nlet resRw1a  =\n    UpdateM.readRW()\n    >>= halfRWf\n    >>= halfRWf\n    |>  UpdateM.readWriteRun 8\n\nlet halfRWf1 = tee (halfMessage >> UpdateM.writeRW) half\n\nlet resRw1b  =\n    UpdateM.readRW()\n    |> UpdateM.bind halfRWf1\n    |> UpdateM.bind halfRWf1\n    |> UpdateM.readWriteRun 8\n\nlet halfRWf2 x : RWMonad<_,_> = update {\n    let    v   = half        x\n    let    msg = halfMessage x\n    do!          UpdateM.writeRW msg |>> ignore\n    return v\n}\n\nlet halfRWf3 x : RWMonad<_,_> = update {\n    do!    UpdateM.writeRW (halfMessage x) |>> ignore\n    return half        x\n}\n\nlet halfRW : RWMonad<_,_> = update {\n    let! x = UpdateM.readRW()\n    return!  halfRWf2 x\n}\nlet quartRW2 : RWMonad<_,_> = update {\n    let! y = halfRW\n    return!  halfRWf2 y\n}\nlet quartRW3 : RWMonad<_,_> = halfRW >>= halfRWf2\nlet quartRWs : RWMonad<_,_> = quartRW2 |>> string\nlet resRw2    = quartRW2 |>  UpdateM.readWriteRun 8\n\nlet [<Test>] ``res2    must be equal to \"value = 42\"``           () = res2   =! \"value = 42\"\nlet [<Test>] ``resr    must be equal to Reader.resr (8)``        () = resr   =! Reader.resr\nlet [<Test>] ``res4    must be equal to ([20,10] \"Hello world\")``() = res4   =! ([30; 20; 10], \"Hello world\")\nlet [<Test>] ``resw1   must be equal to Writer.resw \"``          () = resw1  =! Writer.resw\nlet [<Test>] ``resw2   must be equal to Writer.resw \"``          () = resw2  =! Writer.resw\nlet [<Test>] ``res6    must be equal to 10``                     () = res6   =! 10\nlet [<Test>] ``resRw   must be equal to Writer.resw``            () = resRw  =! Writer.resw\nlet [<Test>] ``resRw2  must be equal to Writer.resw``            () = resRw2 =! Writer.resw\n\n ", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"cbde8669-d188-4274-b4ef-129dd359c6be"}, {"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"b9e34ae3-bbec-447c-9964-30284318d122"}, "snpName": "imperative", "snpContent": "open Useful\n\nlet test(b) = imperative {\n    if b then \n        return 0\n    printoutfn out \"after return!\"\n    return 1 \n}\n\nlet validateName(arg:string) = imperative {\n    if  arg     = null                                                     then return false\n    let idx     = arg.IndexOf(\" \")\n    if  idx     = -1                                                       then return false\n    let name    = arg.Substring(0, idx)\n    let surname = arg.Substring(idx + 1, arg.Length - idx - 1)\n    if  surname.Length < 1               || name.Length < 1                then return false\n    if  System.Char.IsLower(surname.[0]) || System.Char.IsLower(name.[0])  then return false\n    return true \n}\n\nlet readFirstName (stream: System.IO.StreamReader) = imperative {\n    while true do\n        let name = stream.ReadLine().Trim()\n        if (validateName(name)) then return name\n        printoutfn out \"That's not a valid name! Try again...\" \n}\n\nlet checkNames () =\n    \"\"\"calvin\n       Calvin and Hodges\n       Calvin Coolidge\n    \"\"\"\n    |> System.Text.Encoding.UTF8.GetBytes\n    |> (fun content -> new System.IO.MemoryStream(content))\n    |> swap using (fun stream -> \n         new System.IO.StreamReader(stream)\n         |> swap using readFirstName\n         |> printoutfn out \"%A\"\n    )\n\nlet exists f inp = imperative {\n    for v in inp do \n        if f(v) then return true\n    return false \n}\n\nlet checkFor3 () = [ 1 .. 10 ] |> exists (fun v -> v % 3 = 0)\n\nlet odds() = imperative { \n    for x in 1 .. 5 do \n        if (x % 2 = 0) then do! continue'\n        printoutfn out \"number = %d\" x \n}\n\nlet count3 () = imperative { \n    let x = ref 1\n    while true do\n      if (!x % 4 = 0) then do! break'\n      printoutfn out \"number = %d\" !x\n      x := !x + 1 \n}\n\nlet [<Test>] ``test true                     must be 0``               () = runStdOutCall test true       =! (0, \"\")\nlet [<Test>] ``test false                    must be 1``               () = runStdOutCall test false      =! (1, \"after return!\\n\")\nlet [<Test>] ``validateName null             must be false``           () = validateName null             =! false\nlet [<Test>] ``validateName \"Tomas\"          must be false``           () = validateName \"Tomas\"          =! false\nlet [<Test>] ``validateName \"Tomas Petricek\" must be true``            () = validateName \"Tomas Petricek\" =! true\nlet [<Test>] ``checkNames                    must be Calvin Coolidge`` () = runStdOut checkNames          =! \"That's not a valid name! Try again...\\nThat's not a valid name! Try again...\\n\\\"Calvin Coolidge\\\"\\n\"\nlet [<Test>] ``checkFor3                     must be true``            () = checkFor3()                   =! true\nlet [<Test>] ``odds                          must be 1 3 5``           () = runStdOut odds                =! \"number = 1\\nnumber = 3\\nnumber = 5\\n\"\nlet [<Test>] ``count3                        must be 1 2 3``           () = runStdOut count3              =! \"number = 1\\nnumber = 2\\nnumber = 3\\n\"\n", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"86c4e893-d144-41b0-bd3e-4934423ff808"}, {"SnippetId" :"a1c1eae6-9927-45aa-868e-93ac25ec764a"}, {"SnippetId" :"a7f4f5f0-13eb-40fd-afd9-c4521f505e2d"}, {"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"2c535c48-caf0-4422-adf0-76f80b0714c2"}, "snpName": "semigroup monoid", "snpContent": "\ntype SemigroupBuilder<'P, 'T>(map: 'P -> 'T, op: 'T->'T->'T) =\n    member inline __.Yield     (v      :'P) : 'T = map v\n    member inline __.YieldFrom (vs     :'T) : 'T = vs\n    member inline __.Combine   (a:'T, b:'T) : 'T = op a b\n    member inline __.Delay      df               = df()\nlet inline semigroup (map, op, _) = SemigroupBuilder(map, op)\n\nlet concatStr (a:string) b = a + b\n\nlet defAdd    = id            , (+)        , 0  \nlet defProd   = id            , (*)        , 1  \nlet defString = string        , concatStr  , \"\"        \nlet defList   = List.singleton, List.append, []         \n\nsemigroup defAdd {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defProd {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defString {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\nsemigroup defList {\n    yield 7\n    yield 12\n} |> printfn \"%A\"\n\ntype MonoidBuilder<'P, 'T>(map, op, zero: 'T) =\n    inherit SemigroupBuilder<'P, 'T>(map, op)\n    member inline __.Zero()       = zero\nlet inline monoid (map, op, zero) = MonoidBuilder(map, op, zero)\n\nmonoid defAdd {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defProd {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defString {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nmonoid defList {\n    if false then\n        yield 7\n        yield 12\n} |> printfn \"%A\"\n\nlet rec range (mon:MonoidBuilder<_,_>) n = mon { \n    yield n\n    if n < 100 then yield! range mon (n + 1) \n} \n\nrange (monoid defAdd   ) 97 |> printfn \"%A\"\nrange (monoid defProd  ) 97 |> printfn \"%A\"\nrange (monoid defString) 97 |> printfn \"%A\"\nrange (monoid defList  ) 97 |> printfn \"%A\"\n\n//let [<Test>] ``test true                     must be 0``               () = runStdOutCall test true       =! (0, \"\")\n", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"ddb549cd-9ddc-4a2b-9d6a-6e02ed8a86c9"}, "snpName": "Run tests", "snpContent": "// You can select which test to run just by making them predecessors of this snippet\n\nTap.Run typeof<Marker>.DeclaringType    // run tests in module\n\n", "snpParentIdO": {"SnippetId" :"9ca8f090-0191-4e47-96ee-a3b4785c45e2"}, "snpPredIds": [{"SnippetId" :"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}, {"SnippetId" :"b9e34ae3-bbec-447c-9964-30284318d122"}, {"SnippetId" :"ee67a428-8d29-4f66-96f0-e0d94d85698b"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"f3d0eaa1-b96a-41d1-83a2-19a84001e217"}, "snpName": "Snippets", "snpContent": "module Snippets =", "snpParentIdO": {"SnippetId" :"e83d0347-89ba-4fbf-8bd0-02723299e948"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c5930fca-5baf-4b35-9193-18c08fafae39"}, "snpName": "fsharpforfunandprofit", "snpContent": "", "snpParentIdO": {"SnippetId" :"f3d0eaa1-b96a-41d1-83a2-19a84001e217"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7fbfd6ae-e6b6-4182-9c5a-09e5b549cf0e"}, "snpName": "Sequence XAsync", "snpContent": "open Useful\n\n/// Do countN repetitions of the function f and print the time per run\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n    \n    // do a full GC at the start but not thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n\n    printfn \"=======================\"         \n    printfn \"%s\" label \n    printfn \"=======================\"         \n    \n    let mutable totalMs = 0L\n\n    for iteration in [1..countN] do\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        printfn \"#%2i elapsed:%6ims \" iteration stopwatch.ElapsedMilliseconds \n        totalMs <- totalMs + stopwatch.ElapsedMilliseconds\n\n    let avgTimePerRun = totalMs / int64 countN\n    sprintf \"%s: Average time per run:%6ims \" label avgTimePerRun \n    \nlet goodSites = [\n    \"http://google.com\"\n    \"http://bbc.co.uk\"\n    \"http://fsharp.org\"\n    \"http://microsoft.com\"\n    ]\n\nlet badSites = [\n    \"http://bad.example.com\"\n    \"http://verybad.example.com\"\n    \"http://example.com/nopage\"\n    \"http://veryverybad.example.com\"\n    ]\n\n// define a millisecond Unit of Measure\ntype [<Measure>] ms\n\n/// Custom implementation of WebClient with settable timeout\ntype WebClientWithTimeout(timeout:int<ms>) =\n    inherit System.Net.WebClient()\n\n    override this.GetWebRequest(address) =\n        let result = base.GetWebRequest(address)\n        result.Timeout <- int timeout \n        result\n\n// The content of a downloaded page \ntype UriContent = \n    UriContent of System.Uri * string\n\n// The content size of a downloaded page \ntype UriContentSize = \n    UriContentSize of System.Uri * int\n    \n/// Get the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContent>>\nlet getUriContent (uri:System.Uri) = \n    async {\n        use client = new WebClientWithTimeout(1000<ms>) // 1 sec timeout\n        try\n            printfn \" [%s] Started ...\" uri.Host\n            let! html = client.AsyncDownloadString(uri) \n            printfn \" [%s] ... finished\" uri.Host\n            let uriContent = UriContent (uri, html)\n            return uriContent |> XResult.succeedWithMsg (Message <| sprintf \" [%s] ... Loaded!\" uri.Host)\n        with\n        | ex -> \n            printfn \" [%s] ... exception\" uri.Host\n            let err = sprintf \"[%s] %A\" uri.Host ex.Message |> Error\n            return XResult.fail err\n    } |> XAsync\n\n/// Make a UriContentSize from a UriContent\n/// UriContent -> Result<UriContentSize>\nlet makeContentSize (UriContent (uri, html)) = \n    if System.String.IsNullOrEmpty(html) then\n        XResult.fail (Error \"empty page\")\n    else\n        let uriContentSize = UriContentSize (uri, html.Length)\n        XResult.succeed uriContentSize \n\n/// Get the size of the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContentSize>>\nlet getUriContentSize uri =\n    getUriContent uri \n    |> XAsync.bind (makeContentSize >> Async.Return >> XAsync)\n\n/// Get the largest UriContentSize from a list\n/// UriContentSize list -> UriContentSize\nlet maxContentSize list = \n    let contentSize (UriContentSize (_, len)) = len  // extract the len field from a UriContentSize \n    list |> List.maxBy contentSize                   // use maxBy to find the largest  \n\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.XAsync.sequenceA\n    |> XAsync.map maxContentSize\n\nlet largestPageSizeM urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.XAsync.sequenceM\n    |> XAsync.map maxContentSize\n\nlet showContentSizeResult result =\n    let messages = result |> XResult.getMessages\n    match result with\n    | XResult.Success (UriContentSize (uri, len), _) -> printfn \"SUCCESS: [%s] Content size is %i \\n%s\" uri.Host len messages\n    | XResult.Failure errs            -> printfn \"FAILURE: %s\" messages\n\nlet run f sites () = \n    f sites\n    |> XAsync.runSynchronouslyR\n    |> showContentSizeResult \n\n[\n    time 1 \"largestPageSizeA_Good\" <| run largestPageSizeA goodSites\n    time 1 \"largestPageSizeA_Bad \" <| run largestPageSizeA badSites\n    time 1 \"largestPageSizeM_Good\" <| run largestPageSizeM goodSites\n    time 1 \"largestPageSizeM_Bad \" <| run largestPageSizeM badSites\n] \n|> String.concat \"\\n\" \n|> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"c5930fca-5baf-4b35-9193-18c08fafae39"}, "snpPredIds": [{"SnippetId" :"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"8c857791-9ed8-4970-abbb-172bbd126089"}, "snpName": "Sequence Async XResult", "snpContent": "open Useful\n\n/// Do countN repetitions of the function f and print the time per run\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n    \n    // do a full GC at the start but not thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n\n    printfn \"=======================\"         \n    printfn \"%s\" label \n    printfn \"=======================\"         \n    \n    let mutable totalMs = 0L\n\n    for iteration in [1..countN] do\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        printfn \"#%2i elapsed:%6ims \" iteration stopwatch.ElapsedMilliseconds \n        totalMs <- totalMs + stopwatch.ElapsedMilliseconds\n\n    let avgTimePerRun = totalMs / int64 countN\n    sprintf \"%s: Average time per run:%6ims \" label avgTimePerRun \n    \nlet goodSites = [\n    \"http://google.com\"\n    \"http://bbc.co.uk\"\n    \"http://fsharp.org\"\n    \"http://microsoft.com\"\n    ]\n\nlet badSites = [\n    \"http://example.com/nopage\"\n    \"http://bad.example.com\"\n    \"http://verybad.example.com\"\n    \"http://veryverybad.example.com\"\n    ]\n\n// define a millisecond Unit of Measure\ntype [<Measure>] ms\n\n/// Custom implementation of WebClient with settable timeout\ntype WebClientWithTimeout(timeout:int<ms>) =\n    inherit System.Net.WebClient()\n\n    override this.GetWebRequest(address) =\n        let result = base.GetWebRequest(address)\n        result.Timeout <- int timeout \n        result\n\n// The content of a downloaded page \ntype UriContent = \n    UriContent of System.Uri * string\n\n// The content size of a downloaded page \ntype UriContentSize = \n    UriContentSize of System.Uri * int\n    \n/// Get the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContent>>\nlet getUriContent (uri:System.Uri) = \n    async {\n        use client = new WebClientWithTimeout(1000<ms>) // 1 sec timeout\n        try\n            printfn \" [%s] Started ...\" uri.Host\n            let! html = client.AsyncDownloadString(uri) \n            printfn \" [%s] ... finished\" uri.Host\n            let uriContent = UriContent (uri, html)\n            return uriContent |> XResult.succeedWithMsg (Message <| sprintf \" [%s] ... Loaded!\" uri.Host)\n        with\n        | ex -> \n            printfn \" [%s] ... exception\" uri.Host\n            let err = sprintf \"[%s] %A\" uri.Host ex.Message |> Error\n            return XResult.fail err\n    }\n\n/// Make a UriContentSize from a UriContent\n/// UriContent -> Result<UriContentSize>\nlet makeContentSize (UriContent (uri, html)) = \n    if System.String.IsNullOrEmpty(html) then\n        XResult.fail (Error \"empty page\")\n    else\n        let uriContentSize = UriContentSize (uri, html.Length)\n        XResult.succeed uriContentSize \n\n/// Get the size of the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContentSize>>\nlet getUriContentSize uri =\n    getUriContent uri \n    |> Async.map (XResult.bind makeContentSize)\n\n/// Get the largest UriContentSize from a list\n/// UriContentSize list -> UriContentSize\nlet maxContentSize list = \n    let contentSize (UriContentSize (_, len)) = len  // extract the len field from a UriContentSize \n    list |> List.maxBy contentSize                   // use maxBy to find the largest  \n\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.Async.sequenceA\n    |> Async.map List.XResult.sequenceA\n    |> Async.map (XResult.map maxContentSize)\n\nlet largestPageSizeM urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.Async.sequenceM\n    |> Async.map List.XResult.sequenceM\n    |> Async.map (XResult.map maxContentSize)\n\nlet showContentSizeResult result =\n    let messages = result |> XResult.getMessages\n    match result with\n    | XResult.Success (UriContentSize (uri, len), _) -> printfn \"SUCCESS: [%s] Content size is %i \\n%s\" uri.Host len messages\n    | XResult.Failure errs            -> printfn \"FAILURE: %s\" messages\n\nlet run f sites () = \n    f sites\n    |> Async.RunSynchronously\n    |> showContentSizeResult \n    \n[\n    time 1 \"largestPageSizeA_Good\" <| run largestPageSizeA goodSites\n    time 1 \"largestPageSizeA_Bad \" <| run largestPageSizeA badSites\n    time 1 \"largestPageSizeM_Good\" <| run largestPageSizeM goodSites\n    time 1 \"largestPageSizeM_Bad \" <| run largestPageSizeM badSites\n] \n|> String.concat \"\\n\" \n|> printfn \"%s\"\n", "snpParentIdO": {"SnippetId" :"c5930fca-5baf-4b35-9193-18c08fafae39"}, "snpPredIds": [{"SnippetId" :"4ec1bd8a-6593-4b48-92c7-c68f5fe601f8"}], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"c667dd47-3780-4c6b-8e4e-87881d142a33"}, "snpName": "T.Petricek", "snpContent": "", "snpParentIdO": {"SnippetId" :"f3d0eaa1-b96a-41d1-83a2-19a84001e217"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}, {"snpId": {"SnippetId" :"7f16b1da-3e90-4824-a4b5-c0b57365a99e"}, "snpName": "Tree Zipper", "snpContent": "type Tree<'T> = \n  | Node of Tree<'T> * Tree<'T>\n  | Leaf of 'T\n  override x.ToString() = match x with\n                          | Node(l, r) -> sprintf \"(%O, %O)\" l r\n                          | Leaf v     -> sprintf \"%O\" v\n\ntype Path<'T> = \n  | Top \n  | Left  of Path<'T> * Tree<'T>\n  | Right of Path<'T> * Tree<'T>\n  override x.ToString() = match x with\n                          | Left (p, t) -> sprintf \"L(%O, %O)\" p t\n                          | Right(p, t) -> sprintf \"R(%O, %O)\" p t\n                          | Top         -> \"T\"\n\ntype TreeZipper<'T> = \n  | TZ of Tree<'T> * Path<'T>\n  override x.ToString() = match x with TZ(t, p) -> sprintf \"%O [%O]\" t p\n  \n/// Navigates to the left sub-tree\nlet left = function\n  | TZ(Leaf _, _) -> failwith \"cannot go left\"\n  | TZ(Node(l, r), p) -> TZ(l, Left(p, r))\n\n/// Navigates to the right sub-tree\nlet right = function\n  | TZ(Leaf _, _) -> failwith \"cannot go right\"\n  | TZ(Node(l, r), p) -> TZ(r, Right(p, l))\n\n/// Gets the value at the current position\nlet current = function\n  | TZ(Leaf x, _) -> x\n  | _ -> failwith \"cannot get current\"\n\n/// Navigate to the parent node\nlet up = function\n  | TZ(l, Left(p, r))\n  | TZ(r, Right(p, l)) -> TZ(Node(l, r), p)\n  | TZ(_, Top) -> failwith \"cannot go up\"\n\n/// Navigate to the root of the tree\nlet rec top = function\n  | TZ(_, Top) as t -> t\n  | tz -> top (up tz)\n  \n/// Build tree zipper with singleton tree\nlet unit v = TZ(Leaf v, Top)\n\n/// Transform leaves in the current sub-tree of 'treeZip'\n/// into other trees using the provided function 'f'\nlet bindSub f treeZip = \n  let rec bindT = function\n    | Leaf x -> let (TZ(t, _)) = top (f x) in t\n    | Node(l, r) -> Node(bindT l, bindT r)\n  let (TZ(current, path)) = treeZip\n  TZ(bindT current, path)\n  \ntype TreeZipperBuilder() = \n    member x.For(tz:TreeZipper<'T>, f) : TreeZipper<'T>             = bindSub f tz\n    member x.Yield                                               v  = unit v\n    [<CustomOperation(\"left\"   , MaintainsVariableSpace=true )>]\n    member x.Left                                                tz = left tz\n    [<CustomOperation(\"right\"  , MaintainsVariableSpace=true )>]\n    member x.Right                                               tz = right tz\n    [<CustomOperation(\"up\"     , MaintainsVariableSpace=true )>]\n    member x.Up                                                  tz = up tz\n    [<CustomOperation(\"top\"    , MaintainsVariableSpace=true )>]\n    member x.Top                                                 tz = top tz\n    [<CustomOperation(\"current\", MaintainsVariableSpace=false)>]\n    member x.Current                                             tz = current tz\n    [<CustomOperation(\"map\"    , MaintainsVariableSpace=true)>]\n    member x.Select( tz, [<ProjectionParameter>] f)                 = bindSub (f >> unit) tz\n\nlet tree = TreeZipperBuilder()\n\nlet branches = \n  Node( Node(Leaf 1, Leaf 3), \n        Node(Leaf 7, Node(Leaf 12, Leaf 20)) )\n\nlet sample = TZ(branches, Top)\nprintfn \"%O\" sample \n\nsample |> right |> right |> left //|> current\n|> printfn \"%O\"\n\ntree { \n    for x in sample do\n    yield x * 2 \n} |> printfn \"%O\"\n\ntree { \n    for x in sample do\n    right\n    right\n    left\n    current \n} |> printfn \"%O\"\n\ntree {\n    for x in sample do\n    left\n    map (x * 2)\n    top\n    right\n    map (x / 2) \n    top \n} |> printfn \"%O\"\n", "snpParentIdO": {"SnippetId" :"c667dd47-3780-4c6b-8e4e-87881d142a33"}, "snpPredIds": [], "snpProperties": [], "snpGeneration": 3}], "generation": 232, "collapsed": [{"SnippetId" :"0268626d-d502-4981-a917-df659db5c0b6"}, {"SnippetId" :"210013b7-280e-4692-a5b1-0b1512666b10"}, {"SnippetId" :"352915ea-d13c-4c44-bac4-ad1ab58cca61"}, {"SnippetId" :"376fdef6-dfcf-40c5-bd14-97c3b246bb30"}, {"SnippetId" :"39c19121-4cca-4db2-a4d5-99aef7da4163"}, {"SnippetId" :"3e6eb5de-d69e-4fcd-a472-d326d673ae52"}, {"SnippetId" :"3ea9390b-0914-4d7b-af19-afac92964643"}, {"SnippetId" :"46c40fe5-6cf8-45fe-ab13-e9ba182d0bfe"}, {"SnippetId" :"485b02bc-6bd8-4050-88e7-530def75c391"}, {"SnippetId" :"495bce0a-4fb6-48fa-9158-c242d5965baa"}, {"SnippetId" :"4b9d8a3e-9910-4c51-8c34-f29782866424"}, {"SnippetId" :"57a30378-4a52-4122-b297-fe5cec1bd067"}, {"SnippetId" :"5adf83e3-c555-4cd2-ab88-e8af42691daf"}, {"SnippetId" :"60645418-08f5-45ce-a7a0-accafba4b65f"}, {"SnippetId" :"63eca270-405a-4789-941a-e298bbd265bd"}, {"SnippetId" :"64110b26-2d5c-4b29-a81b-75a5495e67a2"}, {"SnippetId" :"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"}, {"SnippetId" :"75e981af-272f-4f04-87a0-f2c6a9fe5fa8"}, {"SnippetId" :"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"}, {"SnippetId" :"83d96c6d-a55e-4975-8d93-06a0fe00f01a"}, {"SnippetId" :"853910d0-fcf7-4517-9f1e-8dd721386d03"}, {"SnippetId" :"86382469-687d-4914-94b9-4067d8c5c7e7"}, {"SnippetId" :"875d3aa7-2adf-4857-9df0-8c7c02ec6169"}, {"SnippetId" :"8d568171-bb31-4bee-a9a6-46514fe8f64e"}, {"SnippetId" :"94342c73-5416-4f11-a667-22e715345d41"}, {"SnippetId" :"980a8a0e-1fd6-45d5-8175-5826cd93bc59"}, {"SnippetId" :"a4f1955e-4ac9-4e56-9991-4f960e601597"}, {"SnippetId" :"a70b4838-75d6-40c3-9a0c-5bd03c57cce5"}, {"SnippetId" :"b6577554-e62e-41ed-983e-d4dd12e3512f"}, {"SnippetId" :"ba90a7d3-7af6-4637-a92f-5d30657d63f2"}, {"SnippetId" :"bc1521b8-a408-454d-9857-de5d145cfd77"}, {"SnippetId" :"be49e291-252c-4064-a3d6-bc61b39895fa"}, {"SnippetId" :"c348e22a-737f-45c5-85ed-5c1a65313dd4"}, {"SnippetId" :"dd763e28-a1e1-4e69-bc18-6241efdf251d"}, {"SnippetId" :"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"}, {"SnippetId" :"e5253dd2-c887-4822-887b-ab249aeae88a"}, {"SnippetId" :"e83d0347-89ba-4fbf-8bd0-02723299e948"}, {"SnippetId" :"e9ac2d66-474a-46a6-95fa-d369e6d703d1"}, {"SnippetId" :"ebc10936-8796-43e0-b809-8f6b539b31a2"}, {"SnippetId" :"edbbf11e-4698-4e33-af0c-135d5b21799b"}, {"SnippetId" :"eea64fd5-1e84-496b-b012-c9a21e875d08"}, {"SnippetId" :"f3c40a7d-724c-47fb-88fd-a38b9680b7cb"}, {"SnippetId" :"f66ab559-6876-4799-94fb-4a86a783054a"}]}